import {
  init_vue_runtime_esm_bundler,
  vue_runtime_esm_bundler_exports
} from "./chunk-UO6EIPBV.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-MZRSZR5A.js";

// node_modules/.pnpm/v3-ol-map@0.0.30/node_modules/v3-ol-map/lib/v3-ol-map.umd.js
var require_v3_ol_map_umd = __commonJS({
  "node_modules/.pnpm/v3-ol-map@0.0.30/node_modules/v3-ol-map/lib/v3-ol-map.umd.js"(exports, module) {
    (function(wt, N) {
      typeof exports == "object" && typeof module != "undefined" ? N(exports, (init_vue_runtime_esm_bundler(), __toCommonJS(vue_runtime_esm_bundler_exports))) : typeof define == "function" && define.amd ? define(["exports", "vue"], N) : (wt = typeof globalThis != "undefined" ? globalThis : wt || self, N(wt["v3-ol-map"] = {}, wt.Vue));
    })(exports, function(wt, N) {
      "use strict";
      var tzt = Object.defineProperty, ezt = Object.defineProperties;
      var nzt = Object.getOwnPropertyDescriptors;
      var GE = Object.getOwnPropertySymbols;
      var YX = Object.prototype.hasOwnProperty, WX = Object.prototype.propertyIsEnumerable;
      var _i = Math.pow, xL = (wt2, N10, Se2) => N10 in wt2 ? tzt(wt2, N10, { enumerable: true, configurable: true, writable: true, value: Se2 }) : wt2[N10] = Se2, st = (wt2, N10) => {
        for (var Se2 in N10 || (N10 = {})) YX.call(N10, Se2) && xL(wt2, Se2, N10[Se2]);
        if (GE) for (var Se2 of GE(N10)) WX.call(N10, Se2) && xL(wt2, Se2, N10[Se2]);
        return wt2;
      }, zt = (wt2, N10) => ezt(wt2, nzt(N10));
      var Ny = (wt2, N10) => {
        var Se2 = {};
        for (var Un2 in wt2) YX.call(wt2, Un2) && N10.indexOf(Un2) < 0 && (Se2[Un2] = wt2[Un2]);
        if (wt2 != null && GE) for (var Un2 of GE(wt2)) N10.indexOf(Un2) < 0 && WX.call(wt2, Un2) && (Se2[Un2] = wt2[Un2]);
        return Se2;
      };
      var Kt = (wt2, N10, Se2) => xL(wt2, typeof N10 != "symbol" ? N10 + "" : N10, Se2);
      var Rt = (wt2, N10, Se2) => new Promise((Un2, nl2) => {
        var UE2 = (Hr2) => {
          try {
            Pd2(Se2.next(Hr2));
          } catch (Nd2) {
            nl2(Nd2);
          }
        }, Ma2 = (Hr2) => {
          try {
            Pd2(Se2.throw(Hr2));
          } catch (Nd2) {
            nl2(Nd2);
          }
        }, Pd2 = (Hr2) => Hr2.done ? Un2(Hr2.value) : Promise.resolve(Hr2.value).then(UE2, Ma2);
        Pd2((Se2 = Se2.apply(wt2, N10)).next());
      });
      class Se {
        constructor(t) {
          this.propagationStopped, this.defaultPrevented, this.type = t, this.target = null;
        }
        preventDefault() {
          this.defaultPrevented = true;
        }
        stopPropagation() {
          this.propagationStopped = true;
        }
      }
      const Un = { PROPERTYCHANGE: "propertychange" };
      class nl {
        constructor() {
          this.disposed = false;
        }
        dispose() {
          this.disposed || (this.disposed = true, this.disposeInternal());
        }
        disposeInternal() {
        }
      }
      function UE(n, t, e) {
        let i, r;
        e = e || Ma;
        let a = 0, o = n.length, s = false;
        for (; a < o; ) i = a + (o - a >> 1), r = +e(n[i], t), r < 0 ? a = i + 1 : (o = i, s = !r);
        return s ? a : ~a;
      }
      function Ma(n, t) {
        return n > t ? 1 : n < t ? -1 : 0;
      }
      function Pd(n, t) {
        return n < t ? 1 : n > t ? -1 : 0;
      }
      function Hr(n, t, e) {
        if (n[0] <= t) return 0;
        const i = n.length;
        if (t <= n[i - 1]) return i - 1;
        if (typeof e == "function") {
          for (let r = 1; r < i; ++r) {
            const a = n[r];
            if (a === t) return r;
            if (a < t) return e(t, n[r - 1], a) > 0 ? r - 1 : r;
          }
          return i - 1;
        }
        if (e > 0) {
          for (let r = 1; r < i; ++r) if (n[r] < t) return r - 1;
          return i - 1;
        }
        if (e < 0) {
          for (let r = 1; r < i; ++r) if (n[r] <= t) return r;
          return i - 1;
        }
        for (let r = 1; r < i; ++r) {
          if (n[r] == t) return r;
          if (n[r] < t) return n[r - 1] - t < t - n[r] ? r - 1 : r;
        }
        return i - 1;
      }
      function Nd(n, t, e) {
        for (; t < e; ) {
          const i = n[t];
          n[t] = n[e], n[e] = i, ++t, --e;
        }
      }
      function De(n, t) {
        const e = Array.isArray(t) ? t : [t], i = e.length;
        for (let r = 0; r < i; r++) n[n.length] = e[r];
      }
      function no(n, t) {
        const e = n.length;
        if (e !== t.length) return false;
        for (let i = 0; i < e; i++) if (n[i] !== t[i]) return false;
        return true;
      }
      function KX(n, t, e) {
        const i = t || Ma;
        return n.every(function(r, a) {
          if (a === 0) return true;
          const o = i(n[a - 1], r);
          return !(o > 0 || o === 0);
        });
      }
      function Cu() {
        return true;
      }
      function Su() {
        return false;
      }
      function Tc() {
      }
      function CL(n) {
        let t, e, i;
        return function() {
          const r = Array.prototype.slice.call(arguments);
          return (!e || this !== i || !no(r, e)) && (i = this, e = r, t = n.apply(this, arguments)), t;
        };
      }
      function VE(n) {
        function t() {
          let e;
          try {
            e = n();
          } catch (i) {
            return Promise.reject(i);
          }
          return e instanceof Promise ? e : Promise.resolve(e);
        }
        return t();
      }
      function Mc(n) {
        for (const t in n) delete n[t];
      }
      function il(n) {
        let t;
        for (t in n) return false;
        return !t;
      }
      class Dc extends nl {
        constructor(t) {
          super(), this.eventTarget_ = t, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
        }
        addEventListener(t, e) {
          if (!t || !e) return;
          const i = this.listeners_ || (this.listeners_ = {}), r = i[t] || (i[t] = []);
          r.includes(e) || r.push(e);
        }
        dispatchEvent(t) {
          const e = typeof t == "string", i = e ? t : t.type, r = this.listeners_ && this.listeners_[i];
          if (!r) return;
          const a = e ? new Se(t) : t;
          a.target || (a.target = this.eventTarget_ || this);
          const o = this.dispatching_ || (this.dispatching_ = {}), s = this.pendingRemovals_ || (this.pendingRemovals_ = {});
          i in o || (o[i] = 0, s[i] = 0), ++o[i];
          let l;
          for (let u = 0, h = r.length; u < h; ++u) if ("handleEvent" in r[u] ? l = r[u].handleEvent(a) : l = r[u].call(this, a), l === false || a.propagationStopped) {
            l = false;
            break;
          }
          if (--o[i] === 0) {
            let u = s[i];
            for (delete s[i]; u--; ) this.removeEventListener(i, Tc);
            delete o[i];
          }
          return l;
        }
        disposeInternal() {
          this.listeners_ && Mc(this.listeners_);
        }
        getListeners(t) {
          return this.listeners_ && this.listeners_[t] || void 0;
        }
        hasListener(t) {
          return this.listeners_ ? t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0 : false;
        }
        removeEventListener(t, e) {
          if (!this.listeners_) return;
          const i = this.listeners_[t];
          if (!i) return;
          const r = i.indexOf(e);
          r !== -1 && (this.pendingRemovals_ && t in this.pendingRemovals_ ? (i[r] = Tc, ++this.pendingRemovals_[t]) : (i.splice(r, 1), i.length === 0 && delete this.listeners_[t]));
        }
      }
      const Nt = { CHANGE: "change", ERROR: "error", BLUR: "blur", CLEAR: "clear", CONTEXTMENU: "contextmenu", CLICK: "click", DBLCLICK: "dblclick", DRAGENTER: "dragenter", DRAGOVER: "dragover", DROP: "drop", FOCUS: "focus", KEYDOWN: "keydown", KEYPRESS: "keypress", LOAD: "load", RESIZE: "resize", TOUCHMOVE: "touchmove", WHEEL: "wheel" };
      function ie(n, t, e, i, r) {
        if (r) {
          const o = e;
          e = function() {
            n.removeEventListener(t, e), o.apply(i != null ? i : this, arguments);
          };
        } else i && i !== n && (e = e.bind(i));
        const a = { target: n, type: t, listener: e };
        return n.addEventListener(t, e), a;
      }
      function kd(n, t, e, i) {
        return ie(n, t, e, i, true);
      }
      function Pe(n) {
        n && n.target && (n.target.removeEventListener(n.type, n.listener), Mc(n));
      }
      class Fd extends Dc {
        constructor() {
          super(), this.on = this.onInternal, this.once = this.onceInternal, this.un = this.unInternal, this.revision_ = 0;
        }
        changed() {
          ++this.revision_, this.dispatchEvent(Nt.CHANGE);
        }
        getRevision() {
          return this.revision_;
        }
        onInternal(t, e) {
          if (Array.isArray(t)) {
            const i = t.length, r = new Array(i);
            for (let a = 0; a < i; ++a) r[a] = ie(this, t[a], e);
            return r;
          }
          return ie(this, t, e);
        }
        onceInternal(t, e) {
          let i;
          if (Array.isArray(t)) {
            const r = t.length;
            i = new Array(r);
            for (let a = 0; a < r; ++a) i[a] = kd(this, t[a], e);
          } else i = kd(this, t, e);
          return e.ol_key = i, i;
        }
        unInternal(t, e) {
          const i = e.ol_key;
          if (i) rl(i);
          else if (Array.isArray(t)) for (let r = 0, a = t.length; r < a; ++r) this.removeEventListener(t[r], e);
          else this.removeEventListener(t, e);
        }
      }
      Fd.prototype.on, Fd.prototype.once, Fd.prototype.un;
      function rl(n) {
        if (Array.isArray(n)) for (let t = 0, e = n.length; t < e; ++t) Pe(n[t]);
        else Pe(n);
      }
      function Qt() {
        throw new Error("Unimplemented abstract method.");
      }
      let $X = 0;
      function Ft(n) {
        return n.ol_uid || (n.ol_uid = String(++$X));
      }
      const JX = "10.2.1";
      class SL extends Se {
        constructor(t, e, i) {
          super(t), this.key = e, this.oldValue = i;
        }
      }
      class Yr extends Fd {
        constructor(t) {
          super(), this.on, this.once, this.un, Ft(this), this.values_ = null, t !== void 0 && this.setProperties(t);
        }
        get(t) {
          let e;
          return this.values_ && this.values_.hasOwnProperty(t) && (e = this.values_[t]), e;
        }
        getKeys() {
          return this.values_ && Object.keys(this.values_) || [];
        }
        getProperties() {
          return this.values_ && Object.assign({}, this.values_) || {};
        }
        getPropertiesInternal() {
          return this.values_;
        }
        hasProperties() {
          return !!this.values_;
        }
        notify(t, e) {
          let i;
          i = `change:${t}`, this.hasListener(i) && this.dispatchEvent(new SL(i, t, e)), i = Un.PROPERTYCHANGE, this.hasListener(i) && this.dispatchEvent(new SL(i, t, e));
        }
        addChangeListener(t, e) {
          this.addEventListener(`change:${t}`, e);
        }
        removeChangeListener(t, e) {
          this.removeEventListener(`change:${t}`, e);
        }
        set(t, e, i) {
          const r = this.values_ || (this.values_ = {});
          if (i) r[t] = e;
          else {
            const a = r[t];
            r[t] = e, a !== e && this.notify(t, a);
          }
        }
        setProperties(t, e) {
          for (const i in t) this.set(i, t[i], e);
        }
        applyProperties(t) {
          t.values_ && Object.assign(this.values_ || (this.values_ = {}), t.values_);
        }
        unset(t, e) {
          if (this.values_ && t in this.values_) {
            const i = this.values_[t];
            delete this.values_[t], il(this.values_) && (this.values_ = null), e || this.notify(t, i);
          }
        }
      }
      const Jn = { ADD: "add", REMOVE: "remove" }, bL = { LENGTH: "length" };
      class ky extends Se {
        constructor(t, e, i) {
          super(t), this.element = e, this.index = i;
        }
      }
      class ir extends Yr {
        constructor(t, e) {
          if (super(), this.on, this.once, this.un, e = e || {}, this.unique_ = !!e.unique, this.array_ = t || [], this.unique_) for (let i = 0, r = this.array_.length; i < r; ++i) this.assertUnique_(this.array_[i], i);
          this.updateLength_();
        }
        clear() {
          for (; this.getLength() > 0; ) this.pop();
        }
        extend(t) {
          for (let e = 0, i = t.length; e < i; ++e) this.push(t[e]);
          return this;
        }
        forEach(t) {
          const e = this.array_;
          for (let i = 0, r = e.length; i < r; ++i) t(e[i], i, e);
        }
        getArray() {
          return this.array_;
        }
        item(t) {
          return this.array_[t];
        }
        getLength() {
          return this.get(bL.LENGTH);
        }
        insertAt(t, e) {
          if (t < 0 || t > this.getLength()) throw new Error("Index out of bounds: " + t);
          this.unique_ && this.assertUnique_(e), this.array_.splice(t, 0, e), this.updateLength_(), this.dispatchEvent(new ky(Jn.ADD, e, t));
        }
        pop() {
          return this.removeAt(this.getLength() - 1);
        }
        push(t) {
          this.unique_ && this.assertUnique_(t);
          const e = this.getLength();
          return this.insertAt(e, t), this.getLength();
        }
        remove(t) {
          const e = this.array_;
          for (let i = 0, r = e.length; i < r; ++i) if (e[i] === t) return this.removeAt(i);
        }
        removeAt(t) {
          if (t < 0 || t >= this.getLength()) return;
          const e = this.array_[t];
          return this.array_.splice(t, 1), this.updateLength_(), this.dispatchEvent(new ky(Jn.REMOVE, e, t)), e;
        }
        setAt(t, e) {
          const i = this.getLength();
          if (t >= i) {
            this.insertAt(t, e);
            return;
          }
          if (t < 0) throw new Error("Index out of bounds: " + t);
          this.unique_ && this.assertUnique_(e, t);
          const r = this.array_[t];
          this.array_[t] = e, this.dispatchEvent(new ky(Jn.REMOVE, r, t)), this.dispatchEvent(new ky(Jn.ADD, e, t));
        }
        updateLength_() {
          this.set(bL.LENGTH, this.array_.length);
        }
        assertUnique_(t, e) {
          for (let i = 0, r = this.array_.length; i < r; ++i) if (this.array_[i] === t && i !== e) throw new Error("Duplicate item added to a unique collection");
        }
      }
      function he(n, t) {
        if (!n) throw new Error(t);
      }
      class xe extends Yr {
        constructor(t) {
          if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), t) if (typeof t.getSimplifiedGeometry == "function") {
            const e = t;
            this.setGeometry(e);
          } else {
            const e = t;
            this.setProperties(e);
          }
        }
        clone() {
          const t = new xe(this.hasProperties() ? this.getProperties() : null);
          t.setGeometryName(this.getGeometryName());
          const e = this.getGeometry();
          e && t.setGeometry(e.clone());
          const i = this.getStyle();
          return i && t.setStyle(i), t;
        }
        getGeometry() {
          return this.get(this.geometryName_);
        }
        getId() {
          return this.id_;
        }
        getGeometryName() {
          return this.geometryName_;
        }
        getStyle() {
          return this.style_;
        }
        getStyleFunction() {
          return this.styleFunction_;
        }
        handleGeometryChange_() {
          this.changed();
        }
        handleGeometryChanged_() {
          this.geometryChangeKey_ && (Pe(this.geometryChangeKey_), this.geometryChangeKey_ = null);
          const t = this.getGeometry();
          t && (this.geometryChangeKey_ = ie(t, Nt.CHANGE, this.handleGeometryChange_, this)), this.changed();
        }
        setGeometry(t) {
          this.set(this.geometryName_, t);
        }
        setStyle(t) {
          this.style_ = t, this.styleFunction_ = t ? BL(t) : void 0, this.changed();
        }
        setId(t) {
          this.id_ = t, this.changed();
        }
        setGeometryName(t) {
          this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = t, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
        }
      }
      function BL(n) {
        if (typeof n == "function") return n;
        let t;
        return Array.isArray(n) ? t = n : (he(typeof n.getZIndex == "function", "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"), t = [n]), function() {
          return t;
        };
      }
      const jE = new Array(6);
      function wn() {
        return [1, 0, 0, 1, 0, 0];
      }
      function tZ(n) {
        return Qy(n, 1, 0, 0, 1, 0, 0);
      }
      function Fy(n, t) {
        const e = n[0], i = n[1], r = n[2], a = n[3], o = n[4], s = n[5], l = t[0], u = t[1], h = t[2], c = t[3], f = t[4], g = t[5];
        return n[0] = e * l + r * u, n[1] = i * l + a * u, n[2] = e * h + r * c, n[3] = i * h + a * c, n[4] = e * f + r * g + o, n[5] = i * f + a * g + s, n;
      }
      function Qy(n, t, e, i, r, a, o) {
        return n[0] = t, n[1] = e, n[2] = i, n[3] = r, n[4] = a, n[5] = o, n;
      }
      function eZ(n, t) {
        return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n;
      }
      function gn(n, t) {
        const e = t[0], i = t[1];
        return t[0] = n[0] * e + n[2] * i + n[4], t[1] = n[1] * e + n[3] * i + n[5], t;
      }
      function nZ(n, t) {
        const e = Math.cos(t), i = Math.sin(t);
        return Fy(n, Qy(jE, e, i, -i, e, 0, 0));
      }
      function TL(n, t, e) {
        return Fy(n, Qy(jE, t, 0, 0, e, 0, 0));
      }
      function ML(n, t, e) {
        return Fy(n, Qy(jE, 1, 0, 0, 1, t, e));
      }
      function Sr(n, t, e, i, r, a, o, s) {
        const l = Math.sin(a), u = Math.cos(a);
        return n[0] = i * u, n[1] = r * l, n[2] = -i * l, n[3] = r * u, n[4] = o * i * u - s * i * l + t, n[5] = o * r * l + s * r * u + e, n;
      }
      function Oy(n, t) {
        const e = iZ(t);
        he(e !== 0, "Transformation matrix cannot be inverted");
        const i = t[0], r = t[1], a = t[2], o = t[3], s = t[4], l = t[5];
        return n[0] = o / e, n[1] = -r / e, n[2] = -a / e, n[3] = i / e, n[4] = (a * l - o * s) / e, n[5] = -(i * l - r * s) / e, n;
      }
      function iZ(n) {
        return n[0] * n[3] - n[1] * n[2];
      }
      const DL = [1e6, 1e6, 1e6, 1e6, 2, 2];
      function RL(n) {
        return "matrix(" + n.map((e, i) => Math.round(e * DL[i]) / DL[i]).join(", ") + ")";
      }
      const ti = { UNKNOWN: 0, INTERSECTING: 1, ABOVE: 2, RIGHT: 4, BELOW: 8, LEFT: 16 };
      function Vn(n) {
        const t = Ii();
        for (let e = 0, i = n.length; e < i; ++e) Qd(t, n[e]);
        return t;
      }
      function rZ(n, t, e) {
        const i = Math.min.apply(null, n), r = Math.min.apply(null, t), a = Math.max.apply(null, n), o = Math.max.apply(null, t);
        return Xr(i, r, a, o, e);
      }
      function es(n, t, e) {
        return e ? (e[0] = n[0] - t, e[1] = n[1] - t, e[2] = n[2] + t, e[3] = n[3] + t, e) : [n[0] - t, n[1] - t, n[2] + t, n[3] + t];
      }
      function LL(n, t) {
        return t ? (t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t) : n.slice();
      }
      function bu(n, t, e) {
        let i, r;
        return t < n[0] ? i = n[0] - t : n[2] < t ? i = t - n[2] : i = 0, e < n[1] ? r = n[1] - e : n[3] < e ? r = e - n[3] : r = 0, i * i + r * r;
      }
      function Wr(n, t) {
        return qE(n, t[0], t[1]);
      }
      function br(n, t) {
        return n[0] <= t[0] && t[2] <= n[2] && n[1] <= t[1] && t[3] <= n[3];
      }
      function qE(n, t, e) {
        return n[0] <= t && t <= n[2] && n[1] <= e && e <= n[3];
      }
      function HE(n, t) {
        const e = n[0], i = n[1], r = n[2], a = n[3], o = t[0], s = t[1];
        let l = ti.UNKNOWN;
        return o < e ? l = l | ti.LEFT : o > r && (l = l | ti.RIGHT), s < i ? l = l | ti.BELOW : s > a && (l = l | ti.ABOVE), l === ti.UNKNOWN && (l = ti.INTERSECTING), l;
      }
      function Ii() {
        return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      }
      function Xr(n, t, e, i, r) {
        return r ? (r[0] = n, r[1] = t, r[2] = e, r[3] = i, r) : [n, t, e, i];
      }
      function Rc(n) {
        return Xr(1 / 0, 1 / 0, -1 / 0, -1 / 0, n);
      }
      function Lc(n, t) {
        const e = n[0], i = n[1];
        return Xr(e, i, e, i, t);
      }
      function YE(n, t, e, i, r) {
        const a = Rc(r);
        return NL(a, n, t, e, i);
      }
      function al(n, t) {
        return n[0] == t[0] && n[2] == t[2] && n[1] == t[1] && n[3] == t[3];
      }
      function PL(n, t) {
        return t[0] < n[0] && (n[0] = t[0]), t[2] > n[2] && (n[2] = t[2]), t[1] < n[1] && (n[1] = t[1]), t[3] > n[3] && (n[3] = t[3]), n;
      }
      function Qd(n, t) {
        t[0] < n[0] && (n[0] = t[0]), t[0] > n[2] && (n[2] = t[0]), t[1] < n[1] && (n[1] = t[1]), t[1] > n[3] && (n[3] = t[1]);
      }
      function NL(n, t, e, i, r) {
        for (; e < i; e += r) aZ(n, t[e], t[e + 1]);
        return n;
      }
      function aZ(n, t, e) {
        n[0] = Math.min(n[0], t), n[1] = Math.min(n[1], e), n[2] = Math.max(n[2], t), n[3] = Math.max(n[3], e);
      }
      function WE(n, t) {
        let e;
        return e = t(Pc(n)), e || (e = t(Nc(n)), e) || (e = t(ol(n)), e) || (e = t(Zr(n)), e) ? e : false;
      }
      function Od(n) {
        let t = 0;
        return ns(n) || (t = ve(n) * Cn(n)), t;
      }
      function Pc(n) {
        return [n[0], n[1]];
      }
      function Nc(n) {
        return [n[2], n[1]];
      }
      function Br(n) {
        return [(n[0] + n[2]) / 2, (n[1] + n[3]) / 2];
      }
      function oZ(n, t) {
        let e;
        if (t === "bottom-left") e = Pc(n);
        else if (t === "bottom-right") e = Nc(n);
        else if (t === "top-left") e = Zr(n);
        else if (t === "top-right") e = ol(n);
        else throw new Error("Invalid corner");
        return e;
      }
      function zd(n, t, e, i, r) {
        const [a, o, s, l, u, h, c, f] = sZ(n, t, e, i);
        return Xr(Math.min(a, s, u, c), Math.min(o, l, h, f), Math.max(a, s, u, c), Math.max(o, l, h, f), r);
      }
      function sZ(n, t, e, i) {
        const r = t * i[0] / 2, a = t * i[1] / 2, o = Math.cos(e), s = Math.sin(e), l = r * o, u = r * s, h = a * o, c = a * s, f = n[0], g = n[1];
        return [f - l + c, g - u - h, f - l - c, g - u + h, f + l - c, g + u + h, f + l + c, g + u - h, f - l + c, g - u - h];
      }
      function Cn(n) {
        return n[3] - n[1];
      }
      function ei(n, t, e) {
        const i = e || Ii();
        return hi(n, t) ? (n[0] > t[0] ? i[0] = n[0] : i[0] = t[0], n[1] > t[1] ? i[1] = n[1] : i[1] = t[1], n[2] < t[2] ? i[2] = n[2] : i[2] = t[2], n[3] < t[3] ? i[3] = n[3] : i[3] = t[3]) : Rc(i), i;
      }
      function Zr(n) {
        return [n[0], n[3]];
      }
      function ol(n) {
        return [n[2], n[3]];
      }
      function ve(n) {
        return n[2] - n[0];
      }
      function hi(n, t) {
        return n[0] <= t[2] && n[2] >= t[0] && n[1] <= t[3] && n[3] >= t[1];
      }
      function ns(n) {
        return n[2] < n[0] || n[3] < n[1];
      }
      function lZ(n, t) {
        return t ? (t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t) : n;
      }
      function uZ(n, t) {
        const e = (n[2] - n[0]) / 2 * (t - 1), i = (n[3] - n[1]) / 2 * (t - 1);
        n[0] -= e, n[2] += e, n[1] -= i, n[3] += i;
      }
      function hZ(n, t, e) {
        let i = false;
        const r = HE(n, t), a = HE(n, e);
        if (r === ti.INTERSECTING || a === ti.INTERSECTING) i = true;
        else {
          const o = n[0], s = n[1], l = n[2], u = n[3], h = t[0], c = t[1], f = e[0], g = e[1], d = (g - c) / (f - h);
          let A, p;
          a & ti.ABOVE && !(r & ti.ABOVE) && (A = f - (g - u) / d, i = A >= o && A <= l), !i && a & ti.RIGHT && !(r & ti.RIGHT) && (p = g - (f - l) * d, i = p >= s && p <= u), !i && a & ti.BELOW && !(r & ti.BELOW) && (A = f - (g - s) / d, i = A >= o && A <= l), !i && a & ti.LEFT && !(r & ti.LEFT) && (p = g - (f - o) * d, i = p >= s && p <= u);
        }
        return i;
      }
      function cZ(n, t, e, i) {
        if (ns(n)) return Rc(e);
        let r = [];
        r = [n[0], n[1], n[2], n[1], n[2], n[3], n[0], n[3]], t(r, r, 2);
        const a = [], o = [];
        for (let s = 0, l = r.length; s < l; s += 2) a.push(r[s]), o.push(r[s + 1]);
        return rZ(a, o, e);
      }
      function kL(n, t) {
        const e = t.getExtent(), i = Br(n);
        if (t.canWrapX() && (i[0] < e[0] || i[0] >= e[2])) {
          const r = ve(e), o = Math.floor((i[0] - e[0]) / r) * r;
          n[0] -= o, n[2] -= o;
        }
        return n;
      }
      function XE(n, t, e) {
        if (t.canWrapX()) {
          const i = t.getExtent();
          if (!isFinite(n[0]) || !isFinite(n[2])) return [[i[0], n[1], i[2], n[3]]];
          kL(n, t);
          const r = ve(i);
          if (ve(n) > r && !e) return [[i[0], n[1], i[2], n[3]]];
          if (n[0] < i[0]) return [[n[0] + r, n[1], i[2], n[3]], [i[0], n[1], n[2], n[3]]];
          if (n[2] > i[2]) return [[n[0], n[1], i[2], n[3]], [i[0], n[1], n[2] - r, n[3]]];
        }
        return [n];
      }
      const fZ = { 9001: "m", 9002: "ft", 9003: "us-ft", 9101: "radians", 9102: "degrees" };
      function FL(n) {
        return fZ[n];
      }
      const ZE = { radians: 6370997 / (2 * Math.PI), degrees: 2 * Math.PI * 6370997 / 360, ft: 0.3048, m: 1, "us-ft": 1200 / 3937 };
      let rr = class {
        constructor(t) {
          this.code_ = t.code, this.units_ = t.units, this.extent_ = t.extent !== void 0 ? t.extent : null, this.worldExtent_ = t.worldExtent !== void 0 ? t.worldExtent : null, this.axisOrientation_ = t.axisOrientation !== void 0 ? t.axisOrientation : "enu", this.global_ = t.global !== void 0 ? t.global : false, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = t.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = t.metersPerUnit;
        }
        canWrapX() {
          return this.canWrapX_;
        }
        getCode() {
          return this.code_;
        }
        getExtent() {
          return this.extent_;
        }
        getUnits() {
          return this.units_;
        }
        getMetersPerUnit() {
          return this.metersPerUnit_ || ZE[this.units_];
        }
        getWorldExtent() {
          return this.worldExtent_;
        }
        getAxisOrientation() {
          return this.axisOrientation_;
        }
        isGlobal() {
          return this.global_;
        }
        setGlobal(t) {
          this.global_ = t, this.canWrapX_ = !!(t && this.extent_);
        }
        getDefaultTileGrid() {
          return this.defaultTileGrid_;
        }
        setDefaultTileGrid(t) {
          this.defaultTileGrid_ = t;
        }
        setExtent(t) {
          this.extent_ = t, this.canWrapX_ = !!(this.global_ && t);
        }
        setWorldExtent(t) {
          this.worldExtent_ = t;
        }
        setGetPointResolution(t) {
          this.getPointResolutionFunc_ = t;
        }
        getPointResolutionFunc() {
          return this.getPointResolutionFunc_;
        }
      };
      const Gd = 6378137, kc = Math.PI * Gd, gZ = [-kc, -kc, kc, kc], dZ = [-180, -85, 180, 85], zy = Gd * Math.log(Math.tan(Math.PI / 2));
      class Fc extends rr {
        constructor(t) {
          super({ code: t, units: "m", extent: gZ, global: true, worldExtent: dZ, getPointResolution: function(e, i) {
            return e / Math.cosh(i[1] / Gd);
          } });
        }
      }
      const Gy = [new Fc("EPSG:3857"), new Fc("EPSG:102100"), new Fc("EPSG:102113"), new Fc("EPSG:900913"), new Fc("http://www.opengis.net/def/crs/EPSG/0/3857"), new Fc("http://www.opengis.net/gml/srs/epsg.xml#3857")];
      function AZ(n, t, e, i) {
        const r = n.length;
        e = e > 1 ? e : 2, i = i != null ? i : e, t === void 0 && (e > 2 ? t = n.slice() : t = new Array(r));
        for (let a = 0; a < r; a += i) {
          t[a] = kc * n[a] / 180;
          let o = Gd * Math.log(Math.tan(Math.PI * (+n[a + 1] + 90) / 360));
          o > zy ? o = zy : o < -zy && (o = -zy), t[a + 1] = o;
        }
        return t;
      }
      function pZ(n, t, e, i) {
        const r = n.length;
        e = e > 1 ? e : 2, i = i != null ? i : e, t === void 0 && (e > 2 ? t = n.slice() : t = new Array(r));
        for (let a = 0; a < r; a += i) t[a] = 180 * n[a] / kc, t[a + 1] = 360 * Math.atan(Math.exp(n[a + 1] / Gd)) / Math.PI - 90;
        return t;
      }
      const vZ = 6378137, QL = [-180, -90, 180, 90], yZ = Math.PI * vZ / 180;
      class Bu extends rr {
        constructor(t, e) {
          super({ code: t, units: "degrees", extent: QL, axisOrientation: e, global: true, metersPerUnit: yZ, worldExtent: QL });
        }
      }
      const Uy = [new Bu("CRS:84"), new Bu("EPSG:4326", "neu"), new Bu("urn:ogc:def:crs:OGC:1.3:CRS84"), new Bu("urn:ogc:def:crs:OGC:2:84"), new Bu("http://www.opengis.net/def/crs/OGC/1.3/CRS84"), new Bu("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"), new Bu("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")];
      let KE = {};
      function mZ(n) {
        return KE[n] || KE[n.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
      }
      function _Z(n, t) {
        KE[n] = t;
      }
      let Qc = {};
      function Oc(n, t, e) {
        const i = n.getCode(), r = t.getCode();
        i in Qc || (Qc[i] = {}), Qc[i][r] = e;
      }
      function OL(n, t) {
        let e;
        return n in Qc && t in Qc[n] && (e = Qc[n][t]), e;
      }
      function en(n, t, e) {
        return Math.min(Math.max(n, t), e);
      }
      function IZ(n, t, e, i, r, a) {
        const o = r - e, s = a - i;
        if (o !== 0 || s !== 0) {
          const l = ((n - e) * o + (t - i) * s) / (o * o + s * s);
          l > 1 ? (e = r, i = a) : l > 0 && (e += o * l, i += s * l);
        }
        return is(n, t, e, i);
      }
      function is(n, t, e, i) {
        const r = e - n, a = i - t;
        return r * r + a * a;
      }
      function EZ(n) {
        const t = n.length;
        for (let i = 0; i < t; i++) {
          let r = i, a = Math.abs(n[i][i]);
          for (let s = i + 1; s < t; s++) {
            const l = Math.abs(n[s][i]);
            l > a && (a = l, r = s);
          }
          if (a === 0) return null;
          const o = n[r];
          n[r] = n[i], n[i] = o;
          for (let s = i + 1; s < t; s++) {
            const l = -n[s][i] / n[i][i];
            for (let u = i; u < t + 1; u++) i == u ? n[s][u] = 0 : n[s][u] += l * n[i][u];
          }
        }
        const e = new Array(t);
        for (let i = t - 1; i >= 0; i--) {
          e[i] = n[i][t] / n[i][i];
          for (let r = i - 1; r >= 0; r--) n[r][t] -= n[r][i] * e[i];
        }
        return e;
      }
      function sl(n) {
        return n * Math.PI / 180;
      }
      function rs(n, t) {
        const e = n % t;
        return e * t < 0 ? e + t : e;
      }
      function Tr(n, t, e) {
        return n + e * (t - n);
      }
      function Ud(n, t) {
        const e = Math.pow(10, t);
        return Math.round(n * e) / e;
      }
      function zL(n, t) {
        return Math.round(Ud(n, t));
      }
      function zc(n, t) {
        return Math.floor(Ud(n, t));
      }
      function ll(n, t) {
        return Math.ceil(Ud(n, t));
      }
      function Vd(n, t, e) {
        const i = e !== void 0 ? n.toFixed(e) : "" + n;
        let r = i.indexOf(".");
        return r = r === -1 ? i.length : r, r > t ? i : new Array(1 + t - r).join("0") + i;
      }
      function Vy(n, t) {
        const e = ("" + n).split("."), i = ("" + t).split(".");
        for (let r = 0; r < Math.max(e.length, i.length); r++) {
          const a = parseInt(e[r] || "0", 10), o = parseInt(i[r] || "0", 10);
          if (a > o) return 1;
          if (o > a) return -1;
        }
        return 0;
      }
      function GL(n, t) {
        return n[0] += +t[0], n[1] += +t[1], n;
      }
      function xZ(n, t) {
        const e = t.getRadius(), i = t.getCenter(), r = i[0], a = i[1], o = n[0], s = n[1];
        let l = o - r;
        const u = s - a;
        l === 0 && u === 0 && (l = 1);
        const h = Math.sqrt(l * l + u * u), c = r + e * l / h, f = a + e * u / h;
        return [c, f];
      }
      function $E(n, t) {
        const e = n[0], i = n[1], r = t[0], a = t[1], o = r[0], s = r[1], l = a[0], u = a[1], h = l - o, c = u - s, f = h === 0 && c === 0 ? 0 : (h * (e - o) + c * (i - s)) / (h * h + c * c || 0);
        let g, d;
        return f <= 0 ? (g = o, d = s) : f >= 1 ? (g = l, d = u) : (g = o + f * h, d = s + f * c), [g, d];
      }
      function Da(n, t) {
        let e = true;
        for (let i = n.length - 1; i >= 0; --i) if (n[i] != t[i]) {
          e = false;
          break;
        }
        return e;
      }
      function JE(n, t) {
        const e = Math.cos(t), i = Math.sin(t), r = n[0] * e - n[1] * i, a = n[1] * e + n[0] * i;
        return n[0] = r, n[1] = a, n;
      }
      function UL(n, t) {
        return n[0] *= t, n[1] *= t, n;
      }
      function io(n, t) {
        const e = n[0] - t[0], i = n[1] - t[1];
        return e * e + i * i;
      }
      function jy(n, t) {
        return Math.sqrt(io(n, t));
      }
      function wZ(n, t) {
        return io(n, $E(n, t));
      }
      function VL(n, t) {
        if (t.canWrapX()) {
          const e = ve(t.getExtent()), i = jL(n, t, e);
          i && (n[0] -= i * e);
        }
        return n;
      }
      function jL(n, t, e) {
        const i = t.getExtent();
        let r = 0;
        return t.canWrapX() && (n[0] < i[0] || n[0] > i[2]) && (e = e || ve(i), r = Math.floor((n[0] - i[0]) / e)), r;
      }
      const tx = 63710088e-1;
      function ex(n, t, e) {
        e = e || tx;
        const i = sl(n[1]), r = sl(t[1]), a = (r - i) / 2, o = sl(t[0] - n[0]) / 2, s = Math.sin(a) * Math.sin(a) + Math.sin(o) * Math.sin(o) * Math.cos(i) * Math.cos(r);
        return 2 * e * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s));
      }
      function nx(n, t) {
        let e = 0;
        for (let i = 0, r = n.length; i < r - 1; ++i) e += ex(n[i], n[i + 1], t);
        return e;
      }
      function qL(n, t) {
        t = t || {};
        const e = t.radius || tx, i = t.projection || "EPSG:3857", r = n.getType();
        r !== "GeometryCollection" && (n = n.clone().transform(i, "EPSG:4326"));
        let a = 0, o, s, l, u, h, c;
        switch (r) {
          case "Point":
          case "MultiPoint":
            break;
          case "LineString":
          case "LinearRing": {
            o = n.getCoordinates(), a = nx(o, e);
            break;
          }
          case "MultiLineString":
          case "Polygon": {
            for (o = n.getCoordinates(), l = 0, u = o.length; l < u; ++l) a += nx(o[l], e);
            break;
          }
          case "MultiPolygon": {
            for (o = n.getCoordinates(), l = 0, u = o.length; l < u; ++l) for (s = o[l], h = 0, c = s.length; h < c; ++h) a += nx(s[h], e);
            break;
          }
          case "GeometryCollection": {
            const f = n.getGeometries();
            for (l = 0, u = f.length; l < u; ++l) a += qL(f[l], t);
            break;
          }
          default:
            throw new Error("Unsupported geometry type: " + r);
        }
        return a;
      }
      function qy(n, t) {
        let e = 0;
        const i = n.length;
        let r = n[i - 1][0], a = n[i - 1][1];
        for (let o = 0; o < i; o++) {
          const s = n[o][0], l = n[o][1];
          e += sl(s - r) * (2 + Math.sin(sl(a)) + Math.sin(sl(l))), r = s, a = l;
        }
        return e * t * t / 2;
      }
      function HL(n, t) {
        t = t || {};
        const e = t.radius || tx, i = t.projection || "EPSG:3857", r = n.getType();
        r !== "GeometryCollection" && (n = n.clone().transform(i, "EPSG:4326"));
        let a = 0, o, s, l, u, h, c;
        switch (r) {
          case "Point":
          case "MultiPoint":
          case "LineString":
          case "MultiLineString":
          case "LinearRing":
            break;
          case "Polygon": {
            for (o = n.getCoordinates(), a = Math.abs(qy(o[0], e)), l = 1, u = o.length; l < u; ++l) a -= Math.abs(qy(o[l], e));
            break;
          }
          case "MultiPolygon": {
            for (o = n.getCoordinates(), l = 0, u = o.length; l < u; ++l) for (s = o[l], a += Math.abs(qy(s[0], e)), h = 1, c = s.length; h < c; ++h) a -= Math.abs(qy(s[h], e));
            break;
          }
          case "GeometryCollection": {
            const f = n.getGeometries();
            for (l = 0, u = f.length; l < u; ++l) a += HL(f[l], t);
            break;
          }
          default:
            throw new Error("Unsupported geometry type: " + r);
        }
        return a;
      }
      function YL(...n) {
      }
      function WL(...n) {
      }
      let ix = true;
      function XL(n) {
        ix = false;
      }
      function rx(n, t) {
        if (t !== void 0) {
          for (let e = 0, i = n.length; e < i; ++e) t[e] = n[e];
          t = t;
        } else t = n.slice();
        return t;
      }
      function ZL(n, t) {
        if (t !== void 0 && n !== t) {
          for (let e = 0, i = n.length; e < i; ++e) t[e] = n[e];
          n = t;
        }
        return n;
      }
      function Hy(n) {
        _Z(n.getCode(), n), Oc(n, n, rx);
      }
      function CZ(n) {
        n.forEach(Hy);
      }
      function Vt(n) {
        return typeof n == "string" ? mZ(n) : n || null;
      }
      function KL(n, t, e, i) {
        n = Vt(n);
        let r;
        const a = n.getPointResolutionFunc();
        if (a) r = a(t, e);
        else {
          const o = n.getUnits();
          if (o == "degrees" && !i || i == "degrees") r = t;
          else {
            const s = ox(n, Vt("EPSG:4326"));
            if (s === ZL && o !== "degrees") r = t * n.getMetersPerUnit();
            else {
              let u = [e[0] - t / 2, e[1], e[0] + t / 2, e[1], e[0], e[1] - t / 2, e[0], e[1] + t / 2];
              u = s(u, u, 2);
              const h = ex(u.slice(0, 2), u.slice(2, 4)), c = ex(u.slice(4, 6), u.slice(6, 8));
              r = (h + c) / 2;
            }
            const l = n.getMetersPerUnit();
            l !== void 0 && (r /= l);
          }
        }
        return r;
      }
      function jd(n) {
        CZ(n), n.forEach(function(t) {
          n.forEach(function(e) {
            t !== e && Oc(t, e, rx);
          });
        });
      }
      function Tu(n, t, e, i) {
        n.forEach(function(r) {
          t.forEach(function(a) {
            Oc(r, a, e), Oc(a, r, i);
          });
        });
      }
      function ax(n, t) {
        return n ? typeof n == "string" ? Vt(n) : n : Vt(t);
      }
      function $L(n) {
        return function(t, e, i, r) {
          const a = t.length;
          i = i !== void 0 ? i : 2, r = r != null ? r : i, e = e !== void 0 ? e : new Array(a);
          for (let o = 0; o < a; o += r) {
            const s = n(t.slice(o, o + i)), l = s.length;
            for (let u = 0, h = r; u < h; ++u) e[o + u] = u >= l ? t[o + u] : s[u];
          }
          return e;
        };
      }
      function Mu(n, t, e, i) {
        const r = Vt(n), a = Vt(t);
        Oc(r, a, $L(e)), Oc(a, r, $L(i));
      }
      function JL(n, t) {
        return XL(), as(n, "EPSG:4326", t !== void 0 ? t : "EPSG:3857");
      }
      function tP(n, t) {
        const e = as(n, t !== void 0 ? t : "EPSG:3857", "EPSG:4326"), i = e[0];
        return (i < -180 || i > 180) && (e[0] = rs(i + 180, 360) - 180), e;
      }
      function ro(n, t) {
        if (n === t) return true;
        const e = n.getUnits() === t.getUnits();
        return (n.getCode() === t.getCode() || ox(n, t) === rx) && e;
      }
      function ox(n, t) {
        const e = n.getCode(), i = t.getCode();
        let r = OL(e, i);
        return r || (r = ZL), r;
      }
      function Gc(n, t) {
        const e = Vt(n), i = Vt(t);
        return ox(e, i);
      }
      function as(n, t, e) {
        return Gc(t, e)(n, void 0, n.length);
      }
      function SZ(n, t, e, i) {
        const r = Gc(t, e);
        return cZ(n, r, void 0);
      }
      function os(n, t) {
        return n;
      }
      function qe(n, t) {
        return ix && !Da(n, [0, 0]) && n[0] >= -180 && n[0] <= 180 && n[1] >= -90 && n[1] <= 90 && (ix = false, YL("Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.")), n;
      }
      function qd(n, t) {
        return n;
      }
      function Ni(n, t) {
        return n;
      }
      function eP(n, t, e) {
        return function(i) {
          let r, a;
          if (n.canWrapX()) {
            const o = n.getExtent(), s = ve(o);
            i = i.slice(0), a = jL(i, n, s), a && (i[0] = i[0] - a * s), i[0] = en(i[0], o[0], o[2]), i[1] = en(i[1], o[1], o[3]), r = e(i);
          } else r = e(i);
          return a && t.canWrapX() && (r[0] += a * ve(t.getExtent())), r;
        };
      }
      function bZ() {
        jd(Gy), jd(Uy), Tu(Uy, Gy, AZ, pZ);
      }
      bZ();
      function ul(n, t, e, i, r, a, o) {
        a = a || [], o = o || 2;
        let s = 0;
        for (let l = t; l < e; l += i) {
          const u = n[l], h = n[l + 1];
          a[s++] = r[0] * u + r[2] * h + r[4], a[s++] = r[1] * u + r[3] * h + r[5];
          for (let c = 2; c < o; c++) a[s++] = n[l + c];
        }
        return a && a.length != s && (a.length = s), a;
      }
      function sx(n, t, e, i, r, a, o) {
        o = o || [];
        const s = Math.cos(r), l = Math.sin(r), u = a[0], h = a[1];
        let c = 0;
        for (let f = t; f < e; f += i) {
          const g = n[f] - u, d = n[f + 1] - h;
          o[c++] = u + g * s - d * l, o[c++] = h + g * l + d * s;
          for (let A = f + 2; A < f + i; ++A) o[c++] = n[A];
        }
        return o && o.length != c && (o.length = c), o;
      }
      function BZ(n, t, e, i, r, a, o, s) {
        s = s || [];
        const l = o[0], u = o[1];
        let h = 0;
        for (let c = t; c < e; c += i) {
          const f = n[c] - l, g = n[c + 1] - u;
          s[h++] = l + r * f, s[h++] = u + a * g;
          for (let d = c + 2; d < c + i; ++d) s[h++] = n[d];
        }
        return s && s.length != h && (s.length = h), s;
      }
      function TZ(n, t, e, i, r, a, o) {
        o = o || [];
        let s = 0;
        for (let l = t; l < e; l += i) {
          o[s++] = n[l] + r, o[s++] = n[l + 1] + a;
          for (let u = l + 2; u < l + i; ++u) o[s++] = n[u];
        }
        return o && o.length != s && (o.length = s), o;
      }
      const nP = wn();
      class Yy extends Yr {
        constructor() {
          super(), this.extent_ = Ii(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = CL((t, e, i) => {
            if (!i) return this.getSimplifiedGeometry(e);
            const r = this.clone();
            return r.applyTransform(i), r.getSimplifiedGeometry(e);
          });
        }
        simplifyTransformed(t, e) {
          return this.simplifyTransformedInternal(this.getRevision(), t, e);
        }
        clone() {
          return Qt();
        }
        closestPointXY(t, e, i, r) {
          return Qt();
        }
        containsXY(t, e) {
          const i = this.getClosestPoint([t, e]);
          return i[0] === t && i[1] === e;
        }
        getClosestPoint(t, e) {
          return e = e || [NaN, NaN], this.closestPointXY(t[0], t[1], e, 1 / 0), e;
        }
        intersectsCoordinate(t) {
          return this.containsXY(t[0], t[1]);
        }
        computeExtent(t) {
          return Qt();
        }
        getExtent(t) {
          if (this.extentRevision_ != this.getRevision()) {
            const e = this.computeExtent(this.extent_);
            (isNaN(e[0]) || isNaN(e[1])) && Rc(e), this.extentRevision_ = this.getRevision();
          }
          return lZ(this.extent_, t);
        }
        rotate(t, e) {
          Qt();
        }
        scale(t, e, i) {
          Qt();
        }
        simplify(t) {
          return this.getSimplifiedGeometry(t * t);
        }
        getSimplifiedGeometry(t) {
          return Qt();
        }
        getType() {
          return Qt();
        }
        applyTransform(t) {
          Qt();
        }
        intersectsExtent(t) {
          return Qt();
        }
        translate(t, e) {
          Qt();
        }
        transform(t, e) {
          const i = Vt(t), r = i.getUnits() == "tile-pixels" ? function(a, o, s) {
            const l = i.getExtent(), u = i.getWorldExtent(), h = Cn(u) / Cn(l);
            return Sr(nP, u[0], u[3], h, -h, 0, 0, 0), ul(a, 0, a.length, s, nP, o), Gc(i, e)(a, o, s);
          } : Gc(i, e);
          return this.applyTransform(r), this;
        }
      }
      class Ra extends Yy {
        constructor() {
          super(), this.layout = "XY", this.stride = 2, this.flatCoordinates;
        }
        computeExtent(t) {
          return YE(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t);
        }
        getCoordinates() {
          return Qt();
        }
        getFirstCoordinate() {
          return this.flatCoordinates.slice(0, this.stride);
        }
        getFlatCoordinates() {
          return this.flatCoordinates;
        }
        getLastCoordinate() {
          return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
        }
        getLayout() {
          return this.layout;
        }
        getSimplifiedGeometry(t) {
          if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t <= this.simplifiedGeometryMaxMinSquaredTolerance) return this;
          const e = this.getSimplifiedGeometryInternal(t);
          return e.getFlatCoordinates().length < this.flatCoordinates.length ? e : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
        }
        getSimplifiedGeometryInternal(t) {
          return this;
        }
        getStride() {
          return this.stride;
        }
        setFlatCoordinates(t, e) {
          this.stride = Hd(t), this.layout = t, this.flatCoordinates = e;
        }
        setCoordinates(t, e) {
          Qt();
        }
        setLayout(t, e, i) {
          let r;
          if (t) r = Hd(t);
          else {
            for (let a = 0; a < i; ++a) {
              if (e.length === 0) {
                this.layout = "XY", this.stride = 2;
                return;
              }
              e = e[0];
            }
            r = e.length, t = Du(r);
          }
          this.layout = t, this.stride = r;
        }
        applyTransform(t) {
          this.flatCoordinates && (t(this.flatCoordinates, this.flatCoordinates, this.layout.startsWith("XYZ") ? 3 : 2, this.stride), this.changed());
        }
        rotate(t, e) {
          const i = this.getFlatCoordinates();
          if (i) {
            const r = this.getStride();
            sx(i, 0, i.length, r, t, e, i), this.changed();
          }
        }
        scale(t, e, i) {
          e === void 0 && (e = t), i || (i = Br(this.getExtent()));
          const r = this.getFlatCoordinates();
          if (r) {
            const a = this.getStride();
            BZ(r, 0, r.length, a, t, e, i, r), this.changed();
          }
        }
        translate(t, e) {
          const i = this.getFlatCoordinates();
          if (i) {
            const r = this.getStride();
            TZ(i, 0, i.length, r, t, e, i), this.changed();
          }
        }
      }
      function Du(n) {
        let t;
        return n == 2 ? t = "XY" : n == 3 ? t = "XYZ" : n == 4 && (t = "XYZM"), t;
      }
      function Hd(n) {
        let t;
        return n == "XY" ? t = 2 : n == "XYZ" || n == "XYM" ? t = 3 : n == "XYZM" && (t = 4), t;
      }
      function MZ(n, t, e) {
        const i = n.getFlatCoordinates();
        if (!i) return null;
        const r = n.getStride();
        return ul(i, 0, i.length, r, t, e);
      }
      function iP(n, t, e, i, r, a, o) {
        const s = n[t], l = n[t + 1], u = n[e] - s, h = n[e + 1] - l;
        let c;
        if (u === 0 && h === 0) c = t;
        else {
          const f = ((r - s) * u + (a - l) * h) / (u * u + h * h);
          if (f > 1) c = e;
          else if (f > 0) {
            for (let g = 0; g < i; ++g) o[g] = Tr(n[t + g], n[e + g], f);
            o.length = i;
            return;
          } else c = t;
        }
        for (let f = 0; f < i; ++f) o[f] = n[c + f];
        o.length = i;
      }
      function lx(n, t, e, i, r) {
        let a = n[t], o = n[t + 1];
        for (t += i; t < e; t += i) {
          const s = n[t], l = n[t + 1], u = is(a, o, s, l);
          u > r && (r = u), a = s, o = l;
        }
        return r;
      }
      function ux(n, t, e, i, r) {
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a];
          r = lx(n, t, s, i, r), t = s;
        }
        return r;
      }
      function DZ(n, t, e, i, r) {
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a];
          r = ux(n, t, s, i, r), t = s[s.length - 1];
        }
        return r;
      }
      function hx(n, t, e, i, r, a, o, s, l, u, h) {
        if (t == e) return u;
        let c, f;
        if (r === 0) {
          if (f = is(o, s, n[t], n[t + 1]), f < u) {
            for (c = 0; c < i; ++c) l[c] = n[t + c];
            return l.length = i, f;
          }
          return u;
        }
        h = h || [NaN, NaN];
        let g = t + i;
        for (; g < e; ) if (iP(n, g - i, g, i, o, s, h), f = is(o, s, h[0], h[1]), f < u) {
          for (u = f, c = 0; c < i; ++c) l[c] = h[c];
          l.length = i, g += i;
        } else g += i * Math.max((Math.sqrt(f) - Math.sqrt(u)) / r | 0, 1);
        if (a && (iP(n, e - i, t, i, o, s, h), f = is(o, s, h[0], h[1]), f < u)) {
          for (u = f, c = 0; c < i; ++c) l[c] = h[c];
          l.length = i;
        }
        return u;
      }
      function cx(n, t, e, i, r, a, o, s, l, u, h) {
        h = h || [NaN, NaN];
        for (let c = 0, f = e.length; c < f; ++c) {
          const g = e[c];
          u = hx(n, t, g, i, r, a, o, s, l, u, h), t = g;
        }
        return u;
      }
      function RZ(n, t, e, i, r, a, o, s, l, u, h) {
        h = h || [NaN, NaN];
        for (let c = 0, f = e.length; c < f; ++c) {
          const g = e[c];
          u = cx(n, t, g, i, r, a, o, s, l, u, h), t = g[g.length - 1];
        }
        return u;
      }
      function rP(n, t, e, i) {
        for (let r = 0, a = e.length; r < a; ++r) n[t++] = e[r];
        return t;
      }
      function Yd(n, t, e, i) {
        for (let r = 0, a = e.length; r < a; ++r) {
          const o = e[r];
          for (let s = 0; s < i; ++s) n[t++] = o[s];
        }
        return t;
      }
      function Wd(n, t, e, i, r) {
        r = r || [];
        let a = 0;
        for (let o = 0, s = e.length; o < s; ++o) {
          const l = Yd(n, t, e[o], i);
          r[a++] = l, t = l;
        }
        return r.length = a, r;
      }
      function aP(n, t, e, i, r) {
        r = r || [];
        let a = 0;
        for (let o = 0, s = e.length; o < s; ++o) {
          const l = Wd(n, t, e[o], i, r[a]);
          l.length === 0 && (l[0] = t), r[a++] = l, t = l[l.length - 1];
        }
        return r.length = a, r;
      }
      function Wy(n, t, e, i, r, a, o) {
        const s = (e - t) / i;
        if (s < 3) {
          for (; t < e; t += i) a[o++] = n[t], a[o++] = n[t + 1];
          return o;
        }
        const l = new Array(s);
        l[0] = 1, l[s - 1] = 1;
        const u = [t, e - i];
        let h = 0;
        for (; u.length > 0; ) {
          const c = u.pop(), f = u.pop();
          let g = 0;
          const d = n[f], A = n[f + 1], p = n[c], v = n[c + 1];
          for (let y = f + i; y < c; y += i) {
            const m = n[y], _ = n[y + 1], E = IZ(m, _, d, A, p, v);
            E > g && (h = y, g = E);
          }
          g > r && (l[(h - t) / i] = 1, f + i < h && u.push(f, h), h + i < c && u.push(h, c));
        }
        for (let c = 0; c < s; ++c) l[c] && (a[o++] = n[t + c * i], a[o++] = n[t + c * i + 1]);
        return o;
      }
      function oP(n, t, e, i, r, a, o, s) {
        for (let l = 0, u = e.length; l < u; ++l) {
          const h = e[l];
          o = Wy(n, t, h, i, r, a, o), s.push(o), t = h;
        }
        return o;
      }
      function Ru(n, t) {
        return t * Math.round(n / t);
      }
      function LZ(n, t, e, i, r, a, o) {
        if (t == e) return o;
        let s = Ru(n[t], r), l = Ru(n[t + 1], r);
        t += i, a[o++] = s, a[o++] = l;
        let u, h;
        do
          if (u = Ru(n[t], r), h = Ru(n[t + 1], r), t += i, t == e) return a[o++] = u, a[o++] = h, o;
        while (u == s && h == l);
        for (; t < e; ) {
          const c = Ru(n[t], r), f = Ru(n[t + 1], r);
          if (t += i, c == u && f == h) continue;
          const g = u - s, d = h - l, A = c - s, p = f - l;
          if (g * p == d * A && (g < 0 && A < g || g == A || g > 0 && A > g) && (d < 0 && p < d || d == p || d > 0 && p > d)) {
            u = c, h = f;
            continue;
          }
          a[o++] = u, a[o++] = h, s = u, l = h, u = c, h = f;
        }
        return a[o++] = u, a[o++] = h, o;
      }
      function fx(n, t, e, i, r, a, o, s) {
        for (let l = 0, u = e.length; l < u; ++l) {
          const h = e[l];
          o = LZ(n, t, h, i, r, a, o), s.push(o), t = h;
        }
        return o;
      }
      function PZ(n, t, e, i, r, a, o, s) {
        for (let l = 0, u = e.length; l < u; ++l) {
          const h = e[l], c = [];
          o = fx(n, t, h, i, r, a, o, c), s.push(c), t = h[h.length - 1];
        }
        return o;
      }
      function ss(n, t, e, i, r) {
        r = r !== void 0 ? r : [];
        let a = 0;
        for (let o = t; o < e; o += i) r[a++] = n.slice(o, o + i);
        return r.length = a, r;
      }
      function Xd(n, t, e, i, r) {
        r = r !== void 0 ? r : [];
        let a = 0;
        for (let o = 0, s = e.length; o < s; ++o) {
          const l = e[o];
          r[a++] = ss(n, t, l, i, r[a]), t = l;
        }
        return r.length = a, r;
      }
      function gx(n, t, e, i, r) {
        r = r !== void 0 ? r : [];
        let a = 0;
        for (let o = 0, s = e.length; o < s; ++o) {
          const l = e[o];
          r[a++] = l.length === 1 && l[0] === t ? [] : Xd(n, t, l, i, r[a]), t = l[l.length - 1];
        }
        return r.length = a, r;
      }
      function sP(n, t, e, i) {
        let r = 0;
        const a = n[e - i], o = n[e - i + 1];
        let s = 0, l = 0;
        for (; t < e; t += i) {
          const u = n[t] - a, h = n[t + 1] - o;
          r += l * u - s * h, s = u, l = h;
        }
        return r / 2;
      }
      function lP(n, t, e, i) {
        let r = 0;
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a];
          r += sP(n, t, s, i), t = s;
        }
        return r;
      }
      function NZ(n, t, e, i) {
        let r = 0;
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a];
          r += lP(n, t, s, i), t = s[s.length - 1];
        }
        return r;
      }
      class ao extends Ra {
        constructor(t, e) {
          super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, e !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(e, t) : this.setCoordinates(t, e);
        }
        clone() {
          return new ao(this.flatCoordinates.slice(), this.layout);
        }
        closestPointXY(t, e, i, r) {
          return r < bu(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(lx(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), hx(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, t, e, i, r));
        }
        getArea() {
          return sP(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        }
        getCoordinates() {
          return ss(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        }
        getSimplifiedGeometryInternal(t) {
          const e = [];
          return e.length = Wy(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, 0), new ao(e, "XY");
        }
        getType() {
          return "LinearRing";
        }
        intersectsExtent(t) {
          return false;
        }
        setCoordinates(t, e) {
          this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Yd(this.flatCoordinates, 0, t, this.stride), this.changed();
        }
      }
      let Oe = class XX extends Ra {
        constructor(t, e) {
          super(), this.setCoordinates(t, e);
        }
        clone() {
          const t = new XX(this.flatCoordinates.slice(), this.layout);
          return t.applyProperties(this), t;
        }
        closestPointXY(t, e, i, r) {
          const a = this.flatCoordinates, o = is(t, e, a[0], a[1]);
          if (o < r) {
            const s = this.stride;
            for (let l = 0; l < s; ++l) i[l] = a[l];
            return i.length = s, o;
          }
          return r;
        }
        getCoordinates() {
          return this.flatCoordinates.slice();
        }
        computeExtent(t) {
          return Lc(this.flatCoordinates, t);
        }
        getType() {
          return "Point";
        }
        intersectsExtent(t) {
          return qE(t, this.flatCoordinates[0], this.flatCoordinates[1]);
        }
        setCoordinates(t, e) {
          this.setLayout(e, t, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = rP(this.flatCoordinates, 0, t, this.stride), this.changed();
        }
      };
      function kZ(n, t, e, i, r) {
        return !WE(r, function(o) {
          return !Lu(n, t, e, i, o[0], o[1]);
        });
      }
      function Lu(n, t, e, i, r, a) {
        let o = 0, s = n[e - i], l = n[e - i + 1];
        for (; t < e; t += i) {
          const u = n[t], h = n[t + 1];
          l <= a ? h > a && (u - s) * (a - l) - (r - s) * (h - l) > 0 && o++ : h <= a && (u - s) * (a - l) - (r - s) * (h - l) < 0 && o--, s = u, l = h;
        }
        return o !== 0;
      }
      function dx(n, t, e, i, r, a) {
        if (e.length === 0 || !Lu(n, t, e[0], i, r, a)) return false;
        for (let o = 1, s = e.length; o < s; ++o) if (Lu(n, e[o - 1], e[o], i, r, a)) return false;
        return true;
      }
      function FZ(n, t, e, i, r, a) {
        if (e.length === 0) return false;
        for (let o = 0, s = e.length; o < s; ++o) {
          const l = e[o];
          if (dx(n, t, l, i, r, a)) return true;
          t = l[l.length - 1];
        }
        return false;
      }
      function Ax(n, t, e, i, r, a, o) {
        let s, l, u, h, c, f, g;
        const d = r[a + 1], A = [];
        for (let y = 0, m = e.length; y < m; ++y) {
          const _ = e[y];
          for (h = n[_ - i], f = n[_ - i + 1], s = t; s < _; s += i) c = n[s], g = n[s + 1], (d <= f && g <= d || f <= d && d <= g) && (u = (d - f) / (g - f) * (c - h) + h, A.push(u)), h = c, f = g;
        }
        let p = NaN, v = -1 / 0;
        for (A.sort(Ma), h = A[0], s = 1, l = A.length; s < l; ++s) {
          c = A[s];
          const y = Math.abs(c - h);
          y > v && (u = (h + c) / 2, dx(n, t, e, i, u, d) && (p = u, v = y)), h = c;
        }
        return isNaN(p) && (p = r[a]), o ? (o.push(p, d, v), o) : [p, d, v];
      }
      function uP(n, t, e, i, r) {
        let a = [];
        for (let o = 0, s = e.length; o < s; ++o) {
          const l = e[o];
          a = Ax(n, t, l, i, r, 2 * o, a), t = l[l.length - 1];
        }
        return a;
      }
      function hP(n, t, e, i, r) {
        let a;
        for (t += i; t < e; t += i) if (a = r(n.slice(t - i, t), n.slice(t, t + i)), a) return a;
        return false;
      }
      function Xy(n, t, e, i, r) {
        const a = NL(Ii(), n, t, e, i);
        return hi(r, a) ? br(r, a) || a[0] >= r[0] && a[2] <= r[2] || a[1] >= r[1] && a[3] <= r[3] ? true : hP(n, t, e, i, function(o, s) {
          return hZ(r, o, s);
        }) : false;
      }
      function QZ(n, t, e, i, r) {
        for (let a = 0, o = e.length; a < o; ++a) {
          if (Xy(n, t, e[a], i, r)) return true;
          t = e[a];
        }
        return false;
      }
      function cP(n, t, e, i, r) {
        return !!(Xy(n, t, e, i, r) || Lu(n, t, e, i, r[0], r[1]) || Lu(n, t, e, i, r[0], r[3]) || Lu(n, t, e, i, r[2], r[1]) || Lu(n, t, e, i, r[2], r[3]));
      }
      function fP(n, t, e, i, r) {
        if (!cP(n, t, e[0], i, r)) return false;
        if (e.length === 1) return true;
        for (let a = 1, o = e.length; a < o; ++a) if (kZ(n, e[a - 1], e[a], i, r) && !Xy(n, e[a - 1], e[a], i, r)) return false;
        return true;
      }
      function OZ(n, t, e, i, r) {
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a];
          if (fP(n, t, s, i, r)) return true;
          t = s[s.length - 1];
        }
        return false;
      }
      function zZ(n, t, e, i) {
        for (; t < e - i; ) {
          for (let r = 0; r < i; ++r) {
            const a = n[t + r];
            n[t + r] = n[e - i + r], n[e - i + r] = a;
          }
          t += i, e -= i;
        }
      }
      function Zy(n, t, e, i) {
        let r = 0, a = n[e - i], o = n[e - i + 1];
        for (; t < e; t += i) {
          const s = n[t], l = n[t + 1];
          r += (s - a) * (l + o), a = s, o = l;
        }
        return r === 0 ? void 0 : r > 0;
      }
      function px(n, t, e, i, r) {
        r = r !== void 0 ? r : false;
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a], l = Zy(n, t, s, i);
          if (a === 0) {
            if (r && l || !r && !l) return false;
          } else if (r && !l || !r && l) return false;
          t = s;
        }
        return true;
      }
      function gP(n, t, e, i, r) {
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a];
          if (!px(n, t, s, i, r)) return false;
          s.length && (t = s[s.length - 1]);
        }
        return true;
      }
      function Ky(n, t, e, i, r) {
        r = r !== void 0 ? r : false;
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a], l = Zy(n, t, s, i);
          (a === 0 ? r && l || !r && !l : r && !l || !r && l) && zZ(n, t, s, i), t = s;
        }
        return t;
      }
      function vx(n, t, e, i, r) {
        for (let a = 0, o = e.length; a < o; ++a) t = Ky(n, t, e[a], i, r);
        return t;
      }
      function dP(n, t) {
        const e = [];
        let i = 0, r = 0, a;
        for (let o = 0, s = t.length; o < s; ++o) {
          const l = t[o], u = Zy(n, i, l, 2);
          if (a === void 0 && (a = u), u === a) e.push(t.slice(r, o + 1));
          else {
            if (e.length === 0) continue;
            e[e.length - 1].push(t[r]);
          }
          r = o + 1, i = l;
        }
        return e;
      }
      let Sn = class wL extends Ra {
        constructor(t, e, i) {
          super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, e !== void 0 && i ? (this.setFlatCoordinates(e, t), this.ends_ = i) : this.setCoordinates(t, e);
        }
        appendLinearRing(t) {
          this.flatCoordinates ? De(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
        }
        clone() {
          const t = new wL(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
          return t.applyProperties(this), t;
        }
        closestPointXY(t, e, i, r) {
          return r < bu(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(ux(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), cx(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, t, e, i, r));
        }
        containsXY(t, e) {
          return dx(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, e);
        }
        getArea() {
          return lP(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
        }
        getCoordinates(t) {
          let e;
          return t !== void 0 ? (e = this.getOrientedFlatCoordinates().slice(), Ky(e, 0, this.ends_, this.stride, t)) : e = this.flatCoordinates, Xd(e, 0, this.ends_, this.stride);
        }
        getEnds() {
          return this.ends_;
        }
        getFlatInteriorPoint() {
          if (this.flatInteriorPointRevision_ != this.getRevision()) {
            const t = Br(this.getExtent());
            this.flatInteriorPoint_ = Ax(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, 0), this.flatInteriorPointRevision_ = this.getRevision();
          }
          return this.flatInteriorPoint_;
        }
        getInteriorPoint() {
          return new Oe(this.getFlatInteriorPoint(), "XYM");
        }
        getLinearRingCount() {
          return this.ends_.length;
        }
        getLinearRing(t) {
          return t < 0 || this.ends_.length <= t ? null : new ao(this.flatCoordinates.slice(t === 0 ? 0 : this.ends_[t - 1], this.ends_[t]), this.layout);
        }
        getLinearRings() {
          const t = this.layout, e = this.flatCoordinates, i = this.ends_, r = [];
          let a = 0;
          for (let o = 0, s = i.length; o < s; ++o) {
            const l = i[o], u = new ao(e.slice(a, l), t);
            r.push(u), a = l;
          }
          return r;
        }
        getOrientedFlatCoordinates() {
          if (this.orientedRevision_ != this.getRevision()) {
            const t = this.flatCoordinates;
            px(t, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = Ky(this.orientedFlatCoordinates_, 0, this.ends_, this.stride)), this.orientedRevision_ = this.getRevision();
          }
          return this.orientedFlatCoordinates_;
        }
        getSimplifiedGeometryInternal(t) {
          const e = [], i = [];
          return e.length = fx(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(t), e, 0, i), new wL(e, "XY", i);
        }
        getType() {
          return "Polygon";
        }
        intersectsExtent(t) {
          return fP(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t);
        }
        setCoordinates(t, e) {
          this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
          const i = Wd(this.flatCoordinates, 0, t, this.stride, this.ends_);
          this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1], this.changed();
        }
      };
      function yx(n) {
        if (ns(n)) throw new Error("Cannot create polygon from empty extent");
        const t = n[0], e = n[1], i = n[2], r = n[3], a = [t, e, t, r, i, r, i, e, t, e];
        return new Sn(a, "XY", [a.length]);
      }
      function AP(n, t, e) {
        t = t || 32;
        const i = n.getStride(), r = n.getLayout(), a = n.getCenter(), o = i * (t + 1), s = new Array(o);
        for (let h = 0; h < o; h += i) {
          s[h] = 0, s[h + 1] = 0;
          for (let c = 2; c < i; c++) s[h + c] = a[c];
        }
        const l = [s.length], u = new Sn(s, r, l);
        return pP(u, a, n.getRadius(), e), u;
      }
      function pP(n, t, e, i) {
        const r = n.getFlatCoordinates(), a = n.getStride(), o = r.length / a - 1, s = i || 0;
        for (let l = 0; l <= o; ++l) {
          const u = l * a, h = s + rs(l, o) * 2 * Math.PI / o;
          r[u] = t[0] + e * Math.cos(h), r[u + 1] = t[1] + e * Math.sin(h);
        }
        n.changed();
      }
      const ni = { PRERENDER: "prerender", POSTRENDER: "postrender", PRECOMPOSE: "precompose", POSTCOMPOSE: "postcompose", RENDERCOMPLETE: "rendercomplete" }, Bt = { IDLE: 0, LOADING: 1, LOADED: 2, ERROR: 3, EMPTY: 4 }, Zd = { name: "rgb", min: [0, 0, 0], max: [255, 255, 255], channel: ["red", "green", "blue"], alias: ["RGB"] };
      var ci = { name: "xyz", min: [0, 0, 0], channel: ["X", "Y", "Z"], alias: ["XYZ", "ciexyz", "cie1931"] };
      ci.whitepoint = { 2: { A: [109.85, 100, 35.585], C: [98.074, 100, 118.232], D50: [96.422, 100, 82.521], D55: [95.682, 100, 92.149], D65: [95.045592705167, 100, 108.9057750759878], D75: [94.972, 100, 122.638], F2: [99.187, 100, 67.395], F7: [95.044, 100, 108.755], F11: [100.966, 100, 64.37], E: [100, 100, 100] }, 10: { A: [111.144, 100, 35.2], C: [97.285, 100, 116.145], D50: [96.72, 100, 81.427], D55: [95.799, 100, 90.926], D65: [94.811, 100, 107.304], D75: [94.416, 100, 120.641], F2: [103.28, 100, 69.026], F7: [95.792, 100, 107.687], F11: [103.866, 100, 65.627], E: [100, 100, 100] } }, ci.max = ci.whitepoint[2].D65, ci.rgb = function(n, t) {
        t = t || ci.whitepoint[2].E;
        var e = n[0] / t[0], i = n[1] / t[1], r = n[2] / t[2], a, o, s;
        return a = e * 3.240969941904521 + i * -1.537383177570093 + r * -0.498610760293, o = e * -0.96924363628087 + i * 1.87596750150772 + r * 0.041555057407175, s = e * 0.055630079696993 + i * -0.20397695888897 + r * 1.056971514242878, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a = a * 12.92, o = o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o = o * 12.92, s = s > 31308e-7 ? 1.055 * Math.pow(s, 1 / 2.4) - 0.055 : s = s * 12.92, a = Math.min(Math.max(0, a), 1), o = Math.min(Math.max(0, o), 1), s = Math.min(Math.max(0, s), 1), [a * 255, o * 255, s * 255];
      }, Zd.xyz = function(n, t) {
        var e = n[0] / 255, i = n[1] / 255, r = n[2] / 255;
        e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92, i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92, r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        var a = e * 0.41239079926595 + i * 0.35758433938387 + r * 0.18048078840183, o = e * 0.21263900587151 + i * 0.71516867876775 + r * 0.072192315360733, s = e * 0.019330818715591 + i * 0.11919477979462 + r * 0.95053215224966;
        return t = t || ci.whitepoint[2].E, [a * t[0], o * t[1], s * t[2]];
      };
      const mx = { name: "luv", min: [0, -134, -140], max: [100, 224, 122], channel: ["lightness", "u", "v"], alias: ["LUV", "cieluv", "cie1976"], xyz: function(n, t, e) {
        var i, r, a, o, s, l, u, h, c, f, g, d, A;
        if (a = n[0], o = n[1], s = n[2], a === 0) return [0, 0, 0];
        var p = 0.0011070564598794539;
        return t = t || "D65", e = e || 2, c = ci.whitepoint[e][t][0], f = ci.whitepoint[e][t][1], g = ci.whitepoint[e][t][2], d = 4 * c / (c + 15 * f + 3 * g), A = 9 * f / (c + 15 * f + 3 * g), i = o / (13 * a) + d || 0, r = s / (13 * a) + A || 0, u = a > 8 ? f * Math.pow((a + 16) / 116, 3) : f * a * p, l = u * 9 * i / (4 * r) || 0, h = u * (12 - 3 * i - 20 * r) / (4 * r) || 0, [l, u, h];
      } };
      ci.luv = function(n, t, e) {
        var i, r, a, o, s, l, u, h, c, f, g, d, A, p = 0.008856451679035631, v = 903.2962962962961;
        t = t || "D65", e = e || 2, c = ci.whitepoint[e][t][0], f = ci.whitepoint[e][t][1], g = ci.whitepoint[e][t][2], d = 4 * c / (c + 15 * f + 3 * g), A = 9 * f / (c + 15 * f + 3 * g), l = n[0], u = n[1], h = n[2], i = 4 * l / (l + 15 * u + 3 * h) || 0, r = 9 * u / (l + 15 * u + 3 * h) || 0;
        var y = u / f;
        return a = y <= p ? v * y : 116 * Math.pow(y, 1 / 3) - 16, o = 13 * a * (i - d), s = 13 * a * (r - A), [a, o, s];
      };
      var vP = { name: "lchuv", channel: ["lightness", "chroma", "hue"], alias: ["LCHuv", "cielchuv"], min: [0, 0, 0], max: [100, 100, 360], luv: function(n) {
        var t = n[0], e = n[1], i = n[2], r, a, o;
        return o = i / 360 * 2 * Math.PI, r = e * Math.cos(o), a = e * Math.sin(o), [t, r, a];
      }, xyz: function(n) {
        return mx.xyz(vP.luv(n));
      } };
      mx.lchuv = function(n) {
        var t = n[0], e = n[1], i = n[2], r = Math.sqrt(e * e + i * i), a = Math.atan2(i, e), o = a * 360 / 2 / Math.PI;
        return o < 0 && (o += 360), [t, r, o];
      }, ci.lchuv = function(n) {
        return mx.lchuv(ci.luv(n));
      };
      const yP = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      var mP = { red: 0, orange: 60, yellow: 120, green: 180, blue: 240, purple: 300 };
      function GZ(n) {
        var h, c;
        var t, e = [], i = 1, r;
        if (typeof n == "number") return { space: "rgb", values: [n >>> 16, (n & 65280) >>> 8, n & 255], alpha: 1 };
        if (typeof n == "number") return { space: "rgb", values: [n >>> 16, (n & 65280) >>> 8, n & 255], alpha: 1 };
        if (n = String(n).toLowerCase(), yP[n]) e = yP[n].slice(), r = "rgb";
        else if (n === "transparent") i = 0, r = "rgb", e = [0, 0, 0];
        else if (n[0] === "#") {
          var a = n.slice(1), o = a.length, s = o <= 4;
          i = 1, s ? (e = [parseInt(a[0] + a[0], 16), parseInt(a[1] + a[1], 16), parseInt(a[2] + a[2], 16)], o === 4 && (i = parseInt(a[3] + a[3], 16) / 255)) : (e = [parseInt(a[0] + a[1], 16), parseInt(a[2] + a[3], 16), parseInt(a[4] + a[5], 16)], o === 8 && (i = parseInt(a[6] + a[7], 16) / 255)), e[0] || (e[0] = 0), e[1] || (e[1] = 0), e[2] || (e[2] = 0), r = "rgb";
        } else if (t = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(n)) {
          var l = t[1];
          r = l.replace(/a$/, "");
          var u = r === "cmyk" ? 4 : r === "gray" ? 1 : 3;
          e = t[2].trim().split(/\s*[,\/]\s*|\s+/), r === "color" && (r = e.shift()), e = e.map(function(f, g) {
            if (f[f.length - 1] === "%") return f = parseFloat(f) / 100, g === 3 ? f : r === "rgb" ? f * 255 : r[0] === "h" || r[0] === "l" && !g ? f * 100 : r === "lab" ? f * 125 : r === "lch" ? g < 2 ? f * 150 : f * 360 : r[0] === "o" && !g ? f : r === "oklab" ? f * 0.4 : r === "oklch" ? g < 2 ? f * 0.4 : f * 360 : f;
            if (r[g] === "h" || g === 2 && r[r.length - 1] === "h") {
              if (mP[f] !== void 0) return mP[f];
              if (f.endsWith("deg")) return parseFloat(f);
              if (f.endsWith("turn")) return parseFloat(f) * 360;
              if (f.endsWith("grad")) return parseFloat(f) * 360 / 400;
              if (f.endsWith("rad")) return parseFloat(f) * 180 / Math.PI;
            }
            return f === "none" ? 0 : parseFloat(f);
          }), i = e.length > u ? e.pop() : 1;
        } else /[0-9](?:\s|\/|,)/.test(n) && (e = n.match(/([0-9]+)/g).map(function(f) {
          return parseFloat(f);
        }), r = ((c = (h = n.match(/([a-z])/ig)) == null ? void 0 : h.join("")) == null ? void 0 : c.toLowerCase()) || "rgb");
        return { space: r, values: e, alpha: i };
      }
      const _x = { name: "hsl", min: [0, 0, 0], max: [360, 100, 100], channel: ["hue", "saturation", "lightness"], alias: ["HSL"], rgb: function(n) {
        var t = n[0] / 360, e = n[1] / 100, i = n[2] / 100, r, a, o, s, l, u = 0;
        if (e === 0) return l = i * 255, [l, l, l];
        for (a = i < 0.5 ? i * (1 + e) : i + e - i * e, r = 2 * i - a, s = [0, 0, 0]; u < 3; ) o = t + 1 / 3 * -(u - 1), o < 0 ? o++ : o > 1 && o--, l = 6 * o < 1 ? r + (a - r) * 6 * o : 2 * o < 1 ? a : 3 * o < 2 ? r + (a - r) * (2 / 3 - o) * 6 : r, s[u++] = l * 255;
        return s;
      } };
      Zd.hsl = function(n) {
        var t = n[0] / 255, e = n[1] / 255, i = n[2] / 255, r = Math.min(t, e, i), a = Math.max(t, e, i), o = a - r, s, l, u;
        return a === r ? s = 0 : t === a ? s = (e - i) / o : e === a ? s = 2 + (i - t) / o : i === a && (s = 4 + (t - e) / o), s = Math.min(s * 60, 360), s < 0 && (s += 360), u = (r + a) / 2, a === r ? l = 0 : u <= 0.5 ? l = o / (a + r) : l = o / (2 - a - r), [s, l * 100, u * 100];
      };
      function UZ(n) {
        Array.isArray(n) && n.raw && (n = String.raw(...arguments)), n instanceof Number && (n = +n);
        var t, e = GZ(n);
        if (!e.space) return [];
        const i = e.space[0] === "h" ? _x.min : Zd.min, r = e.space[0] === "h" ? _x.max : Zd.max;
        return t = Array(3), t[0] = Math.min(Math.max(e.values[0], i[0]), r[0]), t[1] = Math.min(Math.max(e.values[1], i[1]), r[1]), t[2] = Math.min(Math.max(e.values[2], i[2]), r[2]), e.space[0] === "h" && (t = _x.rgb(t)), t.push(Math.min(Math.max(e.alpha, 0), 1)), t;
      }
      const Ix = [NaN, NaN, NaN, 0];
      function VZ(n) {
        return typeof n == "string" ? n : Cx(n);
      }
      const jZ = 1024, Kd = {};
      let Ex = 0;
      function qZ(n) {
        if (n.length === 4) return n;
        const t = n.slice();
        return t[3] = 1, t;
      }
      function _P(n) {
        const t = ci.lchuv(Zd.xyz(n));
        return t[3] = n[3], t;
      }
      function HZ(n) {
        const t = ci.rgb(vP.xyz(n));
        return t[3] = n[3], t;
      }
      function xx(n) {
        if (n === "none") return Ix;
        if (Kd.hasOwnProperty(n)) return Kd[n];
        if (Ex >= jZ) {
          let e = 0;
          for (const i in Kd) e++ & 3 || (delete Kd[i], --Ex);
        }
        const t = UZ(n);
        if (t.length !== 4) throw new Error('failed to parse "' + n + '" as color');
        for (const e of t) if (isNaN(e)) throw new Error('failed to parse "' + n + '" as color');
        return IP(t), Kd[n] = t, ++Ex, t;
      }
      function hl(n) {
        return Array.isArray(n) ? n : xx(n);
      }
      function IP(n) {
        return n[0] = en(n[0] + 0.5 | 0, 0, 255), n[1] = en(n[1] + 0.5 | 0, 0, 255), n[2] = en(n[2] + 0.5 | 0, 0, 255), n[3] = en(n[3], 0, 1), n;
      }
      function Cx(n) {
        let t = n[0];
        t != (t | 0) && (t = t + 0.5 | 0);
        let e = n[1];
        e != (e | 0) && (e = e + 0.5 | 0);
        let i = n[2];
        i != (i | 0) && (i = i + 0.5 | 0);
        const r = n[3] === void 0 ? 1 : Math.round(n[3] * 1e3) / 1e3;
        return "rgba(" + t + "," + e + "," + i + "," + r + ")";
      }
      const cl = typeof navigator != "undefined" && typeof navigator.userAgent != "undefined" ? navigator.userAgent.toLowerCase() : "", YZ = cl.includes("firefox"), WZ = cl.includes("safari") && !cl.includes("chrom") && (cl.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(cl)), XZ = cl.includes("webkit") && !cl.includes("edge"), EP = cl.includes("macintosh"), xP = typeof devicePixelRatio != "undefined" ? devicePixelRatio : 1, wP = typeof WorkerGlobalScope != "undefined" && typeof OffscreenCanvas != "undefined" && self instanceof WorkerGlobalScope, Sx = typeof Image != "undefined" && Image.prototype.decode, ZZ = typeof createImageBitmap == "function", CP = function() {
        let n = false;
        try {
          const t = Object.defineProperty({}, "passive", { get: function() {
            n = true;
          } });
          window.addEventListener("_", null, t), window.removeEventListener("_", null, t);
        } catch (t) {
        }
        return n;
      }();
      function dn(n, t, e, i) {
        let r;
        return e && e.length ? r = e.shift() : wP ? r = new OffscreenCanvas(n || 300, t || 300) : r = document.createElement("canvas"), n && (r.width = n), t && (r.height = t), r.getContext("2d", i);
      }
      let bx;
      function $y() {
        return bx || (bx = dn(1, 1)), bx;
      }
      function Uc(n) {
        const t = n.canvas;
        t.width = 1, t.height = 1, n.clearRect(0, 0, 1, 1);
      }
      function KZ(n) {
        let t = n.offsetWidth;
        const e = getComputedStyle(n);
        return t += parseInt(e.marginLeft, 10) + parseInt(e.marginRight, 10), t;
      }
      function $Z(n) {
        let t = n.offsetHeight;
        const e = getComputedStyle(n);
        return t += parseInt(e.marginTop, 10) + parseInt(e.marginBottom, 10), t;
      }
      function Jy(n, t) {
        const e = t.parentNode;
        e && e.replaceChild(n, t);
      }
      function SP(n) {
        for (; n.lastChild; ) n.lastChild.remove();
      }
      function JZ(n, t) {
        const e = n.childNodes;
        for (let i = 0; ; ++i) {
          const r = e[i], a = t[i];
          if (!r && !a) break;
          if (r !== a) {
            if (!r) {
              n.appendChild(a);
              continue;
            }
            if (!a) {
              n.removeChild(r), --i;
              continue;
            }
            n.insertBefore(a, r);
          }
        }
      }
      class bP extends Dc {
        constructor(t, e, i, r) {
          super(), this.extent = t, this.pixelRatio_ = i, this.resolution = e, this.state = typeof r == "function" ? Bt.IDLE : r, this.image_ = null, this.loader = typeof r == "function" ? r : null;
        }
        changed() {
          this.dispatchEvent(Nt.CHANGE);
        }
        getExtent() {
          return this.extent;
        }
        getImage() {
          return this.image_;
        }
        getPixelRatio() {
          return this.pixelRatio_;
        }
        getResolution() {
          return this.resolution;
        }
        getState() {
          return this.state;
        }
        load() {
          if (this.state == Bt.IDLE && this.loader) {
            this.state = Bt.LOADING, this.changed();
            const t = this.getResolution(), e = Array.isArray(t) ? t[0] : t;
            VE(() => this.loader(this.getExtent(), e, this.getPixelRatio())).then((i) => {
              "image" in i && (this.image_ = i.image), "extent" in i && (this.extent = i.extent), "resolution" in i && (this.resolution = i.resolution), "pixelRatio" in i && (this.pixelRatio_ = i.pixelRatio), (i instanceof HTMLImageElement || i instanceof ImageBitmap || i instanceof HTMLCanvasElement || i instanceof HTMLVideoElement) && (this.image_ = i), this.state = Bt.LOADED;
            }).catch((i) => {
              this.state = Bt.ERROR;
            }).finally(() => this.changed());
          }
        }
        setImage(t) {
          this.image_ = t;
        }
        setResolution(t) {
          this.resolution = t;
        }
      }
      function tK(n, t, e) {
        const i = n;
        let r = true, a = false, o = false;
        const s = [kd(i, Nt.LOAD, function() {
          o = true, a || t();
        })];
        return i.src && Sx ? (a = true, i.decode().then(function() {
          r && t();
        }).catch(function(l) {
          r && (o ? t() : e());
        })) : s.push(kd(i, Nt.ERROR, e)), function() {
          r = false, s.forEach(Pe);
        };
      }
      function eK(n, t) {
        return new Promise((e, i) => {
          function r() {
            o(), e(n);
          }
          function a() {
            o(), i(new Error("Image load error"));
          }
          function o() {
            n.removeEventListener("load", r), n.removeEventListener("error", a);
          }
          n.addEventListener("load", r), n.addEventListener("error", a);
        });
      }
      function BP(n, t) {
        return t && (n.src = t), n.src && Sx ? new Promise((e, i) => n.decode().then(() => e(n)).catch((r) => n.complete && n.width ? e(n) : i(r))) : eK(n);
      }
      function TP(n, t) {
        return t && (n.src = t), n.src && Sx && ZZ ? n.decode().then(() => createImageBitmap(n)).catch((e) => {
          if (n.complete && n.width) return n;
          throw e;
        }) : BP(n);
      }
      class nK {
        constructor() {
          this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32;
        }
        clear() {
          this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0;
        }
        canExpireCache() {
          return this.cacheSize_ > this.maxCacheSize_;
        }
        expire() {
          if (this.canExpireCache()) {
            let t = 0;
            for (const e in this.cache_) {
              const i = this.cache_[e];
              !(t++ & 3) && !i.hasListener() && (delete this.cache_[e], delete this.patternCache_[e], --this.cacheSize_);
            }
          }
        }
        get(t, e, i) {
          const r = Bx(t, e, i);
          return r in this.cache_ ? this.cache_[r] : null;
        }
        getPattern(t, e, i) {
          const r = Bx(t, e, i);
          return r in this.patternCache_ ? this.patternCache_[r] : null;
        }
        set(t, e, i, r, a) {
          const o = Bx(t, e, i), s = o in this.cache_;
          this.cache_[o] = r, a && (r.getImageState() === Bt.IDLE && r.load(), r.getImageState() === Bt.LOADING ? r.ready().then(() => {
            this.patternCache_[o] = $y().createPattern(r.getImage(1), "repeat");
          }) : this.patternCache_[o] = $y().createPattern(r.getImage(1), "repeat")), s || ++this.cacheSize_;
        }
        setSize(t) {
          this.maxCacheSize_ = t, this.expire();
        }
      }
      function Bx(n, t, e) {
        const i = e ? hl(e) : "null";
        return t + ":" + n + ":" + i;
      }
      const oo = new nK();
      let $d = null;
      class iK extends Dc {
        constructor(t, e, i, r, a) {
          super(), this.hitDetectionImage_ = null, this.image_ = t, this.crossOrigin_ = i, this.canvas_ = {}, this.color_ = a, this.imageState_ = r === void 0 ? Bt.IDLE : r, this.size_ = t && t.width && t.height ? [t.width, t.height] : null, this.src_ = e, this.tainted_, this.ready_ = null;
        }
        initializeImage_() {
          this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
        }
        isTainted_() {
          if (this.tainted_ === void 0 && this.imageState_ === Bt.LOADED) {
            $d || ($d = dn(1, 1, void 0, { willReadFrequently: true })), $d.drawImage(this.image_, 0, 0);
            try {
              $d.getImageData(0, 0, 1, 1), this.tainted_ = false;
            } catch (t) {
              $d = null, this.tainted_ = true;
            }
          }
          return this.tainted_ === true;
        }
        dispatchChangeEvent_() {
          this.dispatchEvent(Nt.CHANGE);
        }
        handleImageError_() {
          this.imageState_ = Bt.ERROR, this.dispatchChangeEvent_();
        }
        handleImageLoad_() {
          this.imageState_ = Bt.LOADED, this.size_ = [this.image_.width, this.image_.height], this.dispatchChangeEvent_();
        }
        getImage(t) {
          return this.image_ || this.initializeImage_(), this.replaceColor_(t), this.canvas_[t] ? this.canvas_[t] : this.image_;
        }
        getPixelRatio(t) {
          return this.replaceColor_(t), this.canvas_[t] ? t : 1;
        }
        getImageState() {
          return this.imageState_;
        }
        getHitDetectionImage() {
          if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_) if (this.isTainted_()) {
            const t = this.size_[0], e = this.size_[1], i = dn(t, e);
            i.fillRect(0, 0, t, e), this.hitDetectionImage_ = i.canvas;
          } else this.hitDetectionImage_ = this.image_;
          return this.hitDetectionImage_;
        }
        getSize() {
          return this.size_;
        }
        getSrc() {
          return this.src_;
        }
        load() {
          if (this.imageState_ === Bt.IDLE) {
            this.image_ || this.initializeImage_(), this.imageState_ = Bt.LOADING;
            try {
              this.src_ !== void 0 && (this.image_.src = this.src_);
            } catch (t) {
              this.handleImageError_();
            }
            this.image_ instanceof HTMLImageElement && BP(this.image_, this.src_).then((t) => {
              this.image_ = t, this.handleImageLoad_();
            }).catch(this.handleImageError_.bind(this));
          }
        }
        replaceColor_(t) {
          if (!this.color_ || this.canvas_[t] || this.imageState_ !== Bt.LOADED) return;
          const e = this.image_, i = dn(Math.ceil(e.width * t), Math.ceil(e.height * t)), r = i.canvas;
          i.scale(t, t), i.drawImage(e, 0, 0), i.globalCompositeOperation = "multiply", i.fillStyle = VZ(this.color_), i.fillRect(0, 0, r.width / t, r.height / t), i.globalCompositeOperation = "destination-in", i.drawImage(e, 0, 0), this.canvas_[t] = r;
        }
        ready() {
          return this.ready_ || (this.ready_ = new Promise((t) => {
            if (this.imageState_ === Bt.LOADED || this.imageState_ === Bt.ERROR) t();
            else {
              const e = () => {
                (this.imageState_ === Bt.LOADED || this.imageState_ === Bt.ERROR) && (this.removeEventListener(Nt.CHANGE, e), t());
              };
              this.addEventListener(Nt.CHANGE, e);
            }
          })), this.ready_;
        }
      }
      function Tx(n, t, e, i, r, a) {
        let o = t === void 0 ? void 0 : oo.get(t, e, r);
        return o || (o = new iK(n, n && "src" in n ? n.src || void 0 : t, e, i, r), oo.set(t, e, r, o, a)), a && o && !oo.getPattern(t, e, r) && oo.set(t, e, r, o, a), o;
      }
      class ye {
        constructor(t) {
          t = t || {}, this.patternImage_ = null, this.color_ = null, t.color !== void 0 && this.setColor(t.color);
        }
        clone() {
          const t = this.getColor();
          return new ye({ color: Array.isArray(t) ? t.slice() : t || void 0 });
        }
        getColor() {
          return this.color_;
        }
        setColor(t) {
          if (t !== null && typeof t == "object" && "src" in t) {
            const e = Tx(null, t.src, "anonymous", void 0, t.offset ? null : t.color ? t.color : null, !(t.offset && t.size));
            e.ready().then(() => {
              this.patternImage_ = null;
            }), e.getImageState() === Bt.IDLE && e.load(), e.getImageState() === Bt.LOADING && (this.patternImage_ = e);
          }
          this.color_ = t;
        }
        loading() {
          return !!this.patternImage_;
        }
        ready() {
          return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
        }
      }
      function t0(n, t, e, i, r, a, o) {
        let s, l;
        const u = (e - t) / i;
        if (u === 1) s = t;
        else if (u === 2) s = t, l = r;
        else if (u !== 0) {
          let h = n[t], c = n[t + 1], f = 0;
          const g = [0];
          for (let p = t + i; p < e; p += i) {
            const v = n[p], y = n[p + 1];
            f += Math.sqrt((v - h) * (v - h) + (y - c) * (y - c)), g.push(f), h = v, c = y;
          }
          const d = r * f, A = UE(g, d);
          A < 0 ? (l = (d - g[-A - 2]) / (g[-A - 1] - g[-A - 2]), s = t + (-A - 2) * i) : s = t + A * i;
        }
        o = o > 1 ? o : 2, a = a || new Array(o);
        for (let h = 0; h < o; ++h) a[h] = s === void 0 ? NaN : l === void 0 ? n[s + h] : Tr(n[s + h], n[s + i + h], l);
        return a;
      }
      function Mx(n, t, e, i, r, a) {
        if (e == t) return null;
        let o;
        if (r < n[t + i - 1]) return a ? (o = n.slice(t, t + i), o[i - 1] = r, o) : null;
        if (n[e - 1] < r) return a ? (o = n.slice(e - i, e), o[i - 1] = r, o) : null;
        if (r == n[t + i - 1]) return n.slice(t, t + i);
        let s = t / i, l = e / i;
        for (; s < l; ) {
          const f = s + l >> 1;
          r < n[(f + 1) * i - 1] ? l = f : s = f + 1;
        }
        const u = n[s * i - 1];
        if (r == u) return n.slice((s - 1) * i, (s - 1) * i + i);
        const h = n[(s + 1) * i - 1], c = (r - u) / (h - u);
        o = [];
        for (let f = 0; f < i - 1; ++f) o.push(Tr(n[(s - 1) * i + f], n[s * i + f], c));
        return o.push(r), o;
      }
      function rK(n, t, e, i, r, a, o) {
        if (o) return Mx(n, t, e[e.length - 1], i, r, a);
        let s;
        if (r < n[i - 1]) return a ? (s = n.slice(0, i), s[i - 1] = r, s) : null;
        if (n[n.length - 1] < r) return a ? (s = n.slice(n.length - i), s[i - 1] = r, s) : null;
        for (let l = 0, u = e.length; l < u; ++l) {
          const h = e[l];
          if (t != h) {
            if (r < n[t + i - 1]) return null;
            if (r <= n[h - 1]) return Mx(n, t, h, i, r, false);
            t = h;
          }
        }
        return null;
      }
      function MP(n, t, e, i) {
        let r = n[t], a = n[t + 1], o = 0;
        for (let s = t + i; s < e; s += i) {
          const l = n[s], u = n[s + 1];
          o += Math.sqrt((l - r) * (l - r) + (u - a) * (u - a)), r = l, a = u;
        }
        return o;
      }
      class be extends Ra {
        constructor(t, e) {
          super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, e !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(e, t) : this.setCoordinates(t, e);
        }
        appendCoordinate(t) {
          De(this.flatCoordinates, t), this.changed();
        }
        clone() {
          const t = new be(this.flatCoordinates.slice(), this.layout);
          return t.applyProperties(this), t;
        }
        closestPointXY(t, e, i, r) {
          return r < bu(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(lx(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), hx(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, t, e, i, r));
        }
        forEachSegment(t) {
          return hP(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t);
        }
        getCoordinateAtM(t, e) {
          return this.layout != "XYM" && this.layout != "XYZM" ? null : (e = e !== void 0 ? e : false, Mx(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e));
        }
        getCoordinates() {
          return ss(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        }
        getCoordinateAt(t, e) {
          return t0(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, this.stride);
        }
        getLength() {
          return MP(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        }
        getFlatMidpoint() {
          var t;
          return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(0.5, (t = this.flatMidpoint_) != null ? t : void 0), this.flatMidpointRevision_ = this.getRevision()), this.flatMidpoint_;
        }
        getSimplifiedGeometryInternal(t) {
          const e = [];
          return e.length = Wy(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, 0), new be(e, "XY");
        }
        getType() {
          return "LineString";
        }
        intersectsExtent(t) {
          return Xy(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t);
        }
        setCoordinates(t, e) {
          this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Yd(this.flatCoordinates, 0, t, this.stride), this.changed();
        }
      }
      class Ze {
        constructor(t) {
          t = t || {}, this.color_ = t.color !== void 0 ? t.color : null, this.lineCap_ = t.lineCap, this.lineDash_ = t.lineDash !== void 0 ? t.lineDash : null, this.lineDashOffset_ = t.lineDashOffset, this.lineJoin_ = t.lineJoin, this.miterLimit_ = t.miterLimit, this.width_ = t.width;
        }
        clone() {
          const t = this.getColor();
          return new Ze({ color: Array.isArray(t) ? t.slice() : t || void 0, lineCap: this.getLineCap(), lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0, lineDashOffset: this.getLineDashOffset(), lineJoin: this.getLineJoin(), miterLimit: this.getMiterLimit(), width: this.getWidth() });
        }
        getColor() {
          return this.color_;
        }
        getLineCap() {
          return this.lineCap_;
        }
        getLineDash() {
          return this.lineDash_;
        }
        getLineDashOffset() {
          return this.lineDashOffset_;
        }
        getLineJoin() {
          return this.lineJoin_;
        }
        getMiterLimit() {
          return this.miterLimit_;
        }
        getWidth() {
          return this.width_;
        }
        setColor(t) {
          this.color_ = t;
        }
        setLineCap(t) {
          this.lineCap_ = t;
        }
        setLineDash(t) {
          this.lineDash_ = t;
        }
        setLineDashOffset(t) {
          this.lineDashOffset_ = t;
        }
        setLineJoin(t) {
          this.lineJoin_ = t;
        }
        setMiterLimit(t) {
          this.miterLimit_ = t;
        }
        setWidth(t) {
          this.width_ = t;
        }
      }
      function DP(n) {
        return n[0] > 0 && n[1] > 0;
      }
      function aK(n, t, e) {
        return e === void 0 && (e = [0, 0]), e[0] = n[0] * t + 0.5 | 0, e[1] = n[1] * t + 0.5 | 0, e;
      }
      function bn(n, t) {
        return Array.isArray(n) ? n : (t === void 0 ? t = [n, n] : (t[0] = n, t[1] = n), t);
      }
      class e0 {
        constructor(t) {
          this.opacity_ = t.opacity, this.rotateWithView_ = t.rotateWithView, this.rotation_ = t.rotation, this.scale_ = t.scale, this.scaleArray_ = bn(t.scale), this.displacement_ = t.displacement, this.declutterMode_ = t.declutterMode;
        }
        clone() {
          const t = this.getScale();
          return new e0({ opacity: this.getOpacity(), scale: Array.isArray(t) ? t.slice() : t, rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() });
        }
        getOpacity() {
          return this.opacity_;
        }
        getRotateWithView() {
          return this.rotateWithView_;
        }
        getRotation() {
          return this.rotation_;
        }
        getScale() {
          return this.scale_;
        }
        getScaleArray() {
          return this.scaleArray_;
        }
        getDisplacement() {
          return this.displacement_;
        }
        getDeclutterMode() {
          return this.declutterMode_;
        }
        getAnchor() {
          return Qt();
        }
        getImage(t) {
          return Qt();
        }
        getHitDetectionImage() {
          return Qt();
        }
        getPixelRatio(t) {
          return 1;
        }
        getImageState() {
          return Qt();
        }
        getImageSize() {
          return Qt();
        }
        getOrigin() {
          return Qt();
        }
        getSize() {
          return Qt();
        }
        setDisplacement(t) {
          this.displacement_ = t;
        }
        setOpacity(t) {
          this.opacity_ = t;
        }
        setRotateWithView(t) {
          this.rotateWithView_ = t;
        }
        setRotation(t) {
          this.rotation_ = t;
        }
        setScale(t) {
          this.scale_ = t, this.scaleArray_ = bn(t);
        }
        listenImageChange(t) {
          Qt();
        }
        load() {
          Qt();
        }
        unlistenImageChange(t) {
          Qt();
        }
        ready() {
          return Promise.resolve();
        }
      }
      function so(n) {
        return n ? Array.isArray(n) ? Cx(n) : typeof n == "object" && "src" in n ? oK(n) : n : null;
      }
      function oK(n) {
        if (!n.offset || !n.size) return oo.getPattern(n.src, "anonymous", n.color);
        const t = n.src + ":" + n.offset, e = oo.getPattern(t, void 0, n.color);
        if (e) return e;
        const i = oo.get(n.src, "anonymous", null);
        if (i.getImageState() !== Bt.LOADED) return null;
        const r = dn(n.size[0], n.size[1]);
        return r.drawImage(i.getImage(1), n.offset[0], n.offset[1], n.size[0], n.size[1], 0, 0, n.size[0], n.size[1]), Tx(r.canvas, t, void 0, Bt.LOADED, n.color, true), oo.getPattern(t, void 0, n.color);
      }
      const n0 = "ol-hidden", sK = "ol-selectable", Jd = "ol-unselectable", i0 = "ol-control", r0 = "ol-collapsed", lK = new RegExp(["^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)", "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?", "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))", "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))", `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`].join(""), "i"), RP = ["style", "variant", "weight", "size", "lineHeight", "family"], LP = function(n) {
        const t = n.match(lK);
        if (!t) return null;
        const e = { lineHeight: "normal", size: "1.2em", style: "normal", weight: "normal", variant: "normal" };
        for (let i = 0, r = RP.length; i < r; ++i) {
          const a = t[i + 1];
          a !== void 0 && (e[RP[i]] = a);
        }
        return e.families = e.family.split(/,\s?/), e;
      }, PP = "10px sans-serif", ar = "#000", Vc = "round", ls = [], us = 0, jc = "round", tA = 10, eA = "#000", nA = "center", a0 = "middle", Pu = [0, 0, 0, 0], iA = 1, hs = new Yr();
      let qc = null, Dx;
      const Rx = {}, uK = function() {
        const t = "32px ", e = ["monospace", "serif"], i = e.length, r = "wmytzilWMYTZIL@#/&?$%10";
        let a, o;
        function s(u, h, c) {
          let f = true;
          for (let g = 0; g < i; ++g) {
            const d = e[g];
            if (o = o0(u + " " + h + " " + t + d, r), c != d) {
              const A = o0(u + " " + h + " " + t + c + "," + d, r);
              f = f && A != o;
            }
          }
          return !!f;
        }
        function l() {
          let u = true;
          const h = hs.getKeys();
          for (let c = 0, f = h.length; c < f; ++c) {
            const g = h[c];
            if (hs.get(g) < 100) {
              const [d, A, p] = g.split(`
`);
              s(d, A, p) ? (Mc(Rx), qc = null, Dx = void 0, hs.set(g, 100)) : (hs.set(g, hs.get(g) + 1, true), u = false);
            }
          }
          u && (clearInterval(a), a = void 0);
        }
        return function(u) {
          const h = LP(u);
          if (!h) return;
          const c = h.families;
          for (let f = 0, g = c.length; f < g; ++f) {
            const d = c[f], A = h.style + `
` + h.weight + `
` + d;
            hs.get(A) === void 0 && (hs.set(A, 100, true), s(h.style, h.weight, d) || (hs.set(A, 0, true), a === void 0 && (a = setInterval(l, 32))));
          }
        };
      }(), hK = /* @__PURE__ */ function() {
        let n;
        return function(t) {
          let e = Rx[t];
          if (e == null) {
            if (wP) {
              const i = LP(t), r = NP(t, "g");
              e = (isNaN(Number(i.lineHeight)) ? 1.2 : Number(i.lineHeight)) * (r.actualBoundingBoxAscent + r.actualBoundingBoxDescent);
            } else n || (n = document.createElement("div"), n.innerHTML = "M", n.style.minHeight = "0", n.style.maxHeight = "none", n.style.height = "auto", n.style.padding = "0", n.style.border = "none", n.style.position = "absolute", n.style.display = "block", n.style.left = "-99999px"), n.style.font = t, document.body.appendChild(n), e = n.offsetHeight, document.body.removeChild(n);
            Rx[t] = e;
          }
          return e;
        };
      }();
      function NP(n, t) {
        return qc || (qc = dn(1, 1)), n != Dx && (qc.font = n, Dx = qc.font), qc.measureText(t);
      }
      function o0(n, t) {
        return NP(n, t).width;
      }
      function kP(n, t, e) {
        if (t in e) return e[t];
        const i = t.split(`
`).reduce((r, a) => Math.max(r, o0(n, a)), 0);
        return e[t] = i, i;
      }
      function cK(n, t) {
        const e = [], i = [], r = [];
        let a = 0, o = 0, s = 0, l = 0;
        for (let u = 0, h = t.length; u <= h; u += 2) {
          const c = t[u];
          if (c === `
` || u === h) {
            a = Math.max(a, o), r.push(o), o = 0, s += l, l = 0;
            continue;
          }
          const f = t[u + 1] || n.font, g = o0(f, c);
          e.push(g), o += g;
          const d = hK(f);
          i.push(d), l = Math.max(l, d);
        }
        return { width: a, height: s, widths: e, heights: i, lineWidths: r };
      }
      function fK(n, t, e, i, r, a, o, s, l, u, h) {
        n.save(), e !== 1 && (n.globalAlpha === void 0 ? n.globalAlpha = (c) => c.globalAlpha *= e : n.globalAlpha *= e), t && n.transform.apply(n, t), i.contextInstructions ? (n.translate(l, u), n.scale(h[0], h[1]), gK(i, n)) : h[0] < 0 || h[1] < 0 ? (n.translate(l, u), n.scale(h[0], h[1]), n.drawImage(i, r, a, o, s, 0, 0, o, s)) : n.drawImage(i, r, a, o, s, l, u, o * h[0], s * h[1]), n.restore();
      }
      function gK(n, t) {
        const e = n.contextInstructions;
        for (let i = 0, r = e.length; i < r; i += 2) Array.isArray(e[i + 1]) ? t[e[i]].apply(t, e[i + 1]) : t[e[i]] = e[i + 1];
      }
      class Nu extends e0 {
        constructor(t) {
          super({ opacity: 1, rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : false, rotation: t.rotation !== void 0 ? t.rotation : 0, scale: t.scale !== void 0 ? t.scale : 1, displacement: t.displacement !== void 0 ? t.displacement : [0, 0], declutterMode: t.declutterMode }), this.canvases_, this.hitDetectionCanvas_ = null, this.fill_ = t.fill !== void 0 ? t.fill : null, this.origin_ = [0, 0], this.points_ = t.points, this.radius = t.radius, this.radius2_ = t.radius2, this.angle_ = t.angle !== void 0 ? t.angle : 0, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.size_, this.renderOptions_, this.imageState_ = this.fill_ && this.fill_.loading() ? Bt.LOADING : Bt.LOADED, this.imageState_ === Bt.LOADING && this.ready().then(() => this.imageState_ = Bt.LOADED), this.render();
        }
        clone() {
          const t = this.getScale(), e = new Nu({ fill: this.getFill() ? this.getFill().clone() : void 0, points: this.getPoints(), radius: this.getRadius(), radius2: this.getRadius2(), angle: this.getAngle(), stroke: this.getStroke() ? this.getStroke().clone() : void 0, rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), scale: Array.isArray(t) ? t.slice() : t, displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() });
          return e.setOpacity(this.getOpacity()), e;
        }
        getAnchor() {
          const t = this.size_, e = this.getDisplacement(), i = this.getScaleArray();
          return [t[0] / 2 - e[0] / i[0], t[1] / 2 + e[1] / i[1]];
        }
        getAngle() {
          return this.angle_;
        }
        getFill() {
          return this.fill_;
        }
        setFill(t) {
          this.fill_ = t, this.render();
        }
        getHitDetectionImage() {
          return this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(this.renderOptions_)), this.hitDetectionCanvas_;
        }
        getImage(t) {
          let e = this.canvases_[t];
          if (!e) {
            const i = this.renderOptions_, r = dn(i.size * t, i.size * t);
            this.draw_(i, r, t), e = r.canvas, this.canvases_[t] = e;
          }
          return e;
        }
        getPixelRatio(t) {
          return t;
        }
        getImageSize() {
          return this.size_;
        }
        getImageState() {
          return this.imageState_;
        }
        getOrigin() {
          return this.origin_;
        }
        getPoints() {
          return this.points_;
        }
        getRadius() {
          return this.radius;
        }
        getRadius2() {
          return this.radius2_;
        }
        getSize() {
          return this.size_;
        }
        getStroke() {
          return this.stroke_;
        }
        setStroke(t) {
          this.stroke_ = t, this.render();
        }
        listenImageChange(t) {
        }
        load() {
        }
        unlistenImageChange(t) {
        }
        calculateLineJoinSize_(t, e, i) {
          if (e === 0 || this.points_ === 1 / 0 || t !== "bevel" && t !== "miter") return e;
          let r = this.radius, a = this.radius2_ === void 0 ? r : this.radius2_;
          if (r < a) {
            const I = r;
            r = a, a = I;
          }
          const o = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, s = 2 * Math.PI / o, l = a * Math.sin(s), u = Math.sqrt(a * a - l * l), h = r - u, c = Math.sqrt(l * l + h * h), f = c / l;
          if (t === "miter" && f <= i) return f * e;
          const g = e / 2 / f, d = e / 2 * (h / c), p = Math.sqrt((r + g) * (r + g) + d * d) - r;
          if (this.radius2_ === void 0 || t === "bevel") return p * 2;
          const v = r * Math.sin(s), y = Math.sqrt(r * r - v * v), m = a - y, E = Math.sqrt(v * v + m * m) / v;
          if (E <= i) {
            const I = E * e / 2 - a - r;
            return 2 * Math.max(p, I);
          }
          return p * 2;
        }
        createRenderOptions() {
          var c, f, g, d, A, p;
          let t = Vc, e = jc, i = 0, r = null, a = 0, o, s = 0;
          this.stroke_ && (o = so((c = this.stroke_.getColor()) != null ? c : eA), s = (f = this.stroke_.getWidth()) != null ? f : iA, r = this.stroke_.getLineDash(), a = (g = this.stroke_.getLineDashOffset()) != null ? g : 0, e = (d = this.stroke_.getLineJoin()) != null ? d : jc, t = (A = this.stroke_.getLineCap()) != null ? A : Vc, i = (p = this.stroke_.getMiterLimit()) != null ? p : tA);
          const l = this.calculateLineJoinSize_(e, s, i), u = Math.max(this.radius, this.radius2_ || 0), h = Math.ceil(2 * u + l);
          return { strokeStyle: o, strokeWidth: s, size: h, lineCap: t, lineDash: r, lineDashOffset: a, lineJoin: e, miterLimit: i };
        }
        render() {
          this.renderOptions_ = this.createRenderOptions();
          const t = this.renderOptions_.size;
          this.canvases_ = {}, this.hitDetectionCanvas_ = null, this.size_ = [t, t];
        }
        draw_(t, e, i) {
          if (e.scale(i, i), e.translate(t.size / 2, t.size / 2), this.createPath_(e), this.fill_) {
            let r = this.fill_.getColor();
            r === null && (r = ar), e.fillStyle = so(r), e.fill();
          }
          t.strokeStyle && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineCap = t.lineCap, e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke());
        }
        createHitDetectionCanvas_(t) {
          let e;
          if (this.fill_) {
            let i = this.fill_.getColor(), r = 0;
            typeof i == "string" && (i = hl(i)), i === null ? r = 1 : Array.isArray(i) && (r = i.length === 4 ? i[3] : 1), r === 0 && (e = dn(t.size, t.size), this.drawHitDetectionCanvas_(t, e));
          }
          return e ? e.canvas : this.getImage(1);
        }
        createPath_(t) {
          let e = this.points_;
          const i = this.radius;
          if (e === 1 / 0) t.arc(0, 0, i, 0, 2 * Math.PI);
          else {
            const r = this.radius2_ === void 0 ? i : this.radius2_;
            this.radius2_ !== void 0 && (e *= 2);
            const a = this.angle_ - Math.PI / 2, o = 2 * Math.PI / e;
            for (let s = 0; s < e; s++) {
              const l = a + s * o, u = s % 2 === 0 ? i : r;
              t.lineTo(u * Math.cos(l), u * Math.sin(l));
            }
            t.closePath();
          }
        }
        drawHitDetectionCanvas_(t, e) {
          e.translate(t.size / 2, t.size / 2), this.createPath_(e), e.fillStyle = ar, e.fill(), t.strokeStyle && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke());
        }
        ready() {
          return this.fill_ ? this.fill_.ready() : Promise.resolve();
        }
      }
      class Mr extends Nu {
        constructor(t) {
          t = t || { radius: 5 }, super({ points: 1 / 0, fill: t.fill, radius: t.radius, stroke: t.stroke, scale: t.scale !== void 0 ? t.scale : 1, rotation: t.rotation !== void 0 ? t.rotation : 0, rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : false, displacement: t.displacement !== void 0 ? t.displacement : [0, 0], declutterMode: t.declutterMode });
        }
        clone() {
          const t = this.getScale(), e = new Mr({ fill: this.getFill() ? this.getFill().clone() : void 0, stroke: this.getStroke() ? this.getStroke().clone() : void 0, radius: this.getRadius(), scale: Array.isArray(t) ? t.slice() : t, rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() });
          return e.setOpacity(this.getOpacity()), e;
        }
        setRadius(t) {
          this.radius = t, this.render();
        }
      }
      class de {
        constructor(t) {
          t = t || {}, this.geometry_ = null, this.geometryFunction_ = OP, t.geometry !== void 0 && this.setGeometry(t.geometry), this.fill_ = t.fill !== void 0 ? t.fill : null, this.image_ = t.image !== void 0 ? t.image : null, this.renderer_ = t.renderer !== void 0 ? t.renderer : null, this.hitDetectionRenderer_ = t.hitDetectionRenderer !== void 0 ? t.hitDetectionRenderer : null, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.text_ = t.text !== void 0 ? t.text : null, this.zIndex_ = t.zIndex;
        }
        clone() {
          var e;
          let t = this.getGeometry();
          return t && typeof t == "object" && (t = t.clone()), new de({ geometry: t != null ? t : void 0, fill: this.getFill() ? this.getFill().clone() : void 0, image: this.getImage() ? this.getImage().clone() : void 0, renderer: (e = this.getRenderer()) != null ? e : void 0, stroke: this.getStroke() ? this.getStroke().clone() : void 0, text: this.getText() ? this.getText().clone() : void 0, zIndex: this.getZIndex() });
        }
        getRenderer() {
          return this.renderer_;
        }
        setRenderer(t) {
          this.renderer_ = t;
        }
        setHitDetectionRenderer(t) {
          this.hitDetectionRenderer_ = t;
        }
        getHitDetectionRenderer() {
          return this.hitDetectionRenderer_;
        }
        getGeometry() {
          return this.geometry_;
        }
        getGeometryFunction() {
          return this.geometryFunction_;
        }
        getFill() {
          return this.fill_;
        }
        setFill(t) {
          this.fill_ = t;
        }
        getImage() {
          return this.image_;
        }
        setImage(t) {
          this.image_ = t;
        }
        getStroke() {
          return this.stroke_;
        }
        setStroke(t) {
          this.stroke_ = t;
        }
        getText() {
          return this.text_;
        }
        setText(t) {
          this.text_ = t;
        }
        getZIndex() {
          return this.zIndex_;
        }
        setGeometry(t) {
          typeof t == "function" ? this.geometryFunction_ = t : typeof t == "string" ? this.geometryFunction_ = function(e) {
            return e.get(t);
          } : t ? t !== void 0 && (this.geometryFunction_ = function() {
            return t;
          }) : this.geometryFunction_ = OP, this.geometry_ = t;
        }
        setZIndex(t) {
          this.zIndex_ = t;
        }
      }
      function dK(n) {
        let t;
        if (typeof n == "function") t = n;
        else {
          let e;
          Array.isArray(n) ? e = n : (he(typeof n.getZIndex == "function", "Expected an `Style` or an array of `Style`"), e = [n]), t = function() {
            return e;
          };
        }
        return t;
      }
      let Lx = null;
      function FP(n, t) {
        if (!Lx) {
          const e = new ye({ color: "rgba(255,255,255,0.4)" }), i = new Ze({ color: "#3399CC", width: 1.25 });
          Lx = [new de({ image: new Mr({ fill: e, stroke: i, radius: 5 }), fill: e, stroke: i })];
        }
        return Lx;
      }
      function QP() {
        const n = {}, t = [255, 255, 255, 1], e = [0, 153, 255, 1], i = 3;
        return n.Polygon = [new de({ fill: new ye({ color: [255, 255, 255, 0.5] }) })], n.MultiPolygon = n.Polygon, n.LineString = [new de({ stroke: new Ze({ color: t, width: i + 2 }) }), new de({ stroke: new Ze({ color: e, width: i }) })], n.MultiLineString = n.LineString, n.Circle = n.Polygon.concat(n.LineString), n.Point = [new de({ image: new Mr({ radius: i * 2, fill: new ye({ color: e }), stroke: new Ze({ color: t, width: i / 2 }) }), zIndex: 1 / 0 })], n.MultiPoint = n.Point, n.GeometryCollection = n.Polygon.concat(n.LineString, n.Point), n;
      }
      function OP(n) {
        return n.getGeometry();
      }
      const AK = "#333";
      class Ei {
        constructor(t) {
          t = t || {}, this.font_ = t.font, this.rotation_ = t.rotation, this.rotateWithView_ = t.rotateWithView, this.scale_ = t.scale, this.scaleArray_ = bn(t.scale !== void 0 ? t.scale : 1), this.text_ = t.text, this.textAlign_ = t.textAlign, this.justify_ = t.justify, this.repeat_ = t.repeat, this.textBaseline_ = t.textBaseline, this.fill_ = t.fill !== void 0 ? t.fill : new ye({ color: AK }), this.maxAngle_ = t.maxAngle !== void 0 ? t.maxAngle : Math.PI / 4, this.placement_ = t.placement !== void 0 ? t.placement : "point", this.overflow_ = !!t.overflow, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.offsetX_ = t.offsetX !== void 0 ? t.offsetX : 0, this.offsetY_ = t.offsetY !== void 0 ? t.offsetY : 0, this.backgroundFill_ = t.backgroundFill ? t.backgroundFill : null, this.backgroundStroke_ = t.backgroundStroke ? t.backgroundStroke : null, this.padding_ = t.padding === void 0 ? null : t.padding, this.declutterMode_ = t.declutterMode;
        }
        clone() {
          const t = this.getScale();
          return new Ei({ font: this.getFont(), placement: this.getPlacement(), repeat: this.getRepeat(), maxAngle: this.getMaxAngle(), overflow: this.getOverflow(), rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), scale: Array.isArray(t) ? t.slice() : t, text: this.getText(), textAlign: this.getTextAlign(), justify: this.getJustify(), textBaseline: this.getTextBaseline(), fill: this.getFill() ? this.getFill().clone() : void 0, stroke: this.getStroke() ? this.getStroke().clone() : void 0, offsetX: this.getOffsetX(), offsetY: this.getOffsetY(), backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0, backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0, padding: this.getPadding() || void 0, declutterMode: this.getDeclutterMode() });
        }
        getOverflow() {
          return this.overflow_;
        }
        getFont() {
          return this.font_;
        }
        getMaxAngle() {
          return this.maxAngle_;
        }
        getPlacement() {
          return this.placement_;
        }
        getRepeat() {
          return this.repeat_;
        }
        getOffsetX() {
          return this.offsetX_;
        }
        getOffsetY() {
          return this.offsetY_;
        }
        getFill() {
          return this.fill_;
        }
        getRotateWithView() {
          return this.rotateWithView_;
        }
        getRotation() {
          return this.rotation_;
        }
        getScale() {
          return this.scale_;
        }
        getScaleArray() {
          return this.scaleArray_;
        }
        getStroke() {
          return this.stroke_;
        }
        getText() {
          return this.text_;
        }
        getTextAlign() {
          return this.textAlign_;
        }
        getJustify() {
          return this.justify_;
        }
        getTextBaseline() {
          return this.textBaseline_;
        }
        getBackgroundFill() {
          return this.backgroundFill_;
        }
        getBackgroundStroke() {
          return this.backgroundStroke_;
        }
        getPadding() {
          return this.padding_;
        }
        getDeclutterMode() {
          return this.declutterMode_;
        }
        setOverflow(t) {
          this.overflow_ = t;
        }
        setFont(t) {
          this.font_ = t;
        }
        setMaxAngle(t) {
          this.maxAngle_ = t;
        }
        setOffsetX(t) {
          this.offsetX_ = t;
        }
        setOffsetY(t) {
          this.offsetY_ = t;
        }
        setPlacement(t) {
          this.placement_ = t;
        }
        setRepeat(t) {
          this.repeat_ = t;
        }
        setRotateWithView(t) {
          this.rotateWithView_ = t;
        }
        setFill(t) {
          this.fill_ = t;
        }
        setRotation(t) {
          this.rotation_ = t;
        }
        setScale(t) {
          this.scale_ = t, this.scaleArray_ = bn(t !== void 0 ? t : 1);
        }
        setStroke(t) {
          this.stroke_ = t;
        }
        setText(t) {
          this.text_ = t;
        }
        setTextAlign(t) {
          this.textAlign_ = t;
        }
        setJustify(t) {
          this.justify_ = t;
        }
        setTextBaseline(t) {
          this.textBaseline_ = t;
        }
        setBackgroundFill(t) {
          this.backgroundFill_ = t;
        }
        setBackgroundStroke(t) {
          this.backgroundStroke_ = t;
        }
        setPadding(t) {
          this.padding_ = t;
        }
      }
      const ke = { OPACITY: "opacity", VISIBLE: "visible", EXTENT: "extent", Z_INDEX: "zIndex", MAX_RESOLUTION: "maxResolution", MIN_RESOLUTION: "minResolution", MAX_ZOOM: "maxZoom", MIN_ZOOM: "minZoom", SOURCE: "source", MAP: "map" };
      class zP extends Yr {
        constructor(t) {
          super(), this.on, this.once, this.un, this.background_ = t.background;
          const e = Object.assign({}, t);
          typeof t.properties == "object" && (delete e.properties, Object.assign(e, t.properties)), e[ke.OPACITY] = t.opacity !== void 0 ? t.opacity : 1, he(typeof e[ke.OPACITY] == "number", "Layer opacity must be a number"), e[ke.VISIBLE] = t.visible !== void 0 ? t.visible : true, e[ke.Z_INDEX] = t.zIndex, e[ke.MAX_RESOLUTION] = t.maxResolution !== void 0 ? t.maxResolution : 1 / 0, e[ke.MIN_RESOLUTION] = t.minResolution !== void 0 ? t.minResolution : 0, e[ke.MIN_ZOOM] = t.minZoom !== void 0 ? t.minZoom : -1 / 0, e[ke.MAX_ZOOM] = t.maxZoom !== void 0 ? t.maxZoom : 1 / 0, this.className_ = e.className !== void 0 ? e.className : "ol-layer", delete e.className, this.setProperties(e), this.state_ = null;
        }
        getBackground() {
          return this.background_;
        }
        getClassName() {
          return this.className_;
        }
        getLayerState(t) {
          const e = this.state_ || { layer: this, managed: t === void 0 ? true : t }, i = this.getZIndex();
          return e.opacity = en(Math.round(this.getOpacity() * 100) / 100, 0, 1), e.visible = this.getVisible(), e.extent = this.getExtent(), e.zIndex = i === void 0 && !e.managed ? 1 / 0 : i, e.maxResolution = this.getMaxResolution(), e.minResolution = Math.max(this.getMinResolution(), 0), e.minZoom = this.getMinZoom(), e.maxZoom = this.getMaxZoom(), this.state_ = e, e;
        }
        getLayersArray(t) {
          return Qt();
        }
        getLayerStatesArray(t) {
          return Qt();
        }
        getExtent() {
          return this.get(ke.EXTENT);
        }
        getMaxResolution() {
          return this.get(ke.MAX_RESOLUTION);
        }
        getMinResolution() {
          return this.get(ke.MIN_RESOLUTION);
        }
        getMinZoom() {
          return this.get(ke.MIN_ZOOM);
        }
        getMaxZoom() {
          return this.get(ke.MAX_ZOOM);
        }
        getOpacity() {
          return this.get(ke.OPACITY);
        }
        getSourceState() {
          return Qt();
        }
        getVisible() {
          return this.get(ke.VISIBLE);
        }
        getZIndex() {
          return this.get(ke.Z_INDEX);
        }
        setBackground(t) {
          this.background_ = t, this.changed();
        }
        setExtent(t) {
          this.set(ke.EXTENT, t);
        }
        setMaxResolution(t) {
          this.set(ke.MAX_RESOLUTION, t);
        }
        setMinResolution(t) {
          this.set(ke.MIN_RESOLUTION, t);
        }
        setMaxZoom(t) {
          this.set(ke.MAX_ZOOM, t);
        }
        setMinZoom(t) {
          this.set(ke.MIN_ZOOM, t);
        }
        setOpacity(t) {
          he(typeof t == "number", "Layer opacity must be a number"), this.set(ke.OPACITY, t);
        }
        setVisible(t) {
          this.set(ke.VISIBLE, t);
        }
        setZIndex(t) {
          this.set(ke.Z_INDEX, t);
        }
        disposeInternal() {
          this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
        }
      }
      const Fn = { ANIMATING: 0, INTERACTING: 1 }, Dr = { CENTER: "center", RESOLUTION: "resolution", ROTATION: "rotation" }, pK = 42, Px = 256;
      function GP(n, t, e) {
        return function(i, r, a, o, s) {
          if (!i) return;
          if (!r && !t) return i;
          const l = t ? 0 : a[0] * r, u = t ? 0 : a[1] * r, h = s ? s[0] : 0, c = s ? s[1] : 0;
          let f = n[0] + l / 2 + h, g = n[2] - l / 2 + h, d = n[1] + u / 2 + c, A = n[3] - u / 2 + c;
          f > g && (f = (g + f) / 2, g = f), d > A && (d = (A + d) / 2, A = d);
          let p = en(i[0], f, g), v = en(i[1], d, A);
          if (o && e && r) {
            const y = 30 * r;
            p += -y * Math.log(1 + Math.max(0, f - i[0]) / y) + y * Math.log(1 + Math.max(0, i[0] - g) / y), v += -y * Math.log(1 + Math.max(0, d - i[1]) / y) + y * Math.log(1 + Math.max(0, i[1] - A) / y);
          }
          return [p, v];
        };
      }
      function vK(n) {
        return n;
      }
      function Nx(n, t, e, i) {
        const r = ve(t) / e[0], a = Cn(t) / e[1];
        return i ? Math.min(n, Math.max(r, a)) : Math.min(n, Math.min(r, a));
      }
      function kx(n, t, e) {
        let i = Math.min(n, t);
        const r = 50;
        return i *= Math.log(1 + r * Math.max(0, n / t - 1)) / r + 1, e && (i = Math.max(i, e), i /= Math.log(1 + r * Math.max(0, e / n - 1)) / r + 1), en(i, e / 2, t * 2);
      }
      function yK(n, t, e, i) {
        return t = t !== void 0 ? t : true, function(r, a, o, s) {
          if (r !== void 0) {
            const l = n[0], u = n[n.length - 1], h = e ? Nx(l, e, o, i) : l;
            if (s) return t ? kx(r, h, u) : en(r, u, h);
            const c = Math.min(h, r), f = Math.floor(Hr(n, c, a));
            return n[f] > h && f < n.length - 1 ? n[f + 1] : n[f];
          }
        };
      }
      function mK(n, t, e, i, r, a) {
        return i = i !== void 0 ? i : true, e = e !== void 0 ? e : 0, function(o, s, l, u) {
          if (o !== void 0) {
            const h = r ? Nx(t, r, l, a) : t;
            if (u) return i ? kx(o, h, e) : en(o, e, h);
            const c = 1e-9, f = Math.ceil(Math.log(t / h) / Math.log(n) - c), g = -s * (0.5 - c) + 0.5, d = Math.min(h, o), A = Math.floor(Math.log(t / d) / Math.log(n) + g), p = Math.max(f, A), v = t / Math.pow(n, p);
            return en(v, e, h);
          }
        };
      }
      function UP(n, t, e, i, r) {
        return e = e !== void 0 ? e : true, function(a, o, s, l) {
          if (a !== void 0) {
            const u = i ? Nx(n, i, s, r) : n;
            return !e || !l ? en(a, t, u) : kx(a, u, t);
          }
        };
      }
      function Fx(n) {
        if (n !== void 0) return 0;
      }
      function VP(n) {
        if (n !== void 0) return n;
      }
      function _K(n) {
        const t = 2 * Math.PI / n;
        return function(e, i) {
          if (i) return e;
          if (e !== void 0) return e = Math.floor(e / t + 0.5) * t, e;
        };
      }
      function IK(n) {
        const t = sl(5);
        return function(e, i) {
          return i || e === void 0 ? e : Math.abs(e) <= t ? 0 : e;
        };
      }
      function jP(n) {
        return Math.pow(n, 3);
      }
      function Hc(n) {
        return 1 - jP(1 - n);
      }
      function EK(n) {
        return 3 * n * n - 2 * n * n * n;
      }
      function xK(n) {
        return n;
      }
      const Qx = 0;
      let La = class extends Yr {
        constructor(t) {
          super(), this.on, this.once, this.un, t = Object.assign({}, t), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = ax(t.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, t.projection && XL(), t.center && (t.center = qe(t.center, this.projection_)), t.extent && (t.extent = Ni(t.extent, this.projection_)), this.applyOptions_(t);
        }
        applyOptions_(t) {
          const e = Object.assign({}, t);
          for (const s in Dr) delete e[s];
          this.setProperties(e, true);
          const i = CK(t);
          this.maxResolution_ = i.maxResolution, this.minResolution_ = i.minResolution, this.zoomFactor_ = i.zoomFactor, this.resolutions_ = t.resolutions, this.padding_ = t.padding, this.minZoom_ = i.minZoom;
          const r = wK(t), a = i.constraint, o = SK(t);
          this.constraints_ = { center: r, resolution: a, rotation: o }, this.setRotation(t.rotation !== void 0 ? t.rotation : 0), this.setCenterInternal(t.center !== void 0 ? t.center : null), t.resolution !== void 0 ? this.setResolution(t.resolution) : t.zoom !== void 0 && this.setZoom(t.zoom);
        }
        get padding() {
          return this.padding_;
        }
        set padding(t) {
          let e = this.padding_;
          this.padding_ = t;
          const i = this.getCenterInternal();
          if (i) {
            const r = t || [0, 0, 0, 0];
            e = e || [0, 0, 0, 0];
            const a = this.getResolution(), o = a / 2 * (r[3] - e[3] + e[1] - r[1]), s = a / 2 * (r[0] - e[0] + e[2] - r[2]);
            this.setCenterInternal([i[0] + o, i[1] - s]);
          }
        }
        getUpdatedOptions_(t) {
          const e = this.getProperties();
          return e.resolution !== void 0 ? e.resolution = this.getResolution() : e.zoom = this.getZoom(), e.center = this.getCenterInternal(), e.rotation = this.getRotation(), Object.assign({}, e, t);
        }
        animate(t) {
          this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
          const e = new Array(arguments.length);
          for (let i = 0; i < e.length; ++i) {
            let r = arguments[i];
            r.center && (r = Object.assign({}, r), r.center = qe(r.center, this.getProjection())), r.anchor && (r = Object.assign({}, r), r.anchor = qe(r.anchor, this.getProjection())), e[i] = r;
          }
          this.animateInternal.apply(this, e);
        }
        animateInternal(t) {
          let e = arguments.length, i;
          e > 1 && typeof arguments[e - 1] == "function" && (i = arguments[e - 1], --e);
          let r = 0;
          for (; r < e && !this.isDef(); ++r) {
            const h = arguments[r];
            h.center && this.setCenterInternal(h.center), h.zoom !== void 0 ? this.setZoom(h.zoom) : h.resolution && this.setResolution(h.resolution), h.rotation !== void 0 && this.setRotation(h.rotation);
          }
          if (r === e) {
            i && s0(i, true);
            return;
          }
          let a = Date.now(), o = this.targetCenter_.slice(), s = this.targetResolution_, l = this.targetRotation_;
          const u = [];
          for (; r < e; ++r) {
            const h = arguments[r], c = { start: a, complete: false, anchor: h.anchor, duration: h.duration !== void 0 ? h.duration : 1e3, easing: h.easing || EK, callback: i };
            if (h.center && (c.sourceCenter = o, c.targetCenter = h.center.slice(), o = c.targetCenter), h.zoom !== void 0 ? (c.sourceResolution = s, c.targetResolution = this.getResolutionForZoom(h.zoom), s = c.targetResolution) : h.resolution && (c.sourceResolution = s, c.targetResolution = h.resolution, s = c.targetResolution), h.rotation !== void 0) {
              c.sourceRotation = l;
              const f = rs(h.rotation - l + Math.PI, 2 * Math.PI) - Math.PI;
              c.targetRotation = l + f, l = c.targetRotation;
            }
            bK(c) ? c.complete = true : a += c.duration, u.push(c);
          }
          this.animations_.push(u), this.setHint(Fn.ANIMATING, 1), this.updateAnimations_();
        }
        getAnimating() {
          return this.hints_[Fn.ANIMATING] > 0;
        }
        getInteracting() {
          return this.hints_[Fn.INTERACTING] > 0;
        }
        cancelAnimations() {
          this.setHint(Fn.ANIMATING, -this.hints_[Fn.ANIMATING]);
          let t;
          for (let e = 0, i = this.animations_.length; e < i; ++e) {
            const r = this.animations_[e];
            if (r[0].callback && s0(r[0].callback, false), !t) for (let a = 0, o = r.length; a < o; ++a) {
              const s = r[a];
              if (!s.complete) {
                t = s.anchor;
                break;
              }
            }
          }
          this.animations_.length = 0, this.cancelAnchor_ = t, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        }
        updateAnimations_() {
          if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating()) return;
          const t = Date.now();
          let e = false;
          for (let i = this.animations_.length - 1; i >= 0; --i) {
            const r = this.animations_[i];
            let a = true;
            for (let o = 0, s = r.length; o < s; ++o) {
              const l = r[o];
              if (l.complete) continue;
              const u = t - l.start;
              let h = l.duration > 0 ? u / l.duration : 1;
              h >= 1 ? (l.complete = true, h = 1) : a = false;
              const c = l.easing(h);
              if (l.sourceCenter) {
                const f = l.sourceCenter[0], g = l.sourceCenter[1], d = l.targetCenter[0], A = l.targetCenter[1];
                this.nextCenter_ = l.targetCenter;
                const p = f + c * (d - f), v = g + c * (A - g);
                this.targetCenter_ = [p, v];
              }
              if (l.sourceResolution && l.targetResolution) {
                const f = c === 1 ? l.targetResolution : l.sourceResolution + c * (l.targetResolution - l.sourceResolution);
                if (l.anchor) {
                  const g = this.getViewportSize_(this.getRotation()), d = this.constraints_.resolution(f, 0, g, true);
                  this.targetCenter_ = this.calculateCenterZoom(d, l.anchor);
                }
                this.nextResolution_ = l.targetResolution, this.targetResolution_ = f, this.applyTargetState_(true);
              }
              if (l.sourceRotation !== void 0 && l.targetRotation !== void 0) {
                const f = c === 1 ? rs(l.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : l.sourceRotation + c * (l.targetRotation - l.sourceRotation);
                if (l.anchor) {
                  const g = this.constraints_.rotation(f, true);
                  this.targetCenter_ = this.calculateCenterRotate(g, l.anchor);
                }
                this.nextRotation_ = l.targetRotation, this.targetRotation_ = f;
              }
              if (this.applyTargetState_(true), e = true, !l.complete) break;
            }
            if (a) {
              this.animations_[i] = null, this.setHint(Fn.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
              const o = r[0].callback;
              o && s0(o, true);
            }
          }
          this.animations_ = this.animations_.filter(Boolean), e && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this)));
        }
        calculateCenterRotate(t, e) {
          let i;
          const r = this.getCenterInternal();
          return r !== void 0 && (i = [r[0] - e[0], r[1] - e[1]], JE(i, t - this.getRotation()), GL(i, e)), i;
        }
        calculateCenterZoom(t, e) {
          let i;
          const r = this.getCenterInternal(), a = this.getResolution();
          if (r !== void 0 && a !== void 0) {
            const o = e[0] - t * (e[0] - r[0]) / a, s = e[1] - t * (e[1] - r[1]) / a;
            i = [o, s];
          }
          return i;
        }
        getViewportSize_(t) {
          const e = this.viewportSize_;
          if (t) {
            const i = e[0], r = e[1];
            return [Math.abs(i * Math.cos(t)) + Math.abs(r * Math.sin(t)), Math.abs(i * Math.sin(t)) + Math.abs(r * Math.cos(t))];
          }
          return e;
        }
        setViewportSize(t) {
          this.viewportSize_ = Array.isArray(t) ? t.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
        }
        getCenter() {
          const t = this.getCenterInternal();
          return t && os(t, this.getProjection());
        }
        getCenterInternal() {
          return this.get(Dr.CENTER);
        }
        getConstraints() {
          return this.constraints_;
        }
        getConstrainResolution() {
          return this.get("constrainResolution");
        }
        getHints(t) {
          return t !== void 0 ? (t[0] = this.hints_[0], t[1] = this.hints_[1], t) : this.hints_.slice();
        }
        calculateExtent(t) {
          const e = this.calculateExtentInternal(t);
          return qd(e, this.getProjection());
        }
        calculateExtentInternal(t) {
          t = t || this.getViewportSizeMinusPadding_();
          const e = this.getCenterInternal();
          he(e, "The view center is not defined");
          const i = this.getResolution();
          he(i !== void 0, "The view resolution is not defined");
          const r = this.getRotation();
          return he(r !== void 0, "The view rotation is not defined"), zd(e, i, r, t);
        }
        getMaxResolution() {
          return this.maxResolution_;
        }
        getMinResolution() {
          return this.minResolution_;
        }
        getMaxZoom() {
          return this.getZoomForResolution(this.minResolution_);
        }
        setMaxZoom(t) {
          this.applyOptions_(this.getUpdatedOptions_({ maxZoom: t }));
        }
        getMinZoom() {
          return this.getZoomForResolution(this.maxResolution_);
        }
        setMinZoom(t) {
          this.applyOptions_(this.getUpdatedOptions_({ minZoom: t }));
        }
        setConstrainResolution(t) {
          this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: t }));
        }
        getProjection() {
          return this.projection_;
        }
        getResolution() {
          return this.get(Dr.RESOLUTION);
        }
        getResolutions() {
          return this.resolutions_;
        }
        getResolutionForExtent(t, e) {
          return this.getResolutionForExtentInternal(Ni(t, this.getProjection()), e);
        }
        getResolutionForExtentInternal(t, e) {
          e = e || this.getViewportSizeMinusPadding_();
          const i = ve(t) / e[0], r = Cn(t) / e[1];
          return Math.max(i, r);
        }
        getResolutionForValueFunction(t) {
          t = t || 2;
          const e = this.getConstrainedResolution(this.maxResolution_), i = this.minResolution_, r = Math.log(e / i) / Math.log(t);
          return function(a) {
            return e / Math.pow(t, a * r);
          };
        }
        getRotation() {
          return this.get(Dr.ROTATION);
        }
        getValueForResolutionFunction(t) {
          const e = Math.log(t || 2), i = this.getConstrainedResolution(this.maxResolution_), r = this.minResolution_, a = Math.log(i / r) / e;
          return function(o) {
            return Math.log(i / o) / e / a;
          };
        }
        getViewportSizeMinusPadding_(t) {
          let e = this.getViewportSize_(t);
          const i = this.padding_;
          return i && (e = [e[0] - i[1] - i[3], e[1] - i[0] - i[2]]), e;
        }
        getState() {
          const t = this.getProjection(), e = this.getResolution(), i = this.getRotation();
          let r = this.getCenterInternal();
          const a = this.padding_;
          if (a) {
            const o = this.getViewportSizeMinusPadding_();
            r = Ox(r, this.getViewportSize_(), [o[0] / 2 + a[3], o[1] / 2 + a[0]], e, i);
          }
          return { center: r.slice(0), projection: t !== void 0 ? t : null, resolution: e, nextCenter: this.nextCenter_, nextResolution: this.nextResolution_, nextRotation: this.nextRotation_, rotation: i, zoom: this.getZoom() };
        }
        getViewStateAndExtent() {
          return { viewState: this.getState(), extent: this.calculateExtent() };
        }
        getZoom() {
          let t;
          const e = this.getResolution();
          return e !== void 0 && (t = this.getZoomForResolution(e)), t;
        }
        getZoomForResolution(t) {
          let e = this.minZoom_ || 0, i, r;
          if (this.resolutions_) {
            const a = Hr(this.resolutions_, t, 1);
            e = a, i = this.resolutions_[a], a == this.resolutions_.length - 1 ? r = 2 : r = i / this.resolutions_[a + 1];
          } else i = this.maxResolution_, r = this.zoomFactor_;
          return e + Math.log(i / t) / Math.log(r);
        }
        getResolutionForZoom(t) {
          var e;
          if ((e = this.resolutions_) != null && e.length) {
            if (this.resolutions_.length === 1) return this.resolutions_[0];
            const i = en(Math.floor(t), 0, this.resolutions_.length - 2), r = this.resolutions_[i] / this.resolutions_[i + 1];
            return this.resolutions_[i] / Math.pow(r, en(t - i, 0, 1));
          }
          return this.maxResolution_ / Math.pow(this.zoomFactor_, t - this.minZoom_);
        }
        fit(t, e) {
          let i;
          if (he(Array.isArray(t) || typeof t.getSimplifiedGeometry == "function", "Invalid extent or geometry provided as `geometry`"), Array.isArray(t)) {
            he(!ns(t), "Cannot fit empty extent provided as `geometry`");
            const r = Ni(t, this.getProjection());
            i = yx(r);
          } else if (t.getType() === "Circle") {
            const r = Ni(t.getExtent(), this.getProjection());
            i = yx(r), i.rotate(this.getRotation(), Br(r));
          } else i = t;
          this.fitInternal(i, e);
        }
        rotatedExtentForGeometry(t) {
          const e = this.getRotation(), i = Math.cos(e), r = Math.sin(-e), a = t.getFlatCoordinates(), o = t.getStride();
          let s = 1 / 0, l = 1 / 0, u = -1 / 0, h = -1 / 0;
          for (let c = 0, f = a.length; c < f; c += o) {
            const g = a[c] * i - a[c + 1] * r, d = a[c] * r + a[c + 1] * i;
            s = Math.min(s, g), l = Math.min(l, d), u = Math.max(u, g), h = Math.max(h, d);
          }
          return [s, l, u, h];
        }
        fitInternal(t, e) {
          e = e || {};
          let i = e.size;
          i || (i = this.getViewportSizeMinusPadding_());
          const r = e.padding !== void 0 ? e.padding : [0, 0, 0, 0], a = e.nearest !== void 0 ? e.nearest : false;
          let o;
          e.minResolution !== void 0 ? o = e.minResolution : e.maxZoom !== void 0 ? o = this.getResolutionForZoom(e.maxZoom) : o = 0;
          const s = this.rotatedExtentForGeometry(t);
          let l = this.getResolutionForExtentInternal(s, [i[0] - r[1] - r[3], i[1] - r[0] - r[2]]);
          l = isNaN(l) ? o : Math.max(l, o), l = this.getConstrainedResolution(l, a ? 0 : 1);
          const u = this.getRotation(), h = Math.sin(u), c = Math.cos(u), f = Br(s);
          f[0] += (r[1] - r[3]) / 2 * l, f[1] += (r[0] - r[2]) / 2 * l;
          const g = f[0] * c - f[1] * h, d = f[1] * c + f[0] * h, A = this.getConstrainedCenter([g, d], l), p = e.callback ? e.callback : Tc;
          e.duration !== void 0 ? this.animateInternal({ resolution: l, center: A, duration: e.duration, easing: e.easing }, p) : (this.targetResolution_ = l, this.targetCenter_ = A, this.applyTargetState_(false, true), s0(p, true));
        }
        centerOn(t, e, i) {
          this.centerOnInternal(qe(t, this.getProjection()), e, i);
        }
        centerOnInternal(t, e, i) {
          this.setCenterInternal(Ox(t, e, i, this.getResolution(), this.getRotation()));
        }
        calculateCenterShift(t, e, i, r) {
          let a;
          const o = this.padding_;
          if (o && t) {
            const s = this.getViewportSizeMinusPadding_(-i), l = Ox(t, r, [s[0] / 2 + o[3], s[1] / 2 + o[0]], e, i);
            a = [t[0] - l[0], t[1] - l[1]];
          }
          return a;
        }
        isDef() {
          return !!this.getCenterInternal() && this.getResolution() !== void 0;
        }
        adjustCenter(t) {
          const e = os(this.targetCenter_, this.getProjection());
          this.setCenter([e[0] + t[0], e[1] + t[1]]);
        }
        adjustCenterInternal(t) {
          const e = this.targetCenter_;
          this.setCenterInternal([e[0] + t[0], e[1] + t[1]]);
        }
        adjustResolution(t, e) {
          e = e && qe(e, this.getProjection()), this.adjustResolutionInternal(t, e);
        }
        adjustResolutionInternal(t, e) {
          const i = this.getAnimating() || this.getInteracting(), r = this.getViewportSize_(this.getRotation()), a = this.constraints_.resolution(this.targetResolution_ * t, 0, r, i);
          e && (this.targetCenter_ = this.calculateCenterZoom(a, e)), this.targetResolution_ *= t, this.applyTargetState_();
        }
        adjustZoom(t, e) {
          this.adjustResolution(Math.pow(this.zoomFactor_, -t), e);
        }
        adjustRotation(t, e) {
          e && (e = qe(e, this.getProjection())), this.adjustRotationInternal(t, e);
        }
        adjustRotationInternal(t, e) {
          const i = this.getAnimating() || this.getInteracting(), r = this.constraints_.rotation(this.targetRotation_ + t, i);
          e && (this.targetCenter_ = this.calculateCenterRotate(r, e)), this.targetRotation_ += t, this.applyTargetState_();
        }
        setCenter(t) {
          this.setCenterInternal(t && qe(t, this.getProjection()));
        }
        setCenterInternal(t) {
          this.targetCenter_ = t, this.applyTargetState_();
        }
        setHint(t, e) {
          return this.hints_[t] += e, this.changed(), this.hints_[t];
        }
        setResolution(t) {
          this.targetResolution_ = t, this.applyTargetState_();
        }
        setRotation(t) {
          this.targetRotation_ = t, this.applyTargetState_();
        }
        setZoom(t) {
          this.setResolution(this.getResolutionForZoom(t));
        }
        applyTargetState_(t, e) {
          const i = this.getAnimating() || this.getInteracting() || e, r = this.constraints_.rotation(this.targetRotation_, i), a = this.getViewportSize_(r), o = this.constraints_.resolution(this.targetResolution_, 0, a, i), s = this.constraints_.center(this.targetCenter_, o, a, i, this.calculateCenterShift(this.targetCenter_, o, r, a));
          this.get(Dr.ROTATION) !== r && this.set(Dr.ROTATION, r), this.get(Dr.RESOLUTION) !== o && (this.set(Dr.RESOLUTION, o), this.set("zoom", this.getZoom(), true)), (!s || !this.get(Dr.CENTER) || !Da(this.get(Dr.CENTER), s)) && this.set(Dr.CENTER, s), this.getAnimating() && !t && this.cancelAnimations(), this.cancelAnchor_ = void 0;
        }
        resolveConstraints(t, e, i) {
          t = t !== void 0 ? t : 200;
          const r = e || 0, a = this.constraints_.rotation(this.targetRotation_), o = this.getViewportSize_(a), s = this.constraints_.resolution(this.targetResolution_, r, o), l = this.constraints_.center(this.targetCenter_, s, o, false, this.calculateCenterShift(this.targetCenter_, s, a, o));
          if (t === 0 && !this.cancelAnchor_) {
            this.targetResolution_ = s, this.targetRotation_ = a, this.targetCenter_ = l, this.applyTargetState_();
            return;
          }
          i = i || (t === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== s || this.getRotation() !== a || !this.getCenterInternal() || !Da(this.getCenterInternal(), l)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({ rotation: a, center: l, resolution: s, duration: t, easing: Hc, anchor: i }));
        }
        beginInteraction() {
          this.resolveConstraints(0), this.setHint(Fn.INTERACTING, 1);
        }
        endInteraction(t, e, i) {
          i = i && qe(i, this.getProjection()), this.endInteractionInternal(t, e, i);
        }
        endInteractionInternal(t, e, i) {
          this.getInteracting() && (this.setHint(Fn.INTERACTING, -1), this.resolveConstraints(t, e, i));
        }
        getConstrainedCenter(t, e) {
          const i = this.getViewportSize_(this.getRotation());
          return this.constraints_.center(t, e || this.getResolution(), i);
        }
        getConstrainedZoom(t, e) {
          const i = this.getResolutionForZoom(t);
          return this.getZoomForResolution(this.getConstrainedResolution(i, e));
        }
        getConstrainedResolution(t, e) {
          e = e || 0;
          const i = this.getViewportSize_(this.getRotation());
          return this.constraints_.resolution(t, e, i);
        }
      };
      function s0(n, t) {
        setTimeout(function() {
          n(t);
        }, 0);
      }
      function wK(n) {
        if (n.extent !== void 0) {
          const e = n.smoothExtentConstraint !== void 0 ? n.smoothExtentConstraint : true;
          return GP(n.extent, n.constrainOnlyCenter, e);
        }
        const t = ax(n.projection, "EPSG:3857");
        if (n.multiWorld !== true && t.isGlobal()) {
          const e = t.getExtent().slice();
          return e[0] = -1 / 0, e[2] = 1 / 0, GP(e, false, false);
        }
        return vK;
      }
      function CK(n) {
        let t, e, i, o = n.minZoom !== void 0 ? n.minZoom : Qx, s = n.maxZoom !== void 0 ? n.maxZoom : 28;
        const l = n.zoomFactor !== void 0 ? n.zoomFactor : 2, u = n.multiWorld !== void 0 ? n.multiWorld : false, h = n.smoothResolutionConstraint !== void 0 ? n.smoothResolutionConstraint : true, c = n.showFullExtent !== void 0 ? n.showFullExtent : false, f = ax(n.projection, "EPSG:3857"), g = f.getExtent();
        let d = n.constrainOnlyCenter, A = n.extent;
        if (!u && !A && f.isGlobal() && (d = false, A = g), n.resolutions !== void 0) {
          const p = n.resolutions;
          e = p[o], i = p[s] !== void 0 ? p[s] : p[p.length - 1], n.constrainResolution ? t = yK(p, h, !d && A, c) : t = UP(e, i, h, !d && A, c);
        } else {
          const v = (g ? Math.max(ve(g), Cn(g)) : 360 * ZE.degrees / f.getMetersPerUnit()) / Px / Math.pow(2, Qx), y = v / Math.pow(2, 28 - Qx);
          e = n.maxResolution, e !== void 0 ? o = 0 : e = v / Math.pow(l, o), i = n.minResolution, i === void 0 && (n.maxZoom !== void 0 ? n.maxResolution !== void 0 ? i = e / Math.pow(l, s) : i = v / Math.pow(l, s) : i = y), s = o + Math.floor(Math.log(e / i) / Math.log(l)), i = e / Math.pow(l, s - o), n.constrainResolution ? t = mK(l, e, i, h, !d && A, c) : t = UP(e, i, h, !d && A, c);
        }
        return { constraint: t, maxResolution: e, minResolution: i, minZoom: o, zoomFactor: l };
      }
      function SK(n) {
        if (n.enableRotation !== void 0 ? n.enableRotation : true) {
          const e = n.constrainRotation;
          return e === void 0 || e === true ? IK() : e === false ? VP : typeof e == "number" ? _K(e) : VP;
        }
        return Fx;
      }
      function bK(n) {
        return !(n.sourceCenter && n.targetCenter && !Da(n.sourceCenter, n.targetCenter) || n.sourceResolution !== n.targetResolution || n.sourceRotation !== n.targetRotation);
      }
      function Ox(n, t, e, i, r) {
        const a = Math.cos(-r);
        let o = Math.sin(-r), s = n[0] * a - n[1] * o, l = n[1] * a + n[0] * o;
        s += (t[0] / 2 - e[0]) * i, l += (e[1] - t[1] / 2) * i, o = -o;
        const u = s * a - l * o, h = l * a + s * o;
        return [u, h];
      }
      let Yc = class extends zP {
        constructor(t) {
          const e = Object.assign({}, t);
          delete e.source, super(e), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = false, this.rendered = false, t.render && (this.render = t.render), t.map && this.setMap(t.map), this.addChangeListener(ke.SOURCE, this.handleSourcePropertyChange_);
          const i = t.source ? t.source : null;
          this.setSource(i);
        }
        getLayersArray(t) {
          return t = t || [], t.push(this), t;
        }
        getLayerStatesArray(t) {
          return t = t || [], t.push(this.getLayerState()), t;
        }
        getSource() {
          return this.get(ke.SOURCE) || null;
        }
        getRenderSource() {
          return this.getSource();
        }
        getSourceState() {
          const t = this.getSource();
          return t ? t.getState() : "undefined";
        }
        handleSourceChange_() {
          this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = true, this.dispatchEvent("sourceready"));
        }
        handleSourcePropertyChange_() {
          this.sourceChangeKey_ && (Pe(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = false;
          const t = this.getSource();
          t && (this.sourceChangeKey_ = ie(t, Nt.CHANGE, this.handleSourceChange_, this), t.getState() === "ready" && (this.sourceReady_ = true, setTimeout(() => {
            this.dispatchEvent("sourceready");
          }, 0))), this.changed();
        }
        getFeatures(t) {
          return this.renderer_ ? this.renderer_.getFeatures(t) : Promise.resolve([]);
        }
        getData(t) {
          return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(t);
        }
        isVisible(t) {
          let e;
          const i = this.getMapInternal();
          !t && i && (t = i.getView()), t instanceof La ? e = { viewState: t.getState(), extent: t.calculateExtent() } : e = t, !e.layerStatesArray && i && (e.layerStatesArray = i.getLayerGroup().getLayerStatesArray());
          let r;
          e.layerStatesArray ? r = e.layerStatesArray.find((o) => o.layer === this) : r = this.getLayerState();
          const a = this.getExtent();
          return zx(r, e.viewState) && (!a || hi(a, e.extent));
        }
        getAttributions(t) {
          var a;
          if (!this.isVisible(t)) return [];
          const e = (a = this.getSource()) == null ? void 0 : a.getAttributions();
          if (!e) return [];
          const i = t instanceof La ? t.getViewStateAndExtent() : t;
          let r = e(i);
          return Array.isArray(r) || (r = [r]), r;
        }
        render(t, e) {
          const i = this.getRenderer();
          return i.prepareFrame(t) ? (this.rendered = true, i.renderFrame(t, e)) : null;
        }
        unrender() {
          this.rendered = false;
        }
        getDeclutter() {
        }
        renderDeclutter(t, e) {
        }
        renderDeferred(t) {
          const e = this.getRenderer();
          e && e.renderDeferred(t);
        }
        setMapInternal(t) {
          t || this.unrender(), this.set(ke.MAP, t);
        }
        getMapInternal() {
          return this.get(ke.MAP);
        }
        setMap(t) {
          this.mapPrecomposeKey_ && (Pe(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), t || this.changed(), this.mapRenderKey_ && (Pe(this.mapRenderKey_), this.mapRenderKey_ = null), t && (this.mapPrecomposeKey_ = ie(t, ni.PRECOMPOSE, this.handlePrecompose_, this), this.mapRenderKey_ = ie(this, Nt.CHANGE, t.render, t), this.changed());
        }
        handlePrecompose_(t) {
          const e = t.frameState.layerStatesArray, i = this.getLayerState(false);
          he(!e.some((r) => r.layer === i.layer), "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."), e.push(i);
        }
        setSource(t) {
          this.set(ke.SOURCE, t);
        }
        getRenderer() {
          return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
        }
        hasRenderer() {
          return !!this.renderer_;
        }
        createRenderer() {
          return null;
        }
        disposeInternal() {
          this.renderer_ && (this.renderer_.dispose(), delete this.renderer_), this.setSource(null), super.disposeInternal();
        }
      };
      function zx(n, t) {
        if (!n.visible) return false;
        const e = t.resolution;
        if (e < n.minResolution || e >= n.maxResolution) return false;
        const i = t.zoom;
        return i > n.minZoom && i <= n.maxZoom;
      }
      function qP(n, t, e = 0, i = n.length - 1, r = BK) {
        for (; i > e; ) {
          if (i - e > 600) {
            const l = i - e + 1, u = t - e + 1, h = Math.log(l), c = 0.5 * Math.exp(2 * h / 3), f = 0.5 * Math.sqrt(h * c * (l - c) / l) * (u - l / 2 < 0 ? -1 : 1), g = Math.max(e, Math.floor(t - u * c / l + f)), d = Math.min(i, Math.floor(t + (l - u) * c / l + f));
            qP(n, t, g, d, r);
          }
          const a = n[t];
          let o = e, s = i;
          for (rA(n, e, t), r(n[i], a) > 0 && rA(n, e, i); o < s; ) {
            for (rA(n, o, s), o++, s--; r(n[o], a) < 0; ) o++;
            for (; r(n[s], a) > 0; ) s--;
          }
          r(n[e], a) === 0 ? rA(n, e, s) : (s++, rA(n, s, i)), s <= t && (e = s + 1), t <= s && (i = s - 1);
        }
      }
      function rA(n, t, e) {
        const i = n[t];
        n[t] = n[e], n[e] = i;
      }
      function BK(n, t) {
        return n < t ? -1 : n > t ? 1 : 0;
      }
      let HP = class {
        constructor(t = 9) {
          this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
        }
        all() {
          return this._all(this.data, []);
        }
        search(t) {
          let e = this.data;
          const i = [];
          if (!u0(t, e)) return i;
          const r = this.toBBox, a = [];
          for (; e; ) {
            for (let o = 0; o < e.children.length; o++) {
              const s = e.children[o], l = e.leaf ? r(s) : s;
              u0(t, l) && (e.leaf ? i.push(s) : Ux(t, l) ? this._all(s, i) : a.push(s));
            }
            e = a.pop();
          }
          return i;
        }
        collides(t) {
          let e = this.data;
          if (!u0(t, e)) return false;
          const i = [];
          for (; e; ) {
            for (let r = 0; r < e.children.length; r++) {
              const a = e.children[r], o = e.leaf ? this.toBBox(a) : a;
              if (u0(t, o)) {
                if (e.leaf || Ux(t, o)) return true;
                i.push(a);
              }
            }
            e = i.pop();
          }
          return false;
        }
        load(t) {
          if (!(t && t.length)) return this;
          if (t.length < this._minEntries) {
            for (let i = 0; i < t.length; i++) this.insert(t[i]);
            return this;
          }
          let e = this._build(t.slice(), 0, t.length - 1, 0);
          if (!this.data.children.length) this.data = e;
          else if (this.data.height === e.height) this._splitRoot(this.data, e);
          else {
            if (this.data.height < e.height) {
              const i = this.data;
              this.data = e, e = i;
            }
            this._insert(e, this.data.height - e.height - 1, true);
          }
          return this;
        }
        insert(t) {
          return t && this._insert(t, this.data.height - 1), this;
        }
        clear() {
          return this.data = Xc([]), this;
        }
        remove(t, e) {
          if (!t) return this;
          let i = this.data;
          const r = this.toBBox(t), a = [], o = [];
          let s, l, u;
          for (; i || a.length; ) {
            if (i || (i = a.pop(), l = a[a.length - 1], s = o.pop(), u = true), i.leaf) {
              const h = TK(t, i.children, e);
              if (h !== -1) return i.children.splice(h, 1), a.push(i), this._condense(a), this;
            }
            !u && !i.leaf && Ux(i, r) ? (a.push(i), o.push(s), s = 0, l = i, i = i.children[0]) : l ? (s++, i = l.children[s], u = false) : i = null;
          }
          return this;
        }
        toBBox(t) {
          return t;
        }
        compareMinX(t, e) {
          return t.minX - e.minX;
        }
        compareMinY(t, e) {
          return t.minY - e.minY;
        }
        toJSON() {
          return this.data;
        }
        fromJSON(t) {
          return this.data = t, this;
        }
        _all(t, e) {
          const i = [];
          for (; t; ) t.leaf ? e.push(...t.children) : i.push(...t.children), t = i.pop();
          return e;
        }
        _build(t, e, i, r) {
          const a = i - e + 1;
          let o = this._maxEntries, s;
          if (a <= o) return s = Xc(t.slice(e, i + 1)), Wc(s, this.toBBox), s;
          r || (r = Math.ceil(Math.log(a) / Math.log(o)), o = Math.ceil(a / Math.pow(o, r - 1))), s = Xc([]), s.leaf = false, s.height = r;
          const l = Math.ceil(a / o), u = l * Math.ceil(Math.sqrt(o));
          YP(t, e, i, u, this.compareMinX);
          for (let h = e; h <= i; h += u) {
            const c = Math.min(h + u - 1, i);
            YP(t, h, c, l, this.compareMinY);
            for (let f = h; f <= c; f += l) {
              const g = Math.min(f + l - 1, c);
              s.children.push(this._build(t, f, g, r - 1));
            }
          }
          return Wc(s, this.toBBox), s;
        }
        _chooseSubtree(t, e, i, r) {
          for (; r.push(e), !(e.leaf || r.length - 1 === i); ) {
            let a = 1 / 0, o = 1 / 0, s;
            for (let l = 0; l < e.children.length; l++) {
              const u = e.children[l], h = Gx(u), c = RK(t, u) - h;
              c < o ? (o = c, a = h < a ? h : a, s = u) : c === o && h < a && (a = h, s = u);
            }
            e = s || e.children[0];
          }
          return e;
        }
        _insert(t, e, i) {
          const r = i ? t : this.toBBox(t), a = [], o = this._chooseSubtree(r, this.data, e, a);
          for (o.children.push(t), oA(o, r); e >= 0 && a[e].children.length > this._maxEntries; ) this._split(a, e), e--;
          this._adjustParentBBoxes(r, a, e);
        }
        _split(t, e) {
          const i = t[e], r = i.children.length, a = this._minEntries;
          this._chooseSplitAxis(i, a, r);
          const o = this._chooseSplitIndex(i, a, r), s = Xc(i.children.splice(o, i.children.length - o));
          s.height = i.height, s.leaf = i.leaf, Wc(i, this.toBBox), Wc(s, this.toBBox), e ? t[e - 1].children.push(s) : this._splitRoot(i, s);
        }
        _splitRoot(t, e) {
          this.data = Xc([t, e]), this.data.height = t.height + 1, this.data.leaf = false, Wc(this.data, this.toBBox);
        }
        _chooseSplitIndex(t, e, i) {
          let r, a = 1 / 0, o = 1 / 0;
          for (let s = e; s <= i - e; s++) {
            const l = aA(t, 0, s, this.toBBox), u = aA(t, s, i, this.toBBox), h = LK(l, u), c = Gx(l) + Gx(u);
            h < a ? (a = h, r = s, o = c < o ? c : o) : h === a && c < o && (o = c, r = s);
          }
          return r || i - e;
        }
        _chooseSplitAxis(t, e, i) {
          const r = t.leaf ? this.compareMinX : MK, a = t.leaf ? this.compareMinY : DK, o = this._allDistMargin(t, e, i, r), s = this._allDistMargin(t, e, i, a);
          o < s && t.children.sort(r);
        }
        _allDistMargin(t, e, i, r) {
          t.children.sort(r);
          const a = this.toBBox, o = aA(t, 0, e, a), s = aA(t, i - e, i, a);
          let l = l0(o) + l0(s);
          for (let u = e; u < i - e; u++) {
            const h = t.children[u];
            oA(o, t.leaf ? a(h) : h), l += l0(o);
          }
          for (let u = i - e - 1; u >= e; u--) {
            const h = t.children[u];
            oA(s, t.leaf ? a(h) : h), l += l0(s);
          }
          return l;
        }
        _adjustParentBBoxes(t, e, i) {
          for (let r = i; r >= 0; r--) oA(e[r], t);
        }
        _condense(t) {
          for (let e = t.length - 1, i; e >= 0; e--) t[e].children.length === 0 ? e > 0 ? (i = t[e - 1].children, i.splice(i.indexOf(t[e]), 1)) : this.clear() : Wc(t[e], this.toBBox);
        }
      };
      function TK(n, t, e) {
        if (!e) return t.indexOf(n);
        for (let i = 0; i < t.length; i++) if (e(n, t[i])) return i;
        return -1;
      }
      function Wc(n, t) {
        aA(n, 0, n.children.length, t, n);
      }
      function aA(n, t, e, i, r) {
        r || (r = Xc(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0;
        for (let a = t; a < e; a++) {
          const o = n.children[a];
          oA(r, n.leaf ? i(o) : o);
        }
        return r;
      }
      function oA(n, t) {
        return n.minX = Math.min(n.minX, t.minX), n.minY = Math.min(n.minY, t.minY), n.maxX = Math.max(n.maxX, t.maxX), n.maxY = Math.max(n.maxY, t.maxY), n;
      }
      function MK(n, t) {
        return n.minX - t.minX;
      }
      function DK(n, t) {
        return n.minY - t.minY;
      }
      function Gx(n) {
        return (n.maxX - n.minX) * (n.maxY - n.minY);
      }
      function l0(n) {
        return n.maxX - n.minX + (n.maxY - n.minY);
      }
      function RK(n, t) {
        return (Math.max(t.maxX, n.maxX) - Math.min(t.minX, n.minX)) * (Math.max(t.maxY, n.maxY) - Math.min(t.minY, n.minY));
      }
      function LK(n, t) {
        const e = Math.max(n.minX, t.minX), i = Math.max(n.minY, t.minY), r = Math.min(n.maxX, t.maxX), a = Math.min(n.maxY, t.maxY);
        return Math.max(0, r - e) * Math.max(0, a - i);
      }
      function Ux(n, t) {
        return n.minX <= t.minX && n.minY <= t.minY && t.maxX <= n.maxX && t.maxY <= n.maxY;
      }
      function u0(n, t) {
        return t.minX <= n.maxX && t.minY <= n.maxY && t.maxX >= n.minX && t.maxY >= n.minY;
      }
      function Xc(n) {
        return { children: n, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
      }
      function YP(n, t, e, i, r) {
        const a = [t, e];
        for (; a.length; ) {
          if (e = a.pop(), t = a.pop(), e - t <= i) continue;
          const o = t + Math.ceil((e - t) / i / 2) * i;
          qP(n, o, t, e, r), a.push(t, o, o, e);
        }
      }
      function WP(n, t, e, i) {
        return e !== void 0 && i !== void 0 ? [e / n, i / t] : e !== void 0 ? e / n : i !== void 0 ? i / t : 1;
      }
      class Rr extends e0 {
        constructor(t) {
          t = t || {};
          const e = t.opacity !== void 0 ? t.opacity : 1, i = t.rotation !== void 0 ? t.rotation : 0, r = t.scale !== void 0 ? t.scale : 1, a = t.rotateWithView !== void 0 ? t.rotateWithView : false;
          super({ opacity: e, rotation: i, scale: r, displacement: t.displacement !== void 0 ? t.displacement : [0, 0], rotateWithView: a, declutterMode: t.declutterMode }), this.anchor_ = t.anchor !== void 0 ? t.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = t.anchorOrigin !== void 0 ? t.anchorOrigin : "top-left", this.anchorXUnits_ = t.anchorXUnits !== void 0 ? t.anchorXUnits : "fraction", this.anchorYUnits_ = t.anchorYUnits !== void 0 ? t.anchorYUnits : "fraction", this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : null;
          const o = t.img !== void 0 ? t.img : null;
          let s = t.src;
          he(!(s !== void 0 && o), "`image` and `src` cannot be provided at the same time"), (s === void 0 || s.length === 0) && o && (s = o.src || Ft(o)), he(s !== void 0 && s.length > 0, "A defined and non-empty `src` or `image` must be provided"), he(!((t.width !== void 0 || t.height !== void 0) && t.scale !== void 0), "`width` or `height` cannot be provided together with `scale`");
          let l;
          if (t.src !== void 0 ? l = Bt.IDLE : o !== void 0 && ("complete" in o ? o.complete ? l = o.src ? Bt.LOADED : Bt.IDLE : l = Bt.LOADING : l = Bt.LOADED), this.color_ = t.color !== void 0 ? hl(t.color) : null, this.iconImage_ = Tx(o, s, this.crossOrigin_, l, this.color_), this.offset_ = t.offset !== void 0 ? t.offset : [0, 0], this.offsetOrigin_ = t.offsetOrigin !== void 0 ? t.offsetOrigin : "top-left", this.origin_ = null, this.size_ = t.size !== void 0 ? t.size : null, this.initialOptions_, t.width !== void 0 || t.height !== void 0) {
            let u, h;
            if (t.size) [u, h] = t.size;
            else {
              const c = this.getImage(1);
              if (c.width && c.height) u = c.width, h = c.height;
              else if (c instanceof HTMLImageElement) {
                this.initialOptions_ = t;
                const f = () => {
                  if (this.unlistenImageChange(f), !this.initialOptions_) return;
                  const g = this.iconImage_.getSize();
                  this.setScale(WP(g[0], g[1], t.width, t.height));
                };
                this.listenImageChange(f);
                return;
              }
            }
            u !== void 0 && this.setScale(WP(u, h, t.width, t.height));
          }
        }
        clone() {
          let t, e, i;
          return this.initialOptions_ ? (e = this.initialOptions_.width, i = this.initialOptions_.height) : (t = this.getScale(), t = Array.isArray(t) ? t.slice() : t), new Rr({ anchor: this.anchor_.slice(), anchorOrigin: this.anchorOrigin_, anchorXUnits: this.anchorXUnits_, anchorYUnits: this.anchorYUnits_, color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0, crossOrigin: this.crossOrigin_, offset: this.offset_.slice(), offsetOrigin: this.offsetOrigin_, opacity: this.getOpacity(), rotateWithView: this.getRotateWithView(), rotation: this.getRotation(), scale: t, width: e, height: i, size: this.size_ !== null ? this.size_.slice() : void 0, src: this.getSrc(), displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() });
        }
        getAnchor() {
          let t = this.normalizedAnchor_;
          if (!t) {
            t = this.anchor_;
            const r = this.getSize();
            if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
              if (!r) return null;
              t = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (t[0] *= r[0]), this.anchorYUnits_ == "fraction" && (t[1] *= r[1]);
            }
            if (this.anchorOrigin_ != "top-left") {
              if (!r) return null;
              t === this.anchor_ && (t = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (t[0] = -t[0] + r[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (t[1] = -t[1] + r[1]);
            }
            this.normalizedAnchor_ = t;
          }
          const e = this.getDisplacement(), i = this.getScaleArray();
          return [t[0] - e[0] / i[0], t[1] + e[1] / i[1]];
        }
        setAnchor(t) {
          this.anchor_ = t, this.normalizedAnchor_ = null;
        }
        getColor() {
          return this.color_;
        }
        getImage(t) {
          return this.iconImage_.getImage(t);
        }
        getPixelRatio(t) {
          return this.iconImage_.getPixelRatio(t);
        }
        getImageSize() {
          return this.iconImage_.getSize();
        }
        getImageState() {
          return this.iconImage_.getImageState();
        }
        getHitDetectionImage() {
          return this.iconImage_.getHitDetectionImage();
        }
        getOrigin() {
          if (this.origin_) return this.origin_;
          let t = this.offset_;
          if (this.offsetOrigin_ != "top-left") {
            const e = this.getSize(), i = this.iconImage_.getSize();
            if (!e || !i) return null;
            t = t.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (t[0] = i[0] - e[0] - t[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (t[1] = i[1] - e[1] - t[1]);
          }
          return this.origin_ = t, this.origin_;
        }
        getSrc() {
          return this.iconImage_.getSrc();
        }
        getSize() {
          return this.size_ ? this.size_ : this.iconImage_.getSize();
        }
        getWidth() {
          const t = this.getScaleArray();
          if (this.size_) return this.size_[0] * t[0];
          if (this.iconImage_.getImageState() == Bt.LOADED) return this.iconImage_.getSize()[0] * t[0];
        }
        getHeight() {
          const t = this.getScaleArray();
          if (this.size_) return this.size_[1] * t[1];
          if (this.iconImage_.getImageState() == Bt.LOADED) return this.iconImage_.getSize()[1] * t[1];
        }
        setScale(t) {
          delete this.initialOptions_, super.setScale(t);
        }
        listenImageChange(t) {
          this.iconImage_.addEventListener(Nt.CHANGE, t);
        }
        load() {
          this.iconImage_.load();
        }
        unlistenImageChange(t) {
          this.iconImage_.removeEventListener(Nt.CHANGE, t);
        }
        ready() {
          return this.iconImage_.ready();
        }
      }
      let ku = 0;
      const xi = 1 << ku++, se = 1 << ku++, wi = 1 << ku++, Lr = 1 << ku++, fl = 1 << ku++, Zc = 1 << ku++, h0 = Math.pow(2, ku) - 1, Vx = { [xi]: "boolean", [se]: "number", [wi]: "string", [Lr]: "color", [fl]: "number[]", [Zc]: "size" }, PK = Object.keys(Vx).map(Number).sort(Ma);
      function NK(n) {
        return n in Vx;
      }
      function Kc(n) {
        const t = [];
        for (const e of PK) sA(n, e) && t.push(Vx[e]);
        return t.length === 0 ? "untyped" : t.length < 3 ? t.join(" or ") : t.slice(0, -1).join(", ") + ", or " + t[t.length - 1];
      }
      function sA(n, t) {
        return (n & t) === t;
      }
      function gl(n, t) {
        return n === t;
      }
      class jn {
        constructor(t, e) {
          if (!NK(t)) throw new Error(`literal expressions must have a specific type, got ${Kc(t)}`);
          this.type = t, this.value = e;
        }
      }
      class XP {
        constructor(t, e, ...i) {
          this.type = t, this.operator = e, this.args = i;
        }
      }
      function jx() {
        return { variables: /* @__PURE__ */ new Set(), properties: /* @__PURE__ */ new Set(), featureId: false, geometryType: false };
      }
      function ii(n, t, e) {
        switch (typeof n) {
          case "boolean": {
            if (gl(t, wi)) return new jn(wi, n ? "true" : "false");
            if (!sA(t, xi)) throw new Error(`got a boolean, but expected ${Kc(t)}`);
            return new jn(xi, n);
          }
          case "number": {
            if (gl(t, Zc)) return new jn(Zc, bn(n));
            if (gl(t, xi)) return new jn(xi, !!n);
            if (gl(t, wi)) return new jn(wi, n.toString());
            if (!sA(t, se)) throw new Error(`got a number, but expected ${Kc(t)}`);
            return new jn(se, n);
          }
          case "string": {
            if (gl(t, Lr)) return new jn(Lr, xx(n));
            if (gl(t, xi)) return new jn(xi, !!n);
            if (!sA(t, wi)) throw new Error(`got a string, but expected ${Kc(t)}`);
            return new jn(wi, n);
          }
        }
        if (!Array.isArray(n)) throw new Error("expression must be an array or a primitive value");
        if (n.length === 0) throw new Error("empty expression");
        if (typeof n[0] == "string") return HK(n, t, e);
        for (const i of n) if (typeof i != "number") throw new Error("expected an array of numbers");
        if (gl(t, Zc)) {
          if (n.length !== 2) throw new Error(`expected an array of two values for a size, got ${n.length}`);
          return new jn(Zc, n);
        }
        if (gl(t, Lr)) {
          if (n.length === 3) return new jn(Lr, [...n, 1]);
          if (n.length === 4) return new jn(Lr, n);
          throw new Error(`expected an array of 3 or 4 values for a color, got ${n.length}`);
        }
        if (!sA(t, fl)) throw new Error(`got an array of numbers, but expected ${Kc(t)}`);
        return new jn(fl, n);
      }
      const q = { Get: "get", Var: "var", Concat: "concat", GeometryType: "geometry-type", LineMetric: "line-metric", Any: "any", All: "all", Not: "!", Resolution: "resolution", Zoom: "zoom", Time: "time", Equal: "==", NotEqual: "!=", GreaterThan: ">", GreaterThanOrEqualTo: ">=", LessThan: "<", LessThanOrEqualTo: "<=", Multiply: "*", Divide: "/", Add: "+", Subtract: "-", Clamp: "clamp", Mod: "%", Pow: "^", Abs: "abs", Floor: "floor", Ceil: "ceil", Round: "round", Sin: "sin", Cos: "cos", Atan: "atan", Sqrt: "sqrt", Match: "match", Between: "between", Interpolate: "interpolate", Coalesce: "coalesce", Case: "case", In: "in", Number: "number", String: "string", Array: "array", Color: "color", Id: "id", Band: "band", Palette: "palette", ToString: "to-string", Has: "has" }, kK = { [q.Get]: te(ce(1, 1 / 0), ZP), [q.Var]: te(ce(1, 1), FK), [q.Has]: te(ce(1, 1 / 0), ZP), [q.Id]: te(QK, $c), [q.Concat]: te(ce(2, 1 / 0), ze(wi)), [q.GeometryType]: te(OK, $c), [q.LineMetric]: te($c), [q.Resolution]: te($c), [q.Zoom]: te($c), [q.Time]: te($c), [q.Any]: te(ce(2, 1 / 0), ze(xi)), [q.All]: te(ce(2, 1 / 0), ze(xi)), [q.Not]: te(ce(1, 1), ze(xi)), [q.Equal]: te(ce(2, 2), ze(h0)), [q.NotEqual]: te(ce(2, 2), ze(h0)), [q.GreaterThan]: te(ce(2, 2), ze(se)), [q.GreaterThanOrEqualTo]: te(ce(2, 2), ze(se)), [q.LessThan]: te(ce(2, 2), ze(se)), [q.LessThanOrEqualTo]: te(ce(2, 2), ze(se)), [q.Multiply]: te(ce(2, 1 / 0), KP), [q.Coalesce]: te(ce(2, 1 / 0), KP), [q.Divide]: te(ce(2, 2), ze(se)), [q.Add]: te(ce(2, 1 / 0), ze(se)), [q.Subtract]: te(ce(2, 2), ze(se)), [q.Clamp]: te(ce(3, 3), ze(se)), [q.Mod]: te(ce(2, 2), ze(se)), [q.Pow]: te(ce(2, 2), ze(se)), [q.Abs]: te(ce(1, 1), ze(se)), [q.Floor]: te(ce(1, 1), ze(se)), [q.Ceil]: te(ce(1, 1), ze(se)), [q.Round]: te(ce(1, 1), ze(se)), [q.Sin]: te(ce(1, 1), ze(se)), [q.Cos]: te(ce(1, 1), ze(se)), [q.Atan]: te(ce(1, 2), ze(se)), [q.Sqrt]: te(ce(1, 1), ze(se)), [q.Match]: te(ce(4, 1 / 0), $P, GK), [q.Between]: te(ce(3, 3), ze(se)), [q.Interpolate]: te(ce(6, 1 / 0), $P, UK), [q.Case]: te(ce(3, 1 / 0), zK, VK), [q.In]: te(ce(2, 2), jK), [q.Number]: te(ce(1, 1 / 0), ze(h0)), [q.String]: te(ce(1, 1 / 0), ze(h0)), [q.Array]: te(ce(1, 1 / 0), ze(se)), [q.Color]: te(ce(1, 4), ze(se)), [q.Band]: te(ce(1, 3), ze(se)), [q.Palette]: te(ce(2, 2), qK), [q.ToString]: te(ce(1, 1), ze(xi | se | wi | Lr)) };
      function ZP(n, t, e) {
        const i = n.length - 1, r = new Array(i);
        for (let a = 0; a < i; ++a) {
          const o = n[a + 1];
          switch (typeof o) {
            case "number": {
              r[a] = new jn(se, o);
              break;
            }
            case "string": {
              r[a] = new jn(wi, o);
              break;
            }
            default:
              throw new Error(`expected a string key or numeric array index for a get operation, got ${o}`);
          }
          a === 0 && e.properties.add(String(o));
        }
        return r;
      }
      function FK(n, t, e) {
        const i = n[1];
        if (typeof i != "string") throw new Error("expected a string argument for var operation");
        return e.variables.add(i), [new jn(wi, i)];
      }
      function QK(n, t, e) {
        e.featureId = true;
      }
      function OK(n, t, e) {
        e.geometryType = true;
      }
      function $c(n, t, e) {
        const i = n[0];
        if (n.length !== 1) throw new Error(`expected no arguments for ${i} operation`);
        return [];
      }
      function ce(n, t) {
        return function(e, i, r) {
          const a = e[0], o = e.length - 1;
          if (n === t) {
            if (o !== n) {
              const s = n === 1 ? "" : "s";
              throw new Error(`expected ${n} argument${s} for ${a}, got ${o}`);
            }
          } else if (o < n || o > t) {
            const s = t === 1 / 0 ? `${n} or more` : `${n} to ${t}`;
            throw new Error(`expected ${s} arguments for ${a}, got ${o}`);
          }
        };
      }
      function KP(n, t, e) {
        const i = n.length - 1, r = new Array(i);
        for (let a = 0; a < i; ++a) {
          const o = ii(n[a + 1], t, e);
          r[a] = o;
        }
        return r;
      }
      function ze(n) {
        return function(t, e, i) {
          const r = t.length - 1, a = new Array(r);
          for (let o = 0; o < r; ++o) {
            const s = ii(t[o + 1], n, i);
            a[o] = s;
          }
          return a;
        };
      }
      function zK(n, t, e) {
        const i = n[0], r = n.length - 1;
        if (r % 2 === 0) throw new Error(`expected an odd number of arguments for ${i}, got ${r} instead`);
      }
      function $P(n, t, e) {
        const i = n[0], r = n.length - 1;
        if (r % 2 === 1) throw new Error(`expected an even number of arguments for operation ${i}, got ${r} instead`);
      }
      function GK(n, t, e) {
        const i = n.length - 1, r = wi | se | xi, a = ii(n[1], r, e), o = ii(n[n.length - 1], t, e), s = new Array(i - 2);
        for (let l = 0; l < i - 2; l += 2) {
          try {
            const u = ii(n[l + 2], a.type, e);
            s[l] = u;
          } catch (u) {
            throw new Error(`failed to parse argument ${l + 1} of match expression: ${u.message}`);
          }
          try {
            const u = ii(n[l + 3], o.type, e);
            s[l + 1] = u;
          } catch (u) {
            throw new Error(`failed to parse argument ${l + 2} of match expression: ${u.message}`);
          }
        }
        return [a, ...s, o];
      }
      function UK(n, t, e) {
        const i = n[1];
        let r;
        switch (i[0]) {
          case "linear":
            r = 1;
            break;
          case "exponential":
            const l = i[1];
            if (typeof l != "number" || l <= 0) throw new Error(`expected a number base for exponential interpolation, got ${JSON.stringify(l)} instead`);
            r = l;
            break;
          default:
            throw new Error(`invalid interpolation type: ${JSON.stringify(i)}`);
        }
        const a = new jn(se, r);
        let o;
        try {
          o = ii(n[2], se, e);
        } catch (l) {
          throw new Error(`failed to parse argument 1 in interpolate expression: ${l.message}`);
        }
        const s = new Array(n.length - 3);
        for (let l = 0; l < s.length; l += 2) {
          try {
            const u = ii(n[l + 3], se, e);
            s[l] = u;
          } catch (u) {
            throw new Error(`failed to parse argument ${l + 2} for interpolate expression: ${u.message}`);
          }
          try {
            const u = ii(n[l + 4], t, e);
            s[l + 1] = u;
          } catch (u) {
            throw new Error(`failed to parse argument ${l + 3} for interpolate expression: ${u.message}`);
          }
        }
        return [a, o, ...s];
      }
      function VK(n, t, e) {
        const i = ii(n[n.length - 1], t, e), r = new Array(n.length - 1);
        for (let a = 0; a < r.length - 1; a += 2) {
          try {
            const o = ii(n[a + 1], xi, e);
            r[a] = o;
          } catch (o) {
            throw new Error(`failed to parse argument ${a} of case expression: ${o.message}`);
          }
          try {
            const o = ii(n[a + 2], i.type, e);
            r[a + 1] = o;
          } catch (o) {
            throw new Error(`failed to parse argument ${a + 1} of case expression: ${o.message}`);
          }
        }
        return r[r.length - 1] = i, r;
      }
      function jK(n, t, e) {
        let i = n[2];
        if (!Array.isArray(i)) throw new Error('the second argument for the "in" operator must be an array');
        let r;
        if (typeof i[0] == "string") {
          if (i[0] !== "literal") throw new Error('for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions');
          if (!Array.isArray(i[1])) throw new Error('failed to parse "in" expression: the literal operator must be followed by an array');
          i = i[1], r = wi;
        } else r = se;
        const a = new Array(i.length);
        for (let s = 0; s < a.length; s++) try {
          const l = ii(i[s], r, e);
          a[s] = l;
        } catch (l) {
          throw new Error(`failed to parse haystack item ${s} for "in" expression: ${l.message}`);
        }
        return [ii(n[1], r, e), ...a];
      }
      function qK(n, t, e) {
        let i;
        try {
          i = ii(n[1], se, e);
        } catch (o) {
          throw new Error(`failed to parse first argument in palette expression: ${o.message}`);
        }
        const r = n[2];
        if (!Array.isArray(r)) throw new Error("the second argument of palette must be an array");
        const a = new Array(r.length);
        for (let o = 0; o < a.length; o++) {
          let s;
          try {
            s = ii(r[o], Lr, e);
          } catch (l) {
            throw new Error(`failed to parse color at index ${o} in palette expression: ${l.message}`);
          }
          if (!(s instanceof jn)) throw new Error(`the palette color at index ${o} must be a literal value`);
          a[o] = s;
        }
        return [i, ...a];
      }
      function te(...n) {
        return function(t, e, i) {
          const r = t[0];
          let a;
          for (let o = 0; o < n.length; o++) {
            const s = n[o](t, e, i);
            if (o == n.length - 1) {
              if (!s) throw new Error("expected last argument validator to return the parsed args");
              a = s;
            }
          }
          return new XP(e, r, ...a);
        };
      }
      function HK(n, t, e) {
        const i = n[0], r = kK[i];
        if (!r) throw new Error(`unknown operator: ${i}`);
        return r(n, t, e);
      }
      function qx(n) {
        if (!n) return "";
        const t = n.getType();
        switch (t) {
          case "Point":
          case "LineString":
          case "Polygon":
            return t;
          case "MultiPoint":
          case "MultiLineString":
          case "MultiPolygon":
            return t.substring(5);
          case "Circle":
            return "Polygon";
          case "GeometryCollection":
            return qx(n.getGeometries()[0]);
          default:
            return "";
        }
      }
      function JP() {
        return { variables: {}, properties: {}, resolution: NaN, featureId: null, geometryType: "" };
      }
      function cs(n, t, e) {
        const i = ii(n, t, e);
        return Pa(i);
      }
      function Pa(n, t) {
        if (n instanceof jn) {
          if (n.type === Lr && typeof n.value == "string") {
            const i = xx(n.value);
            return function() {
              return i;
            };
          }
          return function() {
            return n.value;
          };
        }
        const e = n.operator;
        switch (e) {
          case q.Number:
          case q.String:
          case q.Coalesce:
            return YK(n);
          case q.Get:
          case q.Var:
          case q.Has:
            return WK(n);
          case q.Id:
            return (i) => i.featureId;
          case q.GeometryType:
            return (i) => i.geometryType;
          case q.Concat: {
            const i = n.args.map((r) => Pa(r));
            return (r) => "".concat(...i.map((a) => a(r).toString()));
          }
          case q.Resolution:
            return (i) => i.resolution;
          case q.Any:
          case q.All:
          case q.Between:
          case q.In:
          case q.Not:
            return ZK(n);
          case q.Equal:
          case q.NotEqual:
          case q.LessThan:
          case q.LessThanOrEqualTo:
          case q.GreaterThan:
          case q.GreaterThanOrEqualTo:
            return XK(n);
          case q.Multiply:
          case q.Divide:
          case q.Add:
          case q.Subtract:
          case q.Clamp:
          case q.Mod:
          case q.Pow:
          case q.Abs:
          case q.Floor:
          case q.Ceil:
          case q.Round:
          case q.Sin:
          case q.Cos:
          case q.Atan:
          case q.Sqrt:
            return KK(n);
          case q.Case:
            return $K(n);
          case q.Match:
            return JK(n);
          case q.Interpolate:
            return t$(n);
          case q.ToString:
            return e$(n);
          default:
            throw new Error(`Unsupported operator ${e}`);
        }
      }
      function YK(n, t) {
        const e = n.operator, i = n.args.length, r = new Array(i);
        for (let a = 0; a < i; ++a) r[a] = Pa(n.args[a]);
        switch (e) {
          case q.Coalesce:
            return (a) => {
              for (let o = 0; o < i; ++o) {
                const s = r[o](a);
                if (typeof s != "undefined" && s !== null) return s;
              }
              throw new Error("Expected one of the values to be non-null");
            };
          case q.Number:
          case q.String:
            return (a) => {
              for (let o = 0; o < i; ++o) {
                const s = r[o](a);
                if (typeof s === e) return s;
              }
              throw new Error(`Expected one of the values to be a ${e}`);
            };
          default:
            throw new Error(`Unsupported assertion operator ${e}`);
        }
      }
      function WK(n, t) {
        const i = n.args[0].value;
        switch (n.operator) {
          case q.Get:
            return (r) => {
              const a = n.args;
              let o = r.properties[i];
              for (let s = 1, l = a.length; s < l; ++s) {
                const h = a[s].value;
                o = o[h];
              }
              return o;
            };
          case q.Var:
            return (r) => r.variables[i];
          case q.Has:
            return (r) => {
              const a = n.args;
              if (!(i in r.properties)) return false;
              let o = r.properties[i];
              for (let s = 1, l = a.length; s < l; ++s) {
                const h = a[s].value;
                if (!o || !Object.hasOwn(o, h)) return false;
                o = o[h];
              }
              return true;
            };
          default:
            throw new Error(`Unsupported accessor operator ${n.operator}`);
        }
      }
      function XK(n, t) {
        const e = n.operator, i = Pa(n.args[0]), r = Pa(n.args[1]);
        switch (e) {
          case q.Equal:
            return (a) => i(a) === r(a);
          case q.NotEqual:
            return (a) => i(a) !== r(a);
          case q.LessThan:
            return (a) => i(a) < r(a);
          case q.LessThanOrEqualTo:
            return (a) => i(a) <= r(a);
          case q.GreaterThan:
            return (a) => i(a) > r(a);
          case q.GreaterThanOrEqualTo:
            return (a) => i(a) >= r(a);
          default:
            throw new Error(`Unsupported comparison operator ${e}`);
        }
      }
      function ZK(n, t) {
        const e = n.operator, i = n.args.length, r = new Array(i);
        for (let a = 0; a < i; ++a) r[a] = Pa(n.args[a]);
        switch (e) {
          case q.Any:
            return (a) => {
              for (let o = 0; o < i; ++o) if (r[o](a)) return true;
              return false;
            };
          case q.All:
            return (a) => {
              for (let o = 0; o < i; ++o) if (!r[o](a)) return false;
              return true;
            };
          case q.Between:
            return (a) => {
              const o = r[0](a), s = r[1](a), l = r[2](a);
              return o >= s && o <= l;
            };
          case q.In:
            return (a) => {
              const o = r[0](a);
              for (let s = 1; s < i; ++s) if (o === r[s](a)) return true;
              return false;
            };
          case q.Not:
            return (a) => !r[0](a);
          default:
            throw new Error(`Unsupported logical operator ${e}`);
        }
      }
      function KK(n, t) {
        const e = n.operator, i = n.args.length, r = new Array(i);
        for (let a = 0; a < i; ++a) r[a] = Pa(n.args[a]);
        switch (e) {
          case q.Multiply:
            return (a) => {
              let o = 1;
              for (let s = 0; s < i; ++s) o *= r[s](a);
              return o;
            };
          case q.Divide:
            return (a) => r[0](a) / r[1](a);
          case q.Add:
            return (a) => {
              let o = 0;
              for (let s = 0; s < i; ++s) o += r[s](a);
              return o;
            };
          case q.Subtract:
            return (a) => r[0](a) - r[1](a);
          case q.Clamp:
            return (a) => {
              const o = r[0](a), s = r[1](a);
              if (o < s) return s;
              const l = r[2](a);
              return o > l ? l : o;
            };
          case q.Mod:
            return (a) => r[0](a) % r[1](a);
          case q.Pow:
            return (a) => Math.pow(r[0](a), r[1](a));
          case q.Abs:
            return (a) => Math.abs(r[0](a));
          case q.Floor:
            return (a) => Math.floor(r[0](a));
          case q.Ceil:
            return (a) => Math.ceil(r[0](a));
          case q.Round:
            return (a) => Math.round(r[0](a));
          case q.Sin:
            return (a) => Math.sin(r[0](a));
          case q.Cos:
            return (a) => Math.cos(r[0](a));
          case q.Atan:
            return i === 2 ? (a) => Math.atan2(r[0](a), r[1](a)) : (a) => Math.atan(r[0](a));
          case q.Sqrt:
            return (a) => Math.sqrt(r[0](a));
          default:
            throw new Error(`Unsupported numeric operator ${e}`);
        }
      }
      function $K(n, t) {
        const e = n.args.length, i = new Array(e);
        for (let r = 0; r < e; ++r) i[r] = Pa(n.args[r]);
        return (r) => {
          for (let a = 0; a < e - 1; a += 2) if (i[a](r)) return i[a + 1](r);
          return i[e - 1](r);
        };
      }
      function JK(n, t) {
        const e = n.args.length, i = new Array(e);
        for (let r = 0; r < e; ++r) i[r] = Pa(n.args[r]);
        return (r) => {
          const a = i[0](r);
          for (let o = 1; o < e; o += 2) if (a === i[o](r)) return i[o + 1](r);
          return i[e - 1](r);
        };
      }
      function t$(n, t) {
        const e = n.args.length, i = new Array(e);
        for (let r = 0; r < e; ++r) i[r] = Pa(n.args[r]);
        return (r) => {
          const a = i[0](r), o = i[1](r);
          let s, l;
          for (let u = 2; u < e; u += 2) {
            const h = i[u](r);
            let c = i[u + 1](r);
            const f = Array.isArray(c);
            if (f && (c = qZ(c)), h >= o) return u === 2 ? c : f ? n$(a, o, s, l, h, c) : lA(a, o, s, l, h, c);
            s = h, l = c;
          }
          return l;
        };
      }
      function e$(n, t) {
        const e = n.operator, i = n.args.length, r = new Array(i);
        for (let a = 0; a < i; ++a) r[a] = Pa(n.args[a]);
        switch (e) {
          case q.ToString:
            return (a) => {
              const o = r[0](a);
              return n.args[0].type === Lr ? Cx(o) : o.toString();
            };
          default:
            throw new Error(`Unsupported convert operator ${e}`);
        }
      }
      function lA(n, t, e, i, r, a) {
        const o = r - e;
        if (o === 0) return i;
        const s = t - e, l = n === 1 ? s / o : (Math.pow(n, s) - 1) / (Math.pow(n, o) - 1);
        return i + l * (a - i);
      }
      function n$(n, t, e, i, r, a) {
        if (r - e === 0) return i;
        const s = _P(i), l = _P(a);
        let u = l[2] - s[2];
        u > 180 ? u -= 360 : u < -180 && (u += 360);
        const h = [lA(n, t, e, s[0], r, l[0]), lA(n, t, e, s[1], r, l[1]), s[2] + lA(n, t, e, 0, r, u), lA(n, t, e, i[3], r, a[3])];
        return IP(HZ(h));
      }
      function i$(n) {
        return true;
      }
      function r$(n) {
        const t = jx(), e = a$(n, t), i = JP();
        return function(r, a) {
          if (i.properties = r.getPropertiesInternal(), i.resolution = a, t.featureId) {
            const o = r.getId();
            o !== void 0 ? i.featureId = o : i.featureId = null;
          }
          return t.geometryType && (i.geometryType = qx(r.getGeometry())), e(i);
        };
      }
      function tN(n) {
        const t = jx(), e = n.length, i = new Array(e);
        for (let o = 0; o < e; ++o) i[o] = Hx(n[o], t);
        const r = JP(), a = new Array(e);
        return function(o, s) {
          if (r.properties = o.getPropertiesInternal(), r.resolution = s, t.featureId) {
            const u = o.getId();
            u !== void 0 ? r.featureId = u : r.featureId = null;
          }
          let l = 0;
          for (let u = 0; u < e; ++u) {
            const h = i[u](r);
            h && (a[l] = h, l += 1);
          }
          return a.length = l, a;
        };
      }
      function a$(n, t) {
        const e = n.length, i = new Array(e);
        for (let r = 0; r < e; ++r) {
          const a = n[r], o = "filter" in a ? cs(a.filter, xi, t) : i$;
          let s;
          if (Array.isArray(a.style)) {
            const l = a.style.length;
            s = new Array(l);
            for (let u = 0; u < l; ++u) s[u] = Hx(a.style[u], t);
          } else s = [Hx(a.style, t)];
          i[r] = { filter: o, styles: s };
        }
        return function(r) {
          const a = [];
          let o = false;
          for (let s = 0; s < e; ++s) {
            const l = i[s].filter;
            if (l(r) && !(n[s].else && o)) {
              o = true;
              for (const u of i[s].styles) {
                const h = u(r);
                h && a.push(h);
              }
            }
          }
          return a;
        };
      }
      function Hx(n, t) {
        const e = uA(n, "", t), i = hA(n, "", t), r = o$(n, t), a = s$(n, t), o = or(n, "z-index", t);
        if (!e && !i && !r && !a && !il(n)) throw new Error("No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(n));
        const s = new de();
        return function(l) {
          let u = true;
          if (e) {
            const h = e(l);
            h && (u = false), s.setFill(h);
          }
          if (i) {
            const h = i(l);
            h && (u = false), s.setStroke(h);
          }
          if (r) {
            const h = r(l);
            h && (u = false), s.setText(h);
          }
          if (a) {
            const h = a(l);
            h && (u = false), s.setImage(h);
          }
          return o && s.setZIndex(o(l)), u ? null : s;
        };
      }
      function uA(n, t, e) {
        let i;
        if (t + "fill-pattern-src" in n) i = c$(n, t + "fill-", e);
        else {
          if (n[t + "fill-color"] === "none") return (a) => null;
          i = Yx(n, t + "fill-color", e);
        }
        if (!i) return null;
        const r = new ye();
        return function(a) {
          const o = i(a);
          return o === Ix ? null : (r.setColor(o), r);
        };
      }
      function hA(n, t, e) {
        const i = or(n, t + "stroke-width", e), r = Yx(n, t + "stroke-color", e);
        if (!i && !r) return null;
        const a = fs(n, t + "stroke-line-cap", e), o = fs(n, t + "stroke-line-join", e), s = eN(n, t + "stroke-line-dash", e), l = or(n, t + "stroke-line-dash-offset", e), u = or(n, t + "stroke-miter-limit", e), h = new Ze();
        return function(c) {
          if (r) {
            const f = r(c);
            if (f === Ix) return null;
            h.setColor(f);
          }
          if (i && h.setWidth(i(c)), a) {
            const f = a(c);
            if (f !== "butt" && f !== "round" && f !== "square") throw new Error("Expected butt, round, or square line cap");
            h.setLineCap(f);
          }
          if (o) {
            const f = o(c);
            if (f !== "bevel" && f !== "round" && f !== "miter") throw new Error("Expected bevel, round, or miter line join");
            h.setLineJoin(f);
          }
          return s && h.setLineDash(s(c)), l && h.setLineDashOffset(l(c)), u && h.setMiterLimit(u(c)), h;
        };
      }
      function o$(n, t) {
        const e = "text-", i = fs(n, e + "value", t);
        if (!i) return null;
        const r = uA(n, e, t), a = uA(n, e + "background-", t), o = hA(n, e, t), s = hA(n, e + "background-", t), l = fs(n, e + "font", t), u = or(n, e + "max-angle", t), h = or(n, e + "offset-x", t), c = or(n, e + "offset-y", t), f = cA(n, e + "overflow", t), g = fs(n, e + "placement", t), d = or(n, e + "repeat", t), A = f0(n, e + "scale", t), p = cA(n, e + "rotate-with-view", t), v = or(n, e + "rotation", t), y = fs(n, e + "align", t), m = fs(n, e + "justify", t), _ = fs(n, e + "baseline", t), E = eN(n, e + "padding", t), I = d0(n, e + "declutter-mode"), x = new Ei({ declutterMode: I });
        return function(w) {
          if (x.setText(i(w)), r && x.setFill(r(w)), a && x.setBackgroundFill(a(w)), o && x.setStroke(o(w)), s && x.setBackgroundStroke(s(w)), l && x.setFont(l(w)), u && x.setMaxAngle(u(w)), h && x.setOffsetX(h(w)), c && x.setOffsetY(c(w)), f && x.setOverflow(f(w)), g) {
            const C = g(w);
            if (C !== "point" && C !== "line") throw new Error("Expected point or line for text-placement");
            x.setPlacement(C);
          }
          if (d && x.setRepeat(d(w)), A && x.setScale(A(w)), p && x.setRotateWithView(p(w)), v && x.setRotation(v(w)), y) {
            const C = y(w);
            if (C !== "left" && C !== "center" && C !== "right" && C !== "end" && C !== "start") throw new Error("Expected left, right, center, start, or end for text-align");
            x.setTextAlign(C);
          }
          if (m) {
            const C = m(w);
            if (C !== "left" && C !== "right" && C !== "center") throw new Error("Expected left, right, or center for text-justify");
            x.setJustify(C);
          }
          if (_) {
            const C = _(w);
            if (C !== "bottom" && C !== "top" && C !== "middle" && C !== "alphabetic" && C !== "hanging") throw new Error("Expected bottom, top, middle, alphabetic, or hanging for text-baseline");
            x.setTextBaseline(C);
          }
          return E && x.setPadding(E(w)), x;
        };
      }
      function s$(n, t) {
        return "icon-src" in n ? l$(n, t) : "shape-points" in n ? u$(n, t) : "circle-radius" in n ? h$(n, t) : null;
      }
      function l$(n, t) {
        const e = "icon-", i = e + "src", r = aN(n[i], i), a = c0(n, e + "anchor", t), o = f0(n, e + "scale", t), s = or(n, e + "opacity", t), l = c0(n, e + "displacement", t), u = or(n, e + "rotation", t), h = cA(n, e + "rotate-with-view", t), c = iN(n, e + "anchor-origin"), f = rN(n, e + "anchor-x-units"), g = rN(n, e + "anchor-y-units"), d = A$(n, e + "color"), A = g$(n, e + "cross-origin"), p = d$(n, e + "offset"), v = iN(n, e + "offset-origin"), y = g0(n, e + "width"), m = g0(n, e + "height"), _ = f$(n, e + "size"), E = d0(n, e + "declutter-mode"), I = new Rr({ src: r, anchorOrigin: c, anchorXUnits: f, anchorYUnits: g, color: d, crossOrigin: A, offset: p, offsetOrigin: v, height: m, width: y, size: _, declutterMode: E });
        return function(x) {
          return s && I.setOpacity(s(x)), l && I.setDisplacement(l(x)), u && I.setRotation(u(x)), h && I.setRotateWithView(h(x)), o && I.setScale(o(x)), a && I.setAnchor(a(x)), I;
        };
      }
      function u$(n, t) {
        const e = "shape-", i = e + "points", r = e + "radius", a = Wx(n[i], i), o = Wx(n[r], r), s = uA(n, e, t), l = hA(n, e, t), u = f0(n, e + "scale", t), h = c0(n, e + "displacement", t), c = or(n, e + "rotation", t), f = cA(n, e + "rotate-with-view", t), g = g0(n, e + "radius2"), d = g0(n, e + "angle"), A = d0(n, e + "declutter-mode"), p = new Nu({ points: a, radius: o, radius2: g, angle: d, declutterMode: A });
        return function(v) {
          return s && p.setFill(s(v)), l && p.setStroke(l(v)), h && p.setDisplacement(h(v)), c && p.setRotation(c(v)), f && p.setRotateWithView(f(v)), u && p.setScale(u(v)), p;
        };
      }
      function h$(n, t) {
        const e = "circle-", i = uA(n, e, t), r = hA(n, e, t), a = or(n, e + "radius", t), o = f0(n, e + "scale", t), s = c0(n, e + "displacement", t), l = or(n, e + "rotation", t), u = cA(n, e + "rotate-with-view", t), h = d0(n, e + "declutter-mode"), c = new Mr({ radius: 5, declutterMode: h });
        return function(f) {
          return a && c.setRadius(a(f)), i && c.setFill(i(f)), r && c.setStroke(r(f)), s && c.setDisplacement(s(f)), l && c.setRotation(l(f)), u && c.setRotateWithView(u(f)), o && c.setScale(o(f)), c;
        };
      }
      function or(n, t, e) {
        if (!(t in n)) return;
        const i = cs(n[t], se, e);
        return function(r) {
          return Wx(i(r), t);
        };
      }
      function fs(n, t, e) {
        if (!(t in n)) return null;
        const i = cs(n[t], wi, e);
        return function(r) {
          return aN(i(r), t);
        };
      }
      function c$(n, t, e) {
        const i = fs(n, t + "pattern-src", e), r = nN(n, t + "pattern-offset", e), a = nN(n, t + "pattern-size", e), o = Yx(n, t + "color", e);
        return function(s) {
          return { src: i(s), offset: r && r(s), size: a && a(s), color: o && o(s) };
        };
      }
      function cA(n, t, e) {
        if (!(t in n)) return null;
        const i = cs(n[t], xi, e);
        return function(r) {
          const a = i(r);
          if (typeof a != "boolean") throw new Error(`Expected a boolean for ${t}`);
          return a;
        };
      }
      function Yx(n, t, e) {
        if (!(t in n)) return null;
        const i = cs(n[t], Lr, e);
        return function(r) {
          return oN(i(r), t);
        };
      }
      function eN(n, t, e) {
        if (!(t in n)) return null;
        const i = cs(n[t], fl, e);
        return function(r) {
          return fA(i(r), t);
        };
      }
      function c0(n, t, e) {
        if (!(t in n)) return null;
        const i = cs(n[t], fl, e);
        return function(r) {
          const a = fA(i(r), t);
          if (a.length !== 2) throw new Error(`Expected two numbers for ${t}`);
          return a;
        };
      }
      function nN(n, t, e) {
        if (!(t in n)) return null;
        const i = cs(n[t], fl, e);
        return function(r) {
          return sN(i(r), t);
        };
      }
      function f0(n, t, e) {
        if (!(t in n)) return null;
        const i = cs(n[t], fl | se, e);
        return function(r) {
          return p$(i(r), t);
        };
      }
      function g0(n, t) {
        const e = n[t];
        if (e !== void 0) {
          if (typeof e != "number") throw new Error(`Expected a number for ${t}`);
          return e;
        }
      }
      function f$(n, t) {
        const e = n[t];
        if (e !== void 0) {
          if (typeof e == "number") return bn(e);
          if (!Array.isArray(e)) throw new Error(`Expected a number or size array for ${t}`);
          if (e.length !== 2 || typeof e[0] != "number" || typeof e[1] != "number") throw new Error(`Expected a number or size array for ${t}`);
          return e;
        }
      }
      function g$(n, t) {
        const e = n[t];
        if (e !== void 0) {
          if (typeof e != "string") throw new Error(`Expected a string for ${t}`);
          return e;
        }
      }
      function iN(n, t) {
        const e = n[t];
        if (e !== void 0) {
          if (e !== "bottom-left" && e !== "bottom-right" && e !== "top-left" && e !== "top-right") throw new Error(`Expected bottom-left, bottom-right, top-left, or top-right for ${t}`);
          return e;
        }
      }
      function rN(n, t) {
        const e = n[t];
        if (e !== void 0) {
          if (e !== "pixels" && e !== "fraction") throw new Error(`Expected pixels or fraction for ${t}`);
          return e;
        }
      }
      function d$(n, t) {
        const e = n[t];
        if (e !== void 0) return fA(e, t);
      }
      function d0(n, t) {
        const e = n[t];
        if (e !== void 0) {
          if (typeof e != "string") throw new Error(`Expected a string for ${t}`);
          if (e !== "declutter" && e !== "obstacle" && e !== "none") throw new Error(`Expected declutter, obstacle, or none for ${t}`);
          return e;
        }
      }
      function A$(n, t) {
        const e = n[t];
        if (e !== void 0) return oN(e, t);
      }
      function fA(n, t) {
        if (!Array.isArray(n)) throw new Error(`Expected an array for ${t}`);
        const e = n.length;
        for (let i = 0; i < e; ++i) if (typeof n[i] != "number") throw new Error(`Expected an array of numbers for ${t}`);
        return n;
      }
      function aN(n, t) {
        if (typeof n != "string") throw new Error(`Expected a string for ${t}`);
        return n;
      }
      function Wx(n, t) {
        if (typeof n != "number") throw new Error(`Expected a number for ${t}`);
        return n;
      }
      function oN(n, t) {
        if (typeof n == "string") return n;
        const e = fA(n, t), i = e.length;
        if (i < 3 || i > 4) throw new Error(`Expected a color with 3 or 4 values for ${t}`);
        return e;
      }
      function sN(n, t) {
        const e = fA(n, t);
        if (e.length !== 2) throw new Error(`Expected an array of two numbers for ${t}`);
        return e;
      }
      function p$(n, t) {
        return typeof n == "number" ? n : sN(n, t);
      }
      const lN = { RENDER_ORDER: "renderOrder" };
      class A0 extends Yc {
        constructor(t) {
          t = t || {};
          const e = Object.assign({}, t);
          delete e.style, delete e.renderBuffer, delete e.updateWhileAnimating, delete e.updateWhileInteracting, super(e), this.declutter_ = t.declutter ? String(t.declutter) : void 0, this.renderBuffer_ = t.renderBuffer !== void 0 ? t.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(t.style), this.updateWhileAnimating_ = t.updateWhileAnimating !== void 0 ? t.updateWhileAnimating : false, this.updateWhileInteracting_ = t.updateWhileInteracting !== void 0 ? t.updateWhileInteracting : false;
        }
        getDeclutter() {
          return this.declutter_;
        }
        getFeatures(t) {
          return super.getFeatures(t);
        }
        getRenderBuffer() {
          return this.renderBuffer_;
        }
        getRenderOrder() {
          return this.get(lN.RENDER_ORDER);
        }
        getStyle() {
          return this.style_;
        }
        getStyleFunction() {
          return this.styleFunction_;
        }
        getUpdateWhileAnimating() {
          return this.updateWhileAnimating_;
        }
        getUpdateWhileInteracting() {
          return this.updateWhileInteracting_;
        }
        renderDeclutter(t, e) {
          const i = this.getDeclutter();
          i in t.declutter || (t.declutter[i] = new HP(9)), this.getRenderer().renderDeclutter(t, e);
        }
        setRenderOrder(t) {
          this.set(lN.RENDER_ORDER, t);
        }
        setStyle(t) {
          this.style_ = t === void 0 ? FP : t;
          const e = v$(t);
          this.styleFunction_ = t === null ? void 0 : dK(e), this.changed();
        }
      }
      function v$(n) {
        if (n === void 0) return FP;
        if (!n) return null;
        if (typeof n == "function" || n instanceof de) return n;
        if (!Array.isArray(n)) return tN([n]);
        if (n.length === 0) return [];
        const t = n.length, e = n[0];
        if (e instanceof de) {
          const r = new Array(t);
          for (let a = 0; a < t; ++a) {
            const o = n[a];
            if (!(o instanceof de)) throw new Error("Expected a list of style instances");
            r[a] = o;
          }
          return r;
        }
        if ("style" in e) {
          const r = new Array(t);
          for (let a = 0; a < t; ++a) {
            const o = n[a];
            if (!("style" in o)) throw new Error("Expected a list of rules with a style property");
            r[a] = o;
          }
          return r$(r);
        }
        return tN(n);
      }
      const jt = { BEGIN_GEOMETRY: 0, BEGIN_PATH: 1, CIRCLE: 2, CLOSE_PATH: 3, CUSTOM: 4, DRAW_CHARS: 5, DRAW_IMAGE: 6, END_GEOMETRY: 7, FILL: 8, MOVE_TO_LINE_TO: 9, SET_FILL_STYLE: 10, SET_STROKE_STYLE: 11, STROKE: 12 }, p0 = [jt.FILL], dl = [jt.STROKE], Fu = [jt.BEGIN_PATH], uN = [jt.CLOSE_PATH];
      class hN {
        drawCustom(t, e, i, r, a) {
        }
        drawGeometry(t) {
        }
        setStyle(t) {
        }
        drawCircle(t, e, i) {
        }
        drawFeature(t, e, i) {
        }
        drawGeometryCollection(t, e, i) {
        }
        drawLineString(t, e, i) {
        }
        drawMultiLineString(t, e, i) {
        }
        drawMultiPoint(t, e, i) {
        }
        drawMultiPolygon(t, e, i) {
        }
        drawPoint(t, e, i) {
        }
        drawPolygon(t, e, i) {
        }
        drawText(t, e, i) {
        }
        setFillStrokeStyle(t, e) {
        }
        setImageStyle(t, e) {
        }
        setTextStyle(t, e) {
        }
      }
      class gA extends hN {
        constructor(t, e, i, r) {
          super(), this.tolerance = t, this.maxExtent = e, this.pixelRatio = r, this.maxLineWidth = 0, this.resolution = i, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = {};
        }
        applyPixelRatio(t) {
          const e = this.pixelRatio;
          return e == 1 ? t : t.map(function(i) {
            return i * e;
          });
        }
        appendFlatPointCoordinates(t, e) {
          const i = this.getBufferedMaxExtent(), r = this.tmpCoordinate_, a = this.coordinates;
          let o = a.length;
          for (let s = 0, l = t.length; s < l; s += e) r[0] = t[s], r[1] = t[s + 1], Wr(i, r) && (a[o++] = r[0], a[o++] = r[1]);
          return o;
        }
        appendFlatLineCoordinates(t, e, i, r, a, o) {
          const s = this.coordinates;
          let l = s.length;
          const u = this.getBufferedMaxExtent();
          o && (e += r);
          let h = t[e], c = t[e + 1];
          const f = this.tmpCoordinate_;
          let g = true, d, A, p;
          for (d = e + r; d < i; d += r) f[0] = t[d], f[1] = t[d + 1], p = HE(u, f), p !== A ? (g && (s[l++] = h, s[l++] = c, g = false), s[l++] = f[0], s[l++] = f[1]) : p === ti.INTERSECTING ? (s[l++] = f[0], s[l++] = f[1], g = false) : g = true, h = f[0], c = f[1], A = p;
          return (a && g || d === e + r) && (s[l++] = h, s[l++] = c), l;
        }
        drawCustomCoordinates_(t, e, i, r, a) {
          for (let o = 0, s = i.length; o < s; ++o) {
            const l = i[o], u = this.appendFlatLineCoordinates(t, e, l, r, false, false);
            a.push(u), e = l;
          }
          return e;
        }
        drawCustom(t, e, i, r, a) {
          this.beginGeometry(t, e, a);
          const o = t.getType(), s = t.getStride(), l = this.coordinates.length;
          let u, h, c, f, g;
          switch (o) {
            case "MultiPolygon":
              u = t.getOrientedFlatCoordinates(), f = [];
              const d = t.getEndss();
              g = 0;
              for (let A = 0, p = d.length; A < p; ++A) {
                const v = [];
                g = this.drawCustomCoordinates_(u, g, d[A], s, v), f.push(v);
              }
              this.instructions.push([jt.CUSTOM, l, f, t, i, gx, a]), this.hitDetectionInstructions.push([jt.CUSTOM, l, f, t, r || i, gx, a]);
              break;
            case "Polygon":
            case "MultiLineString":
              c = [], u = o == "Polygon" ? t.getOrientedFlatCoordinates() : t.getFlatCoordinates(), g = this.drawCustomCoordinates_(u, 0, t.getEnds(), s, c), this.instructions.push([jt.CUSTOM, l, c, t, i, Xd, a]), this.hitDetectionInstructions.push([jt.CUSTOM, l, c, t, r || i, Xd, a]);
              break;
            case "LineString":
            case "Circle":
              u = t.getFlatCoordinates(), h = this.appendFlatLineCoordinates(u, 0, u.length, s, false, false), this.instructions.push([jt.CUSTOM, l, h, t, i, ss, a]), this.hitDetectionInstructions.push([jt.CUSTOM, l, h, t, r || i, ss, a]);
              break;
            case "MultiPoint":
              u = t.getFlatCoordinates(), h = this.appendFlatPointCoordinates(u, s), h > l && (this.instructions.push([jt.CUSTOM, l, h, t, i, ss, a]), this.hitDetectionInstructions.push([jt.CUSTOM, l, h, t, r || i, ss, a]));
              break;
            case "Point":
              u = t.getFlatCoordinates(), this.coordinates.push(u[0], u[1]), h = this.coordinates.length, this.instructions.push([jt.CUSTOM, l, h, t, i, void 0, a]), this.hitDetectionInstructions.push([jt.CUSTOM, l, h, t, r || i, void 0, a]);
              break;
          }
          this.endGeometry(e);
        }
        beginGeometry(t, e, i) {
          this.beginGeometryInstruction1_ = [jt.BEGIN_GEOMETRY, e, 0, t, i], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [jt.BEGIN_GEOMETRY, e, 0, t, i], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
        }
        finish() {
          return { instructions: this.instructions, hitDetectionInstructions: this.hitDetectionInstructions, coordinates: this.coordinates };
        }
        reverseHitDetectionInstructions() {
          const t = this.hitDetectionInstructions;
          t.reverse();
          let e;
          const i = t.length;
          let r, a, o = -1;
          for (e = 0; e < i; ++e) r = t[e], a = r[0], a == jt.END_GEOMETRY ? o = e : a == jt.BEGIN_GEOMETRY && (r[2] = e, Nd(this.hitDetectionInstructions, o, e), o = -1);
        }
        setFillStrokeStyle(t, e) {
          const i = this.state;
          if (t) {
            const r = t.getColor();
            i.fillPatternScale = r && typeof r == "object" && "src" in r ? this.pixelRatio : 1, i.fillStyle = so(r || ar);
          } else i.fillStyle = void 0;
          if (e) {
            const r = e.getColor();
            i.strokeStyle = so(r || eA);
            const a = e.getLineCap();
            i.lineCap = a !== void 0 ? a : Vc;
            const o = e.getLineDash();
            i.lineDash = o ? o.slice() : ls;
            const s = e.getLineDashOffset();
            i.lineDashOffset = s || us;
            const l = e.getLineJoin();
            i.lineJoin = l !== void 0 ? l : jc;
            const u = e.getWidth();
            i.lineWidth = u !== void 0 ? u : iA;
            const h = e.getMiterLimit();
            i.miterLimit = h !== void 0 ? h : tA, i.lineWidth > this.maxLineWidth && (this.maxLineWidth = i.lineWidth, this.bufferedMaxExtent_ = null);
          } else i.strokeStyle = void 0, i.lineCap = void 0, i.lineDash = null, i.lineDashOffset = void 0, i.lineJoin = void 0, i.lineWidth = void 0, i.miterLimit = void 0;
        }
        createFill(t) {
          const e = t.fillStyle, i = [jt.SET_FILL_STYLE, e];
          return typeof e != "string" && i.push(t.fillPatternScale), i;
        }
        applyStroke(t) {
          this.instructions.push(this.createStroke(t));
        }
        createStroke(t) {
          return [jt.SET_STROKE_STYLE, t.strokeStyle, t.lineWidth * this.pixelRatio, t.lineCap, t.lineJoin, t.miterLimit, this.applyPixelRatio(t.lineDash), t.lineDashOffset * this.pixelRatio];
        }
        updateFillStyle(t, e) {
          const i = t.fillStyle;
          (typeof i != "string" || t.currentFillStyle != i) && (i !== void 0 && this.instructions.push(e.call(this, t)), t.currentFillStyle = i);
        }
        updateStrokeStyle(t, e) {
          const i = t.strokeStyle, r = t.lineCap, a = t.lineDash, o = t.lineDashOffset, s = t.lineJoin, l = t.lineWidth, u = t.miterLimit;
          (t.currentStrokeStyle != i || t.currentLineCap != r || a != t.currentLineDash && !no(t.currentLineDash, a) || t.currentLineDashOffset != o || t.currentLineJoin != s || t.currentLineWidth != l || t.currentMiterLimit != u) && (i !== void 0 && e.call(this, t), t.currentStrokeStyle = i, t.currentLineCap = r, t.currentLineDash = a, t.currentLineDashOffset = o, t.currentLineJoin = s, t.currentLineWidth = l, t.currentMiterLimit = u);
        }
        endGeometry(t) {
          this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
          const e = [jt.END_GEOMETRY, t];
          this.instructions.push(e), this.hitDetectionInstructions.push(e);
        }
        getBufferedMaxExtent() {
          if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = LL(this.maxExtent), this.maxLineWidth > 0)) {
            const t = this.resolution * (this.maxLineWidth + 1) / 2;
            es(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_);
          }
          return this.bufferedMaxExtent_;
        }
      }
      class y$ extends gA {
        constructor(t, e, i, r) {
          super(t, e, i, r), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
        }
        drawPoint(t, e, i) {
          if (!this.image_ || this.maxExtent && !Wr(this.maxExtent, t.getFlatCoordinates())) return;
          this.beginGeometry(t, e, i);
          const r = t.getFlatCoordinates(), a = t.getStride(), o = this.coordinates.length, s = this.appendFlatPointCoordinates(r, a);
          this.instructions.push([jt.DRAW_IMAGE, o, s, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]), this.hitDetectionInstructions.push([jt.DRAW_IMAGE, o, s, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, 1, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]), this.endGeometry(e);
        }
        drawMultiPoint(t, e, i) {
          if (!this.image_) return;
          this.beginGeometry(t, e, i);
          const r = t.getFlatCoordinates(), a = [];
          for (let l = 0, u = r.length; l < u; l += t.getStride()) (!this.maxExtent || Wr(this.maxExtent, r.slice(l, l + 2))) && a.push(r[l], r[l + 1]);
          const o = this.coordinates.length, s = this.appendFlatPointCoordinates(a, 2);
          this.instructions.push([jt.DRAW_IMAGE, o, s, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]), this.hitDetectionInstructions.push([jt.DRAW_IMAGE, o, s, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, 1, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]), this.endGeometry(e);
        }
        finish() {
          return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
        }
        setImageStyle(t, e) {
          const i = t.getAnchor(), r = t.getSize(), a = t.getOrigin();
          this.imagePixelRatio_ = t.getPixelRatio(this.pixelRatio), this.anchorX_ = i[0], this.anchorY_ = i[1], this.hitDetectionImage_ = t.getHitDetectionImage(), this.image_ = t.getImage(this.pixelRatio), this.height_ = r[1], this.opacity_ = t.getOpacity(), this.originX_ = a[0], this.originY_ = a[1], this.rotateWithView_ = t.getRotateWithView(), this.rotation_ = t.getRotation(), this.scale_ = t.getScaleArray(), this.width_ = r[0], this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = e;
        }
      }
      class m$ extends gA {
        constructor(t, e, i, r) {
          super(t, e, i, r);
        }
        drawFlatCoordinates_(t, e, i, r) {
          const a = this.coordinates.length, o = this.appendFlatLineCoordinates(t, e, i, r, false, false), s = [jt.MOVE_TO_LINE_TO, a, o];
          return this.instructions.push(s), this.hitDetectionInstructions.push(s), i;
        }
        drawLineString(t, e, i) {
          const r = this.state, a = r.strokeStyle, o = r.lineWidth;
          if (a === void 0 || o === void 0) return;
          this.updateStrokeStyle(r, this.applyStroke), this.beginGeometry(t, e, i), this.hitDetectionInstructions.push([jt.SET_STROKE_STYLE, r.strokeStyle, r.lineWidth, r.lineCap, r.lineJoin, r.miterLimit, ls, us], Fu);
          const s = t.getFlatCoordinates(), l = t.getStride();
          this.drawFlatCoordinates_(s, 0, s.length, l), this.hitDetectionInstructions.push(dl), this.endGeometry(e);
        }
        drawMultiLineString(t, e, i) {
          const r = this.state, a = r.strokeStyle, o = r.lineWidth;
          if (a === void 0 || o === void 0) return;
          this.updateStrokeStyle(r, this.applyStroke), this.beginGeometry(t, e, i), this.hitDetectionInstructions.push([jt.SET_STROKE_STYLE, r.strokeStyle, r.lineWidth, r.lineCap, r.lineJoin, r.miterLimit, ls, us], Fu);
          const s = t.getEnds(), l = t.getFlatCoordinates(), u = t.getStride();
          let h = 0;
          for (let c = 0, f = s.length; c < f; ++c) h = this.drawFlatCoordinates_(l, h, s[c], u);
          this.hitDetectionInstructions.push(dl), this.endGeometry(e);
        }
        finish() {
          const t = this.state;
          return t.lastStroke != null && t.lastStroke != this.coordinates.length && this.instructions.push(dl), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
        }
        applyStroke(t) {
          t.lastStroke != null && t.lastStroke != this.coordinates.length && (this.instructions.push(dl), t.lastStroke = this.coordinates.length), t.lastStroke = 0, super.applyStroke(t), this.instructions.push(Fu);
        }
      }
      class cN extends gA {
        constructor(t, e, i, r) {
          super(t, e, i, r);
        }
        drawFlatCoordinatess_(t, e, i, r) {
          const a = this.state, o = a.fillStyle !== void 0, s = a.strokeStyle !== void 0, l = i.length;
          this.instructions.push(Fu), this.hitDetectionInstructions.push(Fu);
          for (let u = 0; u < l; ++u) {
            const h = i[u], c = this.coordinates.length, f = this.appendFlatLineCoordinates(t, e, h, r, true, !s), g = [jt.MOVE_TO_LINE_TO, c, f];
            this.instructions.push(g), this.hitDetectionInstructions.push(g), s && (this.instructions.push(uN), this.hitDetectionInstructions.push(uN)), e = h;
          }
          return o && (this.instructions.push(p0), this.hitDetectionInstructions.push(p0)), s && (this.instructions.push(dl), this.hitDetectionInstructions.push(dl)), e;
        }
        drawCircle(t, e, i) {
          const r = this.state, a = r.fillStyle, o = r.strokeStyle;
          if (a === void 0 && o === void 0) return;
          this.setFillStrokeStyles_(), this.beginGeometry(t, e, i), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([jt.SET_FILL_STYLE, ar]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([jt.SET_STROKE_STYLE, r.strokeStyle, r.lineWidth, r.lineCap, r.lineJoin, r.miterLimit, ls, us]);
          const s = t.getFlatCoordinates(), l = t.getStride(), u = this.coordinates.length;
          this.appendFlatLineCoordinates(s, 0, s.length, l, false, false);
          const h = [jt.CIRCLE, u];
          this.instructions.push(Fu, h), this.hitDetectionInstructions.push(Fu, h), r.fillStyle !== void 0 && (this.instructions.push(p0), this.hitDetectionInstructions.push(p0)), r.strokeStyle !== void 0 && (this.instructions.push(dl), this.hitDetectionInstructions.push(dl)), this.endGeometry(e);
        }
        drawPolygon(t, e, i) {
          const r = this.state, a = r.fillStyle, o = r.strokeStyle;
          if (a === void 0 && o === void 0) return;
          this.setFillStrokeStyles_(), this.beginGeometry(t, e, i), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([jt.SET_FILL_STYLE, ar]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([jt.SET_STROKE_STYLE, r.strokeStyle, r.lineWidth, r.lineCap, r.lineJoin, r.miterLimit, ls, us]);
          const s = t.getEnds(), l = t.getOrientedFlatCoordinates(), u = t.getStride();
          this.drawFlatCoordinatess_(l, 0, s, u), this.endGeometry(e);
        }
        drawMultiPolygon(t, e, i) {
          const r = this.state, a = r.fillStyle, o = r.strokeStyle;
          if (a === void 0 && o === void 0) return;
          this.setFillStrokeStyles_(), this.beginGeometry(t, e, i), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([jt.SET_FILL_STYLE, ar]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([jt.SET_STROKE_STYLE, r.strokeStyle, r.lineWidth, r.lineCap, r.lineJoin, r.miterLimit, ls, us]);
          const s = t.getEndss(), l = t.getOrientedFlatCoordinates(), u = t.getStride();
          let h = 0;
          for (let c = 0, f = s.length; c < f; ++c) h = this.drawFlatCoordinatess_(l, h, s[c], u);
          this.endGeometry(e);
        }
        finish() {
          this.reverseHitDetectionInstructions(), this.state = null;
          const t = this.tolerance;
          if (t !== 0) {
            const e = this.coordinates;
            for (let i = 0, r = e.length; i < r; ++i) e[i] = Ru(e[i], t);
          }
          return super.finish();
        }
        setFillStrokeStyles_() {
          const t = this.state;
          t.fillStyle !== void 0 && this.updateFillStyle(t, this.createFill), t.strokeStyle !== void 0 && this.updateStrokeStyle(t, this.applyStroke);
        }
      }
      function _$(n, t, e, i, r) {
        const a = [];
        let o = e, s = 0, l = t.slice(e, 2);
        for (; s < n && o + r < i; ) {
          const [u, h] = l.slice(-2), c = t[o + r], f = t[o + r + 1], g = Math.sqrt((c - u) * (c - u) + (f - h) * (f - h));
          if (s += g, s >= n) {
            const d = (n - s + g) / g, A = Tr(u, c, d), p = Tr(h, f, d);
            l.push(A, p), a.push(l), l = [A, p], s == n && (o += r), s = 0;
          } else if (s < n) l.push(t[o + r], t[o + r + 1]), o += r;
          else {
            const d = g - s, A = Tr(u, c, d / g), p = Tr(h, f, d / g);
            l.push(A, p), a.push(l), l = [A, p], s = 0, o += r;
          }
        }
        return s > 0 && a.push(l), a;
      }
      function I$(n, t, e, i, r) {
        let a = e, o = e, s = 0, l = 0, u = e, h, c, f, g, d, A, p, v, y, m;
        for (c = e; c < i; c += r) {
          const _ = t[c], E = t[c + 1];
          d !== void 0 && (y = _ - d, m = E - A, g = Math.sqrt(y * y + m * m), p !== void 0 && (l += f, h = Math.acos((p * y + v * m) / (f * g)), h > n && (l > s && (s = l, a = u, o = c), l = 0, u = c - r)), f = g, p = y, v = m), d = _, A = E;
        }
        return l += g, l > s ? [u, c] : [a, o];
      }
      const v0 = { left: 0, center: 0.5, right: 1, top: 0, middle: 0.5, hanging: 0.2, alphabetic: 0.8, ideographic: 0.8, bottom: 1 };
      class E$ extends gA {
        constructor(t, e, i, r) {
          super(t, e, i, r), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.fillStates[ar] = { fillStyle: ar }, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
        }
        finish() {
          const t = super.finish();
          return t.textStates = this.textStates, t.fillStates = this.fillStates, t.strokeStates = this.strokeStates, t;
        }
        drawText(t, e, i) {
          const r = this.textFillState_, a = this.textStrokeState_, o = this.textState_;
          if (this.text_ === "" || !o || !r && !a) return;
          const s = this.coordinates;
          let l = s.length;
          const u = t.getType();
          let h = null, c = t.getStride();
          if (o.placement === "line" && (u == "LineString" || u == "MultiLineString" || u == "Polygon" || u == "MultiPolygon")) {
            if (!hi(this.maxExtent, t.getExtent())) return;
            let f;
            if (h = t.getFlatCoordinates(), u == "LineString") f = [h.length];
            else if (u == "MultiLineString") f = t.getEnds();
            else if (u == "Polygon") f = t.getEnds().slice(0, 1);
            else if (u == "MultiPolygon") {
              const p = t.getEndss();
              f = [];
              for (let v = 0, y = p.length; v < y; ++v) f.push(p[v][0]);
            }
            this.beginGeometry(t, e, i);
            const g = o.repeat, d = g ? void 0 : o.textAlign;
            let A = 0;
            for (let p = 0, v = f.length; p < v; ++p) {
              let y;
              g ? y = _$(g * this.resolution, h, A, f[p], c) : y = [h.slice(A, f[p])];
              for (let m = 0, _ = y.length; m < _; ++m) {
                const E = y[m];
                let I = 0, x = E.length;
                if (d == null) {
                  const C = I$(o.maxAngle, E, 0, E.length, 2);
                  I = C[0], x = C[1];
                }
                for (let C = I; C < x; C += c) s.push(E[C], E[C + 1]);
                const w = s.length;
                A = f[p], this.drawChars_(l, w), l = w;
              }
            }
            this.endGeometry(e);
          } else {
            let f = o.overflow ? null : [];
            switch (u) {
              case "Point":
              case "MultiPoint":
                h = t.getFlatCoordinates();
                break;
              case "LineString":
                h = t.getFlatMidpoint();
                break;
              case "Circle":
                h = t.getCenter();
                break;
              case "MultiLineString":
                h = t.getFlatMidpoints(), c = 2;
                break;
              case "Polygon":
                h = t.getFlatInteriorPoint(), o.overflow || f.push(h[2] / this.resolution), c = 3;
                break;
              case "MultiPolygon":
                const y = t.getFlatInteriorPoints();
                h = [];
                for (let m = 0, _ = y.length; m < _; m += 3) o.overflow || f.push(y[m + 2] / this.resolution), h.push(y[m], y[m + 1]);
                if (h.length === 0) return;
                c = 2;
                break;
            }
            const g = this.appendFlatPointCoordinates(h, c);
            if (g === l) return;
            if (f && (g - l) / 2 !== h.length / c) {
              let y = l / 2;
              f = f.filter((m, _) => {
                const E = s[(y + _) * 2] === h[_ * c] && s[(y + _) * 2 + 1] === h[_ * c + 1];
                return E || --y, E;
              });
            }
            this.saveTextStates_(), (o.backgroundFill || o.backgroundStroke) && (this.setFillStrokeStyle(o.backgroundFill, o.backgroundStroke), o.backgroundFill && this.updateFillStyle(this.state, this.createFill), o.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(t, e, i);
            let d = o.padding;
            if (d != Pu && (o.scale[0] < 0 || o.scale[1] < 0)) {
              let y = o.padding[0], m = o.padding[1], _ = o.padding[2], E = o.padding[3];
              o.scale[0] < 0 && (m = -m, E = -E), o.scale[1] < 0 && (y = -y, _ = -_), d = [y, m, _, E];
            }
            const A = this.pixelRatio;
            this.instructions.push([jt.DRAW_IMAGE, l, g, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, this.declutterMode_, this.declutterImageWithText_, d == Pu ? Pu : d.map(function(y) {
              return y * A;
            }), !!o.backgroundFill, !!o.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, f]);
            const p = 1 / A, v = this.state.fillStyle;
            o.backgroundFill && (this.state.fillStyle = ar, this.hitDetectionInstructions.push(this.createFill(this.state))), this.hitDetectionInstructions.push([jt.DRAW_IMAGE, l, g, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [p, p], NaN, this.declutterMode_, this.declutterImageWithText_, d, !!o.backgroundFill, !!o.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_ ? ar : this.fillKey_, this.textOffsetX_, this.textOffsetY_, f]), o.backgroundFill && (this.state.fillStyle = v, this.hitDetectionInstructions.push(this.createFill(this.state))), this.endGeometry(e);
          }
        }
        saveTextStates_() {
          const t = this.textStrokeState_, e = this.textState_, i = this.textFillState_, r = this.strokeKey_;
          t && (r in this.strokeStates || (this.strokeStates[r] = { strokeStyle: t.strokeStyle, lineCap: t.lineCap, lineDashOffset: t.lineDashOffset, lineWidth: t.lineWidth, lineJoin: t.lineJoin, miterLimit: t.miterLimit, lineDash: t.lineDash }));
          const a = this.textKey_;
          a in this.textStates || (this.textStates[a] = { font: e.font, textAlign: e.textAlign || nA, justify: e.justify, textBaseline: e.textBaseline || a0, scale: e.scale });
          const o = this.fillKey_;
          i && (o in this.fillStates || (this.fillStates[o] = { fillStyle: i.fillStyle }));
        }
        drawChars_(t, e) {
          const i = this.textStrokeState_, r = this.textState_, a = this.strokeKey_, o = this.textKey_, s = this.fillKey_;
          this.saveTextStates_();
          const l = this.pixelRatio, u = v0[r.textBaseline], h = this.textOffsetY_ * l, c = this.text_, f = i ? i.lineWidth * Math.abs(r.scale[0]) / 2 : 0;
          this.instructions.push([jt.DRAW_CHARS, t, e, u, r.overflow, s, r.maxAngle, l, h, a, f * l, c, o, 1, this.declutterMode_]), this.hitDetectionInstructions.push([jt.DRAW_CHARS, t, e, u, r.overflow, s && ar, r.maxAngle, l, h, a, f * l, c, o, 1 / l, this.declutterMode_]);
        }
        setTextStyle(t, e) {
          let i, r, a;
          if (!t) this.text_ = "";
          else {
            const o = t.getFill();
            o ? (r = this.textFillState_, r || (r = {}, this.textFillState_ = r), r.fillStyle = so(o.getColor() || ar)) : (r = null, this.textFillState_ = r);
            const s = t.getStroke();
            if (!s) a = null, this.textStrokeState_ = a;
            else {
              a = this.textStrokeState_, a || (a = {}, this.textStrokeState_ = a);
              const d = s.getLineDash(), A = s.getLineDashOffset(), p = s.getWidth(), v = s.getMiterLimit();
              a.lineCap = s.getLineCap() || Vc, a.lineDash = d ? d.slice() : ls, a.lineDashOffset = A === void 0 ? us : A, a.lineJoin = s.getLineJoin() || jc, a.lineWidth = p === void 0 ? iA : p, a.miterLimit = v === void 0 ? tA : v, a.strokeStyle = so(s.getColor() || eA);
            }
            i = this.textState_;
            const l = t.getFont() || PP;
            uK(l);
            const u = t.getScaleArray();
            i.overflow = t.getOverflow(), i.font = l, i.maxAngle = t.getMaxAngle(), i.placement = t.getPlacement(), i.textAlign = t.getTextAlign(), i.repeat = t.getRepeat(), i.justify = t.getJustify(), i.textBaseline = t.getTextBaseline() || a0, i.backgroundFill = t.getBackgroundFill(), i.backgroundStroke = t.getBackgroundStroke(), i.padding = t.getPadding() || Pu, i.scale = u === void 0 ? [1, 1] : u;
            const h = t.getOffsetX(), c = t.getOffsetY(), f = t.getRotateWithView(), g = t.getRotation();
            this.text_ = t.getText() || "", this.textOffsetX_ = h === void 0 ? 0 : h, this.textOffsetY_ = c === void 0 ? 0 : c, this.textRotateWithView_ = f === void 0 ? false : f, this.textRotation_ = g === void 0 ? 0 : g, this.strokeKey_ = a ? (typeof a.strokeStyle == "string" ? a.strokeStyle : Ft(a.strokeStyle)) + a.lineCap + a.lineDashOffset + "|" + a.lineWidth + a.lineJoin + a.miterLimit + "[" + a.lineDash.join() + "]" : "", this.textKey_ = i.font + i.scale + (i.textAlign || "?") + (i.repeat || "?") + (i.justify || "?") + (i.textBaseline || "?"), this.fillKey_ = r && r.fillStyle ? typeof r.fillStyle == "string" ? r.fillStyle : "|" + Ft(r.fillStyle) : "";
          }
          this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = e;
        }
      }
      const x$ = { Circle: cN, Default: gA, Image: y$, LineString: m$, Polygon: cN, Text: E$ };
      class w$ {
        constructor(t, e, i, r) {
          this.tolerance_ = t, this.maxExtent_ = e, this.pixelRatio_ = r, this.resolution_ = i, this.buildersByZIndex_ = {};
        }
        finish() {
          const t = {};
          for (const e in this.buildersByZIndex_) {
            t[e] = t[e] || {};
            const i = this.buildersByZIndex_[e];
            for (const r in i) {
              const a = i[r].finish();
              t[e][r] = a;
            }
          }
          return t;
        }
        getBuilder(t, e) {
          const i = t !== void 0 ? t.toString() : "0";
          let r = this.buildersByZIndex_[i];
          r === void 0 && (r = {}, this.buildersByZIndex_[i] = r);
          let a = r[e];
          if (a === void 0) {
            const o = x$[e];
            a = new o(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_), r[e] = a;
          }
          return a;
        }
      }
      const C$ = 5;
      class fN extends Fd {
        constructor(t) {
          super(), this.ready = true, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = t, this.staleKeys_ = new Array(), this.maxStaleKeys = C$;
        }
        getStaleKeys() {
          return this.staleKeys_;
        }
        prependStaleKey(t) {
          this.staleKeys_.unshift(t), this.staleKeys_.length > this.maxStaleKeys && (this.staleKeys_.length = this.maxStaleKeys);
        }
        getFeatures(t) {
          return Qt();
        }
        getData(t) {
          return null;
        }
        prepareFrame(t) {
          return Qt();
        }
        renderFrame(t, e) {
          return Qt();
        }
        forEachFeatureAtCoordinate(t, e, i, r, a) {
        }
        getLayer() {
          return this.layer_;
        }
        handleFontsChanged() {
        }
        handleImageChange_(t) {
          const e = t.target;
          (e.getState() === Bt.LOADED || e.getState() === Bt.ERROR) && this.renderIfReadyAndVisible();
        }
        loadImage(t) {
          let e = t.getState();
          return e != Bt.LOADED && e != Bt.ERROR && t.addEventListener(Nt.CHANGE, this.boundHandleImageChange_), e == Bt.IDLE && (t.load(), e = t.getState()), e == Bt.LOADED;
        }
        renderIfReadyAndVisible() {
          const t = this.getLayer();
          t && t.getVisible() && t.getSourceState() === "ready" && t.changed();
        }
        renderDeferred(t) {
        }
        disposeInternal() {
          delete this.layer_, super.disposeInternal();
        }
      }
      class dA extends Se {
        constructor(t, e, i, r) {
          super(t), this.inversePixelTransform = e, this.frameState = i, this.context = r;
        }
      }
      class gN {
        constructor() {
          Kt(this, "pushMethodArgs_", (...t) => (this.instructions_[this.zIndex + this.offset_].push(t), this));
          this.instructions_ = [], this.zIndex = 0, this.offset_ = 0, this.context_ = new Proxy($y(), { get: (t, e) => {
            if (typeof $y()[e] == "function") return this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(e), this.pushMethodArgs_;
          }, set: (t, e, i) => (this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(e, i), true) });
        }
        pushFunction(t) {
          this.instructions_[this.zIndex + this.offset_].push(t);
        }
        getContext() {
          return this.context_;
        }
        draw(t) {
          this.instructions_.forEach((e) => {
            for (let i = 0, r = e.length; i < r; ++i) {
              const a = e[i];
              if (typeof a == "function") {
                a(t);
                continue;
              }
              const o = e[++i];
              if (typeof t[a] == "function") t[a](...o);
              else {
                if (typeof o == "function") {
                  t[a] = o(t);
                  continue;
                }
                t[a] = o;
              }
            }
          });
        }
        clear() {
          this.instructions_.length = 0, this.zIndex = 0, this.offset_ = 0;
        }
        offset() {
          this.offset_ = this.instructions_.length, this.zIndex = 0;
        }
      }
      const dN = [];
      let Jc = null;
      function S$() {
        Jc = dn(1, 1, void 0, { willReadFrequently: true });
      }
      class y0 extends fN {
        constructor(t) {
          super(t), this.container = null, this.renderedResolution, this.tempTransform = wn(), this.pixelTransform = wn(), this.inversePixelTransform = wn(), this.context = null, this.deferredContext_ = null, this.containerReused = false, this.frameState = null;
        }
        getImageData(t, e, i) {
          Jc || S$(), Jc.clearRect(0, 0, 1, 1);
          let r;
          try {
            Jc.drawImage(t, e, i, 1, 1, 0, 0, 1, 1), r = Jc.getImageData(0, 0, 1, 1).data;
          } catch (a) {
            return Jc = null, null;
          }
          return r;
        }
        getBackground(t) {
          let i = this.getLayer().getBackground();
          return typeof i == "function" && (i = i(t.viewState.resolution)), i || void 0;
        }
        useContainer(t, e, i) {
          const r = this.getLayer().getClassName();
          let a, o;
          if (t && t.className === r && (!i || t && t.style.backgroundColor && no(hl(t.style.backgroundColor), hl(i)))) {
            const s = t.firstElementChild;
            s instanceof HTMLCanvasElement && (o = s.getContext("2d"));
          }
          if (o && o.canvas.style.transform === e ? (this.container = t, this.context = o, this.containerReused = true) : this.containerReused ? (this.container = null, this.context = null, this.containerReused = false) : this.container && (this.container.style.backgroundColor = null), !this.container) {
            a = document.createElement("div"), a.className = r;
            let s = a.style;
            s.position = "absolute", s.width = "100%", s.height = "100%", o = dn();
            const l = o.canvas;
            a.appendChild(l), s = l.style, s.position = "absolute", s.left = "0", s.transformOrigin = "top left", this.container = a, this.context = o;
          }
          !this.containerReused && i && !this.container.style.backgroundColor && (this.container.style.backgroundColor = i);
        }
        clipUnrotated(t, e, i) {
          const r = Zr(i), a = ol(i), o = Nc(i), s = Pc(i);
          gn(e.coordinateToPixelTransform, r), gn(e.coordinateToPixelTransform, a), gn(e.coordinateToPixelTransform, o), gn(e.coordinateToPixelTransform, s);
          const l = this.inversePixelTransform;
          gn(l, r), gn(l, a), gn(l, o), gn(l, s), t.save(), t.beginPath(), t.moveTo(Math.round(r[0]), Math.round(r[1])), t.lineTo(Math.round(a[0]), Math.round(a[1])), t.lineTo(Math.round(o[0]), Math.round(o[1])), t.lineTo(Math.round(s[0]), Math.round(s[1])), t.clip();
        }
        prepareContainer(t, e) {
          const i = t.extent, r = t.viewState.resolution, a = t.viewState.rotation, o = t.pixelRatio, s = Math.round(ve(i) / r * o), l = Math.round(Cn(i) / r * o);
          Sr(this.pixelTransform, t.size[0] / 2, t.size[1] / 2, 1 / o, 1 / o, a, -s / 2, -l / 2), Oy(this.inversePixelTransform, this.pixelTransform);
          const u = RL(this.pixelTransform);
          if (this.useContainer(e, u, this.getBackground(t)), !this.containerReused) {
            const h = this.context.canvas;
            h.width != s || h.height != l ? (h.width = s, h.height = l) : this.context.clearRect(0, 0, s, l), u !== h.style.transform && (h.style.transform = u);
          }
        }
        dispatchRenderEvent_(t, e, i) {
          const r = this.getLayer();
          if (r.hasListener(t)) {
            const a = new dA(t, this.inversePixelTransform, i, e);
            r.dispatchEvent(a);
          }
        }
        preRender(t, e) {
          this.frameState = e, !e.declutter && this.dispatchRenderEvent_(ni.PRERENDER, t, e);
        }
        postRender(t, e) {
          e.declutter || this.dispatchRenderEvent_(ni.POSTRENDER, t, e);
        }
        renderDeferredInternal(t) {
        }
        getRenderContext(t) {
          return t.declutter && !this.deferredContext_ && (this.deferredContext_ = new gN()), t.declutter ? this.deferredContext_.getContext() : this.context;
        }
        renderDeferred(t) {
          t.declutter && (this.dispatchRenderEvent_(ni.PRERENDER, this.context, t), t.declutter && this.deferredContext_ && (this.deferredContext_.draw(this.context), this.deferredContext_.clear()), this.renderDeferredInternal(t), this.dispatchRenderEvent_(ni.POSTRENDER, this.context, t));
        }
        getRenderTransform(t, e, i, r, a, o, s) {
          const l = a / 2, u = o / 2, h = r / e, c = -h, f = -t[0] + s, g = -t[1];
          return Sr(this.tempTransform, l, u, h, c, -i, f, g);
        }
        disposeInternal() {
          delete this.frameState, super.disposeInternal();
        }
      }
      function b$(n, t, e, i, r, a, o, s, l, u, h, c) {
        let f = n[t], g = n[t + 1], d = 0, A = 0, p = 0, v = 0;
        function y() {
          d = f, A = g, t += i, f = n[t], g = n[t + 1], v += p, p = Math.sqrt((f - d) * (f - d) + (g - A) * (g - A));
        }
        do
          y();
        while (t < e - i && v + p < a);
        let m = p === 0 ? 0 : (a - v) / p;
        const _ = Tr(d, f, m), E = Tr(A, g, m), I = t - i, x = v, w = a + s * l(u, r, h);
        for (; t < e - i && v + p < w; ) y();
        m = p === 0 ? 0 : (w - v) / p;
        const C = Tr(d, f, m), S = Tr(A, g, m);
        let b;
        if (c) {
          const L = [_, E, C, S];
          sx(L, 0, 4, 2, c, L, L), b = L[0] > L[2];
        } else b = _ > C;
        const B = Math.PI, T = [], D = I + i === t;
        t = I, p = 0, v = x, f = n[t], g = n[t + 1];
        let R;
        if (D) {
          y(), R = Math.atan2(g - A, f - d), b && (R += R > 0 ? -B : B);
          const L = (C + _) / 2, k = (S + E) / 2;
          return T[0] = [L, k, (w - a) / 2, R, r], T;
        }
        r = r.replace(/\n/g, " ");
        for (let L = 0, k = r.length; L < k; ) {
          y();
          let P = Math.atan2(g - A, f - d);
          if (b && (P += P > 0 ? -B : B), R !== void 0) {
            let G = P - R;
            if (G += G > B ? -2 * B : G < -B ? 2 * B : 0, Math.abs(G) > o) return null;
          }
          R = P;
          const F = L;
          let Q = 0;
          for (; L < k; ++L) {
            const G = b ? k - L - 1 : L, tt = s * l(u, r[G], h);
            if (t + i < e && v + p < a + Q + tt / 2) break;
            Q += tt;
          }
          if (L === F) continue;
          const z = b ? r.substring(k - F, k - L) : r.substring(F, L);
          m = p === 0 ? 0 : (a + Q / 2 - v) / p;
          const j = Tr(d, f, m), $ = Tr(A, g, m);
          T.push([j, $, Q / 2, P, z]), a += Q;
        }
        return T;
      }
      const tf = Ii(), Al = [], gs = [], ds = [], pl = [];
      function AN(n) {
        return n[3].declutterBox;
      }
      const pN = new RegExp("[-----]");
      function Xx(n, t) {
        return t === "start" ? t = pN.test(n) ? "right" : "left" : t === "end" && (t = pN.test(n) ? "left" : "right"), v0[t];
      }
      function B$(n, t, e) {
        return e > 0 && n.push(`
`, ""), n.push(t, ""), n;
      }
      class T$ {
        constructor(t, e, i, r, a) {
          this.overlaps = i, this.pixelRatio = e, this.resolution = t, this.alignAndScaleFill_, this.instructions = r.instructions, this.coordinates = r.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = wn(), this.hitDetectionInstructions = r.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = r.fillStates || {}, this.strokeStates = r.strokeStates || {}, this.textStates = r.textStates || {}, this.widths_ = {}, this.labels_ = {}, this.zIndexContext_ = a ? new gN() : null;
        }
        getZIndexContext() {
          return this.zIndexContext_;
        }
        createLabel(t, e, i, r) {
          const a = t + e + i + r;
          if (this.labels_[a]) return this.labels_[a];
          const o = r ? this.strokeStates[r] : null, s = i ? this.fillStates[i] : null, l = this.textStates[e], u = this.pixelRatio, h = [l.scale[0] * u, l.scale[1] * u], c = l.justify ? v0[l.justify] : Xx(Array.isArray(t) ? t[0] : t, l.textAlign || nA), f = r && o.lineWidth ? o.lineWidth : 0, g = Array.isArray(t) ? t : String(t).split(`
`).reduce(B$, []), { width: d, height: A, widths: p, heights: v, lineWidths: y } = cK(l, g), m = d + f, _ = [], E = (m + 2) * h[0], I = (A + f) * h[1], x = { width: E < 0 ? Math.floor(E) : Math.ceil(E), height: I < 0 ? Math.floor(I) : Math.ceil(I), contextInstructions: _ };
          (h[0] != 1 || h[1] != 1) && _.push("scale", h), r && (_.push("strokeStyle", o.strokeStyle), _.push("lineWidth", f), _.push("lineCap", o.lineCap), _.push("lineJoin", o.lineJoin), _.push("miterLimit", o.miterLimit), _.push("setLineDash", [o.lineDash]), _.push("lineDashOffset", o.lineDashOffset)), i && _.push("fillStyle", s.fillStyle), _.push("textBaseline", "middle"), _.push("textAlign", "center");
          const w = 0.5 - c;
          let C = c * m + w * f;
          const S = [], b = [];
          let B = 0, T = 0, D = 0, R = 0, L;
          for (let k = 0, P = g.length; k < P; k += 2) {
            const F = g[k];
            if (F === `
`) {
              T += B, B = 0, C = c * m + w * f, ++R;
              continue;
            }
            const Q = g[k + 1] || l.font;
            Q !== L && (r && S.push("font", Q), i && b.push("font", Q), L = Q), B = Math.max(B, v[D]);
            const z = [F, C + w * p[D] + c * (p[D] - y[R]), 0.5 * (f + B) + T];
            C += p[D], r && S.push("strokeText", z), i && b.push("fillText", z), ++D;
          }
          return Array.prototype.push.apply(_, S), Array.prototype.push.apply(_, b), this.labels_[a] = x, x;
        }
        replayTextBackground_(t, e, i, r, a, o, s) {
          t.beginPath(), t.moveTo.apply(t, e), t.lineTo.apply(t, i), t.lineTo.apply(t, r), t.lineTo.apply(t, a), t.lineTo.apply(t, e), o && (this.alignAndScaleFill_ = o[2], this.fill_(t)), s && (this.setStrokeStyle_(t, s), t.stroke());
        }
        calculateImageOrLabelDimensions_(t, e, i, r, a, o, s, l, u, h, c, f, g, d, A, p) {
          s *= f[0], l *= f[1];
          let v = i - s, y = r - l;
          const m = a + u > t ? t - u : a, _ = o + h > e ? e - h : o, E = d[3] + m * f[0] + d[1], I = d[0] + _ * f[1] + d[2], x = v - d[3], w = y - d[0];
          (A || c !== 0) && (Al[0] = x, pl[0] = x, Al[1] = w, gs[1] = w, gs[0] = x + E, ds[0] = gs[0], ds[1] = w + I, pl[1] = ds[1]);
          let C;
          return c !== 0 ? (C = Sr(wn(), i, r, 1, 1, c, -i, -r), gn(C, Al), gn(C, gs), gn(C, ds), gn(C, pl), Xr(Math.min(Al[0], gs[0], ds[0], pl[0]), Math.min(Al[1], gs[1], ds[1], pl[1]), Math.max(Al[0], gs[0], ds[0], pl[0]), Math.max(Al[1], gs[1], ds[1], pl[1]), tf)) : Xr(Math.min(x, x + E), Math.min(w, w + I), Math.max(x, x + E), Math.max(w, w + I), tf), g && (v = Math.round(v), y = Math.round(y)), { drawImageX: v, drawImageY: y, drawImageW: m, drawImageH: _, originX: u, originY: h, declutterBox: { minX: tf[0], minY: tf[1], maxX: tf[2], maxY: tf[3], value: p }, canvasTransform: C, scale: f };
        }
        replayImageOrLabel_(t, e, i, r, a, o, s) {
          const l = !!(o || s), u = r.declutterBox, h = s ? s[2] * r.scale[0] / 2 : 0;
          return u.minX - h <= e[0] && u.maxX + h >= 0 && u.minY - h <= e[1] && u.maxY + h >= 0 && (l && this.replayTextBackground_(t, Al, gs, ds, pl, o, s), fK(t, r.canvasTransform, a, i, r.originX, r.originY, r.drawImageW, r.drawImageH, r.drawImageX, r.drawImageY, r.scale)), true;
        }
        fill_(t) {
          const e = this.alignAndScaleFill_;
          if (e) {
            const i = gn(this.renderedTransform_, [0, 0]), r = 512 * this.pixelRatio;
            t.save(), t.translate(i[0] % r, i[1] % r), e !== 1 && t.scale(e, e), t.rotate(this.viewRotation_);
          }
          t.fill(), e && t.restore();
        }
        setStrokeStyle_(t, e) {
          t.strokeStyle = e[1], t.lineWidth = e[2], t.lineCap = e[3], t.lineJoin = e[4], t.miterLimit = e[5], t.lineDashOffset = e[7], t.setLineDash(e[6]);
        }
        drawLabelWithPointPlacement_(t, e, i, r) {
          const a = this.textStates[e], o = this.createLabel(t, e, r, i), s = this.strokeStates[i], l = this.pixelRatio, u = Xx(Array.isArray(t) ? t[0] : t, a.textAlign || nA), h = v0[a.textBaseline || a0], c = s && s.lineWidth ? s.lineWidth : 0, f = o.width / l - 2 * a.scale[0], g = u * f + 2 * (0.5 - u) * c, d = h * o.height / l + 2 * (0.5 - h) * c;
          return { label: o, anchorX: g, anchorY: d };
        }
        execute_(t, e, i, r, a, o, s, l) {
          const u = this.zIndexContext_;
          let h;
          this.pixelCoordinates_ && no(i, this.renderedTransform_) ? h = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), h = ul(this.coordinates, 0, this.coordinates.length, 2, i, this.pixelCoordinates_), eZ(this.renderedTransform_, i));
          let c = 0;
          const f = r.length;
          let g = 0, d, A, p, v, y, m, _, E, I, x, w, C, S, b = 0, B = 0, T = null, D = null;
          const R = this.coordinateCache_, L = this.viewRotation_, k = Math.round(Math.atan2(-i[1], i[0]) * 1e12) / 1e12, P = { context: t, pixelRatio: this.pixelRatio, resolution: this.resolution, rotation: L }, F = this.instructions != r || this.overlaps ? 0 : 200;
          let Q, z, j, $;
          for (; c < f; ) {
            const G = r[c];
            switch (G[0]) {
              case jt.BEGIN_GEOMETRY:
                Q = G[1], $ = G[3], Q.getGeometry() ? s !== void 0 && !hi(s, $.getExtent()) ? c = G[2] + 1 : ++c : c = G[2], u && (u.zIndex = G[4]);
                break;
              case jt.BEGIN_PATH:
                b > F && (this.fill_(t), b = 0), B > F && (t.stroke(), B = 0), !b && !B && (t.beginPath(), y = NaN, m = NaN), ++c;
                break;
              case jt.CIRCLE:
                g = G[1];
                const J = h[g], et = h[g + 1], nt = h[g + 2], gt = h[g + 3], H = nt - J, W = gt - et, it = Math.sqrt(H * H + W * W);
                t.moveTo(J + it, et), t.arc(J, et, it, 0, 2 * Math.PI, true), ++c;
                break;
              case jt.CLOSE_PATH:
                t.closePath(), ++c;
                break;
              case jt.CUSTOM:
                g = G[1], d = G[2];
                const kt = G[3], vt = G[4], St = G[5];
                P.geometry = kt, P.feature = Q, c in R || (R[c] = []);
                const bt = R[c];
                St ? St(h, g, d, 2, bt) : (bt[0] = h[g], bt[1] = h[g + 1], bt.length = 2), u && (u.zIndex = G[6]), vt(bt, P), ++c;
                break;
              case jt.DRAW_IMAGE:
                g = G[1], d = G[2], I = G[3], A = G[4], p = G[5];
                let Ee = G[6];
                const rn = G[7], Ie = G[8], fn = G[9], an = G[10];
                let wr = G[11];
                const Cr = G[12];
                let Jo = G[13];
                v = G[14] || "declutter";
                const kn = G[15];
                if (!I && G.length >= 20) {
                  x = G[19], w = G[20], C = G[21], S = G[22];
                  const ba = this.drawLabelWithPointPlacement_(x, w, C, S);
                  I = ba.label, G[3] = I;
                  const Bc = G[23];
                  A = (ba.anchorX - Bc) * this.pixelRatio, G[4] = A;
                  const Ba = G[24];
                  p = (ba.anchorY - Ba) * this.pixelRatio, G[5] = p, Ee = I.height, G[6] = Ee, Jo = I.width, G[13] = Jo;
                }
                let Td;
                G.length > 25 && (Td = G[25]);
                let Ty, Md, Dd;
                G.length > 17 ? (Ty = G[16], Md = G[17], Dd = G[18]) : (Ty = Pu, Md = false, Dd = false), an && k ? wr += L : !an && !k && (wr -= L);
                let _L = 0;
                for (; g < d; g += 2) {
                  if (Td && Td[_L++] < Jo / this.pixelRatio) continue;
                  const ba = this.calculateImageOrLabelDimensions_(I.width, I.height, h[g], h[g + 1], Jo, Ee, A, p, Ie, fn, wr, Cr, a, Ty, Md || Dd, Q), Bc = [t, e, I, ba, rn, Md ? T : null, Dd ? D : null];
                  if (l) {
                    let Ba, ts, Ta;
                    if (kn) {
                      const xn = d - g;
                      if (!kn[xn]) {
                        kn[xn] = { args: Bc, declutterMode: v };
                        continue;
                      }
                      const nr = kn[xn];
                      Ba = nr.args, ts = nr.declutterMode, delete kn[xn], Ta = AN(Ba);
                    }
                    let Js, tl;
                    if (Ba && (ts !== "declutter" || !l.collides(Ta)) && (Js = true), (v !== "declutter" || !l.collides(ba.declutterBox)) && (tl = true), ts === "declutter" && v === "declutter") {
                      const xn = Js && tl;
                      Js = xn, tl = xn;
                    }
                    Js && (ts !== "none" && l.insert(Ta), this.replayImageOrLabel_.apply(this, Ba)), tl && (v !== "none" && l.insert(ba.declutterBox), this.replayImageOrLabel_.apply(this, Bc));
                  } else this.replayImageOrLabel_.apply(this, Bc);
                }
                ++c;
                break;
              case jt.DRAW_CHARS:
                const Rd = G[1], IL = G[2], My = G[3], OE = G[4];
                S = G[5];
                const Dy = G[6], eo = G[7], Ld = G[8];
                C = G[9];
                const zE = G[10];
                x = G[11], w = G[12];
                const jX = [G[13], G[13]];
                v = G[14] || "declutter";
                const EL = this.textStates[w], Ry = EL.font, Ly = [EL.scale[0] * eo, EL.scale[1] * eo];
                let Py;
                Ry in this.widths_ ? Py = this.widths_[Ry] : (Py = {}, this.widths_[Ry] = Py);
                const qX = MP(h, Rd, IL, 2), HX = Math.abs(Ly[0]) * kP(Ry, x, Py);
                if (OE || HX <= qX) {
                  const ba = this.textStates[w].textAlign, Bc = (qX - HX) * Xx(x, ba), Ba = b$(h, Rd, IL, 2, x, Bc, Dy, Math.abs(Ly[0]), kP, Ry, Py, k ? 0 : this.viewRotation_);
                  t: if (Ba) {
                    const ts = [];
                    let Ta, Js, tl, xn, nr;
                    if (C) for (Ta = 0, Js = Ba.length; Ta < Js; ++Ta) {
                      nr = Ba[Ta], tl = nr[4], xn = this.createLabel(tl, w, "", C), A = nr[2] + (Ly[0] < 0 ? -zE : zE), p = My * xn.height + (0.5 - My) * 2 * zE * Ly[1] / Ly[0] - Ld;
                      const el = this.calculateImageOrLabelDimensions_(xn.width, xn.height, nr[0], nr[1], xn.width, xn.height, A, p, 0, 0, nr[3], jX, false, Pu, false, Q);
                      if (l && v === "declutter" && l.collides(el.declutterBox)) break t;
                      ts.push([t, e, xn, el, 1, null, null]);
                    }
                    if (S) for (Ta = 0, Js = Ba.length; Ta < Js; ++Ta) {
                      nr = Ba[Ta], tl = nr[4], xn = this.createLabel(tl, w, S, ""), A = nr[2], p = My * xn.height - Ld;
                      const el = this.calculateImageOrLabelDimensions_(xn.width, xn.height, nr[0], nr[1], xn.width, xn.height, A, p, 0, 0, nr[3], jX, false, Pu, false, Q);
                      if (l && v === "declutter" && l.collides(el.declutterBox)) break t;
                      ts.push([t, e, xn, el, 1, null, null]);
                    }
                    l && v !== "none" && l.load(ts.map(AN));
                    for (let el = 0, J3t = ts.length; el < J3t; ++el) this.replayImageOrLabel_.apply(this, ts[el]);
                  }
                }
                ++c;
                break;
              case jt.END_GEOMETRY:
                if (o !== void 0) {
                  Q = G[1];
                  const ba = o(Q, $, v);
                  if (ba) return ba;
                }
                ++c;
                break;
              case jt.FILL:
                F ? b++ : this.fill_(t), ++c;
                break;
              case jt.MOVE_TO_LINE_TO:
                for (g = G[1], d = G[2], z = h[g], j = h[g + 1], t.moveTo(z, j), y = z + 0.5 | 0, m = j + 0.5 | 0, g += 2; g < d; g += 2) z = h[g], j = h[g + 1], _ = z + 0.5 | 0, E = j + 0.5 | 0, (g == d - 2 || _ !== y || E !== m) && (t.lineTo(z, j), y = _, m = E);
                ++c;
                break;
              case jt.SET_FILL_STYLE:
                T = G, this.alignAndScaleFill_ = G[2], b && (this.fill_(t), b = 0, B && (t.stroke(), B = 0)), t.fillStyle = G[1], ++c;
                break;
              case jt.SET_STROKE_STYLE:
                D = G, B && (t.stroke(), B = 0), this.setStrokeStyle_(t, G), ++c;
                break;
              case jt.STROKE:
                F ? B++ : t.stroke(), ++c;
                break;
              default:
                ++c;
                break;
            }
          }
          b && this.fill_(t), B && t.stroke();
        }
        execute(t, e, i, r, a, o) {
          this.viewRotation_ = r, this.execute_(t, e, i, this.instructions, a, void 0, void 0, o);
        }
        executeHitDetection(t, e, i, r, a) {
          return this.viewRotation_ = i, this.execute_(t, [t.canvas.width, t.canvas.height], e, this.hitDetectionInstructions, true, r, a);
        }
      }
      const ef = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"], vN = ["Image", "Text"], M$ = ef.filter((n) => !vN.includes(n));
      class D$ {
        constructor(t, e, i, r, a, o, s) {
          this.maxExtent_ = t, this.overlaps_ = r, this.pixelRatio_ = i, this.resolution_ = e, this.renderBuffer_ = o, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = wn(), this.renderedContext_ = null, this.deferredZIndexContexts_ = {}, this.createExecutors_(a, s);
        }
        clip(t, e) {
          const i = this.getClipCoords(e);
          t.beginPath(), t.moveTo(i[0], i[1]), t.lineTo(i[2], i[3]), t.lineTo(i[4], i[5]), t.lineTo(i[6], i[7]), t.clip();
        }
        createExecutors_(t, e) {
          for (const i in t) {
            let r = this.executorsByZIndex_[i];
            r === void 0 && (r = {}, this.executorsByZIndex_[i] = r);
            const a = t[i];
            for (const o in a) {
              const s = a[o];
              r[o] = new T$(this.resolution_, this.pixelRatio_, this.overlaps_, s, e);
            }
          }
        }
        hasExecutors(t) {
          for (const e in this.executorsByZIndex_) {
            const i = this.executorsByZIndex_[e];
            for (let r = 0, a = t.length; r < a; ++r) if (t[r] in i) return true;
          }
          return false;
        }
        forEachFeatureAtCoordinate(t, e, i, r, a, o) {
          r = Math.round(r);
          const s = r * 2 + 1, l = Sr(this.hitDetectionTransform_, r + 0.5, r + 0.5, 1 / e, -1 / e, -i, -t[0], -t[1]), u = !this.hitDetectionContext_;
          u && (this.hitDetectionContext_ = dn(s, s, void 0, { willReadFrequently: true }));
          const h = this.hitDetectionContext_;
          h.canvas.width !== s || h.canvas.height !== s ? (h.canvas.width = s, h.canvas.height = s) : u || h.clearRect(0, 0, s, s);
          let c;
          this.renderBuffer_ !== void 0 && (c = Ii(), Qd(c, t), es(c, e * (this.renderBuffer_ + r), c));
          const f = R$(r);
          let g;
          function d(E, I, x) {
            const w = h.getImageData(0, 0, s, s).data;
            for (let C = 0, S = f.length; C < S; C++) if (w[f[C]] > 0) {
              if (!o || x === "none" || g !== "Image" && g !== "Text" || o.includes(E)) {
                const b = (f[C] - 3) / 4, B = r - b % s, T = r - (b / s | 0), D = a(E, I, B * B + T * T);
                if (D) return D;
              }
              h.clearRect(0, 0, s, s);
              break;
            }
          }
          const A = Object.keys(this.executorsByZIndex_).map(Number);
          A.sort(Ma);
          let p, v, y, m, _;
          for (p = A.length - 1; p >= 0; --p) {
            const E = A[p].toString();
            for (y = this.executorsByZIndex_[E], v = ef.length - 1; v >= 0; --v) if (g = ef[v], m = y[g], m !== void 0 && (_ = m.executeHitDetection(h, l, i, d, c), _)) return _;
          }
        }
        getClipCoords(t) {
          const e = this.maxExtent_;
          if (!e) return null;
          const i = e[0], r = e[1], a = e[2], o = e[3], s = [i, r, i, o, a, o, a, r];
          return ul(s, 0, 8, 2, t, s), s;
        }
        isEmpty() {
          return il(this.executorsByZIndex_);
        }
        execute(t, e, i, r, a, o, s) {
          const l = Object.keys(this.executorsByZIndex_).map(Number);
          l.sort(Ma), o = o || ef;
          const u = ef.length;
          let h, c, f, g, d;
          for (s && l.reverse(), h = 0, c = l.length; h < c; ++h) {
            const A = l[h].toString();
            for (d = this.executorsByZIndex_[A], f = 0, g = o.length; f < g; ++f) {
              const p = o[f], v = d[p];
              if (v !== void 0) {
                const y = s === null ? void 0 : v.getZIndexContext(), m = y ? y.getContext() : t, _ = this.maxExtent_ && p !== "Image" && p !== "Text";
                if (_ && (m.save(), this.clip(m, i)), !y || p === "Text" || p === "Image" ? v.execute(m, e, i, r, a, s) : y.pushFunction((E) => v.execute(E, e, i, r, a, s)), _ && m.restore(), y) {
                  y.offset();
                  const E = l[h] * u + f;
                  this.deferredZIndexContexts_[E] || (this.deferredZIndexContexts_[E] = []), this.deferredZIndexContexts_[E].push(y);
                }
              }
            }
          }
          this.renderedContext_ = t;
        }
        getDeferredZIndexContexts() {
          return this.deferredZIndexContexts_;
        }
        getRenderedContext() {
          return this.renderedContext_;
        }
        renderDeferred() {
          const t = this.deferredZIndexContexts_, e = Object.keys(t).map(Number).sort(Ma);
          for (let i = 0, r = e.length; i < r; ++i) t[e[i]].forEach((a) => {
            a.draw(this.renderedContext_), a.clear();
          }), t[e[i]].length = 0;
        }
      }
      const Zx = {};
      function R$(n) {
        if (Zx[n] !== void 0) return Zx[n];
        const t = n * 2 + 1, e = n * n, i = new Array(e + 1);
        for (let a = 0; a <= n; ++a) for (let o = 0; o <= n; ++o) {
          const s = a * a + o * o;
          if (s > e) break;
          let l = i[s];
          l || (l = [], i[s] = l), l.push(((n + a) * t + (n + o)) * 4 + 3), a > 0 && l.push(((n - a) * t + (n + o)) * 4 + 3), o > 0 && (l.push(((n + a) * t + (n - o)) * 4 + 3), a > 0 && l.push(((n - a) * t + (n - o)) * 4 + 3));
        }
        const r = [];
        for (let a = 0, o = i.length; a < o; ++a) i[a] && r.push(...i[a]);
        return Zx[n] = r, r;
      }
      class L$ extends hN {
        constructor(t, e, i, r, a, o, s) {
          super(), this.context_ = t, this.pixelRatio_ = e, this.extent_ = i, this.transform_ = r, this.transformRotation_ = r ? Ud(Math.atan2(r[1], r[0]), 10) : 0, this.viewRotation_ = a, this.squaredTolerance_ = o, this.userTransform_ = s, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = false, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = false, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = wn();
        }
        drawImages_(t, e, i, r) {
          if (!this.image_) return;
          const a = ul(t, e, i, r, this.transform_, this.pixelCoordinates_), o = this.context_, s = this.tmpLocalTransform_, l = o.globalAlpha;
          this.imageOpacity_ != 1 && (o.globalAlpha = l * this.imageOpacity_);
          let u = this.imageRotation_;
          this.transformRotation_ === 0 && (u -= this.viewRotation_), this.imageRotateWithView_ && (u += this.viewRotation_);
          for (let h = 0, c = a.length; h < c; h += 2) {
            const f = a[h] - this.imageAnchorX_, g = a[h + 1] - this.imageAnchorY_;
            if (u !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
              const d = f + this.imageAnchorX_, A = g + this.imageAnchorY_;
              Sr(s, d, A, 1, 1, u, -d, -A), o.save(), o.transform.apply(o, s), o.translate(d, A), o.scale(this.imageScale_[0], this.imageScale_[1]), o.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_), o.restore();
            } else o.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, f, g, this.imageWidth_, this.imageHeight_);
          }
          this.imageOpacity_ != 1 && (o.globalAlpha = l);
        }
        drawText_(t, e, i, r) {
          if (!this.textState_ || this.text_ === "") return;
          this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
          const a = ul(t, e, i, r, this.transform_, this.pixelCoordinates_), o = this.context_;
          let s = this.textRotation_;
          for (this.transformRotation_ === 0 && (s -= this.viewRotation_), this.textRotateWithView_ && (s += this.viewRotation_); e < i; e += r) {
            const l = a[e] + this.textOffsetX_, u = a[e + 1] + this.textOffsetY_;
            s !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (o.save(), o.translate(l - this.textOffsetX_, u - this.textOffsetY_), o.rotate(s), o.translate(this.textOffsetX_, this.textOffsetY_), o.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && o.strokeText(this.text_, 0, 0), this.textFillState_ && o.fillText(this.text_, 0, 0), o.restore()) : (this.textStrokeState_ && o.strokeText(this.text_, l, u), this.textFillState_ && o.fillText(this.text_, l, u));
          }
        }
        moveToLineTo_(t, e, i, r, a) {
          const o = this.context_, s = ul(t, e, i, r, this.transform_, this.pixelCoordinates_);
          o.moveTo(s[0], s[1]);
          let l = s.length;
          a && (l -= 2);
          for (let u = 2; u < l; u += 2) o.lineTo(s[u], s[u + 1]);
          return a && o.closePath(), i;
        }
        drawRings_(t, e, i, r) {
          for (let a = 0, o = i.length; a < o; ++a) e = this.moveToLineTo_(t, e, i[a], r, true);
          return e;
        }
        drawCircle(t) {
          if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), !!hi(this.extent_, t.getExtent())) {
            if (this.fillState_ || this.strokeState_) {
              this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
              const e = MZ(t, this.transform_, this.pixelCoordinates_), i = e[2] - e[0], r = e[3] - e[1], a = Math.sqrt(i * i + r * r), o = this.context_;
              o.beginPath(), o.arc(e[0], e[1], a, 0, 2 * Math.PI), this.fillState_ && o.fill(), this.strokeState_ && o.stroke();
            }
            this.text_ !== "" && this.drawText_(t.getCenter(), 0, 2, 2);
          }
        }
        setStyle(t) {
          this.setFillStrokeStyle(t.getFill(), t.getStroke()), this.setImageStyle(t.getImage()), this.setTextStyle(t.getText());
        }
        setTransform(t) {
          this.transform_ = t;
        }
        drawGeometry(t) {
          switch (t.getType()) {
            case "Point":
              this.drawPoint(t);
              break;
            case "LineString":
              this.drawLineString(t);
              break;
            case "Polygon":
              this.drawPolygon(t);
              break;
            case "MultiPoint":
              this.drawMultiPoint(t);
              break;
            case "MultiLineString":
              this.drawMultiLineString(t);
              break;
            case "MultiPolygon":
              this.drawMultiPolygon(t);
              break;
            case "GeometryCollection":
              this.drawGeometryCollection(t);
              break;
            case "Circle":
              this.drawCircle(t);
              break;
          }
        }
        drawFeature(t, e) {
          const i = e.getGeometryFunction()(t);
          i && (this.setStyle(e), this.drawGeometry(i));
        }
        drawGeometryCollection(t) {
          const e = t.getGeometriesArray();
          for (let i = 0, r = e.length; i < r; ++i) this.drawGeometry(e[i]);
        }
        drawPoint(t) {
          this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          const e = t.getFlatCoordinates(), i = t.getStride();
          this.image_ && this.drawImages_(e, 0, e.length, i), this.text_ !== "" && this.drawText_(e, 0, e.length, i);
        }
        drawMultiPoint(t) {
          this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          const e = t.getFlatCoordinates(), i = t.getStride();
          this.image_ && this.drawImages_(e, 0, e.length, i), this.text_ !== "" && this.drawText_(e, 0, e.length, i);
        }
        drawLineString(t) {
          if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), !!hi(this.extent_, t.getExtent())) {
            if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              const e = this.context_, i = t.getFlatCoordinates();
              e.beginPath(), this.moveToLineTo_(i, 0, i.length, t.getStride(), false), e.stroke();
            }
            if (this.text_ !== "") {
              const e = t.getFlatMidpoint();
              this.drawText_(e, 0, 2, 2);
            }
          }
        }
        drawMultiLineString(t) {
          this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          const e = t.getExtent();
          if (hi(this.extent_, e)) {
            if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              const i = this.context_, r = t.getFlatCoordinates();
              let a = 0;
              const o = t.getEnds(), s = t.getStride();
              i.beginPath();
              for (let l = 0, u = o.length; l < u; ++l) a = this.moveToLineTo_(r, a, o[l], s, false);
              i.stroke();
            }
            if (this.text_ !== "") {
              const i = t.getFlatMidpoints();
              this.drawText_(i, 0, i.length, 2);
            }
          }
        }
        drawPolygon(t) {
          if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), !!hi(this.extent_, t.getExtent())) {
            if (this.strokeState_ || this.fillState_) {
              this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
              const e = this.context_;
              e.beginPath(), this.drawRings_(t.getOrientedFlatCoordinates(), 0, t.getEnds(), t.getStride()), this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
            }
            if (this.text_ !== "") {
              const e = t.getFlatInteriorPoint();
              this.drawText_(e, 0, 2, 2);
            }
          }
        }
        drawMultiPolygon(t) {
          if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), !!hi(this.extent_, t.getExtent())) {
            if (this.strokeState_ || this.fillState_) {
              this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
              const e = this.context_, i = t.getOrientedFlatCoordinates();
              let r = 0;
              const a = t.getEndss(), o = t.getStride();
              e.beginPath();
              for (let s = 0, l = a.length; s < l; ++s) {
                const u = a[s];
                r = this.drawRings_(i, r, u, o);
              }
              this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
            }
            if (this.text_ !== "") {
              const e = t.getFlatInteriorPoints();
              this.drawText_(e, 0, e.length, 2);
            }
          }
        }
        setContextFillState_(t) {
          const e = this.context_, i = this.contextFillState_;
          i ? i.fillStyle != t.fillStyle && (i.fillStyle = t.fillStyle, e.fillStyle = t.fillStyle) : (e.fillStyle = t.fillStyle, this.contextFillState_ = { fillStyle: t.fillStyle });
        }
        setContextStrokeState_(t) {
          const e = this.context_, i = this.contextStrokeState_;
          i ? (i.lineCap != t.lineCap && (i.lineCap = t.lineCap, e.lineCap = t.lineCap), no(i.lineDash, t.lineDash) || e.setLineDash(i.lineDash = t.lineDash), i.lineDashOffset != t.lineDashOffset && (i.lineDashOffset = t.lineDashOffset, e.lineDashOffset = t.lineDashOffset), i.lineJoin != t.lineJoin && (i.lineJoin = t.lineJoin, e.lineJoin = t.lineJoin), i.lineWidth != t.lineWidth && (i.lineWidth = t.lineWidth, e.lineWidth = t.lineWidth), i.miterLimit != t.miterLimit && (i.miterLimit = t.miterLimit, e.miterLimit = t.miterLimit), i.strokeStyle != t.strokeStyle && (i.strokeStyle = t.strokeStyle, e.strokeStyle = t.strokeStyle)) : (e.lineCap = t.lineCap, e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset, e.lineJoin = t.lineJoin, e.lineWidth = t.lineWidth, e.miterLimit = t.miterLimit, e.strokeStyle = t.strokeStyle, this.contextStrokeState_ = { lineCap: t.lineCap, lineDash: t.lineDash, lineDashOffset: t.lineDashOffset, lineJoin: t.lineJoin, lineWidth: t.lineWidth, miterLimit: t.miterLimit, strokeStyle: t.strokeStyle });
        }
        setContextTextState_(t) {
          const e = this.context_, i = this.contextTextState_, r = t.textAlign ? t.textAlign : nA;
          i ? (i.font != t.font && (i.font = t.font, e.font = t.font), i.textAlign != r && (i.textAlign = r, e.textAlign = r), i.textBaseline != t.textBaseline && (i.textBaseline = t.textBaseline, e.textBaseline = t.textBaseline)) : (e.font = t.font, e.textAlign = r, e.textBaseline = t.textBaseline, this.contextTextState_ = { font: t.font, textAlign: r, textBaseline: t.textBaseline });
        }
        setFillStrokeStyle(t, e) {
          if (!t) this.fillState_ = null;
          else {
            const i = t.getColor();
            this.fillState_ = { fillStyle: so(i || ar) };
          }
          if (!e) this.strokeState_ = null;
          else {
            const i = e.getColor(), r = e.getLineCap(), a = e.getLineDash(), o = e.getLineDashOffset(), s = e.getLineJoin(), l = e.getWidth(), u = e.getMiterLimit(), h = a || ls;
            this.strokeState_ = { lineCap: r !== void 0 ? r : Vc, lineDash: this.pixelRatio_ === 1 ? h : h.map((c) => c * this.pixelRatio_), lineDashOffset: (o || us) * this.pixelRatio_, lineJoin: s !== void 0 ? s : jc, lineWidth: (l !== void 0 ? l : iA) * this.pixelRatio_, miterLimit: u !== void 0 ? u : tA, strokeStyle: so(i || eA) };
          }
        }
        setImageStyle(t) {
          let e;
          if (!t || !(e = t.getSize())) {
            this.image_ = null;
            return;
          }
          const i = t.getPixelRatio(this.pixelRatio_), r = t.getAnchor(), a = t.getOrigin();
          this.image_ = t.getImage(this.pixelRatio_), this.imageAnchorX_ = r[0] * i, this.imageAnchorY_ = r[1] * i, this.imageHeight_ = e[1] * i, this.imageOpacity_ = t.getOpacity(), this.imageOriginX_ = a[0], this.imageOriginY_ = a[1], this.imageRotateWithView_ = t.getRotateWithView(), this.imageRotation_ = t.getRotation();
          const o = t.getScaleArray();
          this.imageScale_ = [o[0] * this.pixelRatio_ / i, o[1] * this.pixelRatio_ / i], this.imageWidth_ = e[0] * i;
        }
        setTextStyle(t) {
          if (!t) this.text_ = "";
          else {
            const e = t.getFill();
            if (!e) this.textFillState_ = null;
            else {
              const g = e.getColor();
              this.textFillState_ = { fillStyle: so(g || ar) };
            }
            const i = t.getStroke();
            if (!i) this.textStrokeState_ = null;
            else {
              const g = i.getColor(), d = i.getLineCap(), A = i.getLineDash(), p = i.getLineDashOffset(), v = i.getLineJoin(), y = i.getWidth(), m = i.getMiterLimit();
              this.textStrokeState_ = { lineCap: d !== void 0 ? d : Vc, lineDash: A || ls, lineDashOffset: p || us, lineJoin: v !== void 0 ? v : jc, lineWidth: y !== void 0 ? y : iA, miterLimit: m !== void 0 ? m : tA, strokeStyle: so(g || eA) };
            }
            const r = t.getFont(), a = t.getOffsetX(), o = t.getOffsetY(), s = t.getRotateWithView(), l = t.getRotation(), u = t.getScaleArray(), h = t.getText(), c = t.getTextAlign(), f = t.getTextBaseline();
            this.textState_ = { font: r !== void 0 ? r : PP, textAlign: c !== void 0 ? c : nA, textBaseline: f !== void 0 ? f : a0 }, this.text_ = h !== void 0 ? Array.isArray(h) ? h.reduce((g, d, A) => g += A % 2 ? " " : d, "") : h : "", this.textOffsetX_ = a !== void 0 ? this.pixelRatio_ * a : 0, this.textOffsetY_ = o !== void 0 ? this.pixelRatio_ * o : 0, this.textRotateWithView_ = s !== void 0 ? s : false, this.textRotation_ = l !== void 0 ? l : 0, this.textScale_ = [this.pixelRatio_ * u[0], this.pixelRatio_ * u[1]];
          }
        }
      }
      const lo = 0.5;
      function P$(n, t, e, i, r, a, o, s, l) {
        const u = r, h = n[0] * lo, c = n[1] * lo, f = dn(h, c);
        f.imageSmoothingEnabled = false;
        const g = f.canvas, d = new L$(f, lo, r, null, o, s, null), A = e.length, p = Math.floor((256 * 256 * 256 - 1) / A), v = {};
        for (let m = 1; m <= A; ++m) {
          const _ = e[m - 1], E = _.getStyleFunction() || i;
          if (!E) continue;
          let I = E(_, a);
          if (!I) continue;
          Array.isArray(I) || (I = [I]);
          const w = (m * p).toString(16).padStart(7, "#00000");
          for (let C = 0, S = I.length; C < S; ++C) {
            const b = I[C], B = b.getGeometryFunction()(_);
            if (!B || !hi(u, B.getExtent())) continue;
            const T = b.clone(), D = T.getFill();
            D && D.setColor(w);
            const R = T.getStroke();
            R && (R.setColor(w), R.setLineDash(null)), T.setText(void 0);
            const L = b.getImage();
            if (L) {
              const Q = L.getImageSize();
              if (!Q) continue;
              const z = dn(Q[0], Q[1], void 0, { alpha: false }), j = z.canvas;
              z.fillStyle = w, z.fillRect(0, 0, j.width, j.height), T.setImage(new Rr({ img: j, anchor: L.getAnchor(), anchorXUnits: "pixels", anchorYUnits: "pixels", offset: L.getOrigin(), opacity: 1, size: L.getSize(), scale: L.getScale(), rotation: L.getRotation(), rotateWithView: L.getRotateWithView() }));
            }
            const k = T.getZIndex() || 0;
            let P = v[k];
            P || (P = {}, v[k] = P, P.Polygon = [], P.Circle = [], P.LineString = [], P.Point = []);
            const F = B.getType();
            if (F === "GeometryCollection") {
              const Q = B.getGeometriesArrayRecursive();
              for (let z = 0, j = Q.length; z < j; ++z) {
                const $ = Q[z];
                P[$.getType().replace("Multi", "")].push($, T);
              }
            } else P[F.replace("Multi", "")].push(B, T);
          }
        }
        const y = Object.keys(v).map(Number).sort(Ma);
        for (let m = 0, _ = y.length; m < _; ++m) {
          const E = v[y[m]];
          for (const I in E) {
            const x = E[I];
            for (let w = 0, C = x.length; w < C; w += 2) {
              d.setStyle(x[w + 1]);
              for (let S = 0, b = t.length; S < b; ++S) d.setTransform(t[S]), d.drawGeometry(x[w]);
            }
          }
        }
        return f.getImageData(0, 0, g.width, g.height);
      }
      function N$(n, t, e) {
        const i = [];
        if (e) {
          const r = Math.floor(Math.round(n[0]) * lo), a = Math.floor(Math.round(n[1]) * lo), o = (en(r, 0, e.width - 1) + en(a, 0, e.height - 1) * e.width) * 4, s = e.data[o], l = e.data[o + 1], h = e.data[o + 2] + 256 * (l + 256 * s), c = Math.floor((256 * 256 * 256 - 1) / t.length);
          h && h % c === 0 && i.push(t[h / c - 1]);
        }
        return i;
      }
      const k$ = 0.5, yN = { Point: j$, LineString: G$, Polygon: H$, MultiPoint: q$, MultiLineString: U$, MultiPolygon: V$, GeometryCollection: z$, Circle: Q$ };
      function F$(n, t) {
        return parseInt(Ft(n), 10) - parseInt(Ft(t), 10);
      }
      function mN(n, t) {
        const e = _N(n, t);
        return e * e;
      }
      function _N(n, t) {
        return k$ * n / t;
      }
      function Q$(n, t, e, i, r) {
        const a = e.getFill(), o = e.getStroke();
        if (a || o) {
          const l = n.getBuilder(e.getZIndex(), "Circle");
          l.setFillStrokeStyle(a, o), l.drawCircle(t, i, r);
        }
        const s = e.getText();
        if (s && s.getText()) {
          const l = n.getBuilder(e.getZIndex(), "Text");
          l.setTextStyle(s), l.drawText(t, i);
        }
      }
      function IN(n, t, e, i, r, a, o, s) {
        const l = [], u = e.getImage();
        if (u) {
          let f = true;
          const g = u.getImageState();
          g == Bt.LOADED || g == Bt.ERROR ? f = false : g == Bt.IDLE && u.load(), f && l.push(u.ready());
        }
        const h = e.getFill();
        h && h.loading() && l.push(h.ready());
        const c = l.length > 0;
        return c && Promise.all(l).then(() => r(null)), O$(n, t, e, i, a, o, s), c;
      }
      function O$(n, t, e, i, r, a, o) {
        const s = e.getGeometryFunction()(t);
        if (!s) return;
        const l = s.simplifyTransformed(i, r);
        if (e.getRenderer()) EN(n, l, e, t, o);
        else {
          const h = yN[l.getType()];
          h(n, l, e, t, o, a);
        }
      }
      function EN(n, t, e, i, r) {
        if (t.getType() == "GeometryCollection") {
          const o = t.getGeometries();
          for (let s = 0, l = o.length; s < l; ++s) EN(n, o[s], e, i, r);
          return;
        }
        n.getBuilder(e.getZIndex(), "Default").drawCustom(t, i, e.getRenderer(), e.getHitDetectionRenderer(), r);
      }
      function z$(n, t, e, i, r, a) {
        const o = t.getGeometriesArray();
        let s, l;
        for (s = 0, l = o.length; s < l; ++s) {
          const u = yN[o[s].getType()];
          u(n, o[s], e, i, r, a);
        }
      }
      function G$(n, t, e, i, r) {
        const a = e.getStroke();
        if (a) {
          const s = n.getBuilder(e.getZIndex(), "LineString");
          s.setFillStrokeStyle(null, a), s.drawLineString(t, i, r);
        }
        const o = e.getText();
        if (o && o.getText()) {
          const s = n.getBuilder(e.getZIndex(), "Text");
          s.setTextStyle(o), s.drawText(t, i, r);
        }
      }
      function U$(n, t, e, i, r) {
        const a = e.getStroke();
        if (a) {
          const s = n.getBuilder(e.getZIndex(), "LineString");
          s.setFillStrokeStyle(null, a), s.drawMultiLineString(t, i, r);
        }
        const o = e.getText();
        if (o && o.getText()) {
          const s = n.getBuilder(e.getZIndex(), "Text");
          s.setTextStyle(o), s.drawText(t, i, r);
        }
      }
      function V$(n, t, e, i, r) {
        const a = e.getFill(), o = e.getStroke();
        if (o || a) {
          const l = n.getBuilder(e.getZIndex(), "Polygon");
          l.setFillStrokeStyle(a, o), l.drawMultiPolygon(t, i, r);
        }
        const s = e.getText();
        if (s && s.getText()) {
          const l = n.getBuilder(e.getZIndex(), "Text");
          l.setTextStyle(s), l.drawText(t, i, r);
        }
      }
      function j$(n, t, e, i, r, a) {
        const o = e.getImage(), s = e.getText(), l = s && s.getText(), u = a && o && l ? {} : void 0;
        if (o) {
          if (o.getImageState() != Bt.LOADED) return;
          const h = n.getBuilder(e.getZIndex(), "Image");
          h.setImageStyle(o, u), h.drawPoint(t, i, r);
        }
        if (l) {
          const h = n.getBuilder(e.getZIndex(), "Text");
          h.setTextStyle(s, u), h.drawText(t, i, r);
        }
      }
      function q$(n, t, e, i, r, a) {
        const o = e.getImage(), s = o && o.getOpacity() !== 0, l = e.getText(), u = l && l.getText(), h = a && s && u ? {} : void 0;
        if (s) {
          if (o.getImageState() != Bt.LOADED) return;
          const c = n.getBuilder(e.getZIndex(), "Image");
          c.setImageStyle(o, h), c.drawMultiPoint(t, i, r);
        }
        if (u) {
          const c = n.getBuilder(e.getZIndex(), "Text");
          c.setTextStyle(l, h), c.drawText(t, i, r);
        }
      }
      function H$(n, t, e, i, r) {
        const a = e.getFill(), o = e.getStroke();
        if (a || o) {
          const l = n.getBuilder(e.getZIndex(), "Polygon");
          l.setFillStrokeStyle(a, o), l.drawPolygon(t, i, r);
        }
        const s = e.getText();
        if (s && s.getText()) {
          const l = n.getBuilder(e.getZIndex(), "Text");
          l.setTextStyle(s), l.drawText(t, i, r);
        }
      }
      class Y$ extends y0 {
        constructor(t) {
          super(t), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.clipped_ = false, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = Ii(), this.wrappedRenderedExtent_ = Ii(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedPixelRatio_ = 1, this.renderedRenderOrder_ = null, this.renderedFrameDeclutter_, this.replayGroup_ = null, this.replayGroupChanged = true, this.clipping = true, this.targetContext_ = null, this.opacity_ = 1;
        }
        renderWorlds(t, e, i) {
          const r = e.extent, a = e.viewState, o = a.center, s = a.resolution, l = a.projection, u = a.rotation, h = l.getExtent(), c = this.getLayer().getSource(), f = this.getLayer().getDeclutter(), g = e.pixelRatio, d = e.viewHints, A = !(d[Fn.ANIMATING] || d[Fn.INTERACTING]), p = this.context, v = Math.round(ve(r) / s * g), y = Math.round(Cn(r) / s * g), m = c.getWrapX() && l.canWrapX(), _ = m ? ve(h) : null, E = m ? Math.ceil((r[2] - h[2]) / _) + 1 : 1;
          let I = m ? Math.floor((r[0] - h[0]) / _) : 0;
          do {
            let x = this.getRenderTransform(o, s, 0, g, v, y, I * _);
            e.declutter && (x = x.slice(0)), t.execute(p, [p.canvas.width, p.canvas.height], x, u, A, i === void 0 ? ef : i ? vN : M$, i ? f && e.declutter[f] : void 0);
          } while (++I < E);
        }
        setDrawContext_() {
          this.opacity_ !== 1 && (this.targetContext_ = this.context, this.context = dn(this.context.canvas.width, this.context.canvas.height, dN));
        }
        resetDrawContext_() {
          if (this.opacity_ !== 1) {
            const t = this.targetContext_.globalAlpha;
            this.targetContext_.globalAlpha = this.opacity_, this.targetContext_.drawImage(this.context.canvas, 0, 0), this.targetContext_.globalAlpha = t, Uc(this.context), dN.push(this.context.canvas), this.context = this.targetContext_, this.targetContext_ = null;
          }
        }
        renderDeclutter(t) {
          !this.replayGroup_ || !this.getLayer().getDeclutter() || this.renderWorlds(this.replayGroup_, t, true);
        }
        renderDeferredInternal(t) {
          this.replayGroup_ && (this.replayGroup_.renderDeferred(), this.clipped_ && this.context.restore(), this.resetDrawContext_());
        }
        renderFrame(t, e) {
          const i = t.layerStatesArray[t.layerIndex];
          this.opacity_ = i.opacity;
          const r = t.viewState;
          this.prepareContainer(t, e);
          const a = this.context, o = this.replayGroup_;
          let s = o && !o.isEmpty();
          if (!s && !(this.getLayer().hasListener(ni.PRERENDER) || this.getLayer().hasListener(ni.POSTRENDER))) return null;
          if (this.setDrawContext_(), this.preRender(a, t), r.projection, this.clipped_ = false, s && i.extent && this.clipping) {
            const l = Ni(i.extent);
            s = hi(l, t.extent), this.clipped_ = s && !br(l, t.extent), this.clipped_ && this.clipUnrotated(a, t, l);
          }
          return s && this.renderWorlds(o, t, this.getLayer().getDeclutter() ? false : void 0), !t.declutter && this.clipped_ && a.restore(), this.postRender(a, t), this.renderedRotation_ !== r.rotation && (this.renderedRotation_ = r.rotation, this.hitDetectionImageData_ = null), t.declutter || this.resetDrawContext_(), this.container;
        }
        getFeatures(t) {
          return new Promise((e) => {
            if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
              const i = this.frameState.size.slice(), r = this.renderedCenter_, a = this.renderedResolution_, o = this.renderedRotation_, s = this.renderedProjection_, l = this.wrappedRenderedExtent_, u = this.getLayer(), h = [], c = i[0] * lo, f = i[1] * lo;
              h.push(this.getRenderTransform(r, a, o, lo, c, f, 0).slice());
              const g = u.getSource(), d = s.getExtent();
              if (g.getWrapX() && s.canWrapX() && !br(d, l)) {
                let A = l[0];
                const p = ve(d);
                let v = 0, y;
                for (; A < d[0]; ) --v, y = p * v, h.push(this.getRenderTransform(r, a, o, lo, c, f, y).slice()), A += p;
                for (v = 0, A = l[2]; A > d[2]; ) ++v, y = p * v, h.push(this.getRenderTransform(r, a, o, lo, c, f, y).slice()), A -= p;
              }
              this.hitDetectionImageData_ = P$(i, h, this.renderedFeatures_, u.getStyleFunction(), l, a, o, mN(a, this.renderedPixelRatio_));
            }
            e(N$(t, this.renderedFeatures_, this.hitDetectionImageData_));
          });
        }
        forEachFeatureAtCoordinate(t, e, i, r, a) {
          if (!this.replayGroup_) return;
          const o = e.viewState.resolution, s = e.viewState.rotation, l = this.getLayer(), u = {}, h = function(d, A, p) {
            const v = Ft(d), y = u[v];
            if (y) {
              if (y !== true && p < y.distanceSq) {
                if (p === 0) return u[v] = true, a.splice(a.lastIndexOf(y), 1), r(d, l, A);
                y.geometry = A, y.distanceSq = p;
              }
            } else {
              if (p === 0) return u[v] = true, r(d, l, A);
              a.push(u[v] = { feature: d, layer: l, geometry: A, distanceSq: p, callback: r });
            }
          };
          let c;
          const f = [this.replayGroup_], g = this.getLayer().getDeclutter();
          return f.some((d) => c = d.forEachFeatureAtCoordinate(t, o, s, i, h, g && e.declutter[g] ? e.declutter[g].all().map((A) => A.value) : null)), c;
        }
        handleFontsChanged() {
          const t = this.getLayer();
          t.getVisible() && this.replayGroup_ && t.changed();
        }
        handleStyleImageChange_(t) {
          this.renderIfReadyAndVisible();
        }
        prepareFrame(t) {
          const e = this.getLayer(), i = e.getSource();
          if (!i) return false;
          const r = t.viewHints[Fn.ANIMATING], a = t.viewHints[Fn.INTERACTING], o = e.getUpdateWhileAnimating(), s = e.getUpdateWhileInteracting();
          if (this.ready && !o && r || !s && a) return this.animatingOrInteracting_ = true, true;
          this.animatingOrInteracting_ = false;
          const l = t.extent, u = t.viewState, h = u.projection, c = u.resolution, f = t.pixelRatio, g = e.getRevision(), d = e.getRenderBuffer();
          let A = e.getRenderOrder();
          A === void 0 && (A = F$);
          const p = u.center.slice(), v = es(l, d * c), y = v.slice(), m = [v.slice()], _ = h.getExtent();
          if (i.getWrapX() && h.canWrapX() && !br(_, t.extent)) {
            const D = ve(_), R = Math.max(ve(v) / 2, D);
            v[0] = _[0] - R, v[2] = _[2] + R, VL(p, h);
            const L = kL(m[0], h);
            L[0] < _[0] && L[2] < _[2] ? m.push([L[0] + D, L[1], L[2] + D, L[3]]) : L[0] > _[0] && L[2] > _[2] && m.push([L[0] - D, L[1], L[2] - D, L[3]]);
          }
          if (this.ready && this.renderedResolution_ == c && this.renderedRevision_ == g && this.renderedRenderOrder_ == A && this.renderedFrameDeclutter_ === !!t.declutter && br(this.wrappedRenderedExtent_, v)) return no(this.renderedExtent_, y) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = y), this.renderedCenter_ = p, this.replayGroupChanged = false, true;
          this.replayGroup_ = null;
          const E = new w$(_N(c, f), v, c, f);
          let I;
          for (let D = 0, R = m.length; D < R; ++D) i.loadFeatures(m[D], c, h);
          const x = mN(c, f);
          let w = true;
          const C = (D, R) => {
            let L;
            const k = D.getStyleFunction() || e.getStyleFunction();
            if (k && (L = k(D, c)), L) {
              const P = this.renderFeature(D, x, L, E, I, this.getLayer().getDeclutter(), R);
              w = w && !P;
            }
          }, S = qd(v), b = i.getFeaturesInExtent(S);
          A && b.sort(A);
          for (let D = 0, R = b.length; D < R; ++D) C(b[D], D);
          this.renderedFeatures_ = b, this.ready = w;
          const B = E.finish(), T = new D$(v, c, f, i.getOverlaps(), B, e.getRenderBuffer(), !!t.declutter);
          return this.renderedResolution_ = c, this.renderedRevision_ = g, this.renderedRenderOrder_ = A, this.renderedFrameDeclutter_ = !!t.declutter, this.renderedExtent_ = y, this.wrappedRenderedExtent_ = v, this.renderedCenter_ = p, this.renderedProjection_ = h, this.renderedPixelRatio_ = f, this.replayGroup_ = T, this.hitDetectionImageData_ = null, this.replayGroupChanged = true, true;
        }
        renderFeature(t, e, i, r, a, o, s) {
          if (!i) return false;
          let l = false;
          if (Array.isArray(i)) for (let u = 0, h = i.length; u < h; ++u) l = IN(r, t, i[u], e, this.boundHandleStyleImageChange_, a, o, s) || l;
          else l = IN(r, t, i, e, this.boundHandleStyleImageChange_, a, o, s);
          return l;
        }
      }
      class Kr extends A0 {
        constructor(t) {
          super(t);
        }
        createRenderer() {
          return new Y$(this);
        }
      }
      class m0 {
        constructor(t) {
          this.rbush_ = new HP(t), this.items_ = {};
        }
        insert(t, e) {
          const i = { minX: t[0], minY: t[1], maxX: t[2], maxY: t[3], value: e };
          this.rbush_.insert(i), this.items_[Ft(e)] = i;
        }
        load(t, e) {
          const i = new Array(e.length);
          for (let r = 0, a = e.length; r < a; r++) {
            const o = t[r], s = e[r], l = { minX: o[0], minY: o[1], maxX: o[2], maxY: o[3], value: s };
            i[r] = l, this.items_[Ft(s)] = l;
          }
          this.rbush_.load(i);
        }
        remove(t) {
          const e = Ft(t), i = this.items_[e];
          return delete this.items_[e], this.rbush_.remove(i) !== null;
        }
        update(t, e) {
          const i = this.items_[Ft(e)], r = [i.minX, i.minY, i.maxX, i.maxY];
          al(r, t) || (this.remove(e), this.insert(t, e));
        }
        getAll() {
          return this.rbush_.all().map(function(e) {
            return e.value;
          });
        }
        getInExtent(t) {
          const e = { minX: t[0], minY: t[1], maxX: t[2], maxY: t[3] };
          return this.rbush_.search(e).map(function(r) {
            return r.value;
          });
        }
        forEach(t) {
          return this.forEach_(this.getAll(), t);
        }
        forEachInExtent(t, e) {
          return this.forEach_(this.getInExtent(t), e);
        }
        forEach_(t, e) {
          let i;
          for (let r = 0, a = t.length; r < a; r++) if (i = e(t[r]), i) return i;
          return i;
        }
        isEmpty() {
          return il(this.items_);
        }
        clear() {
          this.rbush_.clear(), this.items_ = {};
        }
        getExtent(t) {
          const e = this.rbush_.toJSON();
          return Xr(e.minX, e.minY, e.maxX, e.maxY, t);
        }
        concat(t) {
          this.rbush_.load(t.rbush_.all());
          for (const e in t.items_) this.items_[e] = t.items_[e];
        }
      }
      let AA = class ZX extends Ra {
        constructor(t, e, i) {
          super(), i !== void 0 && e === void 0 ? this.setFlatCoordinates(i, t) : (e = e || 0, this.setCenterAndRadius(t, e, i));
        }
        clone() {
          const t = new ZX(this.flatCoordinates.slice(), void 0, this.layout);
          return t.applyProperties(this), t;
        }
        closestPointXY(t, e, i, r) {
          const a = this.flatCoordinates, o = t - a[0], s = e - a[1], l = o * o + s * s;
          if (l < r) {
            if (l === 0) for (let u = 0; u < this.stride; ++u) i[u] = a[u];
            else {
              const u = this.getRadius() / Math.sqrt(l);
              i[0] = a[0] + u * o, i[1] = a[1] + u * s;
              for (let h = 2; h < this.stride; ++h) i[h] = a[h];
            }
            return i.length = this.stride, l;
          }
          return r;
        }
        containsXY(t, e) {
          const i = this.flatCoordinates, r = t - i[0], a = e - i[1];
          return r * r + a * a <= this.getRadiusSquared_();
        }
        getCenter() {
          return this.flatCoordinates.slice(0, this.stride);
        }
        computeExtent(t) {
          const e = this.flatCoordinates, i = e[this.stride] - e[0];
          return Xr(e[0] - i, e[1] - i, e[0] + i, e[1] + i, t);
        }
        getRadius() {
          return Math.sqrt(this.getRadiusSquared_());
        }
        getRadiusSquared_() {
          const t = this.flatCoordinates[this.stride] - this.flatCoordinates[0], e = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
          return t * t + e * e;
        }
        getType() {
          return "Circle";
        }
        intersectsExtent(t) {
          const e = this.getExtent();
          if (hi(t, e)) {
            const i = this.getCenter();
            return t[0] <= i[0] && t[2] >= i[0] || t[1] <= i[1] && t[3] >= i[1] ? true : WE(t, this.intersectsCoordinate.bind(this));
          }
          return false;
        }
        setCenter(t) {
          const e = this.stride, i = this.flatCoordinates[e] - this.flatCoordinates[0], r = t.slice();
          r[e] = r[0] + i;
          for (let a = 1; a < e; ++a) r[e + a] = t[a];
          this.setFlatCoordinates(this.layout, r), this.changed();
        }
        setCenterAndRadius(t, e, i) {
          this.setLayout(i, t, 0), this.flatCoordinates || (this.flatCoordinates = []);
          const r = this.flatCoordinates;
          let a = rP(r, 0, t, this.stride);
          r[a++] = r[0] + e;
          for (let o = 1, s = this.stride; o < s; ++o) r[a++] = r[o];
          r.length = a, this.changed();
        }
        getCoordinates() {
          return null;
        }
        setCoordinates(t, e) {
        }
        setRadius(t) {
          this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t, this.changed();
        }
        rotate(t, e) {
          const i = this.getCenter(), r = this.getStride();
          this.setCenter(sx(i, 0, i.length, r, t, e, i)), this.changed();
        }
      };
      AA.prototype.transform;
      class yn extends Yy {
        constructor(t) {
          super(), this.geometries_ = t, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
        }
        unlistenGeometriesChange_() {
          this.changeEventsKeys_.forEach(Pe), this.changeEventsKeys_.length = 0;
        }
        listenGeometriesChange_() {
          const t = this.geometries_;
          for (let e = 0, i = t.length; e < i; ++e) this.changeEventsKeys_.push(ie(t[e], Nt.CHANGE, this.changed, this));
        }
        clone() {
          const t = new yn(Kx(this.geometries_));
          return t.applyProperties(this), t;
        }
        closestPointXY(t, e, i, r) {
          if (r < bu(this.getExtent(), t, e)) return r;
          const a = this.geometries_;
          for (let o = 0, s = a.length; o < s; ++o) r = a[o].closestPointXY(t, e, i, r);
          return r;
        }
        containsXY(t, e) {
          const i = this.geometries_;
          for (let r = 0, a = i.length; r < a; ++r) if (i[r].containsXY(t, e)) return true;
          return false;
        }
        computeExtent(t) {
          Rc(t);
          const e = this.geometries_;
          for (let i = 0, r = e.length; i < r; ++i) PL(t, e[i].getExtent());
          return t;
        }
        getGeometries() {
          return Kx(this.geometries_);
        }
        getGeometriesArray() {
          return this.geometries_;
        }
        getGeometriesArrayRecursive() {
          let t = [];
          const e = this.geometries_;
          for (let i = 0, r = e.length; i < r; ++i) e[i].getType() === this.getType() ? t = t.concat(e[i].getGeometriesArrayRecursive()) : t.push(e[i]);
          return t;
        }
        getSimplifiedGeometry(t) {
          if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t < this.simplifiedGeometryMaxMinSquaredTolerance) return this;
          const e = [], i = this.geometries_;
          let r = false;
          for (let a = 0, o = i.length; a < o; ++a) {
            const s = i[a], l = s.getSimplifiedGeometry(t);
            e.push(l), l !== s && (r = true);
          }
          return r ? new yn(e) : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
        }
        getType() {
          return "GeometryCollection";
        }
        intersectsExtent(t) {
          const e = this.geometries_;
          for (let i = 0, r = e.length; i < r; ++i) if (e[i].intersectsExtent(t)) return true;
          return false;
        }
        isEmpty() {
          return this.geometries_.length === 0;
        }
        rotate(t, e) {
          const i = this.geometries_;
          for (let r = 0, a = i.length; r < a; ++r) i[r].rotate(t, e);
          this.changed();
        }
        scale(t, e, i) {
          i || (i = Br(this.getExtent()));
          const r = this.geometries_;
          for (let a = 0, o = r.length; a < o; ++a) r[a].scale(t, e, i);
          this.changed();
        }
        setGeometries(t) {
          this.setGeometriesArray(Kx(t));
        }
        setGeometriesArray(t) {
          this.unlistenGeometriesChange_(), this.geometries_ = t, this.listenGeometriesChange_(), this.changed();
        }
        applyTransform(t) {
          const e = this.geometries_;
          for (let i = 0, r = e.length; i < r; ++i) e[i].applyTransform(t);
          this.changed();
        }
        translate(t, e) {
          const i = this.geometries_;
          for (let r = 0, a = i.length; r < a; ++r) i[r].translate(t, e);
          this.changed();
        }
        disposeInternal() {
          this.unlistenGeometriesChange_(), super.disposeInternal();
        }
      }
      function Kx(n) {
        return n.map((t) => t.clone());
      }
      class ri extends Ra {
        constructor(t, e, i) {
          if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(t[0])) this.setCoordinates(t, e);
          else if (e !== void 0 && i) this.setFlatCoordinates(e, t), this.ends_ = i;
          else {
            const r = t, a = [], o = [];
            for (let l = 0, u = r.length; l < u; ++l) {
              const h = r[l];
              De(a, h.getFlatCoordinates()), o.push(a.length);
            }
            const s = r.length === 0 ? this.getLayout() : r[0].getLayout();
            this.setFlatCoordinates(s, a), this.ends_ = o;
          }
        }
        appendLineString(t) {
          De(this.flatCoordinates, t.getFlatCoordinates().slice()), this.ends_.push(this.flatCoordinates.length), this.changed();
        }
        clone() {
          const t = new ri(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
          return t.applyProperties(this), t;
        }
        closestPointXY(t, e, i, r) {
          return r < bu(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(ux(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), cx(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, t, e, i, r));
        }
        getCoordinateAtM(t, e, i) {
          return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (e = e !== void 0 ? e : false, i = i !== void 0 ? i : false, rK(this.flatCoordinates, 0, this.ends_, this.stride, t, e, i));
        }
        getCoordinates() {
          return Xd(this.flatCoordinates, 0, this.ends_, this.stride);
        }
        getEnds() {
          return this.ends_;
        }
        getLineString(t) {
          return t < 0 || this.ends_.length <= t ? null : new be(this.flatCoordinates.slice(t === 0 ? 0 : this.ends_[t - 1], this.ends_[t]), this.layout);
        }
        getLineStrings() {
          const t = this.flatCoordinates, e = this.ends_, i = this.layout, r = [];
          let a = 0;
          for (let o = 0, s = e.length; o < s; ++o) {
            const l = e[o], u = new be(t.slice(a, l), i);
            r.push(u), a = l;
          }
          return r;
        }
        getFlatMidpoints() {
          const t = [], e = this.flatCoordinates;
          let i = 0;
          const r = this.ends_, a = this.stride;
          for (let o = 0, s = r.length; o < s; ++o) {
            const l = r[o], u = t0(e, i, l, a, 0.5);
            De(t, u), i = l;
          }
          return t;
        }
        getSimplifiedGeometryInternal(t) {
          const e = [], i = [];
          return e.length = oP(this.flatCoordinates, 0, this.ends_, this.stride, t, e, 0, i), new ri(e, "XY", i);
        }
        getType() {
          return "MultiLineString";
        }
        intersectsExtent(t) {
          return QZ(this.flatCoordinates, 0, this.ends_, this.stride, t);
        }
        setCoordinates(t, e) {
          this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
          const i = Wd(this.flatCoordinates, 0, t, this.stride, this.ends_);
          this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1], this.changed();
        }
      }
      class sr extends Ra {
        constructor(t, e) {
          super(), e && !Array.isArray(t[0]) ? this.setFlatCoordinates(e, t) : this.setCoordinates(t, e);
        }
        appendPoint(t) {
          De(this.flatCoordinates, t.getFlatCoordinates()), this.changed();
        }
        clone() {
          const t = new sr(this.flatCoordinates.slice(), this.layout);
          return t.applyProperties(this), t;
        }
        closestPointXY(t, e, i, r) {
          if (r < bu(this.getExtent(), t, e)) return r;
          const a = this.flatCoordinates, o = this.stride;
          for (let s = 0, l = a.length; s < l; s += o) {
            const u = is(t, e, a[s], a[s + 1]);
            if (u < r) {
              r = u;
              for (let h = 0; h < o; ++h) i[h] = a[s + h];
              i.length = o;
            }
          }
          return r;
        }
        getCoordinates() {
          return ss(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        }
        getPoint(t) {
          const e = this.flatCoordinates.length / this.stride;
          return t < 0 || e <= t ? null : new Oe(this.flatCoordinates.slice(t * this.stride, (t + 1) * this.stride), this.layout);
        }
        getPoints() {
          const t = this.flatCoordinates, e = this.layout, i = this.stride, r = [];
          for (let a = 0, o = t.length; a < o; a += i) {
            const s = new Oe(t.slice(a, a + i), e);
            r.push(s);
          }
          return r;
        }
        getType() {
          return "MultiPoint";
        }
        intersectsExtent(t) {
          const e = this.flatCoordinates, i = this.stride;
          for (let r = 0, a = e.length; r < a; r += i) {
            const o = e[r], s = e[r + 1];
            if (qE(t, o, s)) return true;
          }
          return false;
        }
        setCoordinates(t, e) {
          this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Yd(this.flatCoordinates, 0, t, this.stride), this.changed();
        }
      }
      function xN(n, t, e, i) {
        const r = [];
        let a = Ii();
        for (let o = 0, s = e.length; o < s; ++o) {
          const l = e[o];
          a = YE(n, t, l[0], i), r.push((a[0] + a[2]) / 2, (a[1] + a[3]) / 2), t = l[l.length - 1];
        }
        return r;
      }
      class Ci extends Ra {
        constructor(t, e, i) {
          if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !i && !Array.isArray(t[0])) {
            const r = t, a = [], o = [];
            for (let s = 0, l = r.length; s < l; ++s) {
              const u = r[s], h = a.length, c = u.getEnds();
              for (let f = 0, g = c.length; f < g; ++f) c[f] += h;
              De(a, u.getFlatCoordinates()), o.push(c);
            }
            e = r.length === 0 ? this.getLayout() : r[0].getLayout(), t = a, i = o;
          }
          e !== void 0 && i ? (this.setFlatCoordinates(e, t), this.endss_ = i) : this.setCoordinates(t, e);
        }
        appendPolygon(t) {
          let e;
          if (!this.flatCoordinates) this.flatCoordinates = t.getFlatCoordinates().slice(), e = t.getEnds().slice(), this.endss_.push();
          else {
            const i = this.flatCoordinates.length;
            De(this.flatCoordinates, t.getFlatCoordinates()), e = t.getEnds().slice();
            for (let r = 0, a = e.length; r < a; ++r) e[r] += i;
          }
          this.endss_.push(e), this.changed();
        }
        clone() {
          const t = this.endss_.length, e = new Array(t);
          for (let r = 0; r < t; ++r) e[r] = this.endss_[r].slice();
          const i = new Ci(this.flatCoordinates.slice(), this.layout, e);
          return i.applyProperties(this), i;
        }
        closestPointXY(t, e, i, r) {
          return r < bu(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(DZ(this.flatCoordinates, 0, this.endss_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), RZ(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, t, e, i, r));
        }
        containsXY(t, e) {
          return FZ(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t, e);
        }
        getArea() {
          return NZ(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
        }
        getCoordinates(t) {
          let e;
          return t !== void 0 ? (e = this.getOrientedFlatCoordinates().slice(), vx(e, 0, this.endss_, this.stride, t)) : e = this.flatCoordinates, gx(e, 0, this.endss_, this.stride);
        }
        getEndss() {
          return this.endss_;
        }
        getFlatInteriorPoints() {
          if (this.flatInteriorPointsRevision_ != this.getRevision()) {
            const t = xN(this.flatCoordinates, 0, this.endss_, this.stride);
            this.flatInteriorPoints_ = uP(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t), this.flatInteriorPointsRevision_ = this.getRevision();
          }
          return this.flatInteriorPoints_;
        }
        getInteriorPoints() {
          return new sr(this.getFlatInteriorPoints().slice(), "XYM");
        }
        getOrientedFlatCoordinates() {
          if (this.orientedRevision_ != this.getRevision()) {
            const t = this.flatCoordinates;
            gP(t, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = vx(this.orientedFlatCoordinates_, 0, this.endss_, this.stride)), this.orientedRevision_ = this.getRevision();
          }
          return this.orientedFlatCoordinates_;
        }
        getSimplifiedGeometryInternal(t) {
          const e = [], i = [];
          return e.length = PZ(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(t), e, 0, i), new Ci(e, "XY", i);
        }
        getPolygon(t) {
          if (t < 0 || this.endss_.length <= t) return null;
          let e;
          if (t === 0) e = 0;
          else {
            const a = this.endss_[t - 1];
            e = a[a.length - 1];
          }
          const i = this.endss_[t].slice(), r = i[i.length - 1];
          if (e !== 0) for (let a = 0, o = i.length; a < o; ++a) i[a] -= e;
          return new Sn(this.flatCoordinates.slice(e, r), this.layout, i);
        }
        getPolygons() {
          const t = this.layout, e = this.flatCoordinates, i = this.endss_, r = [];
          let a = 0;
          for (let o = 0, s = i.length; o < s; ++o) {
            const l = i[o].slice(), u = l[l.length - 1];
            if (a !== 0) for (let c = 0, f = l.length; c < f; ++c) l[c] -= a;
            const h = new Sn(e.slice(a, u), t, l);
            r.push(h), a = u;
          }
          return r;
        }
        getType() {
          return "MultiPolygon";
        }
        intersectsExtent(t) {
          return OZ(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t);
        }
        setCoordinates(t, e) {
          this.setLayout(e, t, 3), this.flatCoordinates || (this.flatCoordinates = []);
          const i = aP(this.flatCoordinates, 0, t, this.stride, this.endss_);
          if (i.length === 0) this.flatCoordinates.length = 0;
          else {
            const r = i[i.length - 1];
            this.flatCoordinates.length = r.length === 0 ? 0 : r[r.length - 1];
          }
          this.changed();
        }
      }
      const wN = wn();
      class ki {
        constructor(t, e, i, r, a, o) {
          this.styleFunction, this.extent_, this.id_ = o, this.type_ = t, this.flatCoordinates_ = e, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = i || null, this.properties_ = a, this.squaredTolerance_, this.stride_ = r, this.simplifiedGeometry_;
        }
        get(t) {
          return this.properties_[t];
        }
        getExtent() {
          return this.extent_ || (this.extent_ = this.type_ === "Point" ? Lc(this.flatCoordinates_) : YE(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2)), this.extent_;
        }
        getFlatInteriorPoint() {
          if (!this.flatInteriorPoints_) {
            const t = Br(this.getExtent());
            this.flatInteriorPoints_ = Ax(this.flatCoordinates_, 0, this.ends_, 2, t, 0);
          }
          return this.flatInteriorPoints_;
        }
        getFlatInteriorPoints() {
          if (!this.flatInteriorPoints_) {
            const t = dP(this.flatCoordinates_, this.ends_), e = xN(this.flatCoordinates_, 0, t, 2);
            this.flatInteriorPoints_ = uP(this.flatCoordinates_, 0, t, 2, e);
          }
          return this.flatInteriorPoints_;
        }
        getFlatMidpoint() {
          return this.flatMidpoints_ || (this.flatMidpoints_ = t0(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5)), this.flatMidpoints_;
        }
        getFlatMidpoints() {
          if (!this.flatMidpoints_) {
            this.flatMidpoints_ = [];
            const t = this.flatCoordinates_;
            let e = 0;
            const i = this.ends_;
            for (let r = 0, a = i.length; r < a; ++r) {
              const o = i[r], s = t0(t, e, o, 2, 0.5);
              De(this.flatMidpoints_, s), e = o;
            }
          }
          return this.flatMidpoints_;
        }
        getId() {
          return this.id_;
        }
        getOrientedFlatCoordinates() {
          return this.flatCoordinates_;
        }
        getGeometry() {
          return this;
        }
        getSimplifiedGeometry(t) {
          return this;
        }
        simplifyTransformed(t, e) {
          return this;
        }
        getProperties() {
          return this.properties_;
        }
        getPropertiesInternal() {
          return this.properties_;
        }
        getStride() {
          return this.stride_;
        }
        getStyleFunction() {
          return this.styleFunction;
        }
        getType() {
          return this.type_;
        }
        transform(t) {
          t = Vt(t);
          const e = t.getExtent(), i = t.getWorldExtent();
          if (e && i) {
            const r = Cn(i) / Cn(e);
            Sr(wN, i[0], i[3], r, -r, 0, 0, 0), ul(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, wN, this.flatCoordinates_);
          }
        }
        applyTransform(t) {
          t(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
        }
        clone() {
          var t;
          return new ki(this.type_, this.flatCoordinates_.slice(), (t = this.ends_) == null ? void 0 : t.slice(), this.stride_, Object.assign({}, this.properties_), this.id_);
        }
        getEnds() {
          return this.ends_;
        }
        enableSimplifyTransformed() {
          return this.simplifyTransformed = CL((t, e) => {
            if (t === this.squaredTolerance_) return this.simplifiedGeometry_;
            this.simplifiedGeometry_ = this.clone(), e && this.simplifiedGeometry_.applyTransform(e);
            const i = this.simplifiedGeometry_.getFlatCoordinates();
            let r;
            switch (this.type_) {
              case "LineString":
                i.length = Wy(i, 0, this.simplifiedGeometry_.flatCoordinates_.length, this.simplifiedGeometry_.stride_, t, i, 0), r = [i.length];
                break;
              case "MultiLineString":
                r = [], i.length = oP(i, 0, this.simplifiedGeometry_.ends_, this.simplifiedGeometry_.stride_, t, i, 0, r);
                break;
              case "Polygon":
                r = [], i.length = fx(i, 0, this.simplifiedGeometry_.ends_, this.simplifiedGeometry_.stride_, Math.sqrt(t), i, 0, r);
                break;
            }
            return r && (this.simplifiedGeometry_ = new ki(this.type_, i, r, 2, this.properties_, this.id_)), this.squaredTolerance_ = t, this.simplifiedGeometry_;
          }), this;
        }
      }
      ki.prototype.getFlatCoordinates = ki.prototype.getOrientedFlatCoordinates;
      class $x extends Yr {
        constructor(t) {
          var i;
          super(), this.projection = Vt(t.projection), this.attributions_ = CN(t.attributions), this.attributionsCollapsible_ = (i = t.attributionsCollapsible) != null ? i : true, this.loading = false, this.state_ = t.state !== void 0 ? t.state : "ready", this.wrapX_ = t.wrapX !== void 0 ? t.wrapX : false, this.interpolate_ = !!t.interpolate, this.viewResolver = null, this.viewRejector = null;
          const e = this;
          this.viewPromise_ = new Promise(function(r, a) {
            e.viewResolver = r, e.viewRejector = a;
          });
        }
        getAttributions() {
          return this.attributions_;
        }
        getAttributionsCollapsible() {
          return this.attributionsCollapsible_;
        }
        getProjection() {
          return this.projection;
        }
        getResolutions(t) {
          return null;
        }
        getView() {
          return this.viewPromise_;
        }
        getState() {
          return this.state_;
        }
        getWrapX() {
          return this.wrapX_;
        }
        getInterpolate() {
          return this.interpolate_;
        }
        refresh() {
          this.changed();
        }
        setAttributions(t) {
          this.attributions_ = CN(t), this.changed();
        }
        setState(t) {
          this.state_ = t, this.changed();
        }
      }
      function CN(n) {
        return n ? typeof n == "function" ? n : (Array.isArray(n) || (n = [n]), (t) => n) : null;
      }
      const Qn = { ADDFEATURE: "addfeature", CHANGEFEATURE: "changefeature", CLEAR: "clear", REMOVEFEATURE: "removefeature", FEATURESLOADSTART: "featuresloadstart", FEATURESLOADEND: "featuresloadend", FEATURESLOADERROR: "featuresloaderror" };
      function W$(n, t) {
        return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
      }
      function _0(n, t) {
        return [n];
      }
      let X$ = false;
      function Z$(n, t, e, i, r, a, o) {
        const s = new XMLHttpRequest();
        s.open("GET", typeof n == "function" ? n(e, i, r) : n, true), t.getType() == "arraybuffer" && (s.responseType = "arraybuffer"), s.withCredentials = X$, s.onload = function(l) {
          if (!s.status || s.status >= 200 && s.status < 300) {
            const u = t.getType();
            try {
              let h;
              u == "text" || u == "json" ? h = s.responseText : u == "xml" ? h = s.responseXML || s.responseText : u == "arraybuffer" && (h = s.response), h ? a(t.readFeatures(h, { extent: e, featureProjection: r }), t.readProjection(h)) : o();
            } catch (h) {
              o();
            }
          } else o();
        }, s.onerror = o, s.send();
      }
      function SN(n, t) {
        return function(e, i, r, a, o) {
          const s = this;
          Z$(n, t, e, i, r, function(l, u) {
            s.addFeatures(l), a !== void 0 && a(l);
          }, o || Tc);
        };
      }
      class vl extends Se {
        constructor(t, e, i) {
          super(t), this.feature = e, this.features = i;
        }
      }
      class $r extends $x {
        constructor(t) {
          t = t || {}, super({ attributions: t.attributions, interpolate: true, projection: void 0, state: "ready", wrapX: t.wrapX !== void 0 ? t.wrapX : true }), this.on, this.once, this.un, this.loader_ = Tc, this.format_ = t.format || null, this.overlaps_ = t.overlaps === void 0 ? true : t.overlaps, this.url_ = t.url, t.loader !== void 0 ? this.loader_ = t.loader : this.url_ !== void 0 && (he(this.format_, "`format` must be set when `url` is set"), this.loader_ = SN(this.url_, this.format_)), this.strategy_ = t.strategy !== void 0 ? t.strategy : W$;
          const e = t.useSpatialIndex !== void 0 ? t.useSpatialIndex : true;
          this.featuresRtree_ = e ? new m0() : null, this.loadedExtentsRtree_ = new m0(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
          let i, r;
          Array.isArray(t.features) ? r = t.features : t.features && (i = t.features, r = i.getArray()), !e && i === void 0 && (i = new ir(r)), r !== void 0 && this.addFeaturesInternal(r), i !== void 0 && this.bindFeaturesCollection_(i);
        }
        addFeature(t) {
          this.addFeatureInternal(t), this.changed();
        }
        addFeatureInternal(t) {
          const e = Ft(t);
          if (!this.addToIndex_(e, t)) {
            this.featuresCollection_ && this.featuresCollection_.remove(t);
            return;
          }
          this.setupChangeEvents_(e, t);
          const i = t.getGeometry();
          if (i) {
            const r = i.getExtent();
            this.featuresRtree_ && this.featuresRtree_.insert(r, t);
          } else this.nullGeometryFeatures_[e] = t;
          this.dispatchEvent(new vl(Qn.ADDFEATURE, t));
        }
        setupChangeEvents_(t, e) {
          e instanceof ki || (this.featureChangeKeys_[t] = [ie(e, Nt.CHANGE, this.handleFeatureChange_, this), ie(e, Un.PROPERTYCHANGE, this.handleFeatureChange_, this)]);
        }
        addToIndex_(t, e) {
          let i = true;
          if (e.getId() !== void 0) {
            const r = String(e.getId());
            if (!(r in this.idIndex_)) this.idIndex_[r] = e;
            else if (e instanceof ki) {
              const a = this.idIndex_[r];
              a instanceof ki ? Array.isArray(a) ? a.push(e) : this.idIndex_[r] = [a, e] : i = false;
            } else i = false;
          }
          return i && (he(!(t in this.uidIndex_), "The passed `feature` was already added to the source"), this.uidIndex_[t] = e), i;
        }
        addFeatures(t) {
          this.addFeaturesInternal(t), this.changed();
        }
        addFeaturesInternal(t) {
          const e = [], i = [], r = [];
          for (let a = 0, o = t.length; a < o; a++) {
            const s = t[a], l = Ft(s);
            this.addToIndex_(l, s) && i.push(s);
          }
          for (let a = 0, o = i.length; a < o; a++) {
            const s = i[a], l = Ft(s);
            this.setupChangeEvents_(l, s);
            const u = s.getGeometry();
            if (u) {
              const h = u.getExtent();
              e.push(h), r.push(s);
            } else this.nullGeometryFeatures_[l] = s;
          }
          if (this.featuresRtree_ && this.featuresRtree_.load(e, r), this.hasListener(Qn.ADDFEATURE)) for (let a = 0, o = i.length; a < o; a++) this.dispatchEvent(new vl(Qn.ADDFEATURE, i[a]));
        }
        bindFeaturesCollection_(t) {
          let e = false;
          this.addEventListener(Qn.ADDFEATURE, function(i) {
            e || (e = true, t.push(i.feature), e = false);
          }), this.addEventListener(Qn.REMOVEFEATURE, function(i) {
            e || (e = true, t.remove(i.feature), e = false);
          }), t.addEventListener(Jn.ADD, (i) => {
            e || (e = true, this.addFeature(i.element), e = false);
          }), t.addEventListener(Jn.REMOVE, (i) => {
            e || (e = true, this.removeFeature(i.element), e = false);
          }), this.featuresCollection_ = t;
        }
        clear(t) {
          if (t) {
            for (const i in this.featureChangeKeys_) this.featureChangeKeys_[i].forEach(Pe);
            this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
          } else if (this.featuresRtree_) {
            const i = (r) => {
              this.removeFeatureInternal(r);
            };
            this.featuresRtree_.forEach(i);
            for (const r in this.nullGeometryFeatures_) this.removeFeatureInternal(this.nullGeometryFeatures_[r]);
          }
          this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
          const e = new vl(Qn.CLEAR);
          this.dispatchEvent(e), this.changed();
        }
        forEachFeature(t) {
          if (this.featuresRtree_) return this.featuresRtree_.forEach(t);
          this.featuresCollection_ && this.featuresCollection_.forEach(t);
        }
        forEachFeatureAtCoordinateDirect(t, e) {
          const i = [t[0], t[1], t[0], t[1]];
          return this.forEachFeatureInExtent(i, function(r) {
            const a = r.getGeometry();
            if (a instanceof ki || a.intersectsCoordinate(t)) return e(r);
          });
        }
        forEachFeatureInExtent(t, e) {
          if (this.featuresRtree_) return this.featuresRtree_.forEachInExtent(t, e);
          this.featuresCollection_ && this.featuresCollection_.forEach(e);
        }
        forEachFeatureIntersectingExtent(t, e) {
          return this.forEachFeatureInExtent(t, function(i) {
            const r = i.getGeometry();
            if (r instanceof ki || r.intersectsExtent(t)) {
              const a = e(i);
              if (a) return a;
            }
          });
        }
        getFeaturesCollection() {
          return this.featuresCollection_;
        }
        getFeatures() {
          let t;
          return this.featuresCollection_ ? t = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (t = this.featuresRtree_.getAll(), il(this.nullGeometryFeatures_) || De(t, Object.values(this.nullGeometryFeatures_))), t;
        }
        getFeaturesAtCoordinate(t) {
          const e = [];
          return this.forEachFeatureAtCoordinateDirect(t, function(i) {
            e.push(i);
          }), e;
        }
        getFeaturesInExtent(t, e) {
          if (this.featuresRtree_) {
            if (!(e && e.canWrapX() && this.getWrapX())) return this.featuresRtree_.getInExtent(t);
            const r = XE(t, e);
            return [].concat(...r.map((a) => this.featuresRtree_.getInExtent(a)));
          }
          return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
        }
        getClosestFeatureToCoordinate(t, e) {
          const i = t[0], r = t[1];
          let a = null;
          const o = [NaN, NaN];
          let s = 1 / 0;
          const l = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
          return e = e || Cu, this.featuresRtree_.forEachInExtent(l, function(u) {
            if (e(u)) {
              const h = u.getGeometry(), c = s;
              if (s = h instanceof ki ? 0 : h.closestPointXY(i, r, o, s), s < c) {
                a = u;
                const f = Math.sqrt(s);
                l[0] = i - f, l[1] = r - f, l[2] = i + f, l[3] = r + f;
              }
            }
          }), a;
        }
        getExtent(t) {
          return this.featuresRtree_.getExtent(t);
        }
        getFeatureById(t) {
          const e = this.idIndex_[t.toString()];
          return e !== void 0 ? e : null;
        }
        getFeatureByUid(t) {
          const e = this.uidIndex_[t];
          return e !== void 0 ? e : null;
        }
        getFormat() {
          return this.format_;
        }
        getOverlaps() {
          return this.overlaps_;
        }
        getUrl() {
          return this.url_;
        }
        handleFeatureChange_(t) {
          const e = t.target, i = Ft(e), r = e.getGeometry();
          if (!r) i in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(e), this.nullGeometryFeatures_[i] = e);
          else {
            const o = r.getExtent();
            i in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[i], this.featuresRtree_ && this.featuresRtree_.insert(o, e)) : this.featuresRtree_ && this.featuresRtree_.update(o, e);
          }
          const a = e.getId();
          if (a !== void 0) {
            const o = a.toString();
            this.idIndex_[o] !== e && (this.removeFromIdIndex_(e), this.idIndex_[o] = e);
          } else this.removeFromIdIndex_(e), this.uidIndex_[i] = e;
          this.changed(), this.dispatchEvent(new vl(Qn.CHANGEFEATURE, e));
        }
        hasFeature(t) {
          const e = t.getId();
          return e !== void 0 ? e in this.idIndex_ : Ft(t) in this.uidIndex_;
        }
        isEmpty() {
          return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && il(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : true;
        }
        loadFeatures(t, e, i) {
          const r = this.loadedExtentsRtree_, a = this.strategy_(t, e, i);
          for (let o = 0, s = a.length; o < s; ++o) {
            const l = a[o];
            r.forEachInExtent(l, function(h) {
              return br(h.extent, l);
            }) || (++this.loadingExtentsCount_, this.dispatchEvent(new vl(Qn.FEATURESLOADSTART)), this.loader_.call(this, l, e, i, (h) => {
              --this.loadingExtentsCount_, this.dispatchEvent(new vl(Qn.FEATURESLOADEND, void 0, h));
            }, () => {
              --this.loadingExtentsCount_, this.dispatchEvent(new vl(Qn.FEATURESLOADERROR));
            }), r.insert(l, { extent: l.slice() }));
          }
          this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
        }
        refresh() {
          this.clear(true), this.loadedExtentsRtree_.clear(), super.refresh();
        }
        removeLoadedExtent(t) {
          const e = this.loadedExtentsRtree_;
          let i;
          e.forEachInExtent(t, function(r) {
            if (al(r.extent, t)) return i = r, true;
          }), i && e.remove(i);
        }
        removeFeatures(t) {
          let e = false;
          for (let i = 0, r = t.length; i < r; ++i) e = this.removeFeatureInternal(t[i]) || e;
          e && this.changed();
        }
        removeFeature(t) {
          if (!t) return;
          this.removeFeatureInternal(t) && this.changed();
        }
        removeFeatureInternal(t) {
          const e = Ft(t);
          if (!(e in this.uidIndex_)) return false;
          e in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[e] : this.featuresRtree_ && this.featuresRtree_.remove(t);
          const i = this.featureChangeKeys_[e];
          i == null || i.forEach(Pe), delete this.featureChangeKeys_[e];
          const r = t.getId();
          if (r !== void 0) {
            const a = r.toString(), o = this.idIndex_[a];
            o === t ? delete this.idIndex_[a] : Array.isArray(o) && (o.splice(o.indexOf(t), 1), o.length === 1 && (this.idIndex_[a] = o[0]));
          }
          return delete this.uidIndex_[e], this.hasListener(Qn.REMOVEFEATURE) && this.dispatchEvent(new vl(Qn.REMOVEFEATURE, t)), true;
        }
        removeFromIdIndex_(t) {
          for (const e in this.idIndex_) if (this.idIndex_[e] === t) {
            delete this.idIndex_[e];
            break;
          }
        }
        setLoader(t) {
          this.loader_ = t;
        }
        setUrl(t) {
          he(this.format_, "`format` must be set when `url` is set"), this.url_ = t, this.setLoader(SN(t, this.format_));
        }
      }
      const At = { IDLE: 0, LOADING: 1, LOADED: 2, ERROR: 3, EMPTY: 4 };
      class Jx extends Dc {
        constructor(t, e, i) {
          super(), i = i || {}, this.tileCoord = t, this.state = e, this.key = "", this.transition_ = i.transition === void 0 ? 250 : i.transition, this.transitionStarts_ = {}, this.interpolate = !!i.interpolate;
        }
        changed() {
          this.dispatchEvent(Nt.CHANGE);
        }
        release() {
          this.state === At.ERROR && this.setState(At.EMPTY);
        }
        getKey() {
          return this.key + "/" + this.tileCoord;
        }
        getTileCoord() {
          return this.tileCoord;
        }
        getState() {
          return this.state;
        }
        setState(t) {
          if (this.state !== At.ERROR && this.state > t) throw new Error("Tile load sequence violation");
          this.state = t, this.changed();
        }
        load() {
          Qt();
        }
        getAlpha(t, e) {
          if (!this.transition_) return 1;
          let i = this.transitionStarts_[t];
          if (!i) i = e, this.transitionStarts_[t] = i;
          else if (i === -1) return 1;
          const r = e - i + 1e3 / 60;
          return r >= this.transition_ ? 1 : jP(r / this.transition_);
        }
        inTransition(t) {
          return this.transition_ ? this.transitionStarts_[t] !== -1 : false;
        }
        endTransition(t) {
          this.transition_ && (this.transitionStarts_[t] = -1);
        }
        disposeInternal() {
          this.release(), super.disposeInternal();
        }
      }
      class I0 extends Jx {
        constructor(t, e, i, r, a, o) {
          super(t, e, o), this.crossOrigin_ = r, this.src_ = i, this.key = i, this.image_ = new Image(), r !== null && (this.image_.crossOrigin = r), this.unlisten_ = null, this.tileLoadFunction_ = a;
        }
        getImage() {
          return this.image_;
        }
        setImage(t) {
          this.image_ = t, this.state = At.LOADED, this.unlistenImage_(), this.changed();
        }
        handleImageError_() {
          this.state = At.ERROR, this.unlistenImage_(), this.image_ = K$(), this.changed();
        }
        handleImageLoad_() {
          const t = this.image_;
          t.naturalWidth && t.naturalHeight ? this.state = At.LOADED : this.state = At.EMPTY, this.unlistenImage_(), this.changed();
        }
        load() {
          this.state == At.ERROR && (this.state = At.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == At.IDLE && (this.state = At.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = tK(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this)));
        }
        unlistenImage_() {
          this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
        }
        disposeInternal() {
          this.unlistenImage_(), this.image_ = null, super.disposeInternal();
        }
      }
      function K$() {
        const n = dn(1, 1);
        return n.fillStyle = "rgba(0,0,0,0)", n.fillRect(0, 0, 1, 1), n.canvas;
      }
      class $$ {
        constructor(t, e, i) {
          this.decay_ = t, this.minVelocity_ = e, this.delay_ = i, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
        }
        begin() {
          this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
        }
        update(t, e) {
          this.points_.push(t, e, Date.now());
        }
        end() {
          if (this.points_.length < 6) return false;
          const t = Date.now() - this.delay_, e = this.points_.length - 3;
          if (this.points_[e + 2] < t) return false;
          let i = e - 3;
          for (; i > 0 && this.points_[i + 2] > t; ) i -= 3;
          const r = this.points_[e + 2] - this.points_[i + 2];
          if (r < 1e3 / 60) return false;
          const a = this.points_[e] - this.points_[i], o = this.points_[e + 1] - this.points_[i + 1];
          return this.angle_ = Math.atan2(o, a), this.initialVelocity_ = Math.sqrt(a * a + o * o) / r, this.initialVelocity_ > this.minVelocity_;
        }
        getDistance() {
          return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
        }
        getAngle() {
          return this.angle_;
        }
      }
      class J$ extends nl {
        constructor(t) {
          super(), this.map_ = t;
        }
        dispatchRenderEvent(t, e) {
          Qt();
        }
        calculateMatrices2D(t) {
          const e = t.viewState, i = t.coordinateToPixelTransform, r = t.pixelToCoordinateTransform;
          Sr(i, t.size[0] / 2, t.size[1] / 2, 1 / e.resolution, -1 / e.resolution, -e.rotation, -e.center[0], -e.center[1]), Oy(r, i);
        }
        forEachFeatureAtCoordinate(t, e, i, r, a, o, s, l) {
          let u;
          const h = e.viewState;
          function c(_, E, I, x) {
            return a.call(o, E, _ ? I : null, x);
          }
          const f = h.projection, g = VL(t.slice(), f), d = [[0, 0]];
          if (f.canWrapX() && r) {
            const _ = f.getExtent(), E = ve(_);
            d.push([-E, 0], [E, 0]);
          }
          const A = e.layerStatesArray, p = A.length, v = [], y = [];
          for (let _ = 0; _ < d.length; _++) for (let E = p - 1; E >= 0; --E) {
            const I = A[E], x = I.layer;
            if (x.hasRenderer() && zx(I, h) && s.call(l, x)) {
              const w = x.getRenderer(), C = x.getSource();
              if (w && C) {
                const S = C.getWrapX() ? g : t, b = c.bind(null, I.managed);
                y[0] = S[0] + d[_][0], y[1] = S[1] + d[_][1], u = w.forEachFeatureAtCoordinate(y, e, i, b, v);
              }
              if (u) return u;
            }
          }
          if (v.length === 0) return;
          const m = 1 / v.length;
          return v.forEach((_, E) => _.distanceSq += E * m), v.sort((_, E) => _.distanceSq - E.distanceSq), v.some((_) => u = _.callback(_.feature, _.layer, _.geometry)), u;
        }
        hasFeatureAtCoordinate(t, e, i, r, a, o) {
          return this.forEachFeatureAtCoordinate(t, e, i, r, Cu, this, a, o) !== void 0;
        }
        getMap() {
          return this.map_;
        }
        renderFrame(t) {
          Qt();
        }
        scheduleExpireIconCache(t) {
          oo.canExpireCache() && t.postRenderFunctions.push(tJ);
        }
      }
      function tJ(n, t) {
        oo.expire();
      }
      class eJ extends J$ {
        constructor(t) {
          super(t), this.fontChangeListenerKey_ = ie(hs, Un.PROPERTYCHANGE, t.redrawText, t), this.element_ = document.createElement("div");
          const e = this.element_.style;
          e.position = "absolute", e.width = "100%", e.height = "100%", e.zIndex = "0", this.element_.className = Jd + " ol-layers";
          const i = t.getViewport();
          i.insertBefore(this.element_, i.firstChild || null), this.children_ = [], this.renderedVisible_ = true;
        }
        dispatchRenderEvent(t, e) {
          const i = this.getMap();
          if (i.hasListener(t)) {
            const r = new dA(t, void 0, e);
            i.dispatchEvent(r);
          }
        }
        disposeInternal() {
          Pe(this.fontChangeListenerKey_), this.element_.remove(), super.disposeInternal();
        }
        renderFrame(t) {
          if (!t) {
            this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = false);
            return;
          }
          this.calculateMatrices2D(t), this.dispatchRenderEvent(ni.PRECOMPOSE, t);
          const e = t.layerStatesArray.sort((s, l) => s.zIndex - l.zIndex);
          e.some((s) => s.layer instanceof A0 && s.layer.getDeclutter()) && (t.declutter = {});
          const r = t.viewState;
          this.children_.length = 0;
          const a = [];
          let o = null;
          for (let s = 0, l = e.length; s < l; ++s) {
            const u = e[s];
            t.layerIndex = s;
            const h = u.layer, c = h.getSourceState();
            if (!zx(u, r) || c != "ready" && c != "undefined") {
              h.unrender();
              continue;
            }
            const f = h.render(t, o);
            f && (f !== o && (this.children_.push(f), o = f), a.push(u));
          }
          this.declutter(t, a), JZ(this.element_, this.children_), this.dispatchRenderEvent(ni.POSTCOMPOSE, t), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = true), this.scheduleExpireIconCache(t);
        }
        declutter(t, e) {
          if (t.declutter) {
            for (let i = e.length - 1; i >= 0; --i) {
              const r = e[i], a = r.layer;
              a.getDeclutter() && a.renderDeclutter(t, r);
            }
            e.forEach((i) => i.layer.renderDeferred(t));
          }
        }
      }
      class yl extends Se {
        constructor(t, e) {
          super(t), this.layer = e;
        }
      }
      const tw = { LAYERS: "layers" };
      class Pr extends zP {
        constructor(t) {
          t = t || {};
          const e = Object.assign({}, t);
          delete e.layers;
          let i = t.layers;
          super(e), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(tw.LAYERS, this.handleLayersChanged_), i ? Array.isArray(i) ? i = new ir(i.slice(), { unique: true }) : he(typeof i.getArray == "function", "Expected `layers` to be an array or a `Collection`") : i = new ir(void 0, { unique: true }), this.setLayers(i);
        }
        handleLayerChange_() {
          this.changed();
        }
        handleLayersChanged_() {
          this.layersListenerKeys_.forEach(Pe), this.layersListenerKeys_.length = 0;
          const t = this.getLayers();
          this.layersListenerKeys_.push(ie(t, Jn.ADD, this.handleLayersAdd_, this), ie(t, Jn.REMOVE, this.handleLayersRemove_, this));
          for (const i in this.listenerKeys_) this.listenerKeys_[i].forEach(Pe);
          Mc(this.listenerKeys_);
          const e = t.getArray();
          for (let i = 0, r = e.length; i < r; i++) {
            const a = e[i];
            this.registerLayerListeners_(a), this.dispatchEvent(new yl("addlayer", a));
          }
          this.changed();
        }
        registerLayerListeners_(t) {
          const e = [ie(t, Un.PROPERTYCHANGE, this.handleLayerChange_, this), ie(t, Nt.CHANGE, this.handleLayerChange_, this)];
          t instanceof Pr && e.push(ie(t, "addlayer", this.handleLayerGroupAdd_, this), ie(t, "removelayer", this.handleLayerGroupRemove_, this)), this.listenerKeys_[Ft(t)] = e;
        }
        handleLayerGroupAdd_(t) {
          this.dispatchEvent(new yl("addlayer", t.layer));
        }
        handleLayerGroupRemove_(t) {
          this.dispatchEvent(new yl("removelayer", t.layer));
        }
        handleLayersAdd_(t) {
          const e = t.element;
          this.registerLayerListeners_(e), this.dispatchEvent(new yl("addlayer", e)), this.changed();
        }
        handleLayersRemove_(t) {
          const e = t.element, i = Ft(e);
          this.listenerKeys_[i].forEach(Pe), delete this.listenerKeys_[i], this.dispatchEvent(new yl("removelayer", e)), this.changed();
        }
        getLayers() {
          return this.get(tw.LAYERS);
        }
        setLayers(t) {
          const e = this.getLayers();
          if (e) {
            const i = e.getArray();
            for (let r = 0, a = i.length; r < a; ++r) this.dispatchEvent(new yl("removelayer", i[r]));
          }
          this.set(tw.LAYERS, t);
        }
        getLayersArray(t) {
          return t = t !== void 0 ? t : [], this.getLayers().forEach(function(e) {
            e.getLayersArray(t);
          }), t;
        }
        getLayerStatesArray(t) {
          const e = t !== void 0 ? t : [], i = e.length;
          this.getLayers().forEach(function(o) {
            o.getLayerStatesArray(e);
          });
          const r = this.getLayerState();
          let a = r.zIndex;
          !t && r.zIndex === void 0 && (a = 0);
          for (let o = i, s = e.length; o < s; o++) {
            const l = e[o];
            l.opacity *= r.opacity, l.visible = l.visible && r.visible, l.maxResolution = Math.min(l.maxResolution, r.maxResolution), l.minResolution = Math.max(l.minResolution, r.minResolution), l.minZoom = Math.max(l.minZoom, r.minZoom), l.maxZoom = Math.min(l.maxZoom, r.maxZoom), r.extent !== void 0 && (l.extent !== void 0 ? l.extent = ei(l.extent, r.extent) : l.extent = r.extent), l.zIndex === void 0 && (l.zIndex = a);
          }
          return e;
        }
        getSourceState() {
          return "ready";
        }
      }
      class nf extends Se {
        constructor(t, e, i) {
          super(t), this.map = e, this.frameState = i !== void 0 ? i : null;
        }
      }
      class As extends nf {
        constructor(t, e, i, r, a, o) {
          super(t, e, a), this.originalEvent = i, this.pixel_ = null, this.coordinate_ = null, this.dragging = r !== void 0 ? r : false, this.activePointers = o;
        }
        get pixel() {
          return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
        }
        set pixel(t) {
          this.pixel_ = t;
        }
        get coordinate() {
          return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
        }
        set coordinate(t) {
          this.coordinate_ = t;
        }
        preventDefault() {
          super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
        }
        stopPropagation() {
          super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
        }
      }
      const Be = { SINGLECLICK: "singleclick", CLICK: Nt.CLICK, DBLCLICK: Nt.DBLCLICK, POINTERDRAG: "pointerdrag", POINTERMOVE: "pointermove", POINTERDOWN: "pointerdown", POINTERUP: "pointerup", POINTEROVER: "pointerover", POINTEROUT: "pointerout", POINTERENTER: "pointerenter", POINTERLEAVE: "pointerleave", POINTERCANCEL: "pointercancel" }, ew = { POINTERMOVE: "pointermove", POINTERDOWN: "pointerdown", POINTERUP: "pointerup", POINTEROVER: "pointerover", POINTEROUT: "pointerout", POINTERENTER: "pointerenter", POINTERLEAVE: "pointerleave", POINTERCANCEL: "pointercancel" };
      class nJ extends Dc {
        constructor(t, e) {
          super(t), this.map_ = t, this.clickTimeoutId_, this.emulateClicks_ = false, this.dragging_ = false, this.dragListenerKeys_ = [], this.moveTolerance_ = e === void 0 ? 1 : e, this.down_ = null;
          const i = this.map_.getViewport();
          this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = i, this.pointerdownListenerKey_ = ie(i, ew.POINTERDOWN, this.handlePointerDown_, this), this.originalPointerMoveEvent_, this.relayedListenerKey_ = ie(i, ew.POINTERMOVE, this.relayMoveEvent_, this), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(Nt.TOUCHMOVE, this.boundHandleTouchMove_, CP ? { passive: false } : false);
        }
        emulateClick_(t) {
          let e = new As(Be.CLICK, this.map_, t);
          this.dispatchEvent(e), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, e = new As(Be.DBLCLICK, this.map_, t), this.dispatchEvent(e)) : this.clickTimeoutId_ = setTimeout(() => {
            this.clickTimeoutId_ = void 0;
            const i = new As(Be.SINGLECLICK, this.map_, t);
            this.dispatchEvent(i);
          }, 250);
        }
        updateActivePointers_(t) {
          const e = t, i = e.pointerId;
          if (e.type == Be.POINTERUP || e.type == Be.POINTERCANCEL) {
            delete this.trackedTouches_[i];
            for (const r in this.trackedTouches_) if (this.trackedTouches_[r].target !== e.target) {
              delete this.trackedTouches_[r];
              break;
            }
          } else (e.type == Be.POINTERDOWN || e.type == Be.POINTERMOVE) && (this.trackedTouches_[i] = e);
          this.activePointers_ = Object.values(this.trackedTouches_);
        }
        handlePointerUp_(t) {
          this.updateActivePointers_(t);
          const e = new As(Be.POINTERUP, this.map_, t, void 0, void 0, this.activePointers_);
          this.dispatchEvent(e), this.emulateClicks_ && !e.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(t) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(Pe), this.dragListenerKeys_.length = 0, this.dragging_ = false, this.down_ = null);
        }
        isMouseActionButton_(t) {
          return t.button === 0;
        }
        handlePointerDown_(t) {
          this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(t);
          const e = new As(Be.POINTERDOWN, this.map_, t, void 0, void 0, this.activePointers_);
          if (this.dispatchEvent(e), this.down_ = new PointerEvent(t.type, t), Object.defineProperty(this.down_, "target", { writable: false, value: t.target }), this.dragListenerKeys_.length === 0) {
            const i = this.map_.getOwnerDocument();
            this.dragListenerKeys_.push(ie(i, Be.POINTERMOVE, this.handlePointerMove_, this), ie(i, Be.POINTERUP, this.handlePointerUp_, this), ie(this.element_, Be.POINTERCANCEL, this.handlePointerUp_, this)), this.element_.getRootNode && this.element_.getRootNode() !== i && this.dragListenerKeys_.push(ie(this.element_.getRootNode(), Be.POINTERUP, this.handlePointerUp_, this));
          }
        }
        handlePointerMove_(t) {
          if (this.isMoving_(t)) {
            this.updateActivePointers_(t), this.dragging_ = true;
            const e = new As(Be.POINTERDRAG, this.map_, t, this.dragging_, void 0, this.activePointers_);
            this.dispatchEvent(e);
          }
        }
        relayMoveEvent_(t) {
          this.originalPointerMoveEvent_ = t;
          const e = !!(this.down_ && this.isMoving_(t));
          this.dispatchEvent(new As(Be.POINTERMOVE, this.map_, t, e));
        }
        handleTouchMove_(t) {
          const e = this.originalPointerMoveEvent_;
          (!e || e.defaultPrevented) && (typeof t.cancelable != "boolean" || t.cancelable === true) && t.preventDefault();
        }
        isMoving_(t) {
          return this.dragging_ || Math.abs(t.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(t.clientY - this.down_.clientY) > this.moveTolerance_;
        }
        disposeInternal() {
          this.relayedListenerKey_ && (Pe(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(Nt.TOUCHMOVE, this.boundHandleTouchMove_), this.pointerdownListenerKey_ && (Pe(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(Pe), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
        }
      }
      const uo = { POSTRENDER: "postrender", MOVESTART: "movestart", MOVEEND: "moveend", LOADSTART: "loadstart", LOADEND: "loadend" }, qn = { LAYERGROUP: "layergroup", SIZE: "size", TARGET: "target", VIEW: "view" }, E0 = 1 / 0;
      class iJ {
        constructor(t, e) {
          this.priorityFunction_ = t, this.keyFunction_ = e, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
        }
        clear() {
          this.elements_.length = 0, this.priorities_.length = 0, Mc(this.queuedElements_);
        }
        dequeue() {
          const t = this.elements_, e = this.priorities_, i = t[0];
          t.length == 1 ? (t.length = 0, e.length = 0) : (t[0] = t.pop(), e[0] = e.pop(), this.siftUp_(0));
          const r = this.keyFunction_(i);
          return delete this.queuedElements_[r], i;
        }
        enqueue(t) {
          he(!(this.keyFunction_(t) in this.queuedElements_), "Tried to enqueue an `element` that was already added to the queue");
          const e = this.priorityFunction_(t);
          return e != E0 ? (this.elements_.push(t), this.priorities_.push(e), this.queuedElements_[this.keyFunction_(t)] = true, this.siftDown_(0, this.elements_.length - 1), true) : false;
        }
        getCount() {
          return this.elements_.length;
        }
        getLeftChildIndex_(t) {
          return t * 2 + 1;
        }
        getRightChildIndex_(t) {
          return t * 2 + 2;
        }
        getParentIndex_(t) {
          return t - 1 >> 1;
        }
        heapify_() {
          let t;
          for (t = (this.elements_.length >> 1) - 1; t >= 0; t--) this.siftUp_(t);
        }
        isEmpty() {
          return this.elements_.length === 0;
        }
        isKeyQueued(t) {
          return t in this.queuedElements_;
        }
        isQueued(t) {
          return this.isKeyQueued(this.keyFunction_(t));
        }
        siftUp_(t) {
          const e = this.elements_, i = this.priorities_, r = e.length, a = e[t], o = i[t], s = t;
          for (; t < r >> 1; ) {
            const l = this.getLeftChildIndex_(t), u = this.getRightChildIndex_(t), h = u < r && i[u] < i[l] ? u : l;
            e[t] = e[h], i[t] = i[h], t = h;
          }
          e[t] = a, i[t] = o, this.siftDown_(s, t);
        }
        siftDown_(t, e) {
          const i = this.elements_, r = this.priorities_, a = i[e], o = r[e];
          for (; e > t; ) {
            const s = this.getParentIndex_(e);
            if (r[s] > o) i[e] = i[s], r[e] = r[s], e = s;
            else break;
          }
          i[e] = a, r[e] = o;
        }
        reprioritize() {
          const t = this.priorityFunction_, e = this.elements_, i = this.priorities_;
          let r = 0;
          const a = e.length;
          let o, s, l;
          for (s = 0; s < a; ++s) o = e[s], l = t(o), l == E0 ? delete this.queuedElements_[this.keyFunction_(o)] : (i[r] = l, e[r++] = o);
          e.length = r, i.length = r, this.heapify_();
        }
      }
      class rJ extends iJ {
        constructor(t, e) {
          super(function(i) {
            return t.apply(null, i);
          }, function(i) {
            return i[0].getKey();
          }), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = e, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
        }
        enqueue(t) {
          const e = super.enqueue(t);
          return e && t[0].addEventListener(Nt.CHANGE, this.boundHandleTileChange_), e;
        }
        getTilesLoading() {
          return this.tilesLoading_;
        }
        handleTileChange(t) {
          const e = t.target, i = e.getState();
          if (i === At.LOADED || i === At.ERROR || i === At.EMPTY) {
            i !== At.ERROR && e.removeEventListener(Nt.CHANGE, this.boundHandleTileChange_);
            const r = e.getKey();
            r in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[r], --this.tilesLoading_), this.tileChangeCallback_();
          }
        }
        loadMoreTiles(t, e) {
          let i = 0;
          for (; this.tilesLoading_ < t && i < e && this.getCount() > 0; ) {
            const r = this.dequeue()[0], a = r.getKey();
            r.getState() === At.IDLE && !(a in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[a] = true, ++this.tilesLoading_, ++i, r.load());
          }
        }
      }
      function aJ(n, t, e, i, r) {
        if (!n || !(e in n.wantedTiles) || !n.wantedTiles[e][t.getKey()]) return E0;
        const a = n.viewState.center, o = i[0] - a[0], s = i[1] - a[1];
        return 65536 * Math.log(r) + Math.sqrt(o * o + s * s) / r;
      }
      class x0 extends Yr {
        constructor(t) {
          super();
          const e = t.element;
          e && !t.target && !e.style.pointerEvents && (e.style.pointerEvents = "auto"), this.element = e || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], t.render && (this.render = t.render), t.target && this.setTarget(t.target);
        }
        disposeInternal() {
          var t;
          (t = this.element) == null || t.remove(), super.disposeInternal();
        }
        getMap() {
          return this.map_;
        }
        setMap(t) {
          var e, i;
          this.map_ && ((e = this.element) == null || e.remove());
          for (let r = 0, a = this.listenerKeys.length; r < a; ++r) Pe(this.listenerKeys[r]);
          this.listenerKeys.length = 0, this.map_ = t, t && (((i = this.target_) != null ? i : t.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== Tc && this.listenerKeys.push(ie(t, uo.POSTRENDER, this.render, this)), t.render());
        }
        render(t) {
        }
        setTarget(t) {
          this.target_ = typeof t == "string" ? document.getElementById(t) : t;
        }
      }
      class oJ extends x0 {
        constructor(t) {
          t = t || {}, super({ element: document.createElement("div"), render: t.render, target: t.target }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = t.collapsed !== void 0 ? t.collapsed : true, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = t.collapsible !== void 0, this.collapsible_ = t.collapsible !== void 0 ? t.collapsible : true, this.collapsible_ || (this.collapsed_ = false), this.attributions_ = t.attributions;
          const e = t.className !== void 0 ? t.className : "ol-attribution", i = t.tipLabel !== void 0 ? t.tipLabel : "Attributions", r = t.expandClassName !== void 0 ? t.expandClassName : e + "-expand", a = t.collapseLabel !== void 0 ? t.collapseLabel : "", o = t.collapseClassName !== void 0 ? t.collapseClassName : e + "-collapse";
          typeof a == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = a, this.collapseLabel_.className = o) : this.collapseLabel_ = a;
          const s = t.label !== void 0 ? t.label : "i";
          typeof s == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = s, this.label_.className = r) : this.label_ = s;
          const l = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
          this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = i, this.toggleButton_.appendChild(l), this.toggleButton_.addEventListener(Nt.CLICK, this.handleClick_.bind(this), false);
          const u = e + " " + Jd + " " + i0 + (this.collapsed_ && this.collapsible_ ? " " + r0 : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), h = this.element;
          h.className = u, h.appendChild(this.toggleButton_), h.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = true;
        }
        collectSourceAttributions_(t) {
          const e = this.getMap().getAllLayers(), i = new Set(e.flatMap((r) => r.getAttributions(t)));
          if (this.attributions_ !== void 0 && (Array.isArray(this.attributions_) ? this.attributions_.forEach((r) => i.add(r)) : i.add(this.attributions_)), !this.overrideCollapsible_) {
            const r = !e.some((a) => {
              var o;
              return ((o = a.getSource()) == null ? void 0 : o.getAttributionsCollapsible()) === false;
            });
            this.setCollapsible(r);
          }
          return Array.from(i);
        }
        updateElement_(t) {
          return Rt(this, null, function* () {
            if (!t) {
              this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = false);
              return;
            }
            const e = yield Promise.all(this.collectSourceAttributions_(t).map((r) => VE(() => r))), i = e.length > 0;
            if (this.renderedVisible_ != i && (this.element.style.display = i ? "" : "none", this.renderedVisible_ = i), !no(e, this.renderedAttributions_)) {
              SP(this.ulElement_);
              for (let r = 0, a = e.length; r < a; ++r) {
                const o = document.createElement("li");
                o.innerHTML = e[r], this.ulElement_.appendChild(o);
              }
              this.renderedAttributions_ = e;
            }
          });
        }
        handleClick_(t) {
          t.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
        }
        handleToggle_() {
          this.element.classList.toggle(r0), this.collapsed_ ? Jy(this.collapseLabel_, this.label_) : Jy(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
        }
        getCollapsible() {
          return this.collapsible_;
        }
        setCollapsible(t) {
          this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
        }
        setCollapsed(t) {
          this.userCollapsed_ = t, !(!this.collapsible_ || this.collapsed_ === t) && this.handleToggle_();
        }
        getCollapsed() {
          return this.collapsed_;
        }
        render(t) {
          this.updateElement_(t.frameState);
        }
      }
      class sJ extends x0 {
        constructor(t) {
          t = t || {}, super({ element: document.createElement("div"), render: t.render, target: t.target });
          const e = t.className !== void 0 ? t.className : "ol-rotate", i = t.label !== void 0 ? t.label : "", r = t.compassClassName !== void 0 ? t.compassClassName : "ol-compass";
          this.label_ = null, typeof i == "string" ? (this.label_ = document.createElement("span"), this.label_.className = r, this.label_.textContent = i) : (this.label_ = i, this.label_.classList.add(r));
          const a = t.tipLabel ? t.tipLabel : "Reset rotation", o = document.createElement("button");
          o.className = e + "-reset", o.setAttribute("type", "button"), o.title = a, o.appendChild(this.label_), o.addEventListener(Nt.CLICK, this.handleClick_.bind(this), false);
          const s = e + " " + Jd + " " + i0, l = this.element;
          l.className = s, l.appendChild(o), this.callResetNorth_ = t.resetNorth ? t.resetNorth : void 0, this.duration_ = t.duration !== void 0 ? t.duration : 250, this.autoHide_ = t.autoHide !== void 0 ? t.autoHide : true, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(n0);
        }
        handleClick_(t) {
          t.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
        }
        resetNorth_() {
          const e = this.getMap().getView();
          if (!e) return;
          const i = e.getRotation();
          i !== void 0 && (this.duration_ > 0 && i % (2 * Math.PI) !== 0 ? e.animate({ rotation: 0, duration: this.duration_, easing: Hc }) : e.setRotation(0));
        }
        render(t) {
          const e = t.frameState;
          if (!e) return;
          const i = e.viewState.rotation;
          if (i != this.rotation_) {
            const r = "rotate(" + i + "rad)";
            if (this.autoHide_) {
              const a = this.element.classList.contains(n0);
              !a && i === 0 ? this.element.classList.add(n0) : a && i !== 0 && this.element.classList.remove(n0);
            }
            this.label_.style.transform = r;
          }
          this.rotation_ = i;
        }
      }
      class lJ extends x0 {
        constructor(t) {
          t = t || {}, super({ element: document.createElement("div"), target: t.target });
          const e = t.className !== void 0 ? t.className : "ol-zoom", i = t.delta !== void 0 ? t.delta : 1, r = t.zoomInClassName !== void 0 ? t.zoomInClassName : e + "-in", a = t.zoomOutClassName !== void 0 ? t.zoomOutClassName : e + "-out", o = t.zoomInLabel !== void 0 ? t.zoomInLabel : "+", s = t.zoomOutLabel !== void 0 ? t.zoomOutLabel : "", l = t.zoomInTipLabel !== void 0 ? t.zoomInTipLabel : "Zoom in", u = t.zoomOutTipLabel !== void 0 ? t.zoomOutTipLabel : "Zoom out", h = document.createElement("button");
          h.className = r, h.setAttribute("type", "button"), h.title = l, h.appendChild(typeof o == "string" ? document.createTextNode(o) : o), h.addEventListener(Nt.CLICK, this.handleClick_.bind(this, i), false);
          const c = document.createElement("button");
          c.className = a, c.setAttribute("type", "button"), c.title = u, c.appendChild(typeof s == "string" ? document.createTextNode(s) : s), c.addEventListener(Nt.CLICK, this.handleClick_.bind(this, -i), false);
          const f = e + " " + Jd + " " + i0, g = this.element;
          g.className = f, g.appendChild(h), g.appendChild(c), this.duration_ = t.duration !== void 0 ? t.duration : 250;
        }
        handleClick_(t, e) {
          e.preventDefault(), this.zoomByDelta_(t);
        }
        zoomByDelta_(t) {
          const i = this.getMap().getView();
          if (!i) return;
          const r = i.getZoom();
          if (r !== void 0) {
            const a = i.getConstrainedZoom(r + t);
            this.duration_ > 0 ? (i.getAnimating() && i.cancelAnimations(), i.animate({ zoom: a, duration: this.duration_, easing: Hc })) : i.setZoom(a);
          }
        }
      }
      function bN(n) {
        n = n || {};
        const t = new ir();
        return (n.zoom !== void 0 ? n.zoom : true) && t.push(new lJ(n.zoomOptions)), (n.rotate !== void 0 ? n.rotate : true) && t.push(new sJ(n.rotateOptions)), (n.attribution !== void 0 ? n.attribution : true) && t.push(new oJ(n.attributionOptions)), t;
      }
      const nw = { ACTIVE: "active" };
      class pA extends Yr {
        constructor(t) {
          super(), this.on, this.once, this.un, t && t.handleEvent && (this.handleEvent = t.handleEvent), this.map_ = null, this.setActive(true);
        }
        getActive() {
          return this.get(nw.ACTIVE);
        }
        getMap() {
          return this.map_;
        }
        handleEvent(t) {
          return true;
        }
        setActive(t) {
          this.set(nw.ACTIVE, t);
        }
        setMap(t) {
          this.map_ = t;
        }
      }
      function uJ(n, t, e) {
        const i = n.getCenterInternal();
        if (i) {
          const r = [i[0] + t[0], i[1] + t[1]];
          n.animateInternal({ duration: e !== void 0 ? e : 250, easing: xK, center: n.getConstrainedCenter(r) });
        }
      }
      function iw(n, t, e, i) {
        const r = n.getZoom();
        if (r === void 0) return;
        const a = n.getConstrainedZoom(r + t), o = n.getResolutionForZoom(a);
        n.getAnimating() && n.cancelAnimations(), n.animate({ resolution: o, anchor: e, duration: i !== void 0 ? i : 250, easing: Hc });
      }
      class hJ extends pA {
        constructor(t) {
          super(), t = t || {}, this.delta_ = t.delta ? t.delta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 250;
        }
        handleEvent(t) {
          let e = false;
          if (t.type == Be.DBLCLICK) {
            const i = t.originalEvent, r = t.map, a = t.coordinate, o = i.shiftKey ? -this.delta_ : this.delta_, s = r.getView();
            iw(s, o, a, this.duration_), i.preventDefault(), e = true;
          }
          return !e;
        }
      }
      class ml extends pA {
        constructor(t) {
          t = t || {}, super(t), t.handleDownEvent && (this.handleDownEvent = t.handleDownEvent), t.handleDragEvent && (this.handleDragEvent = t.handleDragEvent), t.handleMoveEvent && (this.handleMoveEvent = t.handleMoveEvent), t.handleUpEvent && (this.handleUpEvent = t.handleUpEvent), t.stopDown && (this.stopDown = t.stopDown), this.handlingDownUpSequence = false, this.targetPointers = [];
        }
        getPointerCount() {
          return this.targetPointers.length;
        }
        handleDownEvent(t) {
          return false;
        }
        handleDragEvent(t) {
        }
        handleEvent(t) {
          if (!t.originalEvent) return true;
          let e = false;
          if (this.updateTrackedPointers_(t), this.handlingDownUpSequence) {
            if (t.type == Be.POINTERDRAG) this.handleDragEvent(t), t.originalEvent.preventDefault();
            else if (t.type == Be.POINTERUP) {
              const i = this.handleUpEvent(t);
              this.handlingDownUpSequence = i && this.targetPointers.length > 0;
            }
          } else if (t.type == Be.POINTERDOWN) {
            const i = this.handleDownEvent(t);
            this.handlingDownUpSequence = i, e = this.stopDown(i);
          } else t.type == Be.POINTERMOVE && this.handleMoveEvent(t);
          return !e;
        }
        handleMoveEvent(t) {
        }
        handleUpEvent(t) {
          return false;
        }
        stopDown(t) {
          return t;
        }
        updateTrackedPointers_(t) {
          t.activePointers && (this.targetPointers = t.activePointers);
        }
      }
      function rw(n) {
        const t = n.length;
        let e = 0, i = 0;
        for (let r = 0; r < t; r++) e += n[r].clientX, i += n[r].clientY;
        return { clientX: e / t, clientY: i / t };
      }
      function aw(n) {
        const t = arguments;
        return function(e) {
          let i = true;
          for (let r = 0, a = t.length; r < a && (i = i && t[r](e), !!i); ++r) ;
          return i;
        };
      }
      const cJ = function(n) {
        const t = n.originalEvent;
        return t.altKey && !(t.metaKey || t.ctrlKey) && !t.shiftKey;
      }, fJ = function(n) {
        const t = n.originalEvent;
        return t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey;
      }, gJ = function(n) {
        const t = n.map.getTargetElement(), e = t.getRootNode(), i = n.map.getOwnerDocument().activeElement;
        return e instanceof ShadowRoot ? e.host.contains(i) : t.contains(i);
      }, BN = function(n) {
        const t = n.map.getTargetElement(), e = t.getRootNode();
        return (e instanceof ShadowRoot ? e.host : t).hasAttribute("tabindex") ? gJ(n) : true;
      }, w0 = Cu, TN = function(n) {
        const t = n.originalEvent;
        return t.button == 0 && !(XZ && EP && t.ctrlKey);
      }, dJ = Su, AJ = function(n) {
        return n.type == Be.SINGLECLICK;
      }, ow = function(n) {
        const t = n.originalEvent;
        return !t.altKey && !(t.metaKey || t.ctrlKey) && !t.shiftKey;
      }, pJ = function(n) {
        const t = n.originalEvent;
        return EP ? t.metaKey : t.ctrlKey;
      }, MN = function(n) {
        const t = n.originalEvent;
        return !t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey;
      }, DN = function(n) {
        const t = n.originalEvent, e = t.target.tagName;
        return e !== "INPUT" && e !== "SELECT" && e !== "TEXTAREA" && !t.target.isContentEditable;
      }, sw = function(n) {
        const t = n.originalEvent;
        return he(t !== void 0, "mapBrowserEvent must originate from a pointer event"), t.pointerType == "mouse";
      }, RN = function(n) {
        const t = n.originalEvent;
        return he(t !== void 0, "mapBrowserEvent must originate from a pointer event"), t.isPrimary && t.button === 0;
      };
      class vJ extends ml {
        constructor(t) {
          super({ stopDown: Su }), t = t || {}, this.kinetic_ = t.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = false;
          const e = t.condition ? t.condition : aw(ow, RN);
          this.condition_ = t.onFocusOnly ? aw(BN, e) : e, this.noKinetic_ = false;
        }
        handleDragEvent(t) {
          const e = t.map;
          this.panning_ || (this.panning_ = true, e.getView().beginInteraction());
          const i = this.targetPointers, r = e.getEventPixel(rw(i));
          if (i.length == this.lastPointersCount_) {
            if (this.kinetic_ && this.kinetic_.update(r[0], r[1]), this.lastCentroid) {
              const a = [this.lastCentroid[0] - r[0], r[1] - this.lastCentroid[1]], s = t.map.getView();
              UL(a, s.getResolution()), JE(a, s.getRotation()), s.adjustCenterInternal(a);
            }
          } else this.kinetic_ && this.kinetic_.begin();
          this.lastCentroid = r, this.lastPointersCount_ = i.length, t.originalEvent.preventDefault();
        }
        handleUpEvent(t) {
          const e = t.map, i = e.getView();
          if (this.targetPointers.length === 0) {
            if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
              const r = this.kinetic_.getDistance(), a = this.kinetic_.getAngle(), o = i.getCenterInternal(), s = e.getPixelFromCoordinateInternal(o), l = e.getCoordinateFromPixelInternal([s[0] - r * Math.cos(a), s[1] - r * Math.sin(a)]);
              i.animateInternal({ center: i.getConstrainedCenter(l), duration: 500, easing: Hc });
            }
            return this.panning_ && (this.panning_ = false, i.endInteraction()), false;
          }
          return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, true;
        }
        handleDownEvent(t) {
          if (this.targetPointers.length > 0 && this.condition_(t)) {
            const i = t.map.getView();
            return this.lastCentroid = null, i.getAnimating() && i.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, true;
          }
          return false;
        }
      }
      class yJ extends ml {
        constructor(t) {
          t = t || {}, super({ stopDown: Su }), this.condition_ = t.condition ? t.condition : fJ, this.lastAngle_ = void 0, this.duration_ = t.duration !== void 0 ? t.duration : 250;
        }
        handleDragEvent(t) {
          if (!sw(t)) return;
          const e = t.map, i = e.getView();
          if (i.getConstraints().rotation === Fx) return;
          const r = e.getSize(), a = t.pixel, o = Math.atan2(r[1] / 2 - a[1], a[0] - r[0] / 2);
          if (this.lastAngle_ !== void 0) {
            const s = o - this.lastAngle_;
            i.adjustRotationInternal(-s);
          }
          this.lastAngle_ = o;
        }
        handleUpEvent(t) {
          return sw(t) ? (t.map.getView().endInteraction(this.duration_), false) : true;
        }
        handleDownEvent(t) {
          return sw(t) && TN(t) && this.condition_(t) ? (t.map.getView().beginInteraction(), this.lastAngle_ = void 0, true) : false;
        }
      }
      class mJ extends nl {
        constructor(t) {
          super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + t, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
        }
        disposeInternal() {
          this.setMap(null);
        }
        render_() {
          const t = this.startPixel_, e = this.endPixel_, i = "px", r = this.element_.style;
          r.left = Math.min(t[0], e[0]) + i, r.top = Math.min(t[1], e[1]) + i, r.width = Math.abs(e[0] - t[0]) + i, r.height = Math.abs(e[1] - t[1]) + i;
        }
        setMap(t) {
          if (this.map_) {
            this.map_.getOverlayContainer().removeChild(this.element_);
            const e = this.element_.style;
            e.left = "inherit", e.top = "inherit", e.width = "inherit", e.height = "inherit";
          }
          this.map_ = t, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
        }
        setPixels(t, e) {
          this.startPixel_ = t, this.endPixel_ = e, this.createOrUpdateGeometry(), this.render_();
        }
        createOrUpdateGeometry() {
          if (!this.map_) return;
          const t = this.startPixel_, e = this.endPixel_, r = [t, [t[0], e[1]], e, [e[0], t[1]]].map(this.map_.getCoordinateFromPixelInternal, this.map_);
          r[4] = r[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([r]) : this.geometry_ = new Sn([r]);
        }
        getGeometry() {
          return this.geometry_;
        }
      }
      const rf = { BOXSTART: "boxstart", BOXDRAG: "boxdrag", BOXEND: "boxend", BOXCANCEL: "boxcancel" };
      class vA extends Se {
        constructor(t, e, i) {
          super(t), this.coordinate = e, this.mapBrowserEvent = i;
        }
      }
      class _J extends ml {
        constructor(t) {
          var e, i, r;
          super(), this.on, this.once, this.un, t = t != null ? t : {}, this.box_ = new mJ(t.className || "ol-dragbox"), this.minArea_ = (e = t.minArea) != null ? e : 64, t.onBoxEnd && (this.onBoxEnd = t.onBoxEnd), this.startPixel_ = null, this.condition_ = (i = t.condition) != null ? i : TN, this.boxEndCondition_ = (r = t.boxEndCondition) != null ? r : this.defaultBoxEndCondition;
        }
        defaultBoxEndCondition(t, e, i) {
          const r = i[0] - e[0], a = i[1] - e[1];
          return r * r + a * a >= this.minArea_;
        }
        getGeometry() {
          return this.box_.getGeometry();
        }
        handleDragEvent(t) {
          this.startPixel_ && (this.box_.setPixels(this.startPixel_, t.pixel), this.dispatchEvent(new vA(rf.BOXDRAG, t.coordinate, t)));
        }
        handleUpEvent(t) {
          if (!this.startPixel_) return false;
          const e = this.boxEndCondition_(t, this.startPixel_, t.pixel);
          return e && this.onBoxEnd(t), this.dispatchEvent(new vA(e ? rf.BOXEND : rf.BOXCANCEL, t.coordinate, t)), this.box_.setMap(null), this.startPixel_ = null, false;
        }
        handleDownEvent(t) {
          return this.condition_(t) ? (this.startPixel_ = t.pixel, this.box_.setMap(t.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(new vA(rf.BOXSTART, t.coordinate, t)), true) : false;
        }
        onBoxEnd(t) {
        }
        setActive(t) {
          t || (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(new vA(rf.BOXCANCEL, this.startPixel_, null)), this.startPixel_ = null)), super.setActive(t);
        }
        setMap(t) {
          this.getMap() && (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(new vA(rf.BOXCANCEL, this.startPixel_, null)), this.startPixel_ = null)), super.setMap(t);
        }
      }
      class IJ extends _J {
        constructor(t) {
          t = t || {};
          const e = t.condition ? t.condition : MN;
          super({ condition: e, className: t.className || "ol-dragzoom", minArea: t.minArea }), this.duration_ = t.duration !== void 0 ? t.duration : 200, this.out_ = t.out !== void 0 ? t.out : false;
        }
        onBoxEnd(t) {
          const i = this.getMap().getView();
          let r = this.getGeometry();
          if (this.out_) {
            const a = i.rotatedExtentForGeometry(r), o = i.getResolutionForExtentInternal(a), s = i.getResolution() / o;
            r = r.clone(), r.scale(s * s);
          }
          i.fitInternal(r, { duration: this.duration_, easing: Hc });
        }
      }
      const Qu = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", DOWN: "ArrowDown" };
      class EJ extends pA {
        constructor(t) {
          super(), t = t || {}, this.defaultCondition_ = function(e) {
            return ow(e) && DN(e);
          }, this.condition_ = t.condition !== void 0 ? t.condition : this.defaultCondition_, this.duration_ = t.duration !== void 0 ? t.duration : 100, this.pixelDelta_ = t.pixelDelta !== void 0 ? t.pixelDelta : 128;
        }
        handleEvent(t) {
          let e = false;
          if (t.type == Nt.KEYDOWN) {
            const i = t.originalEvent, r = i.key;
            if (this.condition_(t) && (r == Qu.DOWN || r == Qu.LEFT || r == Qu.RIGHT || r == Qu.UP)) {
              const o = t.map.getView(), s = o.getResolution() * this.pixelDelta_;
              let l = 0, u = 0;
              r == Qu.DOWN ? u = -s : r == Qu.LEFT ? l = -s : r == Qu.RIGHT ? l = s : u = s;
              const h = [l, u];
              JE(h, o.getRotation()), uJ(o, h, this.duration_), i.preventDefault(), e = true;
            }
          }
          return !e;
        }
      }
      class xJ extends pA {
        constructor(t) {
          super(), t = t || {}, this.condition_ = t.condition ? t.condition : function(e) {
            return !pJ(e) && DN(e);
          }, this.delta_ = t.delta ? t.delta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 100;
        }
        handleEvent(t) {
          let e = false;
          if (t.type == Nt.KEYDOWN || t.type == Nt.KEYPRESS) {
            const i = t.originalEvent, r = i.key;
            if (this.condition_(t) && (r === "+" || r === "-")) {
              const a = t.map, o = r === "+" ? this.delta_ : -this.delta_, s = a.getView();
              iw(s, o, void 0, this.duration_), i.preventDefault(), e = true;
            }
          }
          return !e;
        }
      }
      class wJ extends pA {
        constructor(t) {
          t = t || {}, super(t), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = t.maxDelta !== void 0 ? t.maxDelta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 250, this.timeout_ = t.timeout !== void 0 ? t.timeout : 80, this.useAnchor_ = t.useAnchor !== void 0 ? t.useAnchor : true, this.constrainResolution_ = t.constrainResolution !== void 0 ? t.constrainResolution : false;
          const e = t.condition ? t.condition : w0;
          this.condition_ = t.onFocusOnly ? aw(BN, e) : e, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
        }
        endInteraction_() {
          this.trackpadTimeoutId_ = void 0;
          const t = this.getMap();
          if (!t) return;
          t.getView().endInteraction(void 0, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_ ? t.getCoordinateFromPixel(this.lastAnchor_) : null);
        }
        handleEvent(t) {
          if (!this.condition_(t) || t.type !== Nt.WHEEL) return true;
          const i = t.map, r = t.originalEvent;
          r.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = t.pixel);
          let a;
          if (t.type == Nt.WHEEL && (a = r.deltaY, YZ && r.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (a /= xP), r.deltaMode === WheelEvent.DOM_DELTA_LINE && (a *= 40)), a === 0) return false;
          this.lastDelta_ = a;
          const o = Date.now();
          this.startTime_ === void 0 && (this.startTime_ = o), (!this.mode_ || o - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(a) < 4 ? "trackpad" : "wheel");
          const s = i.getView();
          if (this.mode_ === "trackpad" && !(s.getConstrainResolution() || this.constrainResolution_)) return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (s.getAnimating() && s.cancelAnimations(), s.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_), s.adjustZoom(-a / this.deltaPerZoom_, this.lastAnchor_ ? i.getCoordinateFromPixel(this.lastAnchor_) : null), this.startTime_ = o, false;
          this.totalDelta_ += a;
          const l = Math.max(this.timeout_ - (o - this.startTime_), 0);
          return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, i), l), false;
        }
        handleWheelZoom_(t) {
          const e = t.getView();
          e.getAnimating() && e.cancelAnimations();
          let i = -en(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
          (e.getConstrainResolution() || this.constrainResolution_) && (i = i ? i > 0 ? 1 : -1 : 0), iw(e, i, this.lastAnchor_ ? t.getCoordinateFromPixel(this.lastAnchor_) : null, this.duration_), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
        }
        setMouseAnchor(t) {
          this.useAnchor_ = t, t || (this.lastAnchor_ = null);
        }
      }
      class CJ extends ml {
        constructor(t) {
          t = t || {};
          const e = t;
          e.stopDown || (e.stopDown = Su), super(e), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = false, this.rotationDelta_ = 0, this.threshold_ = t.threshold !== void 0 ? t.threshold : 0.3, this.duration_ = t.duration !== void 0 ? t.duration : 250;
        }
        handleDragEvent(t) {
          let e = 0;
          const i = this.targetPointers[0], r = this.targetPointers[1], a = Math.atan2(r.clientY - i.clientY, r.clientX - i.clientX);
          if (this.lastAngle_ !== void 0) {
            const l = a - this.lastAngle_;
            this.rotationDelta_ += l, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = true), e = l;
          }
          this.lastAngle_ = a;
          const o = t.map, s = o.getView();
          s.getConstraints().rotation !== Fx && (this.anchor_ = o.getCoordinateFromPixelInternal(o.getEventPixel(rw(this.targetPointers))), this.rotating_ && (o.render(), s.adjustRotationInternal(e, this.anchor_)));
        }
        handleUpEvent(t) {
          return this.targetPointers.length < 2 ? (t.map.getView().endInteraction(this.duration_), false) : true;
        }
        handleDownEvent(t) {
          if (this.targetPointers.length >= 2) {
            const e = t.map;
            return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = false, this.rotationDelta_ = 0, this.handlingDownUpSequence || e.getView().beginInteraction(), true;
          }
          return false;
        }
      }
      class SJ extends ml {
        constructor(t) {
          t = t || {};
          const e = t;
          e.stopDown || (e.stopDown = Su), super(e), this.anchor_ = null, this.duration_ = t.duration !== void 0 ? t.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
        }
        handleDragEvent(t) {
          let e = 1;
          const i = this.targetPointers[0], r = this.targetPointers[1], a = i.clientX - r.clientX, o = i.clientY - r.clientY, s = Math.sqrt(a * a + o * o);
          this.lastDistance_ !== void 0 && (e = this.lastDistance_ / s), this.lastDistance_ = s;
          const l = t.map, u = l.getView();
          e != 1 && (this.lastScaleDelta_ = e), this.anchor_ = l.getCoordinateFromPixelInternal(l.getEventPixel(rw(this.targetPointers))), l.render(), u.adjustResolutionInternal(e, this.anchor_);
        }
        handleUpEvent(t) {
          if (this.targetPointers.length < 2) {
            const i = t.map.getView(), r = this.lastScaleDelta_ > 1 ? 1 : -1;
            return i.endInteraction(this.duration_, r), false;
          }
          return true;
        }
        handleDownEvent(t) {
          if (this.targetPointers.length >= 2) {
            const e = t.map;
            return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || e.getView().beginInteraction(), true;
          }
          return false;
        }
      }
      function LN(n) {
        n = n || {};
        const t = new ir(), e = new $$(-5e-3, 0.05, 100);
        return (n.altShiftDragRotate !== void 0 ? n.altShiftDragRotate : true) && t.push(new yJ()), (n.doubleClickZoom !== void 0 ? n.doubleClickZoom : true) && t.push(new hJ({ delta: n.zoomDelta, duration: n.zoomDuration })), (n.dragPan !== void 0 ? n.dragPan : true) && t.push(new vJ({ onFocusOnly: n.onFocusOnly, kinetic: e })), (n.pinchRotate !== void 0 ? n.pinchRotate : true) && t.push(new CJ()), (n.pinchZoom !== void 0 ? n.pinchZoom : true) && t.push(new SJ({ duration: n.zoomDuration })), (n.keyboard !== void 0 ? n.keyboard : true) && (t.push(new EJ()), t.push(new xJ({ delta: n.zoomDelta, duration: n.zoomDuration }))), (n.mouseWheelZoom !== void 0 ? n.mouseWheelZoom : true) && t.push(new wJ({ onFocusOnly: n.onFocusOnly, duration: n.zoomDuration })), (n.shiftDragZoom !== void 0 ? n.shiftDragZoom : true) && t.push(new IJ({ duration: n.zoomDuration })), t;
      }
      function PN(n) {
        if (n instanceof Yc) {
          n.setMapInternal(null);
          return;
        }
        n instanceof Pr && n.getLayers().forEach(PN);
      }
      function NN(n, t) {
        if (n instanceof Yc) {
          n.setMapInternal(t);
          return;
        }
        if (n instanceof Pr) {
          const e = n.getLayers().getArray();
          for (let i = 0, r = e.length; i < r; ++i) NN(e[i], t);
        }
      }
      let lw = class extends Yr {
        constructor(t) {
          super(), t = t || {}, this.on, this.once, this.un;
          const e = bJ(t);
          this.renderComplete_ = false, this.loaded_ = true, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = t.maxTilesLoading !== void 0 ? t.maxTilesLoading : 16, this.pixelRatio_ = t.pixelRatio !== void 0 ? t.pixelRatio : xP, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = wn(), this.pixelToCoordinateTransform_ = wn(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = t.moveTolerance, this.keyboardEventTarget_ = e.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.targetElement_ = null, this.resizeObserver_ = new ResizeObserver(() => this.updateSize()), this.controls = e.controls || bN(), this.interactions = e.interactions || LN({ onFocusOnly: true }), this.overlays_ = e.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new rJ(this.getTilePriority.bind(this), this.handleTileChange_.bind(this)), this.addChangeListener(qn.LAYERGROUP, this.handleLayerGroupChanged_), this.addChangeListener(qn.VIEW, this.handleViewChanged_), this.addChangeListener(qn.SIZE, this.handleSizeChanged_), this.addChangeListener(qn.TARGET, this.handleTargetChanged_), this.setProperties(e.values);
          const i = this;
          t.view && !(t.view instanceof La) && t.view.then(function(r) {
            i.setView(new La(r));
          }), this.controls.addEventListener(Jn.ADD, (r) => {
            r.element.setMap(this);
          }), this.controls.addEventListener(Jn.REMOVE, (r) => {
            r.element.setMap(null);
          }), this.interactions.addEventListener(Jn.ADD, (r) => {
            r.element.setMap(this);
          }), this.interactions.addEventListener(Jn.REMOVE, (r) => {
            r.element.setMap(null);
          }), this.overlays_.addEventListener(Jn.ADD, (r) => {
            this.addOverlayInternal_(r.element);
          }), this.overlays_.addEventListener(Jn.REMOVE, (r) => {
            const a = r.element.getId();
            a !== void 0 && delete this.overlayIdIndex_[a.toString()], r.element.setMap(null);
          }), this.controls.forEach((r) => {
            r.setMap(this);
          }), this.interactions.forEach((r) => {
            r.setMap(this);
          }), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
        }
        addControl(t) {
          this.getControls().push(t);
        }
        addInteraction(t) {
          this.getInteractions().push(t);
        }
        addLayer(t) {
          this.getLayerGroup().getLayers().push(t);
        }
        handleLayerAdd_(t) {
          NN(t.layer, this);
        }
        addOverlay(t) {
          this.getOverlays().push(t);
        }
        addOverlayInternal_(t) {
          const e = t.getId();
          e !== void 0 && (this.overlayIdIndex_[e.toString()] = t), t.setMap(this);
        }
        disposeInternal() {
          this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.resizeObserver_.disconnect(), this.setTarget(null), super.disposeInternal();
        }
        forEachFeatureAtPixel(t, e, i) {
          if (!this.frameState_ || !this.renderer_) return;
          const r = this.getCoordinateFromPixelInternal(t);
          i = i !== void 0 ? i : {};
          const a = i.hitTolerance !== void 0 ? i.hitTolerance : 0, o = i.layerFilter !== void 0 ? i.layerFilter : Cu, s = i.checkWrapped !== false;
          return this.renderer_.forEachFeatureAtCoordinate(r, this.frameState_, a, s, e, null, o, null);
        }
        getFeaturesAtPixel(t, e) {
          const i = [];
          return this.forEachFeatureAtPixel(t, function(r) {
            i.push(r);
          }, e), i;
        }
        getAllLayers() {
          const t = [];
          function e(i) {
            i.forEach(function(r) {
              r instanceof Pr ? e(r.getLayers()) : t.push(r);
            });
          }
          return e(this.getLayers()), t;
        }
        hasFeatureAtPixel(t, e) {
          if (!this.frameState_ || !this.renderer_) return false;
          const i = this.getCoordinateFromPixelInternal(t);
          e = e !== void 0 ? e : {};
          const r = e.layerFilter !== void 0 ? e.layerFilter : Cu, a = e.hitTolerance !== void 0 ? e.hitTolerance : 0, o = e.checkWrapped !== false;
          return this.renderer_.hasFeatureAtCoordinate(i, this.frameState_, a, o, r, null);
        }
        getEventCoordinate(t) {
          return this.getCoordinateFromPixel(this.getEventPixel(t));
        }
        getEventCoordinateInternal(t) {
          return this.getCoordinateFromPixelInternal(this.getEventPixel(t));
        }
        getEventPixel(t) {
          const i = this.viewport_.getBoundingClientRect(), r = this.getSize(), a = i.width / r[0], o = i.height / r[1], s = "changedTouches" in t ? t.changedTouches[0] : t;
          return [(s.clientX - i.left) / a, (s.clientY - i.top) / o];
        }
        getTarget() {
          return this.get(qn.TARGET);
        }
        getTargetElement() {
          return this.targetElement_;
        }
        getCoordinateFromPixel(t) {
          return os(this.getCoordinateFromPixelInternal(t), this.getView().getProjection());
        }
        getCoordinateFromPixelInternal(t) {
          const e = this.frameState_;
          return e ? gn(e.pixelToCoordinateTransform, t.slice()) : null;
        }
        getControls() {
          return this.controls;
        }
        getOverlays() {
          return this.overlays_;
        }
        getOverlayById(t) {
          const e = this.overlayIdIndex_[t.toString()];
          return e !== void 0 ? e : null;
        }
        getInteractions() {
          return this.interactions;
        }
        getLayerGroup() {
          return this.get(qn.LAYERGROUP);
        }
        setLayers(t) {
          const e = this.getLayerGroup();
          if (t instanceof ir) {
            e.setLayers(t);
            return;
          }
          const i = e.getLayers();
          i.clear(), i.extend(t);
        }
        getLayers() {
          return this.getLayerGroup().getLayers();
        }
        getLoadingOrNotReady() {
          const t = this.getLayerGroup().getLayerStatesArray();
          for (let e = 0, i = t.length; e < i; ++e) {
            const r = t[e];
            if (!r.visible) continue;
            const a = r.layer.getRenderer();
            if (a && !a.ready) return true;
            const o = r.layer.getSource();
            if (o && o.loading) return true;
          }
          return false;
        }
        getPixelFromCoordinate(t) {
          const e = qe(t, this.getView().getProjection());
          return this.getPixelFromCoordinateInternal(e);
        }
        getPixelFromCoordinateInternal(t) {
          const e = this.frameState_;
          return e ? gn(e.coordinateToPixelTransform, t.slice(0, 2)) : null;
        }
        getRenderer() {
          return this.renderer_;
        }
        getSize() {
          return this.get(qn.SIZE);
        }
        getView() {
          return this.get(qn.VIEW);
        }
        getViewport() {
          return this.viewport_;
        }
        getOverlayContainer() {
          return this.overlayContainer_;
        }
        getOverlayContainerStopEvent() {
          return this.overlayContainerStopEvent_;
        }
        getOwnerDocument() {
          const t = this.getTargetElement();
          return t ? t.ownerDocument : document;
        }
        getTilePriority(t, e, i, r) {
          return aJ(this.frameState_, t, e, i, r);
        }
        handleBrowserEvent(t, e) {
          e = e || t.type;
          const i = new As(e, this, t);
          this.handleMapBrowserEvent(i);
        }
        handleMapBrowserEvent(t) {
          if (!this.frameState_) return;
          const e = t.originalEvent, i = e.type;
          if (i === ew.POINTERDOWN || i === Nt.WHEEL || i === Nt.KEYDOWN) {
            const r = this.getOwnerDocument(), a = this.viewport_.getRootNode ? this.viewport_.getRootNode() : r, o = e.target, s = a instanceof ShadowRoot ? a.host === o ? a.host.ownerDocument : a : a === r ? r.documentElement : a;
            if (this.overlayContainerStopEvent_.contains(o) || !s.contains(o)) return;
          }
          if (t.frameState = this.frameState_, this.dispatchEvent(t) !== false) {
            const r = this.getInteractions().getArray().slice();
            for (let a = r.length - 1; a >= 0; a--) {
              const o = r[a];
              if (o.getMap() !== this || !o.getActive() || !this.getTargetElement()) continue;
              if (!o.handleEvent(t) || t.propagationStopped) break;
            }
          }
        }
        handlePostRender() {
          const t = this.frameState_, e = this.tileQueue_;
          if (!e.isEmpty()) {
            let r = this.maxTilesLoading_, a = r;
            if (t) {
              const o = t.viewHints;
              if (o[Fn.ANIMATING] || o[Fn.INTERACTING]) {
                const s = Date.now() - t.time > 8;
                r = s ? 0 : 8, a = s ? 0 : 2;
              }
            }
            e.getTilesLoading() < r && (e.reprioritize(), e.loadMoreTiles(r, a));
          }
          t && this.renderer_ && !t.animate && (this.renderComplete_ ? (this.hasListener(ni.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(ni.RENDERCOMPLETE, t), this.loaded_ === false && (this.loaded_ = true, this.dispatchEvent(new nf(uo.LOADEND, this, t)))) : this.loaded_ === true && (this.loaded_ = false, this.dispatchEvent(new nf(uo.LOADSTART, this, t))));
          const i = this.postRenderFunctions_;
          for (let r = 0, a = i.length; r < a; ++r) i[r](this, t);
          i.length = 0;
        }
        handleSizeChanged_() {
          this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
        }
        handleTargetChanged_() {
          if (this.mapBrowserEventHandler_) {
            for (let i = 0, r = this.targetChangeHandlerKeys_.length; i < r; ++i) Pe(this.targetChangeHandlerKeys_[i]);
            this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(Nt.CONTEXTMENU, this.boundHandleBrowserEvent_), this.viewport_.removeEventListener(Nt.WHEEL, this.boundHandleBrowserEvent_), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, this.viewport_.remove();
          }
          if (this.targetElement_) {
            this.resizeObserver_.unobserve(this.targetElement_);
            const i = this.targetElement_.getRootNode();
            i instanceof ShadowRoot && this.resizeObserver_.unobserve(i.host), this.setSize(void 0);
          }
          const t = this.getTarget(), e = typeof t == "string" ? document.getElementById(t) : t;
          if (this.targetElement_ = e, !e) this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
          else {
            e.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new eJ(this)), this.mapBrowserEventHandler_ = new nJ(this, this.moveTolerance_);
            for (const a in Be) this.mapBrowserEventHandler_.addEventListener(Be[a], this.handleMapBrowserEvent.bind(this));
            this.viewport_.addEventListener(Nt.CONTEXTMENU, this.boundHandleBrowserEvent_, false), this.viewport_.addEventListener(Nt.WHEEL, this.boundHandleBrowserEvent_, CP ? { passive: false } : false);
            let i;
            if (this.keyboardEventTarget_) i = this.keyboardEventTarget_;
            else {
              const a = e.getRootNode();
              i = a instanceof ShadowRoot ? a.host : e;
            }
            this.targetChangeHandlerKeys_ = [ie(i, Nt.KEYDOWN, this.handleBrowserEvent, this), ie(i, Nt.KEYPRESS, this.handleBrowserEvent, this)];
            const r = e.getRootNode();
            r instanceof ShadowRoot && this.resizeObserver_.observe(r.host), this.resizeObserver_.observe(e);
          }
          this.updateSize();
        }
        handleTileChange_() {
          this.render();
        }
        handleViewPropertyChanged_() {
          this.render();
        }
        handleViewChanged_() {
          this.viewPropertyListenerKey_ && (Pe(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (Pe(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
          const t = this.getView();
          t && (this.updateViewportSize_(this.getSize()), this.viewPropertyListenerKey_ = ie(t, Un.PROPERTYCHANGE, this.handleViewPropertyChanged_, this), this.viewChangeListenerKey_ = ie(t, Nt.CHANGE, this.handleViewPropertyChanged_, this), t.resolveConstraints(0)), this.render();
        }
        handleLayerGroupChanged_() {
          this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(Pe), this.layerGroupPropertyListenerKeys_ = null);
          const t = this.getLayerGroup();
          t && (this.handleLayerAdd_(new yl("addlayer", t)), this.layerGroupPropertyListenerKeys_ = [ie(t, Un.PROPERTYCHANGE, this.render, this), ie(t, Nt.CHANGE, this.render, this), ie(t, "addlayer", this.handleLayerAdd_, this), ie(t, "removelayer", this.handleLayerRemove_, this)]), this.render();
        }
        isRendered() {
          return !!this.frameState_;
        }
        animationDelay_() {
          this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
        }
        renderSync() {
          this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
        }
        redrawText() {
          const t = this.getLayerGroup().getLayerStatesArray();
          for (let e = 0, i = t.length; e < i; ++e) {
            const r = t[e].layer;
            r.hasRenderer() && r.getRenderer().handleFontsChanged();
          }
        }
        render() {
          this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
        }
        removeControl(t) {
          return this.getControls().remove(t);
        }
        removeInteraction(t) {
          return this.getInteractions().remove(t);
        }
        removeLayer(t) {
          return this.getLayerGroup().getLayers().remove(t);
        }
        handleLayerRemove_(t) {
          PN(t.layer);
        }
        removeOverlay(t) {
          return this.getOverlays().remove(t);
        }
        renderFrame_(t) {
          const e = this.getSize(), i = this.getView(), r = this.frameState_;
          let a = null;
          if (e !== void 0 && DP(e) && i && i.isDef()) {
            const o = i.getHints(this.frameState_ ? this.frameState_.viewHints : void 0), s = i.getState();
            if (a = { animate: false, coordinateToPixelTransform: this.coordinateToPixelTransform_, declutter: null, extent: zd(s.center, s.resolution, s.rotation, e), index: this.frameIndex_++, layerIndex: 0, layerStatesArray: this.getLayerGroup().getLayerStatesArray(), pixelRatio: this.pixelRatio_, pixelToCoordinateTransform: this.pixelToCoordinateTransform_, postRenderFunctions: [], size: e, tileQueue: this.tileQueue_, time: t, usedTiles: {}, viewState: s, viewHints: o, wantedTiles: {}, mapId: Ft(this), renderTargets: {} }, s.nextCenter && s.nextResolution) {
              const l = isNaN(s.nextRotation) ? s.rotation : s.nextRotation;
              a.nextExtent = zd(s.nextCenter, s.nextResolution, l, e);
            }
          }
          this.frameState_ = a, this.renderer_.renderFrame(a), a && (a.animate && this.render(), Array.prototype.push.apply(this.postRenderFunctions_, a.postRenderFunctions), r && (!this.previousExtent_ || !ns(this.previousExtent_) && !al(a.extent, this.previousExtent_)) && (this.dispatchEvent(new nf(uo.MOVESTART, this, r)), this.previousExtent_ = Rc(this.previousExtent_)), this.previousExtent_ && !a.viewHints[Fn.ANIMATING] && !a.viewHints[Fn.INTERACTING] && !al(a.extent, this.previousExtent_) && (this.dispatchEvent(new nf(uo.MOVEEND, this, a)), LL(a.extent, this.previousExtent_))), this.dispatchEvent(new nf(uo.POSTRENDER, this, a)), this.renderComplete_ = (this.hasListener(uo.LOADSTART) || this.hasListener(uo.LOADEND) || this.hasListener(ni.RENDERCOMPLETE)) && !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady(), this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
            this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
          }, 0));
        }
        setLayerGroup(t) {
          const e = this.getLayerGroup();
          e && this.handleLayerRemove_(new yl("removelayer", e)), this.set(qn.LAYERGROUP, t);
        }
        setSize(t) {
          this.set(qn.SIZE, t);
        }
        setTarget(t) {
          this.set(qn.TARGET, t);
        }
        setView(t) {
          if (!t || t instanceof La) {
            this.set(qn.VIEW, t);
            return;
          }
          this.set(qn.VIEW, new La());
          const e = this;
          t.then(function(i) {
            e.setView(new La(i));
          });
        }
        updateSize() {
          const t = this.getTargetElement();
          let e;
          if (t) {
            const r = getComputedStyle(t), a = t.offsetWidth - parseFloat(r.borderLeftWidth) - parseFloat(r.paddingLeft) - parseFloat(r.paddingRight) - parseFloat(r.borderRightWidth), o = t.offsetHeight - parseFloat(r.borderTopWidth) - parseFloat(r.paddingTop) - parseFloat(r.paddingBottom) - parseFloat(r.borderBottomWidth);
            !isNaN(a) && !isNaN(o) && (e = [Math.max(0, a), Math.max(0, o)], !DP(e) && (t.offsetWidth || t.offsetHeight || t.getClientRects().length) && YL("No map visible because the map container's width or height are 0."));
          }
          const i = this.getSize();
          e && (!i || !no(e, i)) && (this.setSize(e), this.updateViewportSize_(e));
        }
        updateViewportSize_(t) {
          const e = this.getView();
          e && e.setViewportSize(t);
        }
      };
      function bJ(n) {
        let t = null;
        n.keyboardEventTarget !== void 0 && (t = typeof n.keyboardEventTarget == "string" ? document.getElementById(n.keyboardEventTarget) : n.keyboardEventTarget);
        const e = {}, i = n.layers && typeof n.layers.getLayers == "function" ? n.layers : new Pr({ layers: n.layers });
        e[qn.LAYERGROUP] = i, e[qn.TARGET] = n.target, e[qn.VIEW] = n.view instanceof La ? n.view : new La();
        let r;
        n.controls !== void 0 && (Array.isArray(n.controls) ? r = new ir(n.controls.slice()) : (he(typeof n.controls.getArray == "function", "Expected `controls` to be an array or an `ol/Collection.js`"), r = n.controls));
        let a;
        n.interactions !== void 0 && (Array.isArray(n.interactions) ? a = new ir(n.interactions.slice()) : (he(typeof n.interactions.getArray == "function", "Expected `interactions` to be an array or an `ol/Collection.js`"), a = n.interactions));
        let o;
        return n.overlays !== void 0 ? Array.isArray(n.overlays) ? o = new ir(n.overlays.slice()) : (he(typeof n.overlays.getArray == "function", "Expected `overlays` to be an array or an `ol/Collection.js`"), o = n.overlays) : o = new ir(), { controls: r, interactions: a, keyboardEventTarget: t, overlays: o, values: e };
      }
      const Si = { ELEMENT: "element", MAP: "map", OFFSET: "offset", POSITION: "position", POSITIONING: "positioning" };
      class kN extends Yr {
        constructor(t) {
          super(), this.on, this.once, this.un, this.options = t, this.id = t.id, this.insertFirst = t.insertFirst !== void 0 ? t.insertFirst : true, this.stopEvent = t.stopEvent !== void 0 ? t.stopEvent : true, this.element = document.createElement("div"), this.element.className = t.className !== void 0 ? t.className : "ol-overlay-container " + sK, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = t.autoPan === true ? {} : t.autoPan || void 0, this.rendered = { transform_: "", visible: true }, this.mapPostrenderListenerKey = null, this.addChangeListener(Si.ELEMENT, this.handleElementChanged), this.addChangeListener(Si.MAP, this.handleMapChanged), this.addChangeListener(Si.OFFSET, this.handleOffsetChanged), this.addChangeListener(Si.POSITION, this.handlePositionChanged), this.addChangeListener(Si.POSITIONING, this.handlePositioningChanged), t.element !== void 0 && this.setElement(t.element), this.setOffset(t.offset !== void 0 ? t.offset : [0, 0]), this.setPositioning(t.positioning || "top-left"), t.position !== void 0 && this.setPosition(t.position);
        }
        getElement() {
          return this.get(Si.ELEMENT);
        }
        getId() {
          return this.id;
        }
        getMap() {
          return this.get(Si.MAP) || null;
        }
        getOffset() {
          return this.get(Si.OFFSET);
        }
        getPosition() {
          return this.get(Si.POSITION);
        }
        getPositioning() {
          return this.get(Si.POSITIONING);
        }
        handleElementChanged() {
          SP(this.element);
          const t = this.getElement();
          t && this.element.appendChild(t);
        }
        handleMapChanged() {
          var e;
          this.mapPostrenderListenerKey && ((e = this.element) == null || e.remove(), Pe(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
          const t = this.getMap();
          if (t) {
            this.mapPostrenderListenerKey = ie(t, uo.POSTRENDER, this.render, this), this.updatePixelPosition();
            const i = this.stopEvent ? t.getOverlayContainerStopEvent() : t.getOverlayContainer();
            this.insertFirst ? i.insertBefore(this.element, i.childNodes[0] || null) : i.appendChild(this.element), this.performAutoPan();
          }
        }
        render() {
          this.updatePixelPosition();
        }
        handleOffsetChanged() {
          this.updatePixelPosition();
        }
        handlePositionChanged() {
          this.updatePixelPosition(), this.performAutoPan();
        }
        handlePositioningChanged() {
          this.updatePixelPosition();
        }
        setElement(t) {
          this.set(Si.ELEMENT, t);
        }
        setMap(t) {
          this.set(Si.MAP, t);
        }
        setOffset(t) {
          this.set(Si.OFFSET, t);
        }
        setPosition(t) {
          this.set(Si.POSITION, t);
        }
        performAutoPan() {
          this.autoPan && this.panIntoView(this.autoPan);
        }
        panIntoView(t) {
          const e = this.getMap();
          if (!e || !e.getTargetElement() || !this.get(Si.POSITION)) return;
          const i = this.getRect(e.getTargetElement(), e.getSize()), r = this.getElement(), a = this.getRect(r, [KZ(r), $Z(r)]);
          t = t || {};
          const o = t.margin === void 0 ? 20 : t.margin;
          if (!br(i, a)) {
            const s = a[0] - i[0], l = i[2] - a[2], u = a[1] - i[1], h = i[3] - a[3], c = [0, 0];
            if (s < 0 ? c[0] = s - o : l < 0 && (c[0] = Math.abs(l) + o), u < 0 ? c[1] = u - o : h < 0 && (c[1] = Math.abs(h) + o), c[0] !== 0 || c[1] !== 0) {
              const f = e.getView().getCenterInternal(), g = e.getPixelFromCoordinateInternal(f);
              if (!g) return;
              const d = [g[0] + c[0], g[1] + c[1]], A = t.animation || {};
              e.getView().animateInternal({ center: e.getCoordinateFromPixelInternal(d), duration: A.duration, easing: A.easing });
            }
          }
        }
        getRect(t, e) {
          const i = t.getBoundingClientRect(), r = i.left + window.pageXOffset, a = i.top + window.pageYOffset;
          return [r, a, r + e[0], a + e[1]];
        }
        setPositioning(t) {
          this.set(Si.POSITIONING, t);
        }
        setVisible(t) {
          this.rendered.visible !== t && (this.element.style.display = t ? "" : "none", this.rendered.visible = t);
        }
        updatePixelPosition() {
          const t = this.getMap(), e = this.getPosition();
          if (!t || !t.isRendered() || !e) {
            this.setVisible(false);
            return;
          }
          const i = t.getPixelFromCoordinate(e), r = t.getSize();
          this.updateRenderedPosition(i, r);
        }
        updateRenderedPosition(t, e) {
          const i = this.element.style, r = this.getOffset(), a = this.getPositioning();
          this.setVisible(true);
          const o = Math.round(t[0] + r[0]) + "px", s = Math.round(t[1] + r[1]) + "px";
          let l = "0%", u = "0%";
          a == "bottom-right" || a == "center-right" || a == "top-right" ? l = "-100%" : (a == "bottom-center" || a == "center-center" || a == "top-center") && (l = "-50%"), a == "bottom-left" || a == "bottom-center" || a == "bottom-right" ? u = "-100%" : (a == "center-left" || a == "center-center" || a == "center-right") && (u = "-50%");
          const h = `translate(${l}, ${u}) translate(${o}, ${s})`;
          this.rendered.transform_ != h && (this.rendered.transform_ = h, i.transform = h);
        }
        getOptions() {
          return this.options;
        }
      }
      class FN {
        constructor(t) {
          this.highWaterMark = t !== void 0 ? t : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
        }
        canExpireCache() {
          return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
        }
        expireCache(t) {
          for (; this.canExpireCache(); ) {
            const e = this.pop();
            e instanceof nl && e.dispose();
          }
        }
        clear() {
          this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
        }
        containsKey(t) {
          return this.entries_.hasOwnProperty(t);
        }
        forEach(t) {
          let e = this.oldest_;
          for (; e; ) t(e.value_, e.key_, this), e = e.newer;
        }
        get(t, e) {
          const i = this.entries_[t];
          return he(i !== void 0, "Tried to get a value for a key that does not exist in the cache"), i === this.newest_ || (i === this.oldest_ ? (this.oldest_ = this.oldest_.newer, this.oldest_.older = null) : (i.newer.older = i.older, i.older.newer = i.newer), i.newer = null, i.older = this.newest_, this.newest_.newer = i, this.newest_ = i), i.value_;
        }
        remove(t) {
          const e = this.entries_[t];
          return he(e !== void 0, "Tried to get a value for a key that does not exist in the cache"), e === this.newest_ ? (this.newest_ = e.older, this.newest_ && (this.newest_.newer = null)) : e === this.oldest_ ? (this.oldest_ = e.newer, this.oldest_ && (this.oldest_.older = null)) : (e.newer.older = e.older, e.older.newer = e.newer), delete this.entries_[t], --this.count_, e.value_;
        }
        getCount() {
          return this.count_;
        }
        getKeys() {
          const t = new Array(this.count_);
          let e = 0, i;
          for (i = this.newest_; i; i = i.older) t[e++] = i.key_;
          return t;
        }
        getValues() {
          const t = new Array(this.count_);
          let e = 0, i;
          for (i = this.newest_; i; i = i.older) t[e++] = i.value_;
          return t;
        }
        peekLast() {
          return this.oldest_.value_;
        }
        peekLastKey() {
          return this.oldest_.key_;
        }
        peekFirstKey() {
          return this.newest_.key_;
        }
        peek(t) {
          var e;
          return (e = this.entries_[t]) == null ? void 0 : e.value_;
        }
        pop() {
          const t = this.oldest_;
          return delete this.entries_[t.key_], t.newer && (t.newer.older = null), this.oldest_ = t.newer, this.oldest_ || (this.newest_ = null), --this.count_, t.value_;
        }
        replace(t, e) {
          this.get(t), this.entries_[t].value_ = e;
        }
        set(t, e) {
          he(!(t in this.entries_), "Tried to set a value for a key that is used already");
          const i = { key_: t, newer: null, older: this.newest_, value_: e };
          this.newest_ ? this.newest_.newer = i : this.oldest_ = i, this.newest_ = i, this.entries_[t] = i, ++this.count_;
        }
        setSize(t) {
          this.highWaterMark = t;
        }
      }
      function af(n, t, e, i) {
        return i !== void 0 ? (i[0] = n, i[1] = t, i[2] = e, i) : [n, t, e];
      }
      function QN(n, t, e) {
        return n + "/" + t + "/" + e;
      }
      function of(n) {
        return QN(n[0], n[1], n[2]);
      }
      function ON(n) {
        return BJ(n[0], n[1], n[2]);
      }
      function BJ(n, t, e) {
        return (t << n) + e;
      }
      function TJ(n, t) {
        const e = n[0], i = n[1], r = n[2];
        if (t.getMinZoom() > e || e > t.getMaxZoom()) return false;
        const a = t.getFullTileRange(e);
        return a ? a.containsXY(i, r) : true;
      }
      class C0 {
        constructor(t, e, i, r) {
          this.minX = t, this.maxX = e, this.minY = i, this.maxY = r;
        }
        contains(t) {
          return this.containsXY(t[1], t[2]);
        }
        containsTileRange(t) {
          return this.minX <= t.minX && t.maxX <= this.maxX && this.minY <= t.minY && t.maxY <= this.maxY;
        }
        containsXY(t, e) {
          return this.minX <= t && t <= this.maxX && this.minY <= e && e <= this.maxY;
        }
        equals(t) {
          return this.minX == t.minX && this.minY == t.minY && this.maxX == t.maxX && this.maxY == t.maxY;
        }
        extend(t) {
          t.minX < this.minX && (this.minX = t.minX), t.maxX > this.maxX && (this.maxX = t.maxX), t.minY < this.minY && (this.minY = t.minY), t.maxY > this.maxY && (this.maxY = t.maxY);
        }
        getHeight() {
          return this.maxY - this.minY + 1;
        }
        getSize() {
          return [this.getWidth(), this.getHeight()];
        }
        getWidth() {
          return this.maxX - this.minX + 1;
        }
        intersects(t) {
          return this.minX <= t.maxX && this.maxX >= t.minX && this.minY <= t.maxY && this.maxY >= t.minY;
        }
      }
      function sf(n, t, e, i, r) {
        return r !== void 0 ? (r.minX = n, r.maxX = t, r.minY = e, r.maxY = i, r) : new C0(n, t, e, i);
      }
      const S0 = { DRAWSTART: "drawstart", DRAWEND: "drawend", DRAWABORT: "drawabort" };
      class b0 extends Se {
        constructor(t, e) {
          super(t), this.feature = e;
        }
      }
      function MJ(n, t) {
        const e = [];
        for (let i = 0; i < t.length; ++i) {
          const a = t[i].getGeometry();
          zN(n, a, e);
        }
        return e;
      }
      function B0(n, t) {
        return is(n[0], n[1], t[0], t[1]);
      }
      function lf(n, t) {
        const e = n.length;
        return t < 0 ? n[t + e] : t >= e ? n[t - e] : n[t];
      }
      function T0(n, t, e) {
        let i, r;
        t < e ? (i = t, r = e) : (i = e, r = t);
        const a = Math.ceil(i), o = Math.floor(r);
        if (a > o) {
          const l = uf(n, i), u = uf(n, r);
          return B0(l, u);
        }
        let s = 0;
        if (i < a) {
          const l = uf(n, i), u = lf(n, a);
          s += B0(l, u);
        }
        if (o < r) {
          const l = lf(n, o), u = uf(n, r);
          s += B0(l, u);
        }
        for (let l = a; l < o - 1; ++l) {
          const u = lf(n, l), h = lf(n, l + 1);
          s += B0(u, h);
        }
        return s;
      }
      function zN(n, t, e) {
        if (t instanceof be) {
          M0(n, t.getCoordinates(), false, e);
          return;
        }
        if (t instanceof ri) {
          const i = t.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) M0(n, i[r], false, e);
          return;
        }
        if (t instanceof Sn) {
          const i = t.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) M0(n, i[r], true, e);
          return;
        }
        if (t instanceof Ci) {
          const i = t.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r];
            for (let s = 0, l = o.length; s < l; ++s) M0(n, o[s], true, e);
          }
          return;
        }
        if (t instanceof yn) {
          const i = t.getGeometries();
          for (let r = 0; r < i.length; ++r) zN(n, i[r], e);
          return;
        }
      }
      const uw = { index: -1, endIndex: NaN };
      function DJ(n, t, e, i) {
        const r = n[0], a = n[1];
        let o = 1 / 0, s = -1, l = NaN;
        for (let c = 0; c < t.targets.length; ++c) {
          const f = t.targets[c], g = f.coordinates;
          let d = 1 / 0, A;
          for (let p = 0; p < g.length - 1; ++p) {
            const v = g[p], y = g[p + 1], m = GN(r, a, v, y);
            m.squaredDistance < d && (d = m.squaredDistance, A = p + m.along);
          }
          d < o && (o = d, f.ring && t.targetIndex === c && (f.endIndex > f.startIndex ? A < f.startIndex && (A += g.length) : f.endIndex < f.startIndex && A > f.startIndex && (A -= g.length)), l = A, s = c);
        }
        const u = t.targets[s];
        let h = u.ring;
        if (t.targetIndex === s && h) {
          const c = uf(u.coordinates, l), f = e.getPixelFromCoordinate(c);
          jy(f, t.startPx) > i && (h = false);
        }
        if (h) {
          const c = u.coordinates, f = c.length, g = u.startIndex, d = l;
          if (g < d) {
            const A = T0(c, g, d);
            T0(c, g, d - f) < A && (l -= f);
          } else {
            const A = T0(c, g, d);
            T0(c, g, d + f) < A && (l += f);
          }
        }
        return uw.index = s, uw.endIndex = l, uw;
      }
      function M0(n, t, e, i) {
        const r = n[0], a = n[1];
        for (let o = 0, s = t.length - 1; o < s; ++o) {
          const l = t[o], u = t[o + 1], h = GN(r, a, l, u);
          if (h.squaredDistance === 0) {
            const c = o + h.along;
            i.push({ coordinates: t, ring: e, startIndex: c, endIndex: c });
            return;
          }
        }
      }
      const hw = { along: 0, squaredDistance: 0 };
      function GN(n, t, e, i) {
        const r = e[0], a = e[1], o = i[0], s = i[1], l = o - r, u = s - a;
        let h = 0, c = r, f = a;
        return (l !== 0 || u !== 0) && (h = en(((n - r) * l + (t - a) * u) / (l * l + u * u), 0, 1), c += l * h, f += u * h), hw.along = h, hw.squaredDistance = Ud(is(n, t, c, f), 10), hw;
      }
      function uf(n, t) {
        const e = n.length;
        let i = Math.floor(t);
        const r = t - i;
        i >= e ? i -= e : i < 0 && (i += e);
        let a = i + 1;
        a >= e && (a -= e);
        const o = n[i], s = o[0], l = o[1], u = n[a], h = u[0] - s, c = u[1] - l;
        return [s + h * r, l + c * r];
      }
      class UN extends ml {
        constructor(t) {
          const e = t;
          e.stopDown || (e.stopDown = Su), super(e), this.on, this.once, this.un, this.shouldHandle_ = false, this.downPx_ = null, this.downTimeout_, this.lastDragTime_, this.pointerType_, this.freehand_ = false, this.source_ = t.source ? t.source : null, this.features_ = t.features ? t.features : null, this.snapTolerance_ = t.snapTolerance ? t.snapTolerance : 12, this.type_ = t.type, this.mode_ = NJ(this.type_), this.stopClick_ = !!t.stopClick, this.minPoints_ = t.minPoints ? t.minPoints : this.mode_ === "Polygon" ? 3 : 2, this.maxPoints_ = this.mode_ === "Circle" ? 2 : t.maxPoints ? t.maxPoints : 1 / 0, this.finishCondition_ = t.finishCondition ? t.finishCondition : Cu, this.geometryLayout_ = t.geometryLayout ? t.geometryLayout : "XY";
          let i = t.geometryFunction;
          if (!i) {
            const r = this.mode_;
            if (r === "Circle") i = (a, o, s) => {
              const l = o || new AA([NaN, NaN]), u = qe(a[0]), h = io(u, qe(a[a.length - 1]));
              return l.setCenterAndRadius(u, Math.sqrt(h), this.geometryLayout_), l;
            };
            else {
              let a;
              r === "Point" ? a = Oe : r === "LineString" ? a = be : r === "Polygon" && (a = Sn), i = (o, s, l) => (s ? r === "Polygon" ? o[0].length ? s.setCoordinates([o[0].concat([o[0][0]])], this.geometryLayout_) : s.setCoordinates([], this.geometryLayout_) : s.setCoordinates(o, this.geometryLayout_) : s = new a(o, this.geometryLayout_), s);
            }
          }
          this.geometryFunction_ = i, this.dragVertexDelay_ = t.dragVertexDelay !== void 0 ? t.dragVertexDelay : 500, this.finishCoordinate_ = null, this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchCoords_ = null, this.sketchLine_ = null, this.sketchLineCoords_ = null, this.squaredClickTolerance_ = t.clickTolerance ? t.clickTolerance * t.clickTolerance : 36, this.overlay_ = new Kr({ source: new $r({ useSpatialIndex: false, wrapX: t.wrapX ? t.wrapX : false }), style: t.style ? t.style : RJ(), updateWhileInteracting: true }), this.geometryName_ = t.geometryName, this.condition_ = t.condition ? t.condition : ow, this.freehandCondition_, t.freehand ? this.freehandCondition_ = w0 : this.freehandCondition_ = t.freehandCondition ? t.freehandCondition : MN, this.traceCondition_, this.setTrace(t.trace || false), this.traceState_ = { active: false }, this.traceSource_ = t.traceSource || t.source || null, this.addChangeListener(nw.ACTIVE, this.updateState_);
        }
        setTrace(t) {
          let e;
          t ? t === true ? e = w0 : e = t : e = dJ, this.traceCondition_ = e;
        }
        setMap(t) {
          super.setMap(t), this.updateState_();
        }
        getOverlay() {
          return this.overlay_;
        }
        handleEvent(t) {
          t.originalEvent.type === Nt.CONTEXTMENU && t.originalEvent.preventDefault(), this.freehand_ = this.mode_ !== "Point" && this.freehandCondition_(t);
          let e = t.type === Be.POINTERMOVE, i = true;
          return !this.freehand_ && this.lastDragTime_ && t.type === Be.POINTERDRAG && (Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = t.pixel, this.shouldHandle_ = !this.freehand_, e = true) : this.lastDragTime_ = void 0, this.shouldHandle_ && this.downTimeout_ !== void 0 && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0)), this.freehand_ && t.type === Be.POINTERDRAG && this.sketchFeature_ !== null ? (this.addToDrawing_(t.coordinate), i = false) : this.freehand_ && t.type === Be.POINTERDOWN ? i = false : e && this.getPointerCount() < 2 ? (i = t.type === Be.POINTERMOVE, i && this.freehand_ ? (this.handlePointerMove_(t), this.shouldHandle_ && t.originalEvent.preventDefault()) : (t.originalEvent.pointerType === "mouse" || t.type === Be.POINTERDRAG && this.downTimeout_ === void 0) && this.handlePointerMove_(t)) : t.type === Be.DBLCLICK && (i = false), super.handleEvent(t) && i;
        }
        handleDownEvent(t) {
          return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = t.pixel, this.finishCoordinate_ || this.startDrawing_(t.coordinate), true) : this.condition_(t) ? (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(() => {
            this.handlePointerMove_(new As(Be.POINTERMOVE, t.map, t.originalEvent, false, t.frameState));
          }, this.dragVertexDelay_), this.downPx_ = t.pixel, true) : (this.lastDragTime_ = void 0, false);
        }
        deactivateTrace_() {
          this.traceState_ = { active: false };
        }
        toggleTraceState_(t) {
          if (!this.traceSource_ || !this.traceCondition_(t)) return;
          if (this.traceState_.active) {
            this.deactivateTrace_();
            return;
          }
          const e = this.getMap(), i = e.getCoordinateFromPixel([t.pixel[0] - this.snapTolerance_, t.pixel[1] + this.snapTolerance_]), r = e.getCoordinateFromPixel([t.pixel[0] + this.snapTolerance_, t.pixel[1] - this.snapTolerance_]), a = Vn([i, r]), o = this.traceSource_.getFeaturesInExtent(a);
          if (o.length === 0) return;
          const s = MJ(t.coordinate, o);
          s.length && (this.traceState_ = { active: true, startPx: t.pixel.slice(), targets: s, targetIndex: -1 });
        }
        addOrRemoveTracedCoordinates_(t, e) {
          const i = t.startIndex <= t.endIndex, r = t.startIndex <= e;
          i === r ? i && e > t.endIndex || !i && e < t.endIndex ? this.addTracedCoordinates_(t, t.endIndex, e) : (i && e < t.endIndex || !i && e > t.endIndex) && this.removeTracedCoordinates_(e, t.endIndex) : (this.removeTracedCoordinates_(t.startIndex, t.endIndex), this.addTracedCoordinates_(t, t.startIndex, e));
        }
        removeTracedCoordinates_(t, e) {
          if (t === e) return;
          let i = 0;
          if (t < e) {
            const r = Math.ceil(t);
            let a = Math.floor(e);
            a === e && (a -= 1), i = a - r + 1;
          } else {
            const r = Math.floor(t);
            let a = Math.ceil(e);
            a === e && (a += 1), i = r - a + 1;
          }
          i > 0 && this.removeLastPoints_(i);
        }
        addTracedCoordinates_(t, e, i) {
          if (e === i) return;
          const r = [];
          if (e < i) {
            const a = Math.ceil(e);
            let o = Math.floor(i);
            o === i && (o -= 1);
            for (let s = a; s <= o; ++s) r.push(lf(t.coordinates, s));
          } else {
            const a = Math.floor(e);
            let o = Math.ceil(i);
            o === i && (o += 1);
            for (let s = a; s >= o; --s) r.push(lf(t.coordinates, s));
          }
          r.length && this.appendCoordinates(r);
        }
        updateTrace_(t) {
          const e = this.traceState_;
          if (!e.active || e.targetIndex === -1 && jy(e.startPx, t.pixel) < this.snapTolerance_) return;
          const i = DJ(t.coordinate, e, this.getMap(), this.snapTolerance_);
          if (e.targetIndex !== i.index) {
            if (e.targetIndex !== -1) {
              const l = e.targets[e.targetIndex];
              this.removeTracedCoordinates_(l.startIndex, l.endIndex);
            }
            const s = e.targets[i.index];
            this.addTracedCoordinates_(s, s.startIndex, i.endIndex);
          } else {
            const s = e.targets[e.targetIndex];
            this.addOrRemoveTracedCoordinates_(s, i.endIndex);
          }
          e.targetIndex = i.index;
          const r = e.targets[e.targetIndex];
          r.endIndex = i.endIndex;
          const a = uf(r.coordinates, r.endIndex), o = this.getMap().getPixelFromCoordinate(a);
          t.coordinate = a, t.pixel = [Math.round(o[0]), Math.round(o[1])];
        }
        handleUpEvent(t) {
          let e = true;
          if (this.getPointerCount() === 0) {
            this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(t);
            const i = this.traceState_.active;
            if (this.toggleTraceState_(t), this.shouldHandle_) {
              const r = !this.finishCoordinate_;
              r && this.startDrawing_(t.coordinate), !r && this.freehand_ ? this.finishDrawing() : !this.freehand_ && (!r || this.mode_ === "Point") && (this.atFinish_(t.pixel, i) ? this.finishCondition_(t) && this.finishDrawing() : this.addToDrawing_(t.coordinate)), e = false;
            } else this.freehand_ && this.abortDrawing();
          }
          return !e && this.stopClick_ && t.preventDefault(), e;
        }
        handlePointerMove_(t) {
          if (this.pointerType_ = t.originalEvent.pointerType, this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
            const e = this.downPx_, i = t.pixel, r = e[0] - i[0], a = e[1] - i[1], o = r * r + a * a;
            if (this.shouldHandle_ = this.freehand_ ? o > this.squaredClickTolerance_ : o <= this.squaredClickTolerance_, !this.shouldHandle_) return;
          }
          if (!this.finishCoordinate_) {
            this.createOrUpdateSketchPoint_(t.coordinate.slice());
            return;
          }
          this.updateTrace_(t), this.modifyDrawing_(t.coordinate);
        }
        atFinish_(t, e) {
          let i = false;
          if (this.sketchFeature_) {
            let r = false, a = [this.finishCoordinate_];
            const o = this.mode_;
            if (o === "Point") i = true;
            else if (o === "Circle") i = this.sketchCoords_.length === 2;
            else if (o === "LineString") r = !e && this.sketchCoords_.length > this.minPoints_;
            else if (o === "Polygon") {
              const s = this.sketchCoords_;
              r = s[0].length > this.minPoints_, a = [s[0][0], s[0][s[0].length - 2]], e ? a = [s[0][0]] : a = [s[0][0], s[0][s[0].length - 2]];
            }
            if (r) {
              const s = this.getMap();
              for (let l = 0, u = a.length; l < u; l++) {
                const h = a[l], c = s.getPixelFromCoordinate(h), f = t[0] - c[0], g = t[1] - c[1], d = this.freehand_ ? 1 : this.snapTolerance_;
                if (i = Math.sqrt(f * f + g * g) <= d, i) {
                  this.finishCoordinate_ = h;
                  break;
                }
              }
            }
          }
          return i;
        }
        createOrUpdateSketchPoint_(t) {
          this.sketchPoint_ ? this.sketchPoint_.getGeometry().setCoordinates(t) : (this.sketchPoint_ = new xe(new Oe(t)), this.updateSketchFeatures_());
        }
        createOrUpdateCustomSketchLine_(t) {
          this.sketchLine_ || (this.sketchLine_ = new xe());
          const e = t.getLinearRing(0);
          let i = this.sketchLine_.getGeometry();
          i ? (i.setFlatCoordinates(e.getLayout(), e.getFlatCoordinates()), i.changed()) : (i = new be(e.getFlatCoordinates(), e.getLayout()), this.sketchLine_.setGeometry(i));
        }
        startDrawing_(t) {
          const e = this.getMap().getView().getProjection(), i = Hd(this.geometryLayout_);
          for (; t.length < i; ) t.push(0);
          this.finishCoordinate_ = t, this.mode_ === "Point" ? this.sketchCoords_ = t.slice() : this.mode_ === "Polygon" ? (this.sketchCoords_ = [[t.slice(), t.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [t.slice(), t.slice()], this.sketchLineCoords_ && (this.sketchLine_ = new xe(new be(this.sketchLineCoords_)));
          const r = this.geometryFunction_(this.sketchCoords_, void 0, e);
          this.sketchFeature_ = new xe(), this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(r), this.updateSketchFeatures_(), this.dispatchEvent(new b0(S0.DRAWSTART, this.sketchFeature_));
        }
        modifyDrawing_(t) {
          const e = this.getMap(), i = this.sketchFeature_.getGeometry(), r = e.getView().getProjection(), a = Hd(this.geometryLayout_);
          let o, s;
          for (; t.length < a; ) t.push(0);
          this.mode_ === "Point" ? s = this.sketchCoords_ : this.mode_ === "Polygon" ? (o = this.sketchCoords_[0], s = o[o.length - 1], this.atFinish_(e.getPixelFromCoordinate(t)) && (t = this.finishCoordinate_.slice())) : (o = this.sketchCoords_, s = o[o.length - 1]), s[0] = t[0], s[1] = t[1], this.geometryFunction_(this.sketchCoords_, i, r), this.sketchPoint_ && this.sketchPoint_.getGeometry().setCoordinates(t), i.getType() === "Polygon" && this.mode_ !== "Polygon" ? this.createOrUpdateCustomSketchLine_(i) : this.sketchLineCoords_ && this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_), this.updateSketchFeatures_();
        }
        addToDrawing_(t) {
          const e = this.sketchFeature_.getGeometry(), i = this.getMap().getView().getProjection();
          let r, a;
          const o = this.mode_;
          return o === "LineString" || o === "Circle" ? (this.finishCoordinate_ = t.slice(), a = this.sketchCoords_, a.length >= this.maxPoints_ && (this.freehand_ ? a.pop() : r = true), a.push(t.slice()), this.geometryFunction_(a, e, i)) : o === "Polygon" && (a = this.sketchCoords_[0], a.length >= this.maxPoints_ && (this.freehand_ ? a.pop() : r = true), a.push(t.slice()), r && (this.finishCoordinate_ = a[0]), this.geometryFunction_(this.sketchCoords_, e, i)), this.createOrUpdateSketchPoint_(t.slice()), this.updateSketchFeatures_(), r ? this.finishDrawing() : this.sketchFeature_;
        }
        removeLastPoints_(t) {
          if (!this.sketchFeature_) return;
          const e = this.sketchFeature_.getGeometry(), i = this.getMap().getView().getProjection(), r = this.mode_;
          for (let a = 0; a < t; ++a) {
            let o;
            if (r === "LineString" || r === "Circle") {
              if (o = this.sketchCoords_, o.splice(-2, 1), o.length >= 2) {
                this.finishCoordinate_ = o[o.length - 2].slice();
                const s = this.finishCoordinate_.slice();
                o[o.length - 1] = s, this.createOrUpdateSketchPoint_(s);
              }
              this.geometryFunction_(o, e, i), e.getType() === "Polygon" && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(e);
            } else if (r === "Polygon") {
              o = this.sketchCoords_[0], o.splice(-2, 1);
              const s = this.sketchLine_.getGeometry();
              if (o.length >= 2) {
                const l = o[o.length - 2].slice();
                o[o.length - 1] = l, this.createOrUpdateSketchPoint_(l);
              }
              s.setCoordinates(o), this.geometryFunction_(this.sketchCoords_, e, i);
            }
            if (o.length === 1) {
              this.abortDrawing();
              break;
            }
          }
          this.updateSketchFeatures_();
        }
        removeLastPoint() {
          this.removeLastPoints_(1);
        }
        finishDrawing() {
          const t = this.abortDrawing_();
          if (!t) return null;
          let e = this.sketchCoords_;
          const i = t.getGeometry(), r = this.getMap().getView().getProjection();
          return this.mode_ === "LineString" ? (e.pop(), this.geometryFunction_(e, i, r)) : this.mode_ === "Polygon" && (e[0].pop(), this.geometryFunction_(e, i, r), e = i.getCoordinates()), this.type_ === "MultiPoint" ? t.setGeometry(new sr([e])) : this.type_ === "MultiLineString" ? t.setGeometry(new ri([e])) : this.type_ === "MultiPolygon" && t.setGeometry(new Ci([e])), this.dispatchEvent(new b0(S0.DRAWEND, t)), this.features_ && this.features_.push(t), this.source_ && this.source_.addFeature(t), t;
        }
        abortDrawing_() {
          this.finishCoordinate_ = null;
          const t = this.sketchFeature_;
          return this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(true), this.deactivateTrace_(), t;
        }
        abortDrawing() {
          const t = this.abortDrawing_();
          t && this.dispatchEvent(new b0(S0.DRAWABORT, t));
        }
        appendCoordinates(t) {
          const e = this.mode_, i = !this.sketchFeature_;
          i && this.startDrawing_(t[0]);
          let r;
          if (e === "LineString" || e === "Circle") r = this.sketchCoords_;
          else if (e === "Polygon") r = this.sketchCoords_ && this.sketchCoords_.length ? this.sketchCoords_[0] : [];
          else return;
          i && r.shift(), r.pop();
          for (let o = 0; o < t.length; o++) this.addToDrawing_(t[o]);
          const a = t[t.length - 1];
          this.sketchFeature_ = this.addToDrawing_(a), this.modifyDrawing_(a);
        }
        extend(t) {
          const i = t.getGeometry();
          this.sketchFeature_ = t, this.sketchCoords_ = i.getCoordinates();
          const r = this.sketchCoords_[this.sketchCoords_.length - 1];
          this.finishCoordinate_ = r.slice(), this.sketchCoords_.push(r.slice()), this.sketchPoint_ = new xe(new Oe(r)), this.updateSketchFeatures_(), this.dispatchEvent(new b0(S0.DRAWSTART, this.sketchFeature_));
        }
        updateSketchFeatures_() {
          const t = [];
          this.sketchFeature_ && t.push(this.sketchFeature_), this.sketchLine_ && t.push(this.sketchLine_), this.sketchPoint_ && t.push(this.sketchPoint_);
          const e = this.overlay_.getSource();
          e.clear(true), e.addFeatures(t);
        }
        updateState_() {
          const t = this.getMap(), e = this.getActive();
          (!t || !e) && this.abortDrawing(), this.overlay_.setMap(e ? t : null);
        }
      }
      function RJ() {
        const n = QP();
        return function(t, e) {
          return n[t.getGeometry().getType()];
        };
      }
      function LJ(n, t) {
        return function(e, i, r) {
          const a = qe(e[0]), o = qe(e[e.length - 1]), s = Math.sqrt(io(a, o));
          i = i || AP(new AA(a), n);
          let l = t;
          {
            const u = o[0] - a[0], h = o[1] - a[1];
            l = Math.atan2(h, u);
          }
          return pP(i, a, s, l), i;
        };
      }
      function PJ() {
        return function(n, t, e) {
          const i = Vn([n[0], n[n.length - 1]].map(function(a) {
            return qe(a);
          })), r = [[Pc(i), Nc(i), ol(i), Zr(i), Pc(i)]];
          return t ? t.setCoordinates(r) : t = new Sn(r), t;
        };
      }
      function NJ(n) {
        switch (n) {
          case "Point":
          case "MultiPoint":
            return "Point";
          case "LineString":
          case "MultiLineString":
            return "LineString";
          case "Polygon":
          case "MultiPolygon":
            return "Polygon";
          case "Circle":
            return "Circle";
          default:
            throw new Error("Invalid type: " + n);
        }
      }
      const VN = 0, yA = 1, jN = [0, 0, 0, 0], hf = [], cw = { MODIFYSTART: "modifystart", MODIFYEND: "modifyend" };
      class fw extends Se {
        constructor(t, e, i) {
          super(t), this.features = e, this.mapBrowserEvent = i;
        }
      }
      class gw extends ml {
        constructor(t) {
          super(t), this.on, this.once, this.un, this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this), this.condition_ = t.condition ? t.condition : RN, this.defaultDeleteCondition_ = function(i) {
            return cJ(i) && AJ(i);
          }, this.deleteCondition_ = t.deleteCondition ? t.deleteCondition : this.defaultDeleteCondition_, this.insertVertexCondition_ = t.insertVertexCondition ? t.insertVertexCondition : w0, this.vertexFeature_ = null, this.vertexSegments_ = null, this.lastPixel_ = [0, 0], this.ignoreNextSingleClick_ = false, this.featuresBeingModified_ = null, this.rBush_ = new m0(), this.pixelTolerance_ = t.pixelTolerance !== void 0 ? t.pixelTolerance : 10, this.snappedToVertex_ = false, this.changingFeature_ = false, this.dragSegments_ = [], this.overlay_ = new Kr({ source: new $r({ useSpatialIndex: false, wrapX: !!t.wrapX }), style: t.style ? t.style : FJ(), updateWhileAnimating: true, updateWhileInteracting: true }), this.SEGMENT_WRITERS_ = { Point: this.writePointGeometry_.bind(this), LineString: this.writeLineStringGeometry_.bind(this), LinearRing: this.writeLineStringGeometry_.bind(this), Polygon: this.writePolygonGeometry_.bind(this), MultiPoint: this.writeMultiPointGeometry_.bind(this), MultiLineString: this.writeMultiLineStringGeometry_.bind(this), MultiPolygon: this.writeMultiPolygonGeometry_.bind(this), Circle: this.writeCircleGeometry_.bind(this), GeometryCollection: this.writeGeometryCollectionGeometry_.bind(this) }, this.source_ = null, this.hitDetection_ = null;
          let e;
          if (t.features ? e = t.features : t.source && (this.source_ = t.source, e = new ir(this.source_.getFeatures()), this.source_.addEventListener(Qn.ADDFEATURE, this.handleSourceAdd_.bind(this)), this.source_.addEventListener(Qn.REMOVEFEATURE, this.handleSourceRemove_.bind(this))), !e) throw new Error("The modify interaction requires features, a source or a layer");
          t.hitDetection && (this.hitDetection_ = t.hitDetection), this.features_ = e, this.features_.forEach(this.addFeature_.bind(this)), this.features_.addEventListener(Jn.ADD, this.handleFeatureAdd_.bind(this)), this.features_.addEventListener(Jn.REMOVE, this.handleFeatureRemove_.bind(this)), this.lastPointerEvent_ = null, this.delta_ = [0, 0], this.snapToPointer_ = t.snapToPointer === void 0 ? !this.hitDetection_ : t.snapToPointer;
        }
        addFeature_(t) {
          const e = t.getGeometry();
          if (e) {
            const r = this.SEGMENT_WRITERS_[e.getType()];
            r && r(t, e);
          }
          const i = this.getMap();
          i && i.isRendered() && this.getActive() && this.handlePointerAtPixel_(this.lastPixel_, i), t.addEventListener(Nt.CHANGE, this.boundHandleFeatureChange_);
        }
        willModifyFeatures_(t, e) {
          if (!this.featuresBeingModified_) {
            this.featuresBeingModified_ = new ir();
            const i = this.featuresBeingModified_.getArray();
            for (let r = 0, a = e.length; r < a; ++r) {
              const o = e[r];
              for (let s = 0, l = o.length; s < l; ++s) {
                const u = o[s].feature;
                u && !i.includes(u) && this.featuresBeingModified_.push(u);
              }
            }
            this.featuresBeingModified_.getLength() === 0 ? this.featuresBeingModified_ = null : this.dispatchEvent(new fw(cw.MODIFYSTART, this.featuresBeingModified_, t));
          }
        }
        removeFeature_(t) {
          this.removeFeatureSegmentData_(t), this.vertexFeature_ && this.features_.getLength() === 0 && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), t.removeEventListener(Nt.CHANGE, this.boundHandleFeatureChange_);
        }
        removeFeatureSegmentData_(t) {
          const e = this.rBush_, i = [];
          e.forEach(function(r) {
            t === r.feature && i.push(r);
          });
          for (let r = i.length - 1; r >= 0; --r) {
            const a = i[r];
            for (let o = this.dragSegments_.length - 1; o >= 0; --o) this.dragSegments_[o][0] === a && this.dragSegments_.splice(o, 1);
            e.remove(a);
          }
        }
        setActive(t) {
          this.vertexFeature_ && !t && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), super.setActive(t);
        }
        setMap(t) {
          this.overlay_.setMap(t), super.setMap(t);
        }
        getOverlay() {
          return this.overlay_;
        }
        handleSourceAdd_(t) {
          t.feature && this.features_.push(t.feature);
        }
        handleSourceRemove_(t) {
          t.feature && this.features_.remove(t.feature);
        }
        handleFeatureAdd_(t) {
          this.addFeature_(t.element);
        }
        handleFeatureChange_(t) {
          if (!this.changingFeature_) {
            const e = t.target;
            this.removeFeature_(e), this.addFeature_(e);
          }
        }
        handleFeatureRemove_(t) {
          this.removeFeature_(t.element);
        }
        writePointGeometry_(t, e) {
          const i = e.getCoordinates(), r = { feature: t, geometry: e, segment: [i, i] };
          this.rBush_.insert(e.getExtent(), r);
        }
        writeMultiPointGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r], s = { feature: t, geometry: e, depth: [r], index: r, segment: [o, o] };
            this.rBush_.insert(e.getExtent(), s);
          }
        }
        writeLineStringGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length - 1; r < a; ++r) {
            const o = i.slice(r, r + 2), s = { feature: t, geometry: e, index: r, segment: o };
            this.rBush_.insert(Vn(o), s);
          }
        }
        writeMultiLineStringGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r];
            for (let s = 0, l = o.length - 1; s < l; ++s) {
              const u = o.slice(s, s + 2), h = { feature: t, geometry: e, depth: [r], index: s, segment: u };
              this.rBush_.insert(Vn(u), h);
            }
          }
        }
        writePolygonGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r];
            for (let s = 0, l = o.length - 1; s < l; ++s) {
              const u = o.slice(s, s + 2), h = { feature: t, geometry: e, depth: [r], index: s, segment: u };
              this.rBush_.insert(Vn(u), h);
            }
          }
        }
        writeMultiPolygonGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r];
            for (let s = 0, l = o.length; s < l; ++s) {
              const u = o[s];
              for (let h = 0, c = u.length - 1; h < c; ++h) {
                const f = u.slice(h, h + 2), g = { feature: t, geometry: e, depth: [s, r], index: h, segment: f };
                this.rBush_.insert(Vn(f), g);
              }
            }
          }
        }
        writeCircleGeometry_(t, e) {
          const i = e.getCenter(), r = { feature: t, geometry: e, index: VN, segment: [i, i] }, a = { feature: t, geometry: e, index: yA, segment: [i, i] }, o = [r, a];
          r.featureSegments = o, a.featureSegments = o, this.rBush_.insert(Lc(i), r);
          let s = e;
          this.rBush_.insert(s.getExtent(), a);
        }
        writeGeometryCollectionGeometry_(t, e) {
          const i = e.getGeometriesArray();
          for (let r = 0; r < i.length; ++r) {
            const a = i[r], o = this.SEGMENT_WRITERS_[a.getType()];
            o(t, a);
          }
        }
        createOrUpdateVertexFeature_(t, e, i) {
          let r = this.vertexFeature_;
          return r ? r.getGeometry().setCoordinates(t) : (r = new xe(new Oe(t)), this.vertexFeature_ = r, this.overlay_.getSource().addFeature(r)), r.set("features", e), r.set("geometries", i), r;
        }
        handleEvent(t) {
          if (!t.originalEvent) return true;
          this.lastPointerEvent_ = t;
          let e;
          return !t.map.getView().getInteracting() && t.type == Be.POINTERMOVE && !this.handlingDownUpSequence && this.handlePointerMove_(t), this.vertexFeature_ && this.deleteCondition_(t) && (t.type != Be.SINGLECLICK || !this.ignoreNextSingleClick_ ? e = this.removePoint() : e = true), t.type == Be.SINGLECLICK && (this.ignoreNextSingleClick_ = false), super.handleEvent(t) && !e;
        }
        handleDragEvent(t) {
          this.ignoreNextSingleClick_ = false, this.willModifyFeatures_(t, this.dragSegments_);
          const e = [t.coordinate[0] + this.delta_[0], t.coordinate[1] + this.delta_[1]], i = [], r = [];
          for (let a = 0, o = this.dragSegments_.length; a < o; ++a) {
            const s = this.dragSegments_[a], l = s[0], u = l.feature;
            i.includes(u) || i.push(u);
            const h = l.geometry;
            r.includes(h) || r.push(h);
            const c = l.depth;
            let f;
            const g = l.segment, d = s[1];
            for (; e.length < h.getStride(); ) e.push(g[d][e.length]);
            switch (h.getType()) {
              case "Point":
                f = e, g[0] = e, g[1] = e;
                break;
              case "MultiPoint":
                f = h.getCoordinates(), f[l.index] = e, g[0] = e, g[1] = e;
                break;
              case "LineString":
                f = h.getCoordinates(), f[l.index + d] = e, g[d] = e;
                break;
              case "MultiLineString":
                f = h.getCoordinates(), f[c[0]][l.index + d] = e, g[d] = e;
                break;
              case "Polygon":
                f = h.getCoordinates(), f[c[0]][l.index + d] = e, g[d] = e;
                break;
              case "MultiPolygon":
                f = h.getCoordinates(), f[c[1]][c[0]][l.index + d] = e, g[d] = e;
                break;
              case "Circle":
                if (g[0] = e, g[1] = e, l.index === VN) this.changingFeature_ = true, h.setCenter(e), this.changingFeature_ = false;
                else {
                  this.changingFeature_ = true, t.map.getView().getProjection();
                  let A = jy(qe(h.getCenter()), qe(e));
                  h.setRadius(A), this.changingFeature_ = false;
                }
                break;
            }
            f && this.setGeometryCoordinates_(h, f);
          }
          this.createOrUpdateVertexFeature_(e, i, r);
        }
        handleDownEvent(t) {
          if (!this.condition_(t)) return false;
          const e = t.coordinate;
          this.handlePointerAtPixel_(t.pixel, t.map, e), this.dragSegments_.length = 0, this.featuresBeingModified_ = null;
          const i = this.vertexFeature_;
          if (i) {
            t.map.getView().getProjection();
            const r = [], a = i.getGeometry().getCoordinates(), o = Vn([a]), s = this.rBush_.getInExtent(o), l = {};
            s.sort(kJ);
            for (let u = 0, h = s.length; u < h; ++u) {
              const c = s[u], f = c.segment;
              let g = Ft(c.geometry);
              const d = c.depth;
              if (d && (g += "-" + d.join("-")), l[g] || (l[g] = new Array(2)), c.geometry.getType() === "Circle" && c.index === yA) {
                const A = HN(e, c);
                Da(A, a) && !l[g][0] && (this.dragSegments_.push([c, 0]), l[g][0] = c);
                continue;
              }
              if (Da(f[0], a) && !l[g][0]) {
                this.dragSegments_.push([c, 0]), l[g][0] = c;
                continue;
              }
              if (Da(f[1], a) && !l[g][1]) {
                if (l[g][0] && l[g][0].index === 0) {
                  let A = c.geometry.getCoordinates();
                  switch (c.geometry.getType()) {
                    case "LineString":
                    case "MultiLineString":
                      continue;
                    case "MultiPolygon":
                      A = A[d[1]];
                    case "Polygon":
                      if (c.index !== A[d[0]].length - 2) continue;
                      break;
                  }
                }
                this.dragSegments_.push([c, 1]), l[g][1] = c;
                continue;
              }
              Ft(f) in this.vertexSegments_ && !l[g][0] && !l[g][1] && this.insertVertexCondition_(t) && r.push(c);
            }
            r.length && this.willModifyFeatures_(t, [r]);
            for (let u = r.length - 1; u >= 0; --u) this.insertVertex_(r[u], a);
          }
          return !!this.vertexFeature_;
        }
        handleUpEvent(t) {
          for (let e = this.dragSegments_.length - 1; e >= 0; --e) {
            const i = this.dragSegments_[e][0], r = i.geometry;
            if (r.getType() === "Circle") {
              const a = r.getCenter(), o = i.featureSegments[0], s = i.featureSegments[1];
              o.segment[0] = a, o.segment[1] = a, s.segment[0] = a, s.segment[1] = a, this.rBush_.update(Lc(a), o);
              let l = r;
              this.rBush_.update(l.getExtent(), s);
            } else this.rBush_.update(Vn(i.segment), i);
          }
          return this.featuresBeingModified_ && (this.dispatchEvent(new fw(cw.MODIFYEND, this.featuresBeingModified_, t)), this.featuresBeingModified_ = null), false;
        }
        handlePointerMove_(t) {
          this.lastPixel_ = t.pixel, this.handlePointerAtPixel_(t.pixel, t.map, t.coordinate);
        }
        handlePointerAtPixel_(t, e, i) {
          const r = i || e.getCoordinateFromPixel(t);
          e.getView().getProjection();
          const a = function(l, u) {
            return qN(r, l) - qN(r, u);
          };
          let o, s;
          if (this.hitDetection_) {
            const l = typeof this.hitDetection_ == "object" ? (u) => u === this.hitDetection_ : void 0;
            e.forEachFeatureAtPixel(t, (u, h, c) => {
              c && c.getType() === "Point" && (c = new Oe(os(c.getCoordinates())));
              const f = c || u.getGeometry();
              if (u instanceof xe && this.features_.getArray().includes(u)) {
                s = f;
                const g = u.getGeometry().getFlatCoordinates().slice(0, 2);
                o = [{ feature: u, geometry: s, segment: [g, g] }];
              }
              return true;
            }, { layerFilter: l });
          }
          if (!o) {
            const l = Ni(Lc(r, jN)), u = e.getView().getResolution() * this.pixelTolerance_, h = qd(es(l, u, jN));
            o = this.rBush_.getInExtent(h);
          }
          if (o && o.length > 0) {
            const l = o.sort(a)[0], u = l.segment;
            let h = HN(r, l);
            const c = e.getPixelFromCoordinate(h);
            let f = jy(t, c);
            if (s || f <= this.pixelTolerance_) {
              const g = {};
              if (g[Ft(u)] = true, this.snapToPointer_ || (this.delta_[0] = h[0] - r[0], this.delta_[1] = h[1] - r[1]), l.geometry.getType() === "Circle" && l.index === yA) this.snappedToVertex_ = true, this.createOrUpdateVertexFeature_(h, [l.feature], [l.geometry]);
              else {
                const d = e.getPixelFromCoordinate(u[0]), A = e.getPixelFromCoordinate(u[1]), p = io(c, d), v = io(c, A);
                f = Math.sqrt(Math.min(p, v)), this.snappedToVertex_ = f <= this.pixelTolerance_, this.snappedToVertex_ && (h = p > v ? u[1] : u[0]), this.createOrUpdateVertexFeature_(h, [l.feature], [l.geometry]);
                const y = {};
                y[Ft(l.geometry)] = true;
                for (let m = 1, _ = o.length; m < _; ++m) {
                  const E = o[m].segment;
                  if (Da(u[0], E[0]) && Da(u[1], E[1]) || Da(u[0], E[1]) && Da(u[1], E[0])) {
                    const I = Ft(o[m].geometry);
                    I in y || (y[I] = true, g[Ft(E)] = true);
                  } else break;
                }
              }
              this.vertexSegments_ = g;
              return;
            }
          }
          this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null);
        }
        insertVertex_(t, e) {
          const i = t.segment, r = t.feature, a = t.geometry, o = t.depth, s = t.index;
          let l;
          for (; e.length < a.getStride(); ) e.push(0);
          switch (a.getType()) {
            case "MultiLineString":
              l = a.getCoordinates(), l[o[0]].splice(s + 1, 0, e);
              break;
            case "Polygon":
              l = a.getCoordinates(), l[o[0]].splice(s + 1, 0, e);
              break;
            case "MultiPolygon":
              l = a.getCoordinates(), l[o[1]][o[0]].splice(s + 1, 0, e);
              break;
            case "LineString":
              l = a.getCoordinates(), l.splice(s + 1, 0, e);
              break;
            default:
              return;
          }
          this.setGeometryCoordinates_(a, l);
          const u = this.rBush_;
          u.remove(t), this.updateSegmentIndices_(a, s, o, 1);
          const h = { segment: [i[0], e], feature: r, geometry: a, depth: o, index: s };
          u.insert(Vn(h.segment), h), this.dragSegments_.push([h, 1]);
          const c = { segment: [e, i[1]], feature: r, geometry: a, depth: o, index: s + 1 };
          u.insert(Vn(c.segment), c), this.dragSegments_.push([c, 0]), this.ignoreNextSingleClick_ = true;
        }
        removePoint() {
          if (this.lastPointerEvent_ && this.lastPointerEvent_.type != Be.POINTERDRAG) {
            const t = this.lastPointerEvent_;
            this.willModifyFeatures_(t, this.dragSegments_);
            const e = this.removeVertex_();
            return this.featuresBeingModified_ && this.dispatchEvent(new fw(cw.MODIFYEND, this.featuresBeingModified_, t)), this.featuresBeingModified_ = null, e;
          }
          return false;
        }
        removeVertex_() {
          const t = this.dragSegments_, e = {};
          let i = false, r, a, o, s, l, u, h, c, f, g, d;
          for (l = t.length - 1; l >= 0; --l) o = t[l], g = o[0], d = Ft(g.feature), g.depth && (d += "-" + g.depth.join("-")), d in e || (e[d] = {}), o[1] === 0 ? (e[d].right = g, e[d].index = g.index) : o[1] == 1 && (e[d].left = g, e[d].index = g.index + 1);
          for (d in e) {
            switch (f = e[d].right, h = e[d].left, u = e[d].index, c = u - 1, h !== void 0 ? g = h : g = f, c < 0 && (c = 0), s = g.geometry, a = s.getCoordinates(), r = a, i = false, s.getType()) {
              case "MultiLineString":
                a[g.depth[0]].length > 2 && (a[g.depth[0]].splice(u, 1), i = true);
                break;
              case "LineString":
                a.length > 2 && (a.splice(u, 1), i = true);
                break;
              case "MultiPolygon":
                r = r[g.depth[1]];
              case "Polygon":
                r = r[g.depth[0]], r.length > 4 && (u == r.length - 1 && (u = 0), r.splice(u, 1), i = true, u === 0 && (r.pop(), r.push(r[0]), c = r.length - 1));
                break;
            }
            if (i) {
              this.setGeometryCoordinates_(s, a);
              const A = [];
              if (h !== void 0 && (this.rBush_.remove(h), A.push(h.segment[0])), f !== void 0 && (this.rBush_.remove(f), A.push(f.segment[1])), h !== void 0 && f !== void 0) {
                const p = { depth: g.depth, feature: g.feature, geometry: g.geometry, index: c, segment: A };
                this.rBush_.insert(Vn(p.segment), p);
              }
              this.updateSegmentIndices_(s, u, g.depth, -1), this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), t.length = 0;
            }
          }
          return i;
        }
        setGeometryCoordinates_(t, e) {
          this.changingFeature_ = true, t.setCoordinates(e), this.changingFeature_ = false;
        }
        updateSegmentIndices_(t, e, i, r) {
          this.rBush_.forEachInExtent(t.getExtent(), function(a) {
            a.geometry === t && (i === void 0 || a.depth === void 0 || no(a.depth, i)) && a.index > e && (a.index += r);
          });
        }
      }
      function kJ(n, t) {
        return n.index - t.index;
      }
      function qN(n, t, e) {
        const i = t.geometry;
        if (i.getType() === "Circle") {
          let a = i;
          if (t.index === yA) {
            const o = io(a.getCenter(), qe(n)), s = Math.sqrt(o) - a.getRadius();
            return s * s;
          }
        }
        const r = qe(n);
        return hf[0] = qe(t.segment[0]), hf[1] = qe(t.segment[1]), wZ(r, hf);
      }
      function HN(n, t, e) {
        const i = t.geometry;
        if (i.getType() === "Circle" && t.index === yA) return os(i.getClosestPoint(qe(n)));
        const r = qe(n);
        return hf[0] = qe(t.segment[0]), hf[1] = qe(t.segment[1]), os($E(r, hf));
      }
      function FJ() {
        const n = QP();
        return function(t, e) {
          return n.Point;
        };
      }
      const QJ = { SNAP: "snap" };
      class OJ extends Se {
        constructor(t, e) {
          super(t), this.vertex = e.vertex, this.vertexPixel = e.vertexPixel, this.feature = e.feature, this.segment = e.segment;
        }
      }
      function YN(n) {
        return n.feature ? n.feature : n.element ? n.element : null;
      }
      const dw = [];
      class zJ extends ml {
        constructor(t) {
          t = t || {};
          const e = t;
          e.handleDownEvent || (e.handleDownEvent = Cu), e.stopDown || (e.stopDown = Su), super(e), this.on, this.once, this.un, this.source_ = t.source ? t.source : null, this.vertex_ = t.vertex !== void 0 ? t.vertex : true, this.edge_ = t.edge !== void 0 ? t.edge : true, this.features_ = t.features ? t.features : null, this.featuresListenerKeys_ = [], this.featureChangeListenerKeys_ = {}, this.indexedFeaturesExtents_ = {}, this.pendingFeatures_ = {}, this.pixelTolerance_ = t.pixelTolerance !== void 0 ? t.pixelTolerance : 10, this.rBush_ = new m0(), this.GEOMETRY_SEGMENTERS_ = { Point: this.segmentPointGeometry_.bind(this), LineString: this.segmentLineStringGeometry_.bind(this), LinearRing: this.segmentLineStringGeometry_.bind(this), Polygon: this.segmentPolygonGeometry_.bind(this), MultiPoint: this.segmentMultiPointGeometry_.bind(this), MultiLineString: this.segmentMultiLineStringGeometry_.bind(this), MultiPolygon: this.segmentMultiPolygonGeometry_.bind(this), GeometryCollection: this.segmentGeometryCollectionGeometry_.bind(this), Circle: this.segmentCircleGeometry_.bind(this) };
        }
        addFeature(t, e) {
          e = e !== void 0 ? e : true;
          const i = Ft(t), r = t.getGeometry();
          if (r) {
            const a = this.GEOMETRY_SEGMENTERS_[r.getType()];
            if (a) {
              this.indexedFeaturesExtents_[i] = r.getExtent(Ii());
              const o = [];
              if (a(o, r), o.length === 1) this.rBush_.insert(Vn(o[0]), { feature: t, segment: o[0] });
              else if (o.length > 1) {
                const s = o.map((u) => Vn(u)), l = o.map((u) => ({ feature: t, segment: u }));
                this.rBush_.load(s, l);
              }
            }
          }
          e && (this.featureChangeListenerKeys_[i] = ie(t, Nt.CHANGE, this.handleFeatureChange_, this));
        }
        getFeatures_() {
          let t;
          return this.features_ ? t = this.features_ : this.source_ && (t = this.source_.getFeatures()), t;
        }
        handleEvent(t) {
          const e = this.snapTo(t.pixel, t.coordinate, t.map);
          return e && (t.coordinate = e.vertex.slice(0, 2), t.pixel = e.vertexPixel, this.dispatchEvent(new OJ(QJ.SNAP, { vertex: t.coordinate, vertexPixel: t.pixel, feature: e.feature, segment: e.segment }))), super.handleEvent(t);
        }
        handleFeatureAdd_(t) {
          const e = YN(t);
          e && this.addFeature(e);
        }
        handleFeatureRemove_(t) {
          const e = YN(t);
          e && this.removeFeature(e);
        }
        handleFeatureChange_(t) {
          const e = t.target;
          if (this.handlingDownUpSequence) {
            const i = Ft(e);
            i in this.pendingFeatures_ || (this.pendingFeatures_[i] = e);
          } else this.updateFeature_(e);
        }
        handleUpEvent(t) {
          const e = Object.values(this.pendingFeatures_);
          return e.length && (e.forEach(this.updateFeature_.bind(this)), this.pendingFeatures_ = {}), false;
        }
        removeFeature(t, e) {
          const i = e !== void 0 ? e : true, r = Ft(t), a = this.indexedFeaturesExtents_[r];
          if (a) {
            const o = this.rBush_, s = [];
            o.forEachInExtent(a, function(l) {
              t === l.feature && s.push(l);
            });
            for (let l = s.length - 1; l >= 0; --l) o.remove(s[l]);
          }
          i && (Pe(this.featureChangeListenerKeys_[r]), delete this.featureChangeListenerKeys_[r]);
        }
        setMap(t) {
          const e = this.getMap(), i = this.featuresListenerKeys_, r = this.getFeatures_();
          e && (i.forEach(Pe), i.length = 0, this.rBush_.clear(), Object.values(this.featureChangeListenerKeys_).forEach(Pe), this.featureChangeListenerKeys_ = {}), super.setMap(t), t && (this.features_ ? i.push(ie(this.features_, Jn.ADD, this.handleFeatureAdd_, this), ie(this.features_, Jn.REMOVE, this.handleFeatureRemove_, this)) : this.source_ && i.push(ie(this.source_, Qn.ADDFEATURE, this.handleFeatureAdd_, this), ie(this.source_, Qn.REMOVEFEATURE, this.handleFeatureRemove_, this)), r.forEach((a) => this.addFeature(a)));
        }
        snapTo(t, e, i) {
          i.getView().getProjection();
          const r = qe(e), a = qd(es(Vn([r]), i.getView().getResolution() * this.pixelTolerance_)), o = this.rBush_.getInExtent(a), s = o.length;
          if (s === 0) return null;
          let l, u = 1 / 0, h, c = null;
          const f = this.pixelTolerance_ * this.pixelTolerance_, g = () => {
            if (l) {
              const d = i.getPixelFromCoordinate(l);
              if (io(t, d) <= f) return { vertex: l, vertexPixel: [Math.round(d[0]), Math.round(d[1])], feature: h, segment: c };
            }
            return null;
          };
          if (this.vertex_) {
            for (let A = 0; A < s; ++A) {
              const p = o[A];
              p.feature.getGeometry().getType() !== "Circle" && p.segment.forEach((v) => {
                const y = qe(v), m = io(r, y);
                m < u && (l = v, u = m, h = p.feature);
              });
            }
            const d = g();
            if (d) return d;
          }
          if (this.edge_) {
            for (let A = 0; A < s; ++A) {
              let p = null;
              const v = o[A];
              if (v.feature.getGeometry().getType() === "Circle") {
                let y = v.feature.getGeometry();
                p = xZ(r, y);
              } else {
                const [y, m] = v.segment;
                m && (dw[0] = qe(y), dw[1] = qe(m), p = $E(r, dw));
              }
              if (p) {
                const y = io(r, p);
                y < u && (l = os(p), c = v.feature.getGeometry().getType() === "Circle" ? null : v.segment, u = y, h = v.feature);
              }
            }
            const d = g();
            if (d) return d;
          }
          return null;
        }
        updateFeature_(t) {
          this.removeFeature(t, false), this.addFeature(t, false);
        }
        segmentCircleGeometry_(t, e) {
          this.getMap().getView().getProjection();
          const a = AP(e).getCoordinates()[0];
          for (let o = 0, s = a.length - 1; o < s; ++o) t.push(a.slice(o, o + 2));
        }
        segmentGeometryCollectionGeometry_(t, e) {
          const i = e.getGeometriesArray();
          for (let r = 0; r < i.length; ++r) {
            const a = this.GEOMETRY_SEGMENTERS_[i[r].getType()];
            a && a(t, i[r]);
          }
        }
        segmentLineStringGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length - 1; r < a; ++r) t.push(i.slice(r, r + 2));
        }
        segmentMultiLineStringGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r];
            for (let s = 0, l = o.length - 1; s < l; ++s) t.push(o.slice(s, s + 2));
          }
        }
        segmentMultiPointGeometry_(t, e) {
          e.getCoordinates().forEach((i) => {
            t.push([i]);
          });
        }
        segmentMultiPolygonGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r];
            for (let s = 0, l = o.length; s < l; ++s) {
              const u = o[s];
              for (let h = 0, c = u.length - 1; h < c; ++h) t.push(u.slice(h, h + 2));
            }
          }
        }
        segmentPointGeometry_(t, e) {
          t.push([e.getCoordinates()]);
        }
        segmentPolygonGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r];
            for (let s = 0, l = o.length - 1; s < l; ++s) t.push(o.slice(s, s + 2));
          }
        }
      }
      const Aw = 0.75, D0 = 0.1;
      class GJ extends x0 {
        constructor(t) {
          t = t || {}, super({ element: document.createElement("div"), render: t.render, target: t.target }), this.boundHandleRotationChanged_ = this.handleRotationChanged_.bind(this), this.collapsed_ = t.collapsed !== void 0 ? t.collapsed : true, this.collapsible_ = t.collapsible !== void 0 ? t.collapsible : true, this.collapsible_ || (this.collapsed_ = false), this.rotateWithView_ = t.rotateWithView !== void 0 ? t.rotateWithView : false, this.viewExtent_ = void 0;
          const e = t.className !== void 0 ? t.className : "ol-overviewmap", i = t.tipLabel !== void 0 ? t.tipLabel : "Overview map", r = t.collapseLabel !== void 0 ? t.collapseLabel : "";
          typeof r == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = r) : this.collapseLabel_ = r;
          const a = t.label !== void 0 ? t.label : "";
          typeof a == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = a) : this.label_ = a;
          const o = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_, s = document.createElement("button");
          s.setAttribute("type", "button"), s.title = i, s.appendChild(o), s.addEventListener(Nt.CLICK, this.handleClick_.bind(this), false), this.ovmapDiv_ = document.createElement("div"), this.ovmapDiv_.className = "ol-overviewmap-map", this.view_ = t.view;
          const l = new lw({ view: t.view, controls: new ir(), interactions: new ir() });
          this.ovmap_ = l, t.layers && t.layers.forEach(function(y) {
            l.addLayer(y);
          });
          const u = document.createElement("div");
          u.className = "ol-overviewmap-box", u.style.boxSizing = "border-box", this.boxOverlay_ = new kN({ position: [0, 0], positioning: "center-center", element: u }), this.ovmap_.addOverlay(this.boxOverlay_);
          const h = e + " " + Jd + " " + i0 + (this.collapsed_ && this.collapsible_ ? " " + r0 : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), c = this.element;
          c.className = h, c.appendChild(this.ovmapDiv_), c.appendChild(s);
          const f = this, g = this.boxOverlay_, d = this.boxOverlay_.getElement(), A = function(y) {
            return { clientX: y.clientX, clientY: y.clientY };
          }, p = function(y) {
            const m = A(y), _ = l.getEventCoordinate(m);
            g.setPosition(_);
          }, v = function(y) {
            const m = l.getEventCoordinateInternal(y);
            f.getMap().getView().setCenterInternal(m), window.removeEventListener("pointermove", p), window.removeEventListener("pointerup", v);
          };
          this.ovmapDiv_.addEventListener("pointerdown", function() {
            event.target === d && window.addEventListener("pointermove", p), window.addEventListener("pointerup", v);
          });
        }
        setMap(t) {
          const e = this.getMap();
          if (t !== e) {
            if (e) {
              const i = e.getView();
              i && this.unbindView_(i), this.ovmap_.setTarget(null);
            }
            if (super.setMap(t), t) {
              this.ovmap_.setTarget(this.ovmapDiv_), this.listenerKeys.push(ie(t, Un.PROPERTYCHANGE, this.handleMapPropertyChange_, this));
              const i = t.getView();
              i && this.bindView_(i), this.ovmap_.isRendered() || this.updateBoxAfterOvmapIsRendered_();
            }
          }
        }
        handleMapPropertyChange_(t) {
          if (t.key === qn.VIEW) {
            const e = t.oldValue;
            e && this.unbindView_(e);
            const i = this.getMap().getView();
            this.bindView_(i);
          } else !this.ovmap_.isRendered() && (t.key === qn.TARGET || t.key === qn.SIZE) && this.ovmap_.updateSize();
        }
        bindView_(t) {
          if (!this.view_) {
            const e = new La({ projection: t.getProjection() });
            this.ovmap_.setView(e);
          }
          t.addChangeListener(Dr.ROTATION, this.boundHandleRotationChanged_), this.handleRotationChanged_(), t.isDef() && (this.ovmap_.updateSize(), this.resetExtent_());
        }
        unbindView_(t) {
          t.removeChangeListener(Dr.ROTATION, this.boundHandleRotationChanged_);
        }
        handleRotationChanged_() {
          this.rotateWithView_ && this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
        }
        validateExtent_() {
          const t = this.getMap(), e = this.ovmap_;
          if (!t.isRendered() || !e.isRendered()) return;
          const i = t.getSize(), a = t.getView().calculateExtentInternal(i);
          if (this.viewExtent_ && al(a, this.viewExtent_)) return;
          this.viewExtent_ = a;
          const o = e.getSize(), l = e.getView().calculateExtentInternal(o), u = e.getPixelFromCoordinateInternal(Zr(a)), h = e.getPixelFromCoordinateInternal(Nc(a)), c = Math.abs(u[0] - h[0]), f = Math.abs(u[1] - h[1]), g = o[0], d = o[1];
          c < g * D0 || f < d * D0 || c > g * Aw || f > d * Aw ? this.resetExtent_() : br(l, a) || this.recenter_();
        }
        resetExtent_() {
          const t = this.getMap(), e = this.ovmap_, i = t.getSize(), a = t.getView().calculateExtentInternal(i), o = e.getView(), s = Math.log(Aw / D0) / Math.LN2, l = 1 / (Math.pow(2, s / 2) * D0);
          uZ(a, l), o.fitInternal(yx(a));
        }
        recenter_() {
          const t = this.getMap(), e = this.ovmap_, i = t.getView();
          e.getView().setCenterInternal(i.getCenterInternal());
        }
        updateBox_() {
          const t = this.getMap(), e = this.ovmap_;
          if (!t.isRendered() || !e.isRendered()) return;
          const i = t.getSize(), r = t.getView(), a = e.getView(), o = this.rotateWithView_ ? 0 : -r.getRotation(), s = this.boxOverlay_, l = this.boxOverlay_.getElement(), u = r.getCenter(), h = r.getResolution(), c = a.getResolution(), f = i[0] * h / c, g = i[1] * h / c;
          if (s.setPosition(u), l) {
            l.style.width = f + "px", l.style.height = g + "px";
            const d = "rotate(" + o + "rad)";
            l.style.transform = d;
          }
        }
        updateBoxAfterOvmapIsRendered_() {
          this.ovmapPostrenderKey_ || (this.ovmapPostrenderKey_ = kd(this.ovmap_, uo.POSTRENDER, (t) => {
            delete this.ovmapPostrenderKey_, this.updateBox_();
          }));
        }
        handleClick_(t) {
          t.preventDefault(), this.handleToggle_();
        }
        handleToggle_() {
          this.element.classList.toggle(r0), this.collapsed_ ? Jy(this.collapseLabel_, this.label_) : Jy(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_;
          const t = this.ovmap_;
          if (!this.collapsed_) {
            if (t.isRendered()) {
              this.viewExtent_ = void 0, t.render();
              return;
            }
            t.updateSize(), this.resetExtent_(), this.updateBoxAfterOvmapIsRendered_();
          }
        }
        getCollapsible() {
          return this.collapsible_;
        }
        setCollapsible(t) {
          this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle("ol-uncollapsible"), !t && this.collapsed_ && this.handleToggle_());
        }
        setCollapsed(t) {
          !this.collapsible_ || this.collapsed_ === t || this.handleToggle_();
        }
        getCollapsed() {
          return this.collapsed_;
        }
        getRotateWithView() {
          return this.rotateWithView_;
        }
        setRotateWithView(t) {
          this.rotateWithView_ !== t && (this.rotateWithView_ = t, this.getMap().getView().getRotation() !== 0 && (this.rotateWithView_ ? this.handleRotationChanged_() : this.ovmap_.getView().setRotation(0), this.viewExtent_ = void 0, this.validateExtent_(), this.updateBox_()));
        }
        getOverviewMap() {
          return this.ovmap_;
        }
        render(t) {
          this.validateExtent_(), this.updateBox_();
        }
      }
      const R0 = 6378137, WN = 85.0511287798, L0 = Math.PI / 180, bi = Math.PI, XN = 6378245, ZN = 0.006693421622965943, KN = [1289059486e-2, 836237787e-2, 5591021, 348198983e-2, 167804312e-2, 0], P0 = [75, 60, 45, 30, 15, 0], UJ = [[1410526172116255e-23, 898305509648872e-20, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 173379812e-1], [-7435856389565537e-24, 8983055097726239e-21, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 1026014486e-2], [-3030883460898826e-23, 898305509983578e-20, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 685681737e-2], [-1981981304930552e-23, 8983055099779535e-21, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 448277706e-2], [309191371068437e-23, 8983055096812155e-21, 6995724062e-14, 23.10934304144901, -23663490511e-14, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 25551644e-1], [2890871144776878e-24, 8983055095805407e-21, -3068298e-14, 7.47137025468032, -353937994e-14, -0.02145144861037, -1234426596e-14, 10322952773e-14, -323890364e-14, 826088.5]], $N = [[-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5], [8277824516172526e-19, 111320.7020463578, 6477955746671607e-7, -4082003173641316e-6, 1077490566351142e-5, -1517187553151559e-5, 1205306533862167e-5, -5124939663577472e-6, 9133119359512032e-7, 67.5], [0.00337398766765, 111320.7020202162, 4481351045890365e-9, -2339375119931662e-8, 7968221547186455e-8, -1159649932797253e-7, 9723671115602145e-8, -4366194633752821e-8, 8477230501135234e-9, 52.5], [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837749470245e-9, 992013.7397791013, -122195221711287e-8, 1340652697009075e-9, -620943.6990984312, 144416.9293806241, 37.5], [-3441963504368392e-19, 111320.7020576856, 278.2353980772752, 2485758690035394e-9, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-3218135878613132e-19, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]], N0 = bi * 3e3 / 180, _l = (n) => (e, i, r) => {
        const a = e.length, o = r || 2;
        let s;
        i ? s = i : o !== 2 ? s = e.slice() : s = new Array(a);
        for (let l = 0; l < a; l += o) n(e, s, l);
        return s;
      }, JN = (n, t) => n < 72.004 || n > 137.8347 || t < 0.8293 || t > 55.8271, tk = (n, t) => {
        let e = VJ(n - 105, t - 35), i = jJ(n - 105, t - 35);
        const r = t / 180 * bi;
        let a = Math.sin(r);
        a = 1 - ZN * a * a;
        const o = Math.sqrt(a);
        return e = e * 180 / (XN * (1 - ZN) / (a * o) * bi), i = i * 180 / (XN / o * Math.cos(r) * bi), [i, e];
      }, VJ = (n, t) => {
        let e = -100 + 2 * n + 3 * t + 0.2 * t * t + 0.1 * n * t + 0.2 * Math.sqrt(Math.abs(n));
        return e += (20 * Math.sin(6 * n * bi) + 20 * Math.sin(2 * n * bi)) * 2 / 3, e += (20 * Math.sin(t * bi) + 40 * Math.sin(t / 3 * bi)) * 2 / 3, e += (160 * Math.sin(t / 12 * bi) + 320 * Math.sin(t * bi / 30)) * 2 / 3, e;
      }, jJ = (n, t) => {
        let e = 300 + n + 2 * t + 0.1 * n * n + 0.1 * n * t + 0.1 * Math.sqrt(Math.abs(n));
        return e += (20 * Math.sin(6 * n * bi) + 20 * Math.sin(2 * n * bi)) * 2 / 3, e += (20 * Math.sin(n * bi) + 40 * Math.sin(n / 3 * bi)) * 2 / 3, e += (150 * Math.sin(n / 12 * bi) + 300 * Math.sin(n / 30 * bi)) * 2 / 3, e;
      }, qJ = (n, t, e) => (n = Math.max(n, t), n = Math.min(n, e), n), HJ = (n, t, e) => {
        const i = e - t;
        for (; n > e; ) n -= i;
        for (; n < t; ) n += i;
        return n;
      }, ek = (n, t, e, i) => {
        const r = n[e], a = n[e + 1], o = i[0] + i[1] * Math.abs(r), s = Math.abs(a) / i[9], l = i[2] + i[3] * s + i[4] * s * s + i[5] * s * s * s + i[6] * s * s * s * s + i[7] * s * s * s * s * s + i[8] * s * s * s * s * s * s;
        t[e] = o * (r < 0 ? -1 : 1), t[e + 1] = l * (a < 0 ? -1 : 1);
      }, YJ = (n, t, e) => {
        const i = n[e] - 65e-4, r = n[e + 1] - 6e-3, a = Math.sqrt(i * i + r * r) - 2e-5 * Math.sin(r * N0), o = Math.atan2(r, i) - 3e-6 * Math.cos(i * N0);
        return t[e] = a * Math.cos(o), t[e + 1] = a * Math.sin(o), t;
      }, WJ = (n, t, e) => {
        const i = n[e], r = n[e + 1], a = Math.sqrt(i * i + r * r) + 2e-5 * Math.sin(r * N0), o = Math.atan2(r, i) + 3e-6 * Math.cos(i * N0);
        return t[e] = a * Math.cos(o) + 65e-4, t[e + 1] = a * Math.sin(o) + 6e-3, t;
      }, ho = { forward: _l((n, t, e) => {
        const i = Math.max(Math.min(WN, n[e + 1]), -WN), r = Math.sin(i * L0);
        t[e] = R0 * n[e] * L0, t[e + 1] = R0 * Math.log((1 + r) / (1 - r)) / 2;
      }), inverse: _l((n, t, e) => {
        t[e] = n[e] / R0 / L0, t[e + 1] = (2 * Math.atan(Math.exp(n[e + 1] / R0)) - Math.PI / 2) / L0;
      }) }, Il = { toWGS84: _l((n, t, e) => {
        let i = n[e], r = n[e + 1];
        if (!JN(i, r)) {
          const a = tk(i, r);
          i = i - a[0], r = r - a[1];
        }
        t[e] = i, t[e + 1] = r;
      }), fromWGS84: _l((n, t, e) => {
        let i = n[e], r = n[e + 1];
        if (!JN(i, r)) {
          const a = tk(i, r);
          i = i + a[0], r = r + a[1];
        }
        t[e] = i, t[e + 1] = r;
      }) }, cf = { forward: _l((n, t, e) => {
        const i = HJ(n[e], -180, 180), r = qJ(n[e + 1], -74, 74);
        let a = null, o;
        for (o = 0; o < P0.length; ++o) if (r >= P0[o]) {
          a = $N[o];
          break;
        }
        if (a === null) {
          for (o = P0.length - 1; o >= 0; --o) if (r <= -P0[o]) {
            a = $N[o];
            break;
          }
        }
        t[e] = i, t[e + 1] = r, ek(t, t, e, a);
      }), inverse: _l((n, t, e) => {
        const i = Math.abs(n[e + 1]);
        let r = null;
        for (let a = 0; a < KN.length; a++) if (i >= KN[a]) {
          r = UJ[a];
          break;
        }
        ek(n, t, e, r);
      }) }, ff = { toWGS84: (n, t, e) => {
        const i = _l(YJ)(n, t, e);
        return Il.toWGS84(i, i, e);
      }, fromWGS84: (n, t, e) => {
        const i = Il.fromWGS84(n, t, e);
        return _l(WJ)(i, i, e);
      } }, nk = (n, t, e) => {
        let i = ho.inverse(n, t, e);
        return i = ff.fromWGS84(i, i, e), cf.forward(i, i, e);
      }, ik = (n, t, e) => {
        let i = cf.inverse(n, t, e);
        return i = ff.toWGS84(i, i, e), ho.forward(i, i, e);
      }, XJ = (n, t, e) => {
        const i = cf.inverse(n, t, e);
        return ff.toWGS84(i, i, e);
      }, ZJ = (n, t, e) => {
        const i = ff.fromWGS84(n, t, e);
        return cf.forward(i, i, e);
      }, rk = (n, t, e) => {
        let i = cf.inverse(n, t, e);
        return i = ff.toWGS84(i, i, e), i = Il.fromWGS84(i, i, e), ho.forward(i, i, e);
      }, ak = (n, t, e) => {
        let i = ho.inverse(n, t, e);
        return i = Il.fromWGS84(i, i, e), ho.forward(i, i, e);
      }, ok = (n, t, e) => {
        let i = ho.inverse(n, t, e);
        return i = Il.toWGS84(i, i, e), ho.forward(i, i, e);
      }, KJ = (n, t, e) => {
        const i = ho.inverse(n, t, e);
        return Il.toWGS84(i, i, e);
      }, $J = (n, t, e) => {
        const i = Il.fromWGS84(n, t, e);
        return ho.forward(i, i, e);
      }, sk = (n, t, e) => {
        let i = ho.inverse(n, t, e);
        return i = Il.toWGS84(i, i, e), i = ff.fromWGS84(i, i, e), cf.forward(i, i, e);
      };
      function JJ(n) {
        n("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), n("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), n("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
        for (var t = 0; t <= 60; ++t) n("EPSG:" + (32600 + t), "+proj=utm +zone=" + t + " +datum=WGS84 +units=m"), n("EPSG:" + (32700 + t), "+proj=utm +zone=" + t + " +south +datum=WGS84 +units=m");
        n.WGS84 = n["EPSG:4326"], n["EPSG:3785"] = n["EPSG:3857"], n.GOOGLE = n["EPSG:3857"], n["EPSG:900913"] = n["EPSG:3857"], n["EPSG:102113"] = n["EPSG:3857"];
      }
      var Ou = 1, zu = 2, gf = 3, ttt = 4, pw = 5, lk = 6378137, ett = 6356752314e-3, uk = 0.0066943799901413165, mA = 484813681109536e-20, ut = Math.PI / 2, ntt = 0.16666666666666666, itt = 0.04722222222222222, rtt = 0.022156084656084655, pt = 1e-10, fi = 0.017453292519943295, El = 57.29577951308232, He = Math.PI / 4, _A = Math.PI * 2, Bn = 3.14159265359, lr = {};
      lr.greenwich = 0, lr.lisbon = -9.131906111111, lr.paris = 2.337229166667, lr.bogota = -74.080916666667, lr.madrid = -3.687938888889, lr.rome = 12.452333333333, lr.bern = 7.439583333333, lr.jakarta = 106.807719444444, lr.ferro = -17.666666666667, lr.brussels = 4.367975, lr.stockholm = 18.058277777778, lr.athens = 23.7163375, lr.oslo = 10.722916666667;
      const att = { mm: { to_meter: 1e-3 }, cm: { to_meter: 0.01 }, ft: { to_meter: 0.3048 }, "us-ft": { to_meter: 1200 / 3937 }, fath: { to_meter: 1.8288 }, kmi: { to_meter: 1852 }, "us-ch": { to_meter: 20.1168402336805 }, "us-mi": { to_meter: 1609.34721869444 }, km: { to_meter: 1e3 }, "ind-ft": { to_meter: 0.30479841 }, "ind-yd": { to_meter: 0.91439523 }, mi: { to_meter: 1609.344 }, yd: { to_meter: 0.9144 }, ch: { to_meter: 20.1168 }, link: { to_meter: 0.201168 }, dm: { to_meter: 0.01 }, in: { to_meter: 0.0254 }, "ind-ch": { to_meter: 20.11669506 }, "us-in": { to_meter: 0.025400050800101 }, "us-yd": { to_meter: 0.914401828803658 } };
      var hk = /[\s_\-\/\(\)]/g;
      function xl(n, t) {
        if (n[t]) return n[t];
        for (var e = Object.keys(n), i = t.toLowerCase().replace(hk, ""), r = -1, a, o; ++r < e.length; ) if (a = e[r], o = a.toLowerCase().replace(hk, ""), o === i) return n[a];
      }
      function vw(n) {
        var t = {}, e = n.split("+").map(function(s) {
          return s.trim();
        }).filter(function(s) {
          return s;
        }).reduce(function(s, l) {
          var u = l.split("=");
          return u.push(true), s[u[0].toLowerCase()] = u[1], s;
        }, {}), i, r, a, o = { proj: "projName", datum: "datumCode", rf: function(s) {
          t.rf = parseFloat(s);
        }, lat_0: function(s) {
          t.lat0 = s * fi;
        }, lat_1: function(s) {
          t.lat1 = s * fi;
        }, lat_2: function(s) {
          t.lat2 = s * fi;
        }, lat_ts: function(s) {
          t.lat_ts = s * fi;
        }, lon_0: function(s) {
          t.long0 = s * fi;
        }, lon_1: function(s) {
          t.long1 = s * fi;
        }, lon_2: function(s) {
          t.long2 = s * fi;
        }, alpha: function(s) {
          t.alpha = parseFloat(s) * fi;
        }, gamma: function(s) {
          t.rectified_grid_angle = parseFloat(s);
        }, lonc: function(s) {
          t.longc = s * fi;
        }, x_0: function(s) {
          t.x0 = parseFloat(s);
        }, y_0: function(s) {
          t.y0 = parseFloat(s);
        }, k_0: function(s) {
          t.k0 = parseFloat(s);
        }, k: function(s) {
          t.k0 = parseFloat(s);
        }, a: function(s) {
          t.a = parseFloat(s);
        }, b: function(s) {
          t.b = parseFloat(s);
        }, r: function(s) {
          t.a = t.b = parseFloat(s);
        }, r_a: function() {
          t.R_A = true;
        }, zone: function(s) {
          t.zone = parseInt(s, 10);
        }, south: function() {
          t.utmSouth = true;
        }, towgs84: function(s) {
          t.datum_params = s.split(",").map(function(l) {
            return parseFloat(l);
          });
        }, to_meter: function(s) {
          t.to_meter = parseFloat(s);
        }, units: function(s) {
          t.units = s;
          var l = xl(att, s);
          l && (t.to_meter = l.to_meter);
        }, from_greenwich: function(s) {
          t.from_greenwich = s * fi;
        }, pm: function(s) {
          var l = xl(lr, s);
          t.from_greenwich = (l || parseFloat(s)) * fi;
        }, nadgrids: function(s) {
          s === "@null" ? t.datumCode = "none" : t.nadgrids = s;
        }, axis: function(s) {
          var l = "ewnsud";
          s.length === 3 && l.indexOf(s.substr(0, 1)) !== -1 && l.indexOf(s.substr(1, 1)) !== -1 && l.indexOf(s.substr(2, 1)) !== -1 && (t.axis = s);
        }, approx: function() {
          t.approx = true;
        } };
        for (i in e) r = e[i], i in o ? (a = o[i], typeof a == "function" ? a(r) : t[a] = r) : t[i] = r;
        return typeof t.datumCode == "string" && t.datumCode !== "WGS84" && (t.datumCode = t.datumCode.toLowerCase()), t;
      }
      var IA = 1, ck = 2, fk = 3, k0 = 4, gk = 5, yw = -1, ott = /\s/, stt = /[A-Za-z]/, ltt = /[A-Za-z84_]/, F0 = /[,\]]/, dk = /[\d\.E\-\+]/;
      function ps(n) {
        if (typeof n != "string") throw new Error("not a string");
        this.text = n.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = IA;
      }
      ps.prototype.readCharicter = function() {
        var n = this.text[this.place++];
        if (this.state !== k0) for (; ott.test(n); ) {
          if (this.place >= this.text.length) return;
          n = this.text[this.place++];
        }
        switch (this.state) {
          case IA:
            return this.neutral(n);
          case ck:
            return this.keyword(n);
          case k0:
            return this.quoted(n);
          case gk:
            return this.afterquote(n);
          case fk:
            return this.number(n);
          case yw:
            return;
        }
      }, ps.prototype.afterquote = function(n) {
        if (n === '"') {
          this.word += '"', this.state = k0;
          return;
        }
        if (F0.test(n)) {
          this.word = this.word.trim(), this.afterItem(n);
          return;
        }
        throw new Error(`havn't handled "` + n + '" in afterquote yet, index ' + this.place);
      }, ps.prototype.afterItem = function(n) {
        if (n === ",") {
          this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = IA;
          return;
        }
        if (n === "]") {
          this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = IA, this.currentObject = this.stack.pop(), this.currentObject || (this.state = yw);
          return;
        }
      }, ps.prototype.number = function(n) {
        if (dk.test(n)) {
          this.word += n;
          return;
        }
        if (F0.test(n)) {
          this.word = parseFloat(this.word), this.afterItem(n);
          return;
        }
        throw new Error(`havn't handled "` + n + '" in number yet, index ' + this.place);
      }, ps.prototype.quoted = function(n) {
        if (n === '"') {
          this.state = gk;
          return;
        }
        this.word += n;
      }, ps.prototype.keyword = function(n) {
        if (ltt.test(n)) {
          this.word += n;
          return;
        }
        if (n === "[") {
          var t = [];
          t.push(this.word), this.level++, this.root === null ? this.root = t : this.currentObject.push(t), this.stack.push(this.currentObject), this.currentObject = t, this.state = IA;
          return;
        }
        if (F0.test(n)) {
          this.afterItem(n);
          return;
        }
        throw new Error(`havn't handled "` + n + '" in keyword yet, index ' + this.place);
      }, ps.prototype.neutral = function(n) {
        if (stt.test(n)) {
          this.word = n, this.state = ck;
          return;
        }
        if (n === '"') {
          this.word = "", this.state = k0;
          return;
        }
        if (dk.test(n)) {
          this.word = n, this.state = fk;
          return;
        }
        if (F0.test(n)) {
          this.afterItem(n);
          return;
        }
        throw new Error(`havn't handled "` + n + '" in neutral yet, index ' + this.place);
      }, ps.prototype.output = function() {
        for (; this.place < this.text.length; ) this.readCharicter();
        if (this.state === yw) return this.root;
        throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
      };
      function utt(n) {
        var t = new ps(n);
        return t.output();
      }
      function mw(n, t, e) {
        Array.isArray(t) && (e.unshift(t), t = null);
        var i = t ? {} : n, r = e.reduce(function(a, o) {
          return df(o, a), a;
        }, i);
        t && (n[t] = r);
      }
      function df(n, t) {
        if (!Array.isArray(n)) {
          t[n] = true;
          return;
        }
        var e = n.shift();
        if (e === "PARAMETER" && (e = n.shift()), n.length === 1) {
          if (Array.isArray(n[0])) {
            t[e] = {}, df(n[0], t[e]);
            return;
          }
          t[e] = n[0];
          return;
        }
        if (!n.length) {
          t[e] = true;
          return;
        }
        if (e === "TOWGS84") {
          t[e] = n;
          return;
        }
        if (e === "AXIS") {
          e in t || (t[e] = []), t[e].push(n);
          return;
        }
        Array.isArray(e) || (t[e] = {});
        var i;
        switch (e) {
          case "UNIT":
          case "PRIMEM":
          case "VERT_DATUM":
            t[e] = { name: n[0].toLowerCase(), convert: n[1] }, n.length === 3 && df(n[2], t[e]);
            return;
          case "SPHEROID":
          case "ELLIPSOID":
            t[e] = { name: n[0], a: n[1], rf: n[2] }, n.length === 4 && df(n[3], t[e]);
            return;
          case "EDATUM":
          case "ENGINEERINGDATUM":
          case "LOCAL_DATUM":
          case "DATUM":
          case "VERT_CS":
          case "VERTCRS":
          case "VERTICALCRS":
            n[0] = ["name", n[0]], mw(t, e, n);
            return;
          case "COMPD_CS":
          case "COMPOUNDCRS":
          case "FITTED_CS":
          case "PROJECTEDCRS":
          case "PROJCRS":
          case "GEOGCS":
          case "GEOCCS":
          case "PROJCS":
          case "LOCAL_CS":
          case "GEODCRS":
          case "GEODETICCRS":
          case "GEODETICDATUM":
          case "ENGCRS":
          case "ENGINEERINGCRS":
            n[0] = ["name", n[0]], mw(t, e, n), t[e].type = e;
            return;
          default:
            for (i = -1; ++i < n.length; ) if (!Array.isArray(n[i])) return df(n, t[e]);
            return mw(t, e, n);
        }
      }
      var htt = 0.017453292519943295, ctt = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
      function ftt(n, t) {
        var e = t[0], i = t[1];
        !(e in n) && i in n && (n[e] = n[i], t.length === 3 && (n[e] = t[2](n[e])));
      }
      function co(n) {
        return n * htt;
      }
      function Ak(n) {
        for (var t = Object.keys(n), e = 0, i = t.length; e < i; ++e) {
          var r = t[e];
          ctt.indexOf(r) !== -1 && gtt(n[r]), typeof n[r] == "object" && Ak(n[r]);
        }
      }
      function gtt(n) {
        if (n.AUTHORITY) {
          var t = Object.keys(n.AUTHORITY)[0];
          t && t in n.AUTHORITY && (n.title = t + ":" + n.AUTHORITY[t]);
        }
        if (n.type === "GEOGCS" ? n.projName = "longlat" : n.type === "LOCAL_CS" ? (n.projName = "identity", n.local = true) : typeof n.PROJECTION == "object" ? n.projName = Object.keys(n.PROJECTION)[0] : n.projName = n.PROJECTION, n.AXIS) {
          for (var e = "", i = 0, r = n.AXIS.length; i < r; ++i) {
            var a = [n.AXIS[i][0].toLowerCase(), n.AXIS[i][1].toLowerCase()];
            a[0].indexOf("north") !== -1 || (a[0] === "y" || a[0] === "lat") && a[1] === "north" ? e += "n" : a[0].indexOf("south") !== -1 || (a[0] === "y" || a[0] === "lat") && a[1] === "south" ? e += "s" : a[0].indexOf("east") !== -1 || (a[0] === "x" || a[0] === "lon") && a[1] === "east" ? e += "e" : (a[0].indexOf("west") !== -1 || (a[0] === "x" || a[0] === "lon") && a[1] === "west") && (e += "w");
          }
          e.length === 2 && (e += "u"), e.length === 3 && (n.axis = e);
        }
        n.UNIT && (n.units = n.UNIT.name.toLowerCase(), n.units === "metre" && (n.units = "meter"), n.UNIT.convert && (n.type === "GEOGCS" ? n.DATUM && n.DATUM.SPHEROID && (n.to_meter = n.UNIT.convert * n.DATUM.SPHEROID.a) : n.to_meter = n.UNIT.convert));
        var o = n.GEOGCS;
        n.type === "GEOGCS" && (o = n), o && (o.DATUM ? n.datumCode = o.DATUM.name.toLowerCase() : n.datumCode = o.name.toLowerCase(), n.datumCode.slice(0, 2) === "d_" && (n.datumCode = n.datumCode.slice(2)), n.datumCode === "new_zealand_1949" && (n.datumCode = "nzgd49"), (n.datumCode === "wgs_1984" || n.datumCode === "world_geodetic_system_1984") && (n.PROJECTION === "Mercator_Auxiliary_Sphere" && (n.sphere = true), n.datumCode = "wgs84"), n.datumCode === "belge_1972" && (n.datumCode = "rnb72"), o.DATUM && o.DATUM.SPHEROID && (n.ellps = o.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), n.ellps.toLowerCase().slice(0, 13) === "international" && (n.ellps = "intl"), n.a = o.DATUM.SPHEROID.a, n.rf = parseFloat(o.DATUM.SPHEROID.rf, 10)), o.DATUM && o.DATUM.TOWGS84 && (n.datum_params = o.DATUM.TOWGS84), ~n.datumCode.indexOf("osgb_1936") && (n.datumCode = "osgb36"), ~n.datumCode.indexOf("osni_1952") && (n.datumCode = "osni52"), (~n.datumCode.indexOf("tm65") || ~n.datumCode.indexOf("geodetic_datum_of_1965")) && (n.datumCode = "ire65"), n.datumCode === "ch1903+" && (n.datumCode = "ch1903"), ~n.datumCode.indexOf("israel") && (n.datumCode = "isr93")), n.b && !isFinite(n.b) && (n.b = n.a);
        function s(h) {
          var c = n.to_meter || 1;
          return h * c;
        }
        var l = function(h) {
          return ftt(n, h);
        }, u = [["standard_parallel_1", "Standard_Parallel_1"], ["standard_parallel_1", "Latitude of 1st standard parallel"], ["standard_parallel_2", "Standard_Parallel_2"], ["standard_parallel_2", "Latitude of 2nd standard parallel"], ["false_easting", "False_Easting"], ["false_easting", "False easting"], ["false-easting", "Easting at false origin"], ["false_northing", "False_Northing"], ["false_northing", "False northing"], ["false_northing", "Northing at false origin"], ["central_meridian", "Central_Meridian"], ["central_meridian", "Longitude of natural origin"], ["central_meridian", "Longitude of false origin"], ["latitude_of_origin", "Latitude_Of_Origin"], ["latitude_of_origin", "Central_Parallel"], ["latitude_of_origin", "Latitude of natural origin"], ["latitude_of_origin", "Latitude of false origin"], ["scale_factor", "Scale_Factor"], ["k0", "scale_factor"], ["latitude_of_center", "Latitude_Of_Center"], ["latitude_of_center", "Latitude_of_center"], ["lat0", "latitude_of_center", co], ["longitude_of_center", "Longitude_Of_Center"], ["longitude_of_center", "Longitude_of_center"], ["longc", "longitude_of_center", co], ["x0", "false_easting", s], ["y0", "false_northing", s], ["long0", "central_meridian", co], ["lat0", "latitude_of_origin", co], ["lat0", "standard_parallel_1", co], ["lat1", "standard_parallel_1", co], ["lat2", "standard_parallel_2", co], ["azimuth", "Azimuth"], ["alpha", "azimuth", co], ["srsCode", "name"]];
        u.forEach(l), !n.long0 && n.longc && (n.projName === "Albers_Conic_Equal_Area" || n.projName === "Lambert_Azimuthal_Equal_Area") && (n.long0 = n.longc), !n.lat_ts && n.lat1 && (n.projName === "Stereographic_South_Pole" || n.projName === "Polar Stereographic (variant B)") ? (n.lat0 = co(n.lat1 > 0 ? 90 : -90), n.lat_ts = n.lat1) : !n.lat_ts && n.lat0 && n.projName === "Polar_Stereographic" && (n.lat_ts = n.lat0, n.lat0 = co(n.lat0 > 0 ? 90 : -90));
      }
      function pk(n) {
        var t = utt(n), e = t[0], i = {};
        return df(t, i), Ak(i), i[e];
      }
      function Fi(n) {
        var t = this;
        if (arguments.length === 2) {
          var e = arguments[1];
          typeof e == "string" ? e.charAt(0) === "+" ? Fi[n] = vw(arguments[1]) : Fi[n] = pk(arguments[1]) : Fi[n] = e;
        } else if (arguments.length === 1) {
          if (Array.isArray(n)) return n.map(function(i) {
            Array.isArray(i) ? Fi.apply(t, i) : Fi(i);
          });
          if (typeof n == "string") {
            if (n in Fi) return Fi[n];
          } else "EPSG" in n ? Fi["EPSG:" + n.EPSG] = n : "ESRI" in n ? Fi["ESRI:" + n.ESRI] = n : "IAU2000" in n && (Fi["IAU2000:" + n.IAU2000] = n);
          return;
        }
      }
      JJ(Fi);
      function dtt(n) {
        return typeof n == "string";
      }
      function Att(n) {
        return n in Fi;
      }
      var ptt = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
      function vtt(n) {
        return ptt.some(function(t) {
          return n.indexOf(t) > -1;
        });
      }
      var ytt = ["3857", "900913", "3785", "102113"];
      function mtt(n) {
        var t = xl(n, "authority");
        if (t) {
          var e = xl(t, "epsg");
          return e && ytt.indexOf(e) > -1;
        }
      }
      function _tt(n) {
        var t = xl(n, "extension");
        if (t) return xl(t, "proj4");
      }
      function Itt(n) {
        return n[0] === "+";
      }
      function Ett(n) {
        if (dtt(n)) {
          if (Att(n)) return Fi[n];
          if (vtt(n)) {
            var t = pk(n);
            if (mtt(t)) return Fi["EPSG:3857"];
            var e = _tt(t);
            return e ? vw(e) : t;
          }
          if (Itt(n)) return vw(n);
        } else return n;
      }
      function vk(n, t) {
        n = n || {};
        var e, i;
        if (!t) return n;
        for (i in t) e = t[i], e !== void 0 && (n[i] = e);
        return n;
      }
      function fo(n, t, e) {
        var i = n * t;
        return e / Math.sqrt(1 - i * i);
      }
      function EA(n) {
        return n < 0 ? -1 : 1;
      }
      function mt(n) {
        return Math.abs(n) <= Bn ? n : n - EA(n) * _A;
      }
      function Na(n, t, e) {
        var i = n * e, r = 0.5 * n;
        return i = Math.pow((1 - i) / (1 + i), r), Math.tan(0.5 * (ut - t)) / i;
      }
      function xA(n, t) {
        for (var e = 0.5 * n, i, r, a = ut - 2 * Math.atan(t), o = 0; o <= 15; o++) if (i = n * Math.sin(a), r = ut - 2 * Math.atan(t * Math.pow((1 - i) / (1 + i), e)) - a, a += r, Math.abs(r) <= 1e-10) return a;
        return -9999;
      }
      function xtt() {
        var n = this.b / this.a;
        this.es = 1 - n * n, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = fo(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
      }
      function wtt(n) {
        var t = n.x, e = n.y;
        if (e * El > 90 && e * El < -90 && t * El > 180 && t * El < -180) return null;
        var i, r;
        if (Math.abs(Math.abs(e) - ut) <= pt) return null;
        if (this.sphere) i = this.x0 + this.a * this.k0 * mt(t - this.long0), r = this.y0 + this.a * this.k0 * Math.log(Math.tan(He + 0.5 * e));
        else {
          var a = Math.sin(e), o = Na(this.e, e, a);
          i = this.x0 + this.a * this.k0 * mt(t - this.long0), r = this.y0 - this.a * this.k0 * Math.log(o);
        }
        return n.x = i, n.y = r, n;
      }
      function Ctt(n) {
        var t = n.x - this.x0, e = n.y - this.y0, i, r;
        if (this.sphere) r = ut - 2 * Math.atan(Math.exp(-e / (this.a * this.k0)));
        else {
          var a = Math.exp(-e / (this.a * this.k0));
          if (r = xA(this.e, a), r === -9999) return null;
        }
        return i = mt(this.long0 + t / (this.a * this.k0)), n.x = i, n.y = r, n;
      }
      var Stt = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
      const btt = { init: xtt, forward: wtt, inverse: Ctt, names: Stt };
      function Btt() {
      }
      function yk(n) {
        return n;
      }
      var Ttt = ["longlat", "identity"], Mtt = [btt, { init: Btt, forward: yk, inverse: yk, names: Ttt }], Q0 = {}, O0 = [];
      function mk(n, t) {
        var e = O0.length;
        return n.names ? (O0[e] = n, n.names.forEach(function(i) {
          Q0[i.toLowerCase()] = e;
        }), this) : true;
      }
      function Dtt(n) {
        if (!n) return false;
        var t = n.toLowerCase();
        if (typeof Q0[t] != "undefined" && O0[Q0[t]]) return O0[Q0[t]];
      }
      function Rtt() {
        Mtt.forEach(mk);
      }
      const Ltt = { start: Rtt, add: mk, get: Dtt };
      var ae = {};
      ae.MERIT = { a: 6378137, rf: 298.257, ellipseName: "MERIT 1983" }, ae.SGS85 = { a: 6378136, rf: 298.257, ellipseName: "Soviet Geodetic System 85" }, ae.GRS80 = { a: 6378137, rf: 298.257222101, ellipseName: "GRS 1980(IUGG, 1980)" }, ae.IAU76 = { a: 6378140, rf: 298.257, ellipseName: "IAU 1976" }, ae.airy = { a: 6377563396e-3, b: 635625691e-2, ellipseName: "Airy 1830" }, ae.APL4 = { a: 6378137, rf: 298.25, ellipseName: "Appl. Physics. 1965" }, ae.NWL9D = { a: 6378145, rf: 298.25, ellipseName: "Naval Weapons Lab., 1965" }, ae.mod_airy = { a: 6377340189e-3, b: 6356034446e-3, ellipseName: "Modified Airy" }, ae.andrae = { a: 637710443e-2, rf: 300, ellipseName: "Andrae 1876 (Den., Iclnd.)" }, ae.aust_SA = { a: 6378160, rf: 298.25, ellipseName: "Australian Natl & S. Amer. 1969" }, ae.GRS67 = { a: 6378160, rf: 298.247167427, ellipseName: "GRS 67(IUGG 1967)" }, ae.bessel = { a: 6377397155e-3, rf: 299.1528128, ellipseName: "Bessel 1841" }, ae.bess_nam = { a: 6377483865e-3, rf: 299.1528128, ellipseName: "Bessel 1841 (Namibia)" }, ae.clrk66 = { a: 63782064e-1, b: 63565838e-1, ellipseName: "Clarke 1866" }, ae.clrk80 = { a: 6378249145e-3, rf: 293.4663, ellipseName: "Clarke 1880 mod." }, ae.clrk80ign = { a: 63782492e-1, b: 6356515, rf: 293.4660213, ellipseName: "Clarke 1880 (IGN)" }, ae.clrk58 = { a: 6378293645208759e-9, rf: 294.2606763692654, ellipseName: "Clarke 1858" }, ae.CPM = { a: 63757387e-1, rf: 334.29, ellipseName: "Comm. des Poids et Mesures 1799" }, ae.delmbr = { a: 6376428, rf: 311.5, ellipseName: "Delambre 1810 (Belgium)" }, ae.engelis = { a: 637813605e-2, rf: 298.2566, ellipseName: "Engelis 1985" }, ae.evrst30 = { a: 6377276345e-3, rf: 300.8017, ellipseName: "Everest 1830" }, ae.evrst48 = { a: 6377304063e-3, rf: 300.8017, ellipseName: "Everest 1948" }, ae.evrst56 = { a: 6377301243e-3, rf: 300.8017, ellipseName: "Everest 1956" }, ae.evrst69 = { a: 6377295664e-3, rf: 300.8017, ellipseName: "Everest 1969" }, ae.evrstSS = { a: 6377298556e-3, rf: 300.8017, ellipseName: "Everest (Sabah & Sarawak)" }, ae.fschr60 = { a: 6378166, rf: 298.3, ellipseName: "Fischer (Mercury Datum) 1960" }, ae.fschr60m = { a: 6378155, rf: 298.3, ellipseName: "Fischer 1960" }, ae.fschr68 = { a: 6378150, rf: 298.3, ellipseName: "Fischer 1968" }, ae.helmert = { a: 6378200, rf: 298.3, ellipseName: "Helmert 1906" }, ae.hough = { a: 6378270, rf: 297, ellipseName: "Hough" }, ae.intl = { a: 6378388, rf: 297, ellipseName: "International 1909 (Hayford)" }, ae.kaula = { a: 6378163, rf: 298.24, ellipseName: "Kaula 1961" }, ae.lerch = { a: 6378139, rf: 298.257, ellipseName: "Lerch 1979" }, ae.mprts = { a: 6397300, rf: 191, ellipseName: "Maupertius 1738" }, ae.new_intl = { a: 63781575e-1, b: 63567722e-1, ellipseName: "New International 1967" }, ae.plessis = { a: 6376523, rf: 6355863, ellipseName: "Plessis 1817 (France)" }, ae.krass = { a: 6378245, rf: 298.3, ellipseName: "Krassovsky, 1942" }, ae.SEasia = { a: 6378155, b: 63567733205e-4, ellipseName: "Southeast Asia" }, ae.walbeck = { a: 6376896, b: 63558348467e-4, ellipseName: "Walbeck" }, ae.WGS60 = { a: 6378165, rf: 298.3, ellipseName: "WGS 60" }, ae.WGS66 = { a: 6378145, rf: 298.25, ellipseName: "WGS 66" }, ae.WGS7 = { a: 6378135, rf: 298.26, ellipseName: "WGS 72" };
      var Ptt = ae.WGS84 = { a: 6378137, rf: 298.257223563, ellipseName: "WGS 84" };
      ae.sphere = { a: 6370997, b: 6370997, ellipseName: "Normal Sphere (r=6370997)" };
      function Ntt(n, t, e, i) {
        var r = n * n, a = t * t, o = (r - a) / r, s = 0;
        i ? (n *= 1 - o * (ntt + o * (itt + o * rtt)), r = n * n, o = 0) : s = Math.sqrt(o);
        var l = (r - a) / a;
        return { es: o, e: s, ep2: l };
      }
      function ktt(n, t, e, i, r) {
        if (!n) {
          var a = xl(ae, i);
          a || (a = Ptt), n = a.a, t = a.b, e = a.rf;
        }
        return e && !t && (t = (1 - 1 / e) * n), (e === 0 || Math.abs(n - t) < pt) && (r = true, t = n), { a: n, b: t, rf: e, sphere: r };
      }
      var z0 = { wgs84: { towgs84: "0,0,0", ellipse: "WGS84", datumName: "WGS84" }, ch1903: { towgs84: "674.374,15.056,405.346", ellipse: "bessel", datumName: "swiss" }, ggrs87: { towgs84: "-199.87,74.79,246.62", ellipse: "GRS80", datumName: "Greek_Geodetic_Reference_System_1987" }, nad83: { towgs84: "0,0,0", ellipse: "GRS80", datumName: "North_American_Datum_1983" }, nad27: { nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat", ellipse: "clrk66", datumName: "North_American_Datum_1927" }, potsdam: { towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7", ellipse: "bessel", datumName: "Potsdam Rauenberg 1950 DHDN" }, carthage: { towgs84: "-263.0,6.0,431.0", ellipse: "clark80", datumName: "Carthage 1934 Tunisia" }, hermannskogel: { towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232", ellipse: "bessel", datumName: "Hermannskogel" }, militargeographische_institut: { towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232", ellipse: "bessel", datumName: "Militar-Geographische Institut" }, osni52: { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "airy", datumName: "Irish National" }, ire65: { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "mod_airy", datumName: "Ireland 1965" }, rassadiran: { towgs84: "-133.63,-157.5,-158.62", ellipse: "intl", datumName: "Rassadiran" }, nzgd49: { towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993", ellipse: "intl", datumName: "New Zealand Geodetic Datum 1949" }, osgb36: { towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894", ellipse: "airy", datumName: "Ordnance Survey of Great Britain 1936" }, s_jtsk: { towgs84: "589,76,480", ellipse: "bessel", datumName: "S-JTSK (Ferro)" }, beduaram: { towgs84: "-106,-87,188", ellipse: "clrk80", datumName: "Beduaram" }, gunung_segara: { towgs84: "-403,684,41", ellipse: "bessel", datumName: "Gunung Segara Jakarta" }, rnb72: { towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1", ellipse: "intl", datumName: "Reseau National Belge 1972" } };
      for (var Ftt in z0) {
        var _k = z0[Ftt];
        z0[_k.datumName] = _k;
      }
      function Qtt(n, t, e, i, r, a, o) {
        var s = {};
        return n === void 0 || n === "none" ? s.datum_type = pw : s.datum_type = ttt, t && (s.datum_params = t.map(parseFloat), (s.datum_params[0] !== 0 || s.datum_params[1] !== 0 || s.datum_params[2] !== 0) && (s.datum_type = Ou), s.datum_params.length > 3 && (s.datum_params[3] !== 0 || s.datum_params[4] !== 0 || s.datum_params[5] !== 0 || s.datum_params[6] !== 0) && (s.datum_type = zu, s.datum_params[3] *= mA, s.datum_params[4] *= mA, s.datum_params[5] *= mA, s.datum_params[6] = s.datum_params[6] / 1e6 + 1)), o && (s.datum_type = gf, s.grids = o), s.a = e, s.b = i, s.es = r, s.ep2 = a, s;
      }
      var Ik = {};
      function Ott(n, t) {
        var e = new DataView(t), i = Utt(e), r = Vtt(e, i), a = jtt(e, r, i), o = { header: r, subgrids: a };
        return Ik[n] = o, o;
      }
      function ztt(n) {
        if (n === void 0) return null;
        var t = n.split(",");
        return t.map(Gtt);
      }
      function Gtt(n) {
        if (n.length === 0) return null;
        var t = n[0] === "@";
        return t && (n = n.slice(1)), n === "null" ? { name: "null", mandatory: !t, grid: null, isNull: true } : { name: n, mandatory: !t, grid: Ik[n] || null, isNull: false };
      }
      function Af(n) {
        return n / 3600 * Math.PI / 180;
      }
      function Utt(n) {
        var t = n.getInt32(8, false);
        return t === 11 ? false : (t = n.getInt32(8, true), true);
      }
      function Vtt(n, t) {
        return { nFields: n.getInt32(8, t), nSubgridFields: n.getInt32(24, t), nSubgrids: n.getInt32(40, t), shiftType: _w(n, 56, 64).trim(), fromSemiMajorAxis: n.getFloat64(120, t), fromSemiMinorAxis: n.getFloat64(136, t), toSemiMajorAxis: n.getFloat64(152, t), toSemiMinorAxis: n.getFloat64(168, t) };
      }
      function _w(n, t, e) {
        return String.fromCharCode.apply(null, new Uint8Array(n.buffer.slice(t, e)));
      }
      function jtt(n, t, e) {
        for (var i = 176, r = [], a = 0; a < t.nSubgrids; a++) {
          var o = Htt(n, i, e), s = Ytt(n, i, o, e), l = Math.round(1 + (o.upperLongitude - o.lowerLongitude) / o.longitudeInterval), u = Math.round(1 + (o.upperLatitude - o.lowerLatitude) / o.latitudeInterval);
          r.push({ ll: [Af(o.lowerLongitude), Af(o.lowerLatitude)], del: [Af(o.longitudeInterval), Af(o.latitudeInterval)], lim: [l, u], count: o.gridNodeCount, cvs: qtt(s) }), i += 176 + o.gridNodeCount * 16;
        }
        return r;
      }
      function qtt(n) {
        return n.map(function(t) {
          return [Af(t.longitudeShift), Af(t.latitudeShift)];
        });
      }
      function Htt(n, t, e) {
        return { name: _w(n, t + 8, t + 16).trim(), parent: _w(n, t + 24, t + 24 + 8).trim(), lowerLatitude: n.getFloat64(t + 72, e), upperLatitude: n.getFloat64(t + 88, e), lowerLongitude: n.getFloat64(t + 104, e), upperLongitude: n.getFloat64(t + 120, e), latitudeInterval: n.getFloat64(t + 136, e), longitudeInterval: n.getFloat64(t + 152, e), gridNodeCount: n.getInt32(t + 168, e) };
      }
      function Ytt(n, t, e, i) {
        for (var r = t + 176, a = 16, o = [], s = 0; s < e.gridNodeCount; s++) {
          var l = { latitudeShift: n.getFloat32(r + s * a, i), longitudeShift: n.getFloat32(r + s * a + 4, i), latitudeAccuracy: n.getFloat32(r + s * a + 8, i), longitudeAccuracy: n.getFloat32(r + s * a + 12, i) };
          o.push(l);
        }
        return o;
      }
      function go(n, t) {
        if (!(this instanceof go)) return new go(n);
        t = t || function(u) {
          if (u) throw u;
        };
        var e = Ett(n);
        if (typeof e != "object") {
          t("Could not parse to valid json: " + n);
          return;
        }
        var i = go.projections.get(e.projName);
        if (!i) {
          t("Could not get projection name from: " + n);
          return;
        }
        if (e.datumCode && e.datumCode !== "none") {
          var r = xl(z0, e.datumCode);
          r && (e.datum_params = e.datum_params || (r.towgs84 ? r.towgs84.split(",") : null), e.ellps = r.ellipse, e.datumName = r.datumName ? r.datumName : e.datumCode);
        }
        e.k0 = e.k0 || 1, e.axis = e.axis || "enu", e.ellps = e.ellps || "wgs84", e.lat1 = e.lat1 || e.lat0;
        var a = ktt(e.a, e.b, e.rf, e.ellps, e.sphere), o = Ntt(a.a, a.b, a.rf, e.R_A), s = ztt(e.nadgrids), l = e.datum || Qtt(e.datumCode, e.datum_params, a.a, a.b, o.es, o.ep2, s);
        vk(this, e), vk(this, i), this.a = a.a, this.b = a.b, this.rf = a.rf, this.sphere = a.sphere, this.es = o.es, this.e = o.e, this.ep2 = o.ep2, this.datum = l, this.init(), t(null, this);
      }
      go.projections = Ltt, go.projections.start();
      function Wtt(n, t) {
        return n.datum_type !== t.datum_type || n.a !== t.a || Math.abs(n.es - t.es) > 5e-11 ? false : n.datum_type === Ou ? n.datum_params[0] === t.datum_params[0] && n.datum_params[1] === t.datum_params[1] && n.datum_params[2] === t.datum_params[2] : n.datum_type === zu ? n.datum_params[0] === t.datum_params[0] && n.datum_params[1] === t.datum_params[1] && n.datum_params[2] === t.datum_params[2] && n.datum_params[3] === t.datum_params[3] && n.datum_params[4] === t.datum_params[4] && n.datum_params[5] === t.datum_params[5] && n.datum_params[6] === t.datum_params[6] : true;
      }
      function Ek(n, t, e) {
        var i = n.x, r = n.y, a = n.z ? n.z : 0, o, s, l, u;
        if (r < -ut && r > -1.001 * ut) r = -ut;
        else if (r > ut && r < 1.001 * ut) r = ut;
        else {
          if (r < -ut) return { x: -1 / 0, y: -1 / 0, z: n.z };
          if (r > ut) return { x: 1 / 0, y: 1 / 0, z: n.z };
        }
        return i > Math.PI && (i -= 2 * Math.PI), s = Math.sin(r), u = Math.cos(r), l = s * s, o = e / Math.sqrt(1 - t * l), { x: (o + a) * u * Math.cos(i), y: (o + a) * u * Math.sin(i), z: (o * (1 - t) + a) * s };
      }
      function xk(n, t, e, i) {
        var r = 1e-12, a = r * r, o = 30, s, l, u, h, c, f, g, d, A, p, v, y, m, _ = n.x, E = n.y, I = n.z ? n.z : 0, x, w, C;
        if (s = Math.sqrt(_ * _ + E * E), l = Math.sqrt(_ * _ + E * E + I * I), s / e < r) {
          if (x = 0, l / e < r) return w = ut, C = -i, { x: n.x, y: n.y, z: n.z };
        } else x = Math.atan2(E, _);
        u = I / l, h = s / l, c = 1 / Math.sqrt(1 - t * (2 - t) * h * h), d = h * (1 - t) * c, A = u * c, m = 0;
        do
          m++, g = e / Math.sqrt(1 - t * A * A), C = s * d + I * A - g * (1 - t * A * A), f = t * g / (g + C), c = 1 / Math.sqrt(1 - f * (2 - f) * h * h), p = h * (1 - f) * c, v = u * c, y = v * d - p * A, d = p, A = v;
        while (y * y > a && m < o);
        return w = Math.atan(v / Math.abs(p)), { x, y: w, z: C };
      }
      function Xtt(n, t, e) {
        if (t === Ou) return { x: n.x + e[0], y: n.y + e[1], z: n.z + e[2] };
        if (t === zu) {
          var i = e[0], r = e[1], a = e[2], o = e[3], s = e[4], l = e[5], u = e[6];
          return { x: u * (n.x - l * n.y + s * n.z) + i, y: u * (l * n.x + n.y - o * n.z) + r, z: u * (-s * n.x + o * n.y + n.z) + a };
        }
      }
      function Ztt(n, t, e) {
        if (t === Ou) return { x: n.x - e[0], y: n.y - e[1], z: n.z - e[2] };
        if (t === zu) {
          var i = e[0], r = e[1], a = e[2], o = e[3], s = e[4], l = e[5], u = e[6], h = (n.x - i) / u, c = (n.y - r) / u, f = (n.z - a) / u;
          return { x: h + l * c - s * f, y: -l * h + c + o * f, z: s * h - o * c + f };
        }
      }
      function G0(n) {
        return n === Ou || n === zu;
      }
      function Ktt(n, t, e) {
        if (Wtt(n, t) || n.datum_type === pw || t.datum_type === pw) return e;
        var i = n.a, r = n.es;
        if (n.datum_type === gf) {
          var a = wk(n, false, e);
          if (a !== 0) return;
          i = lk, r = uk;
        }
        var o = t.a, s = t.b, l = t.es;
        if (t.datum_type === gf && (o = lk, s = ett, l = uk), r === l && i === o && !G0(n.datum_type) && !G0(t.datum_type)) return e;
        if (e = Ek(e, r, i), G0(n.datum_type) && (e = Xtt(e, n.datum_type, n.datum_params)), G0(t.datum_type) && (e = Ztt(e, t.datum_type, t.datum_params)), e = xk(e, l, o, s), t.datum_type === gf) {
          var u = wk(t, true, e);
          if (u !== 0) return;
        }
        return e;
      }
      function wk(n, t, e) {
        if (n.grids === null || n.grids.length === 0) return -1;
        var i = { x: -e.x, y: e.y }, r = { x: Number.NaN, y: Number.NaN }, a = [];
        t: for (var o = 0; o < n.grids.length; o++) {
          var s = n.grids[o];
          if (a.push(s.name), s.isNull) {
            r = i;
            break;
          }
          if (s.mandatory, s.grid === null) {
            if (s.mandatory) return -1;
            continue;
          }
          for (var l = s.grid.subgrids, u = 0, h = l.length; u < h; u++) {
            var c = l[u], f = (Math.abs(c.del[1]) + Math.abs(c.del[0])) / 1e4, g = c.ll[0] - f, d = c.ll[1] - f, A = c.ll[0] + (c.lim[0] - 1) * c.del[0] + f, p = c.ll[1] + (c.lim[1] - 1) * c.del[1] + f;
            if (!(d > i.y || g > i.x || p < i.y || A < i.x) && (r = $tt(i, t, c), !isNaN(r.x))) break t;
          }
        }
        return isNaN(r.x) ? -1 : (e.x = -r.x, e.y = r.y, 0);
      }
      function $tt(n, t, e) {
        var i = { x: Number.NaN, y: Number.NaN };
        if (isNaN(n.x)) return i;
        var r = { x: n.x, y: n.y };
        r.x -= e.ll[0], r.y -= e.ll[1], r.x = mt(r.x - Math.PI) + Math.PI;
        var a = Ck(r, e);
        if (t) {
          if (isNaN(a.x)) return i;
          a.x = r.x - a.x, a.y = r.y - a.y;
          var o = 9, s = 1e-12, l, u;
          do {
            if (u = Ck(a, e), isNaN(u.x)) break;
            l = { x: r.x - (u.x + a.x), y: r.y - (u.y + a.y) }, a.x += l.x, a.y += l.y;
          } while (o-- && Math.abs(l.x) > s && Math.abs(l.y) > s);
          if (o < 0) return i;
          i.x = mt(a.x + e.ll[0]), i.y = a.y + e.ll[1];
        } else isNaN(a.x) || (i.x = n.x + a.x, i.y = n.y + a.y);
        return i;
      }
      function Ck(n, t) {
        var e = { x: n.x / t.del[0], y: n.y / t.del[1] }, i = { x: Math.floor(e.x), y: Math.floor(e.y) }, r = { x: e.x - 1 * i.x, y: e.y - 1 * i.y }, a = { x: Number.NaN, y: Number.NaN }, o;
        if (i.x < 0 || i.x >= t.lim[0] || i.y < 0 || i.y >= t.lim[1]) return a;
        o = i.y * t.lim[0] + i.x;
        var s = { x: t.cvs[o][0], y: t.cvs[o][1] };
        o++;
        var l = { x: t.cvs[o][0], y: t.cvs[o][1] };
        o += t.lim[0];
        var u = { x: t.cvs[o][0], y: t.cvs[o][1] };
        o--;
        var h = { x: t.cvs[o][0], y: t.cvs[o][1] }, c = r.x * r.y, f = r.x * (1 - r.y), g = (1 - r.x) * (1 - r.y), d = (1 - r.x) * r.y;
        return a.x = g * s.x + f * l.x + d * h.x + c * u.x, a.y = g * s.y + f * l.y + d * h.y + c * u.y, a;
      }
      function Sk(n, t, e) {
        var i = e.x, r = e.y, a = e.z || 0, o, s, l, u = {};
        for (l = 0; l < 3; l++) if (!(t && l === 2 && e.z === void 0)) switch (l === 0 ? (o = i, "ew".indexOf(n.axis[l]) !== -1 ? s = "x" : s = "y") : l === 1 ? (o = r, "ns".indexOf(n.axis[l]) !== -1 ? s = "y" : s = "x") : (o = a, s = "z"), n.axis[l]) {
          case "e":
            u[s] = o;
            break;
          case "w":
            u[s] = -o;
            break;
          case "n":
            u[s] = o;
            break;
          case "s":
            u[s] = -o;
            break;
          case "u":
            e[s] !== void 0 && (u.z = o);
            break;
          case "d":
            e[s] !== void 0 && (u.z = -o);
            break;
          default:
            return null;
        }
        return u;
      }
      function bk(n) {
        var t = { x: n[0], y: n[1] };
        return n.length > 2 && (t.z = n[2]), n.length > 3 && (t.m = n[3]), t;
      }
      function Jtt(n) {
        Bk(n.x), Bk(n.y);
      }
      function Bk(n) {
        if (typeof Number.isFinite == "function") {
          if (Number.isFinite(n)) return;
          throw new TypeError("coordinates must be finite numbers");
        }
        if (typeof n != "number" || n !== n || !isFinite(n)) throw new TypeError("coordinates must be finite numbers");
      }
      function tet(n, t) {
        return (n.datum.datum_type === Ou || n.datum.datum_type === zu || n.datum.datum_type === gf) && t.datumCode !== "WGS84" || (t.datum.datum_type === Ou || t.datum.datum_type === zu || t.datum.datum_type === gf) && n.datumCode !== "WGS84";
      }
      function U0(n, t, e, i) {
        var r;
        Array.isArray(e) ? e = bk(e) : e = { x: e.x, y: e.y, z: e.z, m: e.m };
        var a = e.z !== void 0;
        if (Jtt(e), n.datum && t.datum && tet(n, t) && (r = new go("WGS84"), e = U0(n, r, e, i), n = r), i && n.axis !== "enu" && (e = Sk(n, false, e)), n.projName === "longlat") e = { x: e.x * fi, y: e.y * fi, z: e.z || 0 };
        else if (n.to_meter && (e = { x: e.x * n.to_meter, y: e.y * n.to_meter, z: e.z || 0 }), e = n.inverse(e), !e) return;
        if (n.from_greenwich && (e.x += n.from_greenwich), e = Ktt(n.datum, t.datum, e), !!e) return t.from_greenwich && (e = { x: e.x - t.from_greenwich, y: e.y, z: e.z || 0 }), t.projName === "longlat" ? e = { x: e.x * El, y: e.y * El, z: e.z || 0 } : (e = t.forward(e), t.to_meter && (e = { x: e.x / t.to_meter, y: e.y / t.to_meter, z: e.z || 0 })), i && t.axis !== "enu" ? Sk(t, true, e) : (e && !a && delete e.z, e);
      }
      var Tk = go("WGS84");
      function Iw(n, t, e, i) {
        var r, a, o;
        return Array.isArray(e) ? (r = U0(n, t, e, i) || { x: NaN, y: NaN }, e.length > 2 ? typeof n.name != "undefined" && n.name === "geocent" || typeof t.name != "undefined" && t.name === "geocent" ? typeof r.z == "number" ? [r.x, r.y, r.z].concat(e.slice(3)) : [r.x, r.y, e[2]].concat(e.slice(3)) : [r.x, r.y].concat(e.slice(2)) : [r.x, r.y]) : (a = U0(n, t, e, i), o = Object.keys(e), o.length === 2 || o.forEach(function(s) {
          if (typeof n.name != "undefined" && n.name === "geocent" || typeof t.name != "undefined" && t.name === "geocent") {
            if (s === "x" || s === "y" || s === "z") return;
          } else if (s === "x" || s === "y") return;
          a[s] = e[s];
        }), a);
      }
      function Mk(n) {
        return n instanceof go ? n : n.oProj ? n.oProj : go(n);
      }
      function tn(n, t, e) {
        n = Mk(n);
        var i = false, r;
        return typeof t == "undefined" ? (t = n, n = Tk, i = true) : (typeof t.x != "undefined" || Array.isArray(t)) && (e = t, t = n, n = Tk, i = true), t = Mk(t), e ? Iw(n, t, e) : (r = { forward: function(a, o) {
          return Iw(n, t, a, o);
        }, inverse: function(a, o) {
          return Iw(t, n, a, o);
        } }, i && (r.oProj = t), r);
      }
      var Dk = 6, Rk = "AJSAJS", Lk = "AFAFAF", pf = 65, ur = 73, Jr = 79, wA = 86, CA = 90;
      const eet = { forward: Pk, inverse: net, toPoint: Nk };
      function Pk(n, t) {
        return t = t || 5, aet(iet({ lat: n[1], lon: n[0] }), t);
      }
      function net(n) {
        var t = xw(Qk(n.toUpperCase()));
        return t.lat && t.lon ? [t.lon, t.lat, t.lon, t.lat] : [t.left, t.bottom, t.right, t.top];
      }
      function Nk(n) {
        var t = xw(Qk(n.toUpperCase()));
        return t.lat && t.lon ? [t.lon, t.lat] : [(t.left + t.right) / 2, (t.top + t.bottom) / 2];
      }
      function Ew(n) {
        return n * (Math.PI / 180);
      }
      function kk(n) {
        return 180 * (n / Math.PI);
      }
      function iet(n) {
        var t = n.lat, e = n.lon, i = 6378137, r = 669438e-8, a = 0.9996, o, s, l, u, h, c, f, g = Ew(t), d = Ew(e), A, p;
        p = Math.floor((e + 180) / 6) + 1, e === 180 && (p = 60), t >= 56 && t < 64 && e >= 3 && e < 12 && (p = 32), t >= 72 && t < 84 && (e >= 0 && e < 9 ? p = 31 : e >= 9 && e < 21 ? p = 33 : e >= 21 && e < 33 ? p = 35 : e >= 33 && e < 42 && (p = 37)), o = (p - 1) * 6 - 180 + 3, A = Ew(o), s = r / (1 - r), l = i / Math.sqrt(1 - r * Math.sin(g) * Math.sin(g)), u = Math.tan(g) * Math.tan(g), h = s * Math.cos(g) * Math.cos(g), c = Math.cos(g) * (d - A), f = i * ((1 - r / 4 - 3 * r * r / 64 - 5 * r * r * r / 256) * g - (3 * r / 8 + 3 * r * r / 32 + 45 * r * r * r / 1024) * Math.sin(2 * g) + (15 * r * r / 256 + 45 * r * r * r / 1024) * Math.sin(4 * g) - 35 * r * r * r / 3072 * Math.sin(6 * g));
        var v = a * l * (c + (1 - u + h) * c * c * c / 6 + (5 - 18 * u + u * u + 72 * h - 58 * s) * c * c * c * c * c / 120) + 5e5, y = a * (f + l * Math.tan(g) * (c * c / 2 + (5 - u + 9 * h + 4 * h * h) * c * c * c * c / 24 + (61 - 58 * u + u * u + 600 * h - 330 * s) * c * c * c * c * c * c / 720));
        return t < 0 && (y += 1e7), { northing: Math.round(y), easting: Math.round(v), zoneNumber: p, zoneLetter: ret(t) };
      }
      function xw(n) {
        var t = n.northing, e = n.easting, i = n.zoneLetter, r = n.zoneNumber;
        if (r < 0 || r > 60) return null;
        var a = 0.9996, o = 6378137, s = 669438e-8, l, u = (1 - Math.sqrt(1 - s)) / (1 + Math.sqrt(1 - s)), h, c, f, g, d, A, p, v, y, m = e - 5e5, _ = t;
        i < "N" && (_ -= 1e7), p = (r - 1) * 6 - 180 + 3, l = s / (1 - s), A = _ / a, v = A / (o * (1 - s / 4 - 3 * s * s / 64 - 5 * s * s * s / 256)), y = v + (3 * u / 2 - 27 * u * u * u / 32) * Math.sin(2 * v) + (21 * u * u / 16 - 55 * u * u * u * u / 32) * Math.sin(4 * v) + 151 * u * u * u / 96 * Math.sin(6 * v), h = o / Math.sqrt(1 - s * Math.sin(y) * Math.sin(y)), c = Math.tan(y) * Math.tan(y), f = l * Math.cos(y) * Math.cos(y), g = o * (1 - s) / Math.pow(1 - s * Math.sin(y) * Math.sin(y), 1.5), d = m / (h * a);
        var E = y - h * Math.tan(y) / g * (d * d / 2 - (5 + 3 * c + 10 * f - 4 * f * f - 9 * l) * d * d * d * d / 24 + (61 + 90 * c + 298 * f + 45 * c * c - 252 * l - 3 * f * f) * d * d * d * d * d * d / 720);
        E = kk(E);
        var I = (d - (1 + 2 * c + f) * d * d * d / 6 + (5 - 2 * f + 28 * c - 3 * f * f + 8 * l + 24 * c * c) * d * d * d * d * d / 120) / Math.cos(y);
        I = p + kk(I);
        var x;
        if (n.accuracy) {
          var w = xw({ northing: n.northing + n.accuracy, easting: n.easting + n.accuracy, zoneLetter: n.zoneLetter, zoneNumber: n.zoneNumber });
          x = { top: w.lat, right: w.lon, bottom: E, left: I };
        } else x = { lat: E, lon: I };
        return x;
      }
      function ret(n) {
        var t = "Z";
        return 84 >= n && n >= 72 ? t = "X" : 72 > n && n >= 64 ? t = "W" : 64 > n && n >= 56 ? t = "V" : 56 > n && n >= 48 ? t = "U" : 48 > n && n >= 40 ? t = "T" : 40 > n && n >= 32 ? t = "S" : 32 > n && n >= 24 ? t = "R" : 24 > n && n >= 16 ? t = "Q" : 16 > n && n >= 8 ? t = "P" : 8 > n && n >= 0 ? t = "N" : 0 > n && n >= -8 ? t = "M" : -8 > n && n >= -16 ? t = "L" : -16 > n && n >= -24 ? t = "K" : -24 > n && n >= -32 ? t = "J" : -32 > n && n >= -40 ? t = "H" : -40 > n && n >= -48 ? t = "G" : -48 > n && n >= -56 ? t = "F" : -56 > n && n >= -64 ? t = "E" : -64 > n && n >= -72 ? t = "D" : -72 > n && n >= -80 && (t = "C"), t;
      }
      function aet(n, t) {
        var e = "00000" + n.easting, i = "00000" + n.northing;
        return n.zoneNumber + n.zoneLetter + oet(n.easting, n.northing, n.zoneNumber) + e.substr(e.length - 5, t) + i.substr(i.length - 5, t);
      }
      function oet(n, t, e) {
        var i = Fk(e), r = Math.floor(n / 1e5), a = Math.floor(t / 1e5) % 20;
        return set(r, a, i);
      }
      function Fk(n) {
        var t = n % Dk;
        return t === 0 && (t = Dk), t;
      }
      function set(n, t, e) {
        var i = e - 1, r = Rk.charCodeAt(i), a = Lk.charCodeAt(i), o = r + n - 1, s = a + t, l = false;
        o > CA && (o = o - CA + pf - 1, l = true), (o === ur || r < ur && o > ur || (o > ur || r < ur) && l) && o++, (o === Jr || r < Jr && o > Jr || (o > Jr || r < Jr) && l) && (o++, o === ur && o++), o > CA && (o = o - CA + pf - 1), s > wA ? (s = s - wA + pf - 1, l = true) : l = false, (s === ur || a < ur && s > ur || (s > ur || a < ur) && l) && s++, (s === Jr || a < Jr && s > Jr || (s > Jr || a < Jr) && l) && (s++, s === ur && s++), s > wA && (s = s - wA + pf - 1);
        var u = String.fromCharCode(o) + String.fromCharCode(s);
        return u;
      }
      function Qk(n) {
        if (n && n.length === 0) throw "MGRSPoint coverting from nothing";
        for (var t = n.length, e = null, i = "", r, a = 0; !/[A-Z]/.test(r = n.charAt(a)); ) {
          if (a >= 2) throw "MGRSPoint bad conversion from: " + n;
          i += r, a++;
        }
        var o = parseInt(i, 10);
        if (a === 0 || a + 3 > t) throw "MGRSPoint bad conversion from: " + n;
        var s = n.charAt(a++);
        if (s <= "A" || s === "B" || s === "Y" || s >= "Z" || s === "I" || s === "O") throw "MGRSPoint zone letter " + s + " not handled: " + n;
        e = n.substring(a, a += 2);
        for (var l = Fk(o), u = uet(e.charAt(0), l), h = het(e.charAt(1), l); h < cet(s); ) h += 2e6;
        var c = t - a;
        if (c % 2 !== 0) throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + n;
        var f = c / 2, g = 0, d = 0, A, p, v, y, m;
        return f > 0 && (A = 1e5 / Math.pow(10, f), p = n.substring(a, a + f), g = parseFloat(p) * A, v = n.substring(a + f), d = parseFloat(v) * A), y = g + u, m = d + h, { easting: y, northing: m, zoneLetter: s, zoneNumber: o, accuracy: A };
      }
      function uet(n, t) {
        for (var e = Rk.charCodeAt(t - 1), i = 1e5, r = false; e !== n.charCodeAt(0); ) {
          if (e++, e === ur && e++, e === Jr && e++, e > CA) {
            if (r) throw "Bad character: " + n;
            e = pf, r = true;
          }
          i += 1e5;
        }
        return i;
      }
      function het(n, t) {
        if (n > "V") throw "MGRSPoint given invalid Northing " + n;
        for (var e = Lk.charCodeAt(t - 1), i = 0, r = false; e !== n.charCodeAt(0); ) {
          if (e++, e === ur && e++, e === Jr && e++, e > wA) {
            if (r) throw "Bad character: " + n;
            e = pf, r = true;
          }
          i += 1e5;
        }
        return i;
      }
      function cet(n) {
        var t;
        switch (n) {
          case "C":
            t = 11e5;
            break;
          case "D":
            t = 2e6;
            break;
          case "E":
            t = 28e5;
            break;
          case "F":
            t = 37e5;
            break;
          case "G":
            t = 46e5;
            break;
          case "H":
            t = 55e5;
            break;
          case "J":
            t = 64e5;
            break;
          case "K":
            t = 73e5;
            break;
          case "L":
            t = 82e5;
            break;
          case "M":
            t = 91e5;
            break;
          case "N":
            t = 0;
            break;
          case "P":
            t = 8e5;
            break;
          case "Q":
            t = 17e5;
            break;
          case "R":
            t = 26e5;
            break;
          case "S":
            t = 35e5;
            break;
          case "T":
            t = 44e5;
            break;
          case "U":
            t = 53e5;
            break;
          case "V":
            t = 62e5;
            break;
          case "W":
            t = 7e6;
            break;
          case "X":
            t = 79e5;
            break;
          default:
            t = -1;
        }
        if (t >= 0) return t;
        throw "Invalid zone letter: " + n;
      }
      function vf(n, t, e) {
        if (!(this instanceof vf)) return new vf(n, t, e);
        if (Array.isArray(n)) this.x = n[0], this.y = n[1], this.z = n[2] || 0;
        else if (typeof n == "object") this.x = n.x, this.y = n.y, this.z = n.z || 0;
        else if (typeof n == "string" && typeof t == "undefined") {
          var i = n.split(",");
          this.x = parseFloat(i[0], 10), this.y = parseFloat(i[1], 10), this.z = parseFloat(i[2], 10) || 0;
        } else this.x = n, this.y = t, this.z = e || 0;
      }
      vf.fromMGRS = function(n) {
        return new vf(Nk(n));
      }, vf.prototype.toMGRS = function(n) {
        return Pk([this.x, this.y], n);
      };
      var fet = 1, get = 0.25, Ok = 0.046875, zk = 0.01953125, Gk = 0.01068115234375, det = 0.75, Aet = 0.46875, pet = 0.013020833333333334, vet = 0.007120768229166667, yet = 0.3645833333333333, met = 0.005696614583333333, _et = 0.3076171875;
      function ww(n) {
        var t = [];
        t[0] = fet - n * (get + n * (Ok + n * (zk + n * Gk))), t[1] = n * (det - n * (Ok + n * (zk + n * Gk)));
        var e = n * n;
        return t[2] = e * (Aet - n * (pet + n * vet)), e *= n, t[3] = e * (yet - n * met), t[4] = e * n * _et, t;
      }
      function yf(n, t, e, i) {
        return e *= t, t *= t, i[0] * n - e * (i[1] + t * (i[2] + t * (i[3] + t * i[4])));
      }
      var Iet = 20;
      function Cw(n, t, e) {
        for (var i = 1 / (1 - t), r = n, a = Iet; a; --a) {
          var o = Math.sin(r), s = 1 - t * o * o;
          if (s = (yf(r, o, Math.cos(r), e) - n) * (s * Math.sqrt(s)) * i, r -= s, Math.abs(s) < pt) return r;
        }
        return r;
      }
      function Eet() {
        this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = ww(this.es), this.ml0 = yf(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
      }
      function xet(n) {
        var t = n.x, e = n.y, i = mt(t - this.long0), r, a, o, s = Math.sin(e), l = Math.cos(e);
        if (this.es) {
          var h = l * i, c = Math.pow(h, 2), f = this.ep2 * Math.pow(l, 2), g = Math.pow(f, 2), d = Math.abs(l) > pt ? Math.tan(e) : 0, A = Math.pow(d, 2), p = Math.pow(A, 2);
          r = 1 - this.es * Math.pow(s, 2), h = h / Math.sqrt(r);
          var v = yf(e, s, l, this.en);
          a = this.a * (this.k0 * h * (1 + c / 6 * (1 - A + f + c / 20 * (5 - 18 * A + p + 14 * f - 58 * A * f + c / 42 * (61 + 179 * p - p * A - 479 * A))))) + this.x0, o = this.a * (this.k0 * (v - this.ml0 + s * i * h / 2 * (1 + c / 12 * (5 - A + 9 * f + 4 * g + c / 30 * (61 + p - 58 * A + 270 * f - 330 * A * f + c / 56 * (1385 + 543 * p - p * A - 3111 * A)))))) + this.y0;
        } else {
          var u = l * Math.sin(i);
          if (Math.abs(Math.abs(u) - 1) < pt) return 93;
          if (a = 0.5 * this.a * this.k0 * Math.log((1 + u) / (1 - u)) + this.x0, o = l * Math.cos(i) / Math.sqrt(1 - Math.pow(u, 2)), u = Math.abs(o), u >= 1) {
            if (u - 1 > pt) return 93;
            o = 0;
          } else o = Math.acos(o);
          e < 0 && (o = -o), o = this.a * this.k0 * (o - this.lat0) + this.y0;
        }
        return n.x = a, n.y = o, n;
      }
      function wet(n) {
        var t, e, i, r, a = (n.x - this.x0) * (1 / this.a), o = (n.y - this.y0) * (1 / this.a);
        if (this.es) if (t = this.ml0 + o / this.k0, e = Cw(t, this.es, this.en), Math.abs(e) < ut) {
          var c = Math.sin(e), f = Math.cos(e), g = Math.abs(f) > pt ? Math.tan(e) : 0, d = this.ep2 * Math.pow(f, 2), A = Math.pow(d, 2), p = Math.pow(g, 2), v = Math.pow(p, 2);
          t = 1 - this.es * Math.pow(c, 2);
          var y = a * Math.sqrt(t) / this.k0, m = Math.pow(y, 2);
          t = t * g, i = e - t * m / (1 - this.es) * 0.5 * (1 - m / 12 * (5 + 3 * p - 9 * d * p + d - 4 * A - m / 30 * (61 + 90 * p - 252 * d * p + 45 * v + 46 * d - m / 56 * (1385 + 3633 * p + 4095 * v + 1574 * v * p)))), r = mt(this.long0 + y * (1 - m / 6 * (1 + 2 * p + d - m / 20 * (5 + 28 * p + 24 * v + 8 * d * p + 6 * d - m / 42 * (61 + 662 * p + 1320 * v + 720 * v * p)))) / f);
        } else i = ut * EA(o), r = 0;
        else {
          var s = Math.exp(a / this.k0), l = 0.5 * (s - 1 / s), u = this.lat0 + o / this.k0, h = Math.cos(u);
          t = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(l, 2))), i = Math.asin(t), o < 0 && (i = -i), l === 0 && h === 0 ? r = 0 : r = mt(Math.atan2(l, h) + this.long0);
        }
        return n.x = r, n.y = i, n;
      }
      var Cet = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
      const V0 = { init: Eet, forward: xet, inverse: wet, names: Cet };
      function Uk(n) {
        var t = Math.exp(n);
        return t = (t - 1 / t) / 2, t;
      }
      function hr(n, t) {
        n = Math.abs(n), t = Math.abs(t);
        var e = Math.max(n, t), i = Math.min(n, t) / (e || 1);
        return e * Math.sqrt(1 + Math.pow(i, 2));
      }
      function bet(n) {
        var t = 1 + n, e = t - 1;
        return e === 0 ? n : n * Math.log(t) / e;
      }
      function Bet(n) {
        var t = Math.abs(n);
        return t = bet(t * (1 + t / (hr(1, t) + 1))), n < 0 ? -t : t;
      }
      function Sw(n, t) {
        for (var e = 2 * Math.cos(2 * t), i = n.length - 1, r = n[i], a = 0, o; --i >= 0; ) o = -a + e * r + n[i], a = r, r = o;
        return t + o * Math.sin(2 * t);
      }
      function Tet(n, t) {
        for (var e = 2 * Math.cos(t), i = n.length - 1, r = n[i], a = 0, o; --i >= 0; ) o = -a + e * r + n[i], a = r, r = o;
        return Math.sin(t) * o;
      }
      function Met(n) {
        var t = Math.exp(n);
        return t = (t + 1 / t) / 2, t;
      }
      function Vk(n, t, e) {
        for (var i = Math.sin(t), r = Math.cos(t), a = Uk(e), o = Met(e), s = 2 * r * o, l = -2 * i * a, u = n.length - 1, h = n[u], c = 0, f = 0, g = 0, d, A; --u >= 0; ) d = f, A = c, f = h, c = g, h = -d + s * f - l * c + n[u], g = -A + l * f + s * c;
        return s = i * o, l = r * a, [s * h - l * g, s * g + l * h];
      }
      function Det() {
        if (!this.approx && (isNaN(this.es) || this.es <= 0)) throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
        this.approx && (V0.init.apply(this), this.forward = V0.forward, this.inverse = V0.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
        var n = this.es / (1 + Math.sqrt(1 - this.es)), t = n / (2 - n), e = t;
        this.cgb[0] = t * (2 + t * (-2 / 3 + t * (-2 + t * (116 / 45 + t * (26 / 45 + t * (-2854 / 675)))))), this.cbg[0] = t * (-2 + t * (2 / 3 + t * (4 / 3 + t * (-82 / 45 + t * (32 / 45 + t * (4642 / 4725)))))), e = e * t, this.cgb[1] = e * (7 / 3 + t * (-8 / 5 + t * (-227 / 45 + t * (2704 / 315 + t * (2323 / 945))))), this.cbg[1] = e * (5 / 3 + t * (-16 / 15 + t * (-13 / 9 + t * (904 / 315 + t * (-1522 / 945))))), e = e * t, this.cgb[2] = e * (56 / 15 + t * (-136 / 35 + t * (-1262 / 105 + t * (73814 / 2835)))), this.cbg[2] = e * (-26 / 15 + t * (34 / 21 + t * (8 / 5 + t * (-12686 / 2835)))), e = e * t, this.cgb[3] = e * (4279 / 630 + t * (-332 / 35 + t * (-399572 / 14175))), this.cbg[3] = e * (1237 / 630 + t * (-12 / 5 + t * (-24832 / 14175))), e = e * t, this.cgb[4] = e * (4174 / 315 + t * (-144838 / 6237)), this.cbg[4] = e * (-734 / 315 + t * (109598 / 31185)), e = e * t, this.cgb[5] = e * (601676 / 22275), this.cbg[5] = e * (444337 / 155925), e = Math.pow(t, 2), this.Qn = this.k0 / (1 + t) * (1 + e * (1 / 4 + e * (1 / 64 + e / 256))), this.utg[0] = t * (-0.5 + t * (2 / 3 + t * (-37 / 96 + t * (1 / 360 + t * (81 / 512 + t * (-96199 / 604800)))))), this.gtu[0] = t * (0.5 + t * (-2 / 3 + t * (5 / 16 + t * (41 / 180 + t * (-127 / 288 + t * (7891 / 37800)))))), this.utg[1] = e * (-1 / 48 + t * (-1 / 15 + t * (437 / 1440 + t * (-46 / 105 + t * (1118711 / 3870720))))), this.gtu[1] = e * (13 / 48 + t * (-3 / 5 + t * (557 / 1440 + t * (281 / 630 + t * (-1983433 / 1935360))))), e = e * t, this.utg[2] = e * (-17 / 480 + t * (37 / 840 + t * (209 / 4480 + t * (-5569 / 90720)))), this.gtu[2] = e * (61 / 240 + t * (-103 / 140 + t * (15061 / 26880 + t * (167603 / 181440)))), e = e * t, this.utg[3] = e * (-4397 / 161280 + t * (11 / 504 + t * (830251 / 7257600))), this.gtu[3] = e * (49561 / 161280 + t * (-179 / 168 + t * (6601661 / 7257600))), e = e * t, this.utg[4] = e * (-4583 / 161280 + t * (108847 / 3991680)), this.gtu[4] = e * (34729 / 80640 + t * (-3418889 / 1995840)), e = e * t, this.utg[5] = e * (-20648693 / 638668800), this.gtu[5] = e * (212378941 / 319334400);
        var i = Sw(this.cbg, this.lat0);
        this.Zb = -this.Qn * (i + Tet(this.gtu, 2 * i));
      }
      function Ret(n) {
        var t = mt(n.x - this.long0), e = n.y;
        e = Sw(this.cbg, e);
        var i = Math.sin(e), r = Math.cos(e), a = Math.sin(t), o = Math.cos(t);
        e = Math.atan2(i, o * r), t = Math.atan2(a * r, hr(i, r * o)), t = Bet(Math.tan(t));
        var s = Vk(this.gtu, 2 * e, 2 * t);
        e = e + s[0], t = t + s[1];
        var l, u;
        return Math.abs(t) <= 2.623395162778 ? (l = this.a * (this.Qn * t) + this.x0, u = this.a * (this.Qn * e + this.Zb) + this.y0) : (l = 1 / 0, u = 1 / 0), n.x = l, n.y = u, n;
      }
      function Let(n) {
        var t = (n.x - this.x0) * (1 / this.a), e = (n.y - this.y0) * (1 / this.a);
        e = (e - this.Zb) / this.Qn, t = t / this.Qn;
        var i, r;
        if (Math.abs(t) <= 2.623395162778) {
          var a = Vk(this.utg, 2 * e, 2 * t);
          e = e + a[0], t = t + a[1], t = Math.atan(Uk(t));
          var o = Math.sin(e), s = Math.cos(e), l = Math.sin(t), u = Math.cos(t);
          e = Math.atan2(o * u, hr(l, u * s)), t = Math.atan2(l, u * s), i = mt(t + this.long0), r = Sw(this.cgb, e);
        } else i = 1 / 0, r = 1 / 0;
        return n.x = i, n.y = r, n;
      }
      var Pet = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
      const j0 = { init: Det, forward: Ret, inverse: Let, names: Pet };
      function Net(n, t) {
        if (n === void 0) {
          if (n = Math.floor((mt(t) + Math.PI) * 30 / Math.PI) + 1, n < 0) return 0;
          if (n > 60) return 60;
        }
        return n;
      }
      var ket = "etmerc";
      function Fet() {
        var n = Net(this.zone, this.long0);
        if (n === void 0) throw new Error("unknown utm zone");
        this.lat0 = 0, this.long0 = (6 * Math.abs(n) - 183) * fi, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, j0.init.apply(this), this.forward = j0.forward, this.inverse = j0.inverse;
      }
      var Qet = ["Universal Transverse Mercator System", "utm"];
      const Oet = { init: Fet, names: Qet, dependsOn: ket };
      function bw(n, t) {
        return Math.pow((1 - n) / (1 + n), t);
      }
      var zet = 20;
      function Get() {
        var n = Math.sin(this.lat0), t = Math.cos(this.lat0);
        t *= t, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * n * n), this.C = Math.sqrt(1 + this.es * t * t / (1 - this.es)), this.phic0 = Math.asin(n / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + He) / (Math.pow(Math.tan(0.5 * this.lat0 + He), this.C) * bw(this.e * n, this.ratexp));
      }
      function Uet(n) {
        var t = n.x, e = n.y;
        return n.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * e + He), this.C) * bw(this.e * Math.sin(e), this.ratexp)) - ut, n.x = this.C * t, n;
      }
      function Vet(n) {
        for (var t = 1e-14, e = n.x / this.C, i = n.y, r = Math.pow(Math.tan(0.5 * i + He) / this.K, 1 / this.C), a = zet; a > 0 && (i = 2 * Math.atan(r * bw(this.e * Math.sin(n.y), -0.5 * this.e)) - ut, !(Math.abs(i - n.y) < t)); --a) n.y = i;
        return a ? (n.x = e, n.y = i, n) : null;
      }
      var jet = ["gauss"];
      const Bw = { init: Get, forward: Uet, inverse: Vet, names: jet };
      function qet() {
        Bw.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
      }
      function Het(n) {
        var t, e, i, r;
        return n.x = mt(n.x - this.long0), Bw.forward.apply(this, [n]), t = Math.sin(n.y), e = Math.cos(n.y), i = Math.cos(n.x), r = this.k0 * this.R2 / (1 + this.sinc0 * t + this.cosc0 * e * i), n.x = r * e * Math.sin(n.x), n.y = r * (this.cosc0 * t - this.sinc0 * e * i), n.x = this.a * n.x + this.x0, n.y = this.a * n.y + this.y0, n;
      }
      function Yet(n) {
        var t, e, i, r, a;
        if (n.x = (n.x - this.x0) / this.a, n.y = (n.y - this.y0) / this.a, n.x /= this.k0, n.y /= this.k0, a = hr(n.x, n.y)) {
          var o = 2 * Math.atan2(a, this.R2);
          t = Math.sin(o), e = Math.cos(o), r = Math.asin(e * this.sinc0 + n.y * t * this.cosc0 / a), i = Math.atan2(n.x * t, a * this.cosc0 * e - n.y * this.sinc0 * t);
        } else r = this.phic0, i = 0;
        return n.x = i, n.y = r, Bw.inverse.apply(this, [n]), n.x = mt(n.x + this.long0), n;
      }
      var Wet = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
      const Xet = { init: qet, forward: Het, inverse: Yet, names: Wet };
      function Zet(n, t, e) {
        return t *= e, Math.tan(0.5 * (ut + n)) * Math.pow((1 - t) / (1 + t), 0.5 * e);
      }
      function Ket() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= pt && (this.k0 = 0.5 * (1 + EA(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= pt && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= pt && Math.abs(Math.cos(this.lat_ts)) > pt && (this.k0 = 0.5 * this.cons * fo(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Na(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = fo(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - ut, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
      }
      function $et(n) {
        var t = n.x, e = n.y, i = Math.sin(e), r = Math.cos(e), a, o, s, l, u, h, c = mt(t - this.long0);
        return Math.abs(Math.abs(t - this.long0) - Math.PI) <= pt && Math.abs(e + this.lat0) <= pt ? (n.x = NaN, n.y = NaN, n) : this.sphere ? (a = 2 * this.k0 / (1 + this.sinlat0 * i + this.coslat0 * r * Math.cos(c)), n.x = this.a * a * r * Math.sin(c) + this.x0, n.y = this.a * a * (this.coslat0 * i - this.sinlat0 * r * Math.cos(c)) + this.y0, n) : (o = 2 * Math.atan(this.ssfn_(e, i, this.e)) - ut, l = Math.cos(o), s = Math.sin(o), Math.abs(this.coslat0) <= pt ? (u = Na(this.e, e * this.con, this.con * i), h = 2 * this.a * this.k0 * u / this.cons, n.x = this.x0 + h * Math.sin(t - this.long0), n.y = this.y0 - this.con * h * Math.cos(t - this.long0), n) : (Math.abs(this.sinlat0) < pt ? (a = 2 * this.a * this.k0 / (1 + l * Math.cos(c)), n.y = a * s) : (a = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * s + this.cosX0 * l * Math.cos(c))), n.y = a * (this.cosX0 * s - this.sinX0 * l * Math.cos(c)) + this.y0), n.x = a * l * Math.sin(c) + this.x0, n));
      }
      function Jet(n) {
        n.x -= this.x0, n.y -= this.y0;
        var t, e, i, r, a, o = Math.sqrt(n.x * n.x + n.y * n.y);
        if (this.sphere) {
          var s = 2 * Math.atan(o / (2 * this.a * this.k0));
          return t = this.long0, e = this.lat0, o <= pt ? (n.x = t, n.y = e, n) : (e = Math.asin(Math.cos(s) * this.sinlat0 + n.y * Math.sin(s) * this.coslat0 / o), Math.abs(this.coslat0) < pt ? this.lat0 > 0 ? t = mt(this.long0 + Math.atan2(n.x, -1 * n.y)) : t = mt(this.long0 + Math.atan2(n.x, n.y)) : t = mt(this.long0 + Math.atan2(n.x * Math.sin(s), o * this.coslat0 * Math.cos(s) - n.y * this.sinlat0 * Math.sin(s))), n.x = t, n.y = e, n);
        } else if (Math.abs(this.coslat0) <= pt) {
          if (o <= pt) return e = this.lat0, t = this.long0, n.x = t, n.y = e, n;
          n.x *= this.con, n.y *= this.con, i = o * this.cons / (2 * this.a * this.k0), e = this.con * xA(this.e, i), t = this.con * mt(this.con * this.long0 + Math.atan2(n.x, -1 * n.y));
        } else r = 2 * Math.atan(o * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), t = this.long0, o <= pt ? a = this.X0 : (a = Math.asin(Math.cos(r) * this.sinX0 + n.y * Math.sin(r) * this.cosX0 / o), t = mt(this.long0 + Math.atan2(n.x * Math.sin(r), o * this.cosX0 * Math.cos(r) - n.y * this.sinX0 * Math.sin(r)))), e = -1 * xA(this.e, Math.tan(0.5 * (ut + a)));
        return n.x = t, n.y = e, n;
      }
      var tnt = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"];
      const ent = { init: Ket, forward: $et, inverse: Jet, names: tnt, ssfn_: Zet };
      function nnt() {
        var n = this.lat0;
        this.lambda0 = this.long0;
        var t = Math.sin(n), e = this.a, i = this.rf, r = 1 / i, a = 2 * r - Math.pow(r, 2), o = this.e = Math.sqrt(a);
        this.R = this.k0 * e * Math.sqrt(1 - a) / (1 - a * Math.pow(t, 2)), this.alpha = Math.sqrt(1 + a / (1 - a) * Math.pow(Math.cos(n), 4)), this.b0 = Math.asin(t / this.alpha);
        var s = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), l = Math.log(Math.tan(Math.PI / 4 + n / 2)), u = Math.log((1 + o * t) / (1 - o * t));
        this.K = s - this.alpha * l + this.alpha * o / 2 * u;
      }
      function int(n) {
        var t = Math.log(Math.tan(Math.PI / 4 - n.y / 2)), e = this.e / 2 * Math.log((1 + this.e * Math.sin(n.y)) / (1 - this.e * Math.sin(n.y))), i = -this.alpha * (t + e) + this.K, r = 2 * (Math.atan(Math.exp(i)) - Math.PI / 4), a = this.alpha * (n.x - this.lambda0), o = Math.atan(Math.sin(a) / (Math.sin(this.b0) * Math.tan(r) + Math.cos(this.b0) * Math.cos(a))), s = Math.asin(Math.cos(this.b0) * Math.sin(r) - Math.sin(this.b0) * Math.cos(r) * Math.cos(a));
        return n.y = this.R / 2 * Math.log((1 + Math.sin(s)) / (1 - Math.sin(s))) + this.y0, n.x = this.R * o + this.x0, n;
      }
      function rnt(n) {
        for (var t = n.x - this.x0, e = n.y - this.y0, i = t / this.R, r = 2 * (Math.atan(Math.exp(e / this.R)) - Math.PI / 4), a = Math.asin(Math.cos(this.b0) * Math.sin(r) + Math.sin(this.b0) * Math.cos(r) * Math.cos(i)), o = Math.atan(Math.sin(i) / (Math.cos(this.b0) * Math.cos(i) - Math.sin(this.b0) * Math.tan(r))), s = this.lambda0 + o / this.alpha, l = 0, u = a, h = -1e3, c = 0; Math.abs(u - h) > 1e-7; ) {
          if (++c > 20) return;
          l = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + a / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(u)) / 2)), h = u, u = 2 * Math.atan(Math.exp(l)) - Math.PI / 2;
        }
        return n.x = s, n.y = u, n;
      }
      var ant = ["somerc"];
      const ont = { init: nnt, forward: int, inverse: rnt, names: ant };
      var mf = 1e-7;
      function snt(n) {
        var t = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], e = typeof n.PROJECTION == "object" ? Object.keys(n.PROJECTION)[0] : n.PROJECTION;
        return "no_uoff" in n || "no_off" in n || t.indexOf(e) !== -1;
      }
      function lnt() {
        var n, t, e, i, r, a, o, s, l, u, h = 0, c, f = 0, g = 0, d = 0, A = 0, p = 0, v = 0;
        this.no_off = snt(this), this.no_rot = "no_rot" in this;
        var y = false;
        "alpha" in this && (y = true);
        var m = false;
        if ("rectified_grid_angle" in this && (m = true), y && (v = this.alpha), m && (h = this.rectified_grid_angle * fi), y || m) f = this.longc;
        else if (g = this.long1, A = this.lat1, d = this.long2, p = this.lat2, Math.abs(A - p) <= mf || (n = Math.abs(A)) <= mf || Math.abs(n - ut) <= mf || Math.abs(Math.abs(this.lat0) - ut) <= mf || Math.abs(Math.abs(p) - ut) <= mf) throw new Error();
        var _ = 1 - this.es;
        t = Math.sqrt(_), Math.abs(this.lat0) > pt ? (s = Math.sin(this.lat0), e = Math.cos(this.lat0), n = 1 - this.es * s * s, this.B = e * e, this.B = Math.sqrt(1 + this.es * this.B * this.B / _), this.A = this.B * this.k0 * t / n, i = this.B * t / (e * Math.sqrt(n)), r = i * i - 1, r <= 0 ? r = 0 : (r = Math.sqrt(r), this.lat0 < 0 && (r = -r)), this.E = r += i, this.E *= Math.pow(Na(this.e, this.lat0, s), this.B)) : (this.B = 1 / t, this.A = this.k0, this.E = i = r = 1), y || m ? (y ? (c = Math.asin(Math.sin(v) / i), m || (h = v)) : (c = h, v = Math.asin(i * Math.sin(c))), this.lam0 = f - Math.asin(0.5 * (r - 1 / r) * Math.tan(c)) / this.B) : (a = Math.pow(Na(this.e, A, Math.sin(A)), this.B), o = Math.pow(Na(this.e, p, Math.sin(p)), this.B), r = this.E / a, l = (o - a) / (o + a), u = this.E * this.E, u = (u - o * a) / (u + o * a), n = g - d, n < -Math.pi ? d -= _A : n > Math.pi && (d += _A), this.lam0 = mt(0.5 * (g + d) - Math.atan(u * Math.tan(0.5 * this.B * (g - d)) / l) / this.B), c = Math.atan(2 * Math.sin(this.B * mt(g - this.lam0)) / (r - 1 / r)), h = v = Math.asin(i * Math.sin(c))), this.singam = Math.sin(c), this.cosgam = Math.cos(c), this.sinrot = Math.sin(h), this.cosrot = Math.cos(h), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A * this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(i * i - 1) / Math.cos(v))), this.lat0 < 0 && (this.u_0 = -this.u_0)), r = 0.5 * c, this.v_pole_n = this.ArB * Math.log(Math.tan(He - r)), this.v_pole_s = this.ArB * Math.log(Math.tan(He + r));
      }
      function unt(n) {
        var t = {}, e, i, r, a, o, s, l, u;
        if (n.x = n.x - this.lam0, Math.abs(Math.abs(n.y) - ut) > pt) {
          if (o = this.E / Math.pow(Na(this.e, n.y, Math.sin(n.y)), this.B), s = 1 / o, e = 0.5 * (o - s), i = 0.5 * (o + s), a = Math.sin(this.B * n.x), r = (e * this.singam - a * this.cosgam) / i, Math.abs(Math.abs(r) - 1) < pt) throw new Error();
          u = 0.5 * this.ArB * Math.log((1 - r) / (1 + r)), s = Math.cos(this.B * n.x), Math.abs(s) < mf ? l = this.A * n.x : l = this.ArB * Math.atan2(e * this.cosgam + a * this.singam, s);
        } else u = n.y > 0 ? this.v_pole_n : this.v_pole_s, l = this.ArB * n.y;
        return this.no_rot ? (t.x = l, t.y = u) : (l -= this.u_0, t.x = u * this.cosrot + l * this.sinrot, t.y = l * this.cosrot - u * this.sinrot), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t;
      }
      function hnt(n) {
        var t, e, i, r, a, o, s, l = {};
        if (n.x = (n.x - this.x0) * (1 / this.a), n.y = (n.y - this.y0) * (1 / this.a), this.no_rot ? (e = n.y, t = n.x) : (e = n.x * this.cosrot - n.y * this.sinrot, t = n.y * this.cosrot + n.x * this.sinrot + this.u_0), i = Math.exp(-this.BrA * e), r = 0.5 * (i - 1 / i), a = 0.5 * (i + 1 / i), o = Math.sin(this.BrA * t), s = (o * this.cosgam + r * this.singam) / a, Math.abs(Math.abs(s) - 1) < pt) l.x = 0, l.y = s < 0 ? -ut : ut;
        else {
          if (l.y = this.E / Math.sqrt((1 + s) / (1 - s)), l.y = xA(this.e, Math.pow(l.y, 1 / this.B)), l.y === 1 / 0) throw new Error();
          l.x = -this.rB * Math.atan2(r * this.cosgam - o * this.singam, Math.cos(this.BrA * t));
        }
        return l.x += this.lam0, l;
      }
      var cnt = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
      const fnt = { init: lnt, forward: unt, inverse: hnt, names: cnt };
      function gnt() {
        if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < pt)) {
          var n = this.b / this.a;
          this.e = Math.sqrt(1 - n * n);
          var t = Math.sin(this.lat1), e = Math.cos(this.lat1), i = fo(this.e, t, e), r = Na(this.e, this.lat1, t), a = Math.sin(this.lat2), o = Math.cos(this.lat2), s = fo(this.e, a, o), l = Na(this.e, this.lat2, a), u = Na(this.e, this.lat0, Math.sin(this.lat0));
          Math.abs(this.lat1 - this.lat2) > pt ? this.ns = Math.log(i / s) / Math.log(r / l) : this.ns = t, isNaN(this.ns) && (this.ns = t), this.f0 = i / (this.ns * Math.pow(r, this.ns)), this.rh = this.a * this.f0 * Math.pow(u, this.ns), this.title || (this.title = "Lambert Conformal Conic");
        }
      }
      function dnt(n) {
        var t = n.x, e = n.y;
        Math.abs(2 * Math.abs(e) - Math.PI) <= pt && (e = EA(e) * (ut - 2 * pt));
        var i = Math.abs(Math.abs(e) - ut), r, a;
        if (i > pt) r = Na(this.e, e, Math.sin(e)), a = this.a * this.f0 * Math.pow(r, this.ns);
        else {
          if (i = e * this.ns, i <= 0) return null;
          a = 0;
        }
        var o = this.ns * mt(t - this.long0);
        return n.x = this.k0 * (a * Math.sin(o)) + this.x0, n.y = this.k0 * (this.rh - a * Math.cos(o)) + this.y0, n;
      }
      function Ant(n) {
        var t, e, i, r, a, o = (n.x - this.x0) / this.k0, s = this.rh - (n.y - this.y0) / this.k0;
        this.ns > 0 ? (t = Math.sqrt(o * o + s * s), e = 1) : (t = -Math.sqrt(o * o + s * s), e = -1);
        var l = 0;
        if (t !== 0 && (l = Math.atan2(e * o, e * s)), t !== 0 || this.ns > 0) {
          if (e = 1 / this.ns, i = Math.pow(t / (this.a * this.f0), e), r = xA(this.e, i), r === -9999) return null;
        } else r = -ut;
        return a = mt(l / this.ns + this.long0), n.x = a, n.y = r, n;
      }
      var pnt = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_1SP", "Lambert_Conformal_Conic_2SP", "lcc", "Lambert Conic Conformal (1SP)", "Lambert Conic Conformal (2SP)"];
      const vnt = { init: gnt, forward: dnt, inverse: Ant, names: pnt };
      function ynt() {
        this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
      }
      function mnt(n) {
        var t, e, i, r, a, o, s, l = n.x, u = n.y, h = mt(l - this.long0);
        return t = Math.pow((1 + this.e * Math.sin(u)) / (1 - this.e * Math.sin(u)), this.alfa * this.e / 2), e = 2 * (Math.atan(this.k * Math.pow(Math.tan(u / 2 + this.s45), this.alfa) / t) - this.s45), i = -h * this.alfa, r = Math.asin(Math.cos(this.ad) * Math.sin(e) + Math.sin(this.ad) * Math.cos(e) * Math.cos(i)), a = Math.asin(Math.cos(e) * Math.sin(i) / Math.cos(r)), o = this.n * a, s = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(r / 2 + this.s45), this.n), n.y = s * Math.cos(o) / 1, n.x = s * Math.sin(o) / 1, this.czech || (n.y *= -1, n.x *= -1), n;
      }
      function _nt(n) {
        var t, e, i, r, a, o, s, l, u = n.x;
        n.x = n.y, n.y = u, this.czech || (n.y *= -1, n.x *= -1), o = Math.sqrt(n.x * n.x + n.y * n.y), a = Math.atan2(n.y, n.x), r = a / Math.sin(this.s0), i = 2 * (Math.atan(Math.pow(this.ro0 / o, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), t = Math.asin(Math.cos(this.ad) * Math.sin(i) - Math.sin(this.ad) * Math.cos(i) * Math.cos(r)), e = Math.asin(Math.cos(i) * Math.sin(r) / Math.cos(t)), n.x = this.long0 - e / this.alfa, s = t, l = 0;
        var h = 0;
        do
          n.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(t / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(s)) / (1 - this.e * Math.sin(s)), this.e / 2)) - this.s45), Math.abs(s - n.y) < 1e-10 && (l = 1), s = n.y, h += 1;
        while (l === 0 && h < 15);
        return h >= 15 ? null : n;
      }
      var Int = ["Krovak", "krovak"];
      const Ent = { init: ynt, forward: mnt, inverse: _nt, names: Int };
      function Qi(n, t, e, i, r) {
        return n * r - t * Math.sin(2 * r) + e * Math.sin(4 * r) - i * Math.sin(6 * r);
      }
      function SA(n) {
        return 1 - 0.25 * n * (1 + n / 16 * (3 + 1.25 * n));
      }
      function bA(n) {
        return 0.375 * n * (1 + 0.25 * n * (1 + 0.46875 * n));
      }
      function BA(n) {
        return 0.05859375 * n * n * (1 + 0.75 * n);
      }
      function TA(n) {
        return n * n * n * (35 / 3072);
      }
      function _f(n, t, e) {
        var i = t * e;
        return n / Math.sqrt(1 - i * i);
      }
      function wl(n) {
        return Math.abs(n) < ut ? n : n - EA(n) * Math.PI;
      }
      function q0(n, t, e, i, r) {
        var a, o;
        a = n / t;
        for (var s = 0; s < 15; s++) if (o = (n - (t * a - e * Math.sin(2 * a) + i * Math.sin(4 * a) - r * Math.sin(6 * a))) / (t - 2 * e * Math.cos(2 * a) + 4 * i * Math.cos(4 * a) - 6 * r * Math.cos(6 * a)), a += o, Math.abs(o) <= 1e-10) return a;
        return NaN;
      }
      function xnt() {
        this.sphere || (this.e0 = SA(this.es), this.e1 = bA(this.es), this.e2 = BA(this.es), this.e3 = TA(this.es), this.ml0 = this.a * Qi(this.e0, this.e1, this.e2, this.e3, this.lat0));
      }
      function wnt(n) {
        var t, e, i = n.x, r = n.y;
        if (i = mt(i - this.long0), this.sphere) t = this.a * Math.asin(Math.cos(r) * Math.sin(i)), e = this.a * (Math.atan2(Math.tan(r), Math.cos(i)) - this.lat0);
        else {
          var a = Math.sin(r), o = Math.cos(r), s = _f(this.a, this.e, a), l = Math.tan(r) * Math.tan(r), u = i * Math.cos(r), h = u * u, c = this.es * o * o / (1 - this.es), f = this.a * Qi(this.e0, this.e1, this.e2, this.e3, r);
          t = s * u * (1 - h * l * (1 / 6 - (8 - l + 8 * c) * h / 120)), e = f - this.ml0 + s * a / o * h * (0.5 + (5 - l + 6 * c) * h / 24);
        }
        return n.x = t + this.x0, n.y = e + this.y0, n;
      }
      function Cnt(n) {
        n.x -= this.x0, n.y -= this.y0;
        var t = n.x / this.a, e = n.y / this.a, i, r;
        if (this.sphere) {
          var a = e + this.lat0;
          i = Math.asin(Math.sin(a) * Math.cos(t)), r = Math.atan2(Math.tan(t), Math.cos(a));
        } else {
          var o = this.ml0 / this.a + e, s = q0(o, this.e0, this.e1, this.e2, this.e3);
          if (Math.abs(Math.abs(s) - ut) <= pt) return n.x = this.long0, n.y = ut, e < 0 && (n.y *= -1), n;
          var l = _f(this.a, this.e, Math.sin(s)), u = l * l * l / this.a / this.a * (1 - this.es), h = Math.pow(Math.tan(s), 2), c = t * this.a / l, f = c * c;
          i = s - l * Math.tan(s) / u * c * c * (0.5 - (1 + 3 * h) * c * c / 24), r = c * (1 - f * (h / 3 + (1 + 3 * h) * h * f / 15)) / Math.cos(s);
        }
        return n.x = mt(r + this.long0), n.y = wl(i), n;
      }
      var Snt = ["Cassini", "Cassini_Soldner", "cass"];
      const bnt = { init: xnt, forward: wnt, inverse: Cnt, names: Snt };
      function Cl(n, t) {
        var e;
        return n > 1e-7 ? (e = n * t, (1 - n * n) * (t / (1 - e * e) - 0.5 / n * Math.log((1 - e) / (1 + e)))) : 2 * t;
      }
      var Bnt = 1, Tnt = 2, Mnt = 3, Dnt = 4;
      function Rnt() {
        var n = Math.abs(this.lat0);
        if (Math.abs(n - ut) < pt ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(n) < pt ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
          var t;
          switch (this.qp = Cl(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = Gnt(this.es), this.mode) {
            case this.N_POLE:
              this.dd = 1;
              break;
            case this.S_POLE:
              this.dd = 1;
              break;
            case this.EQUIT:
              this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
              break;
            case this.OBLIQ:
              this.rq = Math.sqrt(0.5 * this.qp), t = Math.sin(this.lat0), this.sinb1 = Cl(this.e, t) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * t * t) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
              break;
          }
        } else this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
      }
      function Lnt(n) {
        var t, e, i, r, a, o, s, l, u, h, c = n.x, f = n.y;
        if (c = mt(c - this.long0), this.sphere) {
          if (a = Math.sin(f), h = Math.cos(f), i = Math.cos(c), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
            if (e = this.mode === this.EQUIT ? 1 + h * i : 1 + this.sinph0 * a + this.cosph0 * h * i, e <= pt) return null;
            e = Math.sqrt(2 / e), t = e * h * Math.sin(c), e *= this.mode === this.EQUIT ? a : this.cosph0 * a - this.sinph0 * h * i;
          } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
            if (this.mode === this.N_POLE && (i = -i), Math.abs(f + this.lat0) < pt) return null;
            e = He - f * 0.5, e = 2 * (this.mode === this.S_POLE ? Math.cos(e) : Math.sin(e)), t = e * Math.sin(c), e *= i;
          }
        } else {
          switch (s = 0, l = 0, u = 0, i = Math.cos(c), r = Math.sin(c), a = Math.sin(f), o = Cl(this.e, a), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (s = o / this.qp, l = Math.sqrt(1 - s * s)), this.mode) {
            case this.OBLIQ:
              u = 1 + this.sinb1 * s + this.cosb1 * l * i;
              break;
            case this.EQUIT:
              u = 1 + l * i;
              break;
            case this.N_POLE:
              u = ut + f, o = this.qp - o;
              break;
            case this.S_POLE:
              u = f - ut, o = this.qp + o;
              break;
          }
          if (Math.abs(u) < pt) return null;
          switch (this.mode) {
            case this.OBLIQ:
            case this.EQUIT:
              u = Math.sqrt(2 / u), this.mode === this.OBLIQ ? e = this.ymf * u * (this.cosb1 * s - this.sinb1 * l * i) : e = (u = Math.sqrt(2 / (1 + l * i))) * s * this.ymf, t = this.xmf * u * l * r;
              break;
            case this.N_POLE:
            case this.S_POLE:
              o >= 0 ? (t = (u = Math.sqrt(o)) * r, e = i * (this.mode === this.S_POLE ? u : -u)) : t = e = 0;
              break;
          }
        }
        return n.x = this.a * t + this.x0, n.y = this.a * e + this.y0, n;
      }
      function Pnt(n) {
        n.x -= this.x0, n.y -= this.y0;
        var t = n.x / this.a, e = n.y / this.a, i, r, a, o, s, l, u;
        if (this.sphere) {
          var h = 0, c, f = 0;
          if (c = Math.sqrt(t * t + e * e), r = c * 0.5, r > 1) return null;
          switch (r = 2 * Math.asin(r), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (f = Math.sin(r), h = Math.cos(r)), this.mode) {
            case this.EQUIT:
              r = Math.abs(c) <= pt ? 0 : Math.asin(e * f / c), t *= f, e = h * c;
              break;
            case this.OBLIQ:
              r = Math.abs(c) <= pt ? this.lat0 : Math.asin(h * this.sinph0 + e * f * this.cosph0 / c), t *= f * this.cosph0, e = (h - Math.sin(r) * this.sinph0) * c;
              break;
            case this.N_POLE:
              e = -e, r = ut - r;
              break;
            case this.S_POLE:
              r -= ut;
              break;
          }
          i = e === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(t, e);
        } else {
          if (u = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
            if (t /= this.dd, e *= this.dd, l = Math.sqrt(t * t + e * e), l < pt) return n.x = this.long0, n.y = this.lat0, n;
            o = 2 * Math.asin(0.5 * l / this.rq), a = Math.cos(o), t *= o = Math.sin(o), this.mode === this.OBLIQ ? (u = a * this.sinb1 + e * o * this.cosb1 / l, s = this.qp * u, e = l * this.cosb1 * a - e * this.sinb1 * o) : (u = e * o / l, s = this.qp * u, e = l * a);
          } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
            if (this.mode === this.N_POLE && (e = -e), s = t * t + e * e, !s) return n.x = this.long0, n.y = this.lat0, n;
            u = 1 - s / this.qp, this.mode === this.S_POLE && (u = -u);
          }
          i = Math.atan2(t, e), r = Unt(Math.asin(u), this.apa);
        }
        return n.x = mt(this.long0 + i), n.y = r, n;
      }
      var Nnt = 0.3333333333333333, knt = 0.17222222222222222, Fnt = 0.10257936507936508, Qnt = 0.06388888888888888, Ont = 0.0664021164021164, znt = 0.016415012942191543;
      function Gnt(n) {
        var t, e = [];
        return e[0] = n * Nnt, t = n * n, e[0] += t * knt, e[1] = t * Qnt, t *= n, e[0] += t * Fnt, e[1] += t * Ont, e[2] = t * znt, e;
      }
      function Unt(n, t) {
        var e = n + n;
        return n + t[0] * Math.sin(e) + t[1] * Math.sin(e + e) + t[2] * Math.sin(e + e + e);
      }
      var Vnt = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
      const jnt = { init: Rnt, forward: Lnt, inverse: Pnt, names: Vnt, S_POLE: Bnt, N_POLE: Tnt, EQUIT: Mnt, OBLIQ: Dnt };
      function Sl(n) {
        return Math.abs(n) > 1 && (n = n > 1 ? 1 : -1), Math.asin(n);
      }
      function qnt() {
        Math.abs(this.lat1 + this.lat2) < pt || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = fo(this.e3, this.sin_po, this.cos_po), this.qs1 = Cl(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = fo(this.e3, this.sin_po, this.cos_po), this.qs2 = Cl(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = Cl(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > pt ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
      }
      function Hnt(n) {
        var t = n.x, e = n.y;
        this.sin_phi = Math.sin(e), this.cos_phi = Math.cos(e);
        var i = Cl(this.e3, this.sin_phi), r = this.a * Math.sqrt(this.c - this.ns0 * i) / this.ns0, a = this.ns0 * mt(t - this.long0), o = r * Math.sin(a) + this.x0, s = this.rh - r * Math.cos(a) + this.y0;
        return n.x = o, n.y = s, n;
      }
      function Ynt(n) {
        var t, e, i, r, a, o;
        return n.x -= this.x0, n.y = this.rh - n.y + this.y0, this.ns0 >= 0 ? (t = Math.sqrt(n.x * n.x + n.y * n.y), i = 1) : (t = -Math.sqrt(n.x * n.x + n.y * n.y), i = -1), r = 0, t !== 0 && (r = Math.atan2(i * n.x, i * n.y)), i = t * this.ns0 / this.a, this.sphere ? o = Math.asin((this.c - i * i) / (2 * this.ns0)) : (e = (this.c - i * i) / this.ns0, o = this.phi1z(this.e3, e)), a = mt(r / this.ns0 + this.long0), n.x = a, n.y = o, n;
      }
      function Wnt(n, t) {
        var e, i, r, a, o, s = Sl(0.5 * t);
        if (n < pt) return s;
        for (var l = n * n, u = 1; u <= 25; u++) if (e = Math.sin(s), i = Math.cos(s), r = n * e, a = 1 - r * r, o = 0.5 * a * a / i * (t / (1 - l) - e / a + 0.5 / n * Math.log((1 - r) / (1 + r))), s = s + o, Math.abs(o) <= 1e-7) return s;
        return null;
      }
      var Xnt = ["Albers_Conic_Equal_Area", "Albers", "aea"];
      const Znt = { init: qnt, forward: Hnt, inverse: Ynt, names: Xnt, phi1z: Wnt };
      function Knt() {
        this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
      }
      function $nt(n) {
        var t, e, i, r, a, o, s, l, u = n.x, h = n.y;
        return i = mt(u - this.long0), t = Math.sin(h), e = Math.cos(h), r = Math.cos(i), o = this.sin_p14 * t + this.cos_p14 * e * r, a = 1, o > 0 || Math.abs(o) <= pt ? (s = this.x0 + this.a * a * e * Math.sin(i) / o, l = this.y0 + this.a * a * (this.cos_p14 * t - this.sin_p14 * e * r) / o) : (s = this.x0 + this.infinity_dist * e * Math.sin(i), l = this.y0 + this.infinity_dist * (this.cos_p14 * t - this.sin_p14 * e * r)), n.x = s, n.y = l, n;
      }
      function Jnt(n) {
        var t, e, i, r, a, o;
        return n.x = (n.x - this.x0) / this.a, n.y = (n.y - this.y0) / this.a, n.x /= this.k0, n.y /= this.k0, (t = Math.sqrt(n.x * n.x + n.y * n.y)) ? (r = Math.atan2(t, this.rc), e = Math.sin(r), i = Math.cos(r), o = Sl(i * this.sin_p14 + n.y * e * this.cos_p14 / t), a = Math.atan2(n.x * e, t * this.cos_p14 * i - n.y * this.sin_p14 * e), a = mt(this.long0 + a)) : (o = this.phic0, a = 0), n.x = a, n.y = o, n;
      }
      var tit = ["gnom"];
      const eit = { init: Knt, forward: $nt, inverse: Jnt, names: tit };
      function nit(n, t) {
        var e = 1 - (1 - n * n) / (2 * n) * Math.log((1 - n) / (1 + n));
        if (Math.abs(Math.abs(t) - e) < 1e-6) return t < 0 ? -1 * ut : ut;
        for (var i = Math.asin(0.5 * t), r, a, o, s, l = 0; l < 30; l++) if (a = Math.sin(i), o = Math.cos(i), s = n * a, r = Math.pow(1 - s * s, 2) / (2 * o) * (t / (1 - n * n) - a / (1 - s * s) + 0.5 / n * Math.log((1 - s) / (1 + s))), i += r, Math.abs(r) <= 1e-10) return i;
        return NaN;
      }
      function iit() {
        this.sphere || (this.k0 = fo(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
      }
      function rit(n) {
        var t = n.x, e = n.y, i, r, a = mt(t - this.long0);
        if (this.sphere) i = this.x0 + this.a * a * Math.cos(this.lat_ts), r = this.y0 + this.a * Math.sin(e) / Math.cos(this.lat_ts);
        else {
          var o = Cl(this.e, Math.sin(e));
          i = this.x0 + this.a * this.k0 * a, r = this.y0 + this.a * o * 0.5 / this.k0;
        }
        return n.x = i, n.y = r, n;
      }
      function ait(n) {
        n.x -= this.x0, n.y -= this.y0;
        var t, e;
        return this.sphere ? (t = mt(this.long0 + n.x / this.a / Math.cos(this.lat_ts)), e = Math.asin(n.y / this.a * Math.cos(this.lat_ts))) : (e = nit(this.e, 2 * n.y * this.k0 / this.a), t = mt(this.long0 + n.x / (this.a * this.k0))), n.x = t, n.y = e, n;
      }
      var oit = ["cea"];
      const sit = { init: iit, forward: rit, inverse: ait, names: oit };
      function lit() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
      }
      function uit(n) {
        var t = n.x, e = n.y, i = mt(t - this.long0), r = wl(e - this.lat0);
        return n.x = this.x0 + this.a * i * this.rc, n.y = this.y0 + this.a * r, n;
      }
      function hit(n) {
        var t = n.x, e = n.y;
        return n.x = mt(this.long0 + (t - this.x0) / (this.a * this.rc)), n.y = wl(this.lat0 + (e - this.y0) / this.a), n;
      }
      var cit = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
      const fit = { init: lit, forward: uit, inverse: hit, names: cit };
      var jk = 20;
      function git() {
        this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = SA(this.es), this.e1 = bA(this.es), this.e2 = BA(this.es), this.e3 = TA(this.es), this.ml0 = this.a * Qi(this.e0, this.e1, this.e2, this.e3, this.lat0);
      }
      function dit(n) {
        var t = n.x, e = n.y, i, r, a, o = mt(t - this.long0);
        if (a = o * Math.sin(e), this.sphere) Math.abs(e) <= pt ? (i = this.a * o, r = -1 * this.a * this.lat0) : (i = this.a * Math.sin(a) / Math.tan(e), r = this.a * (wl(e - this.lat0) + (1 - Math.cos(a)) / Math.tan(e)));
        else if (Math.abs(e) <= pt) i = this.a * o, r = -1 * this.ml0;
        else {
          var s = _f(this.a, this.e, Math.sin(e)) / Math.tan(e);
          i = s * Math.sin(a), r = this.a * Qi(this.e0, this.e1, this.e2, this.e3, e) - this.ml0 + s * (1 - Math.cos(a));
        }
        return n.x = i + this.x0, n.y = r + this.y0, n;
      }
      function Ait(n) {
        var t, e, i, r, a, o, s, l, u;
        if (i = n.x - this.x0, r = n.y - this.y0, this.sphere) if (Math.abs(r + this.a * this.lat0) <= pt) t = mt(i / this.a + this.long0), e = 0;
        else {
          o = this.lat0 + r / this.a, s = i * i / this.a / this.a + o * o, l = o;
          var h;
          for (a = jk; a; --a) if (h = Math.tan(l), u = -1 * (o * (l * h + 1) - l - 0.5 * (l * l + s) * h) / ((l - o) / h - 1), l += u, Math.abs(u) <= pt) {
            e = l;
            break;
          }
          t = mt(this.long0 + Math.asin(i * Math.tan(l) / this.a) / Math.sin(e));
        }
        else if (Math.abs(r + this.ml0) <= pt) e = 0, t = mt(this.long0 + i / this.a);
        else {
          o = (this.ml0 + r) / this.a, s = i * i / this.a / this.a + o * o, l = o;
          var c, f, g, d, A;
          for (a = jk; a; --a) if (A = this.e * Math.sin(l), c = Math.sqrt(1 - A * A) * Math.tan(l), f = this.a * Qi(this.e0, this.e1, this.e2, this.e3, l), g = this.e0 - 2 * this.e1 * Math.cos(2 * l) + 4 * this.e2 * Math.cos(4 * l) - 6 * this.e3 * Math.cos(6 * l), d = f / this.a, u = (o * (c * d + 1) - d - 0.5 * c * (d * d + s)) / (this.es * Math.sin(2 * l) * (d * d + s - 2 * o * d) / (4 * c) + (o - d) * (c * g - 2 / Math.sin(2 * l)) - g), l -= u, Math.abs(u) <= pt) {
            e = l;
            break;
          }
          c = Math.sqrt(1 - this.es * Math.pow(Math.sin(e), 2)) * Math.tan(e), t = mt(this.long0 + Math.asin(i * c / this.a) / Math.sin(e));
        }
        return n.x = t, n.y = e, n;
      }
      var pit = ["Polyconic", "poly"];
      const vit = { init: git, forward: dit, inverse: Ait, names: pit };
      function yit() {
        this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
      }
      function mit(n) {
        var t, e = n.x, i = n.y, r = i - this.lat0, a = e - this.long0, o = r / mA * 1e-5, s = a, l = 1, u = 0;
        for (t = 1; t <= 10; t++) l = l * o, u = u + this.A[t] * l;
        var h = u, c = s, f = 1, g = 0, d, A, p = 0, v = 0;
        for (t = 1; t <= 6; t++) d = f * h - g * c, A = g * h + f * c, f = d, g = A, p = p + this.B_re[t] * f - this.B_im[t] * g, v = v + this.B_im[t] * f + this.B_re[t] * g;
        return n.x = v * this.a + this.x0, n.y = p * this.a + this.y0, n;
      }
      function _it(n) {
        var t, e = n.x, i = n.y, r = e - this.x0, a = i - this.y0, o = a / this.a, s = r / this.a, l = 1, u = 0, h, c, f = 0, g = 0;
        for (t = 1; t <= 6; t++) h = l * o - u * s, c = u * o + l * s, l = h, u = c, f = f + this.C_re[t] * l - this.C_im[t] * u, g = g + this.C_im[t] * l + this.C_re[t] * u;
        for (var d = 0; d < this.iterations; d++) {
          var A = f, p = g, v, y, m = o, _ = s;
          for (t = 2; t <= 6; t++) v = A * f - p * g, y = p * f + A * g, A = v, p = y, m = m + (t - 1) * (this.B_re[t] * A - this.B_im[t] * p), _ = _ + (t - 1) * (this.B_im[t] * A + this.B_re[t] * p);
          A = 1, p = 0;
          var E = this.B_re[1], I = this.B_im[1];
          for (t = 2; t <= 6; t++) v = A * f - p * g, y = p * f + A * g, A = v, p = y, E = E + t * (this.B_re[t] * A - this.B_im[t] * p), I = I + t * (this.B_im[t] * A + this.B_re[t] * p);
          var x = E * E + I * I;
          f = (m * E + _ * I) / x, g = (_ * E - m * I) / x;
        }
        var w = f, C = g, S = 1, b = 0;
        for (t = 1; t <= 9; t++) S = S * w, b = b + this.D[t] * S;
        var B = this.lat0 + b * mA * 1e5, T = this.long0 + C;
        return n.x = T, n.y = B, n;
      }
      var Iit = ["New_Zealand_Map_Grid", "nzmg"];
      const Eit = { init: yit, forward: mit, inverse: _it, names: Iit };
      function xit() {
      }
      function wit(n) {
        var t = n.x, e = n.y, i = mt(t - this.long0), r = this.x0 + this.a * i, a = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + e / 2.5)) * 1.25;
        return n.x = r, n.y = a, n;
      }
      function Cit(n) {
        n.x -= this.x0, n.y -= this.y0;
        var t = mt(this.long0 + n.x / this.a), e = 2.5 * (Math.atan(Math.exp(0.8 * n.y / this.a)) - Math.PI / 4);
        return n.x = t, n.y = e, n;
      }
      var Sit = ["Miller_Cylindrical", "mill"];
      const bit = { init: xit, forward: wit, inverse: Cit, names: Sit };
      var Bit = 20;
      function Tit() {
        this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = ww(this.es);
      }
      function Mit(n) {
        var t, e, i = n.x, r = n.y;
        if (i = mt(i - this.long0), this.sphere) {
          if (!this.m) r = this.n !== 1 ? Math.asin(this.n * Math.sin(r)) : r;
          else for (var a = this.n * Math.sin(r), o = Bit; o; --o) {
            var s = (this.m * r + Math.sin(r) - a) / (this.m + Math.cos(r));
            if (r -= s, Math.abs(s) < pt) break;
          }
          t = this.a * this.C_x * i * (this.m + Math.cos(r)), e = this.a * this.C_y * r;
        } else {
          var l = Math.sin(r), u = Math.cos(r);
          e = this.a * yf(r, l, u, this.en), t = this.a * i * u / Math.sqrt(1 - this.es * l * l);
        }
        return n.x = t, n.y = e, n;
      }
      function Dit(n) {
        var t, e, i, r;
        return n.x -= this.x0, i = n.x / this.a, n.y -= this.y0, t = n.y / this.a, this.sphere ? (t /= this.C_y, i = i / (this.C_x * (this.m + Math.cos(t))), this.m ? t = Sl((this.m * t + Math.sin(t)) / this.n) : this.n !== 1 && (t = Sl(Math.sin(t) / this.n)), i = mt(i + this.long0), t = wl(t)) : (t = Cw(n.y / this.a, this.es, this.en), r = Math.abs(t), r < ut ? (r = Math.sin(t), e = this.long0 + n.x * Math.sqrt(1 - this.es * r * r) / (this.a * Math.cos(t)), i = mt(e)) : r - pt < ut && (i = this.long0)), n.x = i, n.y = t, n;
      }
      var Rit = ["Sinusoidal", "sinu"];
      const Lit = { init: Tit, forward: Mit, inverse: Dit, names: Rit };
      function Pit() {
      }
      function Nit(n) {
        for (var t = n.x, e = n.y, i = mt(t - this.long0), r = e, a = Math.PI * Math.sin(e); ; ) {
          var o = -(r + Math.sin(r) - a) / (1 + Math.cos(r));
          if (r += o, Math.abs(o) < pt) break;
        }
        r /= 2, Math.PI / 2 - Math.abs(e) < pt && (i = 0);
        var s = 0.900316316158 * this.a * i * Math.cos(r) + this.x0, l = 1.4142135623731 * this.a * Math.sin(r) + this.y0;
        return n.x = s, n.y = l, n;
      }
      function kit(n) {
        var t, e;
        n.x -= this.x0, n.y -= this.y0, e = n.y / (1.4142135623731 * this.a), Math.abs(e) > 0.999999999999 && (e = 0.999999999999), t = Math.asin(e);
        var i = mt(this.long0 + n.x / (0.900316316158 * this.a * Math.cos(t)));
        i < -Math.PI && (i = -Math.PI), i > Math.PI && (i = Math.PI), e = (2 * t + Math.sin(2 * t)) / Math.PI, Math.abs(e) > 1 && (e = 1);
        var r = Math.asin(e);
        return n.x = i, n.y = r, n;
      }
      var Fit = ["Mollweide", "moll"];
      const Qit = { init: Pit, forward: Nit, inverse: kit, names: Fit };
      function Oit() {
        Math.abs(this.lat1 + this.lat2) < pt || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = SA(this.es), this.e1 = bA(this.es), this.e2 = BA(this.es), this.e3 = TA(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = fo(this.e, this.sinphi, this.cosphi), this.ml1 = Qi(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < pt ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = fo(this.e, this.sinphi, this.cosphi), this.ml2 = Qi(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = Qi(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
      }
      function zit(n) {
        var t = n.x, e = n.y, i;
        if (this.sphere) i = this.a * (this.g - e);
        else {
          var r = Qi(this.e0, this.e1, this.e2, this.e3, e);
          i = this.a * (this.g - r);
        }
        var a = this.ns * mt(t - this.long0), o = this.x0 + i * Math.sin(a), s = this.y0 + this.rh - i * Math.cos(a);
        return n.x = o, n.y = s, n;
      }
      function Git(n) {
        n.x -= this.x0, n.y = this.rh - n.y + this.y0;
        var t, e, i, r;
        this.ns >= 0 ? (e = Math.sqrt(n.x * n.x + n.y * n.y), t = 1) : (e = -Math.sqrt(n.x * n.x + n.y * n.y), t = -1);
        var a = 0;
        if (e !== 0 && (a = Math.atan2(t * n.x, t * n.y)), this.sphere) return r = mt(this.long0 + a / this.ns), i = wl(this.g - e / this.a), n.x = r, n.y = i, n;
        var o = this.g - e / this.a;
        return i = q0(o, this.e0, this.e1, this.e2, this.e3), r = mt(this.long0 + a / this.ns), n.x = r, n.y = i, n;
      }
      var Uit = ["Equidistant_Conic", "eqdc"];
      const Vit = { init: Oit, forward: zit, inverse: Git, names: Uit };
      function jit() {
        this.R = this.a;
      }
      function qit(n) {
        var t = n.x, e = n.y, i = mt(t - this.long0), r, a;
        Math.abs(e) <= pt && (r = this.x0 + this.R * i, a = this.y0);
        var o = Sl(2 * Math.abs(e / Math.PI));
        (Math.abs(i) <= pt || Math.abs(Math.abs(e) - ut) <= pt) && (r = this.x0, e >= 0 ? a = this.y0 + Math.PI * this.R * Math.tan(0.5 * o) : a = this.y0 + Math.PI * this.R * -Math.tan(0.5 * o));
        var s = 0.5 * Math.abs(Math.PI / i - i / Math.PI), l = s * s, u = Math.sin(o), h = Math.cos(o), c = h / (u + h - 1), f = c * c, g = c * (2 / u - 1), d = g * g, A = Math.PI * this.R * (s * (c - d) + Math.sqrt(l * (c - d) * (c - d) - (d + l) * (f - d))) / (d + l);
        i < 0 && (A = -A), r = this.x0 + A;
        var p = l + c;
        return A = Math.PI * this.R * (g * p - s * Math.sqrt((d + l) * (l + 1) - p * p)) / (d + l), e >= 0 ? a = this.y0 + A : a = this.y0 - A, n.x = r, n.y = a, n;
      }
      function Hit(n) {
        var t, e, i, r, a, o, s, l, u, h, c, f, g;
        return n.x -= this.x0, n.y -= this.y0, c = Math.PI * this.R, i = n.x / c, r = n.y / c, a = i * i + r * r, o = -Math.abs(r) * (1 + a), s = o - 2 * r * r + i * i, l = -2 * o + 1 + 2 * r * r + a * a, g = r * r / l + (2 * s * s * s / l / l / l - 9 * o * s / l / l) / 27, u = (o - s * s / 3 / l) / l, h = 2 * Math.sqrt(-u / 3), c = 3 * g / u / h, Math.abs(c) > 1 && (c >= 0 ? c = 1 : c = -1), f = Math.acos(c) / 3, n.y >= 0 ? e = (-h * Math.cos(f + Math.PI / 3) - s / 3 / l) * Math.PI : e = -(-h * Math.cos(f + Math.PI / 3) - s / 3 / l) * Math.PI, Math.abs(i) < pt ? t = this.long0 : t = mt(this.long0 + Math.PI * (a - 1 + Math.sqrt(1 + 2 * (i * i - r * r) + a * a)) / 2 / i), n.x = t, n.y = e, n;
      }
      var Yit = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
      const Wit = { init: jit, forward: qit, inverse: Hit, names: Yit };
      function Xit() {
        this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
      }
      function Zit(n) {
        var t = n.x, e = n.y, i = Math.sin(n.y), r = Math.cos(n.y), a = mt(t - this.long0), o, s, l, u, h, c, f, g, d, A, p, v, y, m, _, E, I, x, w, C, S, b, B;
        return this.sphere ? Math.abs(this.sin_p12 - 1) <= pt ? (n.x = this.x0 + this.a * (ut - e) * Math.sin(a), n.y = this.y0 - this.a * (ut - e) * Math.cos(a), n) : Math.abs(this.sin_p12 + 1) <= pt ? (n.x = this.x0 + this.a * (ut + e) * Math.sin(a), n.y = this.y0 + this.a * (ut + e) * Math.cos(a), n) : (x = this.sin_p12 * i + this.cos_p12 * r * Math.cos(a), E = Math.acos(x), I = E ? E / Math.sin(E) : 1, n.x = this.x0 + this.a * I * r * Math.sin(a), n.y = this.y0 + this.a * I * (this.cos_p12 * i - this.sin_p12 * r * Math.cos(a)), n) : (o = SA(this.es), s = bA(this.es), l = BA(this.es), u = TA(this.es), Math.abs(this.sin_p12 - 1) <= pt ? (h = this.a * Qi(o, s, l, u, ut), c = this.a * Qi(o, s, l, u, e), n.x = this.x0 + (h - c) * Math.sin(a), n.y = this.y0 - (h - c) * Math.cos(a), n) : Math.abs(this.sin_p12 + 1) <= pt ? (h = this.a * Qi(o, s, l, u, ut), c = this.a * Qi(o, s, l, u, e), n.x = this.x0 + (h + c) * Math.sin(a), n.y = this.y0 + (h + c) * Math.cos(a), n) : (f = i / r, g = _f(this.a, this.e, this.sin_p12), d = _f(this.a, this.e, i), A = Math.atan((1 - this.es) * f + this.es * g * this.sin_p12 / (d * r)), p = Math.atan2(Math.sin(a), this.cos_p12 * Math.tan(A) - this.sin_p12 * Math.cos(a)), p === 0 ? w = Math.asin(this.cos_p12 * Math.sin(A) - this.sin_p12 * Math.cos(A)) : Math.abs(Math.abs(p) - Math.PI) <= pt ? w = -Math.asin(this.cos_p12 * Math.sin(A) - this.sin_p12 * Math.cos(A)) : w = Math.asin(Math.sin(a) * Math.cos(A) / Math.sin(p)), v = this.e * this.sin_p12 / Math.sqrt(1 - this.es), y = this.e * this.cos_p12 * Math.cos(p) / Math.sqrt(1 - this.es), m = v * y, _ = y * y, C = w * w, S = C * w, b = S * w, B = b * w, E = g * w * (1 - C * _ * (1 - _) / 6 + S / 8 * m * (1 - 2 * _) + b / 120 * (_ * (4 - 7 * _) - 3 * v * v * (1 - 7 * _)) - B / 48 * m), n.x = this.x0 + E * Math.sin(p), n.y = this.y0 + E * Math.cos(p), n));
      }
      function Kit(n) {
        n.x -= this.x0, n.y -= this.y0;
        var t, e, i, r, a, o, s, l, u, h, c, f, g, d, A, p, v, y, m, _, E, I, x, w;
        return this.sphere ? (t = Math.sqrt(n.x * n.x + n.y * n.y), t > 2 * ut * this.a ? void 0 : (e = t / this.a, i = Math.sin(e), r = Math.cos(e), a = this.long0, Math.abs(t) <= pt ? o = this.lat0 : (o = Sl(r * this.sin_p12 + n.y * i * this.cos_p12 / t), s = Math.abs(this.lat0) - ut, Math.abs(s) <= pt ? this.lat0 >= 0 ? a = mt(this.long0 + Math.atan2(n.x, -n.y)) : a = mt(this.long0 - Math.atan2(-n.x, n.y)) : a = mt(this.long0 + Math.atan2(n.x * i, t * this.cos_p12 * r - n.y * this.sin_p12 * i))), n.x = a, n.y = o, n)) : (l = SA(this.es), u = bA(this.es), h = BA(this.es), c = TA(this.es), Math.abs(this.sin_p12 - 1) <= pt ? (f = this.a * Qi(l, u, h, c, ut), t = Math.sqrt(n.x * n.x + n.y * n.y), g = f - t, o = q0(g / this.a, l, u, h, c), a = mt(this.long0 + Math.atan2(n.x, -1 * n.y)), n.x = a, n.y = o, n) : Math.abs(this.sin_p12 + 1) <= pt ? (f = this.a * Qi(l, u, h, c, ut), t = Math.sqrt(n.x * n.x + n.y * n.y), g = t - f, o = q0(g / this.a, l, u, h, c), a = mt(this.long0 + Math.atan2(n.x, n.y)), n.x = a, n.y = o, n) : (t = Math.sqrt(n.x * n.x + n.y * n.y), p = Math.atan2(n.x, n.y), d = _f(this.a, this.e, this.sin_p12), v = Math.cos(p), y = this.e * this.cos_p12 * v, m = -y * y / (1 - this.es), _ = 3 * this.es * (1 - m) * this.sin_p12 * this.cos_p12 * v / (1 - this.es), E = t / d, I = E - m * (1 + m) * Math.pow(E, 3) / 6 - _ * (1 + 3 * m) * Math.pow(E, 4) / 24, x = 1 - m * I * I / 2 - E * I * I * I / 6, A = Math.asin(this.sin_p12 * Math.cos(I) + this.cos_p12 * Math.sin(I) * v), a = mt(this.long0 + Math.asin(Math.sin(p) * Math.sin(I) / Math.cos(A))), w = Math.sin(A), o = Math.atan2((w - this.es * x * this.sin_p12) * Math.tan(A), w * (1 - this.es)), n.x = a, n.y = o, n));
      }
      var $it = ["Azimuthal_Equidistant", "aeqd"];
      const Jit = { init: Xit, forward: Zit, inverse: Kit, names: $it };
      function trt() {
        this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
      }
      function ert(n) {
        var t, e, i, r, a, o, s, l, u = n.x, h = n.y;
        return i = mt(u - this.long0), t = Math.sin(h), e = Math.cos(h), r = Math.cos(i), o = this.sin_p14 * t + this.cos_p14 * e * r, a = 1, (o > 0 || Math.abs(o) <= pt) && (s = this.a * a * e * Math.sin(i), l = this.y0 + this.a * a * (this.cos_p14 * t - this.sin_p14 * e * r)), n.x = s, n.y = l, n;
      }
      function nrt(n) {
        var t, e, i, r, a, o, s;
        return n.x -= this.x0, n.y -= this.y0, t = Math.sqrt(n.x * n.x + n.y * n.y), e = Sl(t / this.a), i = Math.sin(e), r = Math.cos(e), o = this.long0, Math.abs(t) <= pt ? (s = this.lat0, n.x = o, n.y = s, n) : (s = Sl(r * this.sin_p14 + n.y * i * this.cos_p14 / t), a = Math.abs(this.lat0) - ut, Math.abs(a) <= pt ? (this.lat0 >= 0 ? o = mt(this.long0 + Math.atan2(n.x, -n.y)) : o = mt(this.long0 - Math.atan2(-n.x, n.y)), n.x = o, n.y = s, n) : (o = mt(this.long0 + Math.atan2(n.x * i, t * this.cos_p14 * r - n.y * this.sin_p14 * i)), n.x = o, n.y = s, n));
      }
      var irt = ["ortho"];
      const rrt = { init: trt, forward: ert, inverse: nrt, names: irt };
      var An = { FRONT: 1, RIGHT: 2, BACK: 3, LEFT: 4, TOP: 5, BOTTOM: 6 }, Ye = { AREA_0: 1, AREA_1: 2, AREA_2: 3, AREA_3: 4 };
      function art() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= ut - He / 2 ? this.face = An.TOP : this.lat0 <= -(ut - He / 2) ? this.face = An.BOTTOM : Math.abs(this.long0) <= He ? this.face = An.FRONT : Math.abs(this.long0) <= ut + He ? this.face = this.long0 > 0 ? An.RIGHT : An.LEFT : this.face = An.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
      }
      function ort(n) {
        var t = { x: 0, y: 0 }, e, i, r, a, o, s, l = { value: 0 };
        if (n.x -= this.long0, this.es !== 0 ? e = Math.atan(this.one_minus_f_squared * Math.tan(n.y)) : e = n.y, i = n.x, this.face === An.TOP) a = ut - e, i >= He && i <= ut + He ? (l.value = Ye.AREA_0, r = i - ut) : i > ut + He || i <= -(ut + He) ? (l.value = Ye.AREA_1, r = i > 0 ? i - Bn : i + Bn) : i > -(ut + He) && i <= -He ? (l.value = Ye.AREA_2, r = i + ut) : (l.value = Ye.AREA_3, r = i);
        else if (this.face === An.BOTTOM) a = ut + e, i >= He && i <= ut + He ? (l.value = Ye.AREA_0, r = -i + ut) : i < He && i >= -He ? (l.value = Ye.AREA_1, r = -i) : i < -He && i >= -(ut + He) ? (l.value = Ye.AREA_2, r = -i - ut) : (l.value = Ye.AREA_3, r = i > 0 ? -i + Bn : -i - Bn);
        else {
          var u, h, c, f, g, d, A;
          this.face === An.RIGHT ? i = If(i, +ut) : this.face === An.BACK ? i = If(i, +Bn) : this.face === An.LEFT && (i = If(i, -ut)), f = Math.sin(e), g = Math.cos(e), d = Math.sin(i), A = Math.cos(i), u = g * A, h = g * d, c = f, this.face === An.FRONT ? (a = Math.acos(u), r = H0(a, c, h, l)) : this.face === An.RIGHT ? (a = Math.acos(h), r = H0(a, c, -u, l)) : this.face === An.BACK ? (a = Math.acos(-u), r = H0(a, c, -h, l)) : this.face === An.LEFT ? (a = Math.acos(-h), r = H0(a, c, u, l)) : (a = r = 0, l.value = Ye.AREA_0);
        }
        return s = Math.atan(12 / Bn * (r + Math.acos(Math.sin(r) * Math.cos(He)) - ut)), o = Math.sqrt((1 - Math.cos(a)) / (Math.cos(s) * Math.cos(s)) / (1 - Math.cos(Math.atan(1 / Math.cos(r))))), l.value === Ye.AREA_1 ? s += ut : l.value === Ye.AREA_2 ? s += Bn : l.value === Ye.AREA_3 && (s += 1.5 * Bn), t.x = o * Math.cos(s), t.y = o * Math.sin(s), t.x = t.x * this.a + this.x0, t.y = t.y * this.a + this.y0, n.x = t.x, n.y = t.y, n;
      }
      function srt(n) {
        var t = { lam: 0, phi: 0 }, e, i, r, a, o, s, l, u, h, c = { value: 0 };
        if (n.x = (n.x - this.x0) / this.a, n.y = (n.y - this.y0) / this.a, i = Math.atan(Math.sqrt(n.x * n.x + n.y * n.y)), e = Math.atan2(n.y, n.x), n.x >= 0 && n.x >= Math.abs(n.y) ? c.value = Ye.AREA_0 : n.y >= 0 && n.y >= Math.abs(n.x) ? (c.value = Ye.AREA_1, e -= ut) : n.x < 0 && -n.x >= Math.abs(n.y) ? (c.value = Ye.AREA_2, e = e < 0 ? e + Bn : e - Bn) : (c.value = Ye.AREA_3, e += ut), h = Bn / 12 * Math.tan(e), o = Math.sin(h) / (Math.cos(h) - 1 / Math.sqrt(2)), s = Math.atan(o), r = Math.cos(e), a = Math.tan(i), l = 1 - r * r * a * a * (1 - Math.cos(Math.atan(1 / Math.cos(s)))), l < -1 ? l = -1 : l > 1 && (l = 1), this.face === An.TOP) u = Math.acos(l), t.phi = ut - u, c.value === Ye.AREA_0 ? t.lam = s + ut : c.value === Ye.AREA_1 ? t.lam = s < 0 ? s + Bn : s - Bn : c.value === Ye.AREA_2 ? t.lam = s - ut : t.lam = s;
        else if (this.face === An.BOTTOM) u = Math.acos(l), t.phi = u - ut, c.value === Ye.AREA_0 ? t.lam = -s + ut : c.value === Ye.AREA_1 ? t.lam = -s : c.value === Ye.AREA_2 ? t.lam = -s - ut : t.lam = s < 0 ? -s - Bn : -s + Bn;
        else {
          var f, g, d;
          f = l, h = f * f, h >= 1 ? d = 0 : d = Math.sqrt(1 - h) * Math.sin(s), h += d * d, h >= 1 ? g = 0 : g = Math.sqrt(1 - h), c.value === Ye.AREA_1 ? (h = g, g = -d, d = h) : c.value === Ye.AREA_2 ? (g = -g, d = -d) : c.value === Ye.AREA_3 && (h = g, g = d, d = -h), this.face === An.RIGHT ? (h = f, f = -g, g = h) : this.face === An.BACK ? (f = -f, g = -g) : this.face === An.LEFT && (h = f, f = g, g = -h), t.phi = Math.acos(-d) - ut, t.lam = Math.atan2(g, f), this.face === An.RIGHT ? t.lam = If(t.lam, -ut) : this.face === An.BACK ? t.lam = If(t.lam, -Bn) : this.face === An.LEFT && (t.lam = If(t.lam, +ut));
        }
        if (this.es !== 0) {
          var A, p, v;
          A = t.phi < 0 ? 1 : 0, p = Math.tan(t.phi), v = this.b / Math.sqrt(p * p + this.one_minus_f_squared), t.phi = Math.atan(Math.sqrt(this.a * this.a - v * v) / (this.one_minus_f * v)), A && (t.phi = -t.phi);
        }
        return t.lam += this.long0, n.x = t.lam, n.y = t.phi, n;
      }
      function H0(n, t, e, i) {
        var r;
        return n < pt ? (i.value = Ye.AREA_0, r = 0) : (r = Math.atan2(t, e), Math.abs(r) <= He ? i.value = Ye.AREA_0 : r > He && r <= ut + He ? (i.value = Ye.AREA_1, r -= ut) : r > ut + He || r <= -(ut + He) ? (i.value = Ye.AREA_2, r = r >= 0 ? r - Bn : r + Bn) : (i.value = Ye.AREA_3, r += ut)), r;
      }
      function If(n, t) {
        var e = n + t;
        return e < -Bn ? e += _A : e > +Bn && (e -= _A), e;
      }
      var lrt = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
      const urt = { init: art, forward: ort, inverse: srt, names: lrt };
      var Tw = [[1, 22199e-21, -715515e-10, 31103e-10], [0.9986, -482243e-9, -24897e-9, -13309e-10], [0.9954, -83103e-8, -448605e-10, -986701e-12], [0.99, -135364e-8, -59661e-9, 36777e-10], [0.9822, -167442e-8, -449547e-11, -572411e-11], [0.973, -214868e-8, -903571e-10, 18736e-12], [0.96, -305085e-8, -900761e-10, 164917e-11], [0.9427, -382792e-8, -653386e-10, -26154e-10], [0.9216, -467746e-8, -10457e-8, 481243e-11], [0.8962, -536223e-8, -323831e-10, -543432e-11], [0.8679, -609363e-8, -113898e-9, 332484e-11], [0.835, -698325e-8, -640253e-10, 934959e-12], [0.7986, -755338e-8, -500009e-10, 935324e-12], [0.7597, -798324e-8, -35971e-9, -227626e-11], [0.7186, -851367e-8, -701149e-10, -86303e-10], [0.6732, -986209e-8, -199569e-9, 191974e-10], [0.6213, -0.010418, 883923e-10, 624051e-11], [0.5722, -906601e-8, 182e-6, 624051e-11], [0.5322, -677797e-8, 275608e-9, 624051e-11]], MA = [[-520417e-23, 0.0124, 121431e-23, -845284e-16], [0.062, 0.0124, -126793e-14, 422642e-15], [0.124, 0.0124, 507171e-14, -160604e-14], [0.186, 0.0123999, -190189e-13, 600152e-14], [0.248, 0.0124002, 710039e-13, -224e-10], [0.31, 0.0123992, -264997e-12, 835986e-13], [0.372, 0.0124029, 988983e-12, -311994e-12], [0.434, 0.0123893, -369093e-11, -435621e-12], [0.4958, 0.0123198, -102252e-10, -345523e-12], [0.5571, 0.0121916, -154081e-10, -582288e-12], [0.6176, 0.0119938, -241424e-10, -525327e-12], [0.6769, 0.011713, -320223e-10, -516405e-12], [0.7346, 0.0113541, -397684e-10, -609052e-12], [0.7903, 0.0109107, -489042e-10, -104739e-11], [0.8435, 0.0103431, -64615e-9, -140374e-14], [0.8936, 969686e-8, -64636e-9, -8547e-9], [0.9394, 840947e-8, -192841e-9, -42106e-10], [0.9761, 616527e-8, -256e-6, -42106e-10], [1, 328947e-8, -319159e-9, -42106e-10]], qk = 0.8487, Hk = 1.3523, Yk = El / 5, hrt = 1 / Yk, Ef = 18, Y0 = function(n, t) {
        return n[0] + t * (n[1] + t * (n[2] + t * n[3]));
      }, crt = function(n, t) {
        return n[1] + t * (2 * n[2] + t * 3 * n[3]);
      };
      function frt(n, t, e, i) {
        for (var r = t; i; --i) {
          var a = n(r);
          if (r -= a, Math.abs(a) < e) break;
        }
        return r;
      }
      function grt() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
      }
      function drt(n) {
        var t = mt(n.x - this.long0), e = Math.abs(n.y), i = Math.floor(e * Yk);
        i < 0 ? i = 0 : i >= Ef && (i = Ef - 1), e = El * (e - hrt * i);
        var r = { x: Y0(Tw[i], e) * t, y: Y0(MA[i], e) };
        return n.y < 0 && (r.y = -r.y), r.x = r.x * this.a * qk + this.x0, r.y = r.y * this.a * Hk + this.y0, r;
      }
      function Art(n) {
        var t = { x: (n.x - this.x0) / (this.a * qk), y: Math.abs(n.y - this.y0) / (this.a * Hk) };
        if (t.y >= 1) t.x /= Tw[Ef][0], t.y = n.y < 0 ? -ut : ut;
        else {
          var e = Math.floor(t.y * Ef);
          for (e < 0 ? e = 0 : e >= Ef && (e = Ef - 1); ; ) if (MA[e][0] > t.y) --e;
          else if (MA[e + 1][0] <= t.y) ++e;
          else break;
          var i = MA[e], r = 5 * (t.y - i[0]) / (MA[e + 1][0] - i[0]);
          r = frt(function(a) {
            return (Y0(i, a) - t.y) / crt(i, a);
          }, r, pt, 100), t.x /= Y0(Tw[e], r), t.y = (5 * e + r) * fi, n.y < 0 && (t.y = -t.y);
        }
        return t.x = mt(t.x + this.long0), t;
      }
      var prt = ["Robinson", "robin"];
      const vrt = { init: grt, forward: drt, inverse: Art, names: prt };
      function yrt() {
        this.name = "geocent";
      }
      function mrt(n) {
        var t = Ek(n, this.es, this.a);
        return t;
      }
      function _rt(n) {
        var t = xk(n, this.es, this.a, this.b);
        return t;
      }
      var Irt = ["Geocentric", "geocentric", "geocent", "Geocent"];
      const Ert = { init: yrt, forward: mrt, inverse: _rt, names: Irt };
      var Bi = { N_POLE: 0, S_POLE: 1, EQUIT: 2, OBLIQ: 3 }, DA = { h: { def: 1e5, num: true }, azi: { def: 0, num: true, degrees: true }, tilt: { def: 0, num: true, degrees: true }, long0: { def: 0, num: true }, lat0: { def: 0, num: true } };
      function xrt() {
        if (Object.keys(DA).forEach((function(e) {
          if (typeof this[e] == "undefined") this[e] = DA[e].def;
          else {
            if (DA[e].num && isNaN(this[e])) throw new Error("Invalid parameter value, must be numeric " + e + " = " + this[e]);
            DA[e].num && (this[e] = parseFloat(this[e]));
          }
          DA[e].degrees && (this[e] = this[e] * fi);
        }).bind(this)), Math.abs(Math.abs(this.lat0) - ut) < pt ? this.mode = this.lat0 < 0 ? Bi.S_POLE : Bi.N_POLE : Math.abs(this.lat0) < pt ? this.mode = Bi.EQUIT : (this.mode = Bi.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10) throw new Error("Invalid height");
        this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
        var n = this.tilt, t = this.azi;
        this.cg = Math.cos(t), this.sg = Math.sin(t), this.cw = Math.cos(n), this.sw = Math.sin(n);
      }
      function wrt(n) {
        n.x -= this.long0;
        var t = Math.sin(n.y), e = Math.cos(n.y), i = Math.cos(n.x), r, a;
        switch (this.mode) {
          case Bi.OBLIQ:
            a = this.sinph0 * t + this.cosph0 * e * i;
            break;
          case Bi.EQUIT:
            a = e * i;
            break;
          case Bi.S_POLE:
            a = -t;
            break;
          case Bi.N_POLE:
            a = t;
            break;
        }
        switch (a = this.pn1 / (this.p - a), r = a * e * Math.sin(n.x), this.mode) {
          case Bi.OBLIQ:
            a *= this.cosph0 * t - this.sinph0 * e * i;
            break;
          case Bi.EQUIT:
            a *= t;
            break;
          case Bi.N_POLE:
            a *= -(e * i);
            break;
          case Bi.S_POLE:
            a *= e * i;
            break;
        }
        var o, s;
        return o = a * this.cg + r * this.sg, s = 1 / (o * this.sw * this.h1 + this.cw), r = (r * this.cg - a * this.sg) * this.cw * s, a = o * s, n.x = r * this.a, n.y = a * this.a, n;
      }
      function Crt(n) {
        n.x /= this.a, n.y /= this.a;
        var t = { x: n.x, y: n.y }, e, i, r;
        r = 1 / (this.pn1 - n.y * this.sw), e = this.pn1 * n.x * r, i = this.pn1 * n.y * this.cw * r, n.x = e * this.cg + i * this.sg, n.y = i * this.cg - e * this.sg;
        var a = hr(n.x, n.y);
        if (Math.abs(a) < pt) t.x = 0, t.y = n.y;
        else {
          var o, s;
          switch (s = 1 - a * a * this.pfact, s = (this.p - Math.sqrt(s)) / (this.pn1 / a + a / this.pn1), o = Math.sqrt(1 - s * s), this.mode) {
            case Bi.OBLIQ:
              t.y = Math.asin(o * this.sinph0 + n.y * s * this.cosph0 / a), n.y = (o - this.sinph0 * Math.sin(t.y)) * a, n.x *= s * this.cosph0;
              break;
            case Bi.EQUIT:
              t.y = Math.asin(n.y * s / a), n.y = o * a, n.x *= s;
              break;
            case Bi.N_POLE:
              t.y = Math.asin(o), n.y = -n.y;
              break;
            case Bi.S_POLE:
              t.y = -Math.asin(o);
              break;
          }
          t.x = Math.atan2(n.x, n.y);
        }
        return n.x = t.x + this.long0, n.y = t.y, n;
      }
      var Srt = ["Tilted_Perspective", "tpers"];
      const brt = { init: xrt, forward: wrt, inverse: Crt, names: Srt };
      function Brt() {
        if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) throw new Error();
        if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
          var n = 1 - this.es, t = 1 / n;
          this.radius_p = Math.sqrt(n), this.radius_p2 = n, this.radius_p_inv2 = t, this.shape = "ellipse";
        } else this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
        this.title || (this.title = "Geostationary Satellite View");
      }
      function Trt(n) {
        var t = n.x, e = n.y, i, r, a, o;
        if (t = t - this.long0, this.shape === "ellipse") {
          e = Math.atan(this.radius_p2 * Math.tan(e));
          var s = this.radius_p / hr(this.radius_p * Math.cos(e), Math.sin(e));
          if (r = s * Math.cos(t) * Math.cos(e), a = s * Math.sin(t) * Math.cos(e), o = s * Math.sin(e), (this.radius_g - r) * r - a * a - o * o * this.radius_p_inv2 < 0) return n.x = Number.NaN, n.y = Number.NaN, n;
          i = this.radius_g - r, this.flip_axis ? (n.x = this.radius_g_1 * Math.atan(a / hr(o, i)), n.y = this.radius_g_1 * Math.atan(o / i)) : (n.x = this.radius_g_1 * Math.atan(a / i), n.y = this.radius_g_1 * Math.atan(o / hr(a, i)));
        } else this.shape === "sphere" && (i = Math.cos(e), r = Math.cos(t) * i, a = Math.sin(t) * i, o = Math.sin(e), i = this.radius_g - r, this.flip_axis ? (n.x = this.radius_g_1 * Math.atan(a / hr(o, i)), n.y = this.radius_g_1 * Math.atan(o / i)) : (n.x = this.radius_g_1 * Math.atan(a / i), n.y = this.radius_g_1 * Math.atan(o / hr(a, i))));
        return n.x = n.x * this.a, n.y = n.y * this.a, n;
      }
      function Mrt(n) {
        var t = -1, e = 0, i = 0, r, a, o, s;
        if (n.x = n.x / this.a, n.y = n.y / this.a, this.shape === "ellipse") {
          this.flip_axis ? (i = Math.tan(n.y / this.radius_g_1), e = Math.tan(n.x / this.radius_g_1) * hr(1, i)) : (e = Math.tan(n.x / this.radius_g_1), i = Math.tan(n.y / this.radius_g_1) * hr(1, e));
          var l = i / this.radius_p;
          if (r = e * e + l * l + t * t, a = 2 * this.radius_g * t, o = a * a - 4 * r * this.C, o < 0) return n.x = Number.NaN, n.y = Number.NaN, n;
          s = (-a - Math.sqrt(o)) / (2 * r), t = this.radius_g + s * t, e *= s, i *= s, n.x = Math.atan2(e, t), n.y = Math.atan(i * Math.cos(n.x) / t), n.y = Math.atan(this.radius_p_inv2 * Math.tan(n.y));
        } else if (this.shape === "sphere") {
          if (this.flip_axis ? (i = Math.tan(n.y / this.radius_g_1), e = Math.tan(n.x / this.radius_g_1) * Math.sqrt(1 + i * i)) : (e = Math.tan(n.x / this.radius_g_1), i = Math.tan(n.y / this.radius_g_1) * Math.sqrt(1 + e * e)), r = e * e + i * i + t * t, a = 2 * this.radius_g * t, o = a * a - 4 * r * this.C, o < 0) return n.x = Number.NaN, n.y = Number.NaN, n;
          s = (-a - Math.sqrt(o)) / (2 * r), t = this.radius_g + s * t, e *= s, i *= s, n.x = Math.atan2(e, t), n.y = Math.atan(i * Math.cos(n.x) / t);
        }
        return n.x = n.x + this.long0, n;
      }
      var Drt = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
      const Rrt = { init: Brt, forward: Trt, inverse: Mrt, names: Drt };
      var RA = 1.340264, LA = -0.081106, PA = 893e-6, NA = 3796e-6, W0 = Math.sqrt(3) / 2;
      function Lrt() {
        this.es = 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0;
      }
      function Prt(n) {
        var t = mt(n.x - this.long0), e = n.y, i = Math.asin(W0 * Math.sin(e)), r = i * i, a = r * r * r;
        return n.x = t * Math.cos(i) / (W0 * (RA + 3 * LA * r + a * (7 * PA + 9 * NA * r))), n.y = i * (RA + LA * r + a * (PA + NA * r)), n.x = this.a * n.x + this.x0, n.y = this.a * n.y + this.y0, n;
      }
      function Nrt(n) {
        n.x = (n.x - this.x0) / this.a, n.y = (n.y - this.y0) / this.a;
        var t = 1e-9, e = 12, i = n.y, r, a, o, s, l, u;
        for (u = 0; u < e && (r = i * i, a = r * r * r, o = i * (RA + LA * r + a * (PA + NA * r)) - n.y, s = RA + 3 * LA * r + a * (7 * PA + 9 * NA * r), i -= l = o / s, !(Math.abs(l) < t)); ++u) ;
        return r = i * i, a = r * r * r, n.x = W0 * n.x * (RA + 3 * LA * r + a * (7 * PA + 9 * NA * r)) / Math.cos(i), n.y = Math.asin(Math.sin(i) / W0), n.x = mt(n.x + this.long0), n;
      }
      var krt = ["eqearth", "Equal Earth", "Equal_Earth"];
      const Frt = { init: Lrt, forward: Prt, inverse: Nrt, names: krt };
      var kA = 1e-10;
      function Qrt() {
        var n;
        if (this.phi1 = this.lat1, Math.abs(this.phi1) < kA) throw new Error();
        this.es ? (this.en = ww(this.es), this.m1 = yf(this.phi1, this.am1 = Math.sin(this.phi1), n = Math.cos(this.phi1), this.en), this.am1 = n / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1), this.inverse = zrt, this.forward = Ort) : (Math.abs(this.phi1) + kA >= ut ? this.cphi1 = 0 : this.cphi1 = 1 / Math.tan(this.phi1), this.inverse = Urt, this.forward = Grt);
      }
      function Ort(n) {
        var t = mt(n.x - (this.long0 || 0)), e = n.y, i, r, a;
        return i = this.am1 + this.m1 - yf(e, r = Math.sin(e), a = Math.cos(e), this.en), r = a * t / (i * Math.sqrt(1 - this.es * r * r)), n.x = i * Math.sin(r), n.y = this.am1 - i * Math.cos(r), n.x = this.a * n.x + (this.x0 || 0), n.y = this.a * n.y + (this.y0 || 0), n;
      }
      function zrt(n) {
        n.x = (n.x - (this.x0 || 0)) / this.a, n.y = (n.y - (this.y0 || 0)) / this.a;
        var t, e, i, r;
        if (e = hr(n.x, n.y = this.am1 - n.y), r = Cw(this.am1 + this.m1 - e, this.es, this.en), (t = Math.abs(r)) < ut) t = Math.sin(r), i = e * Math.atan2(n.x, n.y) * Math.sqrt(1 - this.es * t * t) / Math.cos(r);
        else if (Math.abs(t - ut) <= kA) i = 0;
        else throw new Error();
        return n.x = mt(i + (this.long0 || 0)), n.y = wl(r), n;
      }
      function Grt(n) {
        var t = mt(n.x - (this.long0 || 0)), e = n.y, i, r;
        return r = this.cphi1 + this.phi1 - e, Math.abs(r) > kA ? (n.x = r * Math.sin(i = t * Math.cos(e) / r), n.y = this.cphi1 - r * Math.cos(i)) : n.x = n.y = 0, n.x = this.a * n.x + (this.x0 || 0), n.y = this.a * n.y + (this.y0 || 0), n;
      }
      function Urt(n) {
        n.x = (n.x - (this.x0 || 0)) / this.a, n.y = (n.y - (this.y0 || 0)) / this.a;
        var t, e, i = hr(n.x, n.y = this.cphi1 - n.y);
        if (e = this.cphi1 + this.phi1 - i, Math.abs(e) > ut) throw new Error();
        return Math.abs(Math.abs(e) - ut) <= kA ? t = 0 : t = i * Math.atan2(n.x, n.y) / Math.cos(e), n.x = mt(t + (this.long0 || 0)), n.y = wl(e), n;
      }
      var Vrt = ["bonne", "Bonne (Werner lat_1=90)"];
      const jrt = { init: Qrt, names: Vrt };
      function qrt(n) {
        n.Proj.projections.add(V0), n.Proj.projections.add(j0), n.Proj.projections.add(Oet), n.Proj.projections.add(Xet), n.Proj.projections.add(ent), n.Proj.projections.add(ont), n.Proj.projections.add(fnt), n.Proj.projections.add(vnt), n.Proj.projections.add(Ent), n.Proj.projections.add(bnt), n.Proj.projections.add(jnt), n.Proj.projections.add(Znt), n.Proj.projections.add(eit), n.Proj.projections.add(sit), n.Proj.projections.add(fit), n.Proj.projections.add(vit), n.Proj.projections.add(Eit), n.Proj.projections.add(bit), n.Proj.projections.add(Lit), n.Proj.projections.add(Qit), n.Proj.projections.add(Vit), n.Proj.projections.add(Wit), n.Proj.projections.add(Jit), n.Proj.projections.add(rrt), n.Proj.projections.add(urt), n.Proj.projections.add(vrt), n.Proj.projections.add(Ert), n.Proj.projections.add(brt), n.Proj.projections.add(Rrt), n.Proj.projections.add(Frt), n.Proj.projections.add(jrt);
      }
      tn.defaultDatum = "WGS84", tn.Proj = go, tn.WGS84 = new tn.Proj("WGS84"), tn.Point = vf, tn.toPoint = bk, tn.defs = Fi, tn.nadgrid = Ott, tn.transform = U0, tn.mgrs = eet, tn.version = "__VERSION__", qrt(tn);
      function Hrt(n) {
        const t = Object.keys(n.defs), e = t.length;
        let i, r;
        for (i = 0; i < e; ++i) {
          const a = t[i];
          if (!Vt(a)) {
            const o = n.defs(a);
            let s = o.units;
            !s && o.projName === "longlat" && (s = "degrees"), Hy(new rr({ code: a, axisOrientation: o.axis, metersPerUnit: o.to_meter, units: s }));
          }
        }
        for (i = 0; i < e; ++i) {
          const a = t[i], o = Vt(a);
          for (r = 0; r < e; ++r) {
            const s = t[r], l = Vt(s);
            if (!OL(a, s)) if (n.defs[a] === n.defs[s]) jd([o, l]);
            else {
              const u = n(a, s);
              Mu(o, l, eP(o, l, u.forward), eP(l, o, u.inverse));
            }
          }
        }
      }
      const Yrt = () => {
        tn.defs("EPSG:3395", "+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs"), tn.defs("EPSG:4548", "+proj=tmerc +lat_0=0 +lon_0=117 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs"), tn.defs("EPSG:4490", "+proj=longlat +ellps=GRS80 +no_defs +type=crs"), Hrt(tn);
        const n = new rr({ code: "EPSG:4490", units: "degrees", axisOrientation: "neu" });
        n.setExtent([-180, -90, 180, 90]), n.setWorldExtent([-180, -90, 180, 90]), Hy(n), Mu("EPSG:4326", "EPSG:4490", function(r) {
          return tn("EPSG:4326", "EPSG:4490", r);
        }, function(r) {
          return tn("EPSG:4490", "EPSG:4326", r);
        }), Mu("EPSG:3857", "EPSG:4490", function(r) {
          return tn("EPSG:3857", "EPSG:4490", r);
        }, function(r) {
          return tn("EPSG:4490", "EPSG:3857", r);
        });
        const t = new rr({ code: "GCJ:02", axisOrientation: "enu", extent: [-20037508342789244e-9, -2003750834278071e-8, 20037508342789244e-9, 2003750834278071e-8], worldExtent: [-180, -85, 180, 85], global: true, units: "m", getPointResolution: function(r, a) {
          return r / Math.cosh(a[1] / 6378137);
        } });
        jd([t]), Tu(Uy, [t], $J, KJ), Tu(Gy, [t], ak, ok);
        const e = new rr({ code: "BD:09", axisOrientation: "enu", extent: [-33554432, -33554432, 33554432, 33554432], worldExtent: [-180, -85, 180, 85], global: true, units: "m", getPointResolution: function(r, a) {
          return r / Math.cosh(a[1] / 6378137);
        } });
        jd([e]), Tu(Uy, [e], ZJ, XJ), Tu(Gy, [e], nk, ik);
        const i = new rr({ code: "EPSG:3395", extent: [-20037508342789244e-9, -20037508342789244e-9, 20037508342789244e-9, 20037508342789244e-9], worldExtent: [-180, -80, 180, 84], global: true, units: "m", axisOrientation: "neu" });
        Hy(i), Mu("EPSG:4326", "EPSG:3395", function(r) {
          return tn("EPSG:4326", "EPSG:3395", r);
        }, function(r) {
          return tn("EPSG:3395", "EPSG:4326", r);
        }), Mu("EPSG:3857", "EPSG:3395", function(r) {
          return tn("EPSG:3857", "EPSG:3395", r);
        }, function(r) {
          return tn("EPSG:3395", "EPSG:3857", r);
        }), Mu("GCJ:02", "EPSG:3395", function(r) {
          const a = ok(r, r, void 0);
          return tn("EPSG:3857", "EPSG:3395", a);
        }, function(r) {
          const a = tn("EPSG:3395", "EPSG:3857", r);
          return ak(a, a, void 0);
        }), Mu("BD:09", "EPSG:3395", function(r) {
          const a = ik(r, r, void 0);
          return tn("EPSG:3857", "EPSG:3395", a);
        }, function(r) {
          const a = tn("EPSG:3395", "EPSG:3857", r);
          return nk(a, a, void 0);
        }), Tu([e], [t], rk, sk), Tu([t], [e], sk, rk);
      }, Wrt = /^[\uD800-\uDBFF]$/, Xrt = /^[\uDC00-\uDFFF]$/, Zrt = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var Wk;
      (function(n) {
        n[n.Unknown = 1e-13] = "Unknown", n[n.Rule = 1e-12] = "Rule", n[n.DICT = 2e-8] = "DICT", n[n.Surname = 1] = "Surname", n[n.Custom = 1] = "Custom";
      })(Wk || (Wk = {}));
      const Nr = { Normal: 1, Surname: 10, Custom: 100 };
      function ka(n) {
        var t;
        return n.length - (((t = n.match(Zrt)) === null || t === void 0 ? void 0 : t.length) || 0);
      }
      function X0(n) {
        const t = [];
        let e = 0;
        for (; e < n.length; ) {
          const i = n[e];
          Wrt.test(i) && Xrt.test(n[e + 1]) ? (t.push(n.substring(e, e + 2)), e += 2) : (t.push(i), e += 1);
        }
        return t;
      }
      class Xk {
        constructor() {
          this.NumberDICT = [], this.StringDICT = /* @__PURE__ */ new Map();
        }
        get(t) {
          if (t.length > 1) return this.StringDICT.get(t);
          {
            const e = t.charCodeAt(0);
            return this.NumberDICT[e];
          }
        }
        set(t, e) {
          if (t.length > 1) this.StringDICT.set(t, e);
          else {
            const i = t.charCodeAt(0);
            this.NumberDICT[i] = e;
          }
        }
        clear() {
          this.NumberDICT = [], this.StringDICT.clear();
        }
      }
      const Zk = { "bng png png": [""], lng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "dng zhng": [""], "ko qio y": [""], q: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], shng: ["", "", "", "", "", ""], xi: ["", "", "", "", "", "", "", "", "", "", "", "", ""], hn: ["", "", "", "", "", ""], "wn m": [""], zhng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sn: ["", "", "", "", "", "", "", "", ""], "shng shng shang": [""], "q j": ["", "", ""], "b fu": [""], "y y y": [""], min: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chu: ["", "", "", "", "", "", "", "", ""], zhun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qi j": [""], p: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], cng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], s: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], di: ["", "", "", ""], ling: ["", "", "", "", "", "", "", "", "", "", "", "", ""], yu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bng: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "sng sng": [""], gn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "g g": ["", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], pn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zhng zhng": [""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], fng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "gun kung": [""], chun: ["", "", "", "", "", ""], chn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ln: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], b: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], wn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "wi wi": [""], "jng dn": [""], "l l": [""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], pi: ["", "", "", ""], f: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "y j": [""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ni: ["", "", "", "", "", "", "", "", "", ""], w: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tu zh": ["", "", ""], "me m ma yo": [""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "w w": [""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", ""], h: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], f: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "l yu yo lo": ["", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], png: ["", "", "", "", "", "", "", "", ""], png: ["", "", "", "", "", ""], qio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], h: ["", "", "", "", "", "", ""], gui: [""], "chng shng": ["", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ho y": [""], "ni mi": [""], q: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], y: ["", "", "", "", "", "", ""], x: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], du: ["", "", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], nng: ["", "", "", "", ""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mo: ["", "", "", "", "", "", "", "", "", "", ""], mi: ["", "", "", "", "", ""], lun: ["", "", ""], r: ["", "", "", "", "", ""], xu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], f: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], n: ["", ""], qin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], su: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", ""], "qin gn": [""], "zh lun": [""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ln ln": [""], ju: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "le lio": [""], "g m": [""], "y y": ["", ""], zhng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], r: ["", "", "", "", "", "", "", "", "", "", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ku: ["", "", "", "", "", "", "", "", "", "", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], h: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], q: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], s: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], su: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gn: ["", "", "", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "xi su": [""], "q zhi": ["", ""], "y y": ["", "", "", "", ""], "j q": ["", ""], tu: ["", "", "", ""], "wng w": [""], "kng hng gng": [""], d: ["", ""], jio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hi: ["", "", "", "", "", "", "", "", ""], "hng png": [""], m: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ye: [""], xing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ling: ["", "", "", "", "", "", "", "", "", "", ""], "qn qng": ["", ""], b: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "dn dn": ["", ""], lin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], du: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "wi mn": ["", ""], rn: ["", "", "", "", "", "", "", "", "", "", ""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], wng: ["", "", "", "", ""], "shn sh": [""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dng: ["", "", "", "", "", "", "", "", ""], z: ["", "", "", "", "", "", ""], "jn jn": ["", "", ""], "p p": [""], "chu qi": [""], zhng: ["", "", "", ""], jn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bng: ["", "", "", "", "", "", "", ""], rng: ["", "", "", "", ""], f: ["", "", ""], "jn sn": [""], ln: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], cng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zi z z": [""], t: ["", "", "", "", "", "", "", "", "", "", ""], f: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tu ch du": [""], hng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], rn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "gn hn": [""], "y g": [""], di: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "lng lng lng": [""], cho: ["", "", ""], "chng zhng": ["", "", "", ""], s: [""], chng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], m: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "men mn": [""], fn: ["", "", "", ""], "cho mio": [""], "yng ng": [""], zhng: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "p p": [""], w: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ji ji jie": [""], "yo f": [""], "rn rn": [""], "fn bn": [""], d: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], fng: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], pi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], wn: ["", "", "", "", "", "", "", "", "", "", "", ""], xn: [""], kng: ["", "", "", "", "", "", ""], i: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "j q": ["", ""], "xi x": [""], "jn yn": [""], dn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], f: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tng: ["", "", "", "", "", "", "", "", "", "", "", ""], yu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hu: ["", "", "", "", "", "", ""], "hu kui": ["", "", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], cu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sn: ["", "", "", "", "", ""], wi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chun zhun": ["", ""], "ch j": ["", "", ""], "j ch": [""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], shng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chen cng": [""], xn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xn: ["", "", "", "", "", "", "", "", "", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "xin xun": [""], "n n": [""], "b bi": [""], "g g": [""], n: ["", "", "", "", "", "", "", "", "", "", "", ""], "n n": [""], bn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], x: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], shn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], q: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "s c": [""], bng: ["", "", "", "", "", ""], "s sh": [""], "ji qi g": [""], "y ch": [""], "din tin": ["", ""], "hn gn": [""], mi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], b: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], b: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zho sho": [""], c: ["", "", "", "", ""], wi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zu: ["", "", ""], yng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "t t": ["", ""], zhn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "h h h": [""], b: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sh: ["", "", "", ""], "y di": ["", "", "", ""], "f f b b": [""], "zu zu": [""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], nng: ["", "", "", "", "", "", ""], q: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "yng yng": [""], w: ["", "", "", ""], k: ["", "", "", "", ""], bo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hui hu": [""], "g h": [""], lo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xing: ["", "", "", "", "", "", "", ""], g: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bi: ["", "", "", "", "", "", "", "", ""], f: ["", "", "", "", "", ""], mng: ["", "", "", "", ""], "r ni": [""], hn: ["", "", "", "", ""], hu: ["", ""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tio: ["", "", "", "", ""], jio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], c: ["", "", "", "", "", "", "", "", "", "", "", "", ""], xng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], kn: ["", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ku: ["", "", "", ""], gng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], m: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], n: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mu: ["", "", "", "", "", "", "", "", "", "", ""], r: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "dng tng tng": [""], ch: ["", "", "", "", "", "", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "gng gng": ["", ""], zhu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], r: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "jin cn": [""], xi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ta: [""], "jio yo": ["", "", ""], zhn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "c z zhi": ["", ""], kui: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chi: ["", "", "", "", "", "", ""], nng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hu hu": ["", ""], jing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chng tng": [""], "zhn zhn": ["", ""], zu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "sh du": [""], tng: ["", "", "", "", "", "", "", "", "", "", "", ""], shn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tu tu": [""], nn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], xio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "bin pin": ["", "", ""], tu: ["", "", "", ""], x: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], c: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], : ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], x: ["", "", ""], "gung kung": [""], k: ["", "", "", "", "", "", "", "", "", "", "", "", ""], w: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ling: ["", "", "", "", "", "", "", "", "", "", "", ""], z: ["", "", "", "", "", "", "", "", "", "", ""], "qio xio": [""], yng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hn: ["", "", "", "", "", "", "", "", "", "", "", ""], jng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sn: ["", ""], pi: [""], s: [""], x: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "y sh y": [""], "s q": [""], "xn shn": [""], xi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], d: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "li ling": [""], jin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "j j": ["", "", "", ""], xio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], pi: ["", "", "", "", "", "", "", ""], bio: ["", "", ""], "ch t": [""], fi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], fng: ["", "", "", "", "", "", "", "", "", "", ""], n: ["", "", "", "", "", "", ""], bi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "h ch": [""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "cu z": [""], "ling li": [""], wn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gun: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], tin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mn: ["", "", "", "", "", "", "", "", "", "", "", ""], "do do": [""], "tn tn": ["", ""], "ju ju": [""], chu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xng: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], png: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tng chng": [""], hu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], t: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ling jng": ["", ""], su: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "chng chng": [""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "kng kng": [""], jun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], n: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhu: ["", "", "", "", "", "", "", "", "", "", "", ""], "w wi": [""], lu: ["", "", "", "", "", "", "", "", "", ""], sng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lng: ["", "", "", "", ""], z: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], bn: ["", "", "", "", "", "", ""], ci: ["", "", "", "", "", "", "", "", "", "", ""], zhi: ["", "", "", "", ""], y: ["", "", "", "", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", ""], qng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chng chn": ["", ""], run: ["", "", "", "", "", "", "", "", "", "", ""], "zhng tng": [""], chn: ["", "", "", "", "", ""], "ji ji": [""], "j ji": [""], "bng bng": [""], ru: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], t: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], wi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], pin: ["", "", "", "", "", "", "", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tng dng": [""], : ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ch: ["", "", ""], shng: ["", "", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", ""], hung: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chu qio": [""], yu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], x: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", ""], c: ["", "", "", "", "", "", ""], b: ["", "", "", "", "", "", "", "", ""], xn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ci s": [""], dun: ["", "", "", "", ""], u: ["", "", "", "", "", "", "", "", ""], tu: ["", "", ""], "zn z z": [""], "l lu": ["", ""], fn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ku gu": [""], su: ["", "", "", "", "", "", "", ""], "zh s t": [""], s: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xi: ["", "", "", "", "", "", ""], "yun yun": ["", ""], rng: ["", "", "", "", ""], n: ["", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "gu jing": [""], m: ["", "", "", "", "", "", "", "", "", "", ""], bng: ["", "", "", "", "", "", "", "", "", "", "", ""], din: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ho: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "x x": [""], shn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qin jin": [""], "qu ju": ["", ""], "cng chen": [""], rng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "t tn": [""], su: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], di: ["", ""], zi: ["", "", "", "", "", "", "", ""], g: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], nu: ["", "", "", "", ""], "cn cn": [""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], cu: ["", "", "", "", "", "", "", "", "", "", ""], yng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zo co": [""], sng: ["", "", "", "", "", "", "", "", "", "", ""], o: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "q cu": [""], chung: ["", "", "", ""], sh: ["", ""], hn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "yn yn": ["", "", ""], "pio bio": ["", ""], lin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tn tn": [""], yng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhun: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], xing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], shn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tu tu": [""], zn: ["", "", "", ""], p: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chng: ["", "", "", "", "", "", "", ""], gung: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dng: ["", "", "", "", "", "", "", "", "", "", ""], "chn zhn zhun": [""], b: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chun: ["", "", "", "", ""], "ti jin": [""], sng: ["", ""], xin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "y j": [""], " w": [""], "tng zhung": [""], ln: ["", "", "", "", "", "", "", "", "", "", "", "", ""], g: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ji jie": [""], qio: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], p: ["", "", "", "", "", "", "", "", "", "", "", ""], si: ["", "", "", ""], "chn tn shn": [""], "dng dng": ["", "", ""], xun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "dn dn": ["", "", ""], cn: ["", "", "", "", "", "", "", ""], "bn bn": [""], "n n": [""], ti: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ln: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "n y i y": [""], mng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], nng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], kung: ["", "", ""], bo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zn: ["", "", "", "", "", "", ""], ho: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qng: ["", "", "", "", "", "", "", "", "", ""], chn: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], tng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "lng lng lng": [""], "chn chn": [""], "rng xing": ["", ""], "hu xi": [""], lu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "nng nng": [""], "w w": [""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zn: ["", "", "", "", "", "", "", ""], yun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zho: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "du ru yu": ["", "", ""], k: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], t: ["", "", "", "", ""], dng: ["", "", "", "", "", "", "", ""], du: ["", "", "", "", "", ""], hung: ["", "", "", "", "", "", "", "", "", "", "", ""], r: ["", "", "", "", "", "", "", "", "", "", "", ""], ni: ["", "", "", ""], "y sh": [""], "li l": [""], han: ["", ""], tin: ["", "", "", "", "", "", "", ""], "xng xng": [""], din: ["", "", "", "", "", "", "", "", "", "", "", ""], "z c": [""], jin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], shu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jing: ["", "", "", "", "", "", "", "", "", ""], mo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], rn: ["", "", "", "", "", "", "", "", ""], "ni n": [""], gng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], c: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gu: ["", "", "", "", ""], "mo m": [""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], x: ["", "", "", "", "", "", "", "", "", "", "", ""], m: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "yu yn": [""], xi: ["", "", ""], jn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], m: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "gun gun": ["", "", "", "", ""], mng: ["", "", "", "", "", "", "", "", "", "", "", "", ""], zhng: ["", "", "", "", "", "", "", "", ""], zu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ku: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], ti: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "fng png": ["", ""], "chng chng": [""], kung: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lng: [""], pn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], f: ["", "", "", "", ""], xin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qi: ["", "", "", "", "", "", "", "", ""], "jng chng": ["", "", ""], su: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], t: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhn: ["", "", "", "", ""], "ling ling": ["", "", ""], dio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], cu: ["", "", "", "", ""], i: ["", "", "", "", "", "", "", ""], du: ["", "", "", "", "", "", "", "", ""], d: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "j j": [""], fn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ch ch": ["", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], png: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ki: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "kn qin": [""], t: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "o w": [""], ch: ["", "", "", "", "", "", "", "", "", ""], dng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zo: ["", ""], do: ["", "", "", "", "", "", "", "", ""], chung: ["", "", "", "", "", "", "", "", ""], "fn fn": [""], "qi qi": [""], kn: ["", "", "", "", "", "", ""], cn: ["", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hu hu": [""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], z: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chung chung": ["", ""], q: ["", "", "", "", "", "", "", ""], "bi bi": ["", ""], "po bo": [""], "chn chn": ["", "", ""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", ""], gng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], do: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chung: ["", "", "", "", ""], k: ["", "", "", "", "", "", "", "", "", "", "", ""], du: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "shu shu": [""], "qun xun": [""], "ch sh": ["", ""], "c c": [""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], cu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "xio xu": [""], "ki k": ["", ""], "l l": [""], t: ["", "", "", "", "", "", "", "", ""], pu: [""], wn: ["", "", "", "", "", "", "", "", "", "", "", ""], "bo b": ["", ""], du: ["", "", "", "", "", "", "", "", "", "", ""], qng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "yn shn": [""], "d zhu": [""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hu: ["", "", "", "", "", "", "", "", ""], shng: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "dun zh": [""], w: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], g: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "d zh": [""], chun: ["", "", "", "", "", "", "", "", ""], "tun zhun": ["", "", ""], "l ji": [""], png: ["", "", "", "", "", "", "", "", "", "", ""], pio: ["", "", "", "", "", "", "", "", "", "", ""], ku: ["", "", "", "", "", "", "", ""], "jio cho": ["", "", "", ""], qio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hu hu": [""], "zh zh": [""], "p p": ["", ""], tng: ["", "", "", "", "", "", "", ""], chn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zun: ["", "", "", "", ""], m: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qun: ["", "", "", "", ""], "jn jng": ["", "", ""], kng: ["", "", "", "", "", "", "", "", "", "", ""], "xi li": [""], "zh ch": [""], n: ["", "", "", ""], sho: ["", "", "", "", "", "", "", "", ""], mio: ["", "", "", "", "", "", "", "", "", "", ""], ku: ["", ""], w: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], kung: ["", "", "", "", "", "", "", "", "", "", "", ""], h: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], go: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "b bi": [""], lng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "jun jun": ["", ""], "l li": [""], ki: ["", "", "", ""], "wng yng": [""], qn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], fn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jun: ["", "", "", "", "", "", "", "", "", "", ""], "tng dng": ["", "", "", ""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sho: ["", "", ""], "gu gu": [""], cng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "to yo": ["", ""], po: ["", "", "", "", "", "", "", "", "", "", ""], d: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hu hu": [""], "bi bi": [""], no: ["", "", "", "", "", "", "", "", "", "", "", ""], "ch shi": [""], fng: ["", "", "", "", "", "", "", "", "", "", ""], z: ["", "", "", "", "", "", "", "", ""], qi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zng cng": [""], fi: ["", "", "", "", "", "", "", "", "", ""], "ku gu": ["", ""], sun: [""], p: ["", "", "", "", "", "", "", "", "", "", ""], "q u": ["", ""], "k qi": [""], "yn yn": ["", ""], bin: ["", "", "", "", "", "", "", "", "", "", ""], n: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], nin: ["", "", "", "", "", "", ""], s: ["", "", "", "", "", "", "", "", "", "", ""], z: ["", "", "", "", "", "", "", ""], shng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], wn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "hu hu hu": ["", ""], bi: ["", "", "", "", "", "", "", "", "", ""], "z c": [""], "dn shn chn": ["", ""], "nn n": [""], "shui l": [""], "b bo p": [""], "kung gun": [""], bin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], b: ["", "", "", "", "", "", ""], "zhn zhn": ["", ""], "k qi": [""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gu: ["", "", "", "", "", "", "", ""], "ng yng": [""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lun: [""], "jun jun": ["", ""], "chng n hn": [""], "wi yn": [""], tng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zh zhi": [""], "hn n": ["", ""], y: ["", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], d: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zh zhi": [""], png: ["", "", "", "", "", "", "", "", "", "", ""], "zh sh": [""], mng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zu: ["", "", "", ""], "sh xi": ["", ""], o: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ln qin": [""], "s mu": [""], "gng hng": [""], "ln mio": [""], "qi ru": [""], d: ["", "", "", ""], "xin xun": ["", ""], "cn shn cn sn": ["", "", "", ""], "i y": [""], "ch ch ch ch": [""], shung: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], shu: ["", ""], gui: [""], b: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "f f": [""], "zhu y l ju": [""], q: ["", "", "", "", "", "", ""], "ji xi": ["", ""], "wi y": ["", "", ""], di: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ru: ["", "", "", "", "", "", "", "", "", "", ""], "j gu": [""], lng: ["", "", "", ""], "do do to": [""], "zh zh": [""], jio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zho sho": [""], "k k": [""], "ti ti": ["", ""], p: ["", "", "", "", "", "", ""], "y xi": [""], "ho ho": [""], tn: ["", "", "", "", "", "", "", ""], "hng hng": [""], mi: ["", "", "", ""], "x y y": [""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "xun sng": [""], yo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], z: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "h g": ["", ""], "cn du": [""], "tng tng": [""], "t t": ["", ""], "zh zh": ["", ""], "xi h": [""], " y": [""], "ma m m": [""], ln: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tn: ["", "", "", ""], "b p": [""], qn: ["", "", "", "", "", "", "", "", "", "", ""], "ji g": [""], "fu p": [""], "ba b": [""], dn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], fn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], " hu": [""], "kng hng": ["", ""], shn: [""], "zh z": [""], "yn shn": [""], w: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "cho cho": [""], "n n": [""], "xu chu ju": [""], chu: ["", "", ""], "du r": [""], hu: ["", ""], "hng hu u": [""], "w y": [""], "ya y": [""], " e": [""], di: ["", "", ""], "mn q": [""], hng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], n: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tn tin": [""], "f ": ["", ""], "di ti": [""], "u u u": [""], "bi bei": [""], "yun yn yn": ["", ""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hu q": [""], "qing qing": ["", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jun: ["", "", "", "", "", ""], pn: ["", ""], "wn mn": [""], "ne n": [""], " m mu": [""], rn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "ti ch": [""], "q zh": [""], "z c": [""], "gu g gu": [""], "c z": [""], "hu x gu": [""], "h     a": [""], no: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "xi g": [""], pi: ["", "", "", "", "", ""], "ho xio": [""], mng: ["", ""], "d dn": [""], "zu j": [""], "xin gn": [""], pu: ["", "", ""], "yng yng": [""], "z z zh": [""], "h h hu hu h": [""], hi: [""], d: ["", "", "", "", "", "", "", "", "", ""], "k k": [""], g: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "k g": [""], zuo: [""], lng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "xin xin": [""], q: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "x di": [""], "li li li lie": [""], z: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], m: [""], "j x qi": [""], "g lu k lo": [""], "sh xn": [""], "zn z z zan": [""], "hi k": [""], hu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hui sh": [""], to: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], " n": [""], "xun xun": ["", ""], "wi h w gu gu": [""], "yn y yn": [""], i: ["", "", "", "", "", "", ""], pn: ["", ""], shn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hng hng hng": [""], "w wa": [""], "h h h": [""], zi: ["", "", "", "", "", "", "", "", ""], "d di": [""], pi: ["", "", "", "", "", "", ""], "gn hn": [""], "y y": ["", ""], "yu hu": ["", ""], nin: ["", "", "", "", "", "", "", "", "", ""], "hu hu": ["", ""], "j ji zhi": ["", ""], mu: [""], "y yo": ["", ""], lng: ["", "", ""], "  ": [""], "l l li": [""], "n na ni n ni": [""], h: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "b p b": [""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ling lng": [""], "li l": [""], hn: ["", "", "", "", "", "", "", "", "", ""], "hng hng": [""], gng: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chu yu": [""], "g ji": [""], "bei bi": [""], "hn hn": [""], chn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "i i": [""], "ji qin": [""], "yn dn xin": [""], ch: ["", "", "", "", ""], "w g ": [""], zo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], d: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "gng hng gng": ["", ""], du: [""], "lo lo": ["", "", ""], hun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lng: ["", "", "", "", ""], "w wi": [""], fng: ["", "", "", ""], "yn jn": [""], "h xi": [""], wi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], shu: [""], chng: ["", "", "", "", "", "", "", "", "", ""], "r w": [""], qing: ["", "", "", ""], y: [""], y: ["", "", "", "", "", "", "", "", "", "", ""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tu: ["", "", "", "", "", "", "", "", "", ""], "zhu zho tio": [""], kn: ["", "", "", "", "", "", "", "", "", ""], "zhu zho": ["", ""], "hng hng": ["", ""], "ln ln": [""], "a    ": [""], qing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tn zhn xing du": [""], wn: ["", "", "", "", "", "", ""], "cu qi": [""], "di sh ji t": [""], "yu w": [""], "z c": [""], "b t": [""], "chu chui": [""], "y y ": [""], fi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], p: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sh: [""], "l la": [""], "yng qng": [""], p: ["", "", "", "", ""], "zh sh": [""], s: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ni: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "lu lu luo": ["", ""], "tn chn tu": [""], bo: ["", ""], dng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lng: [""], "n n": [""], k: ["", ""], "yng y": [""], "l l l": [""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "di zh": [""], wi: ["", "", ""], "nu r": [""], "x hu gu": [""], zn: [""], "w ": [""], h: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hun yun xun h": [""], x: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "h h y": [""], ku: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zhng chung": [""], "wi wi": ["", "", ""], "du zh": [""], "sng sng": [""], "qio jio": [""], "pn bn": [""], "cn sn q": [""], "zh ch": [""], mio: [""], "pn pn": [""], ku: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "lou lu": [""], "zo qio": [""], "h xio xio h": [""], " sh": [""], xi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qing qing": ["", "", "", "", ""], "i y": ["", ""], "m m ma": [""], "k k": [""], "d t": ["", ""], sng: ["", "", "", "", "", "", ""], chn: ["", "", "", "", "", "", "", "", ""], "w g": [""], "png bng": [""], "xin qin qin": [""], lo: ["", "", "", "", "", "", "", "", "", ""], wng: ["", "", "", "", "", "", "", ""], w: ["", "", "", "", "", ""], "hi hi": [""], h: ["", "", "", "", ""], zi: [""], si: [""], "g g g": [""], g: ["", ""], n: ["", "", "", "", ""], di: [""], "i i i": [""], tng: ["", "", "", ""], "zu su": [""], "zh zh zh zhe": [""], m: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], su: ["", ""], tn: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "jio do": [""], "ki g": [""], "shn cn": [""], co: ["", "", "", "", "", "", "", "", "", "", "", ""], pio: ["", "", "", ""], "lu lou": [""], g: ["", ""], "g ji": [""], "jio xio": [""], "x sh": ["", ""], p: ["", "", "", "", "", ""], "d di": [""], "ma m": [""], "l lei": [""], "g g g": [""], si: ["", "", "", "", "", ""], "zu chui": [""], "cho zho": ["", "", ""], zu: ["", "", "", ""], "qio qio": ["", "", ""], "ch x shu": [""], "tn chn": [""], "dn tn": ["", "", "", "", ""], "hi m": [""], : ["", "", "", "", ""], "fn bo": [""], chung: ["", "", ""], "c z h": [""], "tn ku": [""], "cng chng": [""], dng: ["", "", "", "", "", "", "", "", "", ""], p: ["", "", "", "", "", "", "", ""], ju: ["", "", "", ""], l: ["", "", "", "", ""], zhn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], : [""], "zhu zhu": [""], "jio qio ch": [""], yun: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "i i i": [""], "yng yng": ["", ""], "ju xu": [""], "pn pn fn": [""], g: ["", "", "", "", ""], "xn hn hn": [""], dng: ["", "", "", "", "", "", "", "", "", ""], ln: ["", "", "", "", "", "", "", "", "", "", ""], t: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hu hu ": [""], ho: ["", "", "", ""], "h xi": [""], "xi p": [""], "zhu chu": ["", "", ""], m: [""], "ch c": [""], "b po bo": [""], "me mi m": [""], "xi hi": [""], "o xio": [""], m: ["", ""], pn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], m: ["", ""], "rng rng": [""], l: ["", ""], "jio ju jio": [""], chu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hun hun": [""], "z c": [""], chi: ["", "", "", "", ""], "nng nng": [""], "z zn cn": [""], s: ["", "", "", "", "", "", "", "", "", ""], zng: ["", "", "", "", "", "", ""], "z ni yn": [""], nng: [""], "lu lu luo": [""], "wi gu": [""], hu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], nn: ["", "", ""], "jin nn": [""], nn: [""], tun: ["", "", "", "", "", "", "", "", "", "", ""], "tn dn": ["", ""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], kn: ["", "", ""], "wi tng": [""], qn: ["", "", ""], r: ["", "", "", "", "", ""], ti: ["", "", ""], p: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qun jun jun": ["", ""], "chu chun": [""], tun: ["", "", ""], l: ["", "", "", "", "", "", "", "", ""], "hun yun": [""], lun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], t: ["", "", "", ""], "x wi": [""], "d de": ["", ""], "qin s": [""], zhn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chng chng": ["", "", ""], "q yn": [""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zh zh": [""], bn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], qn: ["", "", "", "", "", "", "", "", "", "", ""], "mi fn": [""], "rng kng": [""], "fng fng": [""], "fn bn": [""], tn: ["", "", "", "", "", "", "", "", "", "", "", ""], "hui pi p pi": [""], "d ln": [""], tn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], b: ["", "", "", "", "", "", "", "", "", "", "", ""], fn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], p: ["", "", "", "", "", "", "", "", "", "", ""], "pn bn": [""], kn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], din: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "m m": [""], "k k": ["", ""], xu: ["", "", "", "", "", "", "", "", ""], "d ch": ["", ""], l: ["", "", "", ""], lng: ["", "", "", "", "", "", "", "", "", ""], mn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "dng tng": ["", "", ""], c: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], du: ["", "", "", "", "", "", "", ""], "du du": [""], "du du": ["", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", ""], shng: ["", "", "", "", "", "", "", "", ""], shu: ["", "", "", "", "", ""], da: ["", "", ""], hng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "n n": [""], xng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "yun hun": [""], bng: ["", "", "", "", "", "", "", "", "", "", "", ""], "pu f": [""], cn: ["", "", ""], "bng fng": [""], "d fng": [""], "xi ji": [""], "mi mn": [""], lng: ["", "", "", "", "", ""], "shn yn": [""], "qn jn": [""], "p b": [""], hu: ["", "", "", "", "", "", "", "", "", ""], "su s": [""], "p p": [""], "qng zhng": ["", ""], "wn wn": [""], ln: ["", "", ""], "zhng chng": [""], kng: ["", "", "", "", "", ""], "ci ci": ["", "", ""], "ch tu": [""], bng: ["", "", "", ""], "kn xin": [""], "y sh": ["", ""], pi: ["", "", "", "", "", "", "", "", "", ""], "so so": [""], "jn qn jn": [""], "png bng": [""], "qin zn jin": [""], n: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "du hu": ["", ""], hun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "bo b p": [""], "mo mu w": [""], run: ["", "", ""], "i  y": [""], gng: ["", ""], mi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], d: ["", "", "", "", "", "", "", ""], fng: ["", "", "", ""], hng: [""], chn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jing: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], hung: ["", "", "", "", "", ""], dun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], t: ["", "", "", "", "", "", ""], wng: ["", "", "", "", "", "", ""], "si si s": [""], zng: ["", "", "", "", "", "", ""], tin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhng: ["", "", "", "", "", "", "", "", "", "", "", ""], "tin zhn": [""], wn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], li: ["", "", "", "", "", "", "", "", "", ""], hi: ["", "", "", "", ""], lng: ["", "", "", "", "", "", ""], bng: ["", "", "", "", "", "", "", "", "", ""], chn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "u qi": [""], "qin jin": [""], "zhun tun": [""], shung: ["", "", "", "", "", ""], sh: ["", "", "", "", "", "", ""], lu: ["", "", "", "", "", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "d zh": ["", ""], kn: ["", "", "", "", "", "", ""], chn: ["", "", "", "", "", "", "", "", ""], "zh zhu": [""], qing: ["", "", "", "", ""], zng: ["", "", "", "", "", "", "", "", "", "", ""], qing: ["", "", "", "", "", "", "", "", "", "", "", ""], "kui tu": [""], "tun dng": [""], "qio qu": [""], "zn dn": [""], "qio o": [""], "y t": [""], "xu b ju": [""], ln: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hui: ["", "", ""], rng: ["", "", "", ""], "ln xin": [""], do: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ru: ["", "", "", "", "", "", "", ""], san: [""], zhung: ["", "", "", "", "", "", ""], "k qio": ["", ""], kn: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], mng: ["", "", "", "", "", ""], cn: ["", ""], "zh zhng": [""], "g yng": [""], "jing xing": ["", ""], "png fng fng": [""], zhi: ["", "", "", "", "", "", "", ""], "xun xing": [""], wi: ["", ""], "wn yun wn yun": [""], "mo wn": [""], mng: ["", "", "", "", "", ""], "d di": [""], "f f": ["", "", "", ""], gui: ["", "", ""], yng: ["", "", "", "", "", "", "", "", "", "", "", ""], "hng bn": [""], go: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "to bn": [""], "tu tou": [""], "yn to": [""], "ku ku": ["", ""], "ji ji g xi": [""], hu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ji ji g xi": [""], n: ["", "", ""], "d t": [""], "yn yn": ["", ""], po: ["", "", "", "", "", "", "", ""], ni: ["", "", "", "", "", "", "", ""], "qun jun": ["", "", ""], zu: ["", ""], "q qi xi": [""], ki: ["", "", "", "", "", ""], "bn bn": ["", ""], to: [""], "zng zhung": [""], bn: ["", "", "", "", "", ""], "xn zhu": [""], sh: ["", "", "", "", "", "", "", "", "", ""], "h p ti": [""], "o y": ["", "", ""], yn: ["", "", "", "", "", "", "", "", ""], "du ch": [""], "n r": [""], n: ["", "", "", "", ""], "dng dng tin": [""], "t ji": [""], nun: [""], "ho ho": [""], fn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], shu: ["", "", "", "", "", "", "", "", "", "", ""], "fi pi": [""], wng: ["", "", "", "", ""], zhung: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], m: ["", ""], "f yu": [""], "hi ji": [""], d: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mio: ["", "", "", "", "", ""], "fu pi p": [""], "yu ju": [""], ni: [""], "n nn": [""], tu: ["", "", "", "", "", "", "", "", ""], "wn yun": [""], fng: ["", "", "", "", "", ""], n: [""], zhu: ["", ""], zho: ["", "", "", "", "", "", "", "", "", ""], "ni n": [""], tu: ["", "", "", "", ""], "xin xun x": [""], "zh y": ["", ""], : ["", "", "", ""], mi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "q q": [""], "x x": ["", ""], "shn shn": ["", "", "", "", ""], mn: ["", "", "", "", "", "", "", "", "", "", "", ""], ji: ["", "", "", "", ""], "wi wi": [""], pn: ["", "", "", "", "", ""], "hu hu": [""], "jio xio": [""], "gu d": [""], "lo m": [""], "nin nin": [""], zhn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hng: ["", "", "", "", "", "", "", "", "", "", "", ""], "jn xn": [""], "ku h": [""], " y": [""], "xin shn": [""], w: [""], "ro ro": ["", ""], "sho sho": [""], xi: ["", "", "", "", "", ""], "w mi m": [""], "chu li": [""], ning: ["", "", ""], "n nu": ["", ""], "pu b": [""], "ni su": [""], tu: ["", "", "", "", "", ""], mn: ["", "", "", "", "", "", "", "", ""], "w w y": [""], "x i": [""], "zhu shu": [""], "dng dng": [""], "i i ": [""], " ": [""], min: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "pu pi b": [""], bio: ["", "", "", "", "", "", ""], "f fn": [""], w: ["", "", ""], "n n": ["", ""], "qun jun": ["", ""], hn: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qin jn": [""], "wn w": [""], "li li": ["", "", ""], "zhu chu": [""], "chu no": [""], "n n": [""], "hn kn": [""], "dng yng": [""], nn: [""], "ru chu": [""], ji: ["", "", "", "", "", "", "", "", "", "", "", ""], "tu y": ["", ""], "y y": [""], "wi wi": [""], "d t": ["", "", ""], ru: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "run nn": [""], mio: ["", "", "", "", "", "", ""], "y pi": [""], "min min": [""], "t sh": ["", ""], "du tu": ["", ""], o: ["", "", "", "", "", "", ""], "ch zu": [""], yng: ["", "", "", "", "", ""], "qn shn": [""], ji: ["", "", "", "", "", "", ""], so: [""], "zhn zhn": [""], "ji su": [""], "mng mng": [""], nio: ["", "", "", "", "", "", "", "", ""], to: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bio: [""], "pio pio": ["", ""], xun: ["", "", "", "", "", "", "", "", "", "", "", ""], "mn mn": [""], kng: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hn nn": [""], nn: ["", ""], zh: ["", ""], "m m": [""], pi: [""], zhn: ["", "", "", "", "", "", "", "", "", "", "", ""], "xin yn jn": [""], lin: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qing hun xun": [""], dng: ["", "", "", "", "", ""], cn: ["", "", "", "", "", "", ""], tio: ["", "", "", "", "", ""], b: ["", "", ""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qin xin": ["", ""], "xi hu": [""], "hun qun": [""], "l l": ["", ""], "zh chu": [""], kng: ["", ""], "m z": [""], "sn xn": ["", ""], "bi b": ["", ""], "yu ni": [""], zhun: ["", "", ""], hi: ["", ""], no: [""], "chn cn": [""], b: ["", "", "", ""], ni: ["", ""], "nng nng": ["", "", "", "", "", ""], zhi: [""], "t ji": [""], sng: ["", "", "", "", "", "", "", "", "", ""], ru: ["", "", ""], zhn: ["", "", "", "", "", ""], "m f": [""], "dng tn": [""], "wn yun": [""], chng: ["", ""], qn: ["", "", "", "", "", "", ""], zi: ["", ""], "bo sh": [""], "ji jia jie": [""], "hung hung": [""], kun: ["", "", "", "", "", "", ""], "s xi xi": [""], "ji zn": [""], "bng bng": [""], "jn qn": [""], "lu j": [""], "xi xi": [""], "qn qn": [""], cn: ["", ""], du: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "l lu": [""], "sh y y": [""], "jing jing qing": [""], "jing jing": ["", "", "", ""], zn: ["", "", "", "", "", "", "", "", "", "", ""], "sh zh": ["", ""], xio: ["", "", "", "", "", "", "", "", "", "", ""], "ji j": ["", "", ""], "sho sho": [""], r: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "wng yu": [""], wng: ["", "", "", "", ""], lio: ["", "", "", "", "", "", "", "", "", ""], "mng mng lng png": [""], g: ["", ""], "ku ku": [""], tu: ["", "", "", "", "", "", "", "", "", "", "", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ch ch": [""], ko: ["", ""], "jn jn": [""], "wi y": [""], "nio su": [""], cng: ["", "", "", ""], dio: [""], "png bng bng": [""], lu: ["", "", "", "", "", "", "", ""], "sh zh": ["", ""], "xi t": [""], "ch co": [""], "tn zhn": [""], "n j": [""], "hng lng": [""], "q ki": ["", ""], ng: ["", "", ""], "gng gng": ["", ""], k: ["", "", "", "", ""], gu: ["", "", "", "", "", "", "", "", ""], tio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "q j": [""], lng: ["", "", "", ""], p: ["", "", "", "", "", "", "", "", "", "", ""], "b k": [""], lu: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "f ni": [""], n: [""], "zh sh": ["", ""], qi: ["", "", "", ""], "qio jio": ["", ""], "xi y": [""], b: ["", "", "", "", "", "", "", "", "", ""], chng: ["", "", "", "", "", "", "", ""], "z cu": ["", ""], "lng lng": [""], "dng dng": [""], xio: ["", "", "", "", ""], "p b": ["", ""], "zhn chn": ["", "", ""], "wi wi": [""], "yng dng": [""], "sh di": [""], yo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "kn zhn": [""], "hn dng": [""], "qin kn": [""], "w mo": [""], "k ji": ["", ""], "wi wi": [""], k: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "dng tng": [""], "rng yng": ["", ""], "i ki": [""], "ko qio": [""], cu: ["", "", "", "", "", "", "", "", ""], "qin qn": [""], "d di": [""], cn: [""], dng: ["", "", "", "", "", "", "", ""], "o o": [""], "p pi": [""], "jio qio": ["", ""], "ju gu": ["", ""], "zhn shn": ["", ""], "xi ji": [""], "gu x jun": [""], r: [""], "l li": ["", "", "", ""], "x gu jun": [""], "yng hng": [""], yng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], cho: ["", "", "", "", ""], cun: ["", "", ""], chun: ["", "", "", "", ""], "jng xng": [""], cho: ["", "", "", "", "", "", "", "", "", "", "", ""], qio: ["", "", ""], gng: ["", "", "", "", "", "", "", "", ""], "ch ch chi c": [""], "xing hng": [""], shui: ["", "", ""], p: ["", "", "", ""], "tng n": [""], "m w": [""], "ti ti ti": [""], zhu: ["", "", "", "", "", "", "", ""], "jun jun": [""], shu: ["", "", "", "", "", "", ""], "chu do": ["", ""], "jin jin sn": [""], "sh qi": [""], "q j": ["", ""], "shn qio shn": [""], "zhung chung": [""], "chn chn": [""], mi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "gn gn": [""], "bng bng": ["", ""], "j j": [""], "gung n": [""], gung: ["", "", "", ""], me: [""], "dn tn": [""], "bi tng": [""], "yng yng": [""], "d de": [""], "d du": [""], "mng mng png": [""], "bng png": [""], chng: ["", "", "", "", "", ""], "j cu": [""], qng: ["", "", "", "", "", "", "", "", "", ""], "gu wi hu": [""], "jn qn": [""], ku: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qing s": ["", ""], "yn yn": ["", "", "", "", "", "", ""], "p pi": ["", ""], "nng lng": [""], "d t tu": [""], "ju zhng": [""], "m m": ["", "", ""], cho: ["", "", "", "", "", "", "", ""], yi: [""], sho: ["", "", "", "", "", "", "", "", "", "", "", ""], "xun yun": [""], "qing qing jing": ["", ""], "tn dn": ["", ""], bi: [""], "qing jing qing": [""], "j xu": [""], tun: ["", ""], yu: ["", "", "", ""], "shn xin": [""], wn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "png bng": [""], "pio pio": [""], "zhu b": [""], "tu y": [""], "png fng": [""], wng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], c: ["", ""], "di di": [""], hui: ["", "", "", "", "", "", "", "", "", "", ""], "w wng ji": [""], "chng zhng": [""], "d di de": [""], "cng zng": [""], "sh t": [""], "t ch": ["", "", ""], d: ["", "", "", "", "", "", "", ""], "zh zhng": ["", ""], bi: ["", "", "", "", "", ""], "chng zhng": [""], "jio jio": ["", "", ""], "lng lng": [""], "q j": ["", "", "", ""], "dng tng": [""], gi: ["", ""], rn: ["", "", "", "", "", "", "", "", ""], chn: ["", "", "", "", "", "", ""], t: ["", "", "", "", "", ""], "t ti tu": [""], "gn hn": ["", ""], "y q": [""], "ti sh": [""], "x li": [""], "yng yng": ["", "", ""], "mn wn mn": ["", ""], "sng zhng": [""], "y sh": ["", ""], "q sh": ["", ""], "tn zhn dn": [""], "qin qn": ["", ""], hn: ["", "", "", "", "", "", ""], ni: ["", "", "", "", "", "", "", "", "", ""], "kung wng": [""], "kng hng": [""], "ki x": ["", ""], u: ["", ""], "bo bo": [""], "mn mn": [""], "zu zh": [""], zn: [""], yng: ["", "", "", "", "", "", "", ""], "ku j": [""], "no ni": [""], "zhng zhng": ["", "", "", ""], "ti zhn": [""], "h g": [""], "c j z": [""], "s si": [""], "yu chu": [""], "t di": [""], "yu yo": [""], xun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "x xu": [""], "b p": [""], "x sh": [""], "nn nn": [""], "tio yo": [""], "x q x": [""], "xio jio": [""], "h ku": [""], n: ["", "", "", ""], hn: [""], "dng tng": [""], "qun zhun": [""], " w  w": ["", ""], tng: ["", "", "", "", ""], "yun jun": [""], "qio qio": [""], "ji k": [""], "ho jio": [""], hu: ["", "", "", "", "", "", ""], "mn mn": ["", ""], "y y": ["", ""], qun: ["", "", "", ""], "ku l": [""], "y nin": [""], "mn mn": [""], gun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "kng kng": [""], "ln ln": [""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "yun wn": ["", ""], "ln ln": [""], "y x": ["", ""], "chu chu": [""], "hn mn": [""], "chng tng": [""], "su ru": [""], cn: ["", "", "", "", "", ""], cn: ["", "", "", "", "", "", "", "", ""], "dn d": ["", ""], r: [""], "y tu": [""], "ki q": [""], "dng tng shng yng": [""], "chn xn dn": [""], "k qi": [""], nu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "cng sng": [""], "si s s": [""], "gng gng hng": ["", ""], "shu s": ["", ""], "yo yo": [""], hung: ["", "", "", "", "", "", "", ""], zhng: ["", "", "", "", ""], co: ["", "", "", ""], "x xi": [""], "co so": [""], "x ch": [""], "qi qin": [""], "co cng": [""], "o o": [""], "lin lin": ["", "", "", ""], "jn qn jn": [""], "d ch": [""], "zh zh": [""], "lu l": ["", ""], cng: ["", ""], "zh zh": ["", "", "", ""], chng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bi: ["", "", "", "", "", ""], "chng dng zhng": [""], "x x": [""], "du dn tn": [""], "xio jio": [""], "xin xin": [""], "lio lio": ["", "", "", ""], shng: ["", "", "", "", "", ""], "no no nng": [""], "jng jng": [""], "j jio": [""], "xun hun": [""], "co so so": [""], mn: ["", "", "", "", ""], "mng mng mng": [""], "i y n": [""], "mng mng": ["", "", ""], "q j j": [""], m: [""], "ln xin": [""], "yu yu": [""], "li li": ["", ""], rng: ["", "", "", ""], hun: ["", "", "", "", "", "", "", "", "", "", ""], nn: ["", "", "", "", "", "", ""], "m m": [""], "gng zhung": ["", ""], "zhung gng": [""], "x qu": [""], "x h": ["", "", ""], "ji g": [""], zi: ["", "", "", "", "", "", ""], dng: ["", ""], "h x": [""], chu: ["", "", ""], "bin pin": [""], "shng jing": [""], "shn shn": [""], ci: ["", "", "", "", "", ""], "zh z zh": [""], "l l ci": [""], "b p": [""], "d d": [""], rng: [""], "fn f": [""], "dio d yu l": [""], "kng gng": [""], "y w": [""], "y w k": [""], "tu ch y": [""], "g ji x g": [""], dn: ["", ""], "so so": ["", ""], ro: ["", "", ""], "x ch q": [""], "bn pn": [""], "b o": [""], "x zh": [""], "zh sn kn": [""], zho: ["", "", ""], "kung wng zi": [""], "h g": ["", "", ""], "b b": [""], "dn shn": [""], "n n ru n": [""], zhu: ["", "", "", "", ""], pu: ["", ""], "zh sh zh": [""], "pu pu f": ["", ""], po: ["", "", "", ""], "o o ni": [""], "ln ln": ["", ""], "qing qing chng": [""], "zh zhi": [""], "b p": ["", ""], "yo to": [""], "h h qi": [""], "n n": [""], "p pi": [""], "m m m": [""], chu: ["", "", "", "", ""], "ji y": [""], "f b": ["", "", ""], zh: ["", "", "", "", ""], "dn dn dn": [""], "chi c": [""], nin: ["", ""], "l l l l": [""], "bn pn": [""], pi: [""], ln: [""], gui: ["", "", ""], "tu t zh": [""], "o o ni": [""], "j gu": [""], "pn pn fn": [""], "bi bi": [""], bi: ["", "", "", "", "", "", "", ""], qi: [""], "nng nng nng": [""], "z zhi": ["", ""], hn: ["", "", ""], "ku gu": [""], "ji ji": [""], nn: [""], shun: ["", "", "", ""], "cn zn": [""], "z zn": ["", ""], ko: ["", "", "", "", ""], "y ch hi": [""], "c s chu": [""], "zhui zhui y": [""], "sh sh": [""], bi: ["", ""], "ku gung": [""], nng: ["", "", ""], "jio jio": ["", "", ""], "ku k": [""], "n r": [""], "tio tio": [""], "di sh": [""], li: ["", ""], "y y": ["", ""], "w zhu": [""], "xi ji": ["", ""], "dng dng": ["", ""], "zhng zhng": ["", "", ""], "i i": [""], "tu shu": ["", ""], "t t": [""], "su sh": [""], "s sh su": [""], "kng qin": ["", ""], "bng png": [""], "ru ru": [""], "jio k": [""], "w w": [""], tng: ["", "", "", "", "", "", "", ""], "hu ch": [""], "t sh ch": [""], "l lu": [""], "sho sho": ["", ""], ni: ["", ""], "sh sng su": [""], "y y": [""], "ju zhu": [""], "b p zh": [""], zn: ["", ""], lo: ["", "", ""], sn: ["", "", "", "", "", "", "", ""], "wn wn wn y": [""], png: ["", "", ""], sh: [""], "f f b": [""], do: [""], "lu lu w": [""], "jun qun": [""], "chn tin": [""], "nin ni": [""], "ru wi r": [""], zu: ["", "", "", "", "", "", ""], "w xi": [""], "qng qin": [""], "pu pu": [""], qi: ["", ""], "pi pi": [""], "qin wn": [""], "y y": [""], "ni n y": [""], "hu x": [""], "yn shn yn": [""], "zhng dng": [""], kng: ["", ""], tu: ["", "", ""], "zu zhu chu": [""], tin: ["", ""], kn: ["", "", ""], p: ["", "", "", "", "", ""], "gu gui": [""], "dn shn": ["", ""], "chn xin cn shn": [""], so: ["", "", "", "", "", "", "", "", "", "", ""], png: ["", "", "", "", ""], "zhng kng": [""], "ji yu": [""], "jin jin": ["", ""], "p ch": [""], "si zng ci": [""], "t d d": [""], "zng sng": [""], "hung yng": [""], "zn zun": [""], "x j": [""], "k qi": [""], "chui chui chui tun zhu": [""], "d t": [""], "l l": [""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ji q": [""], "chng dng": [""], "di sh y": [""], "jin qin jin": [""], y: ["", "", "", "", "", "", ""], chn: ["", "", "", "", "", "", "", "", ""], "g g": ["", ""], "lu lu": ["", ""], "chu zu": [""], chui: [""], sn: ["", "", "", "", "", "", "", "", "", ""], "rng nng nng": [""], "png bng": [""], cu: ["", "", "", "", "", ""], "k ": [""], "n nu nu": [""], "l xi xin": [""], qi: ["", ""], "xin xin": [""], "ji zh": [""], "pn bn p": [""], bn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zh ni": [""], "w w w": [""], hu: ["", "", "", "", "", "", "", "", "", "", "", ""], "qing qing chng": [""], "tin shn": [""], "n nu": [""], n: [""], "sh ni": ["", ""], bn: ["", "", "", "", "", "", "", "", "", "", "", ""], "sh s shi": [""], "chn sn": [""], "ji li lio jio no": [""], "fng png": [""], shui: [""], "d t zh": [""], "q j ch": [""], "su sng": [""], "lin lin": [""], "gi x": [""], "h ch": [""], tng: ["", "", "", ""], "ni zh": [""], "m m": [""], "jing qing": [""], "o qio": [""], "ni ch": [""], "mn mn": [""], "chn cn": [""], "s m s": [""], "bio bio": [""], "ju ju": [""], pi: ["", "", "", ""], "pi pi": [""], "zn zn zn qin": [""], "s s": [""], hng: ["", "", "", "", ""], "hng gung": [""], nin: ["", "", "", "", "", "", "", "", "", "", "", ""], "chng zhng": [""], "hu wi": [""], co: ["", "", ""], "xio su": [""], "lio lio": [""], "cu zu": [""], "wi tu": [""], cun: ["", "", "", "", "", "", ""], "qio yo j": [""], "zhu w": [""], "li li": [""], nng: ["", "", "", ""], "qng jng": [""], kui: ["", "", ""], "p b": [""], "b bi": [""], "j j": [""], mng: [""], "su su": [""], xng: ["", "", ""], c: [""], "nng nng nng": [""], "zh ji": [""], "l li": ["", ""], "su su": [""], "l lu yu": [""], "t zhi zh": [""], pn: ["", "", "", ""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "c s": [""], "jn pi": [""], "l lu": ["", ""], "l li": ["", ""], "l lu": [""], "zn cun": [""], "xin jin": [""], "m m m": [""], "zn cun zn zun": [""], zun: [""], "l shi": [""], "l lu": [""], "gu gu": [""], "j q y": [""], fng: [""], "w mu": [""], "ch shu": [""], "g gu ": [""], "du du": ["", ""], "du qu": ["", ""], "sn sn": [""], "dn du": ["", ""], "q y j": [""], "xio xu": [""], "sh sh shu": ["", ""], "i zh": ["", ""], "xing xun": [""], "zhu zh": [""], "y d": [""], "l ti": [""], "fi fi": [""], "y zhng": [""], "du du": [""], "w gun": [""], "tu tio": [""], du: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "yn zh": [""], "chn ji": [""], "w y y": [""], "yu li": [""], "png bng": [""], "mo mo": [""], "p b": [""], "xun xun": [""], "w m": [""], zo: ["", "", "", "", "", "", "", "", ""], g: [""], "gn hn": [""], "ti yng": [""], "x x": [""], "tn zhn": [""], "w w": [""], "p pi": [""], zng: ["", "", "", "", "", "", "", ""], i: ["", "", "", "", "", "", "", "", ""], "hung hung": [""], xun: ["", "", "", "", ""], "x ku": [""], hng: [""], shi: ["", ""], "yn yn": ["", ""], "shng chng": ["", "", ""], "jng yng": [""], shn: ["", "", "", "", "", "", "", ""], "q d": [""], "n n yn": [""], "wng wng": [""], zn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "yn yn": [""], "mn mn": [""], "d sh": [""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "jin ln": [""], nun: ["", "", ""], "bo p": [""], "x x": [""], "p bo": ["", ""], "q q": [""], "q q": [""], "gng gng": [""], "h h": ["", ""], "zng cng": ["", ""], "cng zng": ["", ""], "cn qin jin": [""], "qi h": [""], "b p": ["", "", "", ""], "yu yu": [""], "bn fn": ["", ""], "f f": ["", ""], "fi k": ["", ""], "q x chn": [""], "jun zu": [""], "hung mng wng": [""], "q j": [""], "tng chung": ["", ""], zh: ["", "", "", "", "", "", "", "", ""], "zh sh sh": [""], "sh sh zh": [""], "zh sh": [""], "p p p pio": [""], "do tio m": [""], "gu qi": [""], xi: ["", "", "", ""], "chng chng": [""], z: ["", "", "", "", "", "", "", ""], "y w": [""], "gn gn": [""], "ch ch": [""], "shn sh": [""], cn: ["", "", "", "", "", ""], "rn r": ["", ""], "sho bio": [""], "d du": ["", ""], "g gi": [""], "y zh l du": [""], "gng gng": [""], "tio tio": ["", ""], "m m": [""], "s zh x": [""], "yun wn": ["", ""], "bi fi": [""], "sh du": [""], "ni chu": [""], "w yu": ["", ""], mo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "p m": [""], ng: ["", "", ""], "fng bng": [""], "h d": [""], xn: ["", "", "", ""], "yo yo": [""], " ": [""], "zh q": [""], "cng zng": ["", ""], "xin zhn": [""], "ti s": [""], "gu j gu": [""], "bo f": [""], "y xi": ["", ""], "tu du": ["", "", "", ""], "y du l": [""], "n ch": [""], "pn bn": ["", ""], "yng yng yng yng": [""], "f f f": [""], "bi b b": [""], mu: [""], "sho sho": [""], zh: ["", "", "", "", "", "", "", "", "", ""], "yu yu": ["", ""], "gu j": [""], "zh zu": [""], "di zh": ["", ""], "zh z z": [""], "ch zh": ["", ""], "o o": ["", ""], "b f pi b bi": [""], "du zu w": [""], "b bi": [""], "zh ch": [""], "bi pi": [""], "sh fi": [""], "shn zh shi c": [""], "l yu": ["", ""], "q qi": ["", ""], "q x": ["", ""], "gu ku": [""], "bng bn": [""], "xio jio": [""], "jin zn": ["", ""], "yu y": [""], "h h": [""], gn: ["", ""], "zh y": [""], "g g": [""], "hng hng": [""], "gung gung": [""], "y t": ["", ""], sng: ["", "", ""], "j ji": [""], "y mu": [""], "ro no": ["", ""], "gu hu": ["", ""], "chn zhn": [""], "tng yng": [""], "b po": [""], "bn fn": [""], "fng fng": ["", ""], "s yn": [""], "tng tng": [""], "xun jun xi": [""], "t ch": [""], "o yu": [""], kun: ["", "", "", ""], "sho so": [""], "qn chn cn": [""], "l s q": [""], "chn yn": [""], "bn bng": ["", "", ""], "to chu do": [""], "cng sng": [""], "gn hn": [""], "d zh": [""], "pi bi pi": [""], "bng pu bi bi": [""], "d di t": [""], sn: ["", "", "", ""], "rn shn": [""], "lng lng lng": [""], "f s": [""], "zu su": [""], zu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zho zhu": [""], "chn shn": [""], "ji qi": [""], "y y": [""], "chu zhu dio": [""], "qing kng": [""], "zhu chu": [""], "bi p": [""], mn: [""], "qun jun qun": [""], "du chun": [""], "wi hu": [""], "ji ji": [""], "hn jin": [""], "shn zhn": [""], "yn y": [""], "zh ch": [""], "gu ku": [""], "j zh": [""], "k h": [""], "yu yu": [""], "sng cng": [""], "yun xun": [""], "yng yng yng": [""], pin: ["", "", "", "", "", "", "", "", "", ""], "di y": [""], "dn shn": [""], "cu zu": [""], "d d sh": [""], "ki ji": [""], "ru ru": [""], "l yu": [""], "wn yn": ["", ""], l: ["", "", "", "", "", "", "", "", ""], shn: ["", "", "", "", ""], "b pi": [""], "zhn nin zhn": [""], "f f b": [""], "jin jn": [""], "bng bng": [""], "sh xi": ["", ""], nu: ["", "", "", ""], "qin lin xin": [""], gng: ["", "", "", "", ""], go: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "din zhn zhn": [""], "kn jin": [""], "x di": [""], "j gu": [""], "rng yng": [""], "tun shun qun": [""], "q s": [""], "cu zh": [""], "yu cho": [""], "mn wn": [""], "l ch": [""], "li li": ["", "", ""], "cho jio cho": [""], "chng tng": [""], "ji lio": [""], "m m": [""], "nio m": [""], "hng hng": ["", ""], xu: ["", "", "", "", "", "", ""], "f fi": [""], rn: ["", "", "", "", "", "", ""], "zhn jin": [""], shn: ["", "", "", "", "", "", "", ""], "tu dn": [""], "tng chng": [""], "s qi": [""], "tn din": [""], "fn fn fi": [""], "rn yn": [""], "c chu": [""], "sh qio": [""], "png b": [""], "zhi sh t": [""], "bio bio": [""], "qin lin": [""], "n m": [""], "jin kn": [""], "nu run r": [""], "j j": ["", ""], "hung gu g": [""], "l ch": [""], "mi mi": [""], u: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zh zhu": [""], "ju j": [""], "hui gu": [""], "chn zhn": [""], "wi zu": [""], cng: ["", ""], "y y": [""], "ch q x": [""], "ki i": [""], "y yn": [""], "x ki": [""], "shu su": [""], "i i i i i    ": [""], "q y": [""], "chu x": [""], "ch chui": [""], "kn qin": [""], "kn k": [""], "chun chun": [""], "yn yn": [""], "jn qn": [""], pn: [""], "x chu": [""], "x sh": [""], "lin hn": [""], "zh ch": [""], "s sh": [""], s: [""], "wn m": [""], pio: ["", "", "", "", ""], "qng jng": [""], "fu b": [""], "zh shi": [""], "y yn yn": [""], "hn mi": [""], chu: ["", "", ""], "ku hu": ["", "", ""], cun: ["", "", "", "", "", "", ""], "yn yn yn": [""], "qng kng shng": [""], "yo xio xio": [""], "g g": ["", ""], "gun wn": [""], "d di": [""], "xn xn": [""], m: ["", ""], "du nu": [""], "si su": [""], lu: [""], so: ["", "", "", ""], "sh zh": [""], "d d": [""], "mng mng": [""], "yng r": [""], shu: ["", "", "", ""], "zhng chng zhng": [""], tn: [""], "fn fn": [""], "gu ji": [""], "bn p p": [""], "zhu qu": [""], "d ti": [""], pn: ["", "", ""], "hn hn": ["", ""], tu: [""], "tng shng": ["", ""], "zh j": [""], "gn hn cn": [""], "wn mn": [""], "fng png": [""], "h hung": [""], "ni yu": [""], hng: [""], "shn chn": [""], "dn zhun": [""], "n ni": [""], "mi m": ["", ""], "t d": [""], "m w": [""], "hng png": [""], "sh sh": [""], "zhu z": [""], "u u": ["", ""], "j j": [""], "tu du": [""], "m l": [""], "y ch": [""], "xi y": [""], "b p": [""], "m b": ["", ""], "ch sh": [""], "yu yu o": [""], "png png": ["", ""], "po po": [""], "n n": ["", ""], "yu s": [""], "ju xu": ["", ""], "lng shung": ["", ""], "lu p": ["", ""], "z sh": ["", ""], "s x": [""], "s q z": [""], "x xin": [""], "ko ko": [""], "n yn ": [""], "li li": [""], "qi ji": [""], "qin jin": [""], "j j": ["", "", "", ""], "h x": ["", ""], "jn xn": ["", ""], "yng chng yng": [""], "lin l": [""], "fng hng": ["", ""], "jing jing": [""], "su ni": [""], "yng chng": [""], "tn yn": [""], "w gu": ["", ""], hng: ["", ""], "zhng zhng": ["", ""], "shu to": [""], shun: ["", ""], "kng nng": [""], "w wn yun": [""], "tu tu": [""], w: ["", "", "", "", "", "", "", "", ""], "qi j": [""], "gu gun": [""], "ln ln": ["", "", ""], "tng chng": [""], "no chu zhu": [""], "png png": [""], fi: ["", "", "", ""], "p pi": [""], "nin shn": [""], "bio h": [""], "chn zhn": [""], "hn hn": [""], qin: ["", "", "", "", "", "", "", "", "", ""], "wn mn": [""], "r ru lu": [""], "d du": ["", "", ""], "jin jin": ["", "", "", ""], "min shng": ["", ""], "nun nun": [""], "qi w": [""], "tng tng": [""], "d t d": [""], "gng jing": [""], "hng qng": [""], tun: ["", ""], "hu mn x": [""], "x x": [""], pn: ["", "", "", ""], "mn hn": [""], "tun nun": [""], "qi jio": ["", ""], "yn yn": [""], "bn pn": [""], "zhung hn": [""], "yn gu": [""], "lin lin nin xin xin": [""], "d t": ["", ""], "li li": ["", "", ""], ln: [""], m: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "zhn qn": [""], "n nio": [""], "ch x": ["", ""], "wng wng": [""], "ho xu": [""], "q x xi": [""], "xng yng": [""], "z ho": [""], "pio pio pio": [""], "cng sng": [""], "fng png": [""], "lu t": [""], "png bn": [""], "chng shung": [""], "hu ku hu": [""], "lio li": [""], "cu cu": [""], "cng zng": [""], "cng zng": [""], "p pi": [""], "dng xing": [""], "hung gung": [""], "lio lo lo": [""], "cng zng": [""], "zh zh": [""], "tn shn": [""], "t zh": [""], "sn s": [""], hi: ["", "", "", ""], "chng dng": ["", ""], "cn cn": [""], "png png": [""], "hng gng": ["", ""], "wn mn": [""], "kui hu": [""], "gu w": [""], "pn fn": [""], "j sh": [""], "hu hu": [""], "dng tng": [""], "m n": [""], "b p": [""], "cu zu": [""], "h hu": [""], "i ki k": [""], "wi du": ["", ""], "zn cun": ["", ""], "yng yng": [""], "wng wng": [""], "m mi": ["", ""], su: ["", "", ""], "hui wi": [""], "zn jin": [""], "yng yng yng": [""], "rng rng": [""], shung: [""], "zhu jio z": [""], s: ["", "", ""], "lun lun": [""], "dng tng": [""], "xn qun qun": [""], "hu bio": [""], "zh y": [""], "fn bn": [""], "jing gu": [""], "png fng": [""], qu: ["", "", "", ""], bin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zho zho": [""], "zhu ch": [""], "po po bo": [""], "po fu": [""], "shn qin shn": [""], "zh zh": [""], "jio yo": [""], qun: ["", "", "", "", "", "", ""], "yng yng": [""], "lo lu": [""], "hu hu": [""], r: ["", ""], "f po": [""], "xi ch": ["", ""], "yn shn": [""], "hn xn": [""], ko: ["", "", "", "", "", "", "", "", ""], "jun y": [""], "jn q": [""], "to do": [""], "cho j": [""], "w i": [""], "zng cng": [""], "x y": [""], "xn xn": [""], "cho zhu": [""], "xing yng": ["", ""], ku: ["", "", "", "", ""], "hu yn xn": [""], "jio qio": [""], "qin shn shn": [""], "x y": [""], "sh sh": [""], "y zh": [""], "yng yng": [""], "n yn": [""], "yn yn": [""], "h xio": [""], xing: ["", "", ""], "xn xn": ["", ""], gng: ["", "", ""], li: [""], "cng zng": [""], "l o": [""], "sh shu": [""], "fng png": [""], "cu su": [""], tng: ["", "", ""], "yn y": [""], "o o": [""], "hn rn": [""], "u u": [""], "hung hung": [""], "chn dn chn": [""], "jio zhu qio ju": [""], "yn yn": [""], "ti li": [""], o: [""], "yn xn": [""], "ju jio": ["", "", "", "", ""], "ln ln": [""], "zhu zho": [""], "zho zhu": [""], "f f": [""], di: ["", "", ""], zng: ["", "", "", "", "", "", "", "", ""], "pin pin": [""], "bin min": [""], bng: ["", "", ""], "yu yng": [""], "chng chng": ["", ""], ni: ["", ""], "ji l": [""], "m mu": [""], mng: [""], "g qi": [""], "yu chu": [""], "t zh": [""], bn: ["", "", ""], "jin qin": ["", ""], m: ["", "", "", "", ""], "mo l": [""], "b qun": [""], "zhu bo": [""], "n hn": [""], "kng gng": [""], "pi fi": [""], "fn hun": [""], kung: ["", "", "", "", "", "", "", ""], "y qun ch": [""], "xng shng": [""], "tu y": [""], k: ["", ""], "hun hun": [""], "h m": [""], "t sh": [""], "mng du": [""], "x sh": [""], sun: ["", "", ""], "bi p": [""], "jin yn": ["", ""], "y y": [""], "y wi": [""], ci: [""], "mo mo": ["", ""], "chun chun": [""], "tun tun": ["", ""], "y ji qi": [""], "h xi g hi": [""], "bin pin": ["", ""], "b p": [""], "ho go": [""], "fn fn": [""], "yo xio": [""], "shu x": [""], "g li xi": [""], "nu r": [""], "no no yu": [""], rng: ["", "", "", "", "", "", "", ""], "no yu": [""], "l shui": [""], "wng wng": [""], "yng chng": [""], "mn wn": [""], "bn fn": [""], "mn yn": [""], "qing cng": ["", "", ""], "n gn": [""], "xun xin": [""], "c c": ["", ""], "y ti": [""], "z j": [""], f: ["", "", "", "", ""], "yn kn": [""], "hu hn": [""], "xun qing": [""], "f f": [""], "bng pn": [""], "cu s": [""], "y wi": [""], "tin tin": [""], "zhu zu": [""], "bng pi": [""], gun: ["", "", "", "", "", "", "", "", "", "", ""], "hn hu": [""], "xi ji": [""], "chng dng yng": [""], "tin zhn": [""], "bn pin": ["", ""], "t sh": [""], cu: ["", "", ""], "zo su": [""], "ju qing": [""], "l f": [""], "j z": [""], su: ["", "", "", "", "", "", ""], "m x": [""], "qing wi wi": [""], "hun y y": [""], "b po": [""], "zh h": [""], pio: ["", ""], "w w": [""], "xing hng": [""], wng: ["", "", "", "", ""], "shn shn": [""], ru: ["", "", ""], yng: ["", "", "", "", "", ""], shui: [""], bng: ["", ""], "yu zh": [""], "din tin shng": [""], "tng dng": ["", ""], "zi z": [""], "b q": [""], "d f": [""], "c j": [""], "zi z tin": [""], "zh chu sh": [""], "fn pn": ["", ""], "sh y": [""], "dng dng dng": [""], "jing qing": [""], "p y sh": [""], "ji qi": [""], "y n": [""], n: ["", "", "", ""], "g y": [""], "n yo": ["", ""], "l li": ["", ""], "y xi": [""], xu: ["", "", "", "", "", "", ""], "dn da": [""], "f bin": [""], "fi fi": ["", ""], "shn din": [""], "tng chng": [""], "tng tng": [""], "wi yu y": [""], "tn sh": [""], "p p": ["", ""], "bng png": [""], "m ln": [""], "tin din": [""], "n y ": [""], "k ": [""], "zh ch": [""], "ji xi xi": [""], "li hu": [""], "chi cu": [""], "din chn": [""], "da d": [""], "bi bi": [""], qu: [""], "dn dn": [""], "gu wi": [""], "nng nng": [""], "bi bi": [""], "b b": [""], bi: [""], "j b": [""], "de d d d": [""], "p b": [""], "go ho": [""], "go yo": [""], "l lu b": [""], "zh c": [""], "zho zhn dn": [""], "jin jin": ["", "", "", "", ""], "gi g h": [""], "mng wng": [""], yun: ["", "", ""], "tin xin": [""], "xing xing": [""], dn: ["", "", ""], "x pn": [""], "shng xng": [""], "yn hn": [""], "min min": [""], "kn kn": [""], "yng yng yng": [""], "yo o o": [""], "j x ku": [""], "y ch": [""], "di t": [""], "bng fng": [""], "png pn": [""], "m m": ["", ""], "xun shn xn": [""], tio: ["", "", "", "", ""], "zhe zhu zho zho": [""], "qio sho xio": [""], "cu zhui": [""], gn: ["", ""], "su zu": [""], "p b": ["", "", ""], "y z go": [""], "xng xng": [""], "gu wi ku": [""], "ku j": [""], "qing hun": [""], "mn mn": ["", ""], "dio du": [""], "lou lu l": [""], "shn rn": [""], "lio lio": ["", ""], "jin xin": [""], "w m": [""], "gu ku": [""], "nng chng": [""], "hu yu": [""], "mng mng": [""], "kung gu": [""], "gun qun": [""], "mn mn": [""], "jn gun qn": [""], "jn qn gun": [""], "y x ju": [""], "jio jio": ["", ""], dun: [""], "sh dn": [""], "gng qing kng": [""], "hu x": [""], "pn bn fn": [""], "yn yn": ["", ""], "lu k": [""], "f fi": ["", ""], "zh zh": [""], "l l l": [""], "kung gung": [""], "g lu": [""], "shu sh": ["", ""], "wi wi i": [""], "qu k k": [""], "mng bng": [""], "lu lng": [""], "yng tng": [""], n: ["", ""], "kng kng": [""], "yn yn": [""], "zhu chu du": [""], "kng kng": [""], "zng cng": [""], "jin zhn": [""], "l li": ["", ""], "qu x": [""], "ln ln ln": [""], "no gng": [""], "ji y": [""], "wi wi": [""], "t d": [""], "ch ch": [""], "qio qu": [""], "s xi": [""], "li li": ["", "", "", ""], "s t": [""], "bng png": [""], "hu k g": [""], "wi ku": [""], "xi qi y": [""], "lin qin": [""], "wi i gi": [""], "l l": [""], "o qio": [""], "png png": ["", ""], "yn yn": [""], "li li": [""], "m m": [""], "q zh": [""], "lo lu": [""], "pn b": [""], "j sh": [""], "h qio qio": [""], "k hu": [""], "qu h": [""], " q": [""], c: ["", ""], "xin xn": [""], "li li li": [""], "yn yn": [""], "q zh": ["", ""], "bng fng": [""], "b m": [""], sun: ["", "", "", "", ""], "pio pio": [""], "j zhi": [""], "shu li": [""], "jn jn": [""], "chn shn": [""], "yng shng": [""], "zh zh t": [""], "shn chn": [""], "y y u": [""], "z z": [""], "ch n": [""], "zhng zhng chng": [""], "ho mo": [""], "k k": [""], z: ["", ""], chng: ["", ""], "hu ku": ["", ""], "chng chn chng": ["", ""], "sh zh": ["", ""], "f p": [""], "xn z": [""], "t sh": [""], "zhn zhn": [""], "j q": ["", "", ""], "lng lng": [""], "zu z s": [""], "x qi": ["", ""], "zhng zhng": [""], "zng zng": [""], "xin jin lin": [""], "z ji": [""], "j q": [""], rng: [""], "shn cn cn": [""], "mn mi": [""], "j j": [""], "xio ro": [""], "zhu b": [""], "tng zhng zhng": [""], zu: [""], "bio po": ["", ""], "zhu ju": [""], "cun zn": [""], "kng kng kng": [""], "y y": [""], zhi: ["", ""], bo: ["", ""], "k zh": [""], "jio lio li": [""], "w gu": [""], "tio yo": [""], "xn yn": [""], "y y": [""], "tin din yn": [""], "cho k": [""], "kun cun": ["", ""], "ch q": [""], "q ku": [""], "jng zhn": [""], "kn kn": [""], "zh d": [""], "l jn": [""], "zhu ru": [""], "hng hng": [""], "cn jn hn": [""], "d xi n": [""], "z zu": [""], "lng lng": ["", "", "", "", ""], "zh zh": ["", ""], "d d": ["", ""], shi: ["", "", "", ""], "yn jn": [""], "lng lng": ["", "", ""], "zh zh": [""], o: [""], "pu b f p": [""], "pi bi": [""], g: ["", "", "", ""], "ti ch": [""], "gui di": [""], "zho do": [""], "jng qng": [""], "ln ln": [""], "jn qn": [""], "sh y": ["", ""], "yu yo chu": [""], "xio shu qio": [""], "gng gn lng": [""], "png png": [""], "zhu hu": [""], "jin jin": [""], "d zh": [""], "zn cn cn": [""], "zhun sun zun": [""], "pio bio": [""], "gu gu": [""], "c j": [""], "m mi": [""], "shi s": [""], "sn zhun": [""], "gn gn": [""], "b b": [""], "b b": [""], shi: [""], "zhn jin": [""], "zhun zun": [""], "fn pn bin": [""], "su sh": [""], zun: ["", "", "", "", "", ""], n: ["", "", ""], "sh cho": [""], "kng jng": [""], fn: ["", ""], c: ["", "", "", "", ""], "nin zhn": [""], "c s": [""], "zhu y": [""], "shn sn": [""], "bin bin": ["", ""], min: ["", "", "", "", "", "", ""], "h h h": [""], "g gu": [""], "m mi": [""], "sn shn": ["", ""], zo: ["", "", "", ""], "m s": [""], "ji ji": [""], "x j": ["", ""], "zhng zhng": [""], "ch ch": ["", ""], "yu yo": ["", ""], "hng gng": ["", ""], "h g": ["", ""], "wn wn": ["", ""], fu: [""], "j ji ji": [""], "p p b": ["", ""], "jn jn": [""], "zh z": ["", ""], h: [""], "f f": [""], "chu chu": [""], "li li li": [""], "b b": [""], "tin zhn": [""], "jing jing": [""], "ji ji": ["", "", ""], "gu ku": [""], "bi m": [""], "gng hun": [""], "ji xi": [""], "qun shun": [""], "gi i": [""], "lu lo": ["", ""], "bng bng png": [""], "gi j": ["", ""], "tng tng dng": [""], "tio dio do": [""], "li li li": [""], "gi hi": [""], "ch zh": [""], "wn min mn wn": [""], "hun hun wn": [""], "qn xin": [""], "t t": [""], "yn xin": [""], "zng zng zng": [""], "chn ln": [""], "zhn zhn": [""], "qin qng zhng": [""], "qng q": [""], "ln gun": ["", ""], "chu cho": ["", ""], "tin tn chn": [""], "l l": ["", ""], "run run": [""], "j q": [""], "zhng chng": ["", ""], "mio mo": [""], "xi y": [""], hun: ["", "", ""], "gng gng": ["", ""], "tu x sh": [""], "zng zng": ["", ""], "yn gn": [""], "gu w": [""], "yn yn wn": ["", ""], "bng bng": [""], "g h": ["", ""], "c cu su": [""], "cu shui": [""], "rng rng rng": [""], "zi zng": [""], ci: ["", "", ""], "fng fng": [""], "su s": ["", ""], "yn yn": ["", ""], "zng zng": ["", ""], "zhun jun": [""], "m m": ["", ""], "pio pio": ["", ""], "fn p": [""], "bng bng": [""], "mu mi mio lio": [""], "yo yu zhu": [""], "zng zng": ["", ""], "j ju": [""], "chu chu": [""], "zn zn": [""], ro: ["", "", ""], "chn chn": [""], "hu hu": ["", "", ""], "qio so zo": [""], "jio zhu": ["", ""], "dn tn chn": [""], nng: [""], "p f": [""], "yo l": [""], "rng xing": [""], "l s x l": [""], "xin qin": [""], "jng jng": [""], "t t": [""], "bng bng bng": [""], "zng zng": [""], "j q": [""], "wn yn yn": [""], "fng fng": [""], "shui cu su": [""], "mi mu lio mio m": [""], "qio so": [""], fu: ["", "", "", "", ""], "b ba p": ["", ""], "gu gui": [""], "yng xing": ["", ""], "mi go": [""], "y x": [""], "qing qin": [""], "qing kng": [""], "qin xin yn": [""], nu: [""], "hng gng": [""], "p b p": [""], "q y": [""], k: [""], "qio qio": [""], "zhi d": [""], "do zhu": [""], "hu q": [""], shu: [""], "run nu": [""], "r ni": [""], "zhun dun": [""], "p b": [""], "ch s": [""], "q ch": [""], "ln ln": [""], "j ji": [""], "tng tng": [""], png: ["", ""], "zh z": [""], "y y": [""], "yn yng": [""], "w tu zhu": [""], "r n": [""], "ti zh": [""], "d zh": [""], qi: [""], "n jin": [""], "li l": [""], co: ["", "", "", ""], "b d": [""], "xio xio": [""], "d d": [""], chi: ["", "", ""], "hn qn hn": [""], "png pn pn": ["", ""], "zhn chn": [""], ng: ["", ""], "y y": [""], "p b b": [""], "fi b": [""], "bi bi": [""], "fi z": [""], "png png": ["", ""], "f f zhu": [""], "shng shng": [""], ku: ["", "", ""], "gi hi": [""], "g g g": [""], "nng ni": [""], "gu ku": [""], "mi m": [""], "zng zng": [""], "jio ju": ["", ""], cu: [""], "de te": [""], "zu jun": [""], ni: ["", "", "", "", "", ""], "p f": [""], nio: [""], shu: [""], gu: ["", "", ""], "l x": [""], "yn ": [""], "go go": [""], "l bio": [""], chui: [""], "zhun chun chn zhun": [""], chui: ["", ""], "fn pn": [""], "w h": [""], "shn dn": [""], tn: ["", "", "", "", "", "", "", "", "", "", "", ""], "b bei": [""], "l g": [""], "so so": [""], no: ["", "", "", ""], "n lun": [""], "qin xin": [""], "gung jing": [""], "gung jing": [""], "chu xi": [""], "min bin": [""], "di zh": [""], "zh jn": [""], "sh sh": [""], p: ["", ""], "bn b pn": [""], ku: [""], "gn gn": [""], "s shi": [""], "f b": [""], "jio qi": [""], "chi ch": [""], "sho qu": [""], "h xi": [""], "z z": [""], "hu h": [""], "tn chn": [""], "ji gi": [""], "x zh": [""], "yun yn": [""], "xn xn": [""], "ln hu": [""], "w h": [""], "gu gu": [""], "mo mo": [""], "fi f": [""], "chn yn": [""], qi: [""], "s s": [""], "tio sho": [""], "l j": [""], "k h": [""], "j q": [""], "ru r": [""], "zh nng": [""], "p b": [""], xi: [""], "zh zu": [""], "j ch": [""], ni: [""], "shng ru": [""], "qi ji": [""], "z c": [""], "qin x": [""], chi: [""], "f pi": [""], ro: ["", "", "", "", ""], "yng xng": [""], "qin xn": ["", ""], "yn yn": [""], "h h": [""], "sh su": [""], "png fng": [""], "shn xn": [""], "wn gun gun": [""], "yu s": [""], "sho xio": ["", ""], "lng ling": [""], "pio f": [""], "wn wn min": [""], "sh sh": ["", ""], "t t": [""], "xin lin": ["", ""], "wn y": [""], "zu ch": [""], "l l": [""], "jn jn": [""], "ni rn": [""], "z z zi": [""], "t t": [""], "ji sh": [""], "qio zho": [""], "ti zh ch": [""], "fi fi": ["", ""], "qn qn jn": [""], "z j": ["", ""], "ln m": [""], "tin tin": [""], ti: ["", "", ""], "lu l lo lu": [""], "zh zhu zhe": [""], "shn rn": [""], "g g": [""], "jn su": [""], "ku kui": [""], "r n": [""], "mng mng mng": [""], "yun hun": [""], "x sh": [""], "x x": [""], "m mng": [""], "su su": [""], "gi g h hi": [""], "yo zhu": [""], "dio tio d": [""], "x qi f": [""], "z j": [""], "lio l": [""], xu: [""], "hn hn": [""], "mn wn mn": [""], "p b": [""], "fn fn b": [""], "hng hng": [""], "y o": ["", ""], "x xio": [""], "bo b b": [""], "c z": [""], "wn lun": [""], "ko ho": [""], "yun wi": [""], "zhu chu": [""], "w mi": [""], "xio ho": [""], "y x x": [""], "ji j": [""], "dio zhu": [""], "cng zng": [""], l: [""], "ch zh": [""], "pn png": [""], "gn hn": [""], "hng jing": [""], "hu hu": [""], "xi h": [""], "m m m": [""], "fng bng": [""], "bng bng": [""], "ju qu": [""], "qn qin": [""], "gng zhng": [""], "f f": [""], "di d": [""], "gu q x": [""], "b p": [""], "sh y": [""], ti: ["", "", "", "", "", "", ""], "g lu": [""], "mng bng": [""], "y x": [""], "h g": [""], "qi n": [""], " y": [""], "zh zh": [""], "l zh": [""], su: ["", ""], "yu qi": [""], "xi h": [""], "x q": [""], "b p": [""], "ni nng": [""], "h xi": [""], "gu hu": [""], "m m m": [""], "sh zh": [""], "zh di": [""], "jin chn": [""], "ma m m": [""], "mng mng": [""], "bi bi": [""], "bn fi": [""], "lo lio": [""], "yn xn": [""], "l l": [""], "xu xi": [""], "xng hng hng hng": [""], "shui cu": [""], "tu tu": [""], "lng lng": [""], "bo po po": [""], "j ji": [""], "h k": [""], "y y": ["", ""], "n ju": [""], "bi p": [""], "ch nu": [""], "ch q du nu": [""], "ji qi ji": [""], "b m": [""], "gu gu": [""], "li li": [""], "chng chng": [""], "ji g": [""], "do chu": [""], "shang chng": [""], "yun gn": [""], "yn n": [""], "t x": [""], "f f": [""], "ch zh": [""], "tu tn": [""], li: [""], "yo yo": [""], "qn tn": [""], "jin xin": ["", ""], pin: ["", "", "", "", ""], "pi mi": [""], "yng yng": [""], "q q": ["", "", ""], "jin bin": [""], "lu lun": [""], "z zu": [""], "hu xi": [""], "ji ji xi": ["", ""], "xu h": [""], "l l": [""], to: ["", ""], zhn: [""], "z z": [""], "y di": ["", ""], xing: ["", ""], "dio tio": [""], "y ch ch": [""], "lng lng": [""], "i i i i x": ["", ""], shu: [""], "y y": ["", "", ""], "shu shu yu": ["", ""], "shu shi": ["", ""], "q ju": [""], "ch li": [""], "n n": [""], "dio tio": [""], "p bi": [""], "j j": [""], "z zu zh cu": [""], "ch j": [""], "ho xi": [""], "ln ln": ["", ""], "sh d": [""], "hu gu": [""], "x shi i": [""], "nn nn": ["", ""], mi: ["", ""], zn: ["", ""], "sh zh": ["", ""], "jun xun": [""], "y tu": [""], zhn: [""], "x h": [""], "xing yng": [""], "tio dio zhu": [""], "chn shn": [""], "m mi": [""], "mn mn": [""], "g y": [""], "hu hu hu": [""], "zh zhi": [""], "hun hun": [""], "kn kn": [""], "m h": [""], "m h ho": [""], "j lu": [""], "z zhi": ["", ""], "di t": [""], "b bn": [""], "ji g ji": [""], "xing mn": [""], cng: [""], "zhun zun": ["", ""], "wn zhun": [""], "gn gng zhung": [""], "yun yn": [""], "bn b": [""], "ji g": [""], zu: ["", "", ""], "di t": [""], "j qi": [""], "q c": ["", ""], "j ji": [""], "gu hu": [""], "qu q j": [""], "tng tng": [""], "chu zhu": [""], "q c": [""], "yu t": [""], "b bo": [""], "ku w": [""], "gu ju": [""], "fng fng png": [""], "po b": [""], "q q": [""], "jin chn": [""], "po po": [""], "din di ti": [""], "j j qi": [""], b: [""], "lu l": [""], "di du du ch": [""], zhui: [""], "bng pin": [""], "tio to": [""], "sh chu": [""], "ling ling": [""], "t t": [""], ch: ["", "", ""], "d zh": [""], "dng dng": ["", "", ""], cng: [""], "dn cn": [""], "ju ju": [""], lio: [""], "xi s": [""], t: ["", "", ""], "y zh g": ["", ""], "xn xin": [""], "fn gu": [""], "zhun zhun": [""], "zhu zhu": ["", ""], b: ["", "", ""], "zhun zhun zhui": [""], "zi zi": [""], "nin zhn": [""], "bin bian": [""], "do bin": [""], "y y": ["", "", ""], "gu guo gu": [""], "wng kung": [""], "hi hun": [""], "zh zhi": [""], "yun yun": [""], "zh l": [""], "zh wng": [""], "zhu du": [""], "sh ku": [""], tu: [""], "tng tng": [""], gung: [""], "di di": [""], "su su": [""], "t d": [""], "y wi": [""], "sh d zh": [""], c: [""], "hun hi": [""], "l ch": [""], "kng hng": [""], "n ni n": [""], "xi y y y x": [""], "gi hi": [""], "hun xn": [""], "ch x": [""], ho: [""], "l zh": [""], "xio o": [""], "du d": [""], lio: ["", "", ""], "zn cun cu": ["", ""], "dng dng": [""], "c zu": [""], "f p": [""], "shi sh": [""], ning: ["", ""], "qi chu": [""], "p f": ["", ""], "chn chn": [""], "yn lin xin": [""], "ning ning": [""], "l li": [""], "l x x": [""], "lio lio": [""], "dng dng": ["", ""], "qio jio": [""], "y hu": [""], "hu w": [""], "r rn jin": ["", ""], "d di": [""], "p zho": [""], "y y": [""], "b p": ["", ""], "t tu": ["", ""], bi: [""], "bng png": [""], "h k": ["", ""], chng: ["", ""], "xing jing": [""], "y s": [""], "x hu": [""], "rn rn": [""], "shn shu": [""], "ch l": [""], "xin x": ["", ""], "hu xing": [""], "dio tio yo": [""], "xin ku tin gu": ["", "", ""], "zh ni": [""], "zhng yng": [""], "tu t du": [""], "mi mng": [""], "wn jin": ["", ""], "tng dng": ["", ""], "jun jin cun": [""], "s tu": [""], "jun xun jun": [""], "w hu w": [""], "zhu chu": [""], "xng xng jng": [""], "j j": ["", ""], "zu ni": [""], "yun yun wn wn": [""], "gng gng": ["", ""], zhu: ["", "", "", "", ""], : ["", ""], "cu ch": [""], "su s": [""], "yo z": [""], "y t g": [""], "qing chng": [""], "g l": ["", "", ""], "b p b": [""], "go ho": [""], "z chu": [""], "xi xi": [""], "shu su": [""], "d d": ["", ""], "qio sn cn": [""], "l o": [""], "tng tng": [""], "jin zn": [""], "hu su ru": [""], "qing qing": ["", ""], "sn xin s": [""], "jin jin": ["", ""], "dng chng": ["", ""], "zun zun": [""], "s x": [""], "yo yu": [""], "tu du": [""], "zun zun": [""], "qin yn": [""], "p p": [""], "yo dio tio": [""], "tng tng": [""], "p p": [""], "tn xin": [""], "li li": [""], "ho go": [""], "tng tng": [""], "tn chn xn": [""], "hu shn": [""], "hn b": ["", ""], "kng kng": ["", ""], "xin jin jin jin": [""], "xi xi": [""], "xi k": [""], "bin gun": [""], "h g": ["", ""], "hng xing": [""], "s x": [""], "tng tng": [""], " yn": ["", ""], "hng jun xing": [""], "bn pn": [""], "d sh": ["", ""], "qu qu": [""], "tng tng chng": [""], "kn hn": ["", ""], "x s t": [""], "mn mn": [""], "qu qu": [""], "yn din": [""], " ": [""], "bi p p": [""], "yn yn": [""], "y yo sh": [""], "lng lng": [""], "du zhu": [""], "su du": [""], "gi q i": [""], "hu du": ["", ""], "wi ku": [""], "l di": [""], "zhu cu wi": [""], "h h": ["", ""], "jn jun": ["", ""], "nn nn nu": [""], "qu qio qio": [""], "gun hun": [""], "gu x": [""], "s x": [""], n: [""], "w mng": [""], tng: [""], "l lu": [""], mi: [""], "jng ling": [""], "g j": [""], b: [""], "yng yng": [""], "g t s": [""], "bin yng": [""], "qio sho": [""], "jun xun": [""], "shng zhng": [""], "p bng b bi": [""], la: [""], "xi di": [""], ng: [""], "mu m": [""], "b bng": [""], "mi w": [""], ru: [""], "sh xi": [""], "yn wn": [""], "dn d": ["", ""], du: [""], lu: [""], "bn pn": [""], yng: ["", "", ""], mn: ["", ""], "jng gng": [""], "ji xi ji": [""], "k k": [""], "pn bn": [""], "chn zhn": [""], "fng fng": ["", ""], "bio di": [""], "b f": [""], "so su": [""], "li lio": [""], "sh s y": [""], "yng jun": [""], "zh tu": [""], "y s": [""], "zu z zh": [""], ti: ["", ""], "xing nng": [""], "tng xng": [""], "g le": [""], "ch zha": [""], "nng nng": [""], "yn w": [""], "zh sh": [""], "xn jn": [""], "kui ju": [""], zng: ["", ""], "ti di": [""], "xn xun": [""], "ling lng": [""], pin: ["", "", "", ""], "di ti": [""], "so so": [""], "g g": [""], "bi m": [""], "xio qio": [""], "bng png": [""], "b ju": [""], "b p": [""], "mo mng": [""], "ku yu": [""], "b b": ["", ""], "j c": [""], "b b": [""], "zh zh": ["", ""], "chu di": [""], "lu g": [""], "gu xi w ku": [""], "xin xin": ["", ""], "p b": [""], "y s": [""], "b b": [""], "gu xi": [""], "si x": [""], "nio dio": [""], "dio zho": [""], "gn hn yn": [""], "f gu": [""], "jin qin zhn": [""], "h ji": [""], "pin bin": [""], "chun zh": [""], "cng qing": [""], "sn xn": [""], "bio po": [""], "zh c": [""], "jn qn": ["", ""], chi: [""], "m me": [""], "m me ma": [""], "m m": [""], "dn shn": [""], "zhn yn": [""], "dn zhn": [""], "min mn mng": [""], hu: [""], nng: [""], "q j z zhi": [""], "yn kn yn": [""], "yn kn": [""], "gng w": [""], "gu jn qi": ["", ""], "ku w": [""], lu: [""], "u q": [""], "lu l": [""], "g g g": [""], "w gu": [""], "zh d": [""], "gng hng": [""], "yo xio": [""] }, bl = new Xk();
      Object.keys(Zk).forEach((n) => {
        const t = Zk[n];
        for (let e of t) bl.set(e, n);
      });
      const Krt = ["zh", "ch", "sh", "z", "c", "s", "b", "p", "m", "f", "d", "t", "n", "l", "g", "k", "h", "j", "q", "x", "r", "y", "w", ""], $rt = ["j", "q", "x"], Jrt = ["un", "un", "un", "un", "uan", "u", "u", "u", "u", "ue", "n", "n", "n", "n", "un", "", "", "", "", "u"], tat = { un: "n", un: "n", un: "n", un: "n", uan: "an", u: "", u: "", u: "", u: "", ue: "e", n: "n", n: "n", n: "n", n: "n", un: "n", : "", : "", : "", : "", u: "" }, eat = ["ia", "ian", "iang", "iao", "ie", "iu", "iong", "ua", "uai", "uan", "uang", "ue", "ui", "uo", "an", "e", "van", "ve"], Kk = { : "y", : "r", : "sn", : "s", : "w", : "li", : "q", : "b", : "ji", : "sh", : "bi", : "qin", : "wn", : "y", : "dn", : "ling", : "shung", : "du", : "j", : "sh y", : "lng y", : "d y", : "y sh", : "y sh y" }, $k = { : "chng", : "hng", : "du", : "gng" };
      function nat() {
        const n = { : "lng y", "": "lng y", : "sh y", : "y sh", : "d y", : "y sh y" };
        for (let t in Kk) for (let e in $k) {
          const i = `${t}${e}`, r = `${Kk[t]} ${$k[e]}`;
          n[i] = r;
        }
        return n;
      }
      const Jk = nat(), iat = Object.keys(Jk).map((n) => ({ zh: n, pinyin: Jk[n], probability: 1e-12, length: ka(n), priority: Nr.Normal, dict: Symbol("rule") })), tF = { : { b: [4] }, : { y: [4], y: [1, 2, 3] } }, rat = { : ["", "", "", "", "", "", ""], : ["", "", "", "", "", "", ""] }, aat = Object.keys(tF);
      function oat(n, t, e) {
        if (aat.indexOf(n) === -1) return FA(n);
        if (t === e && t && FA(t) !== t) return Z0(FA(n));
        if (e && !rat[n].includes(e)) {
          const i = FA(e);
          if (i !== e) {
            const r = J0(i), a = tF[n];
            for (let o in a) if (a[o].indexOf(Number(r)) !== -1) return o;
          }
        }
      }
      function sat(n, t) {
        if (n === "" && (!t || !bl.get(t))) return "lio";
      }
      function lat(n, t) {
        if (n === "") return !t || !bl.get(t) ? "tng" : bl.get(t).split(" ")[0];
      }
      function eF(n, t, e) {
        return lat(n, t) || sat(n, t) || oat(n, t, e) || FA(n);
      }
      const Mw = { : "nn gng", : "d w", : "m q", : "s m", : "shng gun", : "u yng", : "xi hu", : "zh g", : "wn rn", : "dng fng", : "h lin", : "hung f", : "y ch", : "gng yng", : "tn ti", : "gng y", : "zng zhng", : "p yng", : "chn y", : "ti sh", : "shn t", : "gng sn", : "zhng sn", : "xun yun", : "lng h", : "zhng l", : "y wn", : "zhng sn", : "m rng", : "xin y", : "l qi", : "s t", : "s kng", : "q gun", : "s ku", : "zhng d", : "z j", : "zhun sn", : "dun m", : "w m", : "gng x", : "q dio", : "yu zhng", : "rng s", : "gng ling", : "tu b", : "ji g", : "zi f", : "g ling", : "dun gn", : "bi l", : "dng gu", : "nn mn", : "h yn", : "yng sh", : "ling qi", : "zu qi", : "dng mn", : "x mn", : "gu lng", : "gun qi", : "zho", : "qin", : "sn", : "l", : "zhu", : "w", : "zhng", : "wng", : "fng", : "chn", : "ch", : "wi", : "jing", : "shn", : "hn", : "yng", : "zh", : "qn", : "yu", : "x", : "h", : "l", : "sh", : "zhng", : "kng", : "co", : "yn", : "hu", : "jn", : "wi", : "to", : "jing", : "q", : "xi", : "zu", : "y", : "bi", : "shu", : "du", : "zhng", : "yn", : "s", : "pn", : "g", : "x", : "fn", : "png", : "lng", : "l", : "wi", : "chng", : "m", : "mio", : "fng", : "hu", : "fng", : "y", : "rn", : "yun", : "li", : "fng", : "bo", : "sh", : "tng", : "fi", : "lin", : "cn", : "xu", : "li", : "h", : "n", : "tng", : "tng", : "yn", : "lu", : "b", : "ho", : "w", : "n", : "chng", : "yu", : "y", : "sh", : "f", : "p", : "bin", : "q", : "kng", : "w", : "y", : "yun", : "b", : "g", : "mng", : "png", : "hung", : "h", : "m", : "xio", : "yn", : "yo", : "sho", : "zhn", : "wng", : "q", : "mo", : "y", : "d", : "m", : "bi", : "mng", : "zng", : "j", : "f", : "chng", : "di", : "tn", : "sng", : "mo", : "png", : "xing", : "j", : "sh", : "q", : "xing", : "zh", : "dng", : "ling", : "d", : "run", : "ln", : "mn", : "x", : "j", : "m", : "qing", : "ji", : "l", : "lu", : "wi", : "jing", : "tng", : "yn", : "gu", : "mi", : "shng", : "ln", : "dio", : "zhng", : "x", : "qi", : "lu", : "go", : "xi", : "ci", : "tin", : "fn", : "h", : "lng", : "hu", : "y", : "wn", : "zh", : "k", : "zn", : "gun", : "l", : "m", : "jng", : "fng", : "qi", : "mio", : "gn", : "xi", : "yng", : "zng", : "dng", : "xun", : "bn", : "dng", : "y", : "shn", : "hng", : "hng", : "bo", : "zh", : "zu", : "sh", : "cu", : "j", : "ni", : "gng", : "chng", : "j", : "xng", : "hu", : "pi", : "l", : "rng", : "wng", : "xn", : "yng", : "y", : "hu", : "zhn", : "q", : "ji", : "fng", : "ru", : "y", : "ch", : "jn", : "j", : "bng", : "m", : "sng", : "jng", : "dun", : "f", : "w", : "w", : "jio", : "b", : "gng", : "m", : "wi", : "shn", : "g", : "ch", : "hu", : "m", : "png", : "qun", : "x", : "bn", : "yng", : "qi", : "zhng", : "y", : "gng", : "nng", : "qi", : "lun", : "bo", : "gn", : "tu", : "l", : "rng", : "z", : "w", : "f", : "li", : "jng", : "zhn", : "sh", : "lng", : "y", : "xng", : "s", : "sho", : "go", : "l", : "j", : "b", : "yn", : "s", : "bi", : "hui", : "p", : "ti", : "cng", : "", : "su", : "xin", : "j", : "li", : "zhu", : "ln", : "t", : "mng", : "ch", : "qio", : "yn", : "y", : "x", : "ni", : "cng", : "shung", : "wn", : "shn", : "dng", : "zhi", : "tn", : "gng", : "lo", : "png", : "j", : "shn", : "f", : "d", : "rn", : "zi", : "l", : "yng", : "x", : "q", : "sng", : "gu", : "p", : "ni", : "shu", : "tng", : "bin", : "h", : "yn", : "j", : "ji", : "p", : "shng", : "nng", : "wn", : "bi", : "zhung", : "yn", : "chi", : "q", : "yn", : "chng", : "m", : "lin", : "r", : "x", : "hun", : "i", : "y", : "rng", : "xing", : "g", : "y", : "shn", : "g", : "lio", : "y", : "zhng", : "j", : "j", : "hng", : "b", : "d", : "gng", : "mn", : "hng", : "kung", : "gu", : "wn", : "ku", : "gung", : "l", : "qu", : "dng", : "u", : "sh", : "w", : "l", : "wi", : "yu", : "ku", : "lng", : "sh", : "gng", : "sh", : "ni", : "cho", : "gu", : "o", : "rng", : "lng", : "z", : "xn", : "kn", : "n", : "jin", : "ro", : "kng", : "zng", : "m", : "sh", : "ni", : "yng", : "j", : "x", : "fng", : "cho", : "gun", : "kui", : "xing", : "zh", : "hu", : "jng", : "hng", : "yu", : "zh", : "qun", : "l", : "g", : "y", : "hun", : "gng", : "mu", : "h", : "yn", : "f", : "xio", : "u", : "qn", : "pio", : "p", : "yn", : "gu", : "yo", : "gu", : "zun", : "chn", : "sh", : "sho", : "qi", : "s", : "nng", : "l", : "chui", : "xng" }, uat = Object.keys(Mw).map((n) => ({ zh: n, pinyin: Mw[n], probability: 1 + ka(n), length: ka(n), priority: Nr.Surname, dict: Symbol("surname") })), nF = { : "zh ge", : "chng wi", : "rn wi", : "zu wi", : "b fen", : "yo qi", : "yng gi", : "zng zhng", : "t gng", : "ju de", : "rn wu", : "n ge", : "chng wi", : "wi zh", : "lio ji", : "ch l", : "hung shang", : "zh yo", : "d ling", : "l ling", : "j h", : "gn b", : "m d", : "xng wi", : "zh jin", : "rn shi", : "sh zhng", : "sh fu", : "dio ch", : "chng xn", : "fn wi", : "zh shi", : "do dn", : "zh ling", : "hng kun", : "hng li", : "hng hu", : "hng y", : "g hng", : "zi hng", : "hng jia", : "ni hng", : "wi hng", : "tng hng", : "bn hng", : "hng w", : "yng hng", : "yn hng", : "shng hng", : "zh hng", : "zng hng", : "hng qng", : "dng hng", : "hng gu", : "hng dang", : "hng hu", : "ti hng", : "r hng", : "zhng hng", : "nng hng", : "gng hng", : "jin hng", : "g hng", : "hng ho", : "hng go", : "hng shu", : "hng wi", : "hng m", : "hng chng", : "hng j", : "hun hng", : "hng hu", : "hng bi", : "hng do", : "do heng", : "cn y", : "chng fn", : "jn gun", : "shng zhng", : "sh ling", : "yng dng", : "yun zhng", : "qing dio", : "zh nng", : "yn yu", : "y wi", : "ch y", : "b zhng", : "mng g", : "zh yu", : "sh dng", : "zh ho", : "chng zhng", : "go xng", : "b lio", : "chn ling", : "png zi", : "xin de", : "zh sh", : "sh de", : "shui lng", : "gi wi", : "b jn", : "chng fn", : "d ying", : "sho nin", : "xng q", : "ti jian", : "xi xi", : "xio zhng", : "gng xn", : "h tong", : "h do", : "chng qng", : "chng jin", : "sh de", : "shn ch", : "li j", : "j y", : "j wi", : "gun jn", : "fng f", : "tu fa", : "tu xing", : "ji zhng", : "z x", : "yo shi", : "jing lng", : "hn ling", : "gng wi", : "j li", : "d ch", : "xin zhng", : "sho n", : "l shang", : "zh p", : "nng ling", : "ch ling", : "gng yng", : "tio zhn", : "x zng", : "j de", : "zng ling", : "dng zhn", : "jing sh", : "ch bi", : "jio wi", : "zhng lo", : "di fu", : "ch y", : "dng de", : "jn ling", : "m yng", : "d qu", : "wi shu", : "pin yi", : "gng mng", : "sh tou", : "zhu zhng", : "wi zh", : "pio liang", : "po dn", : "zng z", : "ju s", : "dng zu", : "jn kui", : "rn wi", : "chng f", : "h tng", : "ch j", : "d xiong", : "d jing", : "shu jio", : "y jio", : "tun zhng", : "du zhng", : "q zhng", : "nn d", : "y tou", : "hu zhng", : "d di", : "wng ye", : "zhng ling", : "y wi", : "ji huo", : "hu shn", : "y zi", : "li ling", : "zhng d", : "min qing", : "kui j", : "gu fn", : "j nn", : "dio dng", : "yn jng", : "sho jing", : "zhng d", : "xio de", : "bin gng", : "d gng", : "rn de", : "png gu", : "nin tou", : "zhng zh", : "sn zng", : "b xu", : "chng xing", : "sho ling", : "xn si", : "du d", : "gn xin", : "h y", : "ch f", : "zhng gun", : "b ln", : "qn qi", : "shn fn", : "g bo", : "zhu shu", : "zh dn", : "k sou", : "y zi", : "wi zhng", : "gng j", : "sh zhng", : "bin ling", : "yng yu", : "xi zi", : "yu q", : "jin ji", : "d xi", : "d bn", : "z dn", : "dn yo", : "r ling", : "xu ru", : "g gn", : "rng ling", : "m hu", : "zhun dng", : "chng hu", : "k zhng", : "ch zh", : "zhu zhng", : "zho j", : "qing p", : "tng zhng", : "shu xing", : "l ma", : "zhn zhng", : "zh gun", : "chng chng", : "min de", : "zhu sh", : "d ji", : "zhn xing", : "xing mo", : "ch fn", : "wi qu", : "wi q", : "b bo", : "bi zi", : "qun zi", : "jin shi", : "lng zho", : "y hu", : "d du", : "d sh", : "chng d", : "shu d", : "d d", : "wng d", : "dng d", : "d h", : "d chng", : "jin d", : "qin d", : "g d", : "dng d", : "zhng d", : "l n", : "zi xing", : "jio ling", : "du chn", : "zng zhng", : "xing gong", : "kng bi", : "d liang", : "shu fn", : "sh tou", : "m shu", : "xng li", : "pn ch", : "sn wn", : "ch jng", : "sn zi", : "qun tou", : "d f", : "z zhng", : "g tou", : "nng k", : "gng hun", : "b ru", : "hun yun", : "chng xi", : "chng li", : "zh g", : "i ho", : "mn tou", : "jn zhng", : "shu zhng", : "chng zhng", : "s zhng", : "zhng z", : "qing jng", : "qi dng", : "tu er", : "zhn zhng", : "zh teng", : "xing ch", : "tng shui", : "zhng jing", : "mng zhng", : "mng jing", : "m tou", : "dng tan", : "d qio", : "gn hu", : "sho ye", : "shu ling", : "b j", : "wi ba", : "li de", : "ho q", : "yo shi", : "dng zu", : "chn zhu", : "y ba", : "ch zi", : "shng jing", : " xn", : "dn zi", : "yng ji", : "zh ju", : "yn zhun", : "xing zhng", : "g sh", : "zhng yu", : "yng zhng", : "dng chng", : "n xu", : "yn hu", : "chng yng", : "hu wi", : "t b", : "zun jn", : "yu du", : "ling xing", : "bi zi", : "sh de", : "sh m", : "j zhng", : "pi zhng", : "ji q", : "fn ling", : "sh c", : "d fng", : "yo he", : "ch ch", : "ling z", : "l tou", : "dio yn", : "c hou", : "chng shn", : "zhn tou", : "pn mng", : "sh zhng", : "gu hun", : "p ling", : "x m", : "din zho", : "shn wi", : "xio jing", : "zhu yn", : "ch s", : "yn w", : "g yu", : "sh gn", : "b l", : "d fng", : "wi tou", : "bn zhng", : "xng xi", : "nng yun", : "qn chi", : "wi sh", : "gu dng", : "xu jin", : "jin di", : "mn yun", : "ji shi", : "j ling", : "yn m", : "cn zhng", : "lin zhng", : "z j", : "w jing", : "wn ch", : "zh bn", : "gng qi", : "j ling", : "do zhng", : "xi lu", : "wng ba", : "qi g", : "jin g", : "y hung", : "chng ji", : "lng h", : "wi hi", : "j zi", : "chng hun", : "g da", : "yn shn", : "d s", : "du gun", : "zh shi", : "din h", : "kn shu", : "f b", : "y mn", : "jn zo", : "qi dun", : "zh tou", : "wi shng", : "ch sheng", : "qi ch", : "zhu l", : "zhu xing", : "j ch", : "tu bn", : "gn zi", : "hn hu", : "sho f", : "xng zh", : "n mn", : "gn li", : "jun q", : "shn zi", : "gng gi", : "lng lu", : "l ba", : "zi h", : "tu dng", : "wi nn", : "zhu l", : "yn zi", : "gn m", : "bi f", : "zng di", : "ji j", : "bo gung", : "q dio", : "xing j", : "jio hu", : "ju zh", : " y", : "zi zhng", : "zhng bi", : "ch chi", : "du ku", : "pi ki", : "tng zhng", : "z fn", : "w ch", : "ji dng", : "zhun j", : "g zi", : "p sh", : "gn sh", : "gn jn", : "dng ling", : "yn zi", : "hu er", : "qi zhng", : "chng fn", : "ch ", : "lu min", : "zun yn", : "di chng", : "shng dng", : "xio ling", : "zu fang", : "zho xing", : "i y", : "dio j", : "kn zhng", : "y zhng", : "fng zheng", : "b xi", : "kng x", : "gng di", : "pin ch", : "shng dio", : "sh ling", : "tn zi", : "w ling", : "kng d", : "dio d", : "sn sh", : "chung shng", : "hi shn", : "mn zi", : "chng di", : "lu ch", : "dn dio", : "lo jing", : "rn shn", : "jin dun", : "chng xin", : "ji z", : "dio yng", : "lu bo", : "f zhu", : "yng shng", : "zh jing", : "zu guo", : "j ju", : "wi zhng", : "gu ling", : "yu q", : "f h", : "qing dn", : "qio rn", : "ch fng", : "qio shng", : "q zi", : "qng dio", : "tio xn", : "di wi", : "lio ji", : "d zhng", : "ji b", : "ln de", : "zng ling", : "y zhu", : "b jing", : "yo si", : "ch j", : "gng gn", : "ch m", : "xin yu", : "jin x", : "zhng dn", : "chng yn", : "chng sh", : "yng chou", : "zh dng", : "w nng", : "bo z", : "qin tou", : "jun yn", : "fi di", : "dn do", : "gn zi", : "mn jing", : "hu tou", : "h ci", : "nun huo", : "li j", : "dio qin", : "ju jing", : "bo zng", : "sng sh", : "yu mo", : "qin f", : "gng t", : "zhung zi", : "bi bo", : "ti zi", : "sng sn", : "h h", : "k w", : "z zhun", : "gng din", : "fn xng", : "tn shui", : "s d", : "bn fn", : "lu de", : "b b", : "xing jin", : "dn b", : "hn dn", : "zhn gun", : "f h", : "nng ni", : "xi hu", : "wi lio", : "yn zho", : "chu dio", : "sh zi", : "x jun", : "bio d", : "bi niu", : "s liang", : "h ci", : "ln y", : "gi zi", : "fn wi", : "lng tng", : "yu w", : "y ling", : "mo f", : "chi qin", : "bi f", : "zhun s", : "shng yu", : "ji gng", : "gng shu", : "zh gn", : "chng ch", : "zhng xing", : "gng chi", : "li dn", : "shng de", : "tio zi", : "chng wi", : "z s", : "jng fng", : "ji g", : "din b", : "din zhng", : "zhng chung", : "lo lao", : "m hu", : "gng jia", : "j l", : "k mn", : "d ling", : "ch cu", : "sh ji", : "cn c", : "d zi", : "zh zhng", : "xing chn", : "hng yn", : "sh mng", : "x ho", : "li zhun", : "jng d", : "h ma", : "qng ji", : "dng zi", : "chn m", : "go l", : "xi ji", : "w wi", : "b jie", : "lio d", : "bin xing", : "h dn", : "qng jia", : "chng zi", : "h wn", : "hun j", : "jio hun", : "jing lng", : "chn y", : "kng qu", : "l ln", : "dn ling", : "zh zhu", : "d dio", : "b s", : "qng b", : "d dng", : "zhn b", : "so zhou", : "qi c", : "nin zhng", : "wi zhun", : "tu zi", : "ci feng", : "l yu", : "xu p", : "sn lun", : "dng ling", : "do teng", : "q sh", : "zn ji", : "chng f", : "zho w", : "dn k", : "xng w", : "rng rang", : "lin li", : "yng d", : "z zhng", : "gu zi", : "li g", : "xun yn", : "tio pi", : "q gn", : "chi y", : "kn k", : "sho r", : "yu tun", : "yng fn", : "tu hun", : "g dio", : "y dio", : "yn dio", : "yu f", : "g p", : "d din", : "chi sh", : "yn chn", : "shu xu", : "go yao", : "tn m", : "dio rn", : "sn j", : "shng tu", : "fng m", : "fng ji", : "g liang", : "sh dng", : "zhng dn", : "wng wi", : "zhng zh", : "q hng", : "m lio", : "xing sheng", : "jio zhng", : "qun xing", : "sh ling", : "chn mn", : "j y", : "ji f", : "si wi", : "jing xio", : "sh ho", : "m lu", : "p do", : "pin zi", : "qi xio", : "dn wn", : "x b", : "ku d", : "jin xi", : "qio shu", : "s dio", : "ch ju", : "bio shui", : "ch zi", : "zho xing", : "chn zh", : "du peng", : "p zi", : "d zi", : "f zi", : "gn jng", : "do sh", : "jing gun", : "ch tou", : "gu xing", : "n ji", : "lo dao", : "xin ling", : "bng x", : "chng fng", : "q yu", : "qng dn", : "b gng", : "fi zi", : "ch sh", : "cn ling", : "qng shui", : "pio mio", : "zhng jing", : "ci gn", : "sh sh", : "jun zi", : "yu shu", : "xing zi", : "png gung", : "qi w", : "kn gun", : "fng tou", : "jng gn", : "go ch", : "kng h", : "bin dn", : "j yng", : "g zi", : "gng x", : "fn ch", : "fi dn", : "wi b", : "f xng", : "j xng", : "cun dng", : "jin hu", : "qin b", : "yu zhng", : "shn ch", : "dio zi", : "xing wi", : "zhun z", : "jng l", : "k ch", : "lio sh", : "zhun you", : "dng p", : "zhu zi", : "dn zi", : "ho zhn", : "yn mi", : "zh x", : "gn lin", : "n jing", : "ji ling", : "hu chun", : "j ling", : "tio b", : "sho xio", : "zhu lu", : "zng w", : "k b", : "yo xi", : "yng chu", : "hun shu", : "m j", : "zh zhu", : "h lng", : "bo zhng", : "x zhe", : "zhng ji", : "gng zhun", : "jio kn", : "chng t", : "so xng", : "p gi", : "zhng sh", : "ch ji", : "y gn", : "zhng zh", : "yng yn", : "qi r", : "zhn jing", : "nin sho", : "sh shn", : "zh ni", : "ch sh", : "zhng fng", : "dng ling", : "fng ling", : "qing dio", : "lo sho", : "m r", : "gu g", : "jing shui", : "ch zi", : "w nang", : "zhng jn", : "k hn", : "bng zhu", : "gng xio", : "qi pin", : "chi sh", : "zh hui", : "yng zho", : "ch n", : "qi cu", : "r tou", : "y ji", : "z zhng", : "do gun", : "ju s", : "dng ling", : "p jia", : "yun fn", : "kng xin", : "ho s", : "n h", : "lng tng", : "bin si", : "h cng", : "chng h", : "lng sn", : "hng lng", : "hu zi", : "ni mng", : "sh lu", : "n ch", : "mu l", : "zh lan", : "zhng bio", : "dio dng", : "gu lu", : "chng zi", : "ji qio", : "chng wn", : "po zh", : "fn hun", : "z zhun", : "go dio", : "yn hng", : "g zhu", : "qing qi", : "bn xing", : "jio hng", : "co shui", : "q mn", : "zhu s", : "nng kn", : "xng tou", : "j n", : "ji jio", : "f j", : "mng jing", : "yu mo", : "tu li", : "n rng", : "zun tn", : "ji cng", : "lu p", : "hng do", : "yn ling", : "ji mn", : "kng er", : "g mo", : "ho k", : "zun kng", : "h nng", : "xng yng", : "fn mn", : "cng c", : "fn ch", : "chng zi", : "xio dio", : "sho yng", : "shu xing", : "rn fng", : "g bei", : "jing mn", : "m bn", : "pi j", : "wi w", : "gn tou", : "hu sun", : "li zhui", : "hng xio", : "yn xun", : "gn dio", : "fng zh", : "nn ch", : "zhu y", : "mn hng", : "j sh", : "dun f", : "shng hun", : "hun qng", : "kn h", : "zh shui", : "zu yu", : "zi k", : "zhun hng", : "yn m", : "kng g", : "p din", : "ling jing", : "hu l", : "sn mn", : "tu f", : "sng hun", : "mi m", : "li j", : "b w", : "dio l", : "sh ti", : "j zhng", : "shun s", : "pi ju", : "qi ku", : "chung ku", : "h qian", : "sh dn", : "p png", : "h d", : "ln sn", : "sh gn", : "tin kng", : "dio zun", : "yu sh", : "ling bin", : "yu xing", : "tng s", : "zhng dio", : "ji do", : "gn k", : "zh k", : "yu gng", : "hu gu", : "zho hu", : "gng zhng", : "j f", : "kng zi", : "n zh", : "zhng zho", : "shu zi", : "sng zng", : "ji di", : "n fn", : "zhng y", : "zhng sn", : "jio dng", : "jun q", : "zi yn", : "tu dn", : "zu cn", : "fn ling", : "dio hun", : "lio rn", : "li zu", : "din dng", : "hn ji", : "zhng xing", : "j shu", : "x f", : "zh gn", : "sh xing", : "hng qing", : "k hu", : "si zi", : "dn gn", : "hun xing", : "zho tou", : "s gun", : "d shui", : " ha", : "g sh", : "m b", : "ho w", : "xi ch", : "xio zhng", : "l jin", : "zhn tou", : "jio du", : "sh w", : "pn y", : "f ye", : "m fi", : "yn fn", : "h jing", : "b he", : "d ch", : "kng wi", : "p l", : "w l", : "dio hu", : "li tou", : "xin sn", : "jio jun", : "mo shi", : "gn jn", : "xin yu", : "xing gu", : "dn shn", : "zh xng", : "p ki", : "c zhng", : "f qi", : "ji j", : "sh ch", : "shng f", : "chng b", : "fng h", : "yn ling", : "sho wi", : "chng y", : "cng jng", : "hu bo", : "wi h", : "wi xing", : "h ho", : "zho m", : "tio dn", : "wn l", : "hun s", : "qing hng", : "zho sh", : "xing shn", : "tio mng", : "m feng", : "fn ni", : "gng y", : "run huo", : "jn xng", : "ho zi", : "zho y", : "bi jing", : "ci zhng", : "ji z", : "mi kng", : "ji fng", : "sh duo", : "chn huo", : "b ji", : "din ling", : "h zi", : "dio sh", : "ch shn", : "d shu", : "dn gng", : "hng mn", : "nng gn", : "jio din", : "ji zi", : "gn xio", : "hng chun", : "jio zh", : "y s", : "m zh", : "yu zh", : "go gn", : "jng zhun", : "zng sn", : "ho du", : "gun qi", : "to bn", : "m ceng", : "mu q", : "zhn l", : "m zha", : "cu he", : "li qie", : "shui d", : "ti zi", : "fn de", : "nin zhu", : "ci y", : "sn zhung", : " nu", : "xng wi", : "xng tou", : "q ling", : "dio yn", : "ch zh", : "yu yn", : "chng s", : "dng h", : "ln dio", : "xing zhng", : "mn yu", : "po zhang", : "sng f", : "xio jing", : "ling xng", : "fng b", : "ci kui", : "d gn", : "l sh", : "jio chng", : "si bi", : "sh xing", : "r m", : "xin ling", : "y s", : "lu lin", : "ling kuai", : "yo gn", : "li da", : "g g", : "gng gn", : "ji gng", : "tio du", : "kn mn", : "yu g", : "t pin", : "tio dng", : "zhn jing", : "qi jng", : "m fng", : "wi y", : "jio huo", : "m su", : "zu nng", : "mio tou", : "d zhn", : "d zng", : "ch shng", : "gu da", : "sh yn", : "sh ch", : "ti gn", : "jing xing", : "fn zi", : "sh ch", : "l yn", : "qing gn", : "fng rn", : "chu mn", : "din jing", : "hu tu", : "jng sh", : "xing lng", : "zhng lio", : "bn f", : "ji ba", : "k gn", : "kn ji", : "zhng dn", : "zhng kn", : "xi mn", : "dng gun", : "sh ling", : "gng dio", : "jin zu", : "dn pin", : "ch ch", : "pio bi", : "gng zi", : "tio ch", : "ho dng", : "zhun l", : "bng q", : "ji bn", : "i yu", : "gn do", : "k ch", : "p chi", : "zhng sh", : "tin hu", : "gng ch", : "jio yn", : "ch si", : "m pn", : "wi m", : "bn sng", : "chng h", : "d dio", : "fi fn", : "zun yng", : "ji zi", : "cho zi", : "gng sh", : "lng dang", : "p sn", : "f hun", : "zhun ln", : "hng ci", : "po tng", : "po s", : "tin y", : "h hu", : "q qio", : "tng ling", : "fng hun", : "w jio", : "mn gn", : "lng tou", : "yn ti", : "yu fng", : "xu zhng", : "gu zi", : "b dio", : "y bi", : "x chn", : "dio yu", : "mn gn", : "zng z", : "t gn", : "bin dio", : "f m", : "m zi", : "yu l", : "chn xn", : "m gn", : "chng yn", : "z xng", : "t dio", : "kn xing", : "y tou", : "xi qi", : "si shng", : "p zhng", : "tng wn", : "b xng", : "xi sh", : "tu q", : "xin dn", : "yu m", : "hn ling", : "y yu", : "ho k", : "zh xing", : "zh jun", : "z sh", : "x chung", : "fng dn", : "jin jing", : "l shu", : "xu f", : "kng dng", : "du xing", : "xin jin", : "hu jing", : "zi b", : "tio zao", : "qio p", : "b d", : "ji f", : "lio dun", : "tng dio", : "sh m", : "sh ch", : "b s", : "tio zi", : "tu m", : "w hu", : "m sh", : "dio zhun", : "j m", : "hun zhi", : "dio yn", : "fn hu", : "j u", : "dun h", : "mn li", : "lng j", : "fn ling", : "hun l", : "zhun dio", : "xng xing", : "shu xing", : "pi yu", : "gi tou", : "lin gn", : "b j", : "do b", : "ling c", : "mng ju", : "b dio", : "jio bn", : "zhng b", : "jun yng", : "sho wi", : "y zhun", : "yu p", : "qin li", : "d li", : "h ch", : "yn ", : "gn q", : "hi ling", : "jng dng", : "zhu chung", : "yu xing", : "sh j", : "gng gun", : "ln ch", : "zhng b", : "hu p", : "ji qio", : "kng ch", : "k xi", : "p chn", : "chng shng", : "yu l", : "i ho", : "zng l", : "gng jng", : "xu png", : "nng yn", : "chng du", : "dng chi", : "zhng zhun", : "bng ch", : "chung min", : "dn ju", : "b l", : "hung dang", : "so zi", : "ji sh", : "mn tu", : "mi f", : "d shu", : "zho ling", : "chung jing", : "j n", : "pn tou", : "ch sh", : "sn su", : "yng s", : "hn zhn", : "qin qing", : "w jin", : "ln zhun", : "ho jio", : "p pi", : "xing f", : "zh gng", : "dng ", : "bng ji", : "li ji", : "gng s", : "dn ji", : "zun xn", : "hung yn", : "m zho", : "bio ling", : "bi mn", : "ci du", : "ch sh", : "gun chi", : "to hun", : "chng mn", : "li fn", : "l lng", : "s xing", : "y xng", : "ju l", : "dn kng", : "zh ch", : "ji j", : "ch xng", : "hn jing", : "ho xu", : "ho ho", : "yn f", : "so b", : "f xing", : "gu gn", : "gng q", : "kng y", : "kn z", : "j b", : "jing hu", : "g zh", : "dio lng", : "f ti", : "ln bng", : "dio pi", : "zhun pn", : "gng go", : "chi gun", : "yu mn", : "jio zhng", : "chng chng", : "ji xng", : "yu tn", : "hu n", : "ch h", : "bng b", : "d kng", : "zhun qun", : "hng bo", : "hng ti", : "yn hng", : "zi hu", : "zhng j", : "gun zhng", : "xing min", : "kn tou", : "pn tou", : "y xng", : "jn yu", : "li c", : "g d", : "yn zho", : "bo sng", : "m sa", : "i du", : "pin zhu", : "chu ju", : "dio sng", : "qing jing", : "chng zu", : "f bin", : "zho m", : "zho f", : "shng fng", : "tin s", : "xing hng", : "q shu", : "bi ti", : "chng ling", : "f ci", : "ji f", : "fn jun", : "xio ling", : "jio zhu", : "l zi", : "dio diao", : "sn bng", : "go tio", : "b s", : "ji xn", : "shn dng", : "to ro", : "n chng", : "nin zi", : "m fng", : "s b", : "chng yun", : "xng qn", : "t l", : "gun ling", : "qing b", : "qing zhng", : "yn ch", : "sh do", : "di li", : "t bn", : "xin w", : "s jing", : "jn li", : "chn ji", : "f sh", : "g shn", : "tin fn", : "p ho", : "s tng", : "bi zh", : "hu shng", : "ju du", : "tng chi", : "su ch", : "sng l", : "m m", : "xu shu", : "s b", : "su co", : "qin wi", : "dio tu", : "lng jun", : "wi dio", : "z ti", : "jun f", : "chui du", : "yng xing", : "sn gung", : "g lu", : "b mng", : "lng tu", : "yn yn", : "li zhou", : "pin er", : "qin shu", : "sn t", : "ni xng", : "qing li", : "ji sng", : "fn jin", : "sho zhung", : "li kng", : "go ji", : "k xu", : "b m", : "p gu", : "m xu", : "zh sng", : "ch zi", : "hng dng", : " zi", : "ch lu", : "g zhng", : "gu ch", : "hun hn", : "l ji", : "sh zh", : "shn ling", : "tng ho", : "m ling", : "gng shng", : "f sng", : "shui zh", : "z m", : "sn ji", : "d qing", : "jio w", : "b qng", : "yn po", : "nio nu", : "co du", : "chng jn", : "n nn", : "qi zhng", : "tio dng", : "hun yun", : "j jing", : "gng g", : "m yo", : "bi xng", : "qi min", : "sn h", : "li jn", : "bi di", : "chng gn", : "nin fng", : "b zi", : "bn shu", : "yn shn", : "r jing", : "chng gung", : "jin f", : "zhng shng", : "xio zhun", : "y zhu", : "ru gun", : "hu jun", : "hng hu", : "ji k", : "gung yn", : "p m", : "du dio", : "ji ch", : "kng ", : "png dio", : "p chung", : "sng zhng", : "zu l", : "sho f", : "shu shu", : "bn tou", : "jn j", : "shui xng", : "l zi", : "bng z", : "tio su", : "pio x", : "ji qing", : "k chun", : "mi xie", : "cu ch", : "mn ji", : "sh dio", : "chng sn", : "jng chung", : "x chng", : "dio mn", : "hu tu", : "hu la", : "to shi", : "c shui", : "xing shui", : "kun zh", : "y qng", : "yn b", : "wn g", : "d d", : "dio q", : "jio chi", : "lu z", : "xing c", : "x dao", : "lu f", : "y xing", : "jn m", : "ju d", : "xi zi", : "chn jun", : "zh zheng", : "x yng", : "b lu", : "du zi", : " sho", : "f j", : "hng sho", : "jing hu", : "k sng", : "sho x", : "yn chun", : "jio yng", : "wi ch", : "jio zho", : "p zhn", : "yn sui", : "ji jn", : "su po", : "sng lun", : "xing xing", : "hu f", : "d chng", : "yn ling", : "zhng qi", : "hu qun", : "hu tng", : "png zhun", : "l qin", : "j du", : "sn j", : "g shi", : "s yn", : "p x", : "yn zh", : "lng zhn", : "sh zh", : "sho nn", : "gun yu", : "ho to", : "n xing", : "yng s", : "wn shng", : "gn r", : "g tng", : "b j", : "p ji", : "jio zhn", : "yn dng", : "q ling", : "xun dio", : "bn xing", : "gn ci", : "j gn", : "g qi", : "gu yu", : "qi k", : "b g", : "m fng", : "y y", : "ji mo", : "b j", : "chn ji", : "sh xng", : "chng ch", : "zhun y", : "zhu liang", : "b c", : "zng qng", : "d sh", : "dio rn", : "ji yun", : "jng gn", : "j ling", : "lng tou", : "shui zhn", : "pn xing", : "su yu", : "h m", : "xing t", : "xng hu", : "zo tu", : "chng hn", : "zun dng", : "cn du", : "dng shn", : "dio wn", : "gn t", : "g b", : "gng xun", : "ji shng", : "lu xin", : "qi qi", : "sn jin", : "sho qi", : "tng f", : "t ling", : "tng ku", : "j di", : "xing sh", : "yng jun", : "zhun j", : "b ti", : "cng zh", : "fi b", : "g ji", : "g l", : "gu wn", : "gui xing", : "ln ti", : "n gng", : "bo chung", : "qio ch", : "sh ji", : "tn xng", : "xing jng", : "z rn", : "zh yn", : "zhu zhng", : "zhun tou", : "p shu", : "chn huo", : "chng p", : "d ling", : "gn ji", : "gng ch", : "ji li", : "q shu", : "sh shn", : "tio hu", : " mn", : "bi lu", : "bi sn", : "ci ch", : "chung tng", : "f xing", : "gng dng", : "ho xng", : "hun yng", : "hun zu", : "ji dio", : "jun yn", : "li dn", : "xing tou", : "xu ji", : "jio yu", : "y ling", : "bi zhun", : "b ji", : "chn ji", : "f q", : "hu hu", : "kun chuo", : "lio w", : "qi hu", : "shn du", : "yng x", : "zhun ti", : "z zh", : "ci ling", : "zng x", : "chng xng", : "chu mu", : "cu zh", : "tio jng", : "dio zh", : "fng zhu", : "g du", : "h er", : "hng ling", : "hun ji", : "hn p", : "k chi", : "min h", : "sh ch", : "xng sh", : "sh jn", : "xn chi", : "y qi", : "cun mi", : "zh go", : "zun gn", : "p hu", : "bn hu", : "chng dio", : "d li", : "du lu", : "fi zhun", : "gn zhng", : "ho shng", : "hu pin", : "jio hn", : "lu gn", : "m m", : "n ho", : "pn sh", : "w nng", : "y sho", : "yu chi", : "zhn gu", : "zhn xng", : "chng shn", : "z ling", : "dio fng", : "f lng", : "fn dio", : "fng zi", : "gng f", : "g zi", : "gung gn", : "ji gn", : "j sng", : "j g", : "kn y", : "kng zhun", : "ling l", : "po lu", : "pi hun", : "p shn", : "sn j", : "sn jin", : "shn xu", : "sh gn", : "tio j", : "tu kng", : "xu b", : "jio h", : "yn gn", : "zhi ci", : "chng ji", : "zh dio", : "z jn", : "b j", : "bin nio", : "c dio", : "do gu", : "lo zhn", : "p q", : "shu bi", : "wi m", : "x b", : "xing m", : "y ti", : "zhun jn", : "bng h", : "bn xing", : "go tu", : "jin mio", : "yu ch", : "mi xing", : "bng q", : "qin dn", : "qi bin", : "qng dio", : "qn mng", : "sn bn", : "xng ch", : "sh ji", : "qin shng", : "chng yng", : "gng zhng", : "zhng d", : "zhng ci", : "zi zhng", : "ji zhng", : "kn zhng", : "zhng zh", : "zhng gu", : "zhng du", : "zhng sh", : "shu zho", : "lng zi", : "chng q", : "chng zhng", : "chng tn", : "chng z", : "chng shn", : "chng yu", : "chng lun", : "y ye", : "ni nai", : "lo ye", : "b ba", : "m ma", : "shn shen", : "ji jiu", : "g gu", : "sh shu", : "y fu", : "ji mu", : "g fu", : "ji fu", : "p po", : "gng gong", : "ji zi", : "ji jie", : "g ge", : "mi mei", : "mi fu", : "y zi", : "bo bao", : "w wa", : "hi zi", : "r zi", : "yng zi", : "sh zi", : "shn zi", : "ji zi", : "so zi", : "b zi", : "tng zi", : "zh zi", : "min zi", : "b zi", : "bi zi", : "mo zi", : "pi zi", : "zh zi", : "bin zi", : "g zi", : "fng zi", : "wn zi", : "tn zi", : "pi zi", : "h zi", : "gu zi", : "i zi", : "y zi", : "xio zi", : "yng zi", : "w zi", : "du zi", : "din zi", : "bn zi", : "zhng zi", : "r zi", : "t zi", : "pin zi", : "yun zi", : "hu zi", : "sng zi", : "zh zi", : "sh zi", : "qin zi", : "sh zi", : "png zi", : "bo zi", : "kui zi", : "ln zi", : "shng zi", : "zu ba", : "r duo", : "qi zi", : "bng b", : "kng tng", : "p pa", : "m gu", : "h lu", : "h li", : "j zi", : "h zi", : "zhu zi", : "zh zi", : "sh fu", : "y fu", : "w zi", : "bi zi", : "c wei", : "mi zi", : "du wu", : "zh lio", : "y er", : "hn tun", : "dng long", : "zhung jia", : "cng ming", : "jng zi", : "yn zi", : "pn zi", : "lio qu", : "l qi", : "x zi", : "ln zi", : "zho xi", : "zho x", : "zho q", : "ch bng", : "shng zhng", : "zng p", : "p ti", : "bin de", : "zhng fu", : "du fu", : "b gn", : "zng yng", : "xng rn", : "d zhe", : "d y", : "wn y", : "zh y", : "d zh", : "tng y", : "wi y", : "zhun y", : "dn y", : "r y", : "q y", : "h y", : "zh y", : "zhu y", : "ch y", : "yn y", : "gu y", : "ji y", : "wn y", : "lio lio", : "gng lio", : "s lio", : "y yu", : "y ho", : "y j", : "y dng", : "y g", : "yu y", : "y y", : "r y", : "sn y", : "s y", : "w y", : "li y", : "q y", : "b y", : "ji y", "": "y lng", : "y lng", : "y r", : "y sn", : "y s", : "y w", : "y li", : "y q", : "y b", : "y ji", : "y yu", : "y bng", : "y lu", : "wi l", : "wi zhn", : "cng hi", : "nn wi", : "z nn", : "hun nn", : "m nn", : "d nn", : "dio nn", : "xn nn", : "lu nn", : "l nn", : "zi nn", : "nn mn", : "k nn", : "wi nn", : "f nn", : "to nn", : "b nn", : "y nn", : "z nn", : " nn", : "xn nn", : "kng nn", : "x huan", : "zho zho", : "b xng", : "y y", : "wn q", : "ni q", : "q zh", : "wi q", : "ji q", : "q jng", : "q ji", : "wi q", : "q xin", : "q f", : "ji q", : "q zh", : "q gng", : "q y", : "g lo" }, hat = Object.keys(nF).map((n) => ({ zh: n, pinyin: nF[n], probability: 2e-8, length: 2, priority: Nr.Normal, dict: Symbol("dict2") })), iF = { : "wi shn me", : "sh j shang", : "jin ch zhng", : "gn shn me", : "zh hu er", : "jn k nng", : "dng sh zhng", : "lio b q", : "cn mu zhng", : "cho xin z", : "hi ni wi", : "jn b zh", : "b l t", : "b zi hu", : "lu shn j", : "yu din er", : "pi j po", : "b d lio", : "m wi sng", : "yn sh ling", : "f p qi", : "sh d f", : "y l jing", : "y gn er", : "du de q", : "n hu er", : "z g er", : "w l ling", : "zn me zho", : "mng hung hung", : "ji ji r", : "xn l hu", : "f xng ling", : "xng chng chng", : "fn z ling", : "gu z jin", : "lo d nn", : "dng ni wi", : "zh me zho", : "sho ni nai", : "n d l", : "gng nin q", : "gng zu ling", : "bi d l", : "shn li hng", : "ho ho er", : "jio xing yu", : "ho y si", : "t y hn", : "mi y si", : "l f sh", : "t sh gn", : "chng q ling", : "ko de zh", : "ch xng do", : "rn xng do", : "zhng lng jing", : "zho mng dn", : "yn m dn", : "m ni h", : "lun hng hng", : "hu gng s", : "zi zhng ling", : "qio de q", : "j zhun t", : " png gng", : "jun xn ci", : "x bn zi", : "gu de q", : "hu gng sh", : "wi sheng n", : "tun tun zhun", : "d bo jio", : "rn sho dn", : "lo sh zi", : "yo gn yu", : "ji zh to", : "no hng hng", : "sn lin gun", : "zhng tu x", : "r rn zhun", : "ji g yn", : "zh shi min", : "h shi zhng", : "xn ho dn", : "gn din ch", : "qing gn zi", : "k sng bng", : "b yn i", : "w gng jn", : "mi de q", : "li h ma", : "j liang g", : "z m dn", : "ki xio chi", : "n qing rn", : "yng xing zhun", : "ju sh yu", : "shu xio hua", : "png tu hu", : "b li gng", : "y gung dn", : "sho ln qun", : "yng tn dio", : "sho xin du", : "lng zhng m", : "du zhe gn", : "mng mng ling", : "run g tou", : "p gi jun", : "hu x n", : "bi hi gu", : "hng tng tng", : "w hu c", : "d du suo", : "h ku b", : "m wi zo", : "y mo zi", : "d shu sh", : "lng wng y", : "q tu shang", : "h tu chng", : "b gn zi", : "zhn pin yi", : "d zh y", : "du dn tu", : "lu y shu", : "yn s h", : "bo de zh", : "bo t qun", : "o de h", : "s w zhng", : "jn b q", : "sh ch hi", : "lin hu lo", : "jin sh min", : "hu ch q", : "din wi ch", : "i g er", : "n zhn er", : "fi hu ling", : "d sh fu", : "zh dn tng", : "d h lu", : "n q mn", : "wi jin d", : "d shn er", : "tn de li", : "jio y zi", : "kng bo dn", : "w li du", : "dn zhu din", : "g tu er", : "kn de q", : "h tu zhng", : "d xng xing", : "jn de q", : "f xing zng", : "k lin xing", : "ch de xi", : "hn bo bo", : "no rng rng", : "sh li bo", : "h de li", : "gn xng yu", : "mn h lu", : "gu gu jio", : "x yng shn", : "ln yn do", : "l ji chng", : "jun p gi", : "gu de yng", : "fi jing jn", : "tio d ling", : "h ba gu", : "gu ji ji", : "cu li dn", : "y ji xu", : "qio zh gng", : "li ch zhng", : "hu d n", : "fn de zho", : "t g da", : "sh fng jng", : "qng ling j", : "xi d d", : "sh z er", : "d m dn", : "k jio pin", : "kn d shn", : "dng din er", : "ch de xio", : "lu h x", : "go l shn", : "zhng shng xing", : "yn xi yn", : "jn de zh", : "ch de ki", : "zu s chu", : "yng shng chng", : "sh de zho", : "sh jn er", : "qin b li", : "k d sng", : "hu de li", : "yn h h", : "sh ke lng", : "lio ju zi", : "zng hng hu", : "mn gun ch", : "qi b zi", : "hng deng deng", : "gn de j", : "dng jin er", : "lu m jio", : "j ni jn", : "fn de shng", : "dng ch b", : "bo h din", : "lng zho hui", : "h do ci", : "dng gun c", : "dn dan min", : "ch de zh", : "zhu jin er", : "zh zho er", : "zh gn tou", : "yn zho er", : "yn jun er", : "xun chun dn", : "xn p er", : "xin qi jio", : "s sh m", : "shu de li", : "shu pio er", : "shu b gn", : "sh de shng", : "sh b zho", : "sh b qng", : "sh jin er", : "shng s b", : "shn fng j", : "s y zheng", : "r j b", : "r de kui", : "qng jia gng", : "j hn sh", : "pi zh b", : "n jn er", : "n w wa", : "ni qi yun", : "n hu er", : "mn tu er", : "mi p er", : "mo jn er", : "li jin bng", : "lio wng ti", : "lo li sho", : "kn ju er", : "ko qn b", : "jun b do", : "jn j ling", : "hu b li", : "hn gu er", : "g nng nng", : "gu jn er", : "gng qi xin", : "g de zh", : "gn lng tu", : "gn de shng", : "gn jio m", : "g zh er", : "g bng cu", : "du de zh", : "du mn zi", : "dng gu gu", : "d li er", : "d zhu zi", : "d bn zi", : "cn jn er", : "c jn er", : "chui shu er", : "chng jn er", : "ch de li", : "b gng sh", : "bn tou er", : "bi f zhng", : "w wa qn", : "s jn er", : "g du er", : "gng lo b", : "d jing yn", : "y dn shu", : "p j ti", : "ti li p", : "k t lng", : "ki h hng", : "l y j", : "hu sh lio", : "y gng gng", : "y chng shn", : "fng y gng", : "xu y gng", : "gu y m", : "xng q y", : "l bi y", : "y j d", : "y yu y", : "y z m", : "y sh y", : "y c fng", : "y yng zh", : "y z ju", : "y nin j", : "y b zu", : "q qu r", : "nn wi shu", : "nn wi qng", : "xng y hng", : "bi bi de", : "gn n hng", : "gn y hng", : "q bi zhn" }, cat = Object.keys(iF).map((n) => ({ zh: n, pinyin: iF[n], probability: 2e-8, length: 3, priority: Nr.Normal, dict: Symbol("dict3") })), rF = { : "chng j s hn", : "s tng b d", : "y m y yng", : "qng zng go yun", : " m tu f", : "ji fng s xing", : "su zu su wi", : "m m hu h", : "h qing sh dn", : "xng go ci li", : "w nng wi l", : "b l si r", : "wi su y wi", : "k sh m r", : "mi wn mi lio", : "b wi rn zh", : "ji ji b b", : "qin p hu j", : "p tin gi d", : "zh ji lio dng", : "gng b yng qi", : "y sh d f", : "b wi w qun", : "b k shu shi", : "h zu fi wi", : "fn ho b ch", : "m m hu h", : "b z wi q", : "qio w shng x", : "lio r zh zhng", : "shn w tng ju", : "go go xng xng", : "i shng tn q", : "hn zng y x", : "ch xn j l", : "q b chng shng", : "bn y sn gng", : "sh hn lu p", : "r sh b xi", : "zhun li zhun q", : "sh y wn j", : "xing y wi mng", : "lin lin b sh", : "q zh k sh", : "shn ch gu m", : "ji ji sh sh", : "yu d fng sh", : "j l g l", : "dio bng qin jing", : "zi g zi w", : "zhun wi wi n", : "t t shi sh", : "sng j b r", : "zhung m zu yng", : "jin y yng wi", : "xing ch w j", : "tn wi gun zh", : "mn mn b l", : "x n i l", : "xin wi rn zh", : "zhng y w zho", : "wi fi zu di", : "hn h q c", : "p y bn mng", : "min wi q nn", : "y y b sh", : "dng tu shng si", : "b zhu bin j", : "d m d yng", : "xn hun zu l", : "y zu lio zh", : "z l hng jin", : "hn hn hu h", : "qi r q fn", : "p t wi xio", : "shn gng bn y", : "qin ch wn bi", : "sh b shng sh", : "j wi j yu", : "tin xun d zhun", : "yng zn ch yu", : "b li xin wi", : "cho chao no no", : "yn tu zhun xing", : "t shng t zhng", : "nng s b q", : "b xng rn sh", : "jn l r wi", : "jng mng qing gn", : "lo lao do do", : "j ji zh zh", : "gng b k m", : "qi r b sh", : "pi yu ji nn", : "x li h t", : "g yu su chng", : "d d qu qu", : "hng tng d xio", : "tng r b wn", : "do gng hu zhng", : "ni fn m xin", : "hu xin wi y", : "bi f bi zhng", : "chng jin tin r", : "fn bi wi shng", : "y lio bi lio", : "d da li li", : "xn j hu lio", : "c xn d yi", : "j p g da", : "y wi png d", : "r j yu li", : "sh shn ch d", : "tu q su ho", : "jin b rng f", : "rn mn wi hun", : "qing zhu b sh", : "wi sh y wn", : "r sh ji zhn", : "xn l yu sh", : "y y hun y", : "shn b shu sh", : "mng sh wi k", : "g z wi zhn", : "yun shng zi do", : "ji k ji nn", : "ho ho xin sheng", : "gui m gui yng", : "po tu l min", : "yu shu ho xin", : "w su b wi", : "dio h l shn", : "b b wi yng", : "ho d x gng", : "zhng sh zh d", : "chng shng b s", : "wi wi zhung gun", : "b k shng sh", : "gu sh shn chi", : "ji shn z ho", : "gn zu gn wi", : "mo s dn ki", : "zu m hun jing", : "wi sh gu zo", : "wi rn sh bio", : "yn ch yng cu", : "yu qing hu dio", : "chng do f zh", : "m ma li li", : "x x do do", : "r l b bng", : "sn bng zh jing", : "gui wn m jio", : "xing m xing yng", : "gng gu y qi", : "ki hu ji gu", : "z z x x", : "chun zng gng l", : "h bi bng zi", : "chng nin li yu", : "zhng er b jng", : "b sh ti ju", : "chng zhn q g", : "q x yn yn", : "jn zhu b sh", : "f fu ti ti", : "qing c du l", : "p li p l", : "rn ci j j", : "f rn shn xng", : "b z wi png", : "wi f b rn", : "lin pin li d", : "h tin qing d", : "lu lu d fng", : "z chu z li", : "l shn ho sh", : "y gng wi shu", : "m m cng cng", : "xu ti r n", : "zh zhu wi n", : "y tu wi jn", : "q q ch ch", : "qing ln dn y", : "lng rn f zh", : "zhun bi wi shng", : "zhun wn m jio", : "zi ji nn to", : "zhng dng fng wi", : "b z wi gui", : "nn xing nn d", : "y y y y", : "dn jn ling ju", : " y fng chng", : "x li hu l", : "fn lo hun tng", : "ho go w yun", : "l s shi shu", : "ch qing rn y", : "d chu d li", : "chng ji l y", : "z yun z y", : "f zhi li li", : "g wi jn yng", : "r t wi n", : "xi b wi l", : "y hng r shng", : "mi tu cng ying", : "tin ch d yun", : "fng jun cn yn", : "du zi du nn", : "r xi wi gn", : "hng ji l shu", : "lng bi wi jin", : "ch bin b jng", : "y chng y h", : "y nin zh ch", : "jn chn tu qio", : "d d d d", : "shu gu li li", : "ho zhng y xi", : "hng de f z", : "chun wi mi tn", : "f shng d g", : "s hi wi ji", : "lio ru zh zhng", : "d yu k wi", : "ch tu l min", : "g gu nng nng", : "chung mng j jng", : "ti rn ch zh", : "n f chng gun", : "yu j b li", : "g tou ji zi", : "y b yn tin", : "y dng din er", : "sh li yn zhun", : "chn c ln dio", : "hu zhng wi lng", : "hu sho hu lio", : "gn cu l su", : "dio er lng dng", : "gung zhng b shu", : "zhng gu d gu", : "zhng du d du", : "nn sh nn fn", : "sh xu wi mng", : "fn f yu wi", : "yn cu yng ch", : "dng du x cng", : "yn xn hu lio", : "zun ni jio jin", : "qio zhung d bn", : "gi xin gng zhng", : "h nn bng zi", : "ho ch ln zu", : "h l b wi", : "d ch fng tu", : "gng chng l d", : "pio pio liang liang", : "zh zhng zh y", : "d m h y", : "l sh chng yn", : "shui xin chu fn", : "ji chng l dun", : "kun d wi hui", : "zu bng yu b", : "y xio lio zh", : "tin xi wi gng", : "hun w h shn", : "h z wi q", : "ho z wi zh", : "fng z chu yu", : "d y png tu", : "chun wi ji hu", : "ch l p wi", : "chng co ji y", : "xio ji zi q", : "sho b gng sh", : "nn fn nn sh", : "tin zhun ji w", : "sh fi fn mng", : "sh w q shu", : "pin tng pin xn", : "ling r wi ch", : "xing lng f h", : "gng hu b li", : "zhng zhng xi hui", : "y shn x gu", : "y y zhng d", : "sng hn lu p", : "sn zu d shn", : "j j y tng", : "ho sh zh t", : "gn jng l su", : "ch jing r xing", : "nio nio nu nu", : "h li wi ba", : "ho y w lo", : "d r w dng", : "d m hu yn", : "bn shng dng dng", : "yo w h li", : "xi bng xi jing", : "shu dio g tu", : "sh din wng z", : "rn sh b xng", : "q go h gu", : "l jio b gi", : "h wi yn gu", : "h wi bio l", : "hu c b b", : "gu gun zhn jing", : "g ge d d", : "d f pin pin", : "zu wi shng c", : "yun jia du tu", : "yu x k chng", : "y ln bn zho", : "pin yn zh y", : "ki hu ji sh", : "jng nin li yu", : "hn h q c", : "gu lin xin ch", : "chng nin li yu", : "b xn s qng", : "b dng rn z", : "bng d yo yun", : "zh f wi hn", : "zh me din er", : "y xng su rn", : "xi hu zhn tou", : "w d fng sh", : "wng wn wn qi", : "sh j wi rn", : "qing nin li yu", : "pi nn ji fn", : "ch zh ti rn", : "zh l wi m", : "wi r li lun", : "tin bng tin jing", : "sh jn qi yun", : "nn qing bi dio", : "k zhng zu l", : "hu j b f", : "xi wi xing tu", : "zhng yu yu x", : "b ling wi chng", : "bi bi qi qi", : "bi jn zh jing", : "q hng b sh", : "xu z sh l", : "xin d wi kui", : "t j ho hn", : "sh b jin qn", : "shn chi gu sh", : "qio qio d d", : "png p zh x", : "mi tu m wi", : "lio lio k sh", : "hng h r jing", : "h f tng yn", : "g bn qin chng", : "dn w x f", : "d rn xin sheng", : "y mn gng sh", : "sh bi l zhun", : "sh fi d sh", : "sh b ch c", : "si wng sh m", : "r b x shn", : "qi shn t hu", : "pin yn zh z", : "po m mi xi", : "nng zh b wn", : "lng lng sn sn", : "ling t ci y", : "lin zhng sn yun", : "l bng yu hui", : "b wi y shn", : "zhun bi wi x", : "y yn hun yn", : "wi wi d gun", : "wi wi b k", : "tng yn h f", : "png b wi jin", : "m c wi shn", : "ji qing di bng", : "f shng j ji", : "dn rn ch zh", : "dn sh h jing", : "chung j tng shn", : "co zhng yng fi", : "zu sh b ji", : "y j du rn", : "su hng ji sh", : "wn y zi do", : "wn b du t", : "ti bn dng dng", : "shn t f f", : "qu ch sho chun", : "m w zn zhng", : "j rn tin xing", : "hu ji sh nn", : "gng jn ti g", : "di z bo j", : "di sn l s", : "b m s tng", : "xu jin no di", : "wi fi zu ", : "rn ci nn d", : "qng fi d y", : "qi zhng yo hi", : "hu j hu lio", : "hu d wi lo", : "ho ji tn bi", : "chng g dng k", : "zi chn zi f", : "y nn chng xing", : "y m g da", : "y ln wi h", : "yng wi zhng yng", : "yn wi xn shng", : "yn b yu zhng", : "t qing b xin", : "png tu d y", : "m b xi j", : "ling ci l yng", : "jio xu xing zhng", : "hu b dng ch", : "h yo h li", : "b z wi xn", : "b j xng j", : "png ru w rn", : "zu z nn to", : "z w chu x", : "zhun hu wi f", : "yng gun sn jn", : "y d r ch", : "xi m sh l", : "wn r b zhun", : "tin do ho hun", : "shn dn l b", : "s du chng bng", : "pin zh zh z", : "nng qu w ln", : "m m w wn", : "ling l r wi", : "l l k sh", : "ku bi zi do", : "jn z ho qi", : "ho wi rn sh", : "ho shng j ji", : "g yu su ho", : "du d ling l", : "zh tin wi sh", : "y xng chun fi", : "xn kun t pn", : "wi d b z", : "tin xi wi ji", : "sh wi wi t", : "sn zi b nn", : "m hu r gun", : "l li l l", : "jin fng ji zun", : "ji cng b li", : "j gng ho y", : "j nin li yu", : "hu d wi lo", : "gng mng gi xng", : "fng wi gu ni", : "du nn xng bng", : "b p b l", : "zu d z hu", : "zu b chng x", : "zu b ku tng", : "zu ji y shang", : "zu zh yu w", : "zu y yu yu", : "zun tu m fng", : "zun tin d dng", : "zun p ch y", : "zun hu d bng", : "zun dng m fng", : "zun bng qi hu", : "z wi f yn", : "zhu f nn sh", : "zhu rn xin bin", : "zhu dio wi p", : "zhu ch nng zhng", : "chu xn yn q", : "chu xn q xu", : "chu ni xing sh", : "chu ni sh xu", : "chu ni f zhng", : "chu mi t gu", : "chu mi gu qi", : "zhung f chng gun", : "zhung yn bo xing", : "zhun chu wi x", : "zhun chn wi x", : "zhui xing lu ji", : "zhui p f l", : "zhui b tu m", : "zh chng wn dun", : "zh jin wi l", : "zh yu q kng", : "zh yu kng x", : "zh tin wi n", : "zh yun yu r", : "zh mo l l", : "zh c b sh", : "zh w b hun", : "zh ling cn du", : "zh ling x chn", : "zh r gun x", : "zh fn zo gi", : "zhu du y s", : "zhu zhng wi hun", : "chng mng j yn", : "zhng zhu tng yn", : "zhng mo cun qi", : "zhng ho zhng w", : "zhi zh su t", : "zh ch w tu", : "zh dng b y", : "zh zo wi bi", : "zh yn wi gng", : "zh sh wi xng", : "zh shn shu m", : "zh g wi w", : "zh gn xing ch", : "zh d y bn", : "zh w q c", : "zhng shn shui xi", : "zhng gun l xi", : "zhng gun n l", : "zhng gng shui w", : "zhng dn gn kn", : "zhn tu xu ti", : "zhn sng jng bi", : "zh y s l", : "sh jin wi sh", : "zh r z zh", : "zho d s wi", : "zhng j xio r", : "zhn n wng hu", : "zhn fng wng q", : "zhn jing qin q", : "zng m tu zh", : "zng shn sh rn", : "zo yo zhng shng", : "zo zhn w yo", : "zo gu sh c", : "cun sn j w", : "cun mei c ", : "cun lng h zhng", : "cun fng j d", : "zi xio zi yn", : "zi ji wn z", : "yn shn b x", : "yn sh xi jun", : "yu zhng sh gu", : "yu lu shn hng", : "y n qi ji", : "y j wi fng", : "y nn chng xing", : "y y li li", : "y zh w dng", : "y xio xun tin", : "y sh chn f", : "y sh xio xi", : "y qing zun x", : "y du qn mu", : "y chun p d", : "y yng k g", : "y zh y xing", : "y q y qi", : "y ji wi gu", : "yu ji w hun", : "yu ji w y", : "yu gu nn tu", : "yu b yu fng", : "yu gn dng jn", : "yu yn t y", : "yng zhng jio jio", : "yng sh yn shu", : "yng yng fi jn", : "yng xn yn zho", : "yng yn yn w", : "yng tin shn sh", : "yn li shu ru", : "yn zhn shn t", : "yn d shng li", : "yn shng qi m", : "yn ch dn sh", : "yn yun wi sh", : "yn sh wi w", : "y mi y w", : "y s li lu", : "y l wng qi", : "y y wi zh", : "y yn wi hu", : "y sh jin qn", : "y shu j shu", : "y sh wi y", : "y shu wi gng", : "y shng ling dn", : "y shn wi jin", : "y qun wi y", : "y l li xng", : "y hu wi f", : "y hi wi bi", : "y gu wi tin", : "y g wi jin", : "y gng xio ju", : "y f wi jio", : "y d w x", : "y sh wng li", : "y qn zi hui", : "y d ji jin", : "y tu l dng", : "y z sh shu", : "y qng chng fi", : "y shang zh hu", : "y dn sh b", : "y hun y bo", : "y gng ho lng", : "y dio w qing", : "yo ch n sh", : "yo m xio chu", : "yng jng x ru", : "ng shu shn mi", : "yng yng s s", : "yng go mi ji", : "yng fng ji y", : "yn zho sh jn", : "yn zho ho m", : "yn sh wng zhn", : "yn jn qin jn", : "yn jn m xi", : "yn ji yu g", : "yn g zho w", : "yn di zh sh", : "yn ch wi cho", : "shn zo fi shng", : "yn g wi xun", : "yn ch ho ", : "y ling wi jin", : "chn hng du sh", : "q sh hng xi", : "dng hng ch s", : "xi ch bn hng", : "r n chng hng", : "d hng d sh", : "xn hng sh m", : "xn ch xing h", : "xu zhi li li", : "xun y g sh", : "xun sh wi y", : "xun dn chng sh", : "xun hun s cn", : "xun gu x y", : "xun qun lu xi", : "xun h gun hu", : "x q yng z", : "xi rn d d", : "xi ln yng zho", : "xing j h zh", : "xing s d j", : "xng wn zi shng", : "xng wn yn w", : "xng gun qn yun", : "xng go ci li", : "xn shu xing yng", : "xn ku xing yng", : "xi sh nng qun", : "xi jin li z", : "jio dun ling chng", : "xio yn b p", : "xio yn dn y", : "xio mng sh bo", : "xu zh ju gn", : "xu ti w shng", : "xu zh wi mn", : "xu m wi l", : "xing wng fng hui", : "xiang pei yu zhu", : "xing sh yu p", : "xing sh r dng", : "xing qi xing cu", : "xing n pi f", : "xing mn yu xing", : "xin zhng ch j", : "xin w zhu bin", : "x yn b ch", : "sh q  jio", : "x mo bin f", : "x su b f", : "w ln yn zho", : "w x wi gu", : "w f hn y", : "w dun zhun hng", : "w sh li y", : "w s xing xun", : "w hu q gu", : "w hu l zh", : "w g d f", : "w z yu ch", : "w xi zh ch", : "w shng w xi", : "w nng wi y", : "w ku bo s", : "w kng b zun", : "w jin k chng", : "w jin dng xi", : "w  b wi", : "w dng wi d", : "w ling wi do", : "w qun tu zho", : "wn w chi sh", : "wi wi tu tu", : "wi r wi su", : "wi b b xi", : "wi shn zu l", : "wi shn zh ku", : "wi rn b f", : "wi qi wi j", : "wi mn f m", : "wi hu f cu", : "wi ho chng qin", : "wi gu wi y", : "wng fng xing yng", : "wng chn pio shng", : "wng zh hun tng", : "wng gng dn gun", : "wng gu d f", : "wn gun ji s", : "wn sh dng ru", : "wn ji b bo", : "wn su ki sh", : "w m shng f", : "tn yn yn l", : "tu yun dun qin", : "tu gn ji sh", : "tun fn ju j", : "tun tu j min", : "t s yn mi", : "t tu zhng no", : "t ku yn mi", : "t b w f", : "tu zhun r q", : "tu m bi n", : "tu hn no mn", : "tu kui j lin", : "tu ch tu m", : "tng z chung y", : "tng w xing zh", : "tng w xing x", : "tng gun zi bo", : "tng wn dio w", : "tng li zhng zh", : "ti sh ki hu", : "tio gun b fn", : "tio y lio chn", : "tio yo tio li", : "tio chn lio zu", : "tin b wi y", : "tin b wi gui", : "tin xi wi lng", : "tin ti l m", : "tin nin b su", : "tn nng q qi", : "tn yn wi zhng", : "tn yn wi zhng", : "sh kng j m", : "su w yng j", : "su yn ci gn", : "sng jn l xu", : "sng yn zh ji", : "s tng b dng", : "s m cun t", : "s b ni li", : "s su zh zh", : "s n f yun", : "shu wng xi d", : "shu g qi jn", : "shn fng r h", : "shn fng chu hu", : "shu zhng zhu yn", : "shung gn du ji", : "sh m r chu", : "sh m ling chi", : "sh l lu ji", : "sh hi ln hung", : "sh bi ln hung", : "sh yn hun f", : "sh p wi p", : "sh chun wi zh", : "sh qu yu jin", : "shu z chng jin", : "shu z y ch", : "shu jio gn jng", : "shu b yng xn", : "sh shu ji wn", : "sh zh y xng", : "sh sh yng w", : "sh qng shui y", : "sh dng q chng", : "sh wi zh j", : "sh yng jing lng", : "sh wi mn tin", : "sh du w y", : "sh y yu l", : "sh yng b li", : "sh sh jn gu", : "sh x zhn cng", : "sh w dng x", : "sh wi w gng", : "sh m ji nn", : "sh sh f zhng", : "sh ch kn zhng", : "sh zh wi zhung", : "sh j lng xin", : "shng jng xin zhun", : "shng jn xin xing", : "shng tu s zhui", : "shn j du rn", : "shn w gu gun", : "shn lng sh sh", : "shn wn q sh", : "shn l qin q", : "shn g wi lng", : "shn w tng j", : "shn chu xi yun", : "sh j wi gng", : "sh dun q chng", : "sh c zhu yng", : "sh xi wi xn", : "sho chng ru xng", : "shng dng xu gui", : "shng b dng gng", : "shn z wi mu", : "shn wi shu c", : "shn shn w ", : "shn ci nn sh", : "shn yn p mi", : "shn y xin k", : "shn yn chng xng", : "shn yo y wi", : "shn li chun sh", : "shn ji zo zhu", : "sh j wi sh", : "s l dn b", : "sng yn wi y", : "sng yn b x", : "sng t chu mi", : "sng h jun sh", : "sn zhn sn bi", : "sn w ling sh", : "sn rn wi zhng", : "sn ch ling cu", : "si jng fn sh", : "s xn gng sh", : "s so yng du", : "run hng xing t", : "r w gu zhng", : "r ti zh b", : "r l qi qng", : "r chng rn y", : "r shu tu sh", : "r qi r cu", : "r dng chn ti", : "ru b g bng", : "ru qng chu ti", : "rng m kung rng", : "r zhng wi sh", : "r yu shn chn", : "r xng yu xi", : "r xu yu g", : "r xng yu sh", : "rn d b j", : "rn yn j j", : "rn m gu yng", : "rn m y d", : "r o fn bng", : "jun lo yng w", : "q y yu ji", : "q yo ro gu", : "qing xng jn xing", : "qng q y qi", : "qng xin sh q", : "qng xin h c", : "qng du jing qu", : "qng chng do d", : "qng z p t", : "qng ln hi si", : "qn shu  mi", : "qn s zh ho", : "qi zh wi ji", : "qi sh do gn", : "qi l yn xn", : "qi jn de dng", : "qio z yn lng", : "qio f q zhng", : "jing zu ni sh", : "qing zh z su", : "qing s qing hu", : "qing sh z i", : "qing sh m jio", : "qing gng jng n", : "qing gu b sh", : "qing f bin h", : "qing r hu k", : "qing d y pn", : "qin xng to qng", : "qin yng dn ji", : "qin lio bi dng", : "q xi r y", : "q yn wi sh", : "ki t jn z", : "q x l q", : "q sh xin zhu", : "q wng sh ni", : "q tin kung d", : "p tin shui t", : "p xing n d", : "p jn li xi", : "p ji wi gu", : "p g wi yun", : "png pio png zhun", : "png tin j d", : "bng shng x q", : "png j j zhng", : "pn zu b sh", : "pin y zh c", : "p f wn shn", : "png lng po fng", : "fu bi kui l", : "png mi ho f", : "pn hu zh li", : "pn chn sh gu", : "n d nn li", : "nng y chu xio", : "nng gun tio xin", : "nng fn dio zh", : "nng m dn zhung", : "nin t wi xing", : "nin y sh ho", : "nin hu chu m", : "n b y ln", : "n r b z", : "nng zh wi sh", : "nng b chn gun", : "no zh wi q", : "nn jn y tu", : "nn d h t", : "nn mn ju sh", : "nn fn bi g", : "m zh n x", : "m yun xn tn", : "m tio xn zho", : "m ling y yng", : "m tu m no", : "m gn nio q", : "mu s chui chn", : "m y d y", : "m fn sh zh", : "m lng jun qi", : "m lng wn jio", : "m mn b zho", : "m b zhu bin", : "mng zhng zh dng", : "mng h zh yng", : "mng xio d yn", : "mng w g dng", : "mio ch kn sh", : "mng xu q cho", : "min l b ci", : "m yu ji y", : "m y tu sh", : "m lin hi g", : "mn shn l jng", : "mn dn h b", : "mi dn chn xng", : "mo mng ji jio", : "mo su du jng", : "mo f do sh", : "mi wn wi shng", : "mi l zun h", : "mi d hun zh", : "mn sn yun s", : "m r hu shn", : "lu p jing h", : "lu lu nn h", : "lu co wi ku", : "lu zh gu xin", : "lun fng h mng", : "shui yu ji zhng", : "shui t tng qng", : "shui shu sh rn", : "shui t gu xn", : "shui m y j", : "shui r chng zhng", : "l jn yn xu", : "lu jn gng ln", : "lng nio jin yun", : "lng nio ch y", : "lng yu q zho", : "lng xu xun hung", : "lng dio fng j", : "li ch zh tu", : "lng yun zh q", : "lng rn png f", : "lng jng cu l", : "ln d y jing", : "li shang y chung", : "li gun hu min", : "lio w j s", : "lio shn d mng", : "lio rn w wn", : "lio b k jin", : "lio b zhng jn", : "lio f cu k", : "shn sh du sh", : "ling xio l wi", : "xing sh du l", : "ling ru zh zo", : "ling r jing hi", : "ling jn mi f", : "ling j shn fn", : "lin g chu hn", : "l y wi zh", : "l lng zh hn", : "l gung b hu", : "l wi qng mo", : "l rng wi gu", : "l shng xng jio", : "l bn jio m", : "lng mi hng yn", : "li tin do d", : "li z chng b", : "li w ji shng", : "li t zh shn", : "li t j sh", : "li lun zh wi", : "li li r zh", : "li kui j s", : "l shn l shu", : "lo yun jn tin", : "lo sh xi r", : "lo sh g zi", : "lng hun f d", : "ku qng du l", : "kung r li sh", : "kung ji m fng", : "k sh shng hu", : "ku qng sh b", : "ku jio shng fng", : "ku jio chn fng", : "ku jio fng qng", : "ku gn sh jio", : "ku f zh li", : "kng f pin pin", : "k y lio zu", : "k m wi h", : "k zh tu y", : "k tu chng zh", : "kng yn wi sh", : "ki hu ji gu", : "jn bn yn ch", : "jio ti j jn", : "ju m pn zh", : "ju tu jing no", : "ju tu ju no", : "jun nio zh hun", : "jun x r zng", : "jun ji bi do", : "j m wi shn", : "j shu xing qng", : "j sh hn zhu", : "j wi mo co", : "j shn qin jing", : "j xi shn shng", : "ji yo b wng", : "ji zhun gng chng", : "ji zhng sn hn", : "jng y l qn", : "jng d xi m", : "jng q jun sh", : "jng j zi t", : "jn sh ki si", : "jn wi shng rng", : "jn tu xio chng", : "jn tu yng j", : "jn tu ch fn", : "jn tu b zh", : "jn du jn sho", : "jn nng hun sh", : "jn j z sh", : "jn gng f q", : "jn gun xin si", : "jn w b jn", : "jn ch bi hi", : "ji y y rn", : "ji rn nn d", : "ji lng x lng", : "ji f yng kung", : "ji q o qio", : "jio no shng m", : "jio shu ling fi", : "jio l ji ch", : "jio sh ln sh", : "jio r s n", : "jio fng b s", : "xing yo zhu gui", : "jing q g y", : "jing mn yu jing", : "jing du g y", : "jin hu lng h", : "jin yng du xng", : "jin b k zhng", : "xin s bo p", : "jin q y rn", : "jin s sh m", : "jin b zhng l", : "jin xin cng ch", : "jin zu b sh", : "ji gun tin xi", : "ji f zh qn", : "ji li qin jn", : "ji j rn z", : "ji do cng rng", : "ji di rn w", : "j fng lng yu", : "j xng y qng", : "j shn l yun", : "j gng ling zu", : "j shang lin y", : "j sh xing dio", : "j b k wi", : "j shn yn j", : "j bn yu y", : "j b tng jio", : "j s li ji", : "j sh li r", : "j l wi b", : "j d li gng", : "j chn mi g", : "j pi mo m", : "hu wi f xin", : "hu f xing y", : "hu jn gng ch", : "hn yng ln yng", : "hu zhu wi du", : "hu zhng wi du", : "hu gun li chng", : "hu mng p s", : "hu chun zhun du", : "hung ch do nng", : "hung gun co l", : "hung f r ch", : "hung f chu tio", : "hun zh fn b", : "hun nin zh s", : "hun nin qu lo", : "hui shang wi k", : "hu d hu wn", : "hu xio wi ji", : "hu f wi q", : "hu ch wi fng", : "hu bu lng dng", : "h xin wi chun", : "h l h zh", : "h li h q", : "h b j x", : "hu wi x d", : "hu d zi w", : "hng jin y gn", : "hng l lio f", : "hng shng j z", : "hng bu lng dng", : "hng qing yng du", : "hng n ln shng", : "hn hi nn tin", : "h f j p", : "h s gn l", : "h h hi gn", : "h yn yu s", : "h zng lin hng", : "ho ho shng shng", : "ho yng du hn", : "ho wn z y", : "ho wi sh dun", : "ho wn ju y", : "ho shng zh d", : "ho q shng y", : "ho  b tng", : "ho dn fi s", : "ho gn bo q", : "ho f b shung", : "hn sun lu p", : "hn yng j hu", : "hn h b mng", : "gu wi y shn", : "gu sh ln cu", : "gu xun j sh", : "gung wn xin sheng", : "gung lng sn ju", : "gun shn di l", : "gun j do sh", : "gu x wi mn", : "gu jin xin wn", : "gu g xing lin", : "g wn fn zho", : "g dio dn tn", : "g dio b tn", : "g y shn rn", : "gu h q rng", : "gu x hu gun", : "gu zho j y", : "gng zh bi gn", : "gng wi chn ch", : "gng shu r xing", : "gng jin su bi", : "gng b chn y", : "gng dio m f", : "gng xng gi w", : "gng p nn sh", : "gng lng mng ho", : "gng di gn b", : "gng chng di h", : "gng chng mng dun", : "g s mng yng", : "g g b n", : "g g b t", : "g shu x yng", : "go ch m m", : "go y b yn", : "gng tu z d", : "gn wi gn zu", : "gn fn su sh", : "gn ch xi li", : "gn t sh k", : "gn mng fn y", : "gn jing m y", : "gn chng zh jing", : "f zi w ch", : "f zhi z hun", : "f wi z yn", : "f sh zhng mn", : "f wi hu sh", : "f ho lu j", : "f shu l sh", : "f shu zh s", : "p zhng z ti", : "f tu zhu fn", : "fng wi ki m", : "fng m lun ", : "fng x xi sh", : "fng yng f yn", : "fng w b ji", : "fn t b r", : "fn fng p li", : "fi fi shng shng", : "fi sh b y", : "fi jing sh q", : "fng p xi ch", : "fng lng yun gun", : "fn r b jio", : "fn bn hun yun", : "fn lo wi y", : "f ln chng zhun", : "f b dng zu", : "f yn qin jn", : "f jin t f", : "f dun xn chng", : "r sh wi n", : "r n xn chng", : "r n qng ji", : " w yng shn", : " pio zhn j", : " pio zi do", : "w zu qing ji", : " y zhng shng", : "w sh j xi", : "w j xi li", : "w b q shn", : " hng du sh", : " jn kng yn", : "  shng shng", : " jn nio yn", : "du y d jio", : "du rn su ho", : "du yn shu qing", : "du wn wi f", : "du dun gu yo", : "du ci shn g", : "dn sh w mn", : "dn j hung gun", : "du n yng j", : "dun hun gu zng", : "dun jin b sh", : "d j q ch", : "du j y shng", : "d m wi sh", : "d jun t xu", : "d jn j yun", : "d yu qin qi", : "d sh d jin", : "du zhun shn hng", : "du d lin chng", : "dng jin zhng ji", : "dng y x h", : "dng zhng kun yo", : "dng mng x yng", : "dng ln x zho", : "dng ling x sh", : "dng ji x sh", : "dng ch x zhui", : "dng chng yu r", : "dng chng y sh", : "dng tu ln ln", : "di dng b j", : "di dn bn ji", : "dio xn yn zho", : "din do y chng", : "d b nng xin", : "d m sh z", : "do q f zh", : "do x pi kng", : "do zi gn g", : "do chng su lng", : "do gu wi yn", : "to zi zh j", : "to pi m zu", : "dng chi wi n", : "dng zhu ch zhng", : "dng zhu b zhu", : "dng w sh zhng", : "dn r nng m", : "tn wn tu shu", : "dn ji w y", : "dn s pio yn", : "d p b wn", : "d mng f d", : "d ch y zi", : "d mn h lu", : "t li zhng zh", : "cu hu lio yun", : "cu k d hng", : "cn j zh li", : "cu cu ch ch", : "cu zh ho qing", : "cu gng wi ru", : "cng s ji jin", : "c f b yng", : "c chng b h", : "c bi wi bn", : "chn sh pin j", : "chn sn n f", : "chu tu t y", : "chun wi xio tn", : "chun fng shn hu", : "chun hng zhu l", : "ch ch j li", : "ch zn j xin", : "ch tng yn qu", : "ch sh xio gng", : "ch go ln shn", : "ch r w jin", : "ch mn yng zh", : "ch ch y m", : "ch ch sh t", : "ch ch jn tu", : "chu shn mn hi", : "chng gun z li", : "ch y wi hu", : "ch r yun jia", : "ch dun cn chng", : "ch cn zh gng", : "chng bi x gng", : "chng bi xng fi", : "chn shu hu n", : "chng y do qng", : "chng t zi y", : "chn t ci y", : "chn ji yu w", : "chng d du gng", : "chn yn zhng j", : "chn yn b ju", : "chn k s j", : "ch qin l yn", : "ch shn fng q", : "ch zi chun zhung", : "zho shng m g", : "zho pn m sh", : "cho jn gun g", : "chng r b h", : "chng su y wi", : "chng hng b xi", : "zhng yu zn bi", : "chng shng j r", : "zhng nin sn lo", : "chng chn b lo", : "zhng o sh fi", : "chng tng l sh", : "chn x zhn n", : "ch sn cu s", : "cng ti li xi", : "cng xin di ch", : "cng zng ni j", : "cng yng jin xi", : "cn sng dn b", : "cn fng s xi", : "cn w cu zng", : "shn chn mo yu", : "ci yu gn j", : "ci b zh shui", : "ci d nn yng", : "ci b zh qin", : "b z wi y", : "b z wi j", : "b z wi f", : "b z ch sh", : "b zhu tng r", : "b zh dng dng", : "b yu li ch", : "b xing wi mu", : "b tn wi bo", : "b lio r lio", : "b k ku du", : "b hung q ch", : "b dng b zhng", : "b ch shn me", : "b ch li sh", : "b ling fn xng", : "b t yng sh", : "b w x g", : "b hn zhng rn", : "b wn yu l", : "b kng m m", : "b p chu jn", : "b f chu su", : "b zh yn wi", : "b hi yn zh", : "bng wi jing gu", : "bng qing jing yng", : "bng du jing gung", : "bng b yu jing", : "bng ji d p", : "bn bn j j", : "bio mi zh nin", : "bio l wi jin", : "bio f din j", : "bin tn l b", : "b gi b q", : "b yn mi shu", : "b w zh sh", : "p shn di h", : "p ji zhn g", : "p ji j n", : "p h hui y", : "p f yng gun", : "bi q yo gng", : "bi chung go w", : "bi chn xng gng", : "bi b zh yn", : "bi gng fi sh", : "p y l gun", : "p si lng mn", : "bo l wn xu", : "bo h png h", : "bo wn zhi gu", : "bo f ch sh", : "bo bin y du", : "bng xin zun ln", : "bi jing fng hu", : "bi shu shui w", : "bi kng qin chung", : "bi y qng xing", : "bi shu wi lng", : "bi shu xing zh", : "b wn w yn", : "b gu jun x", : "b bn s yun", : "o b k zhng", : "o gng shu y", : "n sh ch shn", : "n shn wi l", : "n lo hui sho", : "n b dng ch", : "i rn ho sh", : "i rn gun chng", : "i fng j fng", : "i shn s hi", : " ji  wng", : " dng xing wi", : "zhu wng zh bi", : "zh ln d shu", : "zh tng zho r", : "y b jng rn", : "y jn wi li", : "y r sn xng", : "xu j y ch", : "w j li shu", : "w shng w xi", : "wi y b xn", : "sh shn wi gu", : "sh q qi jing", : "qing zu ji rn", : "q chng du ni", : "ln shn l b", : "jn tin gung yu", : "jin nn ji ju", : "ji q ji b", : "hn hn  ", : "hu g b jn", : "gu p  rn", : "g m sh xin", : "f tu zhu fn", : "fng wi zh bo", : "dng tn bi jing", : "chn hn dng xng", : "ch ch wi mng", : "b wn qing zh", : "b nn ji y", : "lio w shng j", : "yu y shu y", : "d y w r", : "shu y b r", : "j y fn sn", : "sh y sh r", : "sh y jng bi", : "dng y mo r", : "dng y qu r", : "b y r zh", : "w y xng min", : "bio l b y", : "ling yu b y", : "xn ku b y", : "yn xng b y", : "zhng lng b y", : "cn c b y", : "fn fn b y", : "hu y b y", : "b y r sn", : "bi b y y", : "yn xng bo y", : "y bi xi y", : "bi chng ji y", : "png chng ji y", : "qun bi fng y", : "qn j h y", : "bi b hu y", : "bi b sh y", : "bi w sh y", : "wn b sh y", : "wn w sh y", : "h r wi y", : "h ling wi y", : "h r wi y", : "tin xi wi y", : "xing y wi y", : "jio ru hu y", : "jio r hu y", : "jio ru hu y", : "yn xng ru y", : "sh zhng ru y", : "zhng sh ru y", : "wi jng wi y", : "zhng du fi y", : "b nng zn y", : "wn y d sh", : "y b ni zhng", : "y y gun zh", : "y y dng bi", : "bi b dng y", : "sh b dng y", : "y y jng bi", : "y y fng bi", : "y y ch wn", : "y y zh wn", : "bi l tio y", : "zhng q hu y", : "y li r q", : "y l gng jio", : "y l q ch", : "y l b sh", : "zho cho zho lu", : "q y fng yng", : "y hng b xng", : "hng hng b xng" }, fat = Object.keys(rF).map((n) => ({ zh: n, pinyin: rF[n], probability: 2e-8, length: 4, priority: Nr.Normal, dict: Symbol("dict4") })), aF = { : "b r gn bn do", : "b r k sh h", : "b xng r yn zhng", : "b r sh wi k", : "h l r b wi", : "k zhng mng y h", : "mng d wi d y", : "mn y sh wi tin", : "sh hu zh g ling", : "w y x wi gu", : "xin xi shu wi qing", : "hng hng ch zhung yuan", : "y d l y hi", : "yn b jin wi jng", : "zh tng do du zi" }, gat = Object.keys(aF).map((n) => ({ zh: n, pinyin: aF[n], probability: 2e-8, length: 5, priority: Nr.Normal, dict: Symbol("dict5") }));
      function oF(n, t) {
        return n && (n.decimal < t.decimal || n.decimal === t.decimal && n.probability > t.probability) ? n : t;
      }
      function sF(n) {
        n.probability < 1e-300 && (n.probability *= 1e300, n.decimal += 1);
      }
      function dat(n) {
        return n.priority === Nr.Custom ? -(n.length * n.length * 100) : n.priority === Nr.Surname ? -(n.length * n.length * 10) : 0;
      }
      function Aat(n, t) {
        const e = [];
        let i = n.length - 1, r = n[i];
        for (let a = t - 1; a >= 0; a--) {
          const o = a + 1 >= t ? { probability: 1, decimal: 0, patterns: [] } : e[a + 1];
          for (; r && r.index + r.length - 1 === a; ) {
            const l = r.index, u = { probability: r.probability * o.probability, decimal: o.decimal + dat(r), patterns: o.patterns, concatPattern: r };
            sF(u), e[l] = oF(e[l], u), r = n[--i];
          }
          const s = { probability: 1e-13 * o.probability, decimal: 0, patterns: o.patterns };
          sF(s), e[a] = oF(e[a], s), e[a].concatPattern && (e[a].patterns = e[a].patterns.concat(e[a].concatPattern), e[a].concatPattern = void 0, delete e[a + 1]);
        }
        return e[0].patterns.reverse();
      }
      function lF(n, t) {
        return n && n.count <= t.count ? n : t;
      }
      function pat(n) {
        return n.priority === Nr.Custom ? -(n.length * n.length * 1e5) : n.priority === Nr.Surname ? -(n.length * n.length * 100) : 1;
      }
      function vat(n, t) {
        const e = [];
        let i = n.length - 1, r = n[i];
        for (let a = t - 1; a >= 0; a--) {
          const o = a + 1 >= t ? { count: 0, patterns: [] } : e[a + 1];
          for (; r && r.index + r.length - 1 === a; ) {
            const l = r.index, u = { count: pat(r) + o.count, patterns: o.patterns, concatPattern: r };
            e[l] = lF(e[l], u), r = n[--i];
          }
          const s = { count: 1 + o.count, patterns: o.patterns };
          e[a] = lF(e[a], s), e[a].concatPattern && (e[a].patterns = e[a].patterns.concat(e[a].concatPattern), e[a].concatPattern = void 0, delete e[a + 1]);
        }
        return e[0].patterns.reverse();
      }
      function yat(n, t) {
        return !(t.index + t.length <= n.index || t.priority > n.priority || t.priority === n.priority && t.length > n.length);
      }
      function mat(n) {
        const t = [];
        for (let e = n.length - 1; e >= 0; ) {
          const { index: i } = n[e];
          let r = e - 1;
          for (; r >= 0 && yat(n[e], n[r]); ) r--;
          (r < 0 || n[r].index + n[r].length <= i) && t.push(n[e]), e = r;
        }
        return t.reverse();
      }
      var uF;
      (function(n) {
        n[n.ReverseMaxMatch = 1] = "ReverseMaxMatch", n[n.MaxProbability = 2] = "MaxProbability", n[n.MinTokenization = 3] = "MinTokenization";
      })(uF || (uF = {}));
      class hF {
        constructor(t, e = "", i = "") {
          this.children = /* @__PURE__ */ new Map(), this.fail = null, this.patterns = [], this.parent = t, this.prefix = e, this.key = i;
        }
      }
      class _at {
        constructor() {
          this.dictMap = /* @__PURE__ */ new Map(), this.queues = [], this.root = new hF(null);
        }
        build(t) {
          this.buildTrie(t), this.buildFailPointer();
        }
        buildTrie(t) {
          for (let e of t) {
            const i = X0(e.zh);
            let r = this.root;
            for (let a = 0; a < i.length; a++) {
              let o = i[a];
              if (!r.children.has(o)) {
                const s = new hF(r, i.slice(0, a).join(""), o);
                r.children.set(o, s), this.addNodeToQueues(s);
              }
              r = r.children.get(o);
            }
            this.insertPattern(r.patterns, e), e.node = r, this.addPatternToDictMap(e);
          }
        }
        buildFailPointer() {
          let t = [], e = 0;
          for (this.queues.forEach((i) => {
            t = t.concat(i);
          }), this.queues = []; t.length > e; ) {
            let i = t[e++], r = i.parent && i.parent.fail, a = i.key;
            for (; r && !r.children.has(a); ) r = r.fail;
            r ? i.fail = r.children.get(a) : i.fail = this.root;
          }
        }
        addPatternToDictMap(t) {
          this.dictMap.has(t.dict) || this.dictMap.set(t.dict, /* @__PURE__ */ new Set()), this.dictMap.get(t.dict).add(t);
        }
        addNodeToQueues(t) {
          this.queues[ka(t.prefix)] || (this.queues[ka(t.prefix)] = []), this.queues[ka(t.prefix)].push(t);
        }
        insertPattern(t, e) {
          for (let i = t.length - 1; i >= 0; i--) {
            const r = t[i];
            if (e.priority === r.priority && e.probability >= r.probability) t[i + 1] = r;
            else if (e.priority > r.priority) t[i + 1] = r;
            else {
              t[i + 1] = e;
              return;
            }
          }
          t[0] = e;
        }
        removeDict(t) {
          this.dictMap.has(t) && (this.dictMap.get(t).forEach((i) => {
            i.node.patterns = i.node.patterns.filter((r) => r !== i);
          }), this.dictMap.delete(t));
        }
        match(t, e) {
          let i = this.root, r = [];
          const a = X0(t);
          for (let o = 0; o < a.length; o++) {
            let s = a[o];
            for (; i !== null && !i.children.has(s); ) i = i.fail;
            if (i === null) i = this.root;
            else {
              i = i.children.get(s);
              const l = i.patterns.find((h) => e === "off" ? h.priority !== Nr.Surname : e === "head" ? h.length - 1 - o === 0 : true);
              l && r.push(Object.assign(Object.assign({}, l), { index: o - l.length + 1 }));
              let u = i.fail;
              for (; u !== null; ) {
                const h = u.patterns.find((c) => e === "off" ? c.priority !== Nr.Surname : e === "head" ? c.length - 1 - o === 0 : true);
                h && r.push(Object.assign(Object.assign({}, h), { index: o - h.length + 1 })), u = u.fail;
              }
            }
          }
          return r;
        }
        search(t, e, i = 2) {
          const r = this.match(t, e);
          return i === 1 ? mat(r) : i === 3 ? vat(r, ka(t)) : Aat(r, ka(t));
        }
      }
      const Iat = [...gat, ...fat, ...cat, ...hat, ...iat, ...uat], cF = new _at();
      cF.build(Iat);
      const Eat = new Xk(), xat = () => Eat, FA = (n) => {
        const t = bl.get(n);
        return t ? t.split(" ")[0] : n;
      }, wat = (n, t, e, i) => {
        const r = cF.search(n, e, i);
        let a = 0;
        const o = X0(n);
        for (let s = 0; s < o.length; ) {
          const l = r[a];
          if (l && s === l.index) {
            if (l.length === 1 && l.priority <= Nr.Normal) {
              const c = o[s];
              let f = "";
              f = eF(c, o[s - 1], o[s + 1]), t[s] = { origin: c, result: f, isZh: f !== c, originPinyin: f }, s++, a++;
              continue;
            }
            const u = l.pinyin.split(" ");
            let h = 0;
            for (let c = 0; c < l.length; c++) {
              const f = X0(l.zh);
              t[s + c] = { origin: f[c], result: u[h], isZh: true, originPinyin: u[h] }, h++;
            }
            s += l.length, a++;
          } else {
            const u = o[s];
            let h = "";
            h = eF(u, o[s - 1], o[s + 1]), t[s] = { origin: u, result: h, isZh: h !== u, originPinyin: h }, s++;
          }
        }
        return { list: t, matches: r };
      }, Z0 = (n) => n.replace(/(|||)/g, "a").replace(/(|||)/g, "o").replace(/(|||)/g, "e").replace(/(|||)/g, "i").replace(/(|||)/g, "u").replace(/(|||)/g, "").replace(/(n|||)/g, "n").replace(/(m||m|m)/g, "m").replace(/(|||)/g, ""), fF = (n, t = "off") => {
        const e = xat();
        let i = bl.get(n) ? bl.get(n).split(" ") : [];
        if (e.get(n)) i = e.get(n).split(" ");
        else if (t !== "off") {
          const r = Mw[n];
          r && (i = [r].concat(i.filter((a) => a !== r)));
        }
        return i;
      }, Cat = (n, t = "off") => {
        let e = fF(n, t);
        return e.length > 0 ? e.map((i) => ({ origin: n, result: i, isZh: true, originPinyin: i })) : [{ origin: n, result: n, isZh: false, originPinyin: n }];
      }, K0 = (n) => {
        const t = n.split(" "), e = [], i = [];
        for (let r of t) for (let a of Krt) if (r.startsWith(a)) {
          let o = r.slice(a.length);
          $rt.indexOf(a) !== -1 && Jrt.indexOf(o) !== -1 && (o = tat[o]), e.push(a), i.push(o);
          break;
        }
        return { final: i.join(" "), initial: e.join(" ") };
      }, $0 = (n) => {
        const { final: t } = K0(n);
        let e = "", i = "", r = "";
        return eat.indexOf(Z0(t)) !== -1 ? (e = t[0], i = t[1], r = t.slice(2)) : (i = t[0] || "", r = t.slice(1) || ""), { head: e, body: i, tail: r };
      }, J0 = (n) => {
        const t = /(||||||n|m|)/, e = /(||||||||)/, i = /(|||||||m|)/, r = /(|||||||m|)/, a = /(a|o|e|i|u||)/, o = /(n|m)$/, s = [];
        return n.split(" ").forEach((u) => {
          t.test(u) ? s.push("1") : e.test(u) ? s.push("2") : i.test(u) ? s.push("3") : r.test(u) ? s.push("4") : a.test(u) || o.test(u) ? s.push("0") : s.push("");
        }), s.join(" ");
      }, Sat = (n, t) => {
        const e = Z0(n).split(" "), i = J0(t).split(" "), r = [];
        return e.forEach((a, o) => {
          r.push(`${a}${i[o]}`);
        }), r.join(" ");
      }, gF = (n, t) => {
        const e = [];
        return n.split(" ").forEach((r) => {
          e.push(t ? r[0] : r);
        }), e.join(" ");
      }, bat = (n) => typeof n == "string";
      function Dw(n, t) {
        return t instanceof RegExp ? t.test(n) : true;
      }
      const Bat = (n, t) => {
        let e = t.nonZh;
        if (e === "removed") return n.filter((i) => i.isZh || !Dw(i.origin, t.nonZhScope));
        if (e === "consecutive") {
          for (let i = n.length - 2; i >= 0; i--) {
            const r = n[i], a = n[i + 1];
            !r.isZh && !a.isZh && Dw(r.origin, t.nonZhScope) && Dw(a.origin, t.nonZhScope) && (r.origin += a.origin, r.result += a.result, a.delete = true);
          }
          return n.filter((i) => !i.delete);
        } else return n;
      }, dF = (n, t) => ka(n) === 1 && t.multiple ? Cat(n, t.surname) : false, Tat = (n, t) => {
        switch (t.pattern) {
          case "pinyin":
            break;
          case "num":
            n.forEach((e) => {
              e.result = e.isZh ? J0(e.result) : "";
            });
            break;
          case "initial":
            n.forEach((e) => {
              e.result = e.isZh ? K0(e.result).initial : "";
            });
            break;
          case "final":
            n.forEach((e) => {
              e.result = e.isZh ? K0(e.result).final : "";
            });
            break;
          case "first":
            n.forEach((e) => {
              e.result = gF(e.result, e.isZh);
            });
            break;
          case "finalHead":
            n.forEach((e) => {
              e.result = e.isZh ? $0(e.result).head : "";
            });
            break;
          case "finalBody":
            n.forEach((e) => {
              e.result = e.isZh ? $0(e.result).body : "";
            });
            break;
          case "finalTail":
            n.forEach((e) => {
              e.result = e.isZh ? $0(e.result).tail : "";
            });
            break;
        }
      }, Mat = (n, t) => {
        switch (t.toneType) {
          case "symbol":
            break;
          case "none":
            n.forEach((e) => {
              e.isZh && (e.result = Z0(e.result));
            });
            break;
          case "num": {
            n.forEach((e) => {
              e.isZh && (e.result = Sat(e.result, e.originPinyin));
            });
            break;
          }
        }
      }, Dat = (n, t) => {
        t.v && n.forEach((e) => {
          e.isZh && (e.result = e.result.replace(//g, "v"));
        });
      }, Rat = (n, t, e) => {
        if (t.multiple && ka(e) === 1) {
          let i = "";
          n = n.filter((r) => {
            const a = r.result !== i;
            return i = r.result, a;
          });
        }
        return t.type === "array" ? n.map((i) => i.result) : t.type === "all" ? n.map((i) => {
          const r = i.isZh ? i.result : "", { initial: a, final: o } = K0(r), { head: s, body: l, tail: u } = $0(r);
          let h = [];
          return r !== "" && (h = [r].concat(fF(i.origin, t.surname).filter((c) => c !== r))), { origin: i.origin, pinyin: r, initial: a, final: o, first: gF(i.result, i.isZh), finalHead: s, finalBody: l, finalTail: u, num: Number(J0(i.originPinyin)), isZh: i.isZh, polyphonic: h, inZhRange: !!bl.get(i.origin), result: i.result };
        }) : n.map((i) => i.result).join(t.separator);
      }, Lat = (n, t) => (t === false && n.forEach((e) => {
        e.origin === "" ? e.result = e.originPinyin = "y" : e.origin === "" && (e.result = e.originPinyin = "b");
      }), n), Pat = { pattern: "pinyin", toneType: "symbol", type: "string", multiple: false, mode: "normal", removeNonZh: false, nonZh: "spaced", v: false, separator: " ", toneSandhi: true, segmentit: 2 };
      function Nat(n, t) {
        if (t = Object.assign(Object.assign({}, Pat), t || {}), !bat(n)) return n;
        if (n === "") return t.type === "array" || t.type === "all" ? [] : "";
        t.surname === void 0 && (t.mode === "surname" ? t.surname = "all" : t.surname = "off"), t.type === "all" && (t.pattern = "pinyin"), t.pattern === "num" && (t.toneType = "none"), t.removeNonZh && (t.nonZh = "removed");
        let i = Array(ka(n)), { list: r } = wat(n, i, t.surname, t.segmentit);
        return r = Lat(r, t.toneSandhi), r = Bat(r, t), dF(n, t) && (r = dF(n, t)), Tat(r, t), Mat(r, t), Dat(r, t), Rat(r, t, n);
      }
      var Rw;
      (function(n) {
        n[n.AllSegment = 1] = "AllSegment", n[n.AllArray = 2] = "AllArray", n[n.AllString = 3] = "AllString", n[n.PinyinSegment = 4] = "PinyinSegment", n[n.PinyinArray = 5] = "PinyinArray", n[n.PinyinString = 6] = "PinyinString", n[n.ZhSegment = 7] = "ZhSegment", n[n.ZhArray = 8] = "ZhArray", n[n.ZhString = 9] = "ZhString";
      })(Rw || (Rw = {})), Rw.AllSegment;
      const Lw = [{ name: "", longitude: 116.405285, latitude: 39.904989 }, { name: "", longitude: 117.190182, latitude: 39.125596 }, { name: "", longitude: 114.502461, latitude: 38.045474 }, { name: "", longitude: 118.175393, latitude: 39.635113 }, { name: "", longitude: 119.586579, latitude: 39.942531 }, { name: "", longitude: 114.490686, latitude: 36.612273 }, { name: "", longitude: 114.508851, latitude: 37.0682 }, { name: "", longitude: 115.482331, latitude: 38.867657 }, { name: "", longitude: 114.884091, latitude: 40.811901 }, { name: "", longitude: 117.939152, latitude: 40.976204 }, { name: "", longitude: 116.857461, latitude: 38.310582 }, { name: "", longitude: 116.704441, latitude: 39.523927 }, { name: "", longitude: 115.665993, latitude: 37.735097 }, { name: "", longitude: 112.549248, latitude: 37.857014 }, { name: "", longitude: 113.295259, latitude: 40.09031 }, { name: "", longitude: 113.583285, latitude: 37.861188 }, { name: "", longitude: 113.113556, latitude: 36.191112 }, { name: "", longitude: 112.851274, latitude: 35.497553 }, { name: "", longitude: 112.433387, latitude: 39.331261 }, { name: "", longitude: 112.736465, latitude: 37.696495 }, { name: "", longitude: 111.003957, latitude: 35.022778 }, { name: "", longitude: 112.733538, latitude: 38.41769 }, { name: "", longitude: 111.517973, latitude: 36.08415 }, { name: "", longitude: 111.134335, latitude: 37.524366 }, { name: "", longitude: 111.670801, latitude: 40.818311 }, { name: "", longitude: 109.840405, latitude: 40.658168 }, { name: "", longitude: 106.825563, latitude: 39.673734 }, { name: "", longitude: 118.956806, latitude: 42.275317 }, { name: "", longitude: 122.263119, latitude: 43.617429 }, { name: "", longitude: 109.99029, latitude: 39.817179 }, { name: "", longitude: 119.758168, latitude: 49.215333 }, { name: "", longitude: 107.416959, latitude: 40.757402 }, { name: "", longitude: 113.114543, latitude: 41.034126 }, { name: "", longitude: 122.070317, latitude: 46.076268 }, { name: "", longitude: 116.090996, latitude: 43.944018 }, { name: "", longitude: 105.706422, latitude: 38.844814 }, { name: "", longitude: 123.429096, latitude: 41.796767 }, { name: "", longitude: 121.618622, latitude: 38.91459 }, { name: "", longitude: 122.995632, latitude: 41.110626 }, { name: "", longitude: 123.921109, latitude: 41.875956 }, { name: "", longitude: 123.770519, latitude: 41.297909 }, { name: "", longitude: 124.383044, latitude: 40.124296 }, { name: "", longitude: 121.135742, latitude: 41.119269 }, { name: "", longitude: 122.235151, latitude: 40.667432 }, { name: "", longitude: 121.648962, latitude: 42.011796 }, { name: "", longitude: 123.18152, latitude: 41.269402 }, { name: "", longitude: 122.06957, latitude: 41.124484 }, { name: "", longitude: 123.844279, latitude: 42.290585 }, { name: "", longitude: 120.451176, latitude: 41.576758 }, { name: "", longitude: 120.856394, latitude: 40.755572 }, { name: "", longitude: 125.3245, latitude: 43.886841 }, { name: "", longitude: 126.55302, latitude: 43.843577 }, { name: "", longitude: 124.370785, latitude: 43.170344 }, { name: "", longitude: 125.145349, latitude: 42.902692 }, { name: "", longitude: 125.936501, latitude: 41.721177 }, { name: "", longitude: 126.427839, latitude: 41.942505 }, { name: "", longitude: 124.823608, latitude: 45.118243 }, { name: "", longitude: 122.841114, latitude: 45.619026 }, { name: "", longitude: 129.513228, latitude: 42.904823 }, { name: "", longitude: 126.642464, latitude: 45.756967 }, { name: "", longitude: 123.95792, latitude: 47.342081 }, { name: "", longitude: 130.975966, latitude: 45.300046 }, { name: "", longitude: 130.277487, latitude: 47.332085 }, { name: "", longitude: 131.157304, latitude: 46.643442 }, { name: "", longitude: 125.11272, latitude: 46.590734 }, { name: "", longitude: 128.899396, latitude: 47.724775 }, { name: "", longitude: 130.361634, latitude: 46.809606 }, { name: "", longitude: 131.015584, latitude: 45.771266 }, { name: "", longitude: 129.618602, latitude: 44.582962 }, { name: "", longitude: 127.499023, latitude: 50.249585 }, { name: "", longitude: 126.99293, latitude: 46.637393 }, { name: "", longitude: 124.711526, latitude: 52.335262 }, { name: "", longitude: 121.472644, latitude: 31.231706 }, { name: "", longitude: 118.767413, latitude: 32.041544 }, { name: "", longitude: 120.301663, latitude: 31.574729 }, { name: "", longitude: 117.184811, latitude: 34.261792 }, { name: "", longitude: 119.946973, latitude: 31.772752 }, { name: "", longitude: 120.619585, latitude: 31.299379 }, { name: "", longitude: 120.864608, latitude: 32.016212 }, { name: "", longitude: 119.178821, latitude: 34.600018 }, { name: "", longitude: 119.021265, latitude: 33.597506 }, { name: "", longitude: 120.139998, latitude: 33.377631 }, { name: "", longitude: 119.421003, latitude: 32.393159 }, { name: "", longitude: 119.452753, latitude: 32.204402 }, { name: "", longitude: 119.915176, latitude: 32.484882 }, { name: "", longitude: 118.275162, latitude: 33.963008 }, { name: "", longitude: 120.153576, latitude: 30.287459 }, { name: "", longitude: 121.549792, latitude: 29.868388 }, { name: "", longitude: 120.672111, latitude: 28.000575 }, { name: "", longitude: 120.750865, latitude: 30.762653 }, { name: "", longitude: 120.102398, latitude: 30.867198 }, { name: "", longitude: 120.582112, latitude: 29.997117 }, { name: "", longitude: 119.649506, latitude: 29.089524 }, { name: "", longitude: 118.87263, latitude: 28.941708 }, { name: "", longitude: 122.106863, latitude: 30.016028 }, { name: "", longitude: 121.428599, latitude: 28.661378 }, { name: "", longitude: 119.921786, latitude: 28.451993 }, { name: "", longitude: 117.283042, latitude: 31.86119 }, { name: "", longitude: 118.376451, latitude: 31.326319 }, { name: "", longitude: 117.363228, latitude: 32.939667 }, { name: "", longitude: 117.018329, latitude: 32.647574 }, { name: "", longitude: 118.507906, latitude: 31.689362 }, { name: "", longitude: 116.794664, latitude: 33.971707 }, { name: "", longitude: 117.816576, latitude: 30.929935 }, { name: "", longitude: 117.043551, latitude: 30.50883 }, { name: "", longitude: 118.317325, latitude: 29.709239 }, { name: "", longitude: 118.316264, latitude: 32.303627 }, { name: "", longitude: 115.819729, latitude: 32.896969 }, { name: "", longitude: 116.984084, latitude: 33.633891 }, { name: "", longitude: 116.507676, latitude: 31.752889 }, { name: "", longitude: 115.782939, latitude: 33.869338 }, { name: "", longitude: 117.489157, latitude: 30.656037 }, { name: "", longitude: 118.757995, latitude: 30.945667 }, { name: "", longitude: 119.306239, latitude: 26.075302 }, { name: "", longitude: 118.11022, latitude: 24.490474 }, { name: "", longitude: 119.007558, latitude: 25.431011 }, { name: "", longitude: 117.635001, latitude: 26.265444 }, { name: "", longitude: 118.589421, latitude: 24.908853 }, { name: "", longitude: 117.661801, latitude: 24.510897 }, { name: "", longitude: 118.178459, latitude: 26.635627 }, { name: "", longitude: 117.02978, latitude: 25.091603 }, { name: "", longitude: 119.527082, latitude: 26.65924 }, { name: "", longitude: 115.892151, latitude: 28.676493 }, { name: "", longitude: 117.214664, latitude: 29.29256 }, { name: "", longitude: 113.852186, latitude: 27.622946 }, { name: "", longitude: 115.992811, latitude: 29.712034 }, { name: "", longitude: 114.930835, latitude: 27.810834 }, { name: "", longitude: 117.033838, latitude: 28.238638 }, { name: "", longitude: 114.940278, latitude: 25.85097 }, { name: "", longitude: 114.986373, latitude: 27.111699 }, { name: "", longitude: 114.391136, latitude: 27.8043 }, { name: "", longitude: 116.358351, latitude: 27.98385 }, { name: "", longitude: 117.971185, latitude: 28.44442 }, { name: "", longitude: 117.000923, latitude: 36.675807 }, { name: "", longitude: 120.355173, latitude: 36.082982 }, { name: "", longitude: 118.047648, latitude: 36.814939 }, { name: "", longitude: 117.557964, latitude: 34.856424 }, { name: "", longitude: 118.66471, latitude: 37.434564 }, { name: "", longitude: 121.391382, latitude: 37.539297 }, { name: "", longitude: 119.107078, latitude: 36.70925 }, { name: "", longitude: 116.587245, latitude: 35.415393 }, { name: "", longitude: 117.129063, latitude: 36.194968 }, { name: "", longitude: 122.116394, latitude: 37.509691 }, { name: "", longitude: 119.461208, latitude: 35.428588 }, { name: "", longitude: 118.326443, latitude: 35.065282 }, { name: "", longitude: 116.307428, latitude: 37.453968 }, { name: "", longitude: 115.980367, latitude: 36.456013 }, { name: "", longitude: 118.016974, latitude: 37.383542 }, { name: "", longitude: 115.469381, latitude: 35.246531 }, { name: "", longitude: 113.665412, latitude: 34.757975 }, { name: "", longitude: 114.341447, latitude: 34.797049 }, { name: "", longitude: 112.434468, latitude: 34.663041 }, { name: "", longitude: 113.307718, latitude: 33.735241 }, { name: "", longitude: 114.352482, latitude: 36.103442 }, { name: "", longitude: 114.295444, latitude: 35.748236 }, { name: "", longitude: 113.883991, latitude: 35.302616 }, { name: "", longitude: 113.238266, latitude: 35.23904 }, { name: "", longitude: 115.041299, latitude: 35.768234 }, { name: "", longitude: 113.826063, latitude: 34.022956 }, { name: "", longitude: 114.026405, latitude: 33.575855 }, { name: "", longitude: 111.194099, latitude: 34.777338 }, { name: "", longitude: 112.540918, latitude: 32.999082 }, { name: "", longitude: 115.650497, latitude: 34.437054 }, { name: "", longitude: 114.075031, latitude: 32.123274 }, { name: "", longitude: 114.649653, latitude: 33.620357 }, { name: "", longitude: 114.024736, latitude: 32.980169 }, { name: "", longitude: 112.590047, latitude: 35.090378 }, { name: "", longitude: 114.298572, latitude: 30.584355 }, { name: "", longitude: 115.077048, latitude: 30.220074 }, { name: "", longitude: 110.787916, latitude: 32.646907 }, { name: "", longitude: 111.290843, latitude: 30.702636 }, { name: "", longitude: 112.144146, latitude: 32.042426 }, { name: "", longitude: 114.890593, latitude: 30.396536 }, { name: "", longitude: 112.204251, latitude: 31.03542 }, { name: "", longitude: 113.926655, latitude: 30.926423 }, { name: "", longitude: 112.23813, latitude: 30.326857 }, { name: "", longitude: 114.879365, latitude: 30.447711 }, { name: "", longitude: 114.328963, latitude: 29.832798 }, { name: "", longitude: 113.37377, latitude: 31.717497 }, { name: "", longitude: 109.48699, latitude: 30.283114 }, { name: "", longitude: 113.453974, latitude: 30.364953 }, { name: "", longitude: 112.896866, latitude: 30.421215 }, { name: "", longitude: 113.165862, latitude: 30.653061 }, { name: "", longitude: 110.671525, latitude: 31.744449 }, { name: "", longitude: 112.982279, latitude: 28.19409 }, { name: "", longitude: 113.151737, latitude: 27.835806 }, { name: "", longitude: 112.944052, latitude: 27.82973 }, { name: "", longitude: 112.607693, latitude: 26.900358 }, { name: "", longitude: 111.46923, latitude: 27.237842 }, { name: "", longitude: 113.132855, latitude: 29.37029 }, { name: "", longitude: 111.691347, latitude: 29.040225 }, { name: "", longitude: 110.479921, latitude: 29.127401 }, { name: "", longitude: 112.355042, latitude: 28.570066 }, { name: "", longitude: 113.032067, latitude: 25.793589 }, { name: "", longitude: 111.608019, latitude: 26.434516 }, { name: "", longitude: 109.97824, latitude: 27.550082 }, { name: "", longitude: 112.008497, latitude: 27.728136 }, { name: "", longitude: 109.739735, latitude: 28.314296 }, { name: "", longitude: 113.280637, latitude: 23.125178 }, { name: "", longitude: 113.591544, latitude: 24.801322 }, { name: "", longitude: 114.085947, latitude: 22.547 }, { name: "", longitude: 113.553986, latitude: 22.224979 }, { name: "", longitude: 116.708463, latitude: 23.37102 }, { name: "", longitude: 113.122717, latitude: 23.028762 }, { name: "", longitude: 113.094942, latitude: 22.590431 }, { name: "", longitude: 110.364977, latitude: 21.274898 }, { name: "", longitude: 110.919229, latitude: 21.659751 }, { name: "", longitude: 112.472529, latitude: 23.051546 }, { name: "", longitude: 114.412599, latitude: 23.079404 }, { name: "", longitude: 116.117582, latitude: 24.299112 }, { name: "", longitude: 115.364238, latitude: 22.774485 }, { name: "", longitude: 114.697802, latitude: 23.746266 }, { name: "", longitude: 111.975107, latitude: 21.859222 }, { name: "", longitude: 113.051227, latitude: 23.685022 }, { name: "", longitude: 113.746262, latitude: 23.046237 }, { name: "", longitude: 113.382391, latitude: 22.521113 }, { name: "", longitude: 116.632301, latitude: 23.661701 }, { name: "", longitude: 116.355733, latitude: 23.543778 }, { name: "", longitude: 112.044439, latitude: 22.929801 }, { name: "", longitude: 108.320004, latitude: 22.82402 }, { name: "", longitude: 109.411703, latitude: 24.314617 }, { name: "", longitude: 110.299121, latitude: 25.274215 }, { name: "", longitude: 111.297604, latitude: 23.474803 }, { name: "", longitude: 109.119254, latitude: 21.473343 }, { name: "", longitude: 108.345478, latitude: 21.614631 }, { name: "", longitude: 108.624175, latitude: 21.967127 }, { name: "", longitude: 109.602146, latitude: 23.0936 }, { name: "", longitude: 110.154393, latitude: 22.63136 }, { name: "", longitude: 106.616285, latitude: 23.897742 }, { name: "", longitude: 111.552056, latitude: 24.414141 }, { name: "", longitude: 108.062105, latitude: 24.695899 }, { name: "", longitude: 109.229772, latitude: 23.733766 }, { name: "", longitude: 107.353926, latitude: 22.404108 }, { name: "", longitude: 110.33119, latitude: 20.031971 }, { name: "", longitude: 109.508268, latitude: 18.247872 }, { name: "", longitude: 112.34882, latitude: 16.831039 }, { name: "", longitude: 109.576782, latitude: 19.517486 }, { name: "", longitude: 109.516662, latitude: 18.776921 }, { name: "", longitude: 110.466785, latitude: 19.246011 }, { name: "", longitude: 110.753975, latitude: 19.612986 }, { name: "", longitude: 110.388793, latitude: 18.796216 }, { name: "", longitude: 108.653789, latitude: 19.10198 }, { name: "", longitude: 110.349235, latitude: 19.684966 }, { name: "", longitude: 110.102773, latitude: 19.362916 }, { name: "", longitude: 110.007147, latitude: 19.737095 }, { name: "", longitude: 109.687697, latitude: 19.908293 }, { name: "", longitude: 109.452606, latitude: 19.224584 }, { name: "", longitude: 109.053351, latitude: 19.260968 }, { name: "", longitude: 109.175444, latitude: 18.74758 }, { name: "", longitude: 110.037218, latitude: 18.505006 }, { name: "", longitude: 109.70245, latitude: 18.636371 }, { name: "", longitude: 109.839996, latitude: 19.03557 }, { name: "", longitude: 106.504962, latitude: 29.533155 }, { name: "", longitude: 104.065735, latitude: 30.659462 }, { name: "", longitude: 104.773447, latitude: 29.352765 }, { name: "", longitude: 101.716007, latitude: 26.580446 }, { name: "", longitude: 105.443348, latitude: 28.889138 }, { name: "", longitude: 104.398651, latitude: 31.127991 }, { name: "", longitude: 104.741722, latitude: 31.46402 }, { name: "", longitude: 105.829757, latitude: 32.433668 }, { name: "", longitude: 105.571331, latitude: 30.513311 }, { name: "", longitude: 105.066138, latitude: 29.58708 }, { name: "", longitude: 103.761263, latitude: 29.582024 }, { name: "", longitude: 106.082974, latitude: 30.795281 }, { name: "", longitude: 103.831788, latitude: 30.048318 }, { name: "", longitude: 104.630825, latitude: 28.760189 }, { name: "", longitude: 106.633369, latitude: 30.456398 }, { name: "", longitude: 107.502262, latitude: 31.209484 }, { name: "", longitude: 103.001033, latitude: 29.987722 }, { name: "", longitude: 106.753669, latitude: 31.858809 }, { name: "", longitude: 104.641917, latitude: 30.122211 }, { name: "", longitude: 102.221374, latitude: 31.899792 }, { name: "", longitude: 101.963815, latitude: 30.050663 }, { name: "", longitude: 102.258746, latitude: 27.886762 }, { name: "", longitude: 106.713478, latitude: 26.578343 }, { name: "", longitude: 104.846743, latitude: 26.584643 }, { name: "", longitude: 106.937265, latitude: 27.706626 }, { name: "", longitude: 105.932188, latitude: 26.245544 }, { name: "", longitude: 105.28501, latitude: 27.301693 }, { name: "", longitude: 109.191555, latitude: 27.718346 }, { name: "", longitude: 104.897971, latitude: 25.08812 }, { name: "", longitude: 107.977488, latitude: 26.583352 }, { name: "", longitude: 107.517156, latitude: 26.258219 }, { name: "", longitude: 102.712251, latitude: 25.040609 }, { name: "", longitude: 103.797851, latitude: 25.501557 }, { name: "", longitude: 102.543907, latitude: 24.350461 }, { name: "", longitude: 99.167133, latitude: 25.111802 }, { name: "", longitude: 103.717216, latitude: 27.336999 }, { name: "", longitude: 100.233026, latitude: 26.872108 }, { name: "", longitude: 100.972344, latitude: 22.777321 }, { name: "", longitude: 100.08697, latitude: 23.886567 }, { name: "", longitude: 101.546046, latitude: 25.041988 }, { name: "", longitude: 103.384182, latitude: 23.366775 }, { name: "", longitude: 104.24401, latitude: 23.36951 }, { name: "", longitude: 100.797941, latitude: 22.001724 }, { name: "", longitude: 100.225668, latitude: 25.589449 }, { name: "", longitude: 98.578363, latitude: 24.436694 }, { name: "", longitude: 98.854304, latitude: 25.850949 }, { name: "", longitude: 99.706463, latitude: 27.826853 }, { name: "", longitude: 91.132212, latitude: 29.660361 }, { name: "", longitude: 88.885148, latitude: 29.267519 }, { name: "", longitude: 97.178452, latitude: 31.136875 }, { name: "", longitude: 94.362348, latitude: 29.654693 }, { name: "", longitude: 91.766529, latitude: 29.236023 }, { name: "", longitude: 92.060214, latitude: 31.476004 }, { name: "", longitude: 80.105498, latitude: 32.503187 }, { name: "", longitude: 108.948024, latitude: 34.263161 }, { name: "", longitude: 108.979608, latitude: 34.916582 }, { name: "", longitude: 107.14487, latitude: 34.369315 }, { name: "", longitude: 108.705117, latitude: 34.333439 }, { name: "", longitude: 109.502882, latitude: 34.499381 }, { name: "", longitude: 109.49081, latitude: 36.596537 }, { name: "", longitude: 107.028621, latitude: 33.077668 }, { name: "", longitude: 109.741193, latitude: 38.290162 }, { name: "", longitude: 109.029273, latitude: 32.6903 }, { name: "", longitude: 109.939776, latitude: 33.868319 }, { name: "", longitude: 103.823557, latitude: 36.058039 }, { name: "", longitude: 98.277304, latitude: 39.786529 }, { name: "", longitude: 102.187888, latitude: 38.514238 }, { name: "", longitude: 104.173606, latitude: 36.54568 }, { name: "", longitude: 105.724998, latitude: 34.578529 }, { name: "", longitude: 102.634697, latitude: 37.929996 }, { name: "", longitude: 100.455472, latitude: 38.932897 }, { name: "", longitude: 106.684691, latitude: 35.54279 }, { name: "", longitude: 98.510795, latitude: 39.744023 }, { name: "", longitude: 107.638372, latitude: 35.734218 }, { name: "", longitude: 104.626294, latitude: 35.579578 }, { name: "", longitude: 104.929379, latitude: 33.388598 }, { name: "", longitude: 103.212006, latitude: 35.599446 }, { name: "", longitude: 102.911008, latitude: 34.986354 }, { name: "", longitude: 101.778916, latitude: 36.623178 }, { name: "", longitude: 102.10327, latitude: 36.502916 }, { name: "", longitude: 100.901059, latitude: 36.959435 }, { name: "", longitude: 102.019988, latitude: 35.517744 }, { name: "", longitude: 100.619542, latitude: 36.280353 }, { name: "", longitude: 100.242143, latitude: 34.4736 }, { name: "", longitude: 97.008522, latitude: 33.004049 }, { name: "", longitude: 97.370785, latitude: 37.374663 }, { name: "", longitude: 106.278179, latitude: 38.46637 }, { name: "", longitude: 106.376173, latitude: 39.01333 }, { name: "", longitude: 106.199409, latitude: 37.986165 }, { name: "", longitude: 106.285241, latitude: 36.004561 }, { name: "", longitude: 105.189568, latitude: 37.514951 }, { name: "", longitude: 87.617733, latitude: 43.792818 }, { name: "", longitude: 84.873946, latitude: 45.595886 }, { name: "", longitude: 89.184078, latitude: 42.947613 }, { name: "", longitude: 93.51316, latitude: 42.833248 }, { name: "", longitude: 87.304012, latitude: 44.014577 }, { name: "", longitude: 82.074778, latitude: 44.903258 }, { name: "", longitude: 86.150969, latitude: 41.768552 }, { name: "", longitude: 80.265068, latitude: 41.170712 }, { name: "", longitude: 76.172825, latitude: 39.713431 }, { name: "", longitude: 75.989138, latitude: 39.467664 }, { name: "", longitude: 79.92533, latitude: 37.110687 }, { name: "", longitude: 81.317946, latitude: 43.92186 }, { name: "", longitude: 82.985732, latitude: 46.746301 }, { name: "", longitude: 88.13963, latitude: 47.848393 }, { name: "", longitude: 86.041075, latitude: 44.305886 }, { name: "", longitude: 81.285884, latitude: 40.541914 }, { name: "", longitude: 79.077978, latitude: 39.867316 }, { name: "", longitude: 87.526884, latitude: 44.167401 }, { name: "", longitude: 87.824932, latitude: 47.353177 }, { name: "", longitude: 85.501218, latitude: 41.827251 }, { name: "", longitude: 82.353656, latitude: 44.840524 }, { name: "", longitude: 80.63579, latitude: 43.6832 }, { name: "", longitude: 79.287372, latitude: 37.207994 }, { name: "", longitude: 84.8275959, latitude: 44.69288853 }, { name: "", longitude: 121.509062, latitude: 25.044332 }, { name: "", longitude: 114.173355, latitude: 22.320048 }, { name: "", longitude: 114.173355, latitude: 22.320048 }, { name: "", longitude: 113.54909, latitude: 22.198951 }, { name: "", longitude: 113.54909, latitude: 22.198951 }], kat = (n) => {
        const t = Lw.findIndex((e) => e.name === n || e.name === `${n}` || Nat(e.name.split("")[0], { toneType: "none", type: "array" }).join("") === n.toLowerCase());
        return t > -1 ? [Lw[t].longitude, Lw[t].latitude] : false;
      };
      class Fat {
        constructor(t) {
          Kt(this, "map");
          Yrt();
          const e = { center: [108.5525, 34.3227], zoom: 5, constrainResolution: false, projection: "EPSG:4326" };
          let i = st(st({}, e), t.view);
          i != null && i.city && (i.center = kat(i.city) || i.center || e.center);
          const r = new La(i);
          this.map = new lw({ target: t.target, view: r, controls: bN(st({ zoom: false, rotate: false, attribution: false }, t.controls)), interactions: LN(st({ doubleClickZoom: false }, t.interactions)) });
        }
      }
      const Tn = (n, t) => n && Object.prototype.hasOwnProperty.call(n, t) ? typeof n[t] == "object" ? Object.keys(n[t]).length > 0 : typeof n[t] == "boolean" ? n[t] : true : false, AF = (n) => {
        if (!n) return { center: [0, 0], coordinates: void 0, minRadius: 0, sqDistances: void 0, topCenter: [0, 0] };
        let t, e, i, r, a;
        Zr(n.getExtent())[1] >= ol(n.getExtent())[1] ? a = Zr(n.getExtent())[1] : a = ol(n.getExtent())[1], r = [(Zr(n.getExtent())[0] + ol(n.getExtent())[0]) / 2, a];
        const s = n.getType();
        if (s === "Polygon") {
          let u = 0, h = 0, c = 0;
          e = n.getCoordinates()[0].slice(1), e.forEach(function(f) {
            u += f[0], h += f[1], c++;
          }), t = [u / c, h / c];
        } else s === "LineString" ? (t = n.getCoordinateAt(0.5), e = n.getCoordinates()) : s === "Circle" ? t = n.getCenter() : t = Br(n.getExtent());
        let l;
        return e ? (l = e.map(function(u) {
          const h = u[0] - t[0], c = u[1] - t[1];
          return h * h + c * c;
        }), i = Math.sqrt(Math.max.apply(Math, l)) / 3) : i = Math.max(ve(n.getExtent()), Cn(n.getExtent())) / 3, { center: t, coordinates: e, minRadius: i, sqDistances: l, topCenter: r };
      }, pF = (n, t) => {
        n.getView().animate(t);
      }, Qat = Object.freeze(Object.defineProperty({ __proto__: null, calculateCenter: AF, flyTo: (n, t) => {
        const e = t.duration || 2e3, i = n.getView(), r = t.zoom || i.getZoom() || 0;
        let a = 2, o = false;
        function s() {
          --a, !o && a === 0 && (o = true);
        }
        i.animate({ center: t.center, duration: e }, s), i.animate({ zoom: t.flyZoom || r - 1, duration: e / 2 }, { zoom: r, duration: e / 2 }, s);
      }, panTo: pF, validObjKey: Tn }, Symbol.toStringTag, { value: "Module" })), Oat = ["id"], Pw = N.defineComponent({ name: "OlMap", __name: "index", props: { width: { default: "100%" }, height: { default: "100%" }, controls: {}, interactions: {}, view: {}, pixelRatio: {}, keyboardEventTarget: {}, layers: {}, maxTilesLoading: {}, moveTolerance: {}, overlays: {}, target: { default: "map" } }, emits: ["load", "changeZoom", "singleclick", "click", "dblclick", "pointerdrag", "contextmenu", "precompose", "postrender", "loadend", "loadstart", "moveend", "movestart"], setup(n, { expose: t, emit: e }) {
        var E;
        const i = n, r = N.computed(() => typeof i.target == "string" ? i.target : i.target.id), a = N.ref(false);
        let o = N.shallowRef();
        const s = N.computed(() => typeof i.width == "number" ? `${i.width}px` : i.width), l = N.computed(() => typeof i.height == "number" ? `${i.height}px` : i.height), u = ["singleclick", "click", "dblclick", "pointerdrag", "contextmenu", "precompose", "postrender", "loadend", "loadstart", "moveend", "movestart"], h = e, c = () => new Promise((I, x) => {
          o.value = new Fat(st({}, i)), o.value.map ? (I("success"), a.value = true, h("load")) : x(new Error("fail"));
        });
        let f = N.ref(""), g = N.ref("");
        const d = (I) => {
          g.value = I;
        }, A = () => {
          var I, x;
          (I = o.value) == null || I.map.on("pointermove", (w) => {
            var S, b, B, T;
            if (g.value) {
              f.value = g.value;
              return;
            }
            if (w.dragging) {
              f.value = "";
              return;
            }
            const C = (S = o.value) == null ? void 0 : S.map.getEventPixel(w.originalEvent);
            if (C) {
              const D = (b = o.value) == null ? void 0 : b.map.hasFeatureAtPixel(C);
              ((T = (B = o.value) == null ? void 0 : B.map) == null ? void 0 : T.getTargetElement()) && (f.value = D ? "pointer" : "");
            }
          }), (x = o.value) == null || x.map.getView().once("change:resolution", () => {
            var w;
            (w = o.value) == null || w.map.once("moveend", (C) => {
              p(C);
            });
          }), u.forEach((w) => {
            var C;
            (C = o.value) == null || C.map.on(w, (S) => {
              var b;
              h(w, S, (b = o.value) == null ? void 0 : b.map);
            });
          });
        }, p = (I) => {
          var w, C, S;
          const x = zt(st({}, I), { zoom: (w = o.value) == null ? void 0 : w.map.getView().getZoom() });
          h("changeZoom", x, (C = o.value) == null ? void 0 : C.map), (S = o.value) == null || S.map.once("moveend", (b) => {
            p(b);
          });
        }, v = () => {
          u.forEach((I) => {
            rl(I);
          });
        }, y = (I) => {
          var w;
          const x = (w = o.value) == null ? void 0 : w.map.getLayers().getArray();
          return x == null ? void 0 : x.find((C) => C.get("id") === I);
        }, m = () => {
          var I;
          return (I = o.value) == null ? void 0 : I.map;
        }, _ = (I) => {
          var x, w;
          (x = o.value) != null && x.map && pF((w = o.value) == null ? void 0 : w.map, I);
        };
        return N.onMounted(() => {
          c().then(() => {
            A();
          });
        }), N.onBeforeUnmount(() => {
          v();
        }), t({ map: (E = o.value) == null ? void 0 : E.map, getMap: m, getLayerById: y, panTo: _, setCursor: d }), N.provide("VMap", o), (I, x) => (N.openBlock(), N.createElementBlock("div", { id: r.value, style: N.normalizeStyle({ width: s.value, height: l.value, cursor: N.unref(f) }) }, [a.value ? N.renderSlot(I.$slots, "default", { key: 0 }) : N.createCommentVNode("", true)], 12, Oat));
      } }), zat = (n) => n.component(Pw.name || "OlMap", Pw), tm = { PRELOAD: "preload", USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError" };
      class vF extends Yc {
        constructor(t) {
          t = t || {};
          const e = Object.assign({}, t), i = t.cacheSize;
          delete t.cacheSize, delete e.preload, delete e.useInterimTilesOnError, super(e), this.on, this.once, this.un, this.cacheSize_ = i, this.setPreload(t.preload !== void 0 ? t.preload : 0), this.setUseInterimTilesOnError(t.useInterimTilesOnError !== void 0 ? t.useInterimTilesOnError : true);
        }
        getCacheSize() {
          return this.cacheSize_;
        }
        getPreload() {
          return this.get(tm.PRELOAD);
        }
        setPreload(t) {
          this.set(tm.PRELOAD, t);
        }
        getUseInterimTilesOnError() {
          return this.get(tm.USE_INTERIM_TILES_ON_ERROR);
        }
        setUseInterimTilesOnError(t) {
          this.set(tm.USE_INTERIM_TILES_ON_ERROR, t);
        }
        getData(t) {
          return super.getData(t);
        }
      }
      function xf(n) {
        return n instanceof Image || n instanceof HTMLCanvasElement || n instanceof HTMLVideoElement || n instanceof ImageBitmap ? n : null;
      }
      function Nw(n) {
        return n instanceof Uint8Array || n instanceof Uint8ClampedArray || n instanceof Float32Array || n instanceof DataView ? n : null;
      }
      const Gat = new Error("disposed");
      let wf = null;
      function Uat(n) {
        wf || (wf = dn(n.width, n.height, void 0, { willReadFrequently: true }));
        const t = wf.canvas, e = n.width;
        t.width !== e && (t.width = e);
        const i = n.height;
        return t.height !== i && (t.height = i), wf.clearRect(0, 0, e, i), wf.drawImage(n, 0, 0), wf.getImageData(0, 0, e, i).data;
      }
      const Vat = [256, 256];
      class QA extends Jx {
        constructor(t) {
          const e = At.IDLE;
          super(t.tileCoord, e, { transition: t.transition, interpolate: t.interpolate }), this.loader_ = t.loader, this.data_ = null, this.error_ = null, this.size_ = t.size || null, this.controller_ = t.controller || null;
        }
        getSize() {
          if (this.size_) return this.size_;
          const t = xf(this.data_);
          return t ? [t.width, t.height] : Vat;
        }
        getData() {
          return this.data_;
        }
        getError() {
          return this.error_;
        }
        load() {
          if (this.state !== At.IDLE && this.state !== At.ERROR) return;
          this.state = At.LOADING, this.changed();
          const t = this;
          this.loader_().then(function(e) {
            t.data_ = e, t.state = At.LOADED, t.changed();
          }).catch(function(e) {
            t.error_ = e, t.state = At.ERROR, t.changed();
          });
        }
        disposeInternal() {
          this.controller_ && (this.controller_.abort(Gat), this.controller_ = null), super.disposeInternal();
        }
      }
      const kw = 0.5, jat = 10, yF = 0.25;
      class Fw {
        constructor(t, e, i, r, a, o) {
          this.sourceProj_ = t, this.targetProj_ = e;
          let s = {};
          const l = Gc(this.targetProj_, this.sourceProj_);
          this.transformInv_ = function(y) {
            const m = y[0] + "/" + y[1];
            return s[m] || (s[m] = l(y)), s[m];
          }, this.maxSourceExtent_ = r, this.errorThresholdSquared_ = a * a, this.triangles_ = [], this.wrapsXInSource_ = false, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!r && !!this.sourceProj_.getExtent() && ve(r) >= ve(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? ve(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? ve(this.targetProj_.getExtent()) : null;
          const u = Zr(i), h = ol(i), c = Nc(i), f = Pc(i), g = this.transformInv_(u), d = this.transformInv_(h), A = this.transformInv_(c), p = this.transformInv_(f), v = jat + (o ? Math.max(0, Math.ceil(Math.log2(Od(i) / (o * o * 256 * 256)))) : 0);
          if (this.addQuad_(u, h, c, f, g, d, A, p, v), this.wrapsXInSource_) {
            let y = 1 / 0;
            this.triangles_.forEach(function(m, _, E) {
              y = Math.min(y, m.source[0][0], m.source[1][0], m.source[2][0]);
            }), this.triangles_.forEach((m) => {
              if (Math.max(m.source[0][0], m.source[1][0], m.source[2][0]) - y > this.sourceWorldWidth_ / 2) {
                const _ = [[m.source[0][0], m.source[0][1]], [m.source[1][0], m.source[1][1]], [m.source[2][0], m.source[2][1]]];
                _[0][0] - y > this.sourceWorldWidth_ / 2 && (_[0][0] -= this.sourceWorldWidth_), _[1][0] - y > this.sourceWorldWidth_ / 2 && (_[1][0] -= this.sourceWorldWidth_), _[2][0] - y > this.sourceWorldWidth_ / 2 && (_[2][0] -= this.sourceWorldWidth_);
                const E = Math.min(_[0][0], _[1][0], _[2][0]);
                Math.max(_[0][0], _[1][0], _[2][0]) - E < this.sourceWorldWidth_ / 2 && (m.source = _);
              }
            });
          }
          s = {};
        }
        addTriangle_(t, e, i, r, a, o) {
          this.triangles_.push({ source: [r, a, o], target: [t, e, i] });
        }
        addQuad_(t, e, i, r, a, o, s, l, u) {
          const h = Vn([a, o, s, l]), c = this.sourceWorldWidth_ ? ve(h) / this.sourceWorldWidth_ : null, f = this.sourceWorldWidth_, g = this.sourceProj_.canWrapX() && c > 0.5 && c < 1;
          let d = false;
          if (u > 0) {
            if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
              const p = Vn([t, e, i, r]);
              d = ve(p) / this.targetWorldWidth_ > yF || d;
            }
            !g && this.sourceProj_.isGlobal() && c && (d = c > yF || d);
          }
          if (!d && this.maxSourceExtent_ && isFinite(h[0]) && isFinite(h[1]) && isFinite(h[2]) && isFinite(h[3]) && !hi(h, this.maxSourceExtent_)) return;
          let A = 0;
          if (!d && (!isFinite(a[0]) || !isFinite(a[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(s[0]) || !isFinite(s[1]) || !isFinite(l[0]) || !isFinite(l[1]))) {
            if (u > 0) d = true;
            else if (A = (!isFinite(a[0]) || !isFinite(a[1]) ? 8 : 0) + (!isFinite(o[0]) || !isFinite(o[1]) ? 4 : 0) + (!isFinite(s[0]) || !isFinite(s[1]) ? 2 : 0) + (!isFinite(l[0]) || !isFinite(l[1]) ? 1 : 0), A != 1 && A != 2 && A != 4 && A != 8) return;
          }
          if (u > 0) {
            if (!d) {
              const p = [(t[0] + i[0]) / 2, (t[1] + i[1]) / 2], v = this.transformInv_(p);
              let y;
              g ? y = (rs(a[0], f) + rs(s[0], f)) / 2 - rs(v[0], f) : y = (a[0] + s[0]) / 2 - v[0];
              const m = (a[1] + s[1]) / 2 - v[1];
              d = y * y + m * m > this.errorThresholdSquared_;
            }
            if (d) {
              if (Math.abs(t[0] - i[0]) <= Math.abs(t[1] - i[1])) {
                const p = [(e[0] + i[0]) / 2, (e[1] + i[1]) / 2], v = this.transformInv_(p), y = [(r[0] + t[0]) / 2, (r[1] + t[1]) / 2], m = this.transformInv_(y);
                this.addQuad_(t, e, p, y, a, o, v, m, u - 1), this.addQuad_(y, p, i, r, m, v, s, l, u - 1);
              } else {
                const p = [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2], v = this.transformInv_(p), y = [(i[0] + r[0]) / 2, (i[1] + r[1]) / 2], m = this.transformInv_(y);
                this.addQuad_(t, p, y, r, a, v, m, l, u - 1), this.addQuad_(p, e, i, y, v, o, s, m, u - 1);
              }
              return;
            }
          }
          if (g) {
            if (!this.canWrapXInSource_) return;
            this.wrapsXInSource_ = true;
          }
          A & 11 || this.addTriangle_(t, i, r, a, s, l), A & 14 || this.addTriangle_(t, i, e, a, s, o), A && (A & 13 || this.addTriangle_(e, r, t, o, l, a), A & 7 || this.addTriangle_(e, r, i, o, l, s));
        }
        calculateSourceExtent() {
          const t = Ii();
          return this.triangles_.forEach(function(e, i, r) {
            const a = e.source;
            Qd(t, a[0]), Qd(t, a[1]), Qd(t, a[2]);
          }), t;
        }
        getTriangles() {
          return this.triangles_;
        }
      }
      let Qw;
      const vs = [];
      function mF(n, t, e, i, r) {
        n.beginPath(), n.moveTo(0, 0), n.lineTo(t, e), n.lineTo(i, r), n.closePath(), n.save(), n.clip(), n.fillRect(0, 0, Math.max(t, i) + 1, Math.max(e, r)), n.restore();
      }
      function Ow(n, t) {
        return Math.abs(n[t * 4] - 210) > 2 || Math.abs(n[t * 4 + 3] - 0.75 * 255) > 2;
      }
      function qat() {
        if (Qw === void 0) {
          const n = dn(6, 6, vs);
          n.globalCompositeOperation = "lighter", n.fillStyle = "rgba(210, 0, 0, 0.75)", mF(n, 4, 5, 4, 0), mF(n, 4, 5, 0, 5);
          const t = n.getImageData(0, 0, 3, 3).data;
          Qw = Ow(t, 0) || Ow(t, 4) || Ow(t, 8), Uc(n), vs.push(n.canvas);
        }
        return Qw;
      }
      function OA(n, t, e, i) {
        const r = as(e, t, n);
        let a = KL(t, i, e);
        const o = t.getMetersPerUnit();
        o !== void 0 && (a *= o);
        const s = n.getMetersPerUnit();
        s !== void 0 && (a /= s);
        const l = n.getExtent();
        if (!l || Wr(l, r)) {
          const u = KL(n, a, r) / a;
          isFinite(u) && u > 0 && (a /= u);
        }
        return a;
      }
      function _F(n, t, e, i) {
        const r = Br(e);
        let a = OA(n, t, r, i);
        return (!isFinite(a) || a <= 0) && WE(e, function(o) {
          return a = OA(n, t, o, i), isFinite(a) && a > 0;
        }), a;
      }
      function zw(n, t, e, i, r, a, o, s, l, u, h, c, f, g) {
        const d = dn(Math.round(e * n), Math.round(e * t), vs);
        if (c || (d.imageSmoothingEnabled = false), l.length === 0) return d.canvas;
        d.scale(e, e);
        function A(E) {
          return Math.round(E * e) / e;
        }
        d.globalCompositeOperation = "lighter";
        const p = Ii();
        l.forEach(function(E, I, x) {
          PL(p, E.extent);
        });
        let v;
        const y = e / i, m = (c ? 1 : 1 + Math.pow(2, -24)) / y;
        if (!f || l.length !== 1 || u !== 0) {
          if (v = dn(Math.round(ve(p) * y), Math.round(Cn(p) * y), vs), c || (v.imageSmoothingEnabled = false), r && g) {
            const E = (r[0] - p[0]) * y, I = -(r[3] - p[3]) * y, x = ve(r) * y, w = Cn(r) * y;
            v.rect(E, I, x, w), v.clip();
          }
          l.forEach(function(E, I, x) {
            if (E.image.width > 0 && E.image.height > 0) {
              if (E.clipExtent) {
                v.save();
                const B = (E.clipExtent[0] - p[0]) * y, T = -(E.clipExtent[3] - p[3]) * y, D = ve(E.clipExtent) * y, R = Cn(E.clipExtent) * y;
                v.rect(c ? B : Math.round(B), c ? T : Math.round(T), c ? D : Math.round(B + D) - Math.round(B), c ? R : Math.round(T + R) - Math.round(T)), v.clip();
              }
              const w = (E.extent[0] - p[0]) * y, C = -(E.extent[3] - p[3]) * y, S = ve(E.extent) * y, b = Cn(E.extent) * y;
              v.drawImage(E.image, u, u, E.image.width - 2 * u, E.image.height - 2 * u, c ? w : Math.round(w), c ? C : Math.round(C), c ? S : Math.round(w + S) - Math.round(w), c ? b : Math.round(C + b) - Math.round(C)), E.clipExtent && v.restore();
            }
          });
        }
        const _ = Zr(o);
        return s.getTriangles().forEach(function(E, I, x) {
          const w = E.source, C = E.target;
          let S = w[0][0], b = w[0][1], B = w[1][0], T = w[1][1], D = w[2][0], R = w[2][1];
          const L = A((C[0][0] - _[0]) / a), k = A(-(C[0][1] - _[1]) / a), P = A((C[1][0] - _[0]) / a), F = A(-(C[1][1] - _[1]) / a), Q = A((C[2][0] - _[0]) / a), z = A(-(C[2][1] - _[1]) / a), j = S, $ = b;
          S = 0, b = 0, B -= j, T -= $, D -= j, R -= $;
          const G = [[B, T, 0, 0, P - L], [D, R, 0, 0, Q - L], [0, 0, B, T, F - k], [0, 0, D, R, z - k]], tt = EZ(G);
          if (!tt) return;
          if (d.save(), d.beginPath(), qat() || !c) {
            d.moveTo(P, F);
            const et = 4, nt = L - P, gt = k - F;
            for (let H = 0; H < et; H++) d.lineTo(P + A((H + 1) * nt / et), F + A(H * gt / (et - 1))), H != et - 1 && d.lineTo(P + A((H + 1) * nt / et), F + A((H + 1) * gt / (et - 1)));
            d.lineTo(Q, z);
          } else d.moveTo(P, F), d.lineTo(L, k), d.lineTo(Q, z);
          d.clip(), d.transform(tt[0], tt[2], tt[1], tt[3], L, k), d.translate(p[0] - j, p[3] - $);
          let J;
          if (v) J = v.canvas, d.scale(m, -m);
          else {
            const et = l[0], nt = et.extent;
            J = et.image, d.scale(ve(nt) / J.width, -Cn(nt) / J.height);
          }
          d.drawImage(J, 0, 0), d.restore();
        }), v && (Uc(v), vs.push(v.canvas)), h && (d.save(), d.globalCompositeOperation = "source-over", d.strokeStyle = "black", d.lineWidth = 1, s.getTriangles().forEach(function(E, I, x) {
          const w = E.target, C = (w[0][0] - _[0]) / a, S = -(w[0][1] - _[1]) / a, b = (w[1][0] - _[0]) / a, B = -(w[1][1] - _[1]) / a, T = (w[2][0] - _[0]) / a, D = -(w[2][1] - _[1]) / a;
          d.beginPath(), d.moveTo(b, B), d.lineTo(C, S), d.lineTo(T, D), d.closePath(), d.stroke();
        }), d.restore()), d.canvas;
      }
      class em extends QA {
        constructor(t) {
          super({ tileCoord: t.tileCoord, loader: () => Promise.resolve(new Uint8ClampedArray(4)), interpolate: t.interpolate, transition: t.transition }), this.pixelRatio_ = t.pixelRatio, this.gutter_ = t.gutter, this.reprojData_ = null, this.reprojError_ = null, this.reprojSize_ = void 0, this.sourceTileGrid_ = t.sourceTileGrid, this.targetTileGrid_ = t.targetTileGrid, this.wrappedTileCoord_ = t.wrappedTileCoord || t.tileCoord, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0;
          const e = t.sourceProj, i = e.getExtent(), r = t.sourceTileGrid.getExtent();
          this.clipExtent_ = e.canWrapX() ? r ? ei(i, r) : i : r;
          const a = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_), o = this.targetTileGrid_.getExtent();
          let s = this.sourceTileGrid_.getExtent();
          const l = o ? ei(a, o) : a;
          if (Od(l) === 0) {
            this.state = At.EMPTY;
            return;
          }
          i && (s ? s = ei(s, i) : s = i);
          const u = this.targetTileGrid_.getResolution(this.wrappedTileCoord_[0]), h = t.targetProj, c = _F(e, h, l, u);
          if (!isFinite(c) || c <= 0) {
            this.state = At.EMPTY;
            return;
          }
          const f = t.errorThreshold !== void 0 ? t.errorThreshold : kw;
          if (this.triangulation_ = new Fw(e, h, l, s, c * f, u), this.triangulation_.getTriangles().length === 0) {
            this.state = At.EMPTY;
            return;
          }
          this.sourceZ_ = this.sourceTileGrid_.getZForResolution(c);
          let g = this.triangulation_.calculateSourceExtent();
          if (s && (e.canWrapX() ? (g[1] = en(g[1], s[1], s[3]), g[3] = en(g[3], s[1], s[3])) : g = ei(g, s)), !Od(g)) this.state = At.EMPTY;
          else {
            let d = 0, A = 0;
            e.canWrapX() && (d = ve(i), A = Math.floor((g[0] - i[0]) / d)), XE(g.slice(), e, true).forEach((v) => {
              const y = this.sourceTileGrid_.getTileRangeForExtentAndZ(v, this.sourceZ_), m = t.getTileFunction;
              for (let _ = y.minX; _ <= y.maxX; _++) for (let E = y.minY; E <= y.maxY; E++) {
                const I = m(this.sourceZ_, _, E, this.pixelRatio_);
                if (I) {
                  const x = A * d;
                  this.sourceTiles_.push({ tile: I, offset: x });
                }
              }
              ++A;
            }), this.sourceTiles_.length === 0 && (this.state = At.EMPTY);
          }
        }
        getSize() {
          return this.reprojSize_;
        }
        getData() {
          return this.reprojData_;
        }
        getError() {
          return this.reprojError_;
        }
        reproject_() {
          const t = [];
          let e = false;
          if (this.sourceTiles_.forEach((d) => {
            var k;
            const A = d.tile;
            if (!A || A.getState() !== At.LOADED) return;
            const p = A.getSize(), v = this.gutter_;
            let y;
            const m = Nw(A.getData());
            m ? y = m : (e = true, y = Uat(xf(A.getData())));
            const _ = [p[0] + 2 * v, p[1] + 2 * v], E = y instanceof Float32Array, I = _[0] * _[1], x = E ? Float32Array : Uint8ClampedArray, w = new x(y.buffer), C = x.BYTES_PER_ELEMENT, S = C * w.length / I, b = w.byteLength / _[1], B = Math.floor(b / C / _[0]), T = I * B;
            let D = w;
            if (w.length !== T) {
              D = new x(T);
              let P = 0, F = 0;
              const Q = _[0] * B;
              for (let z = 0; z < _[1]; ++z) {
                for (let j = 0; j < Q; ++j) D[P++] = w[F + j];
                F += b / C;
              }
            }
            const R = this.sourceTileGrid_.getTileCoordExtent(A.tileCoord);
            R[0] += d.offset, R[2] += d.offset;
            const L = (k = this.clipExtent_) == null ? void 0 : k.slice();
            L && (L[0] += d.offset, L[2] += d.offset), t.push({ extent: R, clipExtent: L, data: new Uint8ClampedArray(D.buffer), dataType: x, bytesPerPixel: S, pixelSize: _ });
          }), this.sourceTiles_.length = 0, t.length === 0) {
            this.state = At.ERROR, this.changed();
            return;
          }
          const i = this.wrappedTileCoord_[0], r = this.targetTileGrid_.getTileSize(i), a = typeof r == "number" ? r : r[0], o = typeof r == "number" ? r : r[1], s = this.targetTileGrid_.getResolution(i), l = this.sourceTileGrid_.getResolution(this.sourceZ_), u = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
          let h, c;
          const f = t[0].bytesPerPixel, g = Math.ceil(f / 3);
          for (let d = g - 1; d >= 0; --d) {
            const A = [];
            for (let E = 0, I = t.length; E < I; ++E) {
              const x = t[E], w = x.data, C = x.pixelSize, S = C[0], b = C[1], B = dn(S, b, vs), T = B.createImageData(S, b), D = T.data;
              let R = d * 3;
              for (let L = 0, k = D.length; L < k; L += 4) D[L] = w[R], D[L + 1] = w[R + 1], D[L + 2] = w[R + 2], D[L + 3] = 255, R += f;
              B.putImageData(T, 0, 0), A.push({ extent: x.extent, clipExtent: x.clipExtent, image: B.canvas });
            }
            const p = zw(a, o, this.pixelRatio_, l, this.sourceTileGrid_.getExtent(), s, u, this.triangulation_, A, this.gutter_, false, false, false);
            for (let E = 0, I = A.length; E < I; ++E) {
              const w = A[E].image.getContext("2d");
              Uc(w), vs.push(w.canvas);
            }
            const v = p.getContext("2d"), y = v.getImageData(0, 0, p.width, p.height);
            Uc(v), vs.push(p), h || (c = new Uint8ClampedArray(f * y.width * y.height), h = new t[0].dataType(c.buffer));
            const m = y.data;
            let _ = d * 3;
            for (let E = 0, I = m.length; E < I; E += 4) m[E + 3] === 255 ? (c[_] = m[E], c[_ + 1] = m[E + 1], c[_ + 2] = m[E + 2]) : (c[_] = 0, c[_ + 1] = 0, c[_ + 2] = 0), _ += f;
          }
          if (e) {
            const d = dn(a, o), A = new ImageData(h, a);
            d.putImageData(A, 0, 0), this.reprojData_ = d.canvas;
          } else this.reprojData_ = h;
          this.reprojSize_ = [Math.round(a * this.pixelRatio_), Math.round(o * this.pixelRatio_)], this.state = At.LOADED, this.changed();
        }
        load() {
          if (this.state !== At.IDLE && this.state !== At.ERROR) return;
          this.state = At.LOADING, this.changed();
          let t = 0;
          this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: e }) => {
            const i = e.getState();
            if (i !== At.IDLE && i !== At.LOADING) return;
            t++;
            const r = ie(e, Nt.CHANGE, () => {
              const a = e.getState();
              (a == At.LOADED || a == At.ERROR || a == At.EMPTY) && (Pe(r), t--, t === 0 && (this.unlistenSources_(), this.reproject_()));
            });
            this.sourcesListenerKeys_.push(r);
          }), t === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: e }) {
            e.getState() == At.IDLE && e.load();
          });
        }
        unlistenSources_() {
          this.sourcesListenerKeys_.forEach(Pe), this.sourcesListenerKeys_ = null;
        }
      }
      class Cf extends Jx {
        constructor(t, e, i, r, a, o, s, l, u, h, c, f) {
          super(a, At.IDLE, f), this.renderEdges_ = c !== void 0 ? c : false, this.pixelRatio_ = s, this.gutter_ = l, this.canvas_ = null, this.sourceTileGrid_ = e, this.targetTileGrid_ = r, this.wrappedTileCoord_ = o || a, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0, this.clipExtent_ = t.canWrapX() ? t.getExtent() : void 0;
          const g = r.getTileCoordExtent(this.wrappedTileCoord_), d = this.targetTileGrid_.getExtent();
          let A = this.sourceTileGrid_.getExtent();
          const p = d ? ei(g, d) : g;
          if (Od(p) === 0) {
            this.state = At.EMPTY;
            return;
          }
          const v = t.getExtent();
          v && (A ? A = ei(A, v) : A = v);
          const y = r.getResolution(this.wrappedTileCoord_[0]), m = _F(t, i, p, y);
          if (!isFinite(m) || m <= 0) {
            this.state = At.EMPTY;
            return;
          }
          const _ = h !== void 0 ? h : kw;
          if (this.triangulation_ = new Fw(t, i, p, A, m * _, y), this.triangulation_.getTriangles().length === 0) {
            this.state = At.EMPTY;
            return;
          }
          this.sourceZ_ = e.getZForResolution(m);
          let E = this.triangulation_.calculateSourceExtent();
          if (A && (t.canWrapX() ? (E[1] = en(E[1], A[1], A[3]), E[3] = en(E[3], A[1], A[3])) : E = ei(E, A)), !Od(E)) this.state = At.EMPTY;
          else {
            let I = 0, x = 0;
            t.canWrapX() && (I = ve(v), x = Math.floor((E[0] - v[0]) / I)), XE(E.slice(), t, true).forEach((C) => {
              const S = e.getTileRangeForExtentAndZ(C, this.sourceZ_);
              for (let b = S.minX; b <= S.maxX; b++) for (let B = S.minY; B <= S.maxY; B++) {
                const T = u(this.sourceZ_, b, B, s);
                if (T) {
                  const D = x * I;
                  this.sourceTiles_.push({ tile: T, offset: D });
                }
              }
              ++x;
            }), this.sourceTiles_.length === 0 && (this.state = At.EMPTY);
          }
        }
        getImage() {
          return this.canvas_;
        }
        reproject_() {
          const t = [];
          if (this.sourceTiles_.forEach((e) => {
            var r;
            const i = e.tile;
            if (i && i.getState() == At.LOADED) {
              const a = this.sourceTileGrid_.getTileCoordExtent(i.tileCoord);
              a[0] += e.offset, a[2] += e.offset;
              const o = (r = this.clipExtent_) == null ? void 0 : r.slice();
              o && (o[0] += e.offset, o[2] += e.offset), t.push({ extent: a, clipExtent: o, image: i.getImage() });
            }
          }), this.sourceTiles_.length = 0, t.length === 0) this.state = At.ERROR;
          else {
            const e = this.wrappedTileCoord_[0], i = this.targetTileGrid_.getTileSize(e), r = typeof i == "number" ? i : i[0], a = typeof i == "number" ? i : i[1], o = this.targetTileGrid_.getResolution(e), s = this.sourceTileGrid_.getResolution(this.sourceZ_), l = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
            this.canvas_ = zw(r, a, this.pixelRatio_, s, this.sourceTileGrid_.getExtent(), o, l, this.triangulation_, t, this.gutter_, this.renderEdges_, this.interpolate), this.state = At.LOADED;
          }
          this.changed();
        }
        load() {
          if (this.state == At.IDLE) {
            this.state = At.LOADING, this.changed();
            let t = 0;
            this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: e }) => {
              const i = e.getState();
              if (i == At.IDLE || i == At.LOADING) {
                t++;
                const r = ie(e, Nt.CHANGE, (a) => {
                  const o = e.getState();
                  (o == At.LOADED || o == At.ERROR || o == At.EMPTY) && (Pe(r), t--, t === 0 && (this.unlistenSources_(), this.reproject_()));
                });
                this.sourcesListenerKeys_.push(r);
              }
            }), t === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: e }, i, r) {
              e.getState() == At.IDLE && e.load();
            });
          }
        }
        unlistenSources_() {
          this.sourcesListenerKeys_.forEach(Pe), this.sourcesListenerKeys_ = null;
        }
        release() {
          this.canvas_ && (Uc(this.canvas_.getContext("2d")), vs.push(this.canvas_), this.canvas_ = null), super.release();
        }
      }
      function Gw(n, t, e, i) {
        return `${n},${QN(t, e, i)}`;
      }
      function Uw(n, t, e) {
        if (!(e in n)) return n[e] = /* @__PURE__ */ new Set([t]), true;
        const i = n[e], r = i.has(t);
        return r || i.add(t), !r;
      }
      function Hat(n, t, e) {
        const i = n[e];
        return i ? i.delete(t) : false;
      }
      function IF(n, t) {
        const e = n.layerStatesArray[n.layerIndex];
        e.extent && (t = ei(t, Ni(e.extent, n.viewState.projection)));
        const i = e.layer.getRenderSource();
        if (!i.getWrapX()) {
          const r = i.getTileGridForProjection(n.viewState.projection).getExtent();
          r && (t = ei(t, r));
        }
        return t;
      }
      class Yat extends y0 {
        constructor(t, e) {
          super(t), e = e || {}, this.extentChanged = true, this.renderComplete = false, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedRevision, this.renderedTiles = [], this.renderedSourceKey_, this.renderedSourceRevision_, this.tempExtent = Ii(), this.tempTileRange_ = new C0(0, 0, 0, 0), this.tempTileCoord_ = af(0, 0, 0);
          const i = e.cacheSize !== void 0 ? e.cacheSize : 512;
          this.tileCache_ = new FN(i), this.renderedProjection_ = void 0, this.maxStaleKeys = i * 0.5;
        }
        getTileCache() {
          return this.tileCache_;
        }
        getOrCreateTile(t, e, i, r) {
          const a = this.tileCache_, s = this.getLayer().getSource(), l = Gw(s.getKey(), t, e, i);
          let u;
          if (a.containsKey(l)) u = a.get(l);
          else {
            if (u = s.getTile(t, e, i, r.pixelRatio, r.viewState.projection), !u) return null;
            a.set(l, u);
          }
          return u;
        }
        getTile(t, e, i, r) {
          const a = this.getOrCreateTile(t, e, i, r);
          return a || null;
        }
        getData(t) {
          const e = this.frameState;
          if (!e) return null;
          const i = this.getLayer(), r = gn(e.pixelToCoordinateTransform, t.slice()), a = i.getExtent();
          if (a && !Wr(a, r)) return null;
          const o = e.viewState, s = i.getRenderSource(), l = s.getTileGridForProjection(o.projection), u = s.getTilePixelRatio(e.pixelRatio);
          for (let h = l.getZForResolution(o.resolution); h >= l.getMinZoom(); --h) {
            const c = l.getTileCoordForCoordAndZ(r, h), f = this.getTile(h, c[1], c[2], e);
            if (!f || f.getState() !== At.LOADED) continue;
            const g = l.getOrigin(h), d = bn(l.getTileSize(h)), A = l.getResolution(h);
            let p;
            if (f instanceof I0 || f instanceof Cf) p = f.getImage();
            else if (f instanceof QA) {
              if (p = xf(f.getData()), !p) continue;
            } else continue;
            const v = Math.floor(u * ((r[0] - g[0]) / A - c[1] * d[0])), y = Math.floor(u * ((g[1] - r[1]) / A - c[2] * d[1])), m = Math.round(u * s.getGutterForProjection(o.projection));
            return this.getImageData(p, v + m, y + m);
          }
          return null;
        }
        prepareFrame(t) {
          this.renderedProjection_ ? t.viewState.projection !== this.renderedProjection_ && (this.tileCache_.clear(), this.renderedProjection_ = t.viewState.projection) : this.renderedProjection_ = t.viewState.projection;
          const e = this.getLayer().getSource();
          if (!e) return false;
          const i = e.getRevision();
          return this.renderedRevision_ ? this.renderedRevision_ !== i && (this.renderedRevision_ = i, this.renderedSourceKey_ === e.getKey() && this.tileCache_.clear()) : this.renderedRevision_ = i, true;
        }
        enqueueTiles(t, e, i, r, a) {
          const o = t.viewState, s = this.getLayer(), l = s.getRenderSource(), u = l.getTileGridForProjection(o.projection), h = Ft(l);
          h in t.wantedTiles || (t.wantedTiles[h] = {});
          const c = t.wantedTiles[h], f = s.getMapInternal(), g = Math.max(i - a, u.getMinZoom(), u.getZForResolution(Math.min(s.getMaxResolution(), f ? f.getView().getResolutionForZoom(Math.max(s.getMinZoom(), 0)) : u.getResolution(0)), l.zDirection));
          for (let d = i; d >= g; --d) {
            const A = u.getTileRangeForExtentAndZ(e, d, this.tempTileRange_), p = u.getResolution(d);
            for (let v = A.minX; v <= A.maxX; ++v) for (let y = A.minY; y <= A.maxY; ++y) {
              const m = this.getTile(d, v, y, t);
              if (!m || !Uw(r, m, d)) continue;
              const E = m.getKey();
              if (c[E] = true, m.getState() === At.IDLE && !t.tileQueue.isKeyQueued(E)) {
                const I = af(d, v, y, this.tempTileCoord_);
                t.tileQueue.enqueue([m, h, u.getTileCoordCenter(I), p]);
              }
            }
          }
        }
        findStaleTile_(t, e) {
          const i = this.tileCache_, r = t[0], a = t[1], o = t[2], s = this.getStaleKeys();
          for (let l = 0; l < s.length; ++l) {
            const u = Gw(s[l], r, a, o);
            if (i.containsKey(u)) {
              const h = i.get(u);
              if (h.getState() === At.LOADED) return h.endTransition(Ft(this)), Uw(e, h, r), true;
            }
          }
          return false;
        }
        findAltTiles_(t, e, i, r) {
          const a = t.getTileRangeForTileCoordAndZ(e, i, this.tempTileRange_);
          if (!a) return false;
          let o = true;
          const s = this.tileCache_, u = this.getLayer().getRenderSource().getKey();
          for (let h = a.minX; h <= a.maxX; ++h) for (let c = a.minY; c <= a.maxY; ++c) {
            const f = Gw(u, i, h, c);
            let g = false;
            if (s.containsKey(f)) {
              const d = s.get(f);
              d.getState() === At.LOADED && (Uw(r, d, i), g = true);
            }
            g || (o = false);
          }
          return o;
        }
        renderFrame(t, e) {
          this.renderComplete = true;
          const i = t.layerStatesArray[t.layerIndex], r = t.viewState, a = r.projection, o = r.resolution, s = r.center, l = t.pixelRatio, u = this.getLayer(), h = u.getSource(), c = h.getRevision(), f = h.getTileGridForProjection(a), g = f.getZForResolution(o, h.zDirection), d = f.getResolution(g), A = h.getKey();
          this.renderedSourceKey_ ? this.renderedSourceKey_ !== A && (this.prependStaleKey(this.renderedSourceKey_), this.renderedSourceKey_ = A) : this.renderedSourceKey_ = A;
          let p = t.extent;
          const v = h.getTilePixelRatio(l);
          this.prepareContainer(t, e);
          const y = this.context.canvas.width, m = this.context.canvas.height, _ = i.extent && Ni(i.extent);
          _ && (p = ei(p, Ni(i.extent)));
          const E = d * y / 2 / v, I = d * m / 2 / v, x = [s[0] - E, s[1] - I, s[0] + E, s[1] + I], w = {};
          this.renderedTiles.length = 0;
          const C = u.getPreload();
          if (t.nextExtent) {
            const Q = f.getZForResolution(r.nextResolution, h.zDirection), z = IF(t, t.nextExtent);
            this.enqueueTiles(t, z, Q, w, C);
          }
          const S = IF(t, p);
          if (this.enqueueTiles(t, S, g, w, 0), C > 0 && setTimeout(() => {
            this.enqueueTiles(t, S, g - 1, w, C - 1);
          }, 0), !(g in w)) return this.container;
          const b = Ft(this), B = t.time;
          for (const Q of w[g]) {
            const z = Q.getState();
            if ((Q instanceof Cf || Q instanceof em) && z === At.EMPTY) continue;
            const j = Q.tileCoord;
            if (z === At.LOADED && Q.getAlpha(b, B) === 1) {
              Q.endTransition(b);
              continue;
            }
            if (this.renderComplete = false, this.findStaleTile_(j, w)) {
              Hat(w, Q, g), t.animate = true;
              continue;
            }
            if (this.findAltTiles_(f, j, g + 1, w)) continue;
            const tt = f.getMinZoom();
            for (let J = g - 1; J >= tt && !this.findAltTiles_(f, j, J, w); --J) ;
          }
          const T = d / o * l / v, D = this.getRenderContext(t);
          Sr(this.tempTransform, y / 2, m / 2, T, T, 0, -y / 2, -m / 2), i.extent && this.clipUnrotated(D, t, _), h.getInterpolate() || (D.imageSmoothingEnabled = false), this.preRender(D, t);
          const R = Object.keys(w).map(Number);
          R.sort(Ma);
          let L;
          const k = [], P = [];
          for (let Q = R.length - 1; Q >= 0; --Q) {
            const z = R[Q], j = h.getTilePixelSize(z, l, a), G = f.getResolution(z) / d, tt = j[0] * G * T, J = j[1] * G * T, et = f.getTileCoordForCoordAndZ(Zr(x), z), nt = f.getTileCoordExtent(et), gt = gn(this.tempTransform, [v * (nt[0] - x[0]) / d, v * (x[3] - nt[3]) / d]), H = v * h.getGutterForProjection(a);
            for (const W of w[z]) {
              if (W.getState() !== At.LOADED) continue;
              const it = W.tileCoord, kt = et[1] - it[1], vt = Math.round(gt[0] - (kt - 1) * tt), St = et[2] - it[2], bt = Math.round(gt[1] - (St - 1) * J), Ee = Math.round(gt[0] - kt * tt), rn = Math.round(gt[1] - St * J), Ie = vt - Ee, fn = bt - rn, an = R.length === 1;
              let wr = false;
              L = [Ee, rn, Ee + Ie, rn, Ee + Ie, rn + fn, Ee, rn + fn];
              for (let Cr = 0, Jo = k.length; Cr < Jo; ++Cr) if (!an && z < P[Cr]) {
                const kn = k[Cr];
                hi([Ee, rn, Ee + Ie, rn + fn], [kn[0], kn[3], kn[4], kn[7]]) && (wr || (D.save(), wr = true), D.beginPath(), D.moveTo(L[0], L[1]), D.lineTo(L[2], L[3]), D.lineTo(L[4], L[5]), D.lineTo(L[6], L[7]), D.moveTo(kn[6], kn[7]), D.lineTo(kn[4], kn[5]), D.lineTo(kn[2], kn[3]), D.lineTo(kn[0], kn[1]), D.clip());
              }
              k.push(L), P.push(z), this.drawTile(W, t, Ee, rn, Ie, fn, H, an), wr && D.restore(), this.renderedTiles.unshift(W), this.updateUsedTiles(t.usedTiles, h, W);
            }
          }
          this.renderedRevision = c, this.renderedResolution = d, this.extentChanged = !this.renderedExtent_ || !al(this.renderedExtent_, x), this.renderedExtent_ = x, this.renderedPixelRatio = l, this.renderedProjection = a, this.postRender(this.context, t), i.extent && D.restore(), D.imageSmoothingEnabled = true;
          const F = (Q, z) => {
            const j = Ft(h), $ = z.wantedTiles[j], G = $ ? Object.keys($).length : 0;
            this.updateCacheSize(G), this.tileCache_.expireCache();
          };
          return t.postRenderFunctions.push(F), this.container;
        }
        updateCacheSize(t) {
          this.tileCache_.highWaterMark = Math.max(this.tileCache_.highWaterMark, t * 2);
        }
        drawTile(t, e, i, r, a, o, s, l) {
          let u;
          if (t instanceof QA) {
            if (u = xf(t.getData()), !u) throw new Error("Rendering array data is not yet supported");
          } else u = this.getTileImage(t);
          if (!u) return;
          const h = this.getRenderContext(e), c = Ft(this), f = e.layerStatesArray[e.layerIndex], g = f.opacity * (l ? t.getAlpha(c, e.time) : 1), d = g !== h.globalAlpha;
          d && (h.save(), h.globalAlpha = g), h.drawImage(u, s, s, u.width - 2 * s, u.height - 2 * s, i, r, a, o), d && h.restore(), g !== f.opacity ? e.animate = true : l && t.endTransition(c);
        }
        getImage() {
          const t = this.context;
          return t ? t.canvas : null;
        }
        getTileImage(t) {
          return t.getImage();
        }
        updateUsedTiles(t, e, i) {
          const r = Ft(e);
          r in t || (t[r] = {}), t[r][i.getKey()] = true;
        }
      }
      class nm extends vF {
        constructor(t) {
          super(t);
        }
        createRenderer() {
          return new Yat(this, { cacheSize: this.getCacheSize() });
        }
      }
      class Wat extends Dc {
        constructor(t) {
          super(), this.tile, this.handleTileChange_ = this.handleTileChange_.bind(this), this.gutter = t.gutter || 0, this.helper = t.helper, this.loaded = false, this.ready = false;
        }
        setTile(t) {
          if (t !== this.tile) if (this.tile && this.tile.removeEventListener(Nt.CHANGE, this.handleTileChange_), this.tile = t, this.loaded = t.getState() === At.LOADED, this.loaded) this.uploadTile();
          else {
            if (t instanceof I0) {
              const e = t.getImage();
              e instanceof Image && !e.crossOrigin && (e.crossOrigin = "anonymous");
            }
            t.addEventListener(Nt.CHANGE, this.handleTileChange_);
          }
        }
        uploadTile() {
          Qt();
        }
        setReady() {
          this.ready = true, this.dispatchEvent(Nt.CHANGE);
        }
        handleTileChange_() {
          this.tile.getState() === At.LOADED && (this.loaded = true, this.uploadTile());
        }
        setHelper(t) {
          this.helper = t, this.helper && this.loaded && this.uploadTile();
        }
        disposeInternal() {
          this.setHelper(null), this.tile.removeEventListener(Nt.CHANGE, this.handleTileChange_);
        }
      }
      const im = 34962, rm = 34963, Xat = 35040, Vw = 35044, jw = 35048, Zat = 5121, Kat = 5123, $at = 5125, EF = 5126, xF = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
      function Jat(n, t) {
        t = Object.assign({ preserveDrawingBuffer: true, antialias: !WZ }, t);
        const e = xF.length;
        for (let i = 0; i < e; ++i) try {
          const r = n.getContext(xF[i], t);
          if (r) return r;
        } catch (r) {
        }
        return null;
      }
      const tot = { STATIC_DRAW: Vw, STREAM_DRAW: Xat, DYNAMIC_DRAW: jw };
      class am {
        constructor(t, e) {
          this.array_ = null, this.type_ = t, he(t === im || t === rm, "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`"), this.usage_ = e !== void 0 ? e : tot.STATIC_DRAW;
        }
        ofSize(t) {
          return this.array_ = new (om(this.type_))(t), this;
        }
        fromArray(t) {
          return this.array_ = om(this.type_).from(t), this;
        }
        fromArrayBuffer(t) {
          return this.array_ = new (om(this.type_))(t), this;
        }
        getType() {
          return this.type_;
        }
        getArray() {
          return this.array_;
        }
        setArray(t) {
          const e = om(this.type_);
          if (!(t instanceof e)) throw new Error(`Expected ${e}`);
          this.array_ = t;
        }
        getUsage() {
          return this.usage_;
        }
        getSize() {
          return this.array_ ? this.array_.length : 0;
        }
      }
      function om(n) {
        switch (n) {
          case im:
            return Float32Array;
          case rm:
            return Uint32Array;
          default:
            return Float32Array;
        }
      }
      function wF(n, t, e) {
        const i = e ? n.LINEAR : n.NEAREST;
        n.bindTexture(n.TEXTURE_2D, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, i), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, i);
      }
      function eot(n, t, e, i) {
        wF(n, t, i), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, e);
      }
      function CF(n, t, e, i, r, a) {
        const o = n.getGL();
        let s, l;
        e instanceof Float32Array ? (s = o.FLOAT, n.getExtension("OES_texture_float"), l = n.getExtension("OES_texture_float_linear") !== null) : (s = o.UNSIGNED_BYTE, l = true), wF(o, t, a && l);
        const u = e.byteLength / i[1];
        let h = 1;
        u % 8 === 0 ? h = 8 : u % 4 === 0 ? h = 4 : u % 2 === 0 && (h = 2);
        let c;
        switch (r) {
          case 1: {
            c = o.LUMINANCE;
            break;
          }
          case 2: {
            c = o.LUMINANCE_ALPHA;
            break;
          }
          case 3: {
            c = o.RGB;
            break;
          }
          case 4: {
            c = o.RGBA;
            break;
          }
          default:
            throw new Error(`Unsupported number of bands: ${r}`);
        }
        const f = o.getParameter(o.UNPACK_ALIGNMENT);
        o.pixelStorei(o.UNPACK_ALIGNMENT, h), o.texImage2D(o.TEXTURE_2D, 0, c, i[0], i[1], 0, c, s, e), o.pixelStorei(o.UNPACK_ALIGNMENT, f);
      }
      let Sf = null;
      function not() {
        Sf = dn(1, 1, void 0, { willReadFrequently: true });
      }
      class iot extends Wat {
        constructor(t) {
          super(t), this.textures = [], this.renderSize_ = bn(t.grid.getTileSize(t.tile.tileCoord[0])), this.bandCount = NaN;
          const e = new am(im, Vw);
          e.fromArray([0, 1, 1, 1, 1, 0, 0, 0]), this.helper.flushBufferData(e), this.coords = e, this.setTile(t.tile);
        }
        setHelper(t) {
          var i;
          const e = (i = this.helper) == null ? void 0 : i.getGL();
          if (e) {
            this.helper.deleteBuffer(this.coords);
            for (let r = 0; r < this.textures.length; ++r) e.deleteTexture(this.textures[r]);
          }
          super.setHelper(t), t && t.flushBufferData(this.coords);
        }
        uploadTile() {
          const t = this.helper, e = t.getGL(), i = this.tile;
          this.textures.length = 0;
          let r;
          i instanceof I0 || i instanceof Cf ? r = i.getImage() : r = i.getData();
          const a = xf(r);
          if (a) {
            const y = e.createTexture();
            this.textures.push(y), this.bandCount = 4, eot(e, y, a, i.interpolate), this.setReady();
            return;
          }
          r = Nw(r);
          const o = i.getSize(), s = [o[0] + 2 * this.gutter, o[1] + 2 * this.gutter], l = r instanceof Float32Array, u = s[0] * s[1], h = l ? Float32Array : Uint8Array, c = h.BYTES_PER_ELEMENT, f = r.byteLength / s[1];
          this.bandCount = Math.floor(f / c / s[0]);
          const g = Math.ceil(this.bandCount / 4);
          if (g === 1) {
            const y = e.createTexture();
            this.textures.push(y), CF(t, y, r, s, this.bandCount, i.interpolate), this.setReady();
            return;
          }
          const d = new Array(g);
          for (let y = 0; y < g; ++y) {
            const m = e.createTexture();
            this.textures.push(m);
            const _ = y < g - 1 ? 4 : (this.bandCount - 1) % 4 + 1;
            d[y] = new h(u * _);
          }
          let A = 0, p = 0;
          const v = s[0] * this.bandCount;
          for (let y = 0; y < s[1]; ++y) {
            for (let m = 0; m < v; ++m) {
              const _ = r[p + m], E = Math.floor(A / this.bandCount), I = m % this.bandCount, x = Math.floor(I / 4), w = d[x], C = w.length / u, S = I % 4;
              w[E * C + S] = _, ++A;
            }
            p += f / c;
          }
          for (let y = 0; y < g; ++y) {
            const m = this.textures[y], _ = d[y], E = _.length / u;
            CF(t, m, _, s, E, i.interpolate);
          }
          this.setReady();
        }
        getImagePixelData_(t, e, i) {
          const r = this.gutter, a = this.renderSize_[0], o = this.renderSize_[1];
          Sf || not(), Sf.clearRect(0, 0, 1, 1);
          const s = t.width, l = t.height, u = s - 2 * r, h = l - 2 * r, c = r + Math.floor(u * (e / a)), f = r + Math.floor(h * (i / o));
          let g;
          try {
            Sf.drawImage(t, c, f, 1, 1, 0, 0, 1, 1), g = Sf.getImageData(0, 0, 1, 1).data;
          } catch (d) {
            return Sf = null, null;
          }
          return g;
        }
        getArrayPixelData_(t, e, i, r) {
          const a = this.gutter, o = this.renderSize_[0], s = this.renderSize_[1], l = e[0], u = e[1], h = l + 2 * a, c = u + 2 * a, f = a + Math.floor(l * (i / o)), g = a + Math.floor(u * (r / s));
          if (t instanceof DataView) {
            const A = t.byteLength / (h * c), p = A * (g * h + f), v = t.buffer.slice(p, p + A);
            return new DataView(v);
          }
          const d = this.bandCount * (g * h + f);
          return t.slice(d, d + this.bandCount);
        }
        getPixelData(t, e) {
          if (!this.loaded) return null;
          if (this.tile instanceof QA) {
            const i = this.tile.getData(), r = Nw(i);
            if (r) {
              const a = this.tile.getSize();
              return this.getArrayPixelData_(r, a, t, e);
            }
            return this.getImagePixelData_(xf(i), t, e);
          }
          return this.getImagePixelData_(this.tile.getImage(), t, e);
        }
      }
      const sm = { LOST: "webglcontextlost", RESTORED: "webglcontextrestored" }, rot = `
  precision mediump float;

  attribute vec2 a_position;
  varying vec2 v_texCoord;
  varying vec2 v_screenCoord;

  uniform vec2 u_screenSize;

  void main() {
    v_texCoord = a_position * 0.5 + 0.5;
    v_screenCoord = v_texCoord * u_screenSize;
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`, aot = `
  precision mediump float;

  uniform sampler2D u_image;
  uniform float u_opacity;

  varying vec2 v_texCoord;

  void main() {
    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
  }
`;
      class SF {
        constructor(t) {
          this.gl_ = t.webGlContext;
          const e = this.gl_;
          this.scaleRatio_ = t.scaleRatio || 1, this.renderTargetTexture_ = e.createTexture(), this.renderTargetTextureSize_ = null, this.frameBuffer_ = e.createFramebuffer(), this.depthBuffer_ = e.createRenderbuffer();
          const i = e.createShader(e.VERTEX_SHADER);
          e.shaderSource(i, t.vertexShader || rot), e.compileShader(i);
          const r = e.createShader(e.FRAGMENT_SHADER);
          e.shaderSource(r, t.fragmentShader || aot), e.compileShader(r), this.renderTargetProgram_ = e.createProgram(), e.attachShader(this.renderTargetProgram_, i), e.attachShader(this.renderTargetProgram_, r), e.linkProgram(this.renderTargetProgram_), this.renderTargetVerticesBuffer_ = e.createBuffer();
          const a = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
          e.bindBuffer(e.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), e.bufferData(e.ARRAY_BUFFER, new Float32Array(a), e.STATIC_DRAW), this.renderTargetAttribLocation_ = e.getAttribLocation(this.renderTargetProgram_, "a_position"), this.renderTargetUniformLocation_ = e.getUniformLocation(this.renderTargetProgram_, "u_screenSize"), this.renderTargetOpacityLocation_ = e.getUniformLocation(this.renderTargetProgram_, "u_opacity"), this.renderTargetTextureLocation_ = e.getUniformLocation(this.renderTargetProgram_, "u_image"), this.uniforms_ = [], t.uniforms && Object.keys(t.uniforms).forEach((o) => {
            this.uniforms_.push({ value: t.uniforms[o], location: e.getUniformLocation(this.renderTargetProgram_, o) });
          });
        }
        getRenderTargetTexture() {
          return this.renderTargetTexture_;
        }
        getGL() {
          return this.gl_;
        }
        init(t) {
          const e = this.getGL(), i = [e.drawingBufferWidth * this.scaleRatio_, e.drawingBufferHeight * this.scaleRatio_];
          if (e.bindFramebuffer(e.FRAMEBUFFER, this.getFrameBuffer()), e.bindRenderbuffer(e.RENDERBUFFER, this.getDepthBuffer()), e.viewport(0, 0, i[0], i[1]), !this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== i[0] || this.renderTargetTextureSize_[1] !== i[1]) {
            this.renderTargetTextureSize_ = i;
            const r = 0, a = e.RGBA, o = 0, s = e.RGBA, l = e.UNSIGNED_BYTE, u = null;
            e.bindTexture(e.TEXTURE_2D, this.renderTargetTexture_), e.texImage2D(e.TEXTURE_2D, r, a, i[0], i[1], o, s, l, u), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.renderTargetTexture_, 0), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, i[0], i[1]), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, this.depthBuffer_);
          }
        }
        apply(t, e, i, r) {
          const a = this.getGL(), o = t.size;
          if (a.bindFramebuffer(a.FRAMEBUFFER, e ? e.getFrameBuffer() : null), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, this.renderTargetTexture_), !e) {
            const l = Ft(a.canvas);
            if (!t.renderTargets[l]) {
              const u = a.getContextAttributes();
              u && u.preserveDrawingBuffer && (a.clearColor(0, 0, 0, 0), a.clearDepth(1), a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)), t.renderTargets[l] = true;
            }
          }
          a.disable(a.DEPTH_TEST), a.enable(a.BLEND), a.blendFunc(a.ONE, a.ONE_MINUS_SRC_ALPHA), a.viewport(0, 0, a.drawingBufferWidth, a.drawingBufferHeight), a.bindBuffer(a.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), a.useProgram(this.renderTargetProgram_), a.enableVertexAttribArray(this.renderTargetAttribLocation_), a.vertexAttribPointer(this.renderTargetAttribLocation_, 2, a.FLOAT, false, 0, 0), a.uniform2f(this.renderTargetUniformLocation_, o[0], o[1]), a.uniform1i(this.renderTargetTextureLocation_, 0);
          const s = t.layerStatesArray[t.layerIndex].opacity;
          a.uniform1f(this.renderTargetOpacityLocation_, s), this.applyUniforms(t), i && i(a, t), a.drawArrays(a.TRIANGLES, 0, 6), r && r(a, t);
        }
        getFrameBuffer() {
          return this.frameBuffer_;
        }
        getDepthBuffer() {
          return this.depthBuffer_;
        }
        applyUniforms(t) {
          const e = this.getGL();
          let i, r = 1;
          this.uniforms_.forEach(function(a) {
            if (i = typeof a.value == "function" ? a.value(t) : a.value, i instanceof HTMLCanvasElement || i instanceof ImageData) a.texture || (a.texture = e.createTexture()), e.activeTexture(e[`TEXTURE${r}`]), e.bindTexture(e.TEXTURE_2D, a.texture), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), i instanceof ImageData ? e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, i.width, i.height, 0, e.UNSIGNED_BYTE, new Uint8Array(i.data)) : e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, i), e.uniform1i(a.location, r++);
            else if (Array.isArray(i)) switch (i.length) {
              case 2:
                e.uniform2f(a.location, i[0], i[1]);
                return;
              case 3:
                e.uniform3f(a.location, i[0], i[1], i[2]);
                return;
              case 4:
                e.uniform4f(a.location, i[0], i[1], i[2], i[3]);
                return;
              default:
                return;
            }
            else typeof i == "number" && e.uniform1f(a.location, i);
          });
        }
      }
      function bF() {
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }
      function BF(n, t) {
        return n[0] = t[0], n[1] = t[1], n[4] = t[2], n[5] = t[3], n[12] = t[4], n[13] = t[5], n;
      }
      const ys = { PROJECTION_MATRIX: "u_projectionMatrix", SCREEN_TO_WORLD_MATRIX: "u_screenToWorldMatrix", TIME: "u_time", ZOOM: "u_zoom", RESOLUTION: "u_resolution", ROTATION: "u_rotation", VIEWPORT_SIZE_PX: "u_viewportSizePx", PIXEL_RATIO: "u_pixelRatio", HIT_DETECTION: "u_hitDetection" }, Ao = { UNSIGNED_BYTE: Zat, UNSIGNED_SHORT: Kat, UNSIGNED_INT: $at, FLOAT: EF }, lm = {};
      function TF(n) {
        return "shared/" + n;
      }
      let MF = 0;
      function oot() {
        const n = "unique/" + MF;
        return MF += 1, n;
      }
      function sot(n) {
        let t = lm[n];
        if (!t) {
          const e = document.createElement("canvas");
          e.width = 1, e.height = 1, e.style.position = "absolute", e.style.left = "0", t = { users: 0, context: Jat(e) }, lm[n] = t;
        }
        return t.users += 1, t.context;
      }
      function lot(n) {
        const t = lm[n];
        if (!t || (t.users -= 1, t.users > 0)) return;
        const e = t.context, i = e.getExtension("WEBGL_lose_context");
        i && i.loseContext();
        const r = e.canvas;
        r.width = 1, r.height = 1, delete lm[n];
      }
      class uot extends nl {
        constructor(t) {
          super(), t = t || {}, this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this), this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(this), this.canvasCacheKey_ = t.canvasCacheKey ? TF(t.canvasCacheKey) : oot(), this.gl_ = sot(this.canvasCacheKey_), this.bufferCache_ = {}, this.extensionCache_ = {}, this.currentProgram_ = null, this.needsToBeRecreated_ = false;
          const e = this.gl_.canvas;
          e.addEventListener(sm.LOST, this.boundHandleWebGLContextLost_), e.addEventListener(sm.RESTORED, this.boundHandleWebGLContextRestored_), this.offsetRotateMatrix_ = wn(), this.offsetScaleMatrix_ = wn(), this.tmpMat4_ = bF(), this.uniformLocationsByProgram_ = {}, this.attribLocationsByProgram_ = {}, this.uniforms_ = [], t.uniforms && this.setUniforms(t.uniforms), this.postProcessPasses_ = t.postProcesses ? t.postProcesses.map((i) => new SF({ webGlContext: this.gl_, scaleRatio: i.scaleRatio, vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, uniforms: i.uniforms })) : [new SF({ webGlContext: this.gl_ })], this.shaderCompileErrors_ = null, this.startTime_ = Date.now();
        }
        setUniforms(t) {
          this.uniforms_ = [], this.addUniforms(t);
        }
        addUniforms(t) {
          for (const e in t) this.uniforms_.push({ name: e, value: t[e] });
        }
        canvasCacheKeyMatches(t) {
          return this.canvasCacheKey_ === TF(t);
        }
        getExtension(t) {
          if (t in this.extensionCache_) return this.extensionCache_[t];
          const e = this.gl_.getExtension(t);
          return this.extensionCache_[t] = e, e;
        }
        bindBuffer(t) {
          const e = this.gl_, i = Ft(t);
          let r = this.bufferCache_[i];
          if (!r) {
            const a = e.createBuffer();
            r = { buffer: t, webGlBuffer: a }, this.bufferCache_[i] = r;
          }
          e.bindBuffer(t.getType(), r.webGlBuffer);
        }
        flushBufferData(t) {
          const e = this.gl_;
          this.bindBuffer(t), e.bufferData(t.getType(), t.getArray(), t.getUsage());
        }
        deleteBuffer(t) {
          const e = Ft(t);
          delete this.bufferCache_[e];
        }
        disposeInternal() {
          const t = this.gl_.canvas;
          t.removeEventListener(sm.LOST, this.boundHandleWebGLContextLost_), t.removeEventListener(sm.RESTORED, this.boundHandleWebGLContextRestored_), lot(this.canvasCacheKey_), delete this.gl_;
        }
        prepareDraw(t, e, i) {
          const r = this.gl_, a = this.getCanvas(), o = t.size, s = t.pixelRatio;
          (a.width !== o[0] * s || a.height !== o[1] * s) && (a.width = o[0] * s, a.height = o[1] * s, a.style.width = o[0] + "px", a.style.height = o[1] + "px");
          for (let l = this.postProcessPasses_.length - 1; l >= 0; l--) this.postProcessPasses_[l].init(t);
          r.bindTexture(r.TEXTURE_2D, null), r.clearColor(0, 0, 0, 0), r.depthRange(0, 1), r.clearDepth(1), r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT), r.enable(r.BLEND), r.blendFunc(r.ONE, e ? r.ZERO : r.ONE_MINUS_SRC_ALPHA), i ? (r.enable(r.DEPTH_TEST), r.depthFunc(r.LEQUAL)) : r.disable(r.DEPTH_TEST);
        }
        bindFrameBuffer(t, e) {
          const i = this.getGL();
          i.bindFramebuffer(i.FRAMEBUFFER, t), e && i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0);
        }
        bindInitialFrameBuffer() {
          const t = this.getGL(), e = this.postProcessPasses_[0].getFrameBuffer();
          t.bindFramebuffer(t.FRAMEBUFFER, e);
          const i = this.postProcessPasses_[0].getRenderTargetTexture();
          t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, i, 0);
        }
        bindTexture(t, e, i) {
          const r = this.gl_;
          r.activeTexture(r.TEXTURE0 + e), r.bindTexture(r.TEXTURE_2D, t), r.uniform1i(this.getUniformLocation(i), e);
        }
        bindAttribute(t, e, i) {
          const r = this.getGL();
          this.bindBuffer(t);
          const a = this.getAttributeLocation(e);
          r.enableVertexAttribArray(a), r.vertexAttribPointer(a, i, r.FLOAT, false, 0, 0);
        }
        prepareDrawToRenderTarget(t, e, i, r) {
          const a = this.gl_, o = e.getSize();
          a.bindFramebuffer(a.FRAMEBUFFER, e.getFramebuffer()), a.bindRenderbuffer(a.RENDERBUFFER, e.getDepthbuffer()), a.viewport(0, 0, o[0], o[1]), a.bindTexture(a.TEXTURE_2D, e.getTexture()), a.clearColor(0, 0, 0, 0), a.depthRange(0, 1), a.clearDepth(1), a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT), a.enable(a.BLEND), a.blendFunc(a.ONE, i ? a.ZERO : a.ONE_MINUS_SRC_ALPHA), r ? (a.enable(a.DEPTH_TEST), a.depthFunc(a.LEQUAL)) : a.disable(a.DEPTH_TEST);
        }
        drawElements(t, e) {
          const i = this.gl_;
          this.getExtension("OES_element_index_uint");
          const r = i.UNSIGNED_INT, a = 4, o = e - t, s = t * a;
          i.drawElements(i.TRIANGLES, o, r, s);
        }
        finalizeDraw(t, e, i) {
          for (let r = 0, a = this.postProcessPasses_.length; r < a; r++) r === a - 1 ? this.postProcessPasses_[r].apply(t, null, e, i) : this.postProcessPasses_[r].apply(t, this.postProcessPasses_[r + 1]);
        }
        getCanvas() {
          return this.gl_.canvas;
        }
        getGL() {
          return this.gl_;
        }
        applyFrameState(t) {
          const e = t.size, i = t.viewState.rotation, r = t.pixelRatio;
          this.setUniformFloatValue(ys.TIME, (Date.now() - this.startTime_) * 1e-3), this.setUniformFloatValue(ys.ZOOM, t.viewState.zoom), this.setUniformFloatValue(ys.RESOLUTION, t.viewState.resolution), this.setUniformFloatValue(ys.PIXEL_RATIO, r), this.setUniformFloatVec2(ys.VIEWPORT_SIZE_PX, [e[0], e[1]]), this.setUniformFloatValue(ys.ROTATION, i);
        }
        applyHitDetectionUniform(t) {
          const e = this.getUniformLocation(ys.HIT_DETECTION);
          this.getGL().uniform1i(e, t ? 1 : 0), t && this.setUniformFloatValue(ys.PIXEL_RATIO, 0.5);
        }
        applyUniforms(t) {
          const e = this.gl_;
          let i, r = 0;
          this.uniforms_.forEach((a) => {
            if (i = typeof a.value == "function" ? a.value(t) : a.value, i instanceof HTMLCanvasElement || i instanceof HTMLImageElement || i instanceof ImageData || i instanceof WebGLTexture) {
              i instanceof WebGLTexture && !a.texture ? (a.prevValue = void 0, a.texture = i) : a.texture || (a.prevValue = void 0, a.texture = e.createTexture()), this.bindTexture(a.texture, r, a.name), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE);
              const o = !(i instanceof HTMLImageElement) || i.complete;
              !(i instanceof WebGLTexture) && o && a.prevValue !== i && (a.prevValue = i, e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, i)), r++;
            } else if (Array.isArray(i) && i.length === 6) this.setUniformMatrixValue(a.name, BF(this.tmpMat4_, i));
            else if (Array.isArray(i) && i.length <= 4) switch (i.length) {
              case 2:
                e.uniform2f(this.getUniformLocation(a.name), i[0], i[1]);
                return;
              case 3:
                e.uniform3f(this.getUniformLocation(a.name), i[0], i[1], i[2]);
                return;
              case 4:
                e.uniform4f(this.getUniformLocation(a.name), i[0], i[1], i[2], i[3]);
                return;
              default:
                return;
            }
            else typeof i == "number" && e.uniform1f(this.getUniformLocation(a.name), i);
          });
        }
        useProgram(t, e) {
          this.gl_.useProgram(t), this.currentProgram_ = t, e && (this.applyFrameState(e), this.applyUniforms(e));
        }
        compileShader(t, e) {
          const i = this.gl_, r = i.createShader(e);
          return i.shaderSource(r, t), i.compileShader(r), r;
        }
        getProgram(t, e) {
          const i = this.gl_, r = this.compileShader(t, i.FRAGMENT_SHADER), a = this.compileShader(e, i.VERTEX_SHADER), o = i.createProgram();
          if (i.attachShader(o, r), i.attachShader(o, a), i.linkProgram(o), !i.getShaderParameter(r, i.COMPILE_STATUS)) {
            const s = `Fragment shader compilation failed: ${i.getShaderInfoLog(r)}`;
            throw new Error(s);
          }
          if (i.deleteShader(r), !i.getShaderParameter(a, i.COMPILE_STATUS)) {
            const s = `Vertex shader compilation failed: ${i.getShaderInfoLog(a)}`;
            throw new Error(s);
          }
          if (i.deleteShader(a), !i.getProgramParameter(o, i.LINK_STATUS)) {
            const s = `GL program linking failed: ${i.getProgramInfoLog(o)}`;
            throw new Error(s);
          }
          return o;
        }
        getUniformLocation(t) {
          const e = Ft(this.currentProgram_);
          return this.uniformLocationsByProgram_[e] === void 0 && (this.uniformLocationsByProgram_[e] = {}), this.uniformLocationsByProgram_[e][t] === void 0 && (this.uniformLocationsByProgram_[e][t] = this.gl_.getUniformLocation(this.currentProgram_, t)), this.uniformLocationsByProgram_[e][t];
        }
        getAttributeLocation(t) {
          const e = Ft(this.currentProgram_);
          return this.attribLocationsByProgram_[e] === void 0 && (this.attribLocationsByProgram_[e] = {}), this.attribLocationsByProgram_[e][t] === void 0 && (this.attribLocationsByProgram_[e][t] = this.gl_.getAttribLocation(this.currentProgram_, t)), this.attribLocationsByProgram_[e][t];
        }
        makeProjectionTransform(t, e) {
          const i = t.size, r = t.viewState.rotation, a = t.viewState.resolution, o = t.viewState.center;
          return Sr(e, 0, 0, 2 / (a * i[0]), 2 / (a * i[1]), -r, -o[0], -o[1]), e;
        }
        setUniformFloatValue(t, e) {
          this.gl_.uniform1f(this.getUniformLocation(t), e);
        }
        setUniformFloatVec2(t, e) {
          this.gl_.uniform2fv(this.getUniformLocation(t), e);
        }
        setUniformFloatVec4(t, e) {
          this.gl_.uniform4fv(this.getUniformLocation(t), e);
        }
        setUniformMatrixValue(t, e) {
          this.gl_.uniformMatrix4fv(this.getUniformLocation(t), false, e);
        }
        enableAttributeArray_(t, e, i, r, a) {
          const o = this.getAttributeLocation(t);
          o < 0 || (this.gl_.enableVertexAttribArray(o), this.gl_.vertexAttribPointer(o, e, i, false, r, a));
        }
        enableAttributes(t) {
          const e = hot(t);
          let i = 0;
          for (let r = 0; r < t.length; r++) {
            const a = t[r];
            this.enableAttributeArray_(a.name, a.size, a.type || EF, e, i), i += a.size * DF(a.type);
          }
        }
        handleWebGLContextLost(t) {
          Mc(this.bufferCache_), this.currentProgram_ = null, t.preventDefault();
        }
        handleWebGLContextRestored() {
          this.needsToBeRecreated_ = true;
        }
        needsToBeRecreated() {
          return this.needsToBeRecreated_;
        }
        createTexture(t, e, i, r) {
          const a = this.gl_;
          i = i || a.createTexture();
          const o = r ? a.NEAREST : a.LINEAR;
          a.bindTexture(a.TEXTURE_2D, i), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, o), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, o), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);
          const s = 0, l = a.RGBA, u = 0, h = a.RGBA, c = a.UNSIGNED_BYTE;
          return e instanceof Uint8Array ? a.texImage2D(a.TEXTURE_2D, s, l, t[0], t[1], u, h, c, e) : e ? a.texImage2D(a.TEXTURE_2D, s, l, h, c, e) : a.texImage2D(a.TEXTURE_2D, s, l, t[0], t[1], u, h, c, null), i;
        }
      }
      function hot(n) {
        let t = 0;
        for (let e = 0; e < n.length; e++) {
          const i = n[e];
          t += i.size * DF(i.type);
        }
        return t;
      }
      function DF(n) {
        switch (n) {
          case Ao.UNSIGNED_BYTE:
            return Uint8Array.BYTES_PER_ELEMENT;
          case Ao.UNSIGNED_SHORT:
            return Uint16Array.BYTES_PER_ELEMENT;
          case Ao.UNSIGNED_INT:
            return Uint32Array.BYTES_PER_ELEMENT;
          case Ao.FLOAT:
          default:
            return Float32Array.BYTES_PER_ELEMENT;
        }
      }
      class um extends fN {
        constructor(t, e) {
          super(t), e = e || {}, this.inversePixelTransform_ = wn(), this.postProcesses_ = e.postProcesses, this.uniforms_ = e.uniforms, this.helper, this.onMapChanged_ = () => {
            this.clearCache(), this.removeHelper();
          }, t.addChangeListener(ke.MAP, this.onMapChanged_), this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this), this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);
        }
        dispatchPreComposeEvent(t, e) {
          const i = this.getLayer();
          if (i.hasListener(ni.PRECOMPOSE)) {
            const r = new dA(ni.PRECOMPOSE, void 0, e, t);
            i.dispatchEvent(r);
          }
        }
        dispatchPostComposeEvent(t, e) {
          const i = this.getLayer();
          if (i.hasListener(ni.POSTCOMPOSE)) {
            const r = new dA(ni.POSTCOMPOSE, void 0, e, t);
            i.dispatchEvent(r);
          }
        }
        reset(t) {
          this.uniforms_ = t.uniforms, this.helper && this.helper.setUniforms(this.uniforms_);
        }
        removeHelper() {
          this.helper && (this.helper.dispose(), delete this.helper);
        }
        prepareFrame(t) {
          if (this.getLayer().getRenderSource()) {
            let e = true, i = -1, r;
            for (let o = 0, s = t.layerStatesArray.length; o < s; o++) {
              const l = t.layerStatesArray[o].layer, u = l.getRenderer();
              if (!(u instanceof um)) {
                e = true;
                continue;
              }
              const h = l.getClassName();
              if ((e || h !== r) && (i += 1, e = false), r = h, u === this) break;
            }
            const a = "map/" + t.mapId + "/group/" + i;
            (!this.helper || !this.helper.canvasCacheKeyMatches(a) || this.helper.needsToBeRecreated()) && (this.removeHelper(), this.helper = new uot({ postProcesses: this.postProcesses_, uniforms: this.uniforms_, canvasCacheKey: a }), r && (this.helper.getCanvas().className = r), this.afterHelperCreated());
          }
          return this.prepareFrameInternal(t);
        }
        afterHelperCreated() {
        }
        prepareFrameInternal(t) {
          return true;
        }
        clearCache() {
        }
        disposeInternal() {
          var t;
          this.clearCache(), this.removeHelper(), (t = this.getLayer()) == null || t.removeChangeListener(ke.MAP, this.onMapChanged_), super.disposeInternal();
        }
        dispatchRenderEvent_(t, e, i) {
          const r = this.getLayer();
          if (r.hasListener(t)) {
            Sr(this.inversePixelTransform_, 0, 0, i.pixelRatio, -i.pixelRatio, 0, 0, -i.size[1]);
            const a = new dA(t, this.inversePixelTransform_, i, e);
            r.dispatchEvent(a);
          }
        }
        preRender(t, e) {
          this.dispatchRenderEvent_(ni.PRERENDER, t, e);
        }
        postRender(t, e) {
          this.dispatchRenderEvent_(ni.POSTRENDER, t, e);
        }
      }
      const cot = { TILE_TRANSFORM: "u_tileTransform", TRANSITION_ALPHA: "u_transitionAlpha", DEPTH: "u_depth", RENDER_EXTENT: "u_renderExtent", PATTERN_ORIGIN: "u_patternOrigin", RESOLUTION: "u_resolution", ZOOM: "u_zoom", GLOBAL_ALPHA: "u_globalAlpha", PROJECTION_MATRIX: "u_projectionMatrix", SCREEN_TO_WORLD_MATRIX: "u_screenToWorldMatrix" };
      function RF(n) {
        return 1 / (n + 2);
      }
      function fot() {
        return { tileIds: /* @__PURE__ */ new Set(), representationsByZ: {} };
      }
      function LF(n, t) {
        return n.tileIds.has(Ft(t));
      }
      function PF(n, t, e) {
        const i = n.representationsByZ;
        e in i || (i[e] = /* @__PURE__ */ new Set()), i[e].add(t), n.tileIds.add(Ft(t.tile));
      }
      function qw(n, t) {
        const e = n.layerStatesArray[n.layerIndex];
        e.extent && (t = ei(t, Ni(e.extent, n.viewState.projection)));
        const i = e.layer.getRenderSource();
        if (!i.getWrapX()) {
          const r = i.getTileGridForProjection(n.viewState.projection).getExtent();
          r && (t = ei(t, r));
        }
        return t;
      }
      function Hw(n, t) {
        return `${n.getKey()},${of(t)}`;
      }
      class got extends um {
        constructor(t, e) {
          super(t, { uniforms: e.uniforms, postProcesses: e.postProcesses }), this.renderComplete = false, this.tileTransform_ = wn(), this.tempMat4 = bF(), this.tempTileRange_ = new C0(0, 0, 0, 0), this.tempTileCoord_ = af(0, 0, 0), this.tempSize_ = [0, 0];
          const i = e.cacheSize !== void 0 ? e.cacheSize : 512;
          this.tileRepresentationCache = new FN(i), this.frameState = null, this.renderedProjection_ = void 0;
        }
        reset(t) {
          super.reset({ uniforms: t.uniforms });
        }
        prepareFrameInternal(t) {
          this.renderedProjection_ ? t.viewState.projection !== this.renderedProjection_ && (this.clearCache(), this.renderedProjection_ = t.viewState.projection) : this.renderedProjection_ = t.viewState.projection;
          const i = this.getLayer().getRenderSource();
          return !i || ns(qw(t, t.extent)) ? false : i.getState() === "ready";
        }
        createTileRepresentation(t) {
          return Qt();
        }
        enqueueTiles(t, e, i, r, a) {
          const o = t.viewState, s = this.getLayer(), l = s.getRenderSource(), u = l.getTileGridForProjection(o.projection), h = l.getGutterForProjection(o.projection), c = Ft(l);
          c in t.wantedTiles || (t.wantedTiles[c] = {});
          const f = t.wantedTiles[c], g = this.tileRepresentationCache, d = s.getMapInternal(), A = Math.max(i - a, u.getMinZoom(), u.getZForResolution(Math.min(s.getMaxResolution(), d ? d.getView().getResolutionForZoom(Math.max(s.getMinZoom(), 0)) : u.getResolution(0)), l.zDirection));
          for (let p = i; p >= A; --p) {
            const v = u.getTileRangeForExtentAndZ(e, p, this.tempTileRange_), y = u.getResolution(p);
            for (let m = v.minX; m <= v.maxX; ++m) for (let _ = v.minY; _ <= v.maxY; ++_) {
              const E = af(p, m, _, this.tempTileCoord_), I = Hw(l, E);
              let x, w;
              if (g.containsKey(I) && (x = g.get(I), w = x.tile), (!x || x.tile.key !== l.getKey()) && (w = l.getTile(p, m, _, t.pixelRatio, o.projection), !w) || LF(r, w)) continue;
              x ? x.setTile(w) : (x = this.createTileRepresentation({ tile: w, grid: u, helper: this.helper, gutter: h }), g.set(I, x)), PF(r, x, p);
              const C = w.getKey();
              f[C] = true, w.getState() === At.IDLE && (t.tileQueue.isKeyQueued(C) || t.tileQueue.enqueue([w, c, u.getTileCoordCenter(E), y]));
            }
          }
        }
        beforeTilesRender(t, e) {
          this.helper.prepareDraw(this.frameState, !e, true);
        }
        beforeTilesMaskRender(t) {
          return false;
        }
        renderTile(t, e, i, r, a, o, s, l, u, h, c) {
        }
        renderTileMask(t, e, i, r) {
        }
        drawTile_(t, e, i, r, a, o, s) {
          if (!e.ready) return;
          const u = e.tile.tileCoord, h = of(u), c = h in o ? o[h] : 1, f = s.getResolution(i), g = bn(s.getTileSize(i), this.tempSize_), d = s.getOrigin(i), A = s.getTileCoordExtent(u), p = c < 1 ? -1 : RF(i);
          c < 1 && (t.animate = true);
          const v = t.viewState, y = v.center[0], m = v.center[1], _ = g[0] + 2 * r, E = g[1] + 2 * r, I = _ / E, x = (y - d[0]) / (g[0] * f), w = (d[1] - m) / (g[1] * f), C = v.resolution / f, S = u[1], b = u[2];
          tZ(this.tileTransform_), TL(this.tileTransform_, 2 / (t.size[0] * C / _), -2 / (t.size[1] * C / _)), nZ(this.tileTransform_, v.rotation), TL(this.tileTransform_, 1, 1 / I), ML(this.tileTransform_, (g[0] * (S - x) - r) / _, (g[1] * (b - w) - r) / E), this.renderTile(e, this.tileTransform_, t, a, f, g, d, A, p, r, c);
        }
        renderFrame(t) {
          this.frameState = t, this.renderComplete = true;
          const e = this.helper.getGL();
          this.preRender(e, t);
          const i = t.viewState, r = this.getLayer(), a = r.getRenderSource(), o = a.getTileGridForProjection(i.projection), s = a.getGutterForProjection(i.projection), l = qw(t, t.extent), u = o.getZForResolution(i.resolution, a.zDirection), h = fot(), c = r.getPreload();
          if (t.nextExtent) {
            const E = o.getZForResolution(i.nextResolution, a.zDirection), I = qw(t, t.nextExtent);
            this.enqueueTiles(t, I, E, h, c);
          }
          this.enqueueTiles(t, l, u, h, 0), c > 0 && setTimeout(() => {
            this.enqueueTiles(t, l, u - 1, h, c - 1);
          }, 0);
          const f = {}, g = Ft(this), d = t.time;
          let A = false;
          const p = h.representationsByZ;
          if (u in p) for (const E of p[u]) {
            const I = E.tile;
            if ((I instanceof Cf || I instanceof em) && I.getState() === At.EMPTY) continue;
            const x = I.tileCoord;
            if (E.ready) {
              const S = I.getAlpha(g, d);
              if (S === 1) {
                I.endTransition(g);
                continue;
              }
              A = true;
              const b = of(x);
              f[b] = S;
            }
            if (this.renderComplete = false, this.findAltTiles_(o, x, u + 1, h)) continue;
            const C = o.getMinZoom();
            for (let S = u - 1; S >= C && !this.findAltTiles_(o, x, S, h); --S) ;
          }
          const v = Object.keys(p).map(Number).sort(Pd);
          if (this.beforeTilesMaskRender(t)) for (let E = 0, I = v.length; E < I; ++E) {
            const x = v[E];
            for (const w of p[x]) {
              const C = w.tile.tileCoord;
              if (of(C) in f) continue;
              const b = o.getTileCoordExtent(C);
              this.renderTileMask(w, x, b, RF(x));
            }
          }
          this.beforeTilesRender(t, A);
          for (let E = 0, I = v.length; E < I; ++E) {
            const x = v[E];
            for (const w of p[x]) {
              const C = w.tile.tileCoord;
              of(C) in f || this.drawTile_(t, w, x, s, l, f, o);
            }
          }
          if (u in p) for (const E of p[u]) {
            const I = E.tile.tileCoord;
            of(I) in f && this.drawTile_(t, E, u, s, l, f, o);
          }
          this.beforeFinalize(t), this.helper.finalizeDraw(t, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
          const m = this.helper.getCanvas(), _ = this.tileRepresentationCache;
          for (; _.canExpireCache(); ) _.pop().dispose();
          return this.postRender(e, t), m;
        }
        beforeFinalize(t) {
        }
        findAltTiles_(t, e, i, r) {
          const a = t.getTileRangeForTileCoordAndZ(e, i, this.tempTileRange_);
          if (!a) return false;
          let o = true;
          const s = this.tileRepresentationCache, l = this.getLayer().getRenderSource();
          for (let u = a.minX; u <= a.maxX; ++u) for (let h = a.minY; h <= a.maxY; ++h) {
            const c = Hw(l, [i, u, h]);
            let f = false;
            if (s.containsKey(c)) {
              const g = s.get(c);
              g.ready && !LF(r, g.tile) && (PF(r, g, i), f = true);
            }
            f || (o = false);
          }
          return o;
        }
        clearCache() {
          super.clearCache();
          const t = this.tileRepresentationCache;
          t.forEach((e) => e.dispose()), t.clear();
        }
        afterHelperCreated() {
          super.afterHelperCreated(), this.tileRepresentationCache.forEach((t) => t.setHelper(this.helper));
        }
        disposeInternal() {
          super.disposeInternal(), delete this.frameState;
        }
      }
      const oe = zt(st({}, cot), { TILE_TEXTURE_ARRAY: "u_tileTextures", TEXTURE_PIXEL_WIDTH: "u_texturePixelWidth", TEXTURE_PIXEL_HEIGHT: "u_texturePixelHeight", TEXTURE_RESOLUTION: "u_textureResolution", TEXTURE_ORIGIN_X: "u_textureOriginX", TEXTURE_ORIGIN_Y: "u_textureOriginY" }), hm = { TEXTURE_COORD: "a_textureCoord" }, dot = [{ name: hm.TEXTURE_COORD, size: 2, type: Ao.FLOAT }];
      class Aot extends got {
        constructor(t, e) {
          super(t, e), this.program_, this.vertexShader_ = e.vertexShader, this.fragmentShader_ = e.fragmentShader, this.indices_ = new am(rm, Vw), this.indices_.fromArray([0, 1, 3, 1, 2, 3]), this.paletteTextures_ = e.paletteTextures || [];
        }
        reset(t) {
          if (super.reset(t), this.helper) {
            const e = this.helper.getGL();
            for (const i of this.paletteTextures_) i.delete(e);
          }
          if (this.vertexShader_ = t.vertexShader, this.fragmentShader_ = t.fragmentShader, this.paletteTextures_ = t.paletteTextures || [], this.helper) {
            this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
            const e = this.helper.getGL();
            for (const i of this.paletteTextures_) i.getTexture(e);
          }
        }
        afterHelperCreated() {
          super.afterHelperCreated();
          const t = this.helper.getGL();
          for (const e of this.paletteTextures_) e.getTexture(t);
          this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_), this.helper.flushBufferData(this.indices_);
        }
        removeHelper() {
          if (this.helper) {
            const t = this.helper.getGL();
            for (const e of this.paletteTextures_) e.delete(t);
          }
          super.removeHelper();
        }
        createTileRepresentation(t) {
          return new iot(t);
        }
        beforeTilesRender(t, e) {
          super.beforeTilesRender(t, e), this.helper.useProgram(this.program_, t);
        }
        renderTile(t, e, i, r, a, o, s, l, u, h, c) {
          const f = this.helper.getGL();
          this.helper.bindBuffer(t.coords), this.helper.bindBuffer(this.indices_), this.helper.enableAttributes(dot);
          let g = 0;
          for (; g < t.textures.length; ) {
            const I = `${oe.TILE_TEXTURE_ARRAY}[${g}]`;
            this.helper.bindTexture(t.textures[g], g, I), ++g;
          }
          for (let I = 0; I < this.paletteTextures_.length; ++I) {
            const x = this.paletteTextures_[I], w = x.getTexture(f);
            this.helper.bindTexture(w, g, x.name), ++g;
          }
          const d = i.viewState, A = o[0] + 2 * h, p = o[1] + 2 * h, y = t.tile.tileCoord, m = y[1], _ = y[2];
          this.helper.setUniformMatrixValue(oe.TILE_TRANSFORM, BF(this.tempMat4, e)), this.helper.setUniformFloatValue(oe.TRANSITION_ALPHA, c), this.helper.setUniformFloatValue(oe.DEPTH, u);
          let E = r;
          h > 0 && (E = l, ei(E, r, E)), this.helper.setUniformFloatVec4(oe.RENDER_EXTENT, E), this.helper.setUniformFloatValue(oe.RESOLUTION, d.resolution), this.helper.setUniformFloatValue(oe.ZOOM, d.zoom), this.helper.setUniformFloatValue(oe.TEXTURE_PIXEL_WIDTH, A), this.helper.setUniformFloatValue(oe.TEXTURE_PIXEL_HEIGHT, p), this.helper.setUniformFloatValue(oe.TEXTURE_RESOLUTION, a), this.helper.setUniformFloatValue(oe.TEXTURE_ORIGIN_X, s[0] + m * o[0] * a - h * a), this.helper.setUniformFloatValue(oe.TEXTURE_ORIGIN_Y, s[1] - _ * o[1] * a + h * a), this.helper.drawElements(0, this.indices_.getSize());
        }
        getData(t) {
          if (!this.helper.getGL()) return null;
          const i = this.frameState;
          if (!i) return null;
          const r = this.getLayer(), a = gn(i.pixelToCoordinateTransform, t.slice()), o = i.viewState, s = r.getExtent();
          if (s && !Wr(Ni(s, o.projection), a)) return null;
          const l = r.getSources(Vn([a]), o.resolution);
          let u, h, c;
          for (u = l.length - 1; u >= 0; --u) if (h = l[u], h.getState() === "ready") {
            if (c = h.getTileGridForProjection(o.projection), h.getWrapX()) break;
            const g = c.getExtent();
            if (!g || Wr(g, a)) break;
          }
          if (u < 0) return null;
          const f = this.tileRepresentationCache;
          for (let g = c.getZForResolution(o.resolution); g >= c.getMinZoom(); --g) {
            const d = c.getTileCoordForCoordAndZ(a, g), A = Hw(h, d);
            if (!f.containsKey(A)) continue;
            const p = f.get(A), v = p.tile;
            if ((v instanceof Cf || v instanceof em) && v.getState() === At.EMPTY) return null;
            if (!p.loaded) continue;
            const y = c.getOrigin(g), m = bn(c.getTileSize(g)), _ = c.getResolution(g), E = (a[0] - y[0]) / _ - d[1] * m[0], I = (y[1] - a[1]) / _ - d[2] * m[1];
            return p.getPixelData(E, I);
          }
          return null;
        }
        disposeInternal() {
          const t = this.helper;
          if (t) {
            const e = t.getGL();
            for (const i of this.paletteTextures_) i.delete(e);
            this.paletteTextures_.length = 0, e.deleteProgram(this.program_), delete this.program_, t.deleteBuffer(this.indices_);
          }
          super.disposeInternal(), delete this.indices_;
        }
      }
      class pot {
        constructor(t, e) {
          this.name = t, this.data = e, this.texture_ = null;
        }
        getTexture(t) {
          if (!this.texture_) {
            const e = t.createTexture();
            t.bindTexture(t.TEXTURE_2D, e), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, this.data.length / 4, 1, 0, t.RGBA, t.UNSIGNED_BYTE, this.data), this.texture_ = e;
          }
          return this.texture_;
        }
        delete(t) {
          this.texture_ && t.deleteTexture(this.texture_), this.texture_ = null;
        }
      }
      function vot(n, t) {
        return `operator_${n}_${Object.keys(t.functions).length}`;
      }
      function Gu(n) {
        const t = n.toString();
        return t.includes(".") ? t : t + ".0";
      }
      function Yw(n) {
        if (n.length < 2 || n.length > 4) throw new Error("`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.");
        return `vec${n.length}(${n.map(Gu).join(", ")})`;
      }
      function cm(n) {
        const t = hl(n), e = t.length > 3 ? t[3] : 1;
        return Yw([t[0] / 255, t[1] / 255, t[2] / 255, e]);
      }
      function yot(n) {
        const t = bn(n);
        return Yw(t);
      }
      const Ww = {};
      let mot = 0;
      function NF(n) {
        return n in Ww || (Ww[n] = mot++), Ww[n];
      }
      function Uu(n) {
        return Gu(NF(n));
      }
      function kF(n) {
        return "u_var_" + n;
      }
      function _ot() {
        return { inFragmentShader: false, variables: {}, properties: {}, functions: {}, bandCount: 0, style: {} };
      }
      const Xw = "getBandValue", FF = "u_paletteTextures";
      function Iot(n, t, e, i) {
        const r = ii(n, t, e);
        return Zw(r, t, i);
      }
      function Fe(n) {
        return (t, e, i) => {
          const r = e.args.length, a = new Array(r);
          for (let o = 0; o < r; ++o) a[o] = Zw(e.args[o], i, t);
          return n(a, t);
        };
      }
      const Eot = { [q.Get]: (n, t) => {
        const i = t.args[0].value;
        return i in n.properties || (n.properties[i] = { name: i, type: t.type }), (n.inFragmentShader ? "v_prop_" : "a_prop_") + i;
      }, [q.GeometryType]: (n, t, e) => {
        const i = "geometryType";
        return i in n.properties || (n.properties[i] = { name: i, type: wi, evaluator: (o) => qx(o.getGeometry()) }), (n.inFragmentShader ? "v_prop_" : "a_prop_") + i;
      }, [q.LineMetric]: () => "currentLineMetric", [q.Var]: (n, t) => {
        const i = t.args[0].value;
        return i in n.variables || (n.variables[i] = { name: i, type: t.type }), kF(i);
      }, [q.Resolution]: () => "u_resolution", [q.Zoom]: () => "u_zoom", [q.Time]: () => "u_time", [q.Any]: Fe((n) => `(${n.join(" || ")})`), [q.All]: Fe((n) => `(${n.join(" && ")})`), [q.Not]: Fe(([n]) => `(!${n})`), [q.Equal]: Fe(([n, t]) => `(${n} == ${t})`), [q.NotEqual]: Fe(([n, t]) => `(${n} != ${t})`), [q.GreaterThan]: Fe(([n, t]) => `(${n} > ${t})`), [q.GreaterThanOrEqualTo]: Fe(([n, t]) => `(${n} >= ${t})`), [q.LessThan]: Fe(([n, t]) => `(${n} < ${t})`), [q.LessThanOrEqualTo]: Fe(([n, t]) => `(${n} <= ${t})`), [q.Multiply]: Fe((n) => `(${n.join(" * ")})`), [q.Divide]: Fe(([n, t]) => `(${n} / ${t})`), [q.Add]: Fe((n) => `(${n.join(" + ")})`), [q.Subtract]: Fe(([n, t]) => `(${n} - ${t})`), [q.Clamp]: Fe(([n, t, e]) => `clamp(${n}, ${t}, ${e})`), [q.Mod]: Fe(([n, t]) => `mod(${n}, ${t})`), [q.Pow]: Fe(([n, t]) => `pow(${n}, ${t})`), [q.Abs]: Fe(([n]) => `abs(${n})`), [q.Floor]: Fe(([n]) => `floor(${n})`), [q.Ceil]: Fe(([n]) => `ceil(${n})`), [q.Round]: Fe(([n]) => `floor(${n} + 0.5)`), [q.Sin]: Fe(([n]) => `sin(${n})`), [q.Cos]: Fe(([n]) => `cos(${n})`), [q.Atan]: Fe(([n, t]) => t !== void 0 ? `atan(${n}, ${t})` : `atan(${n})`), [q.Sqrt]: Fe(([n]) => `sqrt(${n})`), [q.Match]: Fe((n) => {
        const t = n[0], e = n[n.length - 1];
        let i = null;
        for (let r = n.length - 3; r >= 1; r -= 2) {
          const a = n[r], o = n[r + 1];
          i = `(${t} == ${a} ? ${o} : ${i || e})`;
        }
        return i;
      }), [q.Between]: Fe(([n, t, e]) => `(${n} >= ${t} && ${n} <= ${e})`), [q.Interpolate]: Fe(([n, t, ...e]) => {
        let i = "";
        for (let r = 0; r < e.length - 2; r += 2) {
          const a = e[r], o = i || e[r + 1], s = e[r + 2], l = e[r + 3];
          let u;
          n === Gu(1) ? u = `(${t} - ${a}) / (${s} - ${a})` : u = `(pow(${n}, (${t} - ${a})) - 1.0) / (pow(${n}, (${s} - ${a})) - 1.0)`, i = `mix(${o}, ${l}, clamp(${u}, 0.0, 1.0))`;
        }
        return i;
      }), [q.Case]: Fe((n) => {
        const t = n[n.length - 1];
        let e = null;
        for (let i = n.length - 3; i >= 0; i -= 2) {
          const r = n[i], a = n[i + 1];
          e = `(${r} ? ${a} : ${e || t})`;
        }
        return e;
      }), [q.In]: Fe(([n, ...t], e) => {
        const i = vot("in", e), r = [];
        for (let a = 0; a < t.length; a += 1) r.push(`  if (inputValue == ${t[a]}) { return true; }`);
        return e.functions[i] = `bool ${i}(float inputValue) {
${r.join(`
`)}
  return false;
}`, `${i}(${n})`;
      }), [q.Array]: Fe((n) => `vec${n.length}(${n.join(", ")})`), [q.Color]: Fe((n) => {
        if (n.length === 1) return `vec4(vec3(${n[0]} / 255.0), 1.0)`;
        if (n.length === 2) return `vec4(vec3(${n[0]} / 255.0), ${n[1]})`;
        const t = n.slice(0, 3).map((i) => `${i} / 255.0`);
        if (n.length === 3) return `vec4(${t.join(", ")}, 1.0)`;
        const e = n[3];
        return `vec4(${t.join(", ")}, ${e})`;
      }), [q.Band]: Fe(([n, t, e], i) => {
        if (!(Xw in i.functions)) {
          let r = "";
          const a = i.bandCount || 1;
          for (let o = 0; o < a; o++) {
            const s = Math.floor(o / 4);
            let l = o % 4;
            o === a - 1 && l === 1 && (l = 3);
            const u = `${oe.TILE_TEXTURE_ARRAY}[${s}]`;
            r += `  if (band == ${o + 1}.0) {
    return texture2D(${u}, v_textureCoord + vec2(dx, dy))[${l}];
  }
`;
          }
          i.functions[Xw] = `float getBandValue(float band, float xOffset, float yOffset) {
  float dx = xOffset / ${oe.TEXTURE_PIXEL_WIDTH};
  float dy = yOffset / ${oe.TEXTURE_PIXEL_HEIGHT};
${r}
}`;
        }
        return `${Xw}(${n}, ${t != null ? t : "0.0"}, ${e != null ? e : "0.0"})`;
      }), [q.Palette]: (n, t) => {
        const [e, ...i] = t.args, r = i.length, a = new Uint8Array(r * 4);
        for (let u = 0; u < i.length; u++) {
          const h = i[u].value, c = hl(h), f = u * 4;
          a[f] = c[0], a[f + 1] = c[1], a[f + 2] = c[2], a[f + 3] = c[3] * 255;
        }
        n.paletteTextures || (n.paletteTextures = []);
        const o = `${FF}[${n.paletteTextures.length}]`, s = new pot(o, a);
        n.paletteTextures.push(s);
        const l = Zw(e, se, n);
        return `texture2D(${o}, vec2((${l} + 0.5) / ${r}.0, 0.5))`;
      } };
      function Zw(n, t, e) {
        if (n instanceof XP) {
          const i = Eot[n.operator];
          if (i === void 0) throw new Error(`No compiler defined for this operator: ${JSON.stringify(n.operator)}`);
          return i(e, n, t);
        }
        if ((n.type & se) > 0) return Gu(n.value);
        if ((n.type & xi) > 0) return n.value.toString();
        if ((n.type & wi) > 0) return Uu(n.value.toString());
        if ((n.type & Lr) > 0) return cm(n.value);
        if ((n.type & fl) > 0) return Yw(n.value);
        if ((n.type & Zc) > 0) return yot(n.value);
        throw new Error(`Unexpected expression ${n.value} (expected type ${Kc(t)})`);
      }
      const QF = 0.985;
      function xot(n, t) {
        t = t || [];
        const e = 256, i = e - 1;
        return t[0] = Math.floor(n / e / e / e) / i, t[1] = Math.floor(n / e / e) % e / i, t[2] = Math.floor(n / e) % e / i, t[3] = n % e / i, t;
      }
      function wot(n) {
        let t = 0;
        const e = 256, i = e - 1;
        return t += Math.round(n[0] * e * e * e * i), t += Math.round(n[1] * e * e * i), t += Math.round(n[2] * e * i), t += Math.round(n[3] * i), t;
      }
      function OF() {
        return { "fill-color": "rgba(255,255,255,0.4)", "stroke-color": "#3399CC", "stroke-width": 1.25, "circle-radius": 5, "circle-fill-color": "rgba(255,255,255,0.4)", "circle-stroke-width": 1.25, "circle-stroke-color": "#3399CC" };
      }
      const bf = `#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform mat4 u_projectionMatrix;
uniform mat4 u_screenToWorldMatrix;
uniform vec2 u_viewportSizePx;
uniform float u_pixelRatio;
uniform float u_globalAlpha;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
uniform float u_rotation;
uniform vec4 u_renderExtent;
uniform vec2 u_patternOrigin;
uniform float u_depth;
uniform mediump int u_hitDetection;

const float PI = 3.141592653589793238;
const float TWO_PI = 2.0 * PI;
float currentLineMetric = 0.; // an actual value will be used in the stroke shaders
`, Bf = OF();
      class Cot {
        constructor() {
          this.uniforms_ = [], this.attributes_ = [], this.varyings_ = [], this.hasSymbol_ = false, this.symbolSizeExpression_ = `vec2(${Gu(Bf["circle-radius"])} + ${Gu(Bf["circle-stroke-width"] * 0.5)})`, this.symbolRotationExpression_ = "0.0", this.symbolOffsetExpression_ = "vec2(0.0)", this.symbolColorExpression_ = cm(Bf["circle-fill-color"]), this.texCoordExpression_ = "vec4(0.0, 0.0, 1.0, 1.0)", this.discardExpression_ = "false", this.symbolRotateWithView_ = false, this.hasStroke_ = false, this.strokeWidthExpression_ = Gu(Bf["stroke-width"]), this.strokeColorExpression_ = cm(Bf["stroke-color"]), this.strokeOffsetExpression_ = "0.", this.strokeCapExpression_ = Uu("round"), this.strokeJoinExpression_ = Uu("round"), this.strokeMiterLimitExpression_ = "10.", this.strokeDistanceFieldExpression_ = "-1000.", this.hasFill_ = false, this.fillColorExpression_ = cm(Bf["fill-color"]), this.vertexShaderFunctions_ = [], this.fragmentShaderFunctions_ = [];
        }
        addUniform(t) {
          return this.uniforms_.push(t), this;
        }
        addAttribute(t) {
          return this.attributes_.push(t), this;
        }
        addVarying(t, e, i) {
          return this.varyings_.push({ name: t, type: e, expression: i }), this;
        }
        setSymbolSizeExpression(t) {
          return this.hasSymbol_ = true, this.symbolSizeExpression_ = t, this;
        }
        getSymbolSizeExpression() {
          return this.symbolSizeExpression_;
        }
        setSymbolRotationExpression(t) {
          return this.symbolRotationExpression_ = t, this;
        }
        setSymbolOffsetExpression(t) {
          return this.symbolOffsetExpression_ = t, this;
        }
        getSymbolOffsetExpression() {
          return this.symbolOffsetExpression_;
        }
        setSymbolColorExpression(t) {
          return this.hasSymbol_ = true, this.symbolColorExpression_ = t, this;
        }
        getSymbolColorExpression() {
          return this.symbolColorExpression_;
        }
        setTextureCoordinateExpression(t) {
          return this.texCoordExpression_ = t, this;
        }
        setFragmentDiscardExpression(t) {
          return this.discardExpression_ = t, this;
        }
        getFragmentDiscardExpression() {
          return this.discardExpression_;
        }
        setSymbolRotateWithView(t) {
          return this.symbolRotateWithView_ = t, this;
        }
        setStrokeWidthExpression(t) {
          return this.hasStroke_ = true, this.strokeWidthExpression_ = t, this;
        }
        setStrokeColorExpression(t) {
          return this.hasStroke_ = true, this.strokeColorExpression_ = t, this;
        }
        getStrokeColorExpression() {
          return this.strokeColorExpression_;
        }
        setStrokeOffsetExpression(t) {
          return this.strokeOffsetExpression_ = t, this;
        }
        setStrokeCapExpression(t) {
          return this.strokeCapExpression_ = t, this;
        }
        setStrokeJoinExpression(t) {
          return this.strokeJoinExpression_ = t, this;
        }
        setStrokeMiterLimitExpression(t) {
          return this.strokeMiterLimitExpression_ = t, this;
        }
        setStrokeDistanceFieldExpression(t) {
          return this.strokeDistanceFieldExpression_ = t, this;
        }
        setFillColorExpression(t) {
          return this.hasFill_ = true, this.fillColorExpression_ = t, this;
        }
        getFillColorExpression() {
          return this.fillColorExpression_;
        }
        addVertexShaderFunction(t) {
          this.vertexShaderFunctions_.includes(t) || this.vertexShaderFunctions_.push(t);
        }
        addFragmentShaderFunction(t) {
          this.fragmentShaderFunctions_.includes(t) || this.fragmentShaderFunctions_.push(t);
        }
        getSymbolVertexShader() {
          return this.hasSymbol_ ? `${bf}
${this.uniforms_.map(function(t) {
            return "uniform " + t + ";";
          }).join(`
`)}
attribute vec2 a_position;
attribute float a_index;
attribute vec4 a_prop_hitColor;
${this.attributes_.map(function(t) {
            return "attribute " + t + ";";
          }).join(`
`)}
varying vec2 v_texCoord;
varying vec2 v_quadCoord;
varying vec4 v_prop_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;
${this.varyings_.map(function(t) {
            return "varying " + t.type + " " + t.name + ";";
          }).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
vec2 pxToScreen(vec2 coordPx) {
  vec2 scaled = coordPx / u_viewportSizePx / 0.5;
  return scaled;
}

vec2 screenToPx(vec2 coordScreen) {
  return (coordScreen * 0.5 + 0.5) * u_viewportSizePx;
}

void main(void) {
  v_quadSizePx = ${this.symbolSizeExpression_};
  vec2 halfSizePx = v_quadSizePx * 0.5;
  vec2 centerOffsetPx = ${this.symbolOffsetExpression_};
  vec2 offsetPx = centerOffsetPx;
  if (a_index == 0.0) {
    offsetPx -= halfSizePx;
  } else if (a_index == 1.0) {
    offsetPx += halfSizePx * vec2(1., -1.);
  } else if (a_index == 2.0) {
    offsetPx += halfSizePx;
  } else {
    offsetPx += halfSizePx * vec2(-1., 1.);
  }
  float angle = ${this.symbolRotationExpression_};
  ${this.symbolRotateWithView_ ? "angle += u_rotation;" : ""}
  float c = cos(-angle);
  float s = sin(-angle);
  offsetPx = vec2(c * offsetPx.x - s * offsetPx.y, s * offsetPx.x + c * offsetPx.y);
  vec4 center = u_projectionMatrix * vec4(a_position, 0.0, 1.0);
  gl_Position = center + vec4(pxToScreen(offsetPx), u_depth, 0.);
  vec4 texCoord = ${this.texCoordExpression_};
  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;
  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;
  v_texCoord = vec2(u, v);
  v_prop_hitColor = a_prop_hitColor;
  v_angle = angle;
  c = cos(-v_angle);
  s = sin(-v_angle);
  centerOffsetPx = vec2(c * centerOffsetPx.x - s * centerOffsetPx.y, s * centerOffsetPx.x + c * centerOffsetPx.y); 
  v_centerPx = screenToPx(center.xy) + centerOffsetPx;
${this.varyings_.map(function(t) {
            return "  " + t.name + " = " + t.expression + ";";
          }).join(`
`)}
}` : null;
        }
        getSymbolFragmentShader() {
          return this.hasSymbol_ ? `${bf}
${this.uniforms_.map(function(t) {
            return "uniform " + t + ";";
          }).join(`
`)}
varying vec2 v_texCoord;
varying vec4 v_prop_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;
${this.varyings_.map(function(t) {
            return "varying " + t.type + " " + t.name + ";";
          }).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}

void main(void) {
  if (${this.discardExpression_}) { discard; }
  vec2 coordsPx = gl_FragCoord.xy / u_pixelRatio - v_centerPx; // relative to center
  float c = cos(v_angle);
  float s = sin(v_angle);
  coordsPx = vec2(c * coordsPx.x - s * coordsPx.y, s * coordsPx.x + c * coordsPx.y);
  gl_FragColor = ${this.symbolColorExpression_};
  gl_FragColor.rgb *= gl_FragColor.a;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.05) { discard; };
    gl_FragColor = v_prop_hitColor;
  }
}` : null;
        }
        getStrokeVertexShader() {
          return this.hasStroke_ ? `${bf}
${this.uniforms_.map(function(t) {
            return "uniform " + t + ";";
          }).join(`
`)}
attribute vec2 a_segmentStart;
attribute vec2 a_segmentEnd;
attribute float a_measureStart;
attribute float a_measureEnd;
attribute float a_parameters;
attribute float a_distance;
attribute vec2 a_joinAngles;
attribute vec4 a_prop_hitColor;
${this.attributes_.map(function(t) {
            return "attribute " + t + ";";
          }).join(`
`)}
varying vec2 v_segmentStart;
varying vec2 v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_prop_hitColor;
varying float v_distanceOffsetPx;
varying float v_measureStart;
varying float v_measureEnd;
${this.varyings_.map(function(t) {
            return "varying " + t.type + " " + t.name + ";";
          }).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

vec4 pxToScreen(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return vec4(screenPos, u_depth, 1.0);
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

vec2 getJoinOffsetDirection(vec2 normalPx, float joinAngle) {
  float halfAngle = joinAngle / 2.0;
  float c = cos(halfAngle);
  float s = sin(halfAngle);
  vec2 angleBisectorNormal = vec2(s * normalPx.x + c * normalPx.y, -c * normalPx.x + s * normalPx.y);
  float length = 1.0 / s;
  return angleBisectorNormal * length;
}

vec2 getOffsetPoint(vec2 point, vec2 normal, float joinAngle, float offsetPx) {
  // if on a cap or the join angle is too high, offset the line along the segment normal
  if (cos(joinAngle) > 0.998 || isCap(joinAngle)) {
    return point - normal * offsetPx;
  }
  // offset is applied along the inverted normal (positive offset goes "right" relative to line direction)
  return point - getJoinOffsetDirection(normal, joinAngle) * offsetPx;
}

void main(void) {
  v_angleStart = a_joinAngles.x;
  v_angleEnd = a_joinAngles.y;
  float vertexNumber = floor(abs(a_parameters) / 10000. + 0.5);
  currentLineMetric = vertexNumber < 1.5 ? a_measureStart : a_measureEnd;
  // we're reading the fractional part while keeping the sign (so -4.12 gives -0.12, 3.45 gives 0.45)
  float angleTangentSum = fract(abs(a_parameters) / 10000.) * 10000. * sign(a_parameters);

  float lineWidth = ${this.strokeWidthExpression_};
  float lineOffsetPx = ${this.strokeOffsetExpression_};

  // compute segment start/end in px with offset
  vec2 segmentStartPx = worldToPx(a_segmentStart);
  vec2 segmentEndPx = worldToPx(a_segmentEnd);
  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);
  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);
  segmentStartPx = getOffsetPoint(segmentStartPx, normalPx, v_angleStart, lineOffsetPx),
  segmentEndPx = getOffsetPoint(segmentEndPx, normalPx, v_angleEnd, lineOffsetPx);
  
  // compute current vertex position
  float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;
  float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;
  float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;
  vec2 joinDirection;
  vec2 positionPx = vertexNumber < 1.5 ? segmentStartPx : segmentEndPx;
  // if angle is too high, do not make a proper join
  if (cos(angle) > ${QF} || isCap(angle)) {
    joinDirection = normalPx * normalDir - tangentPx * tangentDir;
  } else {
    joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);
  }
  positionPx = positionPx + joinDirection * (lineWidth * 0.5 + 1.); // adding 1 pixel for antialiasing
  gl_Position = pxToScreen(positionPx);

  v_segmentStart = segmentStartPx;
  v_segmentEnd = segmentEndPx;
  v_width = lineWidth;
  v_prop_hitColor = a_prop_hitColor;
  v_distanceOffsetPx = a_distance / u_resolution - (lineOffsetPx * angleTangentSum);
  v_measureStart = a_measureStart;
  v_measureEnd = a_measureEnd;
${this.varyings_.map(function(t) {
            return "  " + t.name + " = " + t.expression + ";";
          }).join(`
`)}
}` : null;
        }
        getStrokeFragmentShader() {
          return this.hasStroke_ ? `${bf}
${this.uniforms_.map(function(t) {
            return "uniform " + t + ";";
          }).join(`
`)}
varying vec2 v_segmentStart;
varying vec2 v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_prop_hitColor;
varying float v_distanceOffsetPx;
varying float v_measureStart;
varying float v_measureEnd;
${this.varyings_.map(function(t) {
            return "varying " + t.type + " " + t.name + ";";
          }).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}

vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

float segmentDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  vec2 tangent = normalize(end - start);
  vec2 normal = vec2(-tangent.y, tangent.x);
  vec2 startToPoint = point - start;
  return abs(dot(startToPoint, normal)) - width * 0.5;
}

float buttCapDistanceField(vec2 point, vec2 start, vec2 end) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  return dot(startToPoint, -tangent);
}

float squareCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return buttCapDistanceField(point, start, end) - width * 0.5;
}

float roundCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  float onSegment = max(0., 1000. * dot(point - start, end - start)); // this is very high when inside the segment
  return length(point - start) - width * 0.5 - onSegment;
}

float roundJoinDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return roundCapDistanceField(point, start, end, width);
}

float bevelJoinField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  float c = cos(joinAngle * 0.5);
  float s = sin(joinAngle * 0.5);
  float direction = -sign(sin(joinAngle));
  vec2 bisector = vec2(c * tangent.x - s * tangent.y, s * tangent.x + c * tangent.y);
  float radius = width * 0.5 * s;
  return dot(startToPoint, bisector * direction) - radius;
}

float miterJoinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  if (cos(joinAngle) > ${QF}) { // avoid risking a division by zero
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  float miterLength = 1. / sin(joinAngle * 0.5);
  float miterLimit = ${this.strokeMiterLimitExpression_};
  if (miterLength > miterLimit) {
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  return -1000.;
}

float capDistanceField(vec2 point, vec2 start, vec2 end, float width, float capType) {
   if (capType == ${Uu("butt")}) {
    return buttCapDistanceField(point, start, end);
  } else if (capType == ${Uu("square")}) {
    return squareCapDistanceField(point, start, end, width);
  }
  return roundCapDistanceField(point, start, end, width);
}

float joinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float joinType) {
  if (joinType == ${Uu("bevel")}) {
    return bevelJoinField(point, start, end, width, joinAngle);
  } else if (joinType == ${Uu("miter")}) {
    return miterJoinDistanceField(point, start, end, width, joinAngle);
  }
  return roundJoinDistanceField(point, start, end, width);
}

float computeSegmentPointDistance(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float capType, float joinType) {
  if (isCap(joinAngle)) {
    return capDistanceField(point, start, end, width, capType);
  }
  return joinDistanceField(point, start, end, width, joinAngle, joinType);
}

void main(void) {
  vec2 currentPoint = gl_FragCoord.xy / u_pixelRatio;
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(currentPoint);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif

  float segmentLength = length(v_segmentEnd - v_segmentStart);
  vec2 segmentTangent = (v_segmentEnd - v_segmentStart) / segmentLength;
  vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);
  vec2 startToPoint = currentPoint - v_segmentStart;
  float lengthToPoint = max(0., min(dot(segmentTangent, startToPoint), segmentLength));
  float currentLengthPx = lengthToPoint + v_distanceOffsetPx; 
  float currentRadiusPx = abs(dot(segmentNormal, startToPoint));
  float currentRadiusRatio = dot(segmentNormal, startToPoint) * 2. / v_width;
  currentLineMetric = mix(v_measureStart, v_measureEnd, lengthToPoint / segmentLength);

  if (${this.discardExpression_}) { discard; }

  vec4 color = ${this.strokeColorExpression_};
  float capType = ${this.strokeCapExpression_};
  float joinType = ${this.strokeJoinExpression_};
  float segmentStartDistance = computeSegmentPointDistance(currentPoint, v_segmentStart, v_segmentEnd, v_width, v_angleStart, capType, joinType);
  float segmentEndDistance = computeSegmentPointDistance(currentPoint, v_segmentEnd, v_segmentStart, v_width, v_angleEnd, capType, joinType);
  float distance = max(
    segmentDistanceField(currentPoint, v_segmentStart, v_segmentEnd, v_width),
    max(segmentStartDistance, segmentEndDistance)
  );
  distance = max(distance, ${this.strokeDistanceFieldExpression_});
  color.a *= smoothstep(0.5, -0.5, distance);
  gl_FragColor = color;
  gl_FragColor.a *= u_globalAlpha;
  gl_FragColor.rgb *= gl_FragColor.a;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_prop_hitColor;
  }
}` : null;
        }
        getFillVertexShader() {
          return this.hasFill_ ? `${bf}
${this.uniforms_.map(function(t) {
            return "uniform " + t + ";";
          }).join(`
`)}
attribute vec2 a_position;
attribute vec4 a_prop_hitColor;
${this.attributes_.map(function(t) {
            return "attribute " + t + ";";
          }).join(`
`)}
varying vec4 v_prop_hitColor;
${this.varyings_.map(function(t) {
            return "varying " + t.type + " " + t.name + ";";
          }).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
void main(void) {
  gl_Position = u_projectionMatrix * vec4(a_position, u_depth, 1.0);
  v_prop_hitColor = a_prop_hitColor;
${this.varyings_.map(function(t) {
            return "  " + t.name + " = " + t.expression + ";";
          }).join(`
`)}
}` : null;
        }
        getFillFragmentShader() {
          return this.hasFill_ ? `${bf}
${this.uniforms_.map(function(t) {
            return "uniform " + t + ";";
          }).join(`
`)}
varying vec4 v_prop_hitColor;
${this.varyings_.map(function(t) {
            return "varying " + t.type + " " + t.name + ";";
          }).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}
vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

void main(void) {
  vec2 pxPos = gl_FragCoord.xy / u_pixelRatio;
  vec2 pxOrigin = worldToPx(u_patternOrigin);
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(pxPos);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif
  if (${this.discardExpression_}) { discard; }
  gl_FragColor = ${this.fillColorExpression_};
  gl_FragColor.a *= u_globalAlpha;
  gl_FragColor.rgb *= gl_FragColor.a;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_prop_hitColor;
  }
}` : null;
        }
      }
      function Tf(n, t, e) {
        const i = jx();
        return Iot(t, e, i, n);
      }
      function zF(n, t) {
        const e = `
    attribute vec2 ${hm.TEXTURE_COORD};
    uniform mat4 ${oe.TILE_TRANSFORM};
    uniform float ${oe.TEXTURE_PIXEL_WIDTH};
    uniform float ${oe.TEXTURE_PIXEL_HEIGHT};
    uniform float ${oe.TEXTURE_RESOLUTION};
    uniform float ${oe.TEXTURE_ORIGIN_X};
    uniform float ${oe.TEXTURE_ORIGIN_Y};
    uniform float ${oe.DEPTH};

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;

    void main() {
      v_textureCoord = ${hm.TEXTURE_COORD};
      v_mapCoord = vec2(
        ${oe.TEXTURE_ORIGIN_X} + ${oe.TEXTURE_RESOLUTION} * ${oe.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],
        ${oe.TEXTURE_ORIGIN_Y} - ${oe.TEXTURE_RESOLUTION} * ${oe.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]
      );
      gl_Position = ${oe.TILE_TRANSFORM} * vec4(${hm.TEXTURE_COORD}, ${oe.DEPTH}, 1.0);
    }
  `, i = zt(st({}, _ot()), { inFragmentShader: true, bandCount: t, style: n }), r = [];
        if (n.color !== void 0) {
          const c = Tf(i, n.color, Lr);
          r.push(`color = ${c};`);
        }
        if (n.contrast !== void 0) {
          const c = Tf(i, n.contrast, se);
          r.push(`color.rgb = clamp((${c} + 1.0) * color.rgb - (${c} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);
        }
        if (n.exposure !== void 0) {
          const c = Tf(i, n.exposure, se);
          r.push(`color.rgb = clamp((${c} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);
        }
        if (n.saturation !== void 0) {
          const c = Tf(i, n.saturation, se);
          r.push(`
      float saturation = ${c} + 1.0;
      float sr = (1.0 - saturation) * 0.2126;
      float sg = (1.0 - saturation) * 0.7152;
      float sb = (1.0 - saturation) * 0.0722;
      mat3 saturationMatrix = mat3(
        sr + saturation, sr, sr,
        sg, sg + saturation, sg,
        sb, sb, sb + saturation
      );
      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
    `);
        }
        if (n.gamma !== void 0) {
          const c = Tf(i, n.gamma, se);
          r.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${c}));`);
        }
        if (n.brightness !== void 0) {
          const c = Tf(i, n.brightness, se);
          r.push(`color.rgb = clamp(color.rgb + ${c}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);
        }
        const a = {}, o = Object.keys(i.variables).length;
        if (o > 1 && !n.variables) throw new Error(`Missing variables in style (expected ${i.variables})`);
        for (let c = 0; c < o; ++c) {
          const f = i.variables[Object.keys(i.variables)[c]];
          if (!(f.name in n.variables)) throw new Error(`Missing '${f.name}' in style variables`);
          const g = kF(f.name);
          a[g] = function() {
            let d = n.variables[f.name];
            return typeof d == "string" && (d = NF(d)), d !== void 0 ? d : -9999999;
          };
        }
        const s = Object.keys(a).map(function(c) {
          return `uniform float ${c};`;
        }), l = Math.ceil(t / 4);
        s.push(`uniform sampler2D ${oe.TILE_TEXTURE_ARRAY}[${l}];`), i.paletteTextures && s.push(`uniform sampler2D ${FF}[${i.paletteTextures.length}];`);
        const u = Object.keys(i.functions).map(function(c) {
          return i.functions[c];
        }), h = `
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;
    uniform vec4 ${oe.RENDER_EXTENT};
    uniform float ${oe.TRANSITION_ALPHA};
    uniform float ${oe.TEXTURE_PIXEL_WIDTH};
    uniform float ${oe.TEXTURE_PIXEL_HEIGHT};
    uniform float ${oe.RESOLUTION};
    uniform float ${oe.ZOOM};

    ${s.join(`
`)}

    ${u.join(`
`)}

    void main() {
      if (
        v_mapCoord[0] < ${oe.RENDER_EXTENT}[0] ||
        v_mapCoord[1] < ${oe.RENDER_EXTENT}[1] ||
        v_mapCoord[0] > ${oe.RENDER_EXTENT}[2] ||
        v_mapCoord[1] > ${oe.RENDER_EXTENT}[3]
      ) {
        discard;
      }

      vec4 color = texture2D(${oe.TILE_TEXTURE_ARRAY}[0],  v_textureCoord);

      ${r.join(`
`)}

      gl_FragColor = color;
      gl_FragColor.rgb *= gl_FragColor.a;
      gl_FragColor *= ${oe.TRANSITION_ALPHA};
    }`;
        return { vertexShader: e, fragmentShader: h, uniforms: a, paletteTextures: i.paletteTextures };
      }
      class Kw extends vF {
        constructor(t) {
          t = t ? Object.assign({}, t) : {};
          const e = t.style || {};
          delete t.style, super(t), this.sources_ = t.sources, this.renderedSource_ = null, this.renderedResolution_ = NaN, this.style_ = e, this.styleVariables_ = this.style_.variables || {}, this.addChangeListener(ke.SOURCE, this.handleSourceUpdate_);
        }
        getSources(t, e) {
          const i = this.getSource();
          return this.sources_ ? typeof this.sources_ == "function" ? this.sources_(t, e) : this.sources_ : i ? [i] : [];
        }
        getRenderSource() {
          return this.renderedSource_ || this.getSource();
        }
        getSourceState() {
          const t = this.getRenderSource();
          return t ? t.getState() : "undefined";
        }
        handleSourceUpdate_() {
          this.hasRenderer() && this.getRenderer().clearCache();
          const t = this.getSource();
          if (t) if (t.getState() === "loading") {
            const e = () => {
              t.getState() === "ready" && (t.removeEventListener("change", e), this.setStyle(this.style_));
            };
            t.addEventListener("change", e);
          } else this.setStyle(this.style_);
        }
        getSourceBandCount_() {
          const t = Number.MAX_SAFE_INTEGER, e = this.getSources([-t, -t, t, t], t);
          return e && e.length && "bandCount" in e[0] ? e[0].bandCount : 4;
        }
        createRenderer() {
          const t = zF(this.style_, this.getSourceBandCount_());
          return new Aot(this, { vertexShader: t.vertexShader, fragmentShader: t.fragmentShader, uniforms: t.uniforms, cacheSize: this.getCacheSize(), paletteTextures: t.paletteTextures });
        }
        renderSources(t, e) {
          const i = this.getRenderer();
          let r;
          for (let a = 0, o = e.length; a < o; ++a) this.renderedSource_ = e[a], i.prepareFrame(t) && (r = i.renderFrame(t));
          return r;
        }
        render(t, e) {
          this.rendered = true;
          const i = t.viewState, r = this.getSources(t.extent, i.resolution);
          let a = true;
          for (let s = 0, l = r.length; s < l; ++s) {
            const u = r[s], h = u.getState();
            if (h == "loading") {
              const c = () => {
                u.getState() == "ready" && (u.removeEventListener("change", c), this.changed());
              };
              u.addEventListener("change", c);
            }
            a = a && h == "ready";
          }
          const o = this.renderSources(t, r);
          if (this.getRenderer().renderComplete && a) return this.renderedResolution_ = i.resolution, o;
          if (this.renderedResolution_ > 0.5 * i.resolution) {
            const s = this.getSources(t.extent, this.renderedResolution_).filter((l) => !r.includes(l));
            if (s.length > 0) return this.renderSources(t, s);
          }
          return o;
        }
        setStyle(t) {
          if (this.styleVariables_ = t.variables || {}, this.style_ = t, this.hasRenderer()) {
            const e = zF(this.style_, this.getSourceBandCount_());
            this.getRenderer().reset({ vertexShader: e.vertexShader, fragmentShader: e.fragmentShader, uniforms: e.uniforms, paletteTextures: e.paletteTextures }), this.changed();
          }
        }
        updateStyleVariables(t) {
          Object.assign(this.styleVariables_, t), this.changed();
        }
      }
      Kw.prototype.dispose;
      const Mf = { TILELOADSTART: "tileloadstart", TILELOADEND: "tileloadend", TILELOADERROR: "tileloaderror" }, Df = [0, 0, 0], Bl = 5;
      class Rf {
        constructor(t) {
          this.minZoom = t.minZoom !== void 0 ? t.minZoom : 0, this.resolutions_ = t.resolutions, he(KX(this.resolutions_, (r, a) => a - r), "`resolutions` must be sorted in descending order");
          let e;
          if (!t.origins) {
            for (let r = 0, a = this.resolutions_.length - 1; r < a; ++r) if (!e) e = this.resolutions_[r] / this.resolutions_[r + 1];
            else if (this.resolutions_[r] / this.resolutions_[r + 1] !== e) {
              e = void 0;
              break;
            }
          }
          this.zoomFactor_ = e, this.maxZoom = this.resolutions_.length - 1, this.origin_ = t.origin !== void 0 ? t.origin : null, this.origins_ = null, t.origins !== void 0 && (this.origins_ = t.origins, he(this.origins_.length == this.resolutions_.length, "Number of `origins` and `resolutions` must be equal"));
          const i = t.extent;
          i !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = Zr(i)), he(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, "Either `origin` or `origins` must be configured, never both"), this.tileSizes_ = null, t.tileSizes !== void 0 && (this.tileSizes_ = t.tileSizes, he(this.tileSizes_.length == this.resolutions_.length, "Number of `tileSizes` and `resolutions` must be equal")), this.tileSize_ = t.tileSize !== void 0 ? t.tileSize : this.tileSizes_ ? null : Px, he(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, "Either `tileSize` or `tileSizes` must be configured, never both"), this.extent_ = i !== void 0 ? i : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], t.sizes !== void 0 ? this.fullTileRanges_ = t.sizes.map((r, a) => {
            const o = new C0(Math.min(0, r[0]), Math.max(r[0] - 1, -1), Math.min(0, r[1]), Math.max(r[1] - 1, -1));
            if (i) {
              const s = this.getTileRangeForExtentAndZ(i, a);
              o.minX = Math.max(s.minX, o.minX), o.maxX = Math.min(s.maxX, o.maxX), o.minY = Math.max(s.minY, o.minY), o.maxY = Math.min(s.maxY, o.maxY);
            }
            return o;
          }) : i && this.calculateTileRanges_(i);
        }
        forEachTileCoord(t, e, i) {
          const r = this.getTileRangeForExtentAndZ(t, e);
          for (let a = r.minX, o = r.maxX; a <= o; ++a) for (let s = r.minY, l = r.maxY; s <= l; ++s) i([e, a, s]);
        }
        forEachTileCoordParentTileRange(t, e, i, r) {
          let a, o, s, l = null, u = t[0] - 1;
          for (this.zoomFactor_ === 2 ? (o = t[1], s = t[2]) : l = this.getTileCoordExtent(t, r); u >= this.minZoom; ) {
            if (o !== void 0 && s !== void 0 ? (o = Math.floor(o / 2), s = Math.floor(s / 2), a = sf(o, o, s, s, i)) : a = this.getTileRangeForExtentAndZ(l, u, i), e(u, a)) return true;
            --u;
          }
          return false;
        }
        getExtent() {
          return this.extent_;
        }
        getMaxZoom() {
          return this.maxZoom;
        }
        getMinZoom() {
          return this.minZoom;
        }
        getOrigin(t) {
          return this.origin_ ? this.origin_ : this.origins_[t];
        }
        getResolution(t) {
          return this.resolutions_[t];
        }
        getResolutions() {
          return this.resolutions_;
        }
        getTileCoordChildTileRange(t, e, i) {
          if (t[0] < this.maxZoom) {
            if (this.zoomFactor_ === 2) {
              const a = t[1] * 2, o = t[2] * 2;
              return sf(a, a + 1, o, o + 1, e);
            }
            const r = this.getTileCoordExtent(t, i || this.tmpExtent_);
            return this.getTileRangeForExtentAndZ(r, t[0] + 1, e);
          }
          return null;
        }
        getTileRangeForTileCoordAndZ(t, e, i) {
          if (e > this.maxZoom || e < this.minZoom) return null;
          const r = t[0], a = t[1], o = t[2];
          if (e === r) return sf(a, o, a, o, i);
          if (this.zoomFactor_) {
            const l = Math.pow(this.zoomFactor_, e - r), u = Math.floor(a * l), h = Math.floor(o * l);
            if (e < r) return sf(u, u, h, h, i);
            const c = Math.floor(l * (a + 1)) - 1, f = Math.floor(l * (o + 1)) - 1;
            return sf(u, c, h, f, i);
          }
          const s = this.getTileCoordExtent(t, this.tmpExtent_);
          return this.getTileRangeForExtentAndZ(s, e, i);
        }
        getTileRangeForExtentAndZ(t, e, i) {
          this.getTileCoordForXYAndZ_(t[0], t[3], e, false, Df);
          const r = Df[1], a = Df[2];
          this.getTileCoordForXYAndZ_(t[2], t[1], e, true, Df);
          const o = Df[1], s = Df[2];
          return sf(r, o, a, s, i);
        }
        getTileCoordCenter(t) {
          const e = this.getOrigin(t[0]), i = this.getResolution(t[0]), r = bn(this.getTileSize(t[0]), this.tmpSize_);
          return [e[0] + (t[1] + 0.5) * r[0] * i, e[1] - (t[2] + 0.5) * r[1] * i];
        }
        getTileCoordExtent(t, e) {
          const i = this.getOrigin(t[0]), r = this.getResolution(t[0]), a = bn(this.getTileSize(t[0]), this.tmpSize_), o = i[0] + t[1] * a[0] * r, s = i[1] - (t[2] + 1) * a[1] * r, l = o + a[0] * r, u = s + a[1] * r;
          return Xr(o, s, l, u, e);
        }
        getTileCoordForCoordAndResolution(t, e, i) {
          return this.getTileCoordForXYAndResolution_(t[0], t[1], e, false, i);
        }
        getTileCoordForXYAndResolution_(t, e, i, r, a) {
          const o = this.getZForResolution(i), s = i / this.getResolution(o), l = this.getOrigin(o), u = bn(this.getTileSize(o), this.tmpSize_);
          let h = s * (t - l[0]) / i / u[0], c = s * (l[1] - e) / i / u[1];
          return r ? (h = ll(h, Bl) - 1, c = ll(c, Bl) - 1) : (h = zc(h, Bl), c = zc(c, Bl)), af(o, h, c, a);
        }
        getTileCoordForXYAndZ_(t, e, i, r, a) {
          const o = this.getOrigin(i), s = this.getResolution(i), l = bn(this.getTileSize(i), this.tmpSize_);
          let u = (t - o[0]) / s / l[0], h = (o[1] - e) / s / l[1];
          return r ? (u = ll(u, Bl) - 1, h = ll(h, Bl) - 1) : (u = zc(u, Bl), h = zc(h, Bl)), af(i, u, h, a);
        }
        getTileCoordForCoordAndZ(t, e, i) {
          return this.getTileCoordForXYAndZ_(t[0], t[1], e, false, i);
        }
        getTileCoordResolution(t) {
          return this.resolutions_[t[0]];
        }
        getTileSize(t) {
          return this.tileSize_ ? this.tileSize_ : this.tileSizes_[t];
        }
        getFullTileRange(t) {
          return this.fullTileRanges_ ? this.fullTileRanges_[t] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, t) : null;
        }
        getZForResolution(t, e) {
          const i = Hr(this.resolutions_, t, e || 0);
          return en(i, this.minZoom, this.maxZoom);
        }
        tileCoordIntersectsViewport(t, e) {
          return cP(e, 0, e.length, 2, this.getTileCoordExtent(t));
        }
        calculateTileRanges_(t) {
          const e = this.resolutions_.length, i = new Array(e);
          for (let r = this.minZoom; r < e; ++r) i[r] = this.getTileRangeForExtentAndZ(t, r);
          this.fullTileRanges_ = i;
        }
      }
      function $w(n) {
        let t = n.getDefaultTileGrid();
        return t || (t = Bot(n), n.setDefaultTileGrid(t)), t;
      }
      function Sot(n, t, e) {
        const i = t[0], r = n.getTileCoordCenter(t), a = fm(e);
        if (!Wr(a, r)) {
          const o = ve(a), s = Math.ceil((a[0] - r[0]) / o);
          return r[0] += o * s, n.getTileCoordForCoordAndZ(r, i);
        }
        return t;
      }
      function bot(n, t, e, i) {
        i = i !== void 0 ? i : "top-left";
        const r = UF(n, t, e);
        return new Rf({ extent: n, origin: oZ(n, i), resolutions: r, tileSize: e });
      }
      function GF(n) {
        const t = n || {}, e = t.extent || Vt("EPSG:3857").getExtent(), i = { extent: e, minZoom: t.minZoom, tileSize: t.tileSize, resolutions: UF(e, t.maxZoom, t.tileSize, t.maxResolution) };
        return new Rf(i);
      }
      function UF(n, t, e, i) {
        t = t !== void 0 ? t : pK, e = bn(e !== void 0 ? e : Px);
        const r = Cn(n), a = ve(n);
        i = i > 0 ? i : Math.max(a / e[0], r / e[1]);
        const o = t + 1, s = new Array(o);
        for (let l = 0; l < o; ++l) s[l] = i / Math.pow(2, l);
        return s;
      }
      function Bot(n, t, e, i) {
        const r = fm(n);
        return bot(r, t, e, i);
      }
      function fm(n) {
        n = Vt(n);
        let t = n.getExtent();
        if (!t) {
          const e = 180 * ZE.degrees / n.getMetersPerUnit();
          t = Xr(-e, -e, e, e);
        }
        return t;
      }
      class VF extends $x {
        constructor(t) {
          super({ attributions: t.attributions, attributionsCollapsible: t.attributionsCollapsible, projection: t.projection, state: t.state, wrapX: t.wrapX, interpolate: t.interpolate }), this.on, this.once, this.un, this.tilePixelRatio_ = t.tilePixelRatio !== void 0 ? t.tilePixelRatio : 1, this.tileGrid = t.tileGrid !== void 0 ? t.tileGrid : null;
          const e = [256, 256];
          this.tileGrid && bn(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), e), this.tmpSize = [0, 0], this.key_ = t.key || Ft(this), this.tileOptions = { transition: t.transition, interpolate: t.interpolate }, this.zDirection = t.zDirection ? t.zDirection : 0;
        }
        getGutterForProjection(t) {
          return 0;
        }
        getKey() {
          return this.key_;
        }
        setKey(t) {
          this.key_ !== t && (this.key_ = t, this.changed());
        }
        getResolutions(t) {
          const e = t ? this.getTileGridForProjection(t) : this.tileGrid;
          return e ? e.getResolutions() : null;
        }
        getTile(t, e, i, r, a) {
          return Qt();
        }
        getTileGrid() {
          return this.tileGrid;
        }
        getTileGridForProjection(t) {
          return this.tileGrid ? this.tileGrid : $w(t);
        }
        getTilePixelRatio(t) {
          return this.tilePixelRatio_;
        }
        getTilePixelSize(t, e, i) {
          const r = this.getTileGridForProjection(i), a = this.getTilePixelRatio(e), o = bn(r.getTileSize(t), this.tmpSize);
          return a == 1 ? o : aK(o, a, this.tmpSize);
        }
        getTileCoordForTileUrlFunction(t, e) {
          e = e !== void 0 ? e : this.getProjection();
          const i = this.getTileGridForProjection(e);
          return this.getWrapX() && e.isGlobal() && (t = Sot(i, t, e)), TJ(t, i) ? t : null;
        }
        clear() {
        }
        refresh() {
          this.clear(), super.refresh();
        }
      }
      class jF extends Se {
        constructor(t, e) {
          super(t), this.tile = e;
        }
      }
      function Jw(n, t) {
        const e = [];
        Object.keys(t).forEach(function(r) {
          t[r] !== null && t[r] !== void 0 && e.push(r + "=" + encodeURIComponent(t[r]));
        });
        const i = e.join("&");
        return n = n.replace(/[?&]$/, ""), n += n.includes("?") ? "&" : "?", n + i;
      }
      const Tot = /\{z\}/g, Mot = /\{x\}/g, Dot = /\{y\}/g, Rot = /\{-y\}/g;
      function Lot(n, t, e, i, r) {
        return n.replace(Tot, t.toString()).replace(Mot, e.toString()).replace(Dot, i.toString()).replace(Rot, function() {
          if (r === void 0) throw new Error("If the URL template has a {-y} placeholder, the grid extent must be known");
          return (r - i).toString();
        });
      }
      function Pot(n) {
        const t = [];
        let e = /\{([a-z])-([a-z])\}/.exec(n);
        if (e) {
          const i = e[1].charCodeAt(0), r = e[2].charCodeAt(0);
          let a;
          for (a = i; a <= r; ++a) t.push(n.replace(e[0], String.fromCharCode(a)));
          return t;
        }
        if (e = /\{(\d+)-(\d+)\}/.exec(n), e) {
          const i = parseInt(e[2], 10);
          for (let r = parseInt(e[1], 10); r <= i; r++) t.push(n.replace(e[0], r.toString()));
          return t;
        }
        return t.push(n), t;
      }
      function Not(n, t) {
        return function(e, i, r) {
          if (!e) return;
          let a;
          const o = e[0];
          if (t) {
            const s = t.getFullTileRange(o);
            s && (a = s.getHeight() - 1);
          }
          return Lot(n, o, e[1], e[2], a);
        };
      }
      function kot(n, t) {
        const e = n.length, i = new Array(e);
        for (let r = 0; r < e; ++r) i[r] = Not(n[r], t);
        return Fot(i);
      }
      function Fot(n) {
        return n.length === 1 ? n[0] : function(t, e, i) {
          if (!t) return;
          const r = ON(t), a = rs(r, n.length);
          return n[a](t, e, i);
        };
      }
      class tC extends VF {
        constructor(t) {
          super({ attributions: t.attributions, cacheSize: t.cacheSize, projection: t.projection, state: t.state, tileGrid: t.tileGrid, tilePixelRatio: t.tilePixelRatio, wrapX: t.wrapX, transition: t.transition, interpolate: t.interpolate, key: t.key, attributionsCollapsible: t.attributionsCollapsible, zDirection: t.zDirection }), this.generateTileUrlFunction_ = this.tileUrlFunction === tC.prototype.tileUrlFunction, this.tileLoadFunction = t.tileLoadFunction, t.tileUrlFunction && (this.tileUrlFunction = t.tileUrlFunction), this.urls = null, t.urls ? this.setUrls(t.urls) : t.url && this.setUrl(t.url), this.tileLoadingKeys_ = {};
        }
        getTileLoadFunction() {
          return this.tileLoadFunction;
        }
        getTileUrlFunction() {
          return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
        }
        getUrls() {
          return this.urls;
        }
        handleTileChange(t) {
          const e = t.target, i = Ft(e), r = e.getState();
          let a;
          r == At.LOADING ? (this.tileLoadingKeys_[i] = true, a = Mf.TILELOADSTART) : i in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[i], a = r == At.ERROR ? Mf.TILELOADERROR : r == At.LOADED ? Mf.TILELOADEND : void 0), a != null && this.dispatchEvent(new jF(a, e));
        }
        setTileLoadFunction(t) {
          this.tileLoadFunction = t, this.changed();
        }
        setTileUrlFunction(t, e) {
          this.tileUrlFunction = t, typeof e != "undefined" ? this.setKey(e) : this.changed();
        }
        setUrl(t) {
          const e = Pot(t);
          this.urls = e, this.setUrls(e);
        }
        setUrls(t) {
          this.urls = t;
          const e = t.join(`
`);
          this.generateTileUrlFunction_ ? this.setTileUrlFunction(kot(t, this.tileGrid), e) : this.setKey(e);
        }
        tileUrlFunction(t, e, i) {
        }
      }
      class qF extends tC {
        constructor(t) {
          super({ attributions: t.attributions, cacheSize: t.cacheSize, projection: t.projection, state: t.state, tileGrid: t.tileGrid, tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : Qot, tilePixelRatio: t.tilePixelRatio, tileUrlFunction: t.tileUrlFunction, url: t.url, urls: t.urls, wrapX: t.wrapX, transition: t.transition, interpolate: t.interpolate !== void 0 ? t.interpolate : true, key: t.key, attributionsCollapsible: t.attributionsCollapsible, zDirection: t.zDirection }), this.crossOrigin = t.crossOrigin !== void 0 ? t.crossOrigin : null, this.tileClass = t.tileClass !== void 0 ? t.tileClass : I0, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = t.reprojectionErrorThreshold, this.renderReprojectionEdges_ = false;
        }
        getGutterForProjection(t) {
          return this.getProjection() && t && !ro(this.getProjection(), t) ? 0 : this.getGutter();
        }
        getGutter() {
          return 0;
        }
        getKey() {
          let t = super.getKey();
          return this.getInterpolate() || (t += ":disable-interpolation"), t;
        }
        getTileGridForProjection(t) {
          const e = this.getProjection();
          if (this.tileGrid && (!e || ro(e, t))) return this.tileGrid;
          const i = Ft(t);
          return i in this.tileGridForProjection || (this.tileGridForProjection[i] = $w(t)), this.tileGridForProjection[i];
        }
        createTile_(t, e, i, r, a, o) {
          const s = [t, e, i], l = this.getTileCoordForTileUrlFunction(s, a), u = l ? this.tileUrlFunction(l, r, a) : void 0, h = new this.tileClass(s, u !== void 0 ? At.IDLE : At.EMPTY, u !== void 0 ? u : "", this.crossOrigin, this.tileLoadFunction, this.tileOptions);
          return h.key = o, h.addEventListener(Nt.CHANGE, this.handleTileChange.bind(this)), h;
        }
        getTile(t, e, i, r, a) {
          const o = this.getProjection();
          if (!o || !a || ro(o, a)) return this.getTileInternal(t, e, i, r, o || a);
          const s = [t, e, i], l = this.getKey(), u = this.getTileGridForProjection(o), h = this.getTileGridForProjection(a), c = this.getTileCoordForTileUrlFunction(s, a), f = new Cf(o, u, a, h, s, c, this.getTilePixelRatio(r), this.getGutter(), (g, d, A, p) => this.getTileInternal(g, d, A, p, o), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.tileOptions);
          return f.key = l, f;
        }
        getTileInternal(t, e, i, r, a) {
          const o = this.getKey();
          return this.createTile_(t, e, i, r, a, o);
        }
        setRenderReprojectionEdges(t) {
          this.renderReprojectionEdges_ != t && (this.renderReprojectionEdges_ = t, this.changed());
        }
        setTileGridForProjection(t, e) {
          const i = Vt(t);
          if (i) {
            const r = Ft(i);
            r in this.tileGridForProjection || (this.tileGridForProjection[r] = e);
          }
        }
      }
      function Qot(n, t) {
        n.getImage().src = t;
      }
      class eC extends qF {
        constructor(t) {
          t = t || {};
          const e = t.projection !== void 0 ? t.projection : "EPSG:3857", i = t.tileGrid !== void 0 ? t.tileGrid : GF({ extent: fm(e), maxResolution: t.maxResolution, maxZoom: t.maxZoom, minZoom: t.minZoom, tileSize: t.tileSize });
          super({ attributions: t.attributions, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, interpolate: t.interpolate, projection: e, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileGrid: i, tileLoadFunction: t.tileLoadFunction, tilePixelRatio: t.tilePixelRatio, tileUrlFunction: t.tileUrlFunction, url: t.url, urls: t.urls, wrapX: t.wrapX !== void 0 ? t.wrapX : true, transition: t.transition, attributionsCollapsible: t.attributionsCollapsible, zDirection: t.zDirection }), this.gutter_ = t.gutter !== void 0 ? t.gutter : 0;
        }
        getGutter() {
          return this.gutter_;
        }
      }
      class Oot extends $r {
        constructor(t) {
          t = t || {}, super({ attributions: t.attributions, wrapX: t.wrapX }), this.resolution = void 0, this.distance = t.distance !== void 0 ? t.distance : 20, this.minDistance = t.minDistance || 0, this.interpolationRatio = 0, this.features = [], this.geometryFunction = t.geometryFunction || function(e) {
            const i = e.getGeometry();
            return he(!i || i.getType() === "Point", "The default `geometryFunction` can only handle `Point` or null geometries"), i;
          }, this.createCustomCluster_ = t.createCluster, this.source = null, this.boundRefresh_ = this.refresh.bind(this), this.updateDistance(this.distance, this.minDistance), this.setSource(t.source || null);
        }
        clear(t) {
          this.features.length = 0, super.clear(t);
        }
        getDistance() {
          return this.distance;
        }
        getSource() {
          return this.source;
        }
        loadFeatures(t, e, i) {
          var r;
          (r = this.source) == null || r.loadFeatures(t, e, i), e !== this.resolution && (this.resolution = e, this.refresh());
        }
        setDistance(t) {
          this.updateDistance(t, this.minDistance);
        }
        setMinDistance(t) {
          this.updateDistance(this.distance, t);
        }
        getMinDistance() {
          return this.minDistance;
        }
        setSource(t) {
          this.source && this.source.removeEventListener(Nt.CHANGE, this.boundRefresh_), this.source = t, t && t.addEventListener(Nt.CHANGE, this.boundRefresh_), this.refresh();
        }
        refresh() {
          this.clear(), this.cluster(), this.addFeatures(this.features);
        }
        updateDistance(t, e) {
          const i = t === 0 ? 0 : Math.min(e, t) / t, r = t !== this.distance || this.interpolationRatio !== i;
          this.distance = t, this.minDistance = e, this.interpolationRatio = i, r && this.refresh();
        }
        cluster() {
          if (this.resolution === void 0 || !this.source) return;
          const t = Ii(), e = this.distance * this.resolution, i = this.source.getFeatures(), r = {};
          for (let a = 0, o = i.length; a < o; a++) {
            const s = i[a];
            if (!(Ft(s) in r)) {
              const l = this.geometryFunction(s);
              if (l) {
                const u = l.getCoordinates();
                Lc(u, t), es(t, e, t);
                const h = this.source.getFeaturesInExtent(t).filter(function(c) {
                  const f = Ft(c);
                  return f in r ? false : (r[f] = true, true);
                });
                this.features.push(this.createCluster(h, t));
              }
            }
          }
        }
        createCluster(t, e) {
          const i = [0, 0];
          for (let s = t.length - 1; s >= 0; --s) {
            const l = this.geometryFunction(t[s]);
            l ? GL(i, l.getCoordinates()) : t.splice(s, 1);
          }
          UL(i, 1 / t.length);
          const r = Br(e), a = this.interpolationRatio, o = new Oe([i[0] * (1 - a) + r[0] * a, i[1] * (1 - a) + r[1] * a]);
          return this.createCustomCluster_ ? this.createCustomCluster_(o, t) : new xe({ geometry: o, features: t });
        }
      }
      class zot extends VF {
        constructor(t) {
          const e = t.projection === void 0 ? "EPSG:3857" : t.projection;
          let i = t.tileGrid;
          i === void 0 && e && (i = GF({ extent: fm(e), maxResolution: t.maxResolution, maxZoom: t.maxZoom, minZoom: t.minZoom, tileSize: t.tileSize })), super({ cacheSize: 0.1, attributions: t.attributions, attributionsCollapsible: t.attributionsCollapsible, projection: e, tileGrid: i, state: t.state, wrapX: t.wrapX, transition: t.transition, interpolate: t.interpolate, key: t.key }), this.gutter_ = t.gutter !== void 0 ? t.gutter : 0, this.tileSize_ = t.tileSize ? bn(t.tileSize) : null, this.tileSizes_ = null, this.tileLoadingKeys_ = {}, this.loader_ = t.loader, this.handleTileChange_ = this.handleTileChange_.bind(this), this.bandCount = t.bandCount === void 0 ? 4 : t.bandCount, this.tileGridForProjection_ = {}, this.crossOrigin_ = t.crossOrigin || "anonymous";
        }
        setTileSizes(t) {
          this.tileSizes_ = t;
        }
        getTileSize(t) {
          if (this.tileSizes_) return this.tileSizes_[t];
          if (this.tileSize_) return this.tileSize_;
          const e = this.getTileGrid();
          return e ? bn(e.getTileSize(t)) : [256, 256];
        }
        getGutterForProjection(t) {
          const e = this.getProjection();
          return !e || ro(e, t) ? this.gutter_ : 0;
        }
        setLoader(t) {
          this.loader_ = t;
        }
        getReprojTile_(t, e, i, r, a) {
          const o = this.getTileGrid(), s = Math.max.apply(null, o.getResolutions().map((d, A) => {
            const p = bn(o.getTileSize(A)), v = this.getTileSize(A);
            return Math.max(v[0] / p[0], v[1] / p[1]);
          })), l = this.getTileGridForProjection(a), u = this.getTileGridForProjection(r), h = [t, e, i], c = this.getTileCoordForTileUrlFunction(h, r), f = Object.assign({ sourceProj: a, sourceTileGrid: l, targetProj: r, targetTileGrid: u, tileCoord: h, wrappedTileCoord: c, pixelRatio: s, gutter: this.getGutterForProjection(a), getTileFunction: (d, A, p, v) => this.getTile(d, A, p, v, a) }, this.tileOptions), g = new em(f);
          return g.key = this.getKey(), g;
        }
        getTile(t, e, i, r, a) {
          const o = this.getProjection();
          if (o && a && !ro(o, a)) return this.getReprojTile_(t, e, i, a, o);
          const s = this.getTileSize(t), l = this.loader_, u = new AbortController(), h = { signal: u.signal, crossOrigin: this.crossOrigin_ }, c = this.getTileCoordForTileUrlFunction([t, e, i]);
          if (!c) return null;
          const f = c[0], g = c[1], d = c[2];
          function A() {
            return VE(function() {
              return l(f, g, d, h);
            });
          }
          const p = Object.assign({ tileCoord: [t, e, i], loader: A, size: s, controller: u }, this.tileOptions), v = new QA(p);
          return v.key = this.getKey(), v.addEventListener(Nt.CHANGE, this.handleTileChange_), v;
        }
        handleTileChange_(t) {
          const e = t.target, i = Ft(e), r = e.getState();
          let a;
          r == At.LOADING ? (this.tileLoadingKeys_[i] = true, a = Mf.TILELOADSTART) : i in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[i], a = r == At.ERROR ? Mf.TILELOADERROR : r == At.LOADED ? Mf.TILELOADEND : void 0), a && this.dispatchEvent(new jF(a, e));
        }
        getTileGridForProjection(t) {
          const e = this.getProjection();
          if (this.tileGrid && (!e || ro(e, t))) return this.tileGrid;
          const i = Ft(t);
          return i in this.tileGridForProjection_ || (this.tileGridForProjection_[i] = $w(t)), this.tileGridForProjection_[i];
        }
        setTileGridForProjection(t, e) {
          const i = Vt(t);
          if (i) {
            const r = Ft(i);
            r in this.tileGridForProjection_ || (this.tileGridForProjection_[r] = e);
          }
        }
      }
      function gi(n) {
        return (t, ...e) => Got(n, t, e);
      }
      function Lf(n, t) {
        return gi(HF(n, t).get);
      }
      const { apply: Got, construct: ozt, defineProperty: szt, get: lzt, getOwnPropertyDescriptor: HF, getPrototypeOf: nC, has: uzt, ownKeys: Uot, set: hzt, setPrototypeOf: czt } = Reflect, { iterator: zA, species: fzt, toStringTag: Vot, for: gzt } = Symbol, jot = Object, { create: iC, defineProperty: qot, freeze: dzt, is: Azt } = jot, YF = Array.prototype[zA], Hot = gi(YF), WF = ArrayBuffer, Yot = WF.prototype;
      Lf(Yot, "byteLength");
      const XF = typeof SharedArrayBuffer != "undefined" ? SharedArrayBuffer : null;
      XF && Lf(XF.prototype, "byteLength");
      const ZF = nC(Uint8Array);
      ZF.from;
      const Oi = ZF.prototype;
      Oi[zA], gi(Oi.keys), gi(Oi.values), gi(Oi.entries), gi(Oi.set), gi(Oi.reverse), gi(Oi.fill), gi(Oi.copyWithin), gi(Oi.sort), gi(Oi.slice), gi(Oi.subarray), Lf(Oi, "buffer"), Lf(Oi, "byteOffset"), Lf(Oi, "length"), Lf(Oi, Vot);
      const Wot = Uint8Array, KF = Uint16Array, rC = Uint32Array, Xot = Float32Array, GA = nC([][zA]()), $F = gi(GA.next), Zot = gi(function* () {
      }().next), Kot = nC(GA), $ot = DataView.prototype, Jot = gi($ot.getUint16), aC = WeakMap, JF = aC.prototype, tQ = gi(JF.get), tst = gi(JF.set), eQ = new aC(), est = iC(null, { next: { value: function() {
        const t = tQ(eQ, this);
        return $F(t);
      } }, [zA]: { value: function() {
        return this;
      } } });
      function nst(n) {
        if (n[zA] === YF && GA.next === $F) return n;
        const t = iC(est);
        return tst(eQ, t, Hot(n)), t;
      }
      const ist = new aC(), rst = iC(Kot, { next: { value: function() {
        const t = tQ(ist, this);
        return Zot(t);
      }, writable: true, configurable: true } });
      for (const n of Uot(GA)) n !== "next" && qot(rst, n, HF(GA, n));
      const nQ = new WF(4), ast = new Xot(nQ), ost = new rC(nQ), po = new KF(512), vo = new Wot(512);
      for (let n = 0; n < 256; ++n) {
        const t = n - 127;
        t < -24 ? (po[n] = 0, po[n | 256] = 32768, vo[n] = 24, vo[n | 256] = 24) : t < -14 ? (po[n] = 1024 >> -t - 14, po[n | 256] = 1024 >> -t - 14 | 32768, vo[n] = -t - 1, vo[n | 256] = -t - 1) : t <= 15 ? (po[n] = t + 15 << 10, po[n | 256] = t + 15 << 10 | 32768, vo[n] = 13, vo[n | 256] = 13) : t < 128 ? (po[n] = 31744, po[n | 256] = 64512, vo[n] = 24, vo[n | 256] = 24) : (po[n] = 31744, po[n | 256] = 64512, vo[n] = 13, vo[n | 256] = 13);
      }
      const oC = new rC(2048);
      for (let n = 1; n < 1024; ++n) {
        let t = n << 13, e = 0;
        for (; !(t & 8388608); ) t <<= 1, e -= 8388608;
        t &= -8388609, e += 947912704, oC[n] = t | e;
      }
      for (let n = 1024; n < 2048; ++n) oC[n] = 939524096 + (n - 1024 << 13);
      const Pf = new rC(64);
      for (let n = 1; n < 31; ++n) Pf[n] = n << 23;
      Pf[31] = 1199570944, Pf[32] = 2147483648;
      for (let n = 33; n < 63; ++n) Pf[n] = 2147483648 + (n - 32 << 23);
      Pf[63] = 3347054592;
      const iQ = new KF(64);
      for (let n = 1; n < 64; ++n) n !== 32 && (iQ[n] = 1024);
      function sst(n) {
        const t = n >> 10;
        return ost[0] = oC[iQ[t] + (n & 1023)] + Pf[t], ast[0];
      }
      function rQ(n, t, ...e) {
        return sst(Jot(n, t, ...nst(e)));
      }
      var aQ = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
      function UA(n) {
        return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
      }
      function lst(n) {
        if (n.__esModule) return n;
        var t = n.default;
        if (typeof t == "function") {
          var e = function i() {
            return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
          };
          e.prototype = t.prototype;
        } else e = {};
        return Object.defineProperty(e, "__esModule", { value: true }), Object.keys(n).forEach(function(i) {
          var r = Object.getOwnPropertyDescriptor(n, i);
          Object.defineProperty(e, i, r.get ? r : { enumerable: true, get: function() {
            return n[i];
          } });
        }), e;
      }
      var sC = { exports: {} };
      function oQ(n, t, e) {
        const i = e && e.debug || false, r = typeof n == "object" ? n.outer : n, a = r.slice(0, r.indexOf(">") + 1), o = ['"', "'"];
        for (let s = 0; s < o.length; s++) {
          const l = o[s], u = t + "\\=" + l + "([^" + l + "]*)" + l, c = new RegExp(u).exec(a);
          if (c) return c[1];
        }
      }
      sC.exports = oQ, sC.exports.default = oQ;
      var ust = sC.exports;
      const lC = UA(ust);
      var uC = { exports: {} }, hC = { exports: {} }, cC = { exports: {} };
      function sQ(n, t, e) {
        const r = new RegExp(t).exec(n.slice(e));
        return r ? e + r.index : -1;
      }
      cC.exports = sQ, cC.exports.default = sQ;
      var hst = cC.exports, fC = { exports: {} };
      function lQ(n, t, e) {
        const r = new RegExp(t).exec(n.slice(e));
        return r ? e + r.index + r[0].length - 1 : -1;
      }
      fC.exports = lQ, fC.exports.default = lQ;
      var cst = fC.exports, gC = { exports: {} };
      function uQ(n, t) {
        const e = new RegExp(t, "g"), i = n.match(e);
        return i ? i.length : 0;
      }
      gC.exports = uQ, gC.exports.default = uQ;
      var fst = gC.exports;
      const gst = hst, dC = cst, hQ = fst;
      function cQ(n, t, e) {
        const i = e && e.debug || false, r = !(e && typeof e.nested === false), a = e && e.startIndex || 0, o = gst(n, `<${t}[ 
>/]`, a);
        if (o === -1) return;
        const s = n.slice(o + t.length);
        let l = dC(s, "^[^<]*[ /]>", 0);
        const u = l !== -1 && s[l - 1] === "/";
        if (u === false) if (r) {
          let g = 0, d = 1, A = 0;
          for (; (l = dC(s, "[ /]" + t + ">", g)) !== -1; ) {
            const p = s.substring(g, l + 1);
            if (d += hQ(p, "<" + t + `[ 
	>]`), A += hQ(p, "</" + t + ">"), A >= d) break;
            g = l;
          }
        } else l = dC(s, "[ /]" + t + ">", 0);
        const h = o + t.length + l + 1;
        if (h === -1) return;
        const c = n.slice(o, h);
        let f;
        return u ? f = null : f = c.slice(c.indexOf(">") + 1, c.lastIndexOf("<")), { inner: f, outer: c, start: o, end: h };
      }
      hC.exports = cQ, hC.exports.default = cQ;
      var dst = hC.exports;
      const Ast = dst;
      function fQ(n, t, e) {
        const i = [], r = e && e.debug || false, a = e && typeof e.nested == "boolean" ? e.nested : true;
        let o = e && e.startIndex || 0, s;
        for (; s = Ast(n, t, { debug: r, startIndex: o }); ) a ? o = s.start + 1 + t.length : o = s.end, i.push(s);
        return i;
      }
      uC.exports = fQ, uC.exports.default = fQ;
      var pst = uC.exports;
      const vst = UA(pst), VA = { 315: "Artist", 258: "BitsPerSample", 265: "CellLength", 264: "CellWidth", 320: "ColorMap", 259: "Compression", 33432: "Copyright", 306: "DateTime", 338: "ExtraSamples", 266: "FillOrder", 289: "FreeByteCounts", 288: "FreeOffsets", 291: "GrayResponseCurve", 290: "GrayResponseUnit", 316: "HostComputer", 270: "ImageDescription", 257: "ImageLength", 256: "ImageWidth", 271: "Make", 281: "MaxSampleValue", 280: "MinSampleValue", 272: "Model", 254: "NewSubfileType", 274: "Orientation", 262: "PhotometricInterpretation", 284: "PlanarConfiguration", 296: "ResolutionUnit", 278: "RowsPerStrip", 277: "SamplesPerPixel", 305: "Software", 279: "StripByteCounts", 273: "StripOffsets", 255: "SubfileType", 263: "Threshholding", 282: "XResolution", 283: "YResolution", 326: "BadFaxLines", 327: "CleanFaxData", 343: "ClipPath", 328: "ConsecutiveBadFaxLines", 433: "Decode", 434: "DefaultImageColor", 269: "DocumentName", 336: "DotRange", 321: "HalftoneHints", 346: "Indexed", 347: "JPEGTables", 285: "PageName", 297: "PageNumber", 317: "Predictor", 319: "PrimaryChromaticities", 532: "ReferenceBlackWhite", 339: "SampleFormat", 340: "SMinSampleValue", 341: "SMaxSampleValue", 559: "StripRowCounts", 330: "SubIFDs", 292: "T4Options", 293: "T6Options", 325: "TileByteCounts", 323: "TileLength", 324: "TileOffsets", 322: "TileWidth", 301: "TransferFunction", 318: "WhitePoint", 344: "XClipPathUnits", 286: "XPosition", 529: "YCbCrCoefficients", 531: "YCbCrPositioning", 530: "YCbCrSubSampling", 345: "YClipPathUnits", 287: "YPosition", 37378: "ApertureValue", 40961: "ColorSpace", 36868: "DateTimeDigitized", 36867: "DateTimeOriginal", 34665: "Exif IFD", 36864: "ExifVersion", 33434: "ExposureTime", 41728: "FileSource", 37385: "Flash", 40960: "FlashpixVersion", 33437: "FNumber", 42016: "ImageUniqueID", 37384: "LightSource", 37500: "MakerNote", 37377: "ShutterSpeedValue", 37510: "UserComment", 33723: "IPTC", 34675: "ICC Profile", 700: "XMP", 42112: "GDAL_METADATA", 42113: "GDAL_NODATA", 34377: "Photoshop", 33550: "ModelPixelScale", 33922: "ModelTiepoint", 34264: "ModelTransformation", 34735: "GeoKeyDirectory", 34736: "GeoDoubleParams", 34737: "GeoAsciiParams", 50674: "LercParameters" }, yo = {};
      for (const n in VA) VA.hasOwnProperty(n) && (yo[VA[n]] = parseInt(n, 10));
      const yst = [yo.BitsPerSample, yo.ExtraSamples, yo.SampleFormat, yo.StripByteCounts, yo.StripOffsets, yo.StripRowCounts, yo.TileByteCounts, yo.TileOffsets, yo.SubIFDs], AC = { 1: "BYTE", 2: "ASCII", 3: "SHORT", 4: "LONG", 5: "RATIONAL", 6: "SBYTE", 7: "UNDEFINED", 8: "SSHORT", 9: "SLONG", 10: "SRATIONAL", 11: "FLOAT", 12: "DOUBLE", 13: "IFD", 16: "LONG8", 17: "SLONG8", 18: "IFD8" }, fe = {};
      for (const n in AC) AC.hasOwnProperty(n) && (fe[AC[n]] = parseInt(n, 10));
      const cr = { WhiteIsZero: 0, BlackIsZero: 1, RGB: 2, Palette: 3, TransparencyMask: 4, CMYK: 5, YCbCr: 6, CIELab: 8, ICCLab: 9 }, mst = { Unspecified: 0, Assocalpha: 1, Unassalpha: 2 }, _st = { Version: 0, AddCompression: 1 }, pC = { None: 0, Deflate: 1, Zstandard: 2 }, Ist = { 1024: "GTModelTypeGeoKey", 1025: "GTRasterTypeGeoKey", 1026: "GTCitationGeoKey", 2048: "GeographicTypeGeoKey", 2049: "GeogCitationGeoKey", 2050: "GeogGeodeticDatumGeoKey", 2051: "GeogPrimeMeridianGeoKey", 2052: "GeogLinearUnitsGeoKey", 2053: "GeogLinearUnitSizeGeoKey", 2054: "GeogAngularUnitsGeoKey", 2055: "GeogAngularUnitSizeGeoKey", 2056: "GeogEllipsoidGeoKey", 2057: "GeogSemiMajorAxisGeoKey", 2058: "GeogSemiMinorAxisGeoKey", 2059: "GeogInvFlatteningGeoKey", 2060: "GeogAzimuthUnitsGeoKey", 2061: "GeogPrimeMeridianLongGeoKey", 2062: "GeogTOWGS84GeoKey", 3072: "ProjectedCSTypeGeoKey", 3073: "PCSCitationGeoKey", 3074: "ProjectionGeoKey", 3075: "ProjCoordTransGeoKey", 3076: "ProjLinearUnitsGeoKey", 3077: "ProjLinearUnitSizeGeoKey", 3078: "ProjStdParallel1GeoKey", 3079: "ProjStdParallel2GeoKey", 3080: "ProjNatOriginLongGeoKey", 3081: "ProjNatOriginLatGeoKey", 3082: "ProjFalseEastingGeoKey", 3083: "ProjFalseNorthingGeoKey", 3084: "ProjFalseOriginLongGeoKey", 3085: "ProjFalseOriginLatGeoKey", 3086: "ProjFalseOriginEastingGeoKey", 3087: "ProjFalseOriginNorthingGeoKey", 3088: "ProjCenterLongGeoKey", 3089: "ProjCenterLatGeoKey", 3090: "ProjCenterEastingGeoKey", 3091: "ProjCenterNorthingGeoKey", 3092: "ProjScaleAtNatOriginGeoKey", 3093: "ProjScaleAtCenterGeoKey", 3094: "ProjAzimuthAngleGeoKey", 3095: "ProjStraightVertPoleLongGeoKey", 3096: "ProjRectifiedGridAngleGeoKey", 4096: "VerticalCSTypeGeoKey", 4097: "VerticalCitationGeoKey", 4098: "VerticalDatumGeoKey", 4099: "VerticalUnitsGeoKey" };
      function Est(n, t) {
        const { width: e, height: i } = n, r = new Uint8Array(e * i * 3);
        let a;
        for (let o = 0, s = 0; o < n.length; ++o, s += 3) a = 256 - n[o] / t * 256, r[s] = a, r[s + 1] = a, r[s + 2] = a;
        return r;
      }
      function xst(n, t) {
        const { width: e, height: i } = n, r = new Uint8Array(e * i * 3);
        let a;
        for (let o = 0, s = 0; o < n.length; ++o, s += 3) a = n[o] / t * 256, r[s] = a, r[s + 1] = a, r[s + 2] = a;
        return r;
      }
      function wst(n, t) {
        const { width: e, height: i } = n, r = new Uint8Array(e * i * 3), a = t.length / 3, o = t.length / 3 * 2;
        for (let s = 0, l = 0; s < n.length; ++s, l += 3) {
          const u = n[s];
          r[l] = t[u] / 65536 * 256, r[l + 1] = t[u + a] / 65536 * 256, r[l + 2] = t[u + o] / 65536 * 256;
        }
        return r;
      }
      function Cst(n) {
        const { width: t, height: e } = n, i = new Uint8Array(t * e * 3);
        for (let r = 0, a = 0; r < n.length; r += 4, a += 3) {
          const o = n[r], s = n[r + 1], l = n[r + 2], u = n[r + 3];
          i[a] = 255 * ((255 - o) / 256) * ((255 - u) / 256), i[a + 1] = 255 * ((255 - s) / 256) * ((255 - u) / 256), i[a + 2] = 255 * ((255 - l) / 256) * ((255 - u) / 256);
        }
        return i;
      }
      function Sst(n) {
        const { width: t, height: e } = n, i = new Uint8ClampedArray(t * e * 3);
        for (let r = 0, a = 0; r < n.length; r += 3, a += 3) {
          const o = n[r], s = n[r + 1], l = n[r + 2];
          i[a] = o + 1.402 * (l - 128), i[a + 1] = o - 0.34414 * (s - 128) - 0.71414 * (l - 128), i[a + 2] = o + 1.772 * (s - 128);
        }
        return i;
      }
      const bst = 0.95047, Bst = 1, Tst = 1.08883;
      function Mst(n) {
        const { width: t, height: e } = n, i = new Uint8Array(t * e * 3);
        for (let r = 0, a = 0; r < n.length; r += 3, a += 3) {
          const o = n[r + 0], s = n[r + 1] << 24 >> 24, l = n[r + 2] << 24 >> 24;
          let u = (o + 16) / 116, h = s / 500 + u, c = u - l / 200, f, g, d;
          h = bst * (h * h * h > 8856e-6 ? h * h * h : (h - 16 / 116) / 7.787), u = Bst * (u * u * u > 8856e-6 ? u * u * u : (u - 16 / 116) / 7.787), c = Tst * (c * c * c > 8856e-6 ? c * c * c : (c - 16 / 116) / 7.787), f = h * 3.2406 + u * -1.5372 + c * -0.4986, g = h * -0.9689 + u * 1.8758 + c * 0.0415, d = h * 0.0557 + u * -0.204 + c * 1.057, f = f > 31308e-7 ? 1.055 * _i(f, 1 / 2.4) - 0.055 : 12.92 * f, g = g > 31308e-7 ? 1.055 * _i(g, 1 / 2.4) - 0.055 : 12.92 * g, d = d > 31308e-7 ? 1.055 * _i(d, 1 / 2.4) - 0.055 : 12.92 * d, i[a] = Math.max(0, Math.min(1, f)) * 255, i[a + 1] = Math.max(0, Math.min(1, g)) * 255, i[a + 2] = Math.max(0, Math.min(1, d)) * 255;
        }
        return i;
      }
      const gQ = /* @__PURE__ */ new Map();
      function Tl(n, t) {
        Array.isArray(n) || (n = [n]), n.forEach((e) => gQ.set(e, t));
      }
      function dQ(n) {
        return Rt(this, null, function* () {
          const t = gQ.get(n.Compression);
          if (!t) throw new Error(`Unknown compression method identifier: ${n.Compression}`);
          const e = yield t();
          return new e(n);
        });
      }
      Tl([void 0, 1], () => Promise.resolve().then(() => lQt).then((n) => n.default)), Tl(5, () => Promise.resolve().then(() => gQt).then((n) => n.default)), Tl(6, () => {
        throw new Error("old style JPEG compression is not supported.");
      }), Tl(7, () => Promise.resolve().then(() => yQt).then((n) => n.default)), Tl([8, 32946], () => Promise.resolve().then(() => z3t).then((n) => n.default)), Tl(32773, () => Promise.resolve().then(() => U3t).then((n) => n.default)), Tl(34887, () => Promise.resolve().then(() => Y3t).then((n) => Rt(this, null, function* () {
        return yield n.zstd.init(), n;
      })).then((n) => n.default)), Tl(50001, () => Promise.resolve().then(() => X3t).then((n) => n.default));
      function gm(n, t, e, i = 1) {
        return new (Object.getPrototypeOf(n)).constructor(t * e * i);
      }
      function Dst(n, t, e, i, r) {
        const a = t / i, o = e / r;
        return n.map((s) => {
          const l = gm(s, i, r);
          for (let u = 0; u < r; ++u) {
            const h = Math.min(Math.round(o * u), e - 1);
            for (let c = 0; c < i; ++c) {
              const f = Math.min(Math.round(a * c), t - 1), g = s[h * t + f];
              l[u * i + c] = g;
            }
          }
          return l;
        });
      }
      function Nf(n, t, e) {
        return (1 - e) * n + e * t;
      }
      function Rst(n, t, e, i, r) {
        const a = t / i, o = e / r;
        return n.map((s) => {
          const l = gm(s, i, r);
          for (let u = 0; u < r; ++u) {
            const h = o * u, c = Math.floor(h), f = Math.min(Math.ceil(h), e - 1);
            for (let g = 0; g < i; ++g) {
              const d = a * g, A = d % 1, p = Math.floor(d), v = Math.min(Math.ceil(d), t - 1), y = s[c * t + p], m = s[c * t + v], _ = s[f * t + p], E = s[f * t + v], I = Nf(Nf(y, m, A), Nf(_, E, A), h % 1);
              l[u * i + g] = I;
            }
          }
          return l;
        });
      }
      function Lst(n, t, e, i, r, a = "nearest") {
        switch (a.toLowerCase()) {
          case "nearest":
            return Dst(n, t, e, i, r);
          case "bilinear":
          case "linear":
            return Rst(n, t, e, i, r);
          default:
            throw new Error(`Unsupported resampling method: '${a}'`);
        }
      }
      function Pst(n, t, e, i, r, a) {
        const o = t / i, s = e / r, l = gm(n, i, r, a);
        for (let u = 0; u < r; ++u) {
          const h = Math.min(Math.round(s * u), e - 1);
          for (let c = 0; c < i; ++c) {
            const f = Math.min(Math.round(o * c), t - 1);
            for (let g = 0; g < a; ++g) {
              const d = n[h * t * a + f * a + g];
              l[u * i * a + c * a + g] = d;
            }
          }
        }
        return l;
      }
      function Nst(n, t, e, i, r, a) {
        const o = t / i, s = e / r, l = gm(n, i, r, a);
        for (let u = 0; u < r; ++u) {
          const h = s * u, c = Math.floor(h), f = Math.min(Math.ceil(h), e - 1);
          for (let g = 0; g < i; ++g) {
            const d = o * g, A = d % 1, p = Math.floor(d), v = Math.min(Math.ceil(d), t - 1);
            for (let y = 0; y < a; ++y) {
              const m = n[c * t * a + p * a + y], _ = n[c * t * a + v * a + y], E = n[f * t * a + p * a + y], I = n[f * t * a + v * a + y], x = Nf(Nf(m, _, A), Nf(E, I, A), h % 1);
              l[u * i * a + g * a + y] = x;
            }
          }
        }
        return l;
      }
      function kst(n, t, e, i, r, a, o = "nearest") {
        switch (o.toLowerCase()) {
          case "nearest":
            return Pst(n, t, e, i, r, a);
          case "bilinear":
          case "linear":
            return Nst(n, t, e, i, r, a);
          default:
            throw new Error(`Unsupported resampling method: '${o}'`);
        }
      }
      function Fst(n, t, e) {
        let i = 0;
        for (let r = t; r < e; ++r) i += n[r];
        return i;
      }
      function vC(n, t, e) {
        switch (n) {
          case 1:
            if (t <= 8) return new Uint8Array(e);
            if (t <= 16) return new Uint16Array(e);
            if (t <= 32) return new Uint32Array(e);
            break;
          case 2:
            if (t === 8) return new Int8Array(e);
            if (t === 16) return new Int16Array(e);
            if (t === 32) return new Int32Array(e);
            break;
          case 3:
            switch (t) {
              case 16:
              case 32:
                return new Float32Array(e);
              case 64:
                return new Float64Array(e);
            }
            break;
        }
        throw Error("Unsupported data format/bitsPerSample");
      }
      function Qst(n, t) {
        return (n === 1 || n === 2) && t <= 32 && t % 8 === 0 ? false : !(n === 3 && (t === 16 || t === 32 || t === 64));
      }
      function Ost(n, t, e, i, r, a, o) {
        const s = new DataView(n), l = e === 2 ? o * a : o * a * i, u = e === 2 ? 1 : i, h = vC(t, r, l), c = parseInt("1".repeat(r), 2);
        if (t === 1) {
          let f;
          e === 1 ? f = i * r : f = r;
          let g = a * f;
          g & 7 && (g = g + 7 & -8);
          for (let d = 0; d < o; ++d) {
            const A = d * g;
            for (let p = 0; p < a; ++p) {
              const v = A + p * u * r;
              for (let y = 0; y < u; ++y) {
                const m = v + y * r, _ = (d * a + p) * u + y, E = Math.floor(m / 8), I = m % 8;
                if (I + r <= 8) h[_] = s.getUint8(E) >> 8 - r - I & c;
                else if (I + r <= 16) h[_] = s.getUint16(E) >> 16 - r - I & c;
                else if (I + r <= 24) {
                  const x = s.getUint16(E) << 8 | s.getUint8(E + 2);
                  h[_] = x >> 24 - r - I & c;
                } else h[_] = s.getUint32(E) >> 32 - r - I & c;
              }
            }
          }
        }
        return h.buffer;
      }
      class AQ {
        constructor(t, e, i, r, a, o) {
          this.fileDirectory = t, this.geoKeys = e, this.dataView = i, this.littleEndian = r, this.tiles = a ? {} : null, this.isTiled = !t.StripOffsets;
          const s = t.PlanarConfiguration;
          if (this.planarConfiguration = typeof s == "undefined" ? 1 : s, this.planarConfiguration !== 1 && this.planarConfiguration !== 2) throw new Error("Invalid planar configuration.");
          this.source = o;
        }
        getFileDirectory() {
          return this.fileDirectory;
        }
        getGeoKeys() {
          return this.geoKeys;
        }
        getWidth() {
          return this.fileDirectory.ImageWidth;
        }
        getHeight() {
          return this.fileDirectory.ImageLength;
        }
        getSamplesPerPixel() {
          return typeof this.fileDirectory.SamplesPerPixel != "undefined" ? this.fileDirectory.SamplesPerPixel : 1;
        }
        getTileWidth() {
          return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();
        }
        getTileHeight() {
          return this.isTiled ? this.fileDirectory.TileLength : typeof this.fileDirectory.RowsPerStrip != "undefined" ? Math.min(this.fileDirectory.RowsPerStrip, this.getHeight()) : this.getHeight();
        }
        getBlockWidth() {
          return this.getTileWidth();
        }
        getBlockHeight(t) {
          return this.isTiled || (t + 1) * this.getTileHeight() <= this.getHeight() ? this.getTileHeight() : this.getHeight() - t * this.getTileHeight();
        }
        getBytesPerPixel() {
          let t = 0;
          for (let e = 0; e < this.fileDirectory.BitsPerSample.length; ++e) t += this.getSampleByteSize(e);
          return t;
        }
        getSampleByteSize(t) {
          if (t >= this.fileDirectory.BitsPerSample.length) throw new RangeError(`Sample index ${t} is out of range.`);
          return Math.ceil(this.fileDirectory.BitsPerSample[t] / 8);
        }
        getReaderForSample(t) {
          const e = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[t] : 1, i = this.fileDirectory.BitsPerSample[t];
          switch (e) {
            case 1:
              if (i <= 8) return DataView.prototype.getUint8;
              if (i <= 16) return DataView.prototype.getUint16;
              if (i <= 32) return DataView.prototype.getUint32;
              break;
            case 2:
              if (i <= 8) return DataView.prototype.getInt8;
              if (i <= 16) return DataView.prototype.getInt16;
              if (i <= 32) return DataView.prototype.getInt32;
              break;
            case 3:
              switch (i) {
                case 16:
                  return function(r, a) {
                    return rQ(this, r, a);
                  };
                case 32:
                  return DataView.prototype.getFloat32;
                case 64:
                  return DataView.prototype.getFloat64;
              }
              break;
          }
          throw Error("Unsupported data format/bitsPerSample");
        }
        getSampleFormat(t = 0) {
          return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[t] : 1;
        }
        getBitsPerSample(t = 0) {
          return this.fileDirectory.BitsPerSample[t];
        }
        getArrayForSample(t, e) {
          const i = this.getSampleFormat(t), r = this.getBitsPerSample(t);
          return vC(i, r, e);
        }
        getTileOrStrip(t, e, i, r, a) {
          return Rt(this, null, function* () {
            const o = Math.ceil(this.getWidth() / this.getTileWidth()), s = Math.ceil(this.getHeight() / this.getTileHeight());
            let l;
            const { tiles: u } = this;
            this.planarConfiguration === 1 ? l = e * o + t : this.planarConfiguration === 2 && (l = i * o * s + e * o + t);
            let h, c;
            this.isTiled ? (h = this.fileDirectory.TileOffsets[l], c = this.fileDirectory.TileByteCounts[l]) : (h = this.fileDirectory.StripOffsets[l], c = this.fileDirectory.StripByteCounts[l]);
            const f = (yield this.source.fetch([{ offset: h, length: c }], a))[0];
            let g;
            return u === null || !u[l] ? (g = Rt(this, null, function* () {
              let d = yield r.decode(this.fileDirectory, f);
              const A = this.getSampleFormat(), p = this.getBitsPerSample();
              return Qst(A, p) && (d = Ost(d, A, this.planarConfiguration, this.getSamplesPerPixel(), p, this.getTileWidth(), this.getBlockHeight(e))), d;
            }), u !== null && (u[l] = g)) : g = u[l], { x: t, y: e, sample: i, data: yield g };
          });
        }
        _readRaster(t, e, i, r, a, o, s, l, u) {
          return Rt(this, null, function* () {
            const h = this.getTileWidth(), c = this.getTileHeight(), f = this.getWidth(), g = this.getHeight(), d = Math.max(Math.floor(t[0] / h), 0), A = Math.min(Math.ceil(t[2] / h), Math.ceil(f / h)), p = Math.max(Math.floor(t[1] / c), 0), v = Math.min(Math.ceil(t[3] / c), Math.ceil(g / c)), y = t[2] - t[0];
            let m = this.getBytesPerPixel();
            const _ = [], E = [];
            for (let w = 0; w < e.length; ++w) this.planarConfiguration === 1 ? _.push(Fst(this.fileDirectory.BitsPerSample, 0, e[w]) / 8) : _.push(0), E.push(this.getReaderForSample(e[w]));
            const I = [], { littleEndian: x } = this;
            for (let w = p; w < v; ++w) for (let C = d; C < A; ++C) {
              let S;
              this.planarConfiguration === 1 && (S = this.getTileOrStrip(C, w, 0, a, u));
              for (let b = 0; b < e.length; ++b) {
                const B = b, T = e[b];
                this.planarConfiguration === 2 && (m = this.getSampleByteSize(T), S = this.getTileOrStrip(C, w, T, a, u));
                const D = S.then((R) => {
                  const L = R.data, k = new DataView(L), P = this.getBlockHeight(R.y), F = R.y * c, Q = R.x * h, z = F + P, j = (R.x + 1) * h, $ = E[B], G = Math.min(P, P - (z - t[3]), g - F), tt = Math.min(h, h - (j - t[2]), f - Q);
                  for (let J = Math.max(0, t[1] - F); J < G; ++J) for (let et = Math.max(0, t[0] - Q); et < tt; ++et) {
                    const nt = (J * h + et) * m, gt = $.call(k, nt + _[B], x);
                    let H;
                    r ? (H = (J + F - t[1]) * y * e.length + (et + Q - t[0]) * e.length + B, i[H] = gt) : (H = (J + F - t[1]) * y + et + Q - t[0], i[B][H] = gt);
                  }
                });
                I.push(D);
              }
            }
            if (yield Promise.all(I), o && t[2] - t[0] !== o || s && t[3] - t[1] !== s) {
              let w;
              return r ? w = kst(i, t[2] - t[0], t[3] - t[1], o, s, e.length, l) : w = Lst(i, t[2] - t[0], t[3] - t[1], o, s, l), w.width = o, w.height = s, w;
            }
            return i.width = o || t[2] - t[0], i.height = s || t[3] - t[1], i;
          });
        }
        readRasters() {
          return Rt(this, arguments, function* ({ window: t, samples: e = [], interleave: i, pool: r = null, width: a, height: o, resampleMethod: s, fillValue: l, signal: u } = {}) {
            const h = t || [0, 0, this.getWidth(), this.getHeight()];
            if (h[0] > h[2] || h[1] > h[3]) throw new Error("Invalid subsets");
            const c = h[2] - h[0], f = h[3] - h[1], g = c * f, d = this.getSamplesPerPixel();
            if (!e || !e.length) for (let y = 0; y < d; ++y) e.push(y);
            else for (let y = 0; y < e.length; ++y) if (e[y] >= d) return Promise.reject(new RangeError(`Invalid sample index '${e[y]}'.`));
            let A;
            if (i) {
              const y = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1, m = Math.max.apply(null, this.fileDirectory.BitsPerSample);
              A = vC(y, m, g * e.length), l && A.fill(l);
            } else {
              A = [];
              for (let y = 0; y < e.length; ++y) {
                const m = this.getArrayForSample(e[y], g);
                Array.isArray(l) && y < l.length ? m.fill(l[y]) : l && !Array.isArray(l) && m.fill(l), A.push(m);
              }
            }
            const p = r || (yield dQ(this.fileDirectory));
            return yield this._readRaster(h, e, A, i, p, a, o, s, u);
          });
        }
        readRGB() {
          return Rt(this, arguments, function* ({ window: t, interleave: e = true, pool: i = null, width: r, height: a, resampleMethod: o, enableAlpha: s = false, signal: l } = {}) {
            const u = t || [0, 0, this.getWidth(), this.getHeight()];
            if (u[0] > u[2] || u[1] > u[3]) throw new Error("Invalid subsets");
            const h = this.fileDirectory.PhotometricInterpretation;
            if (h === cr.RGB) {
              let v = [0, 1, 2];
              if (this.fileDirectory.ExtraSamples !== mst.Unspecified && s) {
                v = [];
                for (let y = 0; y < this.fileDirectory.BitsPerSample.length; y += 1) v.push(y);
              }
              return this.readRasters({ window: t, interleave: e, samples: v, pool: i, width: r, height: a, resampleMethod: o, signal: l });
            }
            let c;
            switch (h) {
              case cr.WhiteIsZero:
              case cr.BlackIsZero:
              case cr.Palette:
                c = [0];
                break;
              case cr.CMYK:
                c = [0, 1, 2, 3];
                break;
              case cr.YCbCr:
              case cr.CIELab:
                c = [0, 1, 2];
                break;
              default:
                throw new Error("Invalid or unsupported photometric interpretation.");
            }
            const f = { window: u, interleave: true, samples: c, pool: i, width: r, height: a, resampleMethod: o, signal: l }, { fileDirectory: g } = this, d = yield this.readRasters(f), A = _i(2, this.fileDirectory.BitsPerSample[0]);
            let p;
            switch (h) {
              case cr.WhiteIsZero:
                p = Est(d, A);
                break;
              case cr.BlackIsZero:
                p = xst(d, A);
                break;
              case cr.Palette:
                p = wst(d, g.ColorMap);
                break;
              case cr.CMYK:
                p = Cst(d);
                break;
              case cr.YCbCr:
                p = Sst(d);
                break;
              case cr.CIELab:
                p = Mst(d);
                break;
              default:
                throw new Error("Unsupported photometric interpretation.");
            }
            if (!e) {
              const v = new Uint8Array(p.length / 3), y = new Uint8Array(p.length / 3), m = new Uint8Array(p.length / 3);
              for (let _ = 0, E = 0; _ < p.length; _ += 3, ++E) v[E] = p[_], y[E] = p[_ + 1], m[E] = p[_ + 2];
              p = [v, y, m];
            }
            return p.width = d.width, p.height = d.height, p;
          });
        }
        getTiePoints() {
          if (!this.fileDirectory.ModelTiepoint) return [];
          const t = [];
          for (let e = 0; e < this.fileDirectory.ModelTiepoint.length; e += 6) t.push({ i: this.fileDirectory.ModelTiepoint[e], j: this.fileDirectory.ModelTiepoint[e + 1], k: this.fileDirectory.ModelTiepoint[e + 2], x: this.fileDirectory.ModelTiepoint[e + 3], y: this.fileDirectory.ModelTiepoint[e + 4], z: this.fileDirectory.ModelTiepoint[e + 5] });
          return t;
        }
        getGDALMetadata(t = null) {
          const e = {};
          if (!this.fileDirectory.GDAL_METADATA) return null;
          const i = this.fileDirectory.GDAL_METADATA;
          let r = vst(i, "Item");
          t === null ? r = r.filter((a) => lC(a, "sample") === void 0) : r = r.filter((a) => Number(lC(a, "sample")) === t);
          for (let a = 0; a < r.length; ++a) {
            const o = r[a];
            e[lC(o, "name")] = o.inner;
          }
          return e;
        }
        getGDALNoData() {
          if (!this.fileDirectory.GDAL_NODATA) return null;
          const t = this.fileDirectory.GDAL_NODATA;
          return Number(t.substring(0, t.length - 1));
        }
        getOrigin() {
          const t = this.fileDirectory.ModelTiepoint, e = this.fileDirectory.ModelTransformation;
          if (t && t.length === 6) return [t[3], t[4], t[5]];
          if (e) return [e[3], e[7], e[11]];
          throw new Error("The image does not have an affine transformation.");
        }
        getResolution(t = null) {
          const e = this.fileDirectory.ModelPixelScale, i = this.fileDirectory.ModelTransformation;
          if (e) return [e[0], -e[1], e[2]];
          if (i) return i[1] === 0 && i[4] === 0 ? [i[0], -i[5], i[10]] : [Math.sqrt(i[0] * i[0] + i[4] * i[4]), -Math.sqrt(i[1] * i[1] + i[5] * i[5]), i[10]];
          if (t) {
            const [r, a, o] = t.getResolution();
            return [r * t.getWidth() / this.getWidth(), a * t.getHeight() / this.getHeight(), o * t.getWidth() / this.getWidth()];
          }
          throw new Error("The image does not have an affine transformation.");
        }
        pixelIsArea() {
          return this.geoKeys.GTRasterTypeGeoKey === 1;
        }
        getBoundingBox(t = false) {
          const e = this.getHeight(), i = this.getWidth();
          if (this.fileDirectory.ModelTransformation && !t) {
            const [r, a, o, s, l, u, h, c] = this.fileDirectory.ModelTransformation, g = [[0, 0], [0, e], [i, 0], [i, e]].map(([p, v]) => [s + r * p + a * v, c + l * p + u * v]), d = g.map((p) => p[0]), A = g.map((p) => p[1]);
            return [Math.min(...d), Math.min(...A), Math.max(...d), Math.max(...A)];
          } else {
            const r = this.getOrigin(), a = this.getResolution(), o = r[0], s = r[1], l = o + a[0] * i, u = s + a[1] * e;
            return [Math.min(o, l), Math.min(s, u), Math.max(o, l), Math.max(s, u)];
          }
        }
      }
      class zst {
        constructor(t) {
          this._dataView = new DataView(t);
        }
        get buffer() {
          return this._dataView.buffer;
        }
        getUint64(t, e) {
          const i = this.getUint32(t, e), r = this.getUint32(t + 4, e);
          let a;
          if (e) {
            if (a = i + _i(2, 32) * r, !Number.isSafeInteger(a)) throw new Error(`${a} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
            return a;
          }
          if (a = _i(2, 32) * i + r, !Number.isSafeInteger(a)) throw new Error(`${a} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
          return a;
        }
        getInt64(t, e) {
          let i = 0;
          const r = (this._dataView.getUint8(t + (e ? 7 : 0)) & 128) > 0;
          let a = true;
          for (let o = 0; o < 8; o++) {
            let s = this._dataView.getUint8(t + (e ? o : 7 - o));
            r && (a ? s !== 0 && (s = ~(s - 1) & 255, a = false) : s = ~s & 255), i += s * _i(256, o);
          }
          return r && (i = -i), i;
        }
        getUint8(t, e) {
          return this._dataView.getUint8(t, e);
        }
        getInt8(t, e) {
          return this._dataView.getInt8(t, e);
        }
        getUint16(t, e) {
          return this._dataView.getUint16(t, e);
        }
        getInt16(t, e) {
          return this._dataView.getInt16(t, e);
        }
        getUint32(t, e) {
          return this._dataView.getUint32(t, e);
        }
        getInt32(t, e) {
          return this._dataView.getInt32(t, e);
        }
        getFloat16(t, e) {
          return rQ(this._dataView, t, e);
        }
        getFloat32(t, e) {
          return this._dataView.getFloat32(t, e);
        }
        getFloat64(t, e) {
          return this._dataView.getFloat64(t, e);
        }
      }
      class Gst {
        constructor(t, e, i, r) {
          this._dataView = new DataView(t), this._sliceOffset = e, this._littleEndian = i, this._bigTiff = r;
        }
        get sliceOffset() {
          return this._sliceOffset;
        }
        get sliceTop() {
          return this._sliceOffset + this.buffer.byteLength;
        }
        get littleEndian() {
          return this._littleEndian;
        }
        get bigTiff() {
          return this._bigTiff;
        }
        get buffer() {
          return this._dataView.buffer;
        }
        covers(t, e) {
          return this.sliceOffset <= t && this.sliceTop >= t + e;
        }
        readUint8(t) {
          return this._dataView.getUint8(t - this._sliceOffset, this._littleEndian);
        }
        readInt8(t) {
          return this._dataView.getInt8(t - this._sliceOffset, this._littleEndian);
        }
        readUint16(t) {
          return this._dataView.getUint16(t - this._sliceOffset, this._littleEndian);
        }
        readInt16(t) {
          return this._dataView.getInt16(t - this._sliceOffset, this._littleEndian);
        }
        readUint32(t) {
          return this._dataView.getUint32(t - this._sliceOffset, this._littleEndian);
        }
        readInt32(t) {
          return this._dataView.getInt32(t - this._sliceOffset, this._littleEndian);
        }
        readFloat32(t) {
          return this._dataView.getFloat32(t - this._sliceOffset, this._littleEndian);
        }
        readFloat64(t) {
          return this._dataView.getFloat64(t - this._sliceOffset, this._littleEndian);
        }
        readUint64(t) {
          const e = this.readUint32(t), i = this.readUint32(t + 4);
          let r;
          if (this._littleEndian) {
            if (r = e + _i(2, 32) * i, !Number.isSafeInteger(r)) throw new Error(`${r} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
            return r;
          }
          if (r = _i(2, 32) * e + i, !Number.isSafeInteger(r)) throw new Error(`${r} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
          return r;
        }
        readInt64(t) {
          let e = 0;
          const i = (this._dataView.getUint8(t + (this._littleEndian ? 7 : 0)) & 128) > 0;
          let r = true;
          for (let a = 0; a < 8; a++) {
            let o = this._dataView.getUint8(t + (this._littleEndian ? a : 7 - a));
            i && (r ? o !== 0 && (o = ~(o - 1) & 255, r = false) : o = ~o & 255), e += o * _i(256, a);
          }
          return i && (e = -e), e;
        }
        readOffset(t) {
          return this._bigTiff ? this.readUint64(t) : this.readUint32(t);
        }
      }
      const Ust = typeof navigator != "undefined" && navigator.hardwareConcurrency || 2;
      class Vst {
        constructor(t = Ust, e) {
          this.workers = null, this._awaitingDecoder = null, this.size = t, this.messageId = 0, t && (this._awaitingDecoder = e ? Promise.resolve(e) : new Promise((i) => {
            Promise.resolve().then(() => $3t).then((r) => {
              i(r.create);
            });
          }), this._awaitingDecoder.then((i) => {
            this._awaitingDecoder = null, this.workers = [];
            for (let r = 0; r < t; r++) this.workers.push({ worker: i(), idle: true });
          }));
        }
        decode(t, e) {
          return Rt(this, null, function* () {
            return this._awaitingDecoder && (yield this._awaitingDecoder), this.size === 0 ? dQ(t).then((i) => i.decode(t, e)) : new Promise((i) => {
              const r = this.workers.find((s) => s.idle) || this.workers[Math.floor(Math.random() * this.size)];
              r.idle = false;
              const a = this.messageId++, o = (s) => {
                s.data.id === a && (r.idle = true, i(s.data.decoded), r.worker.removeEventListener("message", o));
              };
              r.worker.addEventListener("message", o), r.worker.postMessage({ fileDirectory: t, buffer: e, id: a }, [e]);
            });
          });
        }
        destroy() {
          this.workers && (this.workers.forEach((t) => {
            t.worker.terminate();
          }), this.workers = null);
        }
      }
      const pQ = `\r
\r
`;
      function vQ(n) {
        if (typeof Object.fromEntries != "undefined") return Object.fromEntries(n);
        const t = {};
        for (const [e, i] of n) t[e.toLowerCase()] = i;
        return t;
      }
      function jst(n) {
        const t = n.split(`\r
`).map((e) => {
          const i = e.split(":").map((r) => r.trim());
          return i[0] = i[0].toLowerCase(), i;
        });
        return vQ(t);
      }
      function qst(n) {
        const [t, ...e] = n.split(";").map((r) => r.trim()), i = e.map((r) => r.split("="));
        return { type: t, params: vQ(i) };
      }
      function yC(n) {
        let t, e, i;
        return n && ([, t, e, i] = n.match(/bytes (\d+)-(\d+)\/(\d+)/), t = parseInt(t, 10), e = parseInt(e, 10), i = parseInt(i, 10)), { start: t, end: e, total: i };
      }
      function Hst(n, t) {
        let e = null;
        const i = new TextDecoder("ascii"), r = [], a = `--${t}`, o = `${a}--`;
        for (let s = 0; s < 10; ++s) i.decode(new Uint8Array(n, s, a.length)) === a && (e = s);
        if (e === null) throw new Error("Could not find initial boundary");
        for (; e < n.byteLength; ) {
          const s = i.decode(new Uint8Array(n, e, Math.min(a.length + 1024, n.byteLength - e)));
          if (s.length === 0 || s.startsWith(o)) break;
          if (!s.startsWith(a)) throw new Error("Part does not start with boundary");
          const l = s.substr(a.length + 2);
          if (l.length === 0) break;
          const u = l.indexOf(pQ), h = jst(l.substr(0, u)), { start: c, end: f, total: g } = yC(h["content-range"]), d = e + a.length + u + pQ.length, A = parseInt(f, 10) + 1 - parseInt(c, 10);
          r.push({ headers: h, data: n.slice(d, d + A), offset: c, length: A, fileSize: g }), e = d + A + 4;
        }
        return r;
      }
      class mC {
        fetch(t, e = void 0) {
          return Rt(this, null, function* () {
            return Promise.all(t.map((i) => this.fetchSlice(i, e)));
          });
        }
        fetchSlice(t) {
          return Rt(this, null, function* () {
            throw new Error(`fetching of slice ${t} not possible, not implemented`);
          });
        }
        get fileSize() {
          return null;
        }
        close() {
          return Rt(this, null, function* () {
          });
        }
      }
      class Yst extends Map {
        constructor(t = {}) {
          if (super(), !(t.maxSize && t.maxSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
          if (typeof t.maxAge == "number" && t.maxAge === 0) throw new TypeError("`maxAge` must be a number greater than 0");
          this.maxSize = t.maxSize, this.maxAge = t.maxAge || Number.POSITIVE_INFINITY, this.onEviction = t.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
        }
        _emitEvictions(t) {
          if (typeof this.onEviction == "function") for (const [e, i] of t) this.onEviction(e, i.value);
        }
        _deleteIfExpired(t, e) {
          return typeof e.expiry == "number" && e.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(t, e.value), this.delete(t)) : false;
        }
        _getOrDeleteIfExpired(t, e) {
          if (this._deleteIfExpired(t, e) === false) return e.value;
        }
        _getItemValue(t, e) {
          return e.expiry ? this._getOrDeleteIfExpired(t, e) : e.value;
        }
        _peek(t, e) {
          const i = e.get(t);
          return this._getItemValue(t, i);
        }
        _set(t, e) {
          this.cache.set(t, e), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
        }
        _moveToRecent(t, e) {
          this.oldCache.delete(t), this._set(t, e);
        }
        *_entriesAscending() {
          for (const t of this.oldCache) {
            const [e, i] = t;
            this.cache.has(e) || this._deleteIfExpired(e, i) === false && (yield t);
          }
          for (const t of this.cache) {
            const [e, i] = t;
            this._deleteIfExpired(e, i) === false && (yield t);
          }
        }
        get(t) {
          if (this.cache.has(t)) {
            const e = this.cache.get(t);
            return this._getItemValue(t, e);
          }
          if (this.oldCache.has(t)) {
            const e = this.oldCache.get(t);
            if (this._deleteIfExpired(t, e) === false) return this._moveToRecent(t, e), e.value;
          }
        }
        set(t, e, { maxAge: i = this.maxAge } = {}) {
          const r = typeof i == "number" && i !== Number.POSITIVE_INFINITY ? Date.now() + i : void 0;
          return this.cache.has(t) ? this.cache.set(t, { value: e, expiry: r }) : this._set(t, { value: e, expiry: r }), this;
        }
        has(t) {
          return this.cache.has(t) ? !this._deleteIfExpired(t, this.cache.get(t)) : this.oldCache.has(t) ? !this._deleteIfExpired(t, this.oldCache.get(t)) : false;
        }
        peek(t) {
          if (this.cache.has(t)) return this._peek(t, this.cache);
          if (this.oldCache.has(t)) return this._peek(t, this.oldCache);
        }
        delete(t) {
          const e = this.cache.delete(t);
          return e && this._size--, this.oldCache.delete(t) || e;
        }
        clear() {
          this.cache.clear(), this.oldCache.clear(), this._size = 0;
        }
        resize(t) {
          if (!(t && t > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
          const e = [...this._entriesAscending()], i = e.length - t;
          i < 0 ? (this.cache = new Map(e), this.oldCache = /* @__PURE__ */ new Map(), this._size = e.length) : (i > 0 && this._emitEvictions(e.slice(0, i)), this.oldCache = new Map(e.slice(i)), this.cache = /* @__PURE__ */ new Map(), this._size = 0), this.maxSize = t;
        }
        *keys() {
          for (const [t] of this) yield t;
        }
        *values() {
          for (const [, t] of this) yield t;
        }
        *[Symbol.iterator]() {
          for (const t of this.cache) {
            const [e, i] = t;
            this._deleteIfExpired(e, i) === false && (yield [e, i.value]);
          }
          for (const t of this.oldCache) {
            const [e, i] = t;
            this.cache.has(e) || this._deleteIfExpired(e, i) === false && (yield [e, i.value]);
          }
        }
        *entriesDescending() {
          let t = [...this.cache];
          for (let e = t.length - 1; e >= 0; --e) {
            const i = t[e], [r, a] = i;
            this._deleteIfExpired(r, a) === false && (yield [r, a.value]);
          }
          t = [...this.oldCache];
          for (let e = t.length - 1; e >= 0; --e) {
            const i = t[e], [r, a] = i;
            this.cache.has(r) || this._deleteIfExpired(r, a) === false && (yield [r, a.value]);
          }
        }
        *entriesAscending() {
          for (const [t, e] of this._entriesAscending()) yield [t, e.value];
        }
        get size() {
          if (!this._size) return this.oldCache.size;
          let t = 0;
          for (const e of this.oldCache.keys()) this.cache.has(e) || t++;
          return Math.min(this._size + t, this.maxSize);
        }
        entries() {
          return this.entriesAscending();
        }
        forEach(t, e = this) {
          for (const [i, r] of this.entriesAscending()) t.call(e, r, i, this);
        }
        get [Symbol.toStringTag]() {
          return JSON.stringify([...this.entriesAscending()]);
        }
      }
      function Wst(n) {
        return Rt(this, null, function* () {
          return new Promise((t) => setTimeout(t, n));
        });
      }
      function Xst(n, t) {
        const e = Array.isArray(n) ? n : Array.from(n), i = Array.isArray(t) ? t : Array.from(t);
        return e.map((r, a) => [r, i[a]]);
      }
      class kf extends Error {
        constructor(t) {
          super(t), Error.captureStackTrace && Error.captureStackTrace(this, kf), this.name = "AbortError";
        }
      }
      class Zst extends Error {
        constructor(t, e) {
          super(e), this.errors = t, this.message = e, this.name = "AggregateError";
        }
      }
      const Kst = Zst;
      class $st {
        constructor(t, e, i = null) {
          this.offset = t, this.length = e, this.data = i;
        }
        get top() {
          return this.offset + this.length;
        }
      }
      class yQ {
        constructor(t, e, i) {
          this.offset = t, this.length = e, this.blockIds = i;
        }
      }
      class Jst extends mC {
        constructor(t, { blockSize: e = 65536, cacheSize: i = 100 } = {}) {
          super(), this.source = t, this.blockSize = e, this.blockCache = new Yst({ maxSize: i, onEviction: (r, a) => {
            this.evictedBlocks.set(r, a);
          } }), this.evictedBlocks = /* @__PURE__ */ new Map(), this.blockRequests = /* @__PURE__ */ new Map(), this.blockIdsToFetch = /* @__PURE__ */ new Set(), this.abortedBlockIds = /* @__PURE__ */ new Set();
        }
        get fileSize() {
          return this.source.fileSize;
        }
        fetch(t, e) {
          return Rt(this, null, function* () {
            const i = [], r = [], a = [];
            this.evictedBlocks.clear();
            for (const { offset: f, length: g } of t) {
              let d = f + g;
              const { fileSize: A } = this;
              A !== null && (d = Math.min(d, A));
              const p = Math.floor(f / this.blockSize) * this.blockSize;
              for (let v = p; v < d; v += this.blockSize) {
                const y = Math.floor(v / this.blockSize);
                !this.blockCache.has(y) && !this.blockRequests.has(y) && (this.blockIdsToFetch.add(y), r.push(y)), this.blockRequests.has(y) && i.push(this.blockRequests.get(y)), a.push(y);
              }
            }
            yield Wst(), this.fetchBlocks(e);
            const o = [];
            for (const f of r) this.blockRequests.has(f) && o.push(this.blockRequests.get(f));
            yield Promise.allSettled(i), yield Promise.allSettled(o);
            const s = [], l = a.filter((f) => this.abortedBlockIds.has(f) || !this.blockCache.has(f));
            if (l.forEach((f) => this.blockIdsToFetch.add(f)), l.length > 0 && e && !e.aborted) {
              this.fetchBlocks(null);
              for (const f of l) {
                const g = this.blockRequests.get(f);
                if (!g) throw new Error(`Block ${f} is not in the block requests`);
                s.push(g);
              }
              yield Promise.allSettled(s);
            }
            if (e && e.aborted) throw new kf("Request was aborted");
            const u = a.map((f) => this.blockCache.get(f) || this.evictedBlocks.get(f)), h = u.filter((f) => !f);
            if (h.length) throw new Kst(h, "Request failed");
            const c = new Map(Xst(a, u));
            return this.readSliceData(t, c);
          });
        }
        fetchBlocks(t) {
          if (this.blockIdsToFetch.size > 0) {
            const e = this.groupBlocks(this.blockIdsToFetch), i = this.source.fetch(e, t);
            for (let r = 0; r < e.length; ++r) {
              const a = e[r];
              for (const o of a.blockIds) this.blockRequests.set(o, Rt(this, null, function* () {
                try {
                  const s = (yield i)[r], l = o * this.blockSize, u = l - s.offset, h = Math.min(u + this.blockSize, s.data.byteLength), c = s.data.slice(u, h), f = new $st(l, c.byteLength, c, o);
                  this.blockCache.set(o, f), this.abortedBlockIds.delete(o);
                } catch (s) {
                  if (s.name === "AbortError") s.signal = t, this.blockCache.delete(o), this.abortedBlockIds.add(o);
                  else throw s;
                } finally {
                  this.blockRequests.delete(o);
                }
              }));
            }
            this.blockIdsToFetch.clear();
          }
        }
        groupBlocks(t) {
          const e = Array.from(t).sort((o, s) => o - s);
          if (e.length === 0) return [];
          let i = [], r = null;
          const a = [];
          for (const o of e) r === null || r + 1 === o ? (i.push(o), r = o) : (a.push(new yQ(i[0] * this.blockSize, i.length * this.blockSize, i)), i = [o], r = o);
          return a.push(new yQ(i[0] * this.blockSize, i.length * this.blockSize, i)), a;
        }
        readSliceData(t, e) {
          return t.map((i) => {
            let r = i.offset + i.length;
            this.fileSize !== null && (r = Math.min(this.fileSize, r));
            const a = Math.floor(i.offset / this.blockSize), o = Math.floor(r / this.blockSize), s = new ArrayBuffer(i.length), l = new Uint8Array(s);
            for (let u = a; u <= o; ++u) {
              const h = e.get(u), c = h.offset - i.offset, f = h.top - r;
              let g = 0, d = 0, A;
              c < 0 ? g = -c : c > 0 && (d = c), f < 0 ? A = h.length - g : A = r - h.offset - g;
              const p = new Uint8Array(h.data, g, A);
              l.set(p, d);
            }
            return s;
          });
        }
      }
      class _C {
        get ok() {
          return this.status >= 200 && this.status <= 299;
        }
        get status() {
          throw new Error("not implemented");
        }
        getHeader(t) {
          throw new Error("not implemented");
        }
        getData() {
          return Rt(this, null, function* () {
            throw new Error("not implemented");
          });
        }
      }
      class IC {
        constructor(t) {
          this.url = t;
        }
        request() {
          return Rt(this, arguments, function* ({ headers: t, signal: e } = {}) {
            throw new Error("request is not implemented");
          });
        }
      }
      class tlt extends _C {
        constructor(t) {
          super(), this.response = t;
        }
        get status() {
          return this.response.status;
        }
        getHeader(t) {
          return this.response.headers.get(t);
        }
        getData() {
          return Rt(this, null, function* () {
            return this.response.arrayBuffer ? yield this.response.arrayBuffer() : (yield this.response.buffer()).buffer;
          });
        }
      }
      class elt extends IC {
        constructor(t, e) {
          super(t), this.credentials = e;
        }
        request() {
          return Rt(this, arguments, function* ({ headers: t, signal: e } = {}) {
            const i = yield fetch(this.url, { headers: t, credentials: this.credentials, signal: e });
            return new tlt(i);
          });
        }
      }
      class nlt extends _C {
        constructor(t, e) {
          super(), this.xhr = t, this.data = e;
        }
        get status() {
          return this.xhr.status;
        }
        getHeader(t) {
          return this.xhr.getResponseHeader(t);
        }
        getData() {
          return Rt(this, null, function* () {
            return this.data;
          });
        }
      }
      class ilt extends IC {
        constructRequest(t, e) {
          return new Promise((i, r) => {
            const a = new XMLHttpRequest();
            a.open("GET", this.url), a.responseType = "arraybuffer";
            for (const [o, s] of Object.entries(t)) a.setRequestHeader(o, s);
            a.onload = () => {
              const o = a.response;
              i(new nlt(a, o));
            }, a.onerror = r, a.onabort = () => r(new kf("Request aborted")), a.send(), e && (e.aborted && a.abort(), e.addEventListener("abort", () => a.abort()));
          });
        }
        request() {
          return Rt(this, arguments, function* ({ headers: t, signal: e } = {}) {
            return yield this.constructRequest(t, e);
          });
        }
      }
      const dm = {}, rlt = Object.freeze(Object.defineProperty({ __proto__: null, default: dm }, Symbol.toStringTag, { value: "Module" }));
      class alt extends _C {
        constructor(t, e) {
          super(), this.response = t, this.dataPromise = e;
        }
        get status() {
          return this.response.statusCode;
        }
        getHeader(t) {
          return this.response.headers[t];
        }
        getData() {
          return Rt(this, null, function* () {
            return yield this.dataPromise;
          });
        }
      }
      class olt extends IC {
        constructor(t) {
          super(t), this.parsedUrl = dm.parse(this.url), this.httpApi = (this.parsedUrl.protocol === "http:", dm);
        }
        constructRequest(t, e) {
          return new Promise((i, r) => {
            const a = this.httpApi.get(zt(st({}, this.parsedUrl), { headers: t }), (o) => {
              const s = new Promise((l) => {
                const u = [];
                o.on("data", (h) => {
                  u.push(h);
                }), o.on("end", () => {
                  const h = Buffer.concat(u).buffer;
                  l(h);
                }), o.on("error", r);
              });
              i(new alt(o, s));
            });
            a.on("error", r), e && (e.aborted && a.destroy(new kf("Request aborted")), e.addEventListener("abort", () => a.destroy(new kf("Request aborted"))));
          });
        }
        request() {
          return Rt(this, arguments, function* ({ headers: t, signal: e } = {}) {
            return yield this.constructRequest(t, e);
          });
        }
      }
      class EC extends mC {
        constructor(t, e, i, r) {
          super(), this.client = t, this.headers = e, this.maxRanges = i, this.allowFullFile = r, this._fileSize = null;
        }
        fetch(t, e) {
          return Rt(this, null, function* () {
            return this.maxRanges >= t.length ? this.fetchSlices(t, e) : (this.maxRanges > 0 && t.length > 1, Promise.all(t.map((i) => this.fetchSlice(i, e))));
          });
        }
        fetchSlices(t, e) {
          return Rt(this, null, function* () {
            const i = yield this.client.request({ headers: zt(st({}, this.headers), { Range: `bytes=${t.map(({ offset: r, length: a }) => `${r}-${r + a}`).join(",")}` }), signal: e });
            if (i.ok) if (i.status === 206) {
              const { type: r, params: a } = qst(i.getHeader("content-type"));
              if (r === "multipart/byteranges") {
                const c = Hst(yield i.getData(), a.boundary);
                return this._fileSize = c[0].fileSize || null, c;
              }
              const o = yield i.getData(), { start: s, end: l, total: u } = yC(i.getHeader("content-range"));
              this._fileSize = u || null;
              const h = [{ data: o, offset: s, length: l - s }];
              if (t.length > 1) {
                const c = yield Promise.all(t.slice(1).map((f) => this.fetchSlice(f, e)));
                return h.concat(c);
              }
              return h;
            } else {
              if (!this.allowFullFile) throw new Error("Server responded with full file");
              const r = yield i.getData();
              return this._fileSize = r.byteLength, [{ data: r, offset: 0, length: r.byteLength }];
            }
            else throw new Error("Error fetching data.");
          });
        }
        fetchSlice(t, e) {
          return Rt(this, null, function* () {
            const { offset: i, length: r } = t, a = yield this.client.request({ headers: zt(st({}, this.headers), { Range: `bytes=${i}-${i + r}` }), signal: e });
            if (a.ok) if (a.status === 206) {
              const o = yield a.getData(), { total: s } = yC(a.getHeader("content-range"));
              return this._fileSize = s || null, { data: o, offset: i, length: r };
            } else {
              if (!this.allowFullFile) throw new Error("Server responded with full file");
              const o = yield a.getData();
              return this._fileSize = o.byteLength, { data: o, offset: 0, length: o.byteLength };
            }
            else throw new Error("Error fetching data.");
          });
        }
        get fileSize() {
          return this._fileSize;
        }
      }
      function xC(n, { blockSize: t, cacheSize: e }) {
        return t === null ? n : new Jst(n, { blockSize: t, cacheSize: e });
      }
      function slt(n, o = {}) {
        var s = o, { headers: t = {}, credentials: e, maxRanges: i = 0, allowFullFile: r = false } = s, a = Ny(s, ["headers", "credentials", "maxRanges", "allowFullFile"]);
        const l = new elt(n, e), u = new EC(l, t, i, r);
        return xC(u, a);
      }
      function llt(n, a = {}) {
        var o = a, { headers: t = {}, maxRanges: e = 0, allowFullFile: i = false } = o, r = Ny(o, ["headers", "maxRanges", "allowFullFile"]);
        const s = new ilt(n), l = new EC(s, t, e, i);
        return xC(l, r);
      }
      function ult(n, a = {}) {
        var o = a, { headers: t = {}, maxRanges: e = 0, allowFullFile: i = false } = o, r = Ny(o, ["headers", "maxRanges", "allowFullFile"]);
        const s = new olt(n), l = new EC(s, t, e, i);
        return xC(l, r);
      }
      function wC(n, i = {}) {
        var r = i, { forceXHR: t = false } = r, e = Ny(r, ["forceXHR"]);
        return typeof fetch == "function" && !t ? slt(n, e) : typeof XMLHttpRequest != "undefined" ? llt(n, e) : ult(n, e);
      }
      class hlt extends mC {
        constructor(t) {
          super(), this.file = t;
        }
        fetchSlice(t, e) {
          return Rt(this, null, function* () {
            return new Promise((i, r) => {
              const a = this.file.slice(t.offset, t.offset + t.length), o = new FileReader();
              o.onload = (s) => i(s.target.result), o.onerror = r, o.onabort = r, o.readAsArrayBuffer(a), e && e.addEventListener("abort", () => o.abort());
            });
          });
        }
      }
      function clt(n) {
        return new hlt(n);
      }
      function flt(n, t) {
        let e = n.length - t, i = 0;
        do {
          for (let r = t; r > 0; r--) n[i + t] += n[i], i++;
          e -= t;
        } while (e > 0);
      }
      function glt(n, t, e) {
        let i = 0, r = n.length;
        const a = r / e;
        for (; r > t; ) {
          for (let s = t; s > 0; --s) n[i + t] += n[i], ++i;
          r -= t;
        }
        const o = n.slice();
        for (let s = 0; s < a; ++s) for (let l = 0; l < e; ++l) n[e * s + l] = o[(e - l - 1) * a + s];
      }
      function dlt(n, t, e, i, r, a) {
        if (!t || t === 1) return n;
        for (let l = 0; l < r.length; ++l) {
          if (r[l] % 8 !== 0) throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");
          if (r[l] !== r[0]) throw new Error("When decoding with predictor, all samples must have the same size.");
        }
        const o = r[0] / 8, s = a === 2 ? 1 : r.length;
        for (let l = 0; l < i && !(l * s * e * o >= n.byteLength); ++l) {
          let u;
          if (t === 2) {
            switch (r[0]) {
              case 8:
                u = new Uint8Array(n, l * s * e * o, s * e * o);
                break;
              case 16:
                u = new Uint16Array(n, l * s * e * o, s * e * o / 2);
                break;
              case 32:
                u = new Uint32Array(n, l * s * e * o, s * e * o / 4);
                break;
              default:
                throw new Error(`Predictor 2 not allowed with ${r[0]} bits per sample.`);
            }
            flt(u, s);
          } else t === 3 && (u = new Uint8Array(n, l * s * e * o, s * e * o), glt(u, s, o));
        }
        return n;
      }
      class Vu {
        decode(t, e) {
          return Rt(this, null, function* () {
            const i = yield this.decodeBlock(e), r = t.Predictor || 1;
            if (r !== 1) {
              const a = !t.StripOffsets, o = a ? t.TileWidth : t.ImageWidth, s = a ? t.TileLength : t.RowsPerStrip || t.ImageLength;
              return dlt(i, r, o, s, t.BitsPerSample, t.PlanarConfiguration);
            }
            return i;
          });
        }
      }
      function CC(n) {
        switch (n) {
          case fe.BYTE:
          case fe.ASCII:
          case fe.SBYTE:
          case fe.UNDEFINED:
            return 1;
          case fe.SHORT:
          case fe.SSHORT:
            return 2;
          case fe.LONG:
          case fe.SLONG:
          case fe.FLOAT:
          case fe.IFD:
            return 4;
          case fe.RATIONAL:
          case fe.SRATIONAL:
          case fe.DOUBLE:
          case fe.LONG8:
          case fe.SLONG8:
          case fe.IFD8:
            return 8;
          default:
            throw new RangeError(`Invalid field type: ${n}`);
        }
      }
      function Alt(n) {
        const t = n.GeoKeyDirectory;
        if (!t) return null;
        const e = {};
        for (let i = 4; i <= t[3] * 4; i += 4) {
          const r = Ist[t[i]], a = t[i + 1] ? VA[t[i + 1]] : null, o = t[i + 2], s = t[i + 3];
          let l = null;
          if (!a) l = s;
          else {
            if (l = n[a], typeof l == "undefined" || l === null) throw new Error(`Could not get value of geoKey '${r}'.`);
            typeof l == "string" ? l = l.substring(s, s + o - 1) : l.subarray && (l = l.subarray(s, s + o), o === 1 && (l = l[0]));
          }
          e[r] = l;
        }
        return e;
      }
      function Ff(n, t, e, i) {
        let r = null, a = null;
        const o = CC(t);
        switch (t) {
          case fe.BYTE:
          case fe.ASCII:
          case fe.UNDEFINED:
            r = new Uint8Array(e), a = n.readUint8;
            break;
          case fe.SBYTE:
            r = new Int8Array(e), a = n.readInt8;
            break;
          case fe.SHORT:
            r = new Uint16Array(e), a = n.readUint16;
            break;
          case fe.SSHORT:
            r = new Int16Array(e), a = n.readInt16;
            break;
          case fe.LONG:
          case fe.IFD:
            r = new Uint32Array(e), a = n.readUint32;
            break;
          case fe.SLONG:
            r = new Int32Array(e), a = n.readInt32;
            break;
          case fe.LONG8:
          case fe.IFD8:
            r = new Array(e), a = n.readUint64;
            break;
          case fe.SLONG8:
            r = new Array(e), a = n.readInt64;
            break;
          case fe.RATIONAL:
            r = new Uint32Array(e * 2), a = n.readUint32;
            break;
          case fe.SRATIONAL:
            r = new Int32Array(e * 2), a = n.readInt32;
            break;
          case fe.FLOAT:
            r = new Float32Array(e), a = n.readFloat32;
            break;
          case fe.DOUBLE:
            r = new Float64Array(e), a = n.readFloat64;
            break;
          default:
            throw new RangeError(`Invalid field type: ${t}`);
        }
        if (t === fe.RATIONAL || t === fe.SRATIONAL) for (let s = 0; s < e; s += 2) r[s] = a.call(n, i + s * o), r[s + 1] = a.call(n, i + (s * o + 4));
        else for (let s = 0; s < e; ++s) r[s] = a.call(n, i + s * o);
        return t === fe.ASCII ? new TextDecoder("utf-8").decode(r) : r;
      }
      class plt {
        constructor(t, e, i) {
          this.fileDirectory = t, this.geoKeyDirectory = e, this.nextIFDByteOffset = i;
        }
      }
      class Am extends Error {
        constructor(t) {
          super(`No image at index ${t}`), this.index = t;
        }
      }
      class mQ {
        readRasters() {
          return Rt(this, arguments, function* (t = {}) {
            const { window: e, width: i, height: r } = t;
            let { resX: a, resY: o, bbox: s } = t;
            const l = yield this.getImage();
            let u = l;
            const h = yield this.getImageCount(), c = l.getBoundingBox();
            if (e && s) throw new Error('Both "bbox" and "window" passed.');
            if (i || r) {
              if (e) {
                const [d, A] = l.getOrigin(), [p, v] = l.getResolution();
                s = [d + e[0] * p, A + e[1] * v, d + e[2] * p, A + e[3] * v];
              }
              const g = s || c;
              if (i) {
                if (a) throw new Error("Both width and resX passed");
                a = (g[2] - g[0]) / i;
              }
              if (r) {
                if (o) throw new Error("Both width and resY passed");
                o = (g[3] - g[1]) / r;
              }
            }
            if (a || o) {
              const g = [];
              for (let d = 0; d < h; ++d) {
                const A = yield this.getImage(d), { SubfileType: p, NewSubfileType: v } = A.fileDirectory;
                (d === 0 || p === 2 || v & 1) && g.push(A);
              }
              g.sort((d, A) => d.getWidth() - A.getWidth());
              for (let d = 0; d < g.length; ++d) {
                const A = g[d], p = (c[2] - c[0]) / A.getWidth(), v = (c[3] - c[1]) / A.getHeight();
                if (u = A, a && a > p || o && o > v) break;
              }
            }
            let f = e;
            if (s) {
              const [g, d] = l.getOrigin(), [A, p] = u.getResolution(l);
              f = [Math.round((s[0] - g) / A), Math.round((s[1] - d) / p), Math.round((s[2] - g) / A), Math.round((s[3] - d) / p)], f = [Math.min(f[0], f[2]), Math.min(f[1], f[3]), Math.max(f[0], f[2]), Math.max(f[1], f[3])];
            }
            return u.readRasters(zt(st({}, t), { window: f }));
          });
        }
      }
      class Qf extends mQ {
        constructor(t, e, i, r, a = {}) {
          super(), this.source = t, this.littleEndian = e, this.bigTiff = i, this.firstIFDOffset = r, this.cache = a.cache || false, this.ifdRequests = [], this.ghostValues = null;
        }
        getSlice(t, e) {
          return Rt(this, null, function* () {
            const i = this.bigTiff ? 4048 : 1024;
            return new Gst((yield this.source.fetch([{ offset: t, length: typeof e != "undefined" ? e : i }]))[0], t, this.littleEndian, this.bigTiff);
          });
        }
        parseFileDirectoryAt(t) {
          return Rt(this, null, function* () {
            const e = this.bigTiff ? 20 : 12, i = this.bigTiff ? 8 : 2;
            let r = yield this.getSlice(t);
            const a = this.bigTiff ? r.readUint64(t) : r.readUint16(t), o = a * e + (this.bigTiff ? 16 : 6);
            r.covers(t, o) || (r = yield this.getSlice(t, o));
            const s = {};
            let l = t + (this.bigTiff ? 8 : 2);
            for (let c = 0; c < a; l += e, ++c) {
              const f = r.readUint16(l), g = r.readUint16(l + 2), d = this.bigTiff ? r.readUint64(l + 4) : r.readUint32(l + 4);
              let A, p;
              const v = CC(g), y = l + (this.bigTiff ? 12 : 8);
              if (v * d <= (this.bigTiff ? 8 : 4)) A = Ff(r, g, d, y);
              else {
                const m = r.readOffset(y), _ = CC(g) * d;
                if (r.covers(m, _)) A = Ff(r, g, d, m);
                else {
                  const E = yield this.getSlice(m, _);
                  A = Ff(E, g, d, m);
                }
              }
              d === 1 && yst.indexOf(f) === -1 && !(g === fe.RATIONAL || g === fe.SRATIONAL) ? p = A[0] : p = A, s[VA[f]] = p;
            }
            const u = Alt(s), h = r.readOffset(t + i + e * a);
            return new plt(s, u, h);
          });
        }
        requestIFD(t) {
          return Rt(this, null, function* () {
            if (this.ifdRequests[t]) return this.ifdRequests[t];
            if (t === 0) return this.ifdRequests[t] = this.parseFileDirectoryAt(this.firstIFDOffset), this.ifdRequests[t];
            if (!this.ifdRequests[t - 1]) try {
              this.ifdRequests[t - 1] = this.requestIFD(t - 1);
            } catch (e) {
              throw e instanceof Am ? new Am(t) : e;
            }
            return this.ifdRequests[t] = Rt(this, null, function* () {
              const e = yield this.ifdRequests[t - 1];
              if (e.nextIFDByteOffset === 0) throw new Am(t);
              return this.parseFileDirectoryAt(e.nextIFDByteOffset);
            }), this.ifdRequests[t];
          });
        }
        getImage(t = 0) {
          return Rt(this, null, function* () {
            const e = yield this.requestIFD(t);
            return new AQ(e.fileDirectory, e.geoKeyDirectory, this.dataView, this.littleEndian, this.cache, this.source);
          });
        }
        getImageCount() {
          return Rt(this, null, function* () {
            let t = 0, e = true;
            for (; e; ) try {
              yield this.requestIFD(t), ++t;
            } catch (i) {
              if (i instanceof Am) e = false;
              else throw i;
            }
            return t;
          });
        }
        getGhostValues() {
          return Rt(this, null, function* () {
            const t = this.bigTiff ? 16 : 8;
            if (this.ghostValues) return this.ghostValues;
            const e = "GDAL_STRUCTURAL_METADATA_SIZE=", i = e.length + 100;
            let r = yield this.getSlice(t, i);
            if (e === Ff(r, fe.ASCII, e.length, t)) {
              const o = Ff(r, fe.ASCII, i, t).split(`
`)[0], s = Number(o.split("=")[1].split(" ")[0]) + o.length;
              s > i && (r = yield this.getSlice(t, s));
              const l = Ff(r, fe.ASCII, s, t);
              this.ghostValues = {}, l.split(`
`).filter((u) => u.length > 0).map((u) => u.split("=")).forEach(([u, h]) => {
                this.ghostValues[u] = h;
              });
            }
            return this.ghostValues;
          });
        }
        static fromSource(t, e, i) {
          return Rt(this, null, function* () {
            const r = (yield t.fetch([{ offset: 0, length: 1024 }], i))[0], a = new zst(r), o = a.getUint16(0, 0);
            let s;
            if (o === 18761) s = true;
            else if (o === 19789) s = false;
            else throw new TypeError("Invalid byte order value.");
            const l = a.getUint16(2, s);
            let u;
            if (l === 42) u = false;
            else if (l === 43) {
              if (u = true, a.getUint16(4, s) !== 8) throw new Error("Unsupported offset byte-size.");
            } else throw new TypeError("Invalid magic number.");
            const h = u ? a.getUint64(8, s) : a.getUint32(4, s);
            return new Qf(t, s, u, h, e);
          });
        }
        close() {
          return typeof this.source.close == "function" ? this.source.close() : false;
        }
      }
      class vlt extends mQ {
        constructor(t, e) {
          super(), this.mainFile = t, this.overviewFiles = e, this.imageFiles = [t].concat(e), this.fileDirectoriesPerFile = null, this.fileDirectoriesPerFileParsing = null, this.imageCount = null;
        }
        parseFileDirectoriesPerFile() {
          return Rt(this, null, function* () {
            const t = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map((e) => e.parseFileDirectoryAt(e.firstIFDOffset)));
            return this.fileDirectoriesPerFile = yield Promise.all(t), this.fileDirectoriesPerFile;
          });
        }
        getImage(t = 0) {
          return Rt(this, null, function* () {
            yield this.getImageCount(), yield this.parseFileDirectoriesPerFile();
            let e = 0, i = 0;
            for (let r = 0; r < this.imageFiles.length; r++) {
              const a = this.imageFiles[r];
              for (let o = 0; o < this.imageCounts[r]; o++) {
                if (t === e) {
                  const s = yield a.requestIFD(i);
                  return new AQ(s.fileDirectory, s.geoKeyDirectory, a.dataView, a.littleEndian, a.cache, a.source);
                }
                e++, i++;
              }
              i = 0;
            }
            throw new RangeError("Invalid image index");
          });
        }
        getImageCount() {
          return Rt(this, null, function* () {
            if (this.imageCount !== null) return this.imageCount;
            const t = [this.mainFile.getImageCount()].concat(this.overviewFiles.map((e) => e.getImageCount()));
            return this.imageCounts = yield Promise.all(t), this.imageCount = this.imageCounts.reduce((e, i) => e + i, 0), this.imageCount;
          });
        }
      }
      function ylt(i) {
        return Rt(this, arguments, function* (n, t = {}, e) {
          return Qf.fromSource(wC(n, t), e);
        });
      }
      function mlt(n, t) {
        return Rt(this, null, function* () {
          return Qf.fromSource(clt(n), t);
        });
      }
      function _lt(r) {
        return Rt(this, arguments, function* (n, t = [], e = {}, i) {
          const a = yield Qf.fromSource(wC(n, e), i), o = yield Promise.all(t.map((s) => Qf.fromSource(wC(s, e))));
          return new vlt(a, o);
        });
      }
      function Ilt(n) {
        return ((n.fileDirectory.NewSubfileType || 0) & 4) === 4;
      }
      function Elt(n, t) {
        if (!n) return false;
        if (n === true) return true;
        if (t.getSamplesPerPixel() !== 3) return false;
        const e = t.fileDirectory.PhotometricInterpretation, i = cr;
        return e === i.CMYK || e === i.YCbCr || e === i.CIELab || e === i.ICCLab;
      }
      const _Q = "STATISTICS_MAXIMUM", IQ = "STATISTICS_MINIMUM", SC = 256;
      let bC;
      function xlt() {
        return bC || (bC = new Vst()), bC;
      }
      function wlt(n) {
        try {
          return n.getBoundingBox();
        } catch (t) {
          return [0, 0, n.getWidth(), n.getHeight()];
        }
      }
      function Clt(n) {
        try {
          return n.getOrigin().slice(0, 2);
        } catch (t) {
          return [0, n.getHeight()];
        }
      }
      function Slt(n, t) {
        try {
          return n.getResolution(t);
        } catch (e) {
          return [t.getWidth() / n.getWidth(), t.getHeight() / n.getHeight()];
        }
      }
      function blt(n) {
        const t = n.geoKeys;
        if (!t) return null;
        if (t.ProjectedCSTypeGeoKey && t.ProjectedCSTypeGeoKey !== 32767) {
          const e = "EPSG:" + t.ProjectedCSTypeGeoKey;
          let i = Vt(e);
          if (!i) {
            const r = FL(t.ProjLinearUnitsGeoKey);
            r && (i = new rr({ code: e, units: r }));
          }
          return i;
        }
        if (t.GeographicTypeGeoKey && t.GeographicTypeGeoKey !== 32767) {
          const e = "EPSG:" + t.GeographicTypeGeoKey;
          let i = Vt(e);
          if (!i) {
            const r = FL(t.GeogAngularUnitsGeoKey);
            r && (i = new rr({ code: e, units: r }));
          }
          return i;
        }
        return null;
      }
      function Blt(n) {
        return n.getImageCount().then(function(t) {
          const e = new Array(t);
          for (let i = 0; i < t; ++i) e[i] = n.getImage(i);
          return Promise.all(e);
        });
      }
      function Tlt(n, t) {
        let e;
        return n.blob ? e = mlt(n.blob) : n.overviews ? e = _lt(n.url, n.overviews, t) : e = ylt(n.url, t), e.then(Blt);
      }
      function jA(n, t, e, i, r) {
        if (Array.isArray(n)) {
          const a = n.length;
          if (!Array.isArray(t) || a != t.length) {
            const o = new Error(i);
            throw r(o), o;
          }
          for (let o = 0; o < a; ++o) jA(n[o], t[o], e, i, r);
          return;
        }
        if (t = t, Math.abs(n - t) > e * n) throw new Error(i);
      }
      function Mlt(n) {
        return n instanceof Int8Array ? -128 : n instanceof Int16Array ? -32768 : n instanceof Int32Array ? -2147483648 : n instanceof Float32Array ? 12e-39 : 0;
      }
      function Dlt(n) {
        return n instanceof Int8Array ? 127 : n instanceof Uint8Array || n instanceof Uint8ClampedArray ? 255 : n instanceof Int16Array ? 32767 : n instanceof Uint16Array ? 65535 : n instanceof Int32Array ? 2147483647 : n instanceof Uint32Array ? 4294967295 : n instanceof Float32Array ? 34e37 : 255;
      }
      class EQ extends zot {
        constructor(t) {
          super({ state: "loading", tileGrid: null, projection: t.projection || null, transition: t.transition, interpolate: t.interpolate !== false, wrapX: t.wrapX }), this.sourceInfo_ = t.sources;
          const e = this.sourceInfo_.length;
          this.sourceOptions_ = t.sourceOptions, this.sourceImagery_ = new Array(e), this.sourceMasks_ = new Array(e), this.resolutionFactors_ = new Array(e), this.samplesPerPixel_, this.nodataValues_, this.metadata_, this.normalize_ = t.normalize !== false, this.addAlpha_ = false, this.error_ = null, this.convertToRGB_ = t.convertToRGB || false, this.setKey(this.sourceInfo_.map((a) => a.url).join(","));
          const i = this, r = new Array(e);
          for (let a = 0; a < e; ++a) r[a] = Tlt(this.sourceInfo_[a], this.sourceOptions_);
          Promise.all(r).then(function(a) {
            i.configure_(a);
          }).catch(function(a) {
            WL(a), i.error_ = a, i.setState("error");
          });
        }
        getError() {
          return this.error_;
        }
        determineProjection(t) {
          const e = t[0];
          for (let i = e.length - 1; i >= 0; --i) {
            const r = e[i], a = blt(r);
            if (a) {
              this.projection = a;
              break;
            }
          }
        }
        configure_(t) {
          let e, i, r, a, o;
          const s = new Array(t.length), l = new Array(t.length), u = new Array(t.length);
          let h = 0;
          const c = t.length;
          for (let A = 0; A < c; ++A) {
            const p = [], v = [];
            t[A].forEach((w) => {
              Ilt(w) ? v.push(w) : p.push(w);
            });
            const y = p.length;
            if (v.length > 0 && v.length !== y) throw new Error(`Expected one mask per image found ${v.length} masks and ${y} images`);
            let m, _;
            const E = new Array(y), I = new Array(y), x = new Array(y);
            l[A] = new Array(y), u[A] = new Array(y);
            for (let w = 0; w < y; ++w) {
              const C = p[w], S = C.getGDALNoData();
              u[A][w] = C.getGDALMetadata(0), l[A][w] = S;
              const b = this.sourceInfo_[A].bands;
              s[A] = b ? b.length : C.getSamplesPerPixel();
              const B = y - (w + 1);
              m || (m = wlt(C)), _ || (_ = Clt(C));
              const T = Slt(C, p[0]);
              x[B] = T[0];
              const D = [C.getTileWidth(), C.getTileHeight()];
              D[0] !== D[1] && D[1] < SC && (D[0] = SC, D[1] = SC), E[B] = D;
              const R = T[0] / Math.abs(T[1]);
              I[B] = [D[0], D[1] / R];
            }
            if (e ? ei(e, m, e) : e = m, !i) i = _;
            else {
              const w = `Origin mismatch for source ${A}, got [${_}] but expected [${i}]`;
              jA(i, _, 0, w, this.viewRejector);
            }
            if (!o) o = x, this.resolutionFactors_[A] = 1;
            else {
              o.length - h > x.length && (h = o.length - x.length);
              const w = o[o.length - 1] / x[x.length - 1];
              this.resolutionFactors_[A] = w;
              const C = x.map((b) => b *= w), S = `Resolution mismatch for source ${A}, got [${C}] but expected [${o}]`;
              jA(o.slice(h, o.length), C, 0.02, S, this.viewRejector);
            }
            r ? jA(r.slice(h, r.length), I, 0.01, `Tile size mismatch for source ${A}`, this.viewRejector) : r = I, a ? jA(a.slice(h, a.length), E, 0, `Tile size mismatch for source ${A}`, this.viewRejector) : a = E, this.sourceImagery_[A] = p.reverse(), this.sourceMasks_[A] = v.reverse();
          }
          for (let A = 0, p = this.sourceImagery_.length; A < p; ++A) {
            const v = this.sourceImagery_[A];
            for (; v.length < o.length; ) v.unshift(void 0);
          }
          this.getProjection() || this.determineProjection(t), this.samplesPerPixel_ = s, this.nodataValues_ = l, this.metadata_ = u;
          t: for (let A = 0; A < c; ++A) {
            if (this.sourceInfo_[A].nodata !== void 0) {
              this.addAlpha_ = true;
              break;
            }
            if (this.sourceMasks_[A].length) {
              this.addAlpha_ = true;
              break;
            }
            const p = l[A], v = this.sourceInfo_[A].bands;
            if (v) {
              for (let y = 0; y < v.length; ++y) if (p[v[y] - 1] !== null) {
                this.addAlpha_ = true;
                break t;
              }
              continue;
            }
            for (let y = 0; y < p.length; ++y) if (p[y] !== null) {
              this.addAlpha_ = true;
              break t;
            }
          }
          let f = this.addAlpha_ ? 1 : 0;
          for (let A = 0; A < c; ++A) f += s[A];
          this.bandCount = f;
          const g = new Rf({ extent: e, minZoom: h, origin: i, resolutions: o, tileSizes: r });
          this.tileGrid = g, this.setTileSizes(a), this.setLoader(this.loadTile_.bind(this)), this.setState("ready");
          const d = 1;
          o.length === 2 ? o = [o[0], o[1], o[1] / 2] : o.length === 1 && (o = [o[0] * 2, o[0], o[0] / 2]), this.viewResolver({ showFullExtent: true, projection: this.projection, resolutions: o, center: os(Br(e), this.projection), extent: qd(e, this.projection), zoom: d });
        }
        loadTile_(t, e, i, r) {
          const a = this.getTileSize(t), o = this.sourceImagery_.length, s = new Array(o * 2), l = this.nodataValues_, u = this.sourceInfo_, h = xlt();
          for (let c = 0; c < o; ++c) {
            const f = u[c], g = this.resolutionFactors_[c], d = [Math.round(e * (a[0] * g)), Math.round(i * (a[1] * g)), Math.round((e + 1) * (a[0] * g)), Math.round((i + 1) * (a[1] * g))], A = this.sourceImagery_[c][t];
            let p;
            f.bands && (p = f.bands.map(function(E) {
              return E - 1;
            }));
            let v;
            "nodata" in f && f.nodata !== null ? v = f.nodata : p ? v = p.map(function(E) {
              return l[c][E];
            }) : v = l[c];
            const y = { window: d, width: a[0], height: a[1], samples: p, fillValue: v, pool: h, interleave: false, signal: r.signal };
            Elt(this.convertToRGB_, A) ? s[c] = A.readRGB(y) : s[c] = A.readRasters(y);
            const m = o + c, _ = this.sourceMasks_[c][t];
            if (!_) {
              s[m] = Promise.resolve(null);
              continue;
            }
            s[m] = _.readRasters({ window: d, width: a[0], height: a[1], samples: [0], pool: h, interleave: false });
          }
          return Promise.all(s).then(this.composeTile_.bind(this, a)).catch(function(c) {
            throw WL(c), c;
          });
        }
        composeTile_(t, e) {
          const i = this.metadata_, r = this.sourceInfo_, a = this.sourceImagery_.length, o = this.bandCount, s = this.samplesPerPixel_, l = this.nodataValues_, u = this.normalize_, h = this.addAlpha_, c = t[0] * t[1], f = c * o;
          let g;
          u ? g = new Uint8Array(f) : g = new Float32Array(f);
          let d = 0;
          for (let A = 0; A < c; ++A) {
            let p = h;
            for (let v = 0; v < a; ++v) {
              const y = r[v];
              let m = y.min, _ = y.max, E, I;
              if (u) {
                const x = i[v][0];
                m === void 0 && (x && IQ in x ? m = parseFloat(x[IQ]) : m = Mlt(e[v][0])), _ === void 0 && (x && _Q in x ? _ = parseFloat(x[_Q]) : _ = Dlt(e[v][0])), E = 255 / (_ - m), I = -m * E;
              }
              for (let x = 0; x < s[v]; ++x) {
                const w = e[v][x][A];
                let C;
                if (u ? C = en(E * w + I, 0, 255) : C = w, !h) g[d] = C;
                else {
                  let S = y.nodata;
                  if (S === void 0) {
                    let B;
                    y.bands ? B = y.bands[x] - 1 : B = x, S = l[v][B];
                  }
                  const b = isNaN(S);
                  (!b && w !== S || b && !isNaN(w)) && (p = false, g[d] = C);
                }
                d++;
              }
              if (!p) {
                const x = a + v, w = e[x];
                w && !w[0][A] && (p = true);
              }
            }
            h && (p || (g[d] = 255), d++);
          }
          return g;
        }
      }
      const zi = { VERSION1: "version1", VERSION2: "version2", VERSION3: "version3" }, ju = {};
      ju[zi.VERSION1] = { level0: { supports: [], formats: [], qualities: ["native"] }, level1: { supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"], formats: ["jpg"], qualities: ["native"] }, level2: { supports: ["regionByPx", "regionByPct", "sizeByW", "sizeByH", "sizeByPct", "sizeByConfinedWh", "sizeByWh"], formats: ["jpg", "png"], qualities: ["native", "color", "grey", "bitonal"] } }, ju[zi.VERSION2] = { level0: { supports: [], formats: ["jpg"], qualities: ["default"] }, level1: { supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"], formats: ["jpg"], qualities: ["default"] }, level2: { supports: ["regionByPx", "regionByPct", "sizeByW", "sizeByH", "sizeByPct", "sizeByConfinedWh", "sizeByDistortedWh", "sizeByWh"], formats: ["jpg", "png"], qualities: ["default", "bitonal"] } }, ju[zi.VERSION3] = { level0: { supports: [], formats: ["jpg"], qualities: ["default"] }, level1: { supports: ["regionByPx", "regionSquare", "sizeByW", "sizeByH", "sizeByWh"], formats: ["jpg"], qualities: ["default"] }, level2: { supports: ["regionByPx", "regionSquare", "regionByPct", "sizeByW", "sizeByH", "sizeByPct", "sizeByConfinedWh", "sizeByWh"], formats: ["jpg", "png"], qualities: ["default"] } }, ju.none = { none: { supports: [], formats: [], qualities: [] } };
      const Rlt = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/, xQ = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/, Llt = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;
      function Plt(n) {
        let t = n.getComplianceLevelSupportedFeatures();
        return t === void 0 && (t = ju[zi.VERSION1].level0), { url: n.imageInfo["@id"] === void 0 ? void 0 : n.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""), supports: t.supports, formats: [...t.formats, n.imageInfo.formats === void 0 ? [] : n.imageInfo.formats], qualities: [...t.qualities, n.imageInfo.qualities === void 0 ? [] : n.imageInfo.qualities], resolutions: n.imageInfo.scale_factors, tileSize: n.imageInfo.tile_width !== void 0 ? n.imageInfo.tile_height !== void 0 ? [n.imageInfo.tile_width, n.imageInfo.tile_height] : [n.imageInfo.tile_width, n.imageInfo.tile_width] : n.imageInfo.tile_height != null ? [n.imageInfo.tile_height, n.imageInfo.tile_height] : void 0 };
      }
      function Nlt(n) {
        const t = n.getComplianceLevelSupportedFeatures(), e = Array.isArray(n.imageInfo.profile) && n.imageInfo.profile.length > 1, i = e && n.imageInfo.profile[1].supports ? n.imageInfo.profile[1].supports : [], r = e && n.imageInfo.profile[1].formats ? n.imageInfo.profile[1].formats : [], a = e && n.imageInfo.profile[1].qualities ? n.imageInfo.profile[1].qualities : [];
        return { url: n.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""), sizes: n.imageInfo.sizes === void 0 ? void 0 : n.imageInfo.sizes.map(function(o) {
          return [o.width, o.height];
        }), tileSize: n.imageInfo.tiles === void 0 ? void 0 : [n.imageInfo.tiles.map(function(o) {
          return o.width;
        })[0], n.imageInfo.tiles.map(function(o) {
          return o.height === void 0 ? o.width : o.height;
        })[0]], resolutions: n.imageInfo.tiles === void 0 ? void 0 : n.imageInfo.tiles.map(function(o) {
          return o.scaleFactors;
        })[0], supports: [...t.supports, ...i], formats: [...t.formats, ...r], qualities: [...t.qualities, ...a] };
      }
      function klt(n) {
        const t = n.getComplianceLevelSupportedFeatures(), e = n.imageInfo.extraFormats === void 0 ? t.formats : [...t.formats, ...n.imageInfo.extraFormats], i = n.imageInfo.preferredFormats !== void 0 && Array.isArray(n.imageInfo.preferredFormats) && n.imageInfo.preferredFormats.length > 0 ? n.imageInfo.preferredFormats.filter(function(r) {
          return ["jpg", "png", "gif"].includes(r);
        }).reduce(function(r, a) {
          return r === void 0 && e.includes(a) ? a : r;
        }, void 0) : void 0;
        return { url: n.imageInfo.id, sizes: n.imageInfo.sizes === void 0 ? void 0 : n.imageInfo.sizes.map(function(r) {
          return [r.width, r.height];
        }), tileSize: n.imageInfo.tiles === void 0 ? void 0 : [n.imageInfo.tiles.map(function(r) {
          return r.width;
        })[0], n.imageInfo.tiles.map(function(r) {
          return r.height;
        })[0]], resolutions: n.imageInfo.tiles === void 0 ? void 0 : n.imageInfo.tiles.map(function(r) {
          return r.scaleFactors;
        })[0], supports: n.imageInfo.extraFeatures === void 0 ? t.supports : [...t.supports, ...n.imageInfo.extraFeatures], formats: e, qualities: n.imageInfo.extraQualities === void 0 ? t.qualities : [...t.qualities, ...n.imageInfo.extraQualities], preferredFormat: i };
      }
      const pm = {};
      pm[zi.VERSION1] = Plt, pm[zi.VERSION2] = Nlt, pm[zi.VERSION3] = klt;
      class Flt {
        constructor(t) {
          this.setImageInfo(t);
        }
        setImageInfo(t) {
          typeof t == "string" ? this.imageInfo = JSON.parse(t) : this.imageInfo = t;
        }
        getImageApiVersion() {
          if (this.imageInfo === void 0) return;
          let t = this.imageInfo["@context"] || "ol-no-context";
          typeof t == "string" && (t = [t]);
          for (let e = 0; e < t.length; e++) switch (t[e]) {
            case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
            case "http://iiif.io/api/image/1/context.json":
              return zi.VERSION1;
            case "http://iiif.io/api/image/2/context.json":
              return zi.VERSION2;
            case "http://iiif.io/api/image/3/context.json":
              return zi.VERSION3;
            case "ol-no-context":
              if (this.getComplianceLevelEntryFromProfile(zi.VERSION1) && this.imageInfo.identifier) return zi.VERSION1;
              break;
          }
          he(false, "Cannot determine IIIF Image API version from provided image information JSON");
        }
        getComplianceLevelEntryFromProfile(t) {
          if (!(this.imageInfo === void 0 || this.imageInfo.profile === void 0)) switch (t === void 0 && (t = this.getImageApiVersion()), t) {
            case zi.VERSION1:
              if (Rlt.test(this.imageInfo.profile)) return this.imageInfo.profile;
              break;
            case zi.VERSION3:
              if (Llt.test(this.imageInfo.profile)) return this.imageInfo.profile;
              break;
            case zi.VERSION2:
              if (typeof this.imageInfo.profile == "string" && xQ.test(this.imageInfo.profile)) return this.imageInfo.profile;
              if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && typeof this.imageInfo.profile[0] == "string" && xQ.test(this.imageInfo.profile[0])) return this.imageInfo.profile[0];
              break;
          }
        }
        getComplianceLevelFromProfile(t) {
          const e = this.getComplianceLevelEntryFromProfile(t);
          if (e === void 0) return;
          const i = e.match(/level[0-2](?:\.json)?$/g);
          return Array.isArray(i) ? i[0].replace(".json", "") : void 0;
        }
        getComplianceLevelSupportedFeatures() {
          if (this.imageInfo === void 0) return;
          const t = this.getImageApiVersion(), e = this.getComplianceLevelFromProfile(t);
          return e === void 0 ? ju.none.none : ju[t][e];
        }
        getTileSourceOptions(t) {
          const e = t || {}, i = this.getImageApiVersion();
          if (i === void 0) return;
          const r = i === void 0 ? void 0 : pm[i](this);
          if (r !== void 0) return { url: r.url, version: i, size: [this.imageInfo.width, this.imageInfo.height], sizes: r.sizes, format: e.format !== void 0 && r.formats.includes(e.format) ? e.format : r.preferredFormat !== void 0 ? r.preferredFormat : "jpg", supports: r.supports, quality: e.quality && r.qualities.includes(e.quality) ? e.quality : r.qualities.includes("native") ? "native" : "default", resolutions: Array.isArray(r.resolutions) ? r.resolutions.sort(function(a, o) {
            return o - a;
          }) : void 0, tileSize: r.tileSize };
        }
      }
      function BC(n) {
        return Array.isArray(n) ? Math.min(...n) : n;
      }
      class Qlt extends bP {
        constructor(t, e, i, r, a, o, s) {
          let l = t.getExtent();
          l && t.canWrapX() && (l = l.slice(), l[0] = -1 / 0, l[2] = 1 / 0);
          let u = e.getExtent();
          u && e.canWrapX() && (u = u.slice(), u[0] = -1 / 0, u[2] = 1 / 0);
          const h = u ? ei(i, u) : i, c = Br(h), f = OA(t, e, c, r), g = kw, d = new Fw(t, e, h, l, f * g, r), A = d.calculateSourceExtent(), p = ns(A) ? null : o(A, f, a), v = p ? Bt.IDLE : Bt.EMPTY, y = p ? p.getPixelRatio() : 1;
          super(i, r, y, v), this.targetProj_ = e, this.maxSourceExtent_ = l, this.triangulation_ = d, this.targetResolution_ = r, this.targetExtent_ = i, this.sourceImage_ = p, this.sourcePixelRatio_ = y, this.interpolate_ = s, this.canvas_ = null, this.sourceListenerKey_ = null;
        }
        disposeInternal() {
          this.state == Bt.LOADING && this.unlistenSource_(), super.disposeInternal();
        }
        getImage() {
          return this.canvas_;
        }
        getProjection() {
          return this.targetProj_;
        }
        reproject_() {
          const t = this.sourceImage_.getState();
          if (t == Bt.LOADED) {
            const e = ve(this.targetExtent_) / this.targetResolution_, i = Cn(this.targetExtent_) / this.targetResolution_;
            this.canvas_ = zw(e, i, this.sourcePixelRatio_, BC(this.sourceImage_.getResolution()), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [{ extent: this.sourceImage_.getExtent(), image: this.sourceImage_.getImage() }], 0, void 0, this.interpolate_, true);
          }
          this.state = t, this.changed();
        }
        load() {
          if (this.state == Bt.IDLE) {
            this.state = Bt.LOADING, this.changed();
            const t = this.sourceImage_.getState();
            t == Bt.LOADED || t == Bt.ERROR ? this.reproject_() : (this.sourceListenerKey_ = ie(this.sourceImage_, Nt.CHANGE, (e) => {
              const i = this.sourceImage_.getState();
              (i == Bt.LOADED || i == Bt.ERROR) && (this.unlistenSource_(), this.reproject_());
            }), this.sourceImage_.load());
          }
        }
        unlistenSource_() {
          Pe(this.sourceListenerKey_), this.sourceListenerKey_ = null;
        }
      }
      const Ml = 4, TC = { IMAGELOADSTART: "imageloadstart", IMAGELOADEND: "imageloadend", IMAGELOADERROR: "imageloaderror" };
      class Olt extends Se {
        constructor(t, e) {
          super(t), this.image = e;
        }
      }
      class zlt extends $x {
        constructor(t) {
          super({ attributions: t.attributions, projection: t.projection, state: t.state, interpolate: t.interpolate !== void 0 ? t.interpolate : true }), this.on, this.once, this.un, this.loader = t.loader || null, this.resolutions_ = t.resolutions !== void 0 ? t.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0, this.image = null, this.wantedExtent_, this.wantedResolution_, this.static_ = t.loader ? t.loader.length === 0 : false, this.wantedProjection_ = null;
        }
        getResolutions() {
          return this.resolutions_;
        }
        setResolutions(t) {
          this.resolutions_ = t;
        }
        findNearestResolution(t) {
          const e = this.getResolutions();
          if (e) {
            const i = Hr(e, t, 0);
            t = e[i];
          }
          return t;
        }
        getImage(t, e, i, r) {
          const a = this.getProjection();
          if (!a || !r || ro(a, r)) return a && (r = a), this.getImageInternal(t, e, i, r);
          if (this.reprojectedImage_) {
            if (this.reprojectedRevision_ == this.getRevision() && ro(this.reprojectedImage_.getProjection(), r) && this.reprojectedImage_.getResolution() == e && al(this.reprojectedImage_.getExtent(), t)) return this.reprojectedImage_;
            this.reprojectedImage_.dispose(), this.reprojectedImage_ = null;
          }
          return this.reprojectedImage_ = new Qlt(a, r, t, e, i, (o, s, l) => this.getImageInternal(o, s, l, a), this.getInterpolate()), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_;
        }
        getImageInternal(t, e, i, r) {
          if (this.loader) {
            const a = wQ(t, e, i, 1), o = this.findNearestResolution(e);
            if (this.image && (this.static_ || this.wantedProjection_ === r && (this.wantedExtent_ && br(this.wantedExtent_, a) || br(this.image.getExtent(), a)) && (this.wantedResolution_ && BC(this.wantedResolution_) === o || BC(this.image.getResolution()) === o))) return this.image;
            this.wantedProjection_ = r, this.wantedExtent_ = a, this.wantedResolution_ = o, this.image = new bP(a, o, i, this.loader), this.image.addEventListener(Nt.CHANGE, this.handleImageChange.bind(this));
          }
          return this.image;
        }
        handleImageChange(t) {
          const e = t.target;
          let i;
          switch (e.getState()) {
            case Bt.LOADING:
              this.loading = true, i = TC.IMAGELOADSTART;
              break;
            case Bt.LOADED:
              this.loading = false, i = TC.IMAGELOADEND;
              break;
            case Bt.ERROR:
              this.loading = false, i = TC.IMAGELOADERROR;
              break;
            default:
              return;
          }
          this.hasListener(i) && this.dispatchEvent(new Olt(i, e));
        }
      }
      function Glt(n, t) {
        n.getImage().src = t;
      }
      function wQ(n, t, e, i) {
        const r = t / e, a = Br(n), o = ll(ve(n) / r, Ml), s = ll(Cn(n) / r, Ml), l = ll((i - 1) * o / 2, Ml), u = o + 2 * l, h = ll((i - 1) * s / 2, Ml), c = s + 2 * h;
        return zd(a, r, 0, [u, c]);
      }
      const vm = "1.3.0", CQ = [101, 101];
      function SQ(n, t, e, i, r) {
        r.WIDTH = e[0], r.HEIGHT = e[1];
        const a = i.getAxisOrientation(), o = Vy(r.VERSION, "1.3") >= 0;
        r[o ? "CRS" : "SRS"] = i.getCode();
        const s = o && a.startsWith("ne") ? [t[1], t[0], t[3], t[2]] : t;
        return r.BBOX = s.join(","), Jw(n, r);
      }
      function bQ(n, t, e, i, r, a, o) {
        a = Object.assign({ REQUEST: "GetMap" }, a);
        const s = t / e, l = [zL(ve(n) / s, Ml), zL(Cn(n) / s, Ml)];
        if (e != 1) switch (o) {
          case "geoserver":
            const h = 90 * e + 0.5 | 0;
            "FORMAT_OPTIONS" in a ? a.FORMAT_OPTIONS += ";dpi:" + h : a.FORMAT_OPTIONS = "dpi:" + h;
            break;
          case "mapserver":
            a.MAP_RESOLUTION = 90 * e;
            break;
          case "carmentaserver":
          case "qgis":
            a.DPI = 90 * e;
            break;
          default:
            throw new Error("Unknown `serverType` configured");
        }
        return SQ(r, n, l, i, a);
      }
      function ym(n, t) {
        return Object.assign({ REQUEST: t, SERVICE: "WMS", VERSION: vm, FORMAT: "image/png", STYLES: "", TRANSPARENT: true }, n);
      }
      function Ult(n) {
        var o;
        const t = n.hidpi === void 0 ? true : n.hidpi, e = Vt(n.projection || "EPSG:3857"), i = n.ratio || 1.5, r = n.load || TP, a = (o = n.crossOrigin) != null ? o : null;
        return (s, l, u) => {
          s = wQ(s, l, u, i), u != 1 && (!t || n.serverType === void 0) && (u = 1);
          const h = bQ(s, l, u, e, n.url, ym(n.params, "GetMap"), n.serverType), c = new Image();
          return c.crossOrigin = a, r(c, h).then((f) => ({ image: f, extent: s, pixelRatio: u }));
        };
      }
      function Vlt(n, t, e) {
        if (n.url === void 0) return;
        const i = Vt(n.projection || "EPSG:3857"), r = zd(t, e, 0, CQ), a = { QUERY_LAYERS: n.params.LAYERS, INFO_FORMAT: "application/json" };
        Object.assign(a, ym(n.params, "GetFeatureInfo"), n.params);
        const o = zc((t[0] - r[0]) / e, Ml), s = zc((r[3] - t[1]) / e, Ml), l = Vy(a.VERSION, "1.3") >= 0;
        return a[l ? "I" : "X"] = o, a[l ? "J" : "Y"] = s, SQ(n.url, r, CQ, i, a);
      }
      function jlt(n, t) {
        if (n.url === void 0) return;
        const e = { SERVICE: "WMS", VERSION: vm, REQUEST: "GetLegendGraphic", FORMAT: "image/png" };
        if (t !== void 0) {
          const i = Vt(n.projection || "EPSG:3857").getMetersPerUnit() || 1, r = 28e-5;
          e.SCALE = t * i / r;
        }
        if (Object.assign(e, n.params), n.params !== void 0 && e.LAYER === void 0) {
          const i = e.LAYERS;
          if (!(!Array.isArray(i) || i.length !== 1)) return;
          e.LAYER = i;
        }
        return Jw(n.url, e);
      }
      class qlt extends zlt {
        constructor(t) {
          t = t || {}, super({ attributions: t.attributions, interpolate: t.interpolate, projection: t.projection, resolutions: t.resolutions }), this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : null, this.url_ = t.url, this.imageLoadFunction_ = t.imageLoadFunction !== void 0 ? t.imageLoadFunction : Glt, this.params_ = Object.assign({}, t.params), this.serverType_ = t.serverType, this.hidpi_ = t.hidpi !== void 0 ? t.hidpi : true, this.renderedRevision_ = 0, this.ratio_ = t.ratio !== void 0 ? t.ratio : 1.5, this.loaderProjection_ = null;
        }
        getFeatureInfoUrl(t, e, i, r) {
          const a = Vt(i), o = this.getProjection();
          o && o !== a && (e = OA(o, a, t, e), t = as(t, a, o));
          const s = { url: this.url_, params: st(st({}, this.params_), r), projection: o || a };
          return Vlt(s, t, e);
        }
        getLegendUrl(t, e) {
          return jlt({ url: this.url_, params: st(st({}, this.params_), e) }, t);
        }
        getParams() {
          return this.params_;
        }
        getImageInternal(t, e, i, r) {
          return this.url_ === void 0 ? null : ((!this.loader || this.loaderProjection_ !== r) && (this.loaderProjection_ = r, this.loader = Ult({ crossOrigin: this.crossOrigin_, params: this.params_, projection: r, serverType: this.serverType_, hidpi: this.hidpi_, url: this.url_, ratio: this.ratio_, load: (a, o) => (this.image.setImage(a), this.imageLoadFunction_(this.image, o), TP(a)) })), super.getImageInternal(t, e, i, r));
        }
        getImageLoadFunction() {
          return this.imageLoadFunction_;
        }
        getUrl() {
          return this.url_;
        }
        setImageLoadFunction(t) {
          this.imageLoadFunction_ = t, this.changed();
        }
        setUrl(t) {
          t != this.url_ && (this.url_ = t, this.loader = null, this.changed());
        }
        updateParams(t) {
          Object.assign(this.params_, t), this.changed();
        }
        changed() {
          this.image = null, super.changed();
        }
      }
      const Hlt = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
      class Ylt extends eC {
        constructor(t) {
          t = t || {};
          let e;
          t.attributions !== void 0 ? e = t.attributions : e = [Hlt];
          const i = t.crossOrigin !== void 0 ? t.crossOrigin : "anonymous", r = t.url !== void 0 ? t.url : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
          super({ attributions: e, attributionsCollapsible: false, cacheSize: t.cacheSize, crossOrigin: i, interpolate: t.interpolate, maxZoom: t.maxZoom !== void 0 ? t.maxZoom : 19, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileLoadFunction: t.tileLoadFunction, transition: t.transition, url: r, wrapX: t.wrapX, zDirection: t.zDirection });
        }
      }
      class Wlt extends Yc {
        constructor(t) {
          t = t || {}, super(t);
        }
      }
      class Xlt extends y0 {
        constructor(t) {
          super(t), this.image = null;
        }
        getImage() {
          return this.image ? this.image.getImage() : null;
        }
        prepareFrame(t) {
          const e = t.layerStatesArray[t.layerIndex], i = t.pixelRatio, r = t.viewState, a = r.resolution, o = this.getLayer().getSource(), s = t.viewHints;
          let l = t.extent;
          if (e.extent !== void 0 && (l = ei(l, Ni(e.extent, r.projection))), !s[Fn.ANIMATING] && !s[Fn.INTERACTING] && !ns(l)) if (o) {
            const u = r.projection, h = o.getImage(l, a, i, u);
            h && (this.loadImage(h) ? this.image = h : h.getState() === Bt.EMPTY && (this.image = null));
          } else this.image = null;
          return !!this.image;
        }
        getData(t) {
          const e = this.frameState;
          if (!e) return null;
          const i = this.getLayer(), r = gn(e.pixelToCoordinateTransform, t.slice()), a = i.getExtent();
          if (a && !Wr(a, r)) return null;
          const o = this.image.getExtent(), s = this.image.getImage(), l = ve(o), u = Math.floor(s.width * ((r[0] - o[0]) / l));
          if (u < 0 || u >= s.width) return null;
          const h = Cn(o), c = Math.floor(s.height * ((o[3] - r[1]) / h));
          return c < 0 || c >= s.height ? null : this.getImageData(s, u, c);
        }
        renderFrame(t, e) {
          const i = this.image, r = i.getExtent(), a = i.getResolution(), [o, s] = Array.isArray(a) ? a : [a, a], l = i.getPixelRatio(), u = t.layerStatesArray[t.layerIndex], h = t.pixelRatio, c = t.viewState, f = c.center, g = c.resolution, d = h * o / (g * l), A = h * s / (g * l);
          this.prepareContainer(t, e);
          const p = this.context.canvas.width, v = this.context.canvas.height, y = this.getRenderContext(t);
          let m = false, _ = true;
          if (u.extent) {
            const C = Ni(u.extent, c.projection);
            _ = hi(C, t.extent), m = _ && !br(C, t.extent), m && this.clipUnrotated(y, t, C);
          }
          const E = i.getImage(), I = Sr(this.tempTransform, p / 2, v / 2, d, A, 0, l * (r[0] - f[0]) / o, l * (f[1] - r[3]) / s);
          this.renderedResolution = s * h / l;
          const x = E.width * I[0], w = E.height * I[3];
          if (this.getLayer().getSource().getInterpolate() || (y.imageSmoothingEnabled = false), this.preRender(y, t), _ && x >= 0.5 && w >= 0.5) {
            const C = I[4], S = I[5], b = u.opacity;
            b !== 1 && (y.save(), y.globalAlpha = b), y.drawImage(E, 0, 0, +E.width, +E.height, C, S, x, w), b !== 1 && y.restore();
          }
          return this.postRender(this.context, t), m && y.restore(), y.imageSmoothingEnabled = true, this.container;
        }
      }
      class Zlt extends Wlt {
        constructor(t) {
          super(t);
        }
        createRenderer() {
          return new Xlt(this);
        }
        getData(t) {
          return super.getData(t);
        }
      }
      class Klt extends qF {
        constructor(t) {
          t = t || {};
          const e = Object.assign({}, t.params);
          super({ attributions: t.attributions, attributionsCollapsible: t.attributionsCollapsible, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, interpolate: t.interpolate, projection: t.projection, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileClass: t.tileClass, tileGrid: t.tileGrid, tileLoadFunction: t.tileLoadFunction, url: t.url, urls: t.urls, wrapX: t.wrapX !== void 0 ? t.wrapX : true, transition: t.transition, zDirection: t.zDirection }), this.gutter_ = t.gutter !== void 0 ? t.gutter : 0, this.params_ = e, this.v13_ = true, this.serverType_ = t.serverType, this.hidpi_ = t.hidpi !== void 0 ? t.hidpi : true, this.tmpExtent_ = Ii(), this.updateV13_(), this.setKey(this.getKeyForParams_());
        }
        getFeatureInfoUrl(t, e, i, r) {
          const a = Vt(i), o = this.getProjection() || a;
          let s = this.getTileGrid();
          s || (s = this.getTileGridForProjection(o));
          const l = as(t, a, o), u = OA(o, a, t, e), h = s.getZForResolution(u, this.zDirection), c = s.getResolution(h), f = s.getTileCoordForCoordAndZ(l, h);
          if (s.getResolutions().length <= f[0]) return;
          let g = s.getTileCoordExtent(f, this.tmpExtent_);
          const d = this.gutter_;
          d !== 0 && (g = es(g, c * d, g));
          const A = { QUERY_LAYERS: this.params_.LAYERS };
          Object.assign(A, ym(this.params_, "GetFeatureInfo"), r);
          const p = Math.floor((l[0] - g[0]) / c), v = Math.floor((g[3] - l[1]) / c);
          return A[this.v13_ ? "I" : "X"] = p, A[this.v13_ ? "J" : "Y"] = v, this.getRequestUrl_(f, g, 1, o || a, A);
        }
        getLegendUrl(t, e) {
          if (this.urls[0] === void 0) return;
          const i = { SERVICE: "WMS", VERSION: vm, REQUEST: "GetLegendGraphic", FORMAT: "image/png" };
          if (e === void 0 || e.LAYER === void 0) {
            const r = this.params_.LAYERS;
            if (!(!Array.isArray(r) || r.length === 1)) return;
            i.LAYER = r;
          }
          if (t !== void 0) {
            const r = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, a = 28e-5;
            i.SCALE = t * r / a;
          }
          return Object.assign(i, e), Jw(this.urls[0], i);
        }
        getGutter() {
          return this.gutter_;
        }
        getParams() {
          return this.params_;
        }
        getRequestUrl_(t, e, i, r, a) {
          const o = this.urls;
          if (!o) return;
          let s;
          if (o.length == 1) s = o[0];
          else {
            const l = rs(ON(t), o.length);
            s = o[l];
          }
          return bQ(e, (this.tileGrid || this.getTileGridForProjection(r)).getResolution(t[0]), i, r, s, a, this.serverType_);
        }
        getTilePixelRatio(t) {
          return !this.hidpi_ || this.serverType_ === void 0 ? 1 : t;
        }
        getKeyForParams_() {
          let t = 0;
          const e = [];
          for (const i in this.params_) e[t++] = i + "-" + this.params_[i];
          return e.join("/");
        }
        updateParams(t) {
          Object.assign(this.params_, t), this.updateV13_(), this.setKey(this.getKeyForParams_());
        }
        updateV13_() {
          const t = this.params_.VERSION || vm;
          this.v13_ = Vy(t, "1.3") >= 0;
        }
        tileUrlFunction(t, e, i) {
          let r = this.getTileGrid();
          if (r || (r = this.getTileGridForProjection(i)), r.getResolutions().length <= t[0]) return;
          e != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (e = 1);
          const a = r.getResolution(t[0]);
          let o = r.getTileCoordExtent(t, this.tmpExtent_);
          const s = this.gutter_;
          s !== 0 && (o = es(o, a * s, o));
          const l = Object.assign({}, ym(this.params_, "GetMap"));
          return this.getRequestUrl_(t, o, e, i, l);
        }
      }
      const $lt = (n) => {
        let t;
        if ((n == null ? void 0 : n.tileGrid) !== void 0) return t = n.tileGrid, new Rf(t);
      }, mo = (n, t) => {
        const e = $lt(t), i = zt(st({}, t), { tileGrid: e });
        return new nm(zt(st({}, n), { source: new eC(i) }));
      }, Jlt = (n) => new nm(zt(st({}, n), { source: void 0 })), mm = (n, t, e) => {
        const i = [];
        for (let s = 0; s < 19; s++) i[s] = Math.pow(2, 18 - s);
        const r = new Rf({ origin: [0, 0], resolutions: i }), a = zt(st({}, t), { url: "", projection: "BD:09", tileGrid: r, tileUrlFunction: function(s) {
          if (!s) return "";
          const l = s[0], u = s[1], h = -s[2] - 1;
          return e.replace("{x}", u.toString()).replace("{y}", h.toString()).replace("{z}", l.toString());
        }, crossOrigin: "anonymous" }), o = new eC(a);
        return new nm(zt(st({}, n), { source: o }));
      }, tut = (n, t) => {
        const e = zt(st({}, n), { source: new EQ(t) });
        return new Kw(e);
      }, eut = (n, t) => {
        const e = st({}, t);
        return new nm(zt(st({}, n), { source: new Ylt(e) }));
      }, Dl = (n, t) => {
        const e = (c) => {
          if (n) {
            const f = !!c;
            n == null || n.setVisible(f);
          }
        };
        N.watch(() => t.visible, (c) => {
          e(c);
        }, { deep: true });
        const i = (c) => {
          n == null || n.setExtent(c);
        };
        N.watch(() => t.extent, (c) => {
          i(c);
        }, { deep: true });
        const r = (c) => {
          (c || c === 0) && (n == null || n.setMaxResolution(c));
        };
        N.watch(() => t.maxResolution, (c) => {
          r(c);
        });
        const a = (c) => {
          (c || c === 0) && (n == null || n.setMinResolution(c));
        };
        N.watch(() => t.minResolution, (c) => {
          a(c);
        });
        const o = (c) => {
          (c || c === 0) && (n == null || n.setOpacity(c));
        };
        N.watch(() => t.opacity, (c) => {
          o(c);
        });
        const s = (c) => {
          (c || c === 0) && (n == null || n.setZIndex(c));
        };
        N.watch(() => t.zIndex, (c) => {
          s(c);
        });
        const l = (c) => {
          (c || c === 0) && (n == null || n.setMaxZoom(c));
        };
        N.watch(() => t.maxZoom, (c) => {
          l(c);
        });
        const u = (c) => {
          (c || c === 0) && (n == null || n.setMinZoom(c));
        };
        return N.watch(() => t.minZoom, (c) => {
          u(c);
        }), { onMounted: () => {
          e(t.visible), i(t.extent), r(t.maxResolution), a(t.minResolution), o(t.opacity), s(t.zIndex), l(t.maxZoom), u(t.minZoom);
        } };
      }, _o = new Uint8Array(4);
      class nut {
        constructor(t, e) {
          this.helper_ = t;
          const i = t.getGL();
          this.texture_ = i.createTexture(), this.framebuffer_ = i.createFramebuffer(), this.depthbuffer_ = i.createRenderbuffer(), this.size_ = e || [1, 1], this.data_ = new Uint8Array(0), this.dataCacheDirty_ = true, this.updateSize_();
        }
        setSize(t) {
          no(t, this.size_) || (this.size_[0] = t[0], this.size_[1] = t[1], this.updateSize_());
        }
        getSize() {
          return this.size_;
        }
        clearCachedData() {
          this.dataCacheDirty_ = true;
        }
        readAll() {
          if (this.dataCacheDirty_) {
            const t = this.size_, e = this.helper_.getGL();
            e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer_), e.readPixels(0, 0, t[0], t[1], e.RGBA, e.UNSIGNED_BYTE, this.data_), this.dataCacheDirty_ = false;
          }
          return this.data_;
        }
        readPixel(t, e) {
          if (t < 0 || e < 0 || t > this.size_[0] || e >= this.size_[1]) return _o[0] = 0, _o[1] = 0, _o[2] = 0, _o[3] = 0, _o;
          this.readAll();
          const i = Math.floor(t) + (this.size_[1] - Math.floor(e) - 1) * this.size_[0];
          return _o[0] = this.data_[i * 4], _o[1] = this.data_[i * 4 + 1], _o[2] = this.data_[i * 4 + 2], _o[3] = this.data_[i * 4 + 3], _o;
        }
        getTexture() {
          return this.texture_;
        }
        getFramebuffer() {
          return this.framebuffer_;
        }
        getDepthbuffer() {
          return this.depthbuffer_;
        }
        updateSize_() {
          const t = this.size_, e = this.helper_.getGL();
          this.texture_ = this.helper_.createTexture(t, null, this.texture_), e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer_), e.viewport(0, 0, t[0], t[1]), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.texture_, 0), e.bindRenderbuffer(e.RENDERBUFFER, this.depthbuffer_), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, t[0], t[1]), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, this.depthbuffer_), this.data_ = new Uint8Array(t[0] * t[1] * 4);
        }
      }
      const BQ = { GENERATE_POLYGON_BUFFERS: "GENERATE_POLYGON_BUFFERS", GENERATE_POINT_BUFFERS: "GENERATE_POINT_BUFFERS", GENERATE_LINE_STRING_BUFFERS: "GENERATE_LINE_STRING_BUFFERS" };
      function iut() {
        const n = 'const t="GENERATE_POLYGON_BUFFERS",e="GENERATE_POINT_BUFFERS",n="GENERATE_LINE_STRING_BUFFERS";function r(t,e){const n=e[0],r=e[1];return e[0]=t[0]*n+t[2]*r+t[4],e[1]=t[1]*n+t[3]*r+t[5],e}function x(t,e){const n=(r=e)[0]*r[3]-r[1]*r[2];var r;!function(t,e){if(!t)throw new Error(e)}(0!==n,"Transformation matrix cannot be inverted");const x=e[0],o=e[1],u=e[2],i=e[3],f=e[4],s=e[5];return t[0]=i/n,t[1]=-o/n,t[2]=-u/n,t[3]=x/n,t[4]=(u*s-i*f)/n,t[5]=-(x*s-o*f)/n,t}function o(t,e,n=2){const r=e&&e.length,x=r?e[0]*n:t.length;let o=u(t,0,x,n,!0);const i=[];if(!o||o.next===o.prev)return i;let s,l,c;if(r&&(o=function(t,e,n,r){const x=[];for(let n=0,o=e.length;n<o;n++){const i=u(t,e[n]*r,n<o-1?e[n+1]*r:t.length,r,!1);i===i.next&&(i.steiner=!0),x.push(g(i))}x.sort(y);for(let t=0;t<x.length;t++)n=h(x[t],n);return n}(t,e,o,n)),t.length>80*n){s=1/0,l=1/0;let e=-1/0,r=-1/0;for(let o=n;o<x;o+=n){const n=t[o],x=t[o+1];n<s&&(s=n),x<l&&(l=x),n>e&&(e=n),x>r&&(r=x)}c=Math.max(e-s,r-l),c=0!==c?32767/c:0}return f(o,i,n,s,l,c,0),i}function u(t,e,n,r,x){let o;if(x===function(t,e,n,r){let x=0;for(let o=e,u=n-r;o<n;o+=r)x+=(t[u]-t[o])*(t[o+1]+t[u+1]),u=o;return x}(t,e,n,r)>0)for(let x=e;x<n;x+=r)o=z(x/r|0,t[x],t[x+1],o);else for(let x=n-r;x>=e;x-=r)o=z(x/r|0,t[x],t[x+1],o);return o&&M(o,o.next)&&(F(o),o=o.next),o}function i(t,e){if(!t)return t;e||(e=t);let n,r=t;do{if(n=!1,r.steiner||!M(r,r.next)&&0!==d(r.prev,r,r.next))r=r.next;else{if(F(r),r=e=r.prev,r===r.next)break;n=!0}}while(n||r!==e);return e}function f(t,e,n,r,x,o,u){if(!t)return;!u&&o&&function(t,e,n,r){let x=t;do{0===x.z&&(x.z=v(x.x,x.y,e,n,r)),x.prevZ=x.prev,x.nextZ=x.next,x=x.next}while(x!==t);x.prevZ.nextZ=null,x.prevZ=null,function(t){let e,n=1;do{let r,x=t;t=null;let o=null;for(e=0;x;){e++;let u=x,i=0;for(let t=0;t<n&&(i++,u=u.nextZ,u);t++);let f=n;for(;i>0||f>0&&u;)0!==i&&(0===f||!u||x.z<=u.z)?(r=x,x=x.nextZ,i--):(r=u,u=u.nextZ,f--),o?o.nextZ=r:t=r,r.prevZ=o,o=r;x=u}o.nextZ=null,n*=2}while(e>1)}(x)}(t,r,x,o);let y=t;for(;t.prev!==t.next;){const h=t.prev,p=t.next;if(o?l(t,r,x,o):s(t))e.push(h.i,t.i,p.i),F(t),t=p.next,y=p.next;else if((t=p)===y){u?1===u?f(t=c(i(t),e),e,n,r,x,o,2):2===u&&a(t,e,n,r,x,o):f(i(t),e,n,r,x,o,1);break}}}function s(t){const e=t.prev,n=t,r=t.next;if(d(e,n,r)>=0)return!1;const x=e.x,o=n.x,u=r.x,i=e.y,f=n.y,s=r.y,l=x<o?x<u?x:u:o<u?o:u,c=i<f?i<s?i:s:f<s?f:s,a=x>o?x>u?x:u:o>u?o:u,y=i>f?i>s?i:s:f>s?f:s;let h=r.next;for(;h!==e;){if(h.x>=l&&h.x<=a&&h.y>=c&&h.y<=y&&b(x,i,o,f,u,s,h.x,h.y)&&d(h.prev,h,h.next)>=0)return!1;h=h.next}return!0}function l(t,e,n,r){const x=t.prev,o=t,u=t.next;if(d(x,o,u)>=0)return!1;const i=x.x,f=o.x,s=u.x,l=x.y,c=o.y,a=u.y,y=i<f?i<s?i:s:f<s?f:s,h=l<c?l<a?l:a:c<a?c:a,p=i>f?i>s?i:s:f>s?f:s,g=l>c?l>a?l:a:c>a?c:a,Z=v(y,h,e,n,r),M=v(p,g,e,n,r);let w=t.prevZ,m=t.nextZ;for(;w&&w.z>=Z&&m&&m.z<=M;){if(w.x>=y&&w.x<=p&&w.y>=h&&w.y<=g&&w!==x&&w!==u&&b(i,l,f,c,s,a,w.x,w.y)&&d(w.prev,w,w.next)>=0)return!1;if(w=w.prevZ,m.x>=y&&m.x<=p&&m.y>=h&&m.y<=g&&m!==x&&m!==u&&b(i,l,f,c,s,a,m.x,m.y)&&d(m.prev,m,m.next)>=0)return!1;m=m.nextZ}for(;w&&w.z>=Z;){if(w.x>=y&&w.x<=p&&w.y>=h&&w.y<=g&&w!==x&&w!==u&&b(i,l,f,c,s,a,w.x,w.y)&&d(w.prev,w,w.next)>=0)return!1;w=w.prevZ}for(;m&&m.z<=M;){if(m.x>=y&&m.x<=p&&m.y>=h&&m.y<=g&&m!==x&&m!==u&&b(i,l,f,c,s,a,m.x,m.y)&&d(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function c(t,e){let n=t;do{const r=n.prev,x=n.next.next;!M(r,x)&&w(r,n,n.next,x)&&E(r,x)&&E(x,r)&&(e.push(r.i,n.i,x.i),F(n),F(n.next),n=t=x),n=n.next}while(n!==t);return i(n)}function a(t,e,n,r,x,o){let u=t;do{let t=u.next.next;for(;t!==u.prev;){if(u.i!==t.i&&Z(u,t)){let s=I(u,t);return u=i(u,u.next),s=i(s,s.next),f(u,e,n,r,x,o,0),void f(s,e,n,r,x,o,0)}t=t.next}u=u.next}while(u!==t)}function y(t,e){return t.x-e.x}function h(t,e){const n=function(t,e){let n=e;const r=t.x,x=t.y;let o,u=-1/0;do{if(x<=n.y&&x>=n.next.y&&n.next.y!==n.y){const t=n.x+(x-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=r&&t>u&&(u=t,o=n.x<n.next.x?n:n.next,t===r))return o}n=n.next}while(n!==e);if(!o)return null;const i=o,f=o.x,s=o.y;let l=1/0;n=o;do{if(r>=n.x&&n.x>=f&&r!==n.x&&b(x<s?r:u,x,f,s,x<s?u:r,x,n.x,n.y)){const e=Math.abs(x-n.y)/(r-n.x);E(n,t)&&(e<l||e===l&&(n.x>o.x||n.x===o.x&&p(o,n)))&&(o=n,l=e)}n=n.next}while(n!==i);return o}(t,e);if(!n)return e;const r=I(n,t);return i(r,r.next),i(n,n.next)}function p(t,e){return d(t.prev,t,e.prev)<0&&d(e.next,t,t.next)<0}function v(t,e,n,r,x){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-n)*x|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-r)*x|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function g(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function b(t,e,n,r,x,o,u,i){return(x-u)*(e-i)>=(t-u)*(o-i)&&(t-u)*(r-i)>=(n-u)*(e-i)&&(n-u)*(o-i)>=(x-u)*(r-i)}function Z(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&w(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(E(t,e)&&E(e,t)&&function(t,e){let n=t,r=!1;const x=(t.x+e.x)/2,o=(t.y+e.y)/2;do{n.y>o!=n.next.y>o&&n.next.y!==n.y&&x<(n.next.x-n.x)*(o-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==t);return r}(t,e)&&(d(t.prev,t,e.prev)||d(t,e.prev,e))||M(t,e)&&d(t.prev,t,t.next)>0&&d(e.prev,e,e.next)>0)}function d(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function M(t,e){return t.x===e.x&&t.y===e.y}function w(t,e,n,r){const x=A(d(t,e,n)),o=A(d(t,e,r)),u=A(d(n,r,t)),i=A(d(n,r,e));return x!==o&&u!==i||(!(0!==x||!m(t,n,e))||(!(0!==o||!m(t,r,e))||(!(0!==u||!m(n,t,r))||!(0!==i||!m(n,e,r)))))}function m(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function A(t){return t>0?1:t<0?-1:0}function E(t,e){return d(t.prev,t,t.next)<0?d(t,e,t.next)>=0&&d(t,t.prev,e)>=0:d(t,e,t.prev)<0||d(t,t.next,e)<0}function I(t,e){const n=P(t.i,t.x,t.y),r=P(e.i,e.x,e.y),x=t.next,o=e.prev;return t.next=e,e.prev=t,n.next=x,x.prev=n,r.next=n,n.prev=r,o.next=r,r.prev=o,r}function z(t,e,n,r){const x=P(t,e,n);return r?(x.next=r.next,x.prev=r,r.next.prev=x,r.next=x):(x.prev=x,x.next=x),x}function F(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function P(t,e,n){return{i:t,x:e,y:n,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}new Array(6);const B=[],N={vertexPosition:0,indexPosition:0};function R(t,e,n,r,x){t[e+0]=n,t[e+1]=r,t[e+2]=x}function S(t,e,n,r,x,o){const u=3+x,i=t[e+0],f=t[e+1],s=B;s.length=x;for(let n=0;n<s.length;n++)s[n]=t[e+2+n];let l=o?o.vertexPosition:0,c=o?o.indexPosition:0;const a=l/u;return R(n,l,i,f,0),s.length&&n.set(s,l+3),l+=u,R(n,l,i,f,1),s.length&&n.set(s,l+3),l+=u,R(n,l,i,f,2),s.length&&n.set(s,l+3),l+=u,R(n,l,i,f,3),s.length&&n.set(s,l+3),l+=u,r[c++]=a,r[c++]=a+1,r[c++]=a+3,r[c++]=a+1,r[c++]=a+2,r[c++]=a+3,N.vertexPosition=l,N.indexPosition=c,N}function T(t,e,n,x,o,u,i,f,s,l,c){const a=10+f.length,y=u.length/a,h=[t[e+0],t[e+1]],p=[t[n],t[n+1]],v=t[e+2],g=t[n+2],b=r(s,[...h]),Z=r(s,[...p]);function d(t,e,n){const r=Math.sqrt((e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])),x=[(e[0]-t[0])/r,(e[1]-t[1])/r],o=[-x[1],x[0]],u=Math.sqrt((n[0]-t[0])*(n[0]-t[0])+(n[1]-t[1])*(n[1]-t[1])),i=[(n[0]-t[0])/u,(n[1]-t[1])/u],f=0===r||0===u?0:Math.acos((s=i[0]*x[0]+i[1]*x[1],l=-1,c=1,Math.min(Math.max(s,l),c)));var s,l,c;return i[0]*o[0]+i[1]*o[1]>0?f:2*Math.PI-f}let M=-1,w=-1,m=c;const A=null!==o;if(null!==x){M=d(b,Z,r(s,[...[t[x],t[x+1]]])),Math.cos(M)<=.985&&(m+=Math.tan((M-Math.PI)/2))}if(A){w=d(Z,b,r(s,[...[t[o],t[o+1]]])),Math.cos(w)<=.985&&(m+=Math.tan((Math.PI-w)/2))}function E(t,e){return 0===e?1e4*t:Math.sign(e)*(1e4*t+Math.abs(e))}return u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(0,c)),u.push(...f),u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(1,c)),u.push(...f),u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(2,c)),u.push(...f),u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(3,c)),u.push(...f),i.push(y,y+1,y+2,y+1,y+3,y+2),{length:l+Math.sqrt((Z[0]-b[0])*(Z[0]-b[0])+(Z[1]-b[1])*(Z[1]-b[1])),angle:m}}function _(t,e,n,r,x){const u=2+x;let i=e;const f=t.slice(i,i+x);i+=x;const s=t[i++];let l=0;const c=new Array(s-1);for(let e=0;e<s;e++)l+=t[i++],e<s-1&&(c[e]=l);const a=t.slice(i,i+2*l),y=o(a,c,2);for(let t=0;t<y.length;t++)r.push(y[t]+n.length/u);for(let t=0;t<a.length;t+=2)n.push(a[t],a[t+1],...f);return i+2*l}const O=self;O.onmessage=r=>{const o=r.data;switch(o.type){case e:{const t=3,e=2,n=o.customAttributesSize,r=e+n,x=new Float32Array(o.renderInstructions),u=x.length/r,i=4*u*(n+t),f=new Uint32Array(6*u),s=new Float32Array(i);let l;for(let t=0;t<x.length;t+=r)l=S(x,t,s,f,n,l);const c=Object.assign({vertexBuffer:s.buffer,indexBuffer:f.buffer,renderInstructions:x.buffer},o);O.postMessage(c,[s.buffer,f.buffer,x.buffer]);break}case n:{const t=[],e=[],n=o.customAttributesSize,r=3,u=new Float32Array(o.renderInstructions);let i=0;const f=[1,0,0,1,0,0];let s,l;for(x(f,o.renderInstructionsTransform);i<u.length;){l=Array.from(u.slice(i,i+n)),i+=n,s=u[i++];const x=i,o=i+(s-1)*r,c=u[x]===u[o]&&u[x+1]===u[o+1];let a=0,y=0;for(let n=0;n<s-1;n++){let h=null;n>0?h=i+(n-1)*r:c&&(h=o-r);let p=null;n<s-2?p=i+(n+2)*r:c&&(p=x+r);const v=T(u,i+n*r,i+(n+1)*r,h,p,t,e,l,f,a,y);a=v.length,y=v.angle}i+=s*r}const c=Uint32Array.from(e),a=Float32Array.from(t),y=Object.assign({vertexBuffer:a.buffer,indexBuffer:c.buffer,renderInstructions:u.buffer},o);O.postMessage(y,[a.buffer,c.buffer,u.buffer]);break}case t:{const t=[],e=[],n=o.customAttributesSize,r=new Float32Array(o.renderInstructions);let x=0;for(;x<r.length;)x=_(r,x,t,e,n);const u=Uint32Array.from(e),i=Float32Array.from(t),f=Object.assign({vertexBuffer:i.buffer,indexBuffer:u.buffer,renderInstructions:r.buffer},o);O.postMessage(f,[i.buffer,u.buffer,r.buffer]);break}}};';
        return new Worker(typeof Blob == "undefined" ? "data:application/javascript;base64," + Buffer.from(n, "binary").toString("base64") : URL.createObjectURL(new Blob([n], { type: "application/javascript" })));
      }
      function rut(n, t) {
        const e = n.viewState.projection, r = t.getSource().getWrapX() && e.canWrapX(), a = e.getExtent(), o = n.extent, s = r ? ve(a) : null, l = r ? Math.ceil((o[2] - a[2]) / s) + 1 : 1;
        return [r ? Math.floor((o[0] - a[0]) / s) : 0, l, s];
      }
      class aut extends um {
        constructor(t, e) {
          var s;
          const i = e.uniforms || {}, r = wn();
          i[ys.PROJECTION_MATRIX] = r, super(t, { uniforms: i, postProcesses: e.postProcesses }), this.sourceRevision_ = -1, this.verticesBuffer_ = new am(im, jw), this.indicesBuffer_ = new am(rm, jw), this.vertexShader_ = e.vertexShader, this.fragmentShader_ = e.fragmentShader, this.program_, this.hitDetectionEnabled_ = (s = e.hitDetectionEnabled) != null ? s : true;
          const a = e.attributes ? e.attributes.map(function(l) {
            return { name: "a_prop_" + l.name, size: 1, type: Ao.FLOAT };
          }) : [];
          this.attributes = [{ name: "a_position", size: 2, type: Ao.FLOAT }, { name: "a_index", size: 1, type: Ao.FLOAT }], this.hitDetectionEnabled_ && (this.attributes.push({ name: "a_prop_hitColor", size: 4, type: Ao.FLOAT }), this.attributes.push({ name: "a_featureUid", size: 1, type: Ao.FLOAT })), this.attributes.push(...a), this.customAttributes = e.attributes ? e.attributes : [], this.previousExtent_ = Ii(), this.currentTransform_ = r, this.renderTransform_ = wn(), this.invertRenderTransform_ = wn(), this.renderInstructions_ = new Float32Array(0), this.hitRenderTarget_, this.lastSentId = 0, this.worker_ = iut(), this.worker_.addEventListener("message", (l) => {
            const u = l.data;
            if (u.type === BQ.GENERATE_POINT_BUFFERS) {
              const h = u.projectionTransform;
              this.verticesBuffer_.fromArrayBuffer(u.vertexBuffer), this.helper.flushBufferData(this.verticesBuffer_), this.indicesBuffer_.fromArrayBuffer(u.indexBuffer), this.helper.flushBufferData(this.indicesBuffer_), this.renderTransform_ = h, Oy(this.invertRenderTransform_, this.renderTransform_), this.renderInstructions_ = new Float32Array(l.data.renderInstructions), u.id === this.lastSentId && (this.ready = true), this.getLayer().changed();
            }
          }), this.featureCache_ = {}, this.featureCount_ = 0;
          const o = this.getLayer().getSource();
          this.sourceListenKeys_ = [ie(o, Qn.ADDFEATURE, this.handleSourceFeatureAdded_, this), ie(o, Qn.CHANGEFEATURE, this.handleSourceFeatureChanged_, this), ie(o, Qn.REMOVEFEATURE, this.handleSourceFeatureDelete_, this), ie(o, Qn.CLEAR, this.handleSourceFeatureClear_, this)], o.forEachFeature((l) => {
            this.featureCache_[Ft(l)] = { feature: l, properties: l.getProperties(), geometry: l.getGeometry() }, this.featureCount_++;
          });
        }
        afterHelperCreated() {
          this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_), this.hitDetectionEnabled_ && (this.hitRenderTarget_ = new nut(this.helper)), this.verticesBuffer_.getArray() && this.helper.flushBufferData(this.verticesBuffer_), this.indicesBuffer_.getArray() && this.helper.flushBufferData(this.indicesBuffer_);
        }
        handleSourceFeatureAdded_(t) {
          const e = t.feature;
          this.featureCache_[Ft(e)] = { feature: e, properties: e.getProperties(), geometry: e.getGeometry() }, this.featureCount_++;
        }
        handleSourceFeatureChanged_(t) {
          const e = t.feature;
          this.featureCache_[Ft(e)] = { feature: e, properties: e.getProperties(), geometry: e.getGeometry() };
        }
        handleSourceFeatureDelete_(t) {
          const e = t.feature;
          delete this.featureCache_[Ft(e)], this.featureCount_--;
        }
        handleSourceFeatureClear_() {
          this.featureCache_ = {}, this.featureCount_ = 0;
        }
        renderFrame(t) {
          const e = this.helper.getGL();
          this.preRender(e, t);
          const [i, r, a] = rut(t, this.getLayer());
          return this.renderWorlds(t, false, i, r, a), this.helper.finalizeDraw(t, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent), this.hitDetectionEnabled_ && (this.renderWorlds(t, true, i, r, a), this.hitRenderTarget_.clearCachedData()), this.postRender(e, t), this.helper.getCanvas();
        }
        prepareFrameInternal(t) {
          const e = this.getLayer(), i = e.getSource(), r = t.viewState, a = !t.viewHints[Fn.ANIMATING] && !t.viewHints[Fn.INTERACTING], o = !al(this.previousExtent_, t.extent), s = this.sourceRevision_ < i.getRevision();
          if (s && (this.sourceRevision_ = i.getRevision()), a && (o || s)) {
            const l = r.projection, u = r.resolution, h = e instanceof A0 ? e.getRenderBuffer() : 0, c = es(t.extent, h * u);
            i.loadFeatures(c, u, l), this.rebuildBuffers_(t), this.previousExtent_ = t.extent.slice();
          }
          return this.helper.useProgram(this.program_, t), this.helper.prepareDraw(t), this.helper.bindBuffer(this.verticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.attributes), true;
        }
        rebuildBuffers_(t) {
          const e = wn();
          this.helper.makeProjectionTransform(t, e);
          const r = (this.hitDetectionEnabled_ ? 7 : 2) + this.customAttributes.length, a = r * this.featureCount_;
          (!this.renderInstructions_ || this.renderInstructions_.length !== a) && (this.renderInstructions_ = new Float32Array(a));
          let o, s;
          const l = [], u = [];
          let h = -1;
          for (const f in this.featureCache_) if (o = this.featureCache_[f], s = o.geometry, !(!s || s.getType() !== "Point")) {
            if (l[0] = s.getFlatCoordinates()[0], l[1] = s.getFlatCoordinates()[1], gn(e, l), this.renderInstructions_[++h] = l[0], this.renderInstructions_[++h] = l[1], this.hitDetectionEnabled_) {
              const g = xot(h + 5, u);
              this.renderInstructions_[++h] = g[0], this.renderInstructions_[++h] = g[1], this.renderInstructions_[++h] = g[2], this.renderInstructions_[++h] = g[3], this.renderInstructions_[++h] = Number(f);
            }
            for (let g = 0; g < this.customAttributes.length; g++) {
              const d = this.customAttributes[g].callback(o.feature, o.properties);
              this.renderInstructions_[++h] = d;
            }
          }
          const c = { id: ++this.lastSentId, type: BQ.GENERATE_POINT_BUFFERS, renderInstructions: this.renderInstructions_.buffer, customAttributesSize: r - 2 };
          c.projectionTransform = e, this.ready = false, this.worker_.postMessage(c, [this.renderInstructions_.buffer]), this.renderInstructions_ = null;
        }
        forEachFeatureAtCoordinate(t, e, i, r, a) {
          if (he(this.hitDetectionEnabled_, "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option."), !this.renderInstructions_ || !this.hitDetectionEnabled_) return;
          const o = gn(e.coordinateToPixelTransform, t.slice()), s = this.hitRenderTarget_.readPixel(o[0] / 2, o[1] / 2), l = [s[0] / 255, s[1] / 255, s[2] / 255, s[3] / 255], u = wot(l), h = this.renderInstructions_[u], c = Math.floor(h).toString(), g = this.getLayer().getSource().getFeatureByUid(c);
          if (g) return r(g, this.getLayer(), null);
        }
        renderWorlds(t, e, i, r, a) {
          let o = i;
          this.helper.useProgram(this.program_, t), e && (this.hitRenderTarget_.setSize([Math.floor(t.size[0] / 2), Math.floor(t.size[1] / 2)]), this.helper.prepareDrawToRenderTarget(t, this.hitRenderTarget_, true)), this.helper.bindBuffer(this.verticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.attributes);
          do {
            this.helper.makeProjectionTransform(t, this.currentTransform_), ML(this.currentTransform_, o * a, 0), Fy(this.currentTransform_, this.invertRenderTransform_), this.helper.applyUniforms(t), this.helper.applyHitDetectionUniform(e);
            const s = this.indicesBuffer_.getSize();
            this.helper.drawElements(0, s);
          } while (++o < r);
        }
        disposeInternal() {
          this.worker_.terminate(), this.sourceListenKeys_.forEach(function(t) {
            Pe(t);
          }), this.sourceListenKeys_ = null, super.disposeInternal();
        }
        renderDeclutter() {
        }
      }
      const Fa = { BLUR: "blur", GRADIENT: "gradient", RADIUS: "radius" }, out = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
      class sut extends A0 {
        constructor(t) {
          t = t || {};
          const e = Object.assign({}, t);
          delete e.gradient, delete e.radius, delete e.blur, delete e.weight, super(e), this.gradient_ = null, this.addChangeListener(Fa.GRADIENT, this.handleGradientChanged_), this.setGradient(t.gradient ? t.gradient : out), this.setBlur(t.blur !== void 0 ? t.blur : 15), this.setRadius(t.radius !== void 0 ? t.radius : 8);
          const i = t.weight ? t.weight : "weight";
          this.weightFunction_ = typeof i == "string" ? (r) => r.get(i) : i, this.setRenderOrder(null);
        }
        getBlur() {
          return this.get(Fa.BLUR);
        }
        getGradient() {
          return this.get(Fa.GRADIENT);
        }
        getRadius() {
          return this.get(Fa.RADIUS);
        }
        handleGradientChanged_() {
          this.gradient_ = lut(this.getGradient());
        }
        setBlur(t) {
          this.set(Fa.BLUR, t);
        }
        setGradient(t) {
          this.set(Fa.GRADIENT, t);
        }
        setRadius(t) {
          this.set(Fa.RADIUS, t);
        }
        createRenderer() {
          const t = new Cot().addAttribute("float a_prop_weight").addVarying("v_prop_weight", "float", "a_prop_weight").addUniform("float u_size").addUniform("float u_blurSlope").setSymbolSizeExpression("vec2(u_size)").setSymbolColorExpression("vec4(smoothstep(0., 1., (1. - length(coordsPx * 2. / v_quadSizePx)) * u_blurSlope) * v_prop_weight)");
          return new aut(this, { className: this.getClassName(), attributes: [{ name: "weight", callback: (e) => {
            const i = this.weightFunction_(e);
            return i !== void 0 ? en(i, 0, 1) : 1;
          } }], uniforms: { u_size: () => (this.get(Fa.RADIUS) + this.get(Fa.BLUR)) * 2, u_blurSlope: () => this.get(Fa.RADIUS) / Math.max(1, this.get(Fa.BLUR)) }, hitDetectionEnabled: true, vertexShader: t.getSymbolVertexShader(), fragmentShader: t.getSymbolFragmentShader(), postProcesses: [{ fragmentShader: `
            precision mediump float;

            uniform sampler2D u_image;
            uniform sampler2D u_gradientTexture;
            uniform float u_opacity;

            varying vec2 v_texCoord;

            void main() {
              vec4 color = texture2D(u_image, v_texCoord);
              gl_FragColor.a = color.a * u_opacity;
              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;
              gl_FragColor.rgb *= gl_FragColor.a;
            }`, uniforms: { u_gradientTexture: () => this.gradient_, u_opacity: () => this.getOpacity() } }] });
        }
        renderDeclutter() {
        }
      }
      function lut(n) {
        const i = dn(1, 256), r = i.createLinearGradient(0, 0, 1, 256), a = 1 / (n.length - 1);
        for (let o = 0, s = n.length; o < s; ++o) r.addColorStop(o * a, n[o]);
        return i.fillStyle = r, i.fillRect(0, 0, 1, 256), i.canvas;
      }
      const TQ = (n) => {
        const t = N.inject("VMap"), e = N.unref(t).map, r = N.inject("ConfigProvide") || N.inject("$OlMapConfig");
        let a = n, o = N.shallowRef(null), s = N.shallowRef(false), l = N.ref();
        N.provide("ParentTileLayer", o);
        const u = (C) => Rt(this, null, function* () {
          if (s.value = C, a.tileType) switch (a.tileType.toUpperCase()) {
            case "TDT":
              g();
              break;
            case "OSM":
              d();
              break;
            case "TDT_SATELLITE":
              g("Satellite");
              break;
            case "TDT_TERRAIN":
              g("Terrain");
              break;
            case "BAIDU":
              A();
              break;
            case "BAIDU_SATELLITE":
              A("Satellite");
              break;
            case "BAIDU_MIDNIGHT":
              A("midnight");
              break;
            case "AMAP":
              p();
              break;
            case "AMAP_SATELLITE":
              p("Satellite");
              break;
            case "GEOTIFF":
              v();
              break;
            case "CUSTOMER":
            case "XYZ":
              c();
              break;
            default:
              f();
              break;
          }
          else f();
        }), h = (C) => Rt(this, null, function* () {
          C && C.get("group") ? C.getLayers().getArray().forEach((b) => {
            e.removeLayer(b);
          }) : e.removeLayer(C), yield u();
        }), c = () => {
          o.value = mo(a, a.source), y();
        }, f = (C = true) => {
          o.value = Jlt(a), C ? y() : N.unref(t).map.setLayers([o.value]);
        }, g = (C) => {
          const S = st(st({}, mE.tdt), r.tdt);
          let { Normal: b, Normal_Label: B, Satellite: T, Satellite_Label: D, Terrain: R, Terrain_Label: L, ak: k } = S;
          try {
            if (!k) throw new Error("ak!");
          } catch (Q) {
          }
          const P = st({}, a), F = zt(st({}, a.source), { projection: "EPSG:3857" });
          if (!C || C === "Normal") {
            const Q = mo(P, zt(st({}, F), { url: (b || "") + k }));
            Q.set("base", true);
            const z = mo(P, zt(st({}, F), { url: (B || "") + k }));
            z.set("base", true), o.value = new Pr({ layers: [Q, z] });
          } else if (C === "Satellite") {
            const Q = mo(P, zt(st({}, F), { url: (T || "") + k }));
            Q.set("base", true);
            const z = mo(P, zt(st({}, F), { url: (D || "") + k }));
            z.set("base", true), o.value = new Pr({ layers: [Q, z] });
          } else if (C === "Terrain") {
            const Q = mo(P, zt(st({}, F), { url: (R || "") + k }));
            Q.set("base", true);
            const z = mo(P, zt(st({}, F), { url: (L || "") + k }));
            z.set("base", true), o.value = new Pr({ layers: [Q, z] });
          }
          y(true);
        }, d = () => {
          const C = st({}, a), S = zt(st({}, a.source), { projection: "EPSG:3857" });
          o.value = eut(C, S), y();
        }, A = (C) => {
          const S = st(st({}, mE.baidu), r.baidu);
          let { Normal: b, Satellite: B, Satellite_Label: T, midnight: D, ak: R } = S;
          if (!C || C === "Normal") b && (o.value = mm(a, a.source, b), y());
          else if (C === "Satellite") {
            if (B && T) {
              const L = mm(a, a.source, B);
              L.set("base", true);
              const k = mm(a, a.source, T);
              k.set("base", true), o.value = new Pr({ layers: [L, k] }), y(true);
            }
          } else if (C === "midnight" && D) {
            try {
              if (!R) throw new Error("ak!");
            } catch (L) {
            }
            o.value = mm(a, a.source, D + R), y();
          }
        }, p = (C) => {
          const S = st(st({}, mE.amap), r.amap);
          let { Normal: b, Satellite: B, Satellite_Label: T } = S;
          if (!C || C === "Normal") {
            const D = zt(st({}, a.source), { url: b, projection: "GCJ:02" });
            o.value = mo(a, D), y();
          } else if (C === "Satellite") {
            const D = zt(st({}, a.source), { url: B, projection: "GCJ:02" }), R = zt(st({}, a.source), { url: T, projection: "GCJ:02" }), L = mo(a, D);
            L.set("base", true);
            const k = mo(a, R);
            k.set("base", true), o.value = new Pr({ layers: [L, k] }), y(true);
          }
        }, v = () => {
          o.value = tut(a, a.source), y();
        }, y = (C) => {
          s.value ? _() : m(C);
        }, m = (C) => {
          o.value && (o.value.set("layerTypeName", "TileLayer"), o.value.set("base", true), a.zIndex ? o.value.setZIndex(a.zIndex) : o.value.setZIndex(0), C ? (o.value.set("group", true), o.value.getLayers().getArray().forEach((B) => {
            e == null || e.addLayer(B);
          })) : e == null || e.addLayer(o.value));
        }, _ = () => {
          if (!o.value) return;
          new GJ(zt(st({}, l.value), { layers: [o.value] })).setMap(N.unref(t).map);
        }, E = (C) => Rt(this, null, function* () {
          return l.value = C, Promise.resolve();
        }), I = (C) => {
          var S;
          (S = o.value) == null || S.setVisible(C);
        }, x = () => o.value, w = () => {
          var C;
          (C = o.value) != null && C.get("group") ? o.value.getLayers().getArray().forEach((B) => {
            e == null || e.removeLayer(B);
          }) : e == null || e.removeLayer(o.value), o.value = null;
        };
        return N.watchEffect(() => {
          o.value && Dl(o.value, a);
        }), { init: u, resetTile: h, setOverviewMapOptions: E, setLayerVisible: I, getLayer: x, clearTile: w };
      }, uut = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
      let qu = (n = 21) => {
        let t = "", e = crypto.getRandomValues(new Uint8Array(n));
        for (; n--; ) t += uut[e[n] & 63];
        return t;
      };
      const MC = N.defineComponent({ name: "OlTile", __name: "index", props: { tileType: {}, layerId: { default: `tile-layer-${qu()}` }, source: { default: void 0 }, className: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, preload: {}, map: {}, useInterimTilesOnError: { type: Boolean }, properties: {}, cacheSize: {} }, setup(n) {
        const t = n, { init: e, resetTile: i, getLayer: r, clearTile: a } = TQ(t);
        let o = N.ref(false);
        return N.watch(() => t.tileType, (s, l) => {
          if (s && l && s.toUpperCase() !== l.toUpperCase()) {
            const u = r();
            u && i(u);
          }
        }, { deep: true, immediate: false }), N.watch(() => t.source, (s) => {
          if (s && t.tileType) {
            const l = r();
            l && i(l);
          }
        }, { deep: true, immediate: false }), N.onMounted(() => {
          e().then(() => {
            o.value = true;
          });
        }), N.onUnmounted(() => {
          a();
        }), (s, l) => N.unref(o) ? N.renderSlot(s.$slots, "default", { key: 0 }) : N.createCommentVNode("", true);
      } }), hut = (n) => n.component(MC.name || "OlTile", MC), DC = N.defineComponent({ name: "OlImage", __name: "index", props: { source: { default: () => ({ url: "", crossOrigin: "", projection: "EPSG:4326", imageExtent: [0, 0, 180, 90] }) }, className: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, map: {}, properties: {} }, setup(n) {
        const t = n, e = N.inject("VMap"), i = N.unref(e).map;
        let r = N.shallowRef(), a = N.ref(false);
        return N.watchEffect(() => {
          Dl(r.value, t);
        }), N.onMounted(() => {
          r.value = new Zlt(zt(st({}, t), { source: void 0 })), r.value.set("layerTypeName", "ImageLayer"), N.provide("ParentTileLayer", r), i.addLayer(r.value), a.value = true;
        }), (o, s) => N.unref(a) ? N.renderSlot(o.$slots, "default", { key: 0 }) : N.createCommentVNode("", true);
      } }), cut = (n) => n.component(DC.name || "OlImage", DC);
      class qA {
        constructor() {
          this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.featureClass = xe, this.supportedMediaTypes = null;
        }
        getReadOptions(t, e) {
          if (e) {
            let i = e.dataProjection ? Vt(e.dataProjection) : this.readProjection(t);
            e.extent && i && i.getUnits() === "tile-pixels" && (i = Vt(i), i.setWorldExtent(e.extent)), e = { dataProjection: i, featureProjection: e.featureProjection };
          }
          return this.adaptOptions(e);
        }
        adaptOptions(t) {
          return Object.assign({ dataProjection: this.dataProjection, featureProjection: this.defaultFeatureProjection, featureClass: this.featureClass }, t);
        }
        getType() {
          return Qt();
        }
        readFeature(t, e) {
          return Qt();
        }
        readFeatures(t, e) {
          return Qt();
        }
        readGeometry(t, e) {
          return Qt();
        }
        readProjection(t) {
          return Qt();
        }
        writeFeature(t, e) {
          return Qt();
        }
        writeFeatures(t, e) {
          return Qt();
        }
        writeGeometry(t, e) {
          return Qt();
        }
      }
      function sn(n, t, e) {
        const i = e ? Vt(e.featureProjection) : null, r = e ? Vt(e.dataProjection) : null;
        let a = n;
        if (i && r && !ro(i, r)) {
          t && (a = n.clone());
          const o = t ? i : r, s = t ? r : i;
          o.getUnits() === "tile-pixels" ? a.transform(o, s) : a.applyTransform(Gc(o, s));
        }
        if (t && e && e.decimals !== void 0) {
          const o = Math.pow(10, e.decimals), s = function(l) {
            for (let u = 0, h = l.length; u < h; ++u) l[u] = Math.round(l[u] * o) / o;
            return l;
          };
          a === n && (a = n.clone()), a.applyTransform(s);
        }
        return a;
      }
      function RC(n, t) {
        const e = t ? Vt(t.featureProjection) : null, i = t ? Vt(t.dataProjection) : null;
        return e && i && !ro(e, i) ? SZ(n, i, e) : n;
      }
      const fut = { Point: Oe, LineString: be, Polygon: Sn, MultiPoint: sr, MultiLineString: ri, MultiPolygon: Ci };
      function gut(n, t, e) {
        return Array.isArray(t[0]) ? (gP(n, 0, t, e) || (n = n.slice(), vx(n, 0, t, e)), n) : (px(n, 0, t, e) || (n = n.slice(), Ky(n, 0, t, e)), n);
      }
      function MQ(n, t) {
        var a;
        const e = n.geometry;
        if (!e) return [];
        if (Array.isArray(e)) return e.map((o) => MQ(zt(st({}, n), { geometry: o }))).flat();
        const i = e.type === "MultiPolygon" ? "Polygon" : e.type;
        if (i === "GeometryCollection" || i === "Circle") throw new Error("Unsupported geometry type: " + i);
        const r = e.layout.length;
        return sn(new ki(i, i === "Polygon" ? gut(e.flatCoordinates, e.ends, r) : e.flatCoordinates, (a = e.ends) == null ? void 0 : a.flat(), r, n.properties || {}, n.id).enableSimplifyTransformed(), false, t);
      }
      function LC(n, t) {
        if (!n) return null;
        if (Array.isArray(n)) {
          const i = n.map((r) => LC(r, t));
          return new yn(i);
        }
        const e = fut[n.type];
        return sn(new e(n.flatCoordinates, n.layout, n.ends), false, t);
      }
      class PC extends qA {
        constructor() {
          super();
        }
        getType() {
          return "json";
        }
        readFeature(t, e) {
          return this.readFeatureFromObject(_m(t), this.getReadOptions(t, e));
        }
        readFeatures(t, e) {
          return this.readFeaturesFromObject(_m(t), this.getReadOptions(t, e));
        }
        readFeatureFromObject(t, e) {
          return Qt();
        }
        readFeaturesFromObject(t, e) {
          return Qt();
        }
        readGeometry(t, e) {
          return this.readGeometryFromObject(_m(t), this.getReadOptions(t, e));
        }
        readGeometryFromObject(t, e) {
          return Qt();
        }
        readProjection(t) {
          return this.readProjectionFromObject(_m(t));
        }
        readProjectionFromObject(t) {
          return Qt();
        }
        writeFeature(t, e) {
          return JSON.stringify(this.writeFeatureObject(t, e));
        }
        writeFeatureObject(t, e) {
          return Qt();
        }
        writeFeatures(t, e) {
          return JSON.stringify(this.writeFeaturesObject(t, e));
        }
        writeFeaturesObject(t, e) {
          return Qt();
        }
        writeGeometry(t, e) {
          return JSON.stringify(this.writeGeometryObject(t, e));
        }
        writeGeometryObject(t, e) {
          return Qt();
        }
      }
      function _m(n) {
        if (typeof n == "string") {
          const t = JSON.parse(n);
          return t || null;
        }
        return n !== null ? n : null;
      }
      const dut = { Point: yut, LineString: mut, Polygon: xut, MultiPoint: Iut, MultiLineString: _ut, MultiPolygon: Eut }, Aut = { Point: wut, LineString: Cut, Polygon: Sut, MultiPoint: But, MultiLineString: but, MultiPolygon: Tut };
      class put extends PC {
        constructor(t) {
          t = t || {}, super(), this.geometryName_ = t.geometryName;
        }
        readFeatureFromObject(t, e, i) {
          const r = t, a = DQ(r.geometry, e), o = new xe();
          if (this.geometryName_ && o.setGeometryName(this.geometryName_), o.setGeometry(a), r.attributes) {
            o.setProperties(r.attributes, true);
            const s = r.attributes[i];
            s !== void 0 && o.setId(s);
          }
          return o;
        }
        readFeaturesFromObject(t, e) {
          if (e = e || {}, t.features) {
            const i = t, r = [], a = i.features;
            for (let o = 0, s = a.length; o < s; ++o) r.push(this.readFeatureFromObject(a[o], e, t.objectIdFieldName));
            return r;
          }
          return [this.readFeatureFromObject(t, e)];
        }
        readGeometryFromObject(t, e) {
          return DQ(t, e);
        }
        readProjectionFromObject(t) {
          if (t.spatialReference && t.spatialReference.wkid !== void 0) {
            const i = t.spatialReference.wkid;
            return Vt("EPSG:" + i);
          }
          return null;
        }
        writeGeometryObject(t, e) {
          return RQ(t, this.adaptOptions(e));
        }
        writeFeatureObject(t, e) {
          e = this.adaptOptions(e);
          const i = {};
          if (!t.hasProperties()) return i.attributes = {}, i;
          const r = t.getProperties(), a = t.getGeometry();
          if (a) {
            i.geometry = RQ(a, e);
            const o = e && (e.dataProjection || e.featureProjection);
            o && (i.geometry.spatialReference = { wkid: Number(Vt(o).getCode().split(":").pop()) }), delete r[t.getGeometryName()];
          }
          return il(r) ? i.attributes = {} : i.attributes = r, i;
        }
        writeFeaturesObject(t, e) {
          e = this.adaptOptions(e);
          const i = [];
          for (let r = 0, a = t.length; r < a; ++r) i.push(this.writeFeatureObject(t[r], e));
          return { features: i };
        }
      }
      function DQ(n, t) {
        if (!n) return null;
        let e;
        if (typeof n.x == "number" && typeof n.y == "number") e = "Point";
        else if (n.points) e = "MultiPoint";
        else if (n.paths) n.paths.length === 1 ? e = "LineString" : e = "MultiLineString";
        else if (n.rings) {
          const r = n, a = Of(r), o = vut(r.rings, a);
          o.length === 1 ? (e = "Polygon", n = Object.assign({}, n, { rings: o[0] })) : (e = "MultiPolygon", n = Object.assign({}, n, { rings: o }));
        }
        const i = dut[e];
        return sn(i(n), false, t);
      }
      function vut(n, t) {
        const e = [], i = [], r = [];
        let a, o;
        for (a = 0, o = n.length; a < o; ++a) e.length = 0, Yd(e, 0, n[a], t.length), Zy(e, 0, e.length, t.length) ? i.push([n[a]]) : r.push(n[a]);
        for (; r.length; ) {
          const s = r.shift();
          let l = false;
          for (a = i.length - 1; a >= 0; a--) {
            const u = i[a][0];
            if (br(new ao(u).getExtent(), new ao(s).getExtent())) {
              i[a].push(s), l = true;
              break;
            }
          }
          l || i.push([s.reverse()]);
        }
        return i;
      }
      function yut(n) {
        let t;
        return n.m !== void 0 && n.z !== void 0 ? t = new Oe([n.x, n.y, n.z, n.m], "XYZM") : n.z !== void 0 ? t = new Oe([n.x, n.y, n.z], "XYZ") : n.m !== void 0 ? t = new Oe([n.x, n.y, n.m], "XYM") : t = new Oe([n.x, n.y]), t;
      }
      function mut(n) {
        const t = Of(n);
        return new be(n.paths[0], t);
      }
      function _ut(n) {
        const t = Of(n);
        return new ri(n.paths, t);
      }
      function Of(n) {
        let t = "XY";
        return n.hasZ === true && n.hasM === true ? t = "XYZM" : n.hasZ === true ? t = "XYZ" : n.hasM === true && (t = "XYM"), t;
      }
      function Iut(n) {
        const t = Of(n);
        return new sr(n.points, t);
      }
      function Eut(n) {
        const t = Of(n);
        return new Ci(n.rings, t);
      }
      function xut(n) {
        const t = Of(n);
        return new Sn(n.rings, t);
      }
      function wut(n, t) {
        const e = n.getCoordinates();
        let i;
        const r = n.getLayout();
        if (r === "XYZ") i = { x: e[0], y: e[1], z: e[2] };
        else if (r === "XYM") i = { x: e[0], y: e[1], m: e[2] };
        else if (r === "XYZM") i = { x: e[0], y: e[1], z: e[2], m: e[3] };
        else if (r === "XY") i = { x: e[0], y: e[1] };
        else throw new Error("Invalid geometry layout");
        return i;
      }
      function HA(n) {
        const t = n.getLayout();
        return { hasZ: t === "XYZ" || t === "XYZM", hasM: t === "XYM" || t === "XYZM" };
      }
      function Cut(n, t) {
        const e = HA(n);
        return { hasZ: e.hasZ, hasM: e.hasM, paths: [n.getCoordinates()] };
      }
      function Sut(n, t) {
        const e = HA(n);
        return { hasZ: e.hasZ, hasM: e.hasM, rings: n.getCoordinates(false) };
      }
      function but(n, t) {
        const e = HA(n);
        return { hasZ: e.hasZ, hasM: e.hasM, paths: n.getCoordinates() };
      }
      function But(n, t) {
        const e = HA(n);
        return { hasZ: e.hasZ, hasM: e.hasM, points: n.getCoordinates() };
      }
      function Tut(n, t) {
        const e = HA(n), i = n.getCoordinates(false), r = [];
        for (let a = 0; a < i.length; a++) for (let o = i[a].length - 1; o >= 0; o--) r.push(i[a][o]);
        return { hasZ: e.hasZ, hasM: e.hasM, rings: r };
      }
      function RQ(n, t) {
        const e = Aut[n.getType()];
        return e(sn(n, true, t), t);
      }
      class zf extends PC {
        constructor(t) {
          t = t || {}, super(), this.dataProjection = Vt(t.dataProjection ? t.dataProjection : "EPSG:4326"), t.featureProjection && (this.defaultFeatureProjection = Vt(t.featureProjection)), t.featureClass && (this.featureClass = t.featureClass), this.geometryName_ = t.geometryName, this.extractGeometryName_ = t.extractGeometryName, this.supportedMediaTypes = ["application/geo+json", "application/vnd.geo+json"];
        }
        readFeatureFromObject(t, e) {
          let i = null;
          t.type === "Feature" ? i = t : i = { type: "Feature", geometry: t, properties: null };
          const r = NC(i.geometry);
          if (this.featureClass === ki) return MQ({ geometry: r, id: i.id, properties: i.properties }, e);
          const a = new xe();
          return this.geometryName_ ? a.setGeometryName(this.geometryName_) : this.extractGeometryName_ && i.geometry_name && a.setGeometryName(i.geometry_name), a.setGeometry(LC(r, e)), "id" in i && a.setId(i.id), i.properties && a.setProperties(i.properties, true), a;
        }
        readFeaturesFromObject(t, e) {
          const i = t;
          let r = null;
          if (i.type === "FeatureCollection") {
            const a = t;
            r = [];
            const o = a.features;
            for (let s = 0, l = o.length; s < l; ++s) {
              const u = this.readFeatureFromObject(o[s], e);
              u && r.push(u);
            }
          } else r = [this.readFeatureFromObject(t, e)];
          return r.flat();
        }
        readGeometryFromObject(t, e) {
          return Mut(t, e);
        }
        readProjectionFromObject(t) {
          const e = t.crs;
          let i;
          if (e) if (e.type == "name") i = Vt(e.properties.name);
          else if (e.type === "EPSG") i = Vt("EPSG:" + e.properties.code);
          else throw new Error("Unknown SRS type");
          else i = this.dataProjection;
          return i;
        }
        writeFeatureObject(t, e) {
          e = this.adaptOptions(e);
          const i = { type: "Feature", geometry: null, properties: null }, r = t.getId();
          if (r !== void 0 && (i.id = r), !t.hasProperties()) return i;
          const a = t.getProperties(), o = t.getGeometry();
          return o && (i.geometry = kC(o, e), delete a[t.getGeometryName()]), il(a) || (i.properties = a), i;
        }
        writeFeaturesObject(t, e) {
          e = this.adaptOptions(e);
          const i = [];
          for (let r = 0, a = t.length; r < a; ++r) i.push(this.writeFeatureObject(t[r], e));
          return { type: "FeatureCollection", features: i };
        }
        writeGeometryObject(t, e) {
          return kC(t, this.adaptOptions(e));
        }
      }
      function NC(n, t) {
        if (!n) return null;
        let e;
        switch (n.type) {
          case "Point": {
            e = Rut(n);
            break;
          }
          case "LineString": {
            e = Lut(n);
            break;
          }
          case "Polygon": {
            e = Fut(n);
            break;
          }
          case "MultiPoint": {
            e = Nut(n);
            break;
          }
          case "MultiLineString": {
            e = Put(n);
            break;
          }
          case "MultiPolygon": {
            e = kut(n);
            break;
          }
          case "GeometryCollection": {
            e = Dut(n);
            break;
          }
          default:
            throw new Error("Unsupported GeoJSON type: " + n.type);
        }
        return e;
      }
      function Mut(n, t) {
        const e = NC(n);
        return LC(e, t);
      }
      function Dut(n, t) {
        return n.geometries.map(function(i) {
          return NC(i);
        });
      }
      function Rut(n) {
        const t = n.coordinates;
        return { type: "Point", flatCoordinates: t, layout: Du(t.length) };
      }
      function Lut(n) {
        var i;
        const t = n.coordinates, e = t.flat();
        return { type: "LineString", flatCoordinates: e, ends: [e.length], layout: Du(((i = t[0]) == null ? void 0 : i.length) || 2) };
      }
      function Put(n) {
        var a, o;
        const t = n.coordinates, e = ((o = (a = t[0]) == null ? void 0 : a[0]) == null ? void 0 : o.length) || 2, i = [], r = Wd(i, 0, t, e);
        return { type: "MultiLineString", flatCoordinates: i, ends: r, layout: Du(e) };
      }
      function Nut(n) {
        var e;
        const t = n.coordinates;
        return { type: "MultiPoint", flatCoordinates: t.flat(), layout: Du(((e = t[0]) == null ? void 0 : e.length) || 2) };
      }
      function kut(n) {
        var a, o;
        const t = n.coordinates, e = [], i = ((o = (a = t[0]) == null ? void 0 : a[0]) == null ? void 0 : o[0].length) || 2, r = aP(e, 0, t, i);
        return { type: "MultiPolygon", flatCoordinates: e, ends: r, layout: Du(i) };
      }
      function Fut(n) {
        var a, o;
        const t = n.coordinates, e = [], i = (o = (a = t[0]) == null ? void 0 : a[0]) == null ? void 0 : o.length, r = Wd(e, 0, t, i);
        return { type: "Polygon", flatCoordinates: e, ends: r, layout: Du(i) };
      }
      function kC(n, t) {
        n = sn(n, true, t);
        const e = n.getType();
        let i;
        switch (e) {
          case "Point": {
            i = Vut(n);
            break;
          }
          case "LineString": {
            i = Out(n);
            break;
          }
          case "Polygon": {
            i = jut(n, t);
            break;
          }
          case "MultiPoint": {
            i = Gut(n);
            break;
          }
          case "MultiLineString": {
            i = zut(n);
            break;
          }
          case "MultiPolygon": {
            i = Uut(n, t);
            break;
          }
          case "GeometryCollection": {
            i = Qut(n, t);
            break;
          }
          case "Circle": {
            i = { type: "GeometryCollection", geometries: [] };
            break;
          }
          default:
            throw new Error("Unsupported geometry type: " + e);
        }
        return i;
      }
      function Qut(n, t) {
        return t = Object.assign({}, t), delete t.featureProjection, { type: "GeometryCollection", geometries: n.getGeometriesArray().map(function(i) {
          return kC(i, t);
        }) };
      }
      function Out(n, t) {
        return { type: "LineString", coordinates: n.getCoordinates() };
      }
      function zut(n, t) {
        return { type: "MultiLineString", coordinates: n.getCoordinates() };
      }
      function Gut(n, t) {
        return { type: "MultiPoint", coordinates: n.getCoordinates() };
      }
      function Uut(n, t) {
        let e;
        return t && (e = t.rightHanded), { type: "MultiPolygon", coordinates: n.getCoordinates(e) };
      }
      function Vut(n, t) {
        return { type: "Point", coordinates: n.getCoordinates() };
      }
      function jut(n, t) {
        let e;
        return t && (e = t.rightHanded), { type: "Polygon", coordinates: n.getCoordinates(e) };
      }
      const Hu = "http://www.w3.org/2001/XMLSchema-instance";
      function $t(n, t) {
        return Gf().createElementNS(n, t);
      }
      function Gi(n, t) {
        return LQ(n, t, []).join("");
      }
      function LQ(n, t, e) {
        if (n.nodeType == Node.CDATA_SECTION_NODE || n.nodeType == Node.TEXT_NODE) e.push(n.nodeValue);
        else {
          let i;
          for (i = n.firstChild; i; i = i.nextSibling) LQ(i, t, e);
        }
        return e;
      }
      function ta(n) {
        return "documentElement" in n;
      }
      function qut(n, t, e) {
        return n.getAttributeNS(t, e) || "";
      }
      function ea(n) {
        return new DOMParser().parseFromString(n, "application/xml");
      }
      function Im(n, t) {
        return function(e, i) {
          const r = n.call(t != null ? t : this, e, i);
          if (r !== void 0) {
            const a = i[i.length - 1];
            De(a, r);
          }
        };
      }
      function Tt(n, t) {
        return function(e, i) {
          const r = n.call(t != null ? t : this, e, i);
          r !== void 0 && i[i.length - 1].push(r);
        };
      }
      function Gt(n, t) {
        return function(e, i) {
          const r = n.call(t != null ? t : this, e, i);
          r !== void 0 && (i[i.length - 1] = r);
        };
      }
      function Ge(n, t, e) {
        return function(i, r) {
          const a = n.call(this, i, r);
          if (a !== void 0) {
            const o = r[r.length - 1], s = i.localName;
            let l;
            s in o ? l = o[s] : (l = [], o[s] = l), l.push(a);
          }
        };
      }
      function O(n, t, e) {
        return function(i, r) {
          const a = n.call(this, i, r);
          if (a !== void 0) {
            const o = r[r.length - 1], s = t !== void 0 ? t : i.localName;
            o[s] = a;
          }
        };
      }
      function U(n, t) {
        return function(e, i, r) {
          n.call(t != null ? t : this, e, i, r), r[r.length - 1].node.appendChild(e);
        };
      }
      function PQ(n, t) {
        let e, i;
        return function(r, a, o) {
          if (e === void 0) {
            e = {};
            const s = {};
            s[r.localName] = n, e[r.namespaceURI] = s, i = pn(r.localName);
          }
          NQ(e, i, a, o);
        };
      }
      function pn(n, t) {
        return function(e, i, r) {
          const o = i[i.length - 1].node;
          let s = n;
          s === void 0 && (s = r);
          const l = t !== void 0 ? t : o.namespaceURI;
          return $t(l, s);
        };
      }
      const ai = pn();
      function fr(n, t) {
        const e = t.length, i = new Array(e);
        for (let r = 0; r < e; ++r) i[r] = n[t[r]];
        return i;
      }
      function K(n, t, e) {
        e = e !== void 0 ? e : {};
        let i, r;
        for (i = 0, r = n.length; i < r; ++i) e[n[i]] = t;
        return e;
      }
      function gr(n, t, e, i) {
        let r;
        for (r = t.firstElementChild; r; r = r.nextElementSibling) {
          const a = n[r.namespaceURI];
          if (a !== void 0) {
            const o = a[r.localName];
            o !== void 0 && o.call(i, r, e);
          }
        }
      }
      function rt(n, t, e, i, r) {
        return i.push(n), gr(t, e, i, r), i.pop();
      }
      function NQ(n, t, e, i, r, a) {
        const o = (r !== void 0 ? r : e).length;
        let s, l;
        for (let u = 0; u < o; ++u) s = e[u], s !== void 0 && (l = t.call(a, s, i, r !== void 0 ? r[u] : void 0), l !== void 0 && n[l.namespaceURI][l.localName].call(a, l, s, i));
      }
      function Xt(n, t, e, i, r, a, o) {
        return r.push(n), NQ(t, e, i, r, a, o), r.pop();
      }
      let FC;
      function Hut() {
        return FC === void 0 && typeof XMLSerializer != "undefined" && (FC = new XMLSerializer()), FC;
      }
      let QC;
      function Gf() {
        return QC === void 0 && typeof document != "undefined" && (QC = document.implementation.createDocument("", "", null)), QC;
      }
      class YA extends qA {
        constructor() {
          super(), this.xmlSerializer_ = Hut();
        }
        getType() {
          return "xml";
        }
        readFeature(t, e) {
          if (!t) return null;
          if (typeof t == "string") {
            const i = ea(t);
            return this.readFeatureFromDocument(i, e);
          }
          return ta(t) ? this.readFeatureFromDocument(t, e) : this.readFeatureFromNode(t, e);
        }
        readFeatureFromDocument(t, e) {
          const i = this.readFeaturesFromDocument(t, e);
          return i.length > 0 ? i[0] : null;
        }
        readFeatureFromNode(t, e) {
          return null;
        }
        readFeatures(t, e) {
          if (!t) return [];
          if (typeof t == "string") {
            const i = ea(t);
            return this.readFeaturesFromDocument(i, e);
          }
          return ta(t) ? this.readFeaturesFromDocument(t, e) : this.readFeaturesFromNode(t, e);
        }
        readFeaturesFromDocument(t, e) {
          const i = [];
          for (let r = t.firstChild; r; r = r.nextSibling) r.nodeType == Node.ELEMENT_NODE && De(i, this.readFeaturesFromNode(r, e));
          return i;
        }
        readFeaturesFromNode(t, e) {
          return Qt();
        }
        readGeometry(t, e) {
          if (!t) return null;
          if (typeof t == "string") {
            const i = ea(t);
            return this.readGeometryFromDocument(i, e);
          }
          return ta(t) ? this.readGeometryFromDocument(t, e) : this.readGeometryFromNode(t, e);
        }
        readGeometryFromDocument(t, e) {
          return null;
        }
        readGeometryFromNode(t, e) {
          return null;
        }
        readProjection(t) {
          if (!t) return null;
          if (typeof t == "string") {
            const e = ea(t);
            return this.readProjectionFromDocument(e);
          }
          return ta(t) ? this.readProjectionFromDocument(t) : this.readProjectionFromNode(t);
        }
        readProjectionFromDocument(t) {
          return this.dataProjection;
        }
        readProjectionFromNode(t) {
          return this.dataProjection;
        }
        writeFeature(t, e) {
          const i = this.writeFeatureNode(t, e);
          return this.xmlSerializer_.serializeToString(i);
        }
        writeFeatureNode(t, e) {
          return null;
        }
        writeFeatures(t, e) {
          const i = this.writeFeaturesNode(t, e);
          return this.xmlSerializer_.serializeToString(i);
        }
        writeFeaturesNode(t, e) {
          return null;
        }
        writeGeometry(t, e) {
          const i = this.writeGeometryNode(t, e);
          return this.xmlSerializer_.serializeToString(i);
        }
        writeGeometryNode(t, e) {
          return null;
        }
      }
      const ms = "http://www.opengis.net/gml", Yut = /^\s*$/;
      class Mt extends YA {
        constructor(t) {
          super(), t = t || {}, this.featureType = t.featureType, this.featureNS = t.featureNS, this.srsName = t.srsName, this.schemaLocation = "", this.FEATURE_COLLECTION_PARSERS = {}, this.FEATURE_COLLECTION_PARSERS[this.namespace] = { featureMember: Tt(this.readFeaturesInternal), featureMembers: Gt(this.readFeaturesInternal) }, this.supportedMediaTypes = ["application/gml+xml"];
        }
        readFeaturesInternal(t, e) {
          const i = t.localName;
          let r = null;
          if (i == "FeatureCollection") r = rt([], this.FEATURE_COLLECTION_PARSERS, t, e, this);
          else if (i == "featureMembers" || i == "featureMember" || i == "member") {
            const a = e[0];
            let o = a.featureType, s = a.featureNS;
            const l = "p", u = "p0";
            if (!o && t.childNodes) {
              o = [], s = {};
              for (let f = 0, g = t.childNodes.length; f < g; ++f) {
                const d = t.childNodes[f];
                if (d.nodeType === 1) {
                  const A = d.nodeName.split(":").pop();
                  if (!o.includes(A)) {
                    let p = "", v = 0;
                    const y = d.namespaceURI;
                    for (const m in s) {
                      if (s[m] === y) {
                        p = m;
                        break;
                      }
                      ++v;
                    }
                    p || (p = l + v, s[p] = y), o.push(p + ":" + A);
                  }
                }
              }
              i != "featureMember" && (a.featureType = o, a.featureNS = s);
            }
            if (typeof s == "string") {
              const f = s;
              s = {}, s[u] = f;
            }
            const h = {}, c = Array.isArray(o) ? o : [o];
            for (const f in s) {
              const g = {};
              for (let d = 0, A = c.length; d < A; ++d) (c[d].includes(":") ? c[d].split(":")[0] : u) === f && (g[c[d].split(":").pop()] = i == "featureMembers" ? Tt(this.readFeatureElement, this) : Gt(this.readFeatureElement, this));
              h[s[f]] = g;
            }
            i == "featureMember" || i == "member" ? r = rt(void 0, h, t, e) : r = rt([], h, t, e);
          }
          return r === null && (r = []), r;
        }
        readGeometryOrExtent(t, e) {
          const i = e[0];
          return i.srsName = t.firstElementChild.getAttribute("srsName"), i.srsDimension = t.firstElementChild.getAttribute("srsDimension"), rt(null, this.GEOMETRY_PARSERS, t, e, this);
        }
        readExtentElement(t, e) {
          const i = e[0], r = this.readGeometryOrExtent(t, e);
          return r ? RC(r, i) : void 0;
        }
        readGeometryElement(t, e) {
          const i = e[0], r = this.readGeometryOrExtent(t, e);
          return r ? sn(r, false, i) : void 0;
        }
        readFeatureElementInternal(t, e, i) {
          let r;
          const a = {};
          for (let l = t.firstElementChild; l; l = l.nextElementSibling) {
            let u;
            const h = l.localName;
            l.childNodes.length === 0 || l.childNodes.length === 1 && (l.firstChild.nodeType === 3 || l.firstChild.nodeType === 4) ? (u = Gi(l, false), Yut.test(u) && (u = void 0)) : (i && (u = h === "boundedBy" ? this.readExtentElement(l, e) : this.readGeometryElement(l, e)), u ? h !== "boundedBy" && (r = h) : u = this.readFeatureElementInternal(l, e, false));
            const c = l.attributes.length;
            if (c > 0 && !(u instanceof Yy)) {
              u = { _content_: u };
              for (let f = 0; f < c; f++) {
                const g = l.attributes[f].name;
                u[g] = l.attributes[f].value;
              }
            }
            a[h] ? (a[h] instanceof Array || (a[h] = [a[h]]), a[h].push(u)) : a[h] = u;
          }
          if (!i) return a;
          const o = new xe(a);
          r && o.setGeometryName(r);
          const s = t.getAttribute("fid") || qut(t, this.namespace, "id");
          return s && o.setId(s), o;
        }
        readFeatureElement(t, e) {
          return this.readFeatureElementInternal(t, e, true);
        }
        readPoint(t, e) {
          const i = this.readFlatCoordinatesFromNode(t, e);
          if (i) return new Oe(i, "XYZ");
        }
        readMultiPoint(t, e) {
          const i = rt([], this.MULTIPOINT_PARSERS, t, e, this);
          if (i) return new sr(i);
        }
        readMultiLineString(t, e) {
          const i = rt([], this.MULTILINESTRING_PARSERS, t, e, this);
          if (i) return new ri(i);
        }
        readMultiPolygon(t, e) {
          const i = rt([], this.MULTIPOLYGON_PARSERS, t, e, this);
          if (i) return new Ci(i);
        }
        pointMemberParser(t, e) {
          gr(this.POINTMEMBER_PARSERS, t, e, this);
        }
        lineStringMemberParser(t, e) {
          gr(this.LINESTRINGMEMBER_PARSERS, t, e, this);
        }
        polygonMemberParser(t, e) {
          gr(this.POLYGONMEMBER_PARSERS, t, e, this);
        }
        readLineString(t, e) {
          const i = this.readFlatCoordinatesFromNode(t, e);
          if (i) return new be(i, "XYZ");
        }
        readFlatLinearRing(t, e) {
          const i = rt(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, t, e, this);
          if (i) return i;
        }
        readLinearRing(t, e) {
          const i = this.readFlatCoordinatesFromNode(t, e);
          if (i) return new ao(i, "XYZ");
        }
        readPolygon(t, e) {
          const i = rt([null], this.FLAT_LINEAR_RINGS_PARSERS, t, e, this);
          if (i && i[0]) {
            const r = i[0], a = [r.length];
            let o, s;
            for (o = 1, s = i.length; o < s; ++o) De(r, i[o]), a.push(r.length);
            return new Sn(r, "XYZ", a);
          }
        }
        readFlatCoordinatesFromNode(t, e) {
          return rt(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, t, e, this);
        }
        readGeometryFromNode(t, e) {
          const i = this.readGeometryElement(t, [this.getReadOptions(t, e || {})]);
          return i || null;
        }
        readFeaturesFromNode(t, e) {
          const i = { featureType: this.featureType, featureNS: this.featureNS };
          return i && Object.assign(i, this.getReadOptions(t, e)), this.readFeaturesInternal(t, [i]) || [];
        }
        readProjectionFromNode(t) {
          return Vt(this.srsName ? this.srsName : t.firstElementChild.getAttribute("srsName"));
        }
      }
      Mt.prototype.namespace = ms, Mt.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml": {} }, Mt.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml": {} }, Mt.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml": {} }, Mt.prototype.MULTIPOINT_PARSERS = { "http://www.opengis.net/gml": { pointMember: Tt(Mt.prototype.pointMemberParser), pointMembers: Tt(Mt.prototype.pointMemberParser) } }, Mt.prototype.MULTILINESTRING_PARSERS = { "http://www.opengis.net/gml": { lineStringMember: Tt(Mt.prototype.lineStringMemberParser), lineStringMembers: Tt(Mt.prototype.lineStringMemberParser) } }, Mt.prototype.MULTIPOLYGON_PARSERS = { "http://www.opengis.net/gml": { polygonMember: Tt(Mt.prototype.polygonMemberParser), polygonMembers: Tt(Mt.prototype.polygonMemberParser) } }, Mt.prototype.POINTMEMBER_PARSERS = { "http://www.opengis.net/gml": { Point: Tt(Mt.prototype.readFlatCoordinatesFromNode) } }, Mt.prototype.LINESTRINGMEMBER_PARSERS = { "http://www.opengis.net/gml": { LineString: Tt(Mt.prototype.readLineString) } }, Mt.prototype.POLYGONMEMBER_PARSERS = { "http://www.opengis.net/gml": { Polygon: Tt(Mt.prototype.readPolygon) } }, Mt.prototype.RING_PARSERS = { "http://www.opengis.net/gml": { LinearRing: Gt(Mt.prototype.readFlatLinearRing) } };
      function Rl(n) {
        const t = Gi(n, false);
        return na(t);
      }
      function na(n) {
        const t = /^\s*(true|1)|(false|0)\s*$/.exec(n);
        if (t) return t[1] !== void 0 || false;
      }
      function Em(n) {
        const t = Gi(n, false), e = Date.parse(t);
        return isNaN(e) ? void 0 : e / 1e3;
      }
      function me(n) {
        const t = Gi(n, false);
        return Qa(t);
      }
      function Qa(n) {
        const t = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(n);
        if (t) return parseFloat(t[1]);
      }
      function mn(n) {
        const t = Gi(n, false);
        return _s(t);
      }
      function _s(n) {
        const t = /^\s*(\d+)\s*$/.exec(n);
        if (t) return parseInt(t[1], 10);
      }
      function at(n) {
        return Gi(n, false).trim();
      }
      function Uf(n, t) {
        Yt(n, t ? "1" : "0");
      }
      function Wut(n, t) {
        n.appendChild(Gf().createCDATASection(t));
      }
      function Xut(n, t) {
        const e = new Date(t * 1e3), i = e.getUTCFullYear() + "-" + Vd(e.getUTCMonth() + 1, 2) + "-" + Vd(e.getUTCDate(), 2) + "T" + Vd(e.getUTCHours(), 2) + ":" + Vd(e.getUTCMinutes(), 2) + ":" + Vd(e.getUTCSeconds(), 2) + "Z";
        n.appendChild(Gf().createTextNode(i));
      }
      function dr(n, t) {
        const e = t.toPrecision();
        n.appendChild(Gf().createTextNode(e));
      }
      function xm(n, t) {
        const e = t.toString();
        n.appendChild(Gf().createTextNode(e));
      }
      function Yt(n, t) {
        n.appendChild(Gf().createTextNode(t));
      }
      const Zut = ms + " http://schemas.opengis.net/gml/2.1.2/feature.xsd", Kut = { MultiLineString: "lineStringMember", MultiCurve: "curveMember", MultiPolygon: "polygonMember", MultiSurface: "surfaceMember" };
      class Ae extends Mt {
        constructor(t) {
          t = t || {}, super(t), this.FEATURE_COLLECTION_PARSERS[ms].featureMember = Tt(this.readFeaturesInternal), this.schemaLocation = t.schemaLocation ? t.schemaLocation : Zut;
        }
        readFlatCoordinates(t, e) {
          const i = Gi(t, false).replace(/^\s*|\s*$/g, ""), a = e[0].srsName;
          let o = "enu";
          if (a) {
            const u = Vt(a);
            u && (o = u.getAxisOrientation());
          }
          const s = i.trim().split(/\s+/), l = [];
          for (let u = 0, h = s.length; u < h; u++) {
            const c = s[u].split(/,+/), f = parseFloat(c[0]), g = parseFloat(c[1]), d = c.length === 3 ? parseFloat(c[2]) : 0;
            o.startsWith("en") ? l.push(f, g, d) : l.push(g, f, d);
          }
          return l;
        }
        readBox(t, e) {
          const i = rt([null], this.BOX_PARSERS_, t, e, this);
          return Xr(i[1][0], i[1][1], i[1][3], i[1][4]);
        }
        innerBoundaryIsParser(t, e) {
          const i = rt(void 0, this.RING_PARSERS, t, e, this);
          i && e[e.length - 1].push(i);
        }
        outerBoundaryIsParser(t, e) {
          const i = rt(void 0, this.RING_PARSERS, t, e, this);
          if (i) {
            const r = e[e.length - 1];
            r[0] = i;
          }
        }
        GEOMETRY_NODE_FACTORY_(t, e, i) {
          const r = e[e.length - 1], a = r.multiSurface, o = r.surface, s = r.multiCurve;
          return Array.isArray(t) ? i = "Envelope" : (i = t.getType(), i === "MultiPolygon" && a === true ? i = "MultiSurface" : i === "Polygon" && o === true ? i = "Surface" : i === "MultiLineString" && s === true && (i = "MultiCurve")), $t("http://www.opengis.net/gml", i);
        }
        writeFeatureElement(t, e, i) {
          const r = e.getId();
          r && t.setAttribute("fid", r);
          const a = i[i.length - 1], o = a.featureNS, s = e.getGeometryName();
          a.serializers || (a.serializers = {}, a.serializers[o] = {});
          const l = [], u = [];
          if (e.hasProperties()) {
            const c = e.getProperties();
            for (const f in c) {
              const g = c[f];
              g != null && (l.push(f), u.push(g), f == s || typeof g.getSimplifiedGeometry == "function" ? f in a.serializers[o] || (a.serializers[o][f] = U(this.writeGeometryElement, this)) : f in a.serializers[o] || (a.serializers[o][f] = U(Yt)));
            }
          }
          const h = Object.assign({}, a);
          h.node = t, Xt(h, a.serializers, pn(void 0, o), u, i, l);
        }
        writeCurveOrLineString(t, e, i) {
          const a = i[i.length - 1].srsName;
          if (t.nodeName !== "LineStringSegment" && a && t.setAttribute("srsName", a), t.nodeName === "LineString" || t.nodeName === "LineStringSegment") {
            const o = this.createCoordinatesNode_(t.namespaceURI);
            t.appendChild(o), this.writeCoordinates_(o, e, i);
          } else if (t.nodeName === "Curve") {
            const o = $t(t.namespaceURI, "segments");
            t.appendChild(o), this.writeCurveSegments_(o, e, i);
          }
        }
        writeLineStringOrCurveMember(t, e, i) {
          const r = this.GEOMETRY_NODE_FACTORY_(e, i);
          r && (t.appendChild(r), this.writeCurveOrLineString(r, e, i));
        }
        writeMultiCurveOrLineString(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName, s = r.curve;
          o && t.setAttribute("srsName", o);
          const l = e.getLineStrings();
          Xt({ node: t, hasZ: a, srsName: o, curve: s }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, l, i, void 0, this);
        }
        writeGeometryElement(t, e, i) {
          const r = i[i.length - 1], a = Object.assign({}, r);
          a.node = t;
          let o;
          Array.isArray(e) ? o = RC(e, r) : o = sn(e, true, r), Xt(a, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [o], i, void 0, this);
        }
        createCoordinatesNode_(t) {
          const e = $t(t, "coordinates");
          return e.setAttribute("decimal", "."), e.setAttribute("cs", ","), e.setAttribute("ts", " "), e;
        }
        writeCoordinates_(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName, s = e.getCoordinates(), l = s.length, u = new Array(l);
          for (let h = 0; h < l; ++h) {
            const c = s[h];
            u[h] = this.getCoords_(c, o, a);
          }
          Yt(t, u.join(" "));
        }
        writeCurveSegments_(t, e, i) {
          const r = $t(t.namespaceURI, "LineStringSegment");
          t.appendChild(r), this.writeCurveOrLineString(r, e, i);
        }
        writeSurfaceOrPolygon(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName;
          if (t.nodeName !== "PolygonPatch" && o && t.setAttribute("srsName", o), t.nodeName === "Polygon" || t.nodeName === "PolygonPatch") {
            const s = e.getLinearRings();
            Xt({ node: t, hasZ: a, srsName: o }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, s, i, void 0, this);
          } else if (t.nodeName === "Surface") {
            const s = $t(t.namespaceURI, "patches");
            t.appendChild(s), this.writeSurfacePatches_(s, e, i);
          }
        }
        RING_NODE_FACTORY_(t, e, i) {
          const r = e[e.length - 1], a = r.node, o = r.exteriorWritten;
          return o === void 0 && (r.exteriorWritten = true), $t(a.namespaceURI, o !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs");
        }
        writeSurfacePatches_(t, e, i) {
          const r = $t(t.namespaceURI, "PolygonPatch");
          t.appendChild(r), this.writeSurfaceOrPolygon(r, e, i);
        }
        writeRing(t, e, i) {
          const r = $t(t.namespaceURI, "LinearRing");
          t.appendChild(r), this.writeLinearRing(r, e, i);
        }
        getCoords_(t, e, i) {
          let a = (e ? Vt(e).getAxisOrientation() : "enu").startsWith("en") ? t[0] + "," + t[1] : t[1] + "," + t[0];
          if (i) {
            const o = t[2] || 0;
            a += "," + o;
          }
          return a;
        }
        writePoint(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName;
          o && t.setAttribute("srsName", o);
          const s = this.createCoordinatesNode_(t.namespaceURI);
          t.appendChild(s);
          const l = e.getCoordinates(), u = this.getCoords_(l, o, a);
          Yt(s, u);
        }
        writeMultiPoint(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName;
          o && t.setAttribute("srsName", o);
          const s = e.getPoints();
          Xt({ node: t, hasZ: a, srsName: o }, this.POINTMEMBER_SERIALIZERS, pn("pointMember"), s, i, void 0, this);
        }
        writePointMember(t, e, i) {
          const r = $t(t.namespaceURI, "Point");
          t.appendChild(r), this.writePoint(r, e, i);
        }
        writeLinearRing(t, e, i) {
          const a = i[i.length - 1].srsName;
          a && t.setAttribute("srsName", a);
          const o = this.createCoordinatesNode_(t.namespaceURI);
          t.appendChild(o), this.writeCoordinates_(o, e, i);
        }
        writeMultiSurfaceOrPolygon(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName, s = r.surface;
          o && t.setAttribute("srsName", o);
          const l = e.getPolygons();
          Xt({ node: t, hasZ: a, srsName: o, surface: s }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, l, i, void 0, this);
        }
        writeSurfaceOrPolygonMember(t, e, i) {
          const r = this.GEOMETRY_NODE_FACTORY_(e, i);
          r && (t.appendChild(r), this.writeSurfaceOrPolygon(r, e, i));
        }
        writeEnvelope(t, e, i) {
          const a = i[i.length - 1].srsName;
          a && t.setAttribute("srsName", a);
          const o = ["lowerCorner", "upperCorner"], s = [e[0] + " " + e[1], e[2] + " " + e[3]];
          Xt({ node: t }, this.ENVELOPE_SERIALIZERS, ai, s, i, o, this);
        }
        MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, e, i) {
          const r = e[e.length - 1].node;
          return $t("http://www.opengis.net/gml", Kut[r.nodeName]);
        }
      }
      Ae.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml": { coordinates: Gt(Ae.prototype.readFlatCoordinates) } }, Ae.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml": { innerBoundaryIs: Ae.prototype.innerBoundaryIsParser, outerBoundaryIs: Ae.prototype.outerBoundaryIsParser } }, Ae.prototype.BOX_PARSERS_ = { "http://www.opengis.net/gml": { coordinates: Tt(Ae.prototype.readFlatCoordinates) } }, Ae.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml": { Point: Gt(Mt.prototype.readPoint), MultiPoint: Gt(Mt.prototype.readMultiPoint), LineString: Gt(Mt.prototype.readLineString), MultiLineString: Gt(Mt.prototype.readMultiLineString), LinearRing: Gt(Mt.prototype.readLinearRing), Polygon: Gt(Mt.prototype.readPolygon), MultiPolygon: Gt(Mt.prototype.readMultiPolygon), Box: Gt(Ae.prototype.readBox) } }, Ae.prototype.GEOMETRY_SERIALIZERS = { "http://www.opengis.net/gml": { Curve: U(Ae.prototype.writeCurveOrLineString), MultiCurve: U(Ae.prototype.writeMultiCurveOrLineString), Point: U(Ae.prototype.writePoint), MultiPoint: U(Ae.prototype.writeMultiPoint), LineString: U(Ae.prototype.writeCurveOrLineString), MultiLineString: U(Ae.prototype.writeMultiCurveOrLineString), LinearRing: U(Ae.prototype.writeLinearRing), Polygon: U(Ae.prototype.writeSurfaceOrPolygon), MultiPolygon: U(Ae.prototype.writeMultiSurfaceOrPolygon), Surface: U(Ae.prototype.writeSurfaceOrPolygon), MultiSurface: U(Ae.prototype.writeMultiSurfaceOrPolygon), Envelope: U(Ae.prototype.writeEnvelope) } }, Ae.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { lineStringMember: U(Ae.prototype.writeLineStringOrCurveMember), curveMember: U(Ae.prototype.writeLineStringOrCurveMember) } }, Ae.prototype.RING_SERIALIZERS = { "http://www.opengis.net/gml": { outerBoundaryIs: U(Ae.prototype.writeRing), innerBoundaryIs: U(Ae.prototype.writeRing) } }, Ae.prototype.POINTMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { pointMember: U(Ae.prototype.writePointMember) } }, Ae.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { surfaceMember: U(Ae.prototype.writeSurfaceOrPolygonMember), polygonMember: U(Ae.prototype.writeSurfaceOrPolygonMember) } }, Ae.prototype.ENVELOPE_SERIALIZERS = { "http://www.opengis.net/gml": { lowerCorner: U(Yt), upperCorner: U(Yt) } };
      const $ut = ms + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd", Jut = { MultiLineString: "lineStringMember", MultiCurve: "curveMember", MultiPolygon: "polygonMember", MultiSurface: "surfaceMember" };
      class lt extends Mt {
        constructor(t) {
          t = t || {}, super(t), this.surface_ = t.surface !== void 0 ? t.surface : false, this.curve_ = t.curve !== void 0 ? t.curve : false, this.multiCurve_ = t.multiCurve !== void 0 ? t.multiCurve : true, this.multiSurface_ = t.multiSurface !== void 0 ? t.multiSurface : true, this.schemaLocation = t.schemaLocation ? t.schemaLocation : $ut, this.hasZ = t.hasZ !== void 0 ? t.hasZ : false;
        }
        readMultiCurve(t, e) {
          const i = rt([], this.MULTICURVE_PARSERS, t, e, this);
          if (i) return new ri(i);
        }
        readFlatCurveRing(t, e) {
          const i = rt([], this.MULTICURVE_PARSERS, t, e, this), r = [];
          for (let a = 0, o = i.length; a < o; ++a) De(r, i[a].getFlatCoordinates());
          return r;
        }
        readMultiSurface(t, e) {
          const i = rt([], this.MULTISURFACE_PARSERS, t, e, this);
          if (i) return new Ci(i);
        }
        curveMemberParser(t, e) {
          gr(this.CURVEMEMBER_PARSERS, t, e, this);
        }
        surfaceMemberParser(t, e) {
          gr(this.SURFACEMEMBER_PARSERS, t, e, this);
        }
        readPatch(t, e) {
          return rt([null], this.PATCHES_PARSERS, t, e, this);
        }
        readSegment(t, e) {
          return rt([], this.SEGMENTS_PARSERS, t, e, this);
        }
        readPolygonPatch(t, e) {
          return rt([null], this.FLAT_LINEAR_RINGS_PARSERS, t, e, this);
        }
        readLineStringSegment(t, e) {
          return rt([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS, t, e, this);
        }
        interiorParser(t, e) {
          const i = rt(void 0, this.RING_PARSERS, t, e, this);
          i && e[e.length - 1].push(i);
        }
        exteriorParser(t, e) {
          const i = rt(void 0, this.RING_PARSERS, t, e, this);
          if (i) {
            const r = e[e.length - 1];
            r[0] = i;
          }
        }
        readSurface(t, e) {
          const i = rt([null], this.SURFACE_PARSERS, t, e, this);
          if (i && i[0]) {
            const r = i[0], a = [r.length];
            let o, s;
            for (o = 1, s = i.length; o < s; ++o) De(r, i[o]), a.push(r.length);
            return new Sn(r, "XYZ", a);
          }
        }
        readCurve(t, e) {
          const i = rt([null], this.CURVE_PARSERS, t, e, this);
          if (i) return new be(i, "XYZ");
        }
        readEnvelope(t, e) {
          const i = rt([null], this.ENVELOPE_PARSERS, t, e, this);
          return Xr(i[1][0], i[1][1], i[2][0], i[2][1]);
        }
        readFlatPos(t, e) {
          let i = Gi(t, false);
          const r = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/, a = [];
          let o;
          for (; o = r.exec(i); ) a.push(parseFloat(o[1])), i = i.substr(o[0].length);
          if (i !== "") return;
          const l = e[0].srsName;
          if ((l ? Vt(l).getAxisOrientation() : "enu") === "neu") for (let c = 0, f = a.length; c < f; c += 3) {
            const g = a[c], d = a[c + 1];
            a[c] = d, a[c + 1] = g;
          }
          const h = a.length;
          if (h == 2 && a.push(0), h !== 0) return a;
        }
        readFlatPosList(t, e) {
          const i = Gi(t, false).replace(/^\s*|\s*$/g, ""), r = e[0], a = r.srsName, o = r.srsDimension, s = a ? Vt(a).getAxisOrientation() : "enu", l = i.split(/\s+/);
          let u = 2;
          t.getAttribute("srsDimension") ? u = _s(t.getAttribute("srsDimension")) : t.getAttribute("dimension") ? u = _s(t.getAttribute("dimension")) : t.parentNode.getAttribute("srsDimension") ? u = _s(t.parentNode.getAttribute("srsDimension")) : o && (u = _s(o));
          const h = s.startsWith("en");
          let c, f, g;
          const d = [];
          for (let A = 0, p = l.length; A < p; A += u) c = parseFloat(l[A]), f = parseFloat(l[A + 1]), g = u === 3 ? parseFloat(l[A + 2]) : 0, h ? d.push(c, f, g) : d.push(f, c, g);
          return d;
        }
        writePos_(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = a ? "3" : "2";
          t.setAttribute("srsDimension", o);
          const s = r.srsName, l = s ? Vt(s).getAxisOrientation() : "enu", u = e.getCoordinates();
          let h = l.startsWith("en") ? u[0] + " " + u[1] : u[1] + " " + u[0];
          if (a) {
            const c = u[2] || 0;
            h += " " + c;
          }
          Yt(t, h);
        }
        getCoords_(t, e, i) {
          let a = (e ? Vt(e).getAxisOrientation() : "enu").startsWith("en") ? t[0] + " " + t[1] : t[1] + " " + t[0];
          if (i) {
            const o = t[2] || 0;
            a += " " + o;
          }
          return a;
        }
        writePosList_(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = a ? "3" : "2";
          t.setAttribute("srsDimension", o);
          const s = r.srsName, l = e.getCoordinates(), u = l.length, h = new Array(u);
          let c;
          for (let f = 0; f < u; ++f) c = l[f], h[f] = this.getCoords_(c, s, a);
          Yt(t, h.join(" "));
        }
        writePoint(t, e, i) {
          const a = i[i.length - 1].srsName;
          a && t.setAttribute("srsName", a);
          const o = $t(t.namespaceURI, "pos");
          t.appendChild(o), this.writePos_(o, e, i);
        }
        writeEnvelope(t, e, i) {
          const a = i[i.length - 1].srsName;
          a && t.setAttribute("srsName", a);
          const o = ["lowerCorner", "upperCorner"], s = [e[0] + " " + e[1], e[2] + " " + e[3]];
          Xt({ node: t }, this.ENVELOPE_SERIALIZERS, ai, s, i, o, this);
        }
        writeLinearRing(t, e, i) {
          const a = i[i.length - 1].srsName;
          a && t.setAttribute("srsName", a);
          const o = $t(t.namespaceURI, "posList");
          t.appendChild(o), this.writePosList_(o, e, i);
        }
        RING_NODE_FACTORY_(t, e, i) {
          const r = e[e.length - 1], a = r.node, o = r.exteriorWritten;
          return o === void 0 && (r.exteriorWritten = true), $t(a.namespaceURI, o !== void 0 ? "interior" : "exterior");
        }
        writeSurfaceOrPolygon(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName;
          if (t.nodeName !== "PolygonPatch" && o && t.setAttribute("srsName", o), t.nodeName === "Polygon" || t.nodeName === "PolygonPatch") {
            const s = e.getLinearRings();
            Xt({ node: t, hasZ: a, srsName: o }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, s, i, void 0, this);
          } else if (t.nodeName === "Surface") {
            const s = $t(t.namespaceURI, "patches");
            t.appendChild(s), this.writeSurfacePatches_(s, e, i);
          }
        }
        writeCurveOrLineString(t, e, i) {
          const a = i[i.length - 1].srsName;
          if (t.nodeName !== "LineStringSegment" && a && t.setAttribute("srsName", a), t.nodeName === "LineString" || t.nodeName === "LineStringSegment") {
            const o = $t(t.namespaceURI, "posList");
            t.appendChild(o), this.writePosList_(o, e, i);
          } else if (t.nodeName === "Curve") {
            const o = $t(t.namespaceURI, "segments");
            t.appendChild(o), this.writeCurveSegments_(o, e, i);
          }
        }
        writeMultiSurfaceOrPolygon(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName, s = r.surface;
          o && t.setAttribute("srsName", o);
          const l = e.getPolygons();
          Xt({ node: t, hasZ: a, srsName: o, surface: s }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, l, i, void 0, this);
        }
        writeMultiPoint(t, e, i) {
          const r = i[i.length - 1], a = r.srsName, o = r.hasZ;
          a && t.setAttribute("srsName", a);
          const s = e.getPoints();
          Xt({ node: t, hasZ: o, srsName: a }, this.POINTMEMBER_SERIALIZERS, pn("pointMember"), s, i, void 0, this);
        }
        writeMultiCurveOrLineString(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName, s = r.curve;
          o && t.setAttribute("srsName", o);
          const l = e.getLineStrings();
          Xt({ node: t, hasZ: a, srsName: o, curve: s }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, l, i, void 0, this);
        }
        writeRing(t, e, i) {
          const r = $t(t.namespaceURI, "LinearRing");
          t.appendChild(r), this.writeLinearRing(r, e, i);
        }
        writeSurfaceOrPolygonMember(t, e, i) {
          const r = this.GEOMETRY_NODE_FACTORY_(e, i);
          r && (t.appendChild(r), this.writeSurfaceOrPolygon(r, e, i));
        }
        writePointMember(t, e, i) {
          const r = $t(t.namespaceURI, "Point");
          t.appendChild(r), this.writePoint(r, e, i);
        }
        writeLineStringOrCurveMember(t, e, i) {
          const r = this.GEOMETRY_NODE_FACTORY_(e, i);
          r && (t.appendChild(r), this.writeCurveOrLineString(r, e, i));
        }
        writeSurfacePatches_(t, e, i) {
          const r = $t(t.namespaceURI, "PolygonPatch");
          t.appendChild(r), this.writeSurfaceOrPolygon(r, e, i);
        }
        writeCurveSegments_(t, e, i) {
          const r = $t(t.namespaceURI, "LineStringSegment");
          t.appendChild(r), this.writeCurveOrLineString(r, e, i);
        }
        writeGeometryElement(t, e, i) {
          const r = i[i.length - 1], a = Object.assign({}, r);
          a.node = t;
          let o;
          Array.isArray(e) ? o = RC(e, r) : o = sn(e, true, r), Xt(a, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [o], i, void 0, this);
        }
        writeFeatureElement(t, e, i) {
          const r = e.getId();
          r && t.setAttribute("fid", r);
          const a = i[i.length - 1], o = a.featureNS, s = e.getGeometryName();
          a.serializers || (a.serializers = {}, a.serializers[o] = {});
          const l = [], u = [];
          if (e.hasProperties()) {
            const c = e.getProperties();
            for (const f in c) {
              const g = c[f];
              g != null && (l.push(f), u.push(g), f == s || typeof g.getSimplifiedGeometry == "function" ? f in a.serializers[o] || (a.serializers[o][f] = U(this.writeGeometryElement, this)) : f in a.serializers[o] || (a.serializers[o][f] = U(Yt)));
            }
          }
          const h = Object.assign({}, a);
          h.node = t, Xt(h, a.serializers, pn(void 0, o), u, i, l);
        }
        writeFeatureMembers_(t, e, i) {
          const r = i[i.length - 1], a = r.featureType, o = r.featureNS, s = {};
          s[o] = {}, s[o][a] = U(this.writeFeatureElement, this);
          const l = Object.assign({}, r);
          l.node = t, Xt(l, s, pn(a, o), e, i);
        }
        MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, e, i) {
          const r = e[e.length - 1].node;
          return $t(this.namespace, Jut[r.nodeName]);
        }
        GEOMETRY_NODE_FACTORY_(t, e, i) {
          const r = e[e.length - 1], a = r.multiSurface, o = r.surface, s = r.curve, l = r.multiCurve;
          return Array.isArray(t) ? i = "Envelope" : (i = t.getType(), i === "MultiPolygon" && a === true ? i = "MultiSurface" : i === "Polygon" && o === true ? i = "Surface" : i === "LineString" && s === true ? i = "Curve" : i === "MultiLineString" && l === true && (i = "MultiCurve")), $t(this.namespace, i);
        }
        writeGeometryNode(t, e) {
          e = this.adaptOptions(e);
          const i = $t(this.namespace, "geom"), r = { node: i, hasZ: this.hasZ, srsName: this.srsName, curve: this.curve_, surface: this.surface_, multiSurface: this.multiSurface_, multiCurve: this.multiCurve_ };
          return e && Object.assign(r, e), this.writeGeometryElement(i, t, [r]), i;
        }
        writeFeaturesNode(t, e) {
          e = this.adaptOptions(e);
          const i = $t(this.namespace, "featureMembers");
          i.setAttributeNS(Hu, "xsi:schemaLocation", this.schemaLocation);
          const r = { srsName: this.srsName, hasZ: this.hasZ, curve: this.curve_, surface: this.surface_, multiSurface: this.multiSurface_, multiCurve: this.multiCurve_, featureNS: this.featureNS, featureType: this.featureType };
          return e && Object.assign(r, e), this.writeFeatureMembers_(i, t, [r]), i;
        }
      }
      lt.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml": { pos: Gt(lt.prototype.readFlatPos), posList: Gt(lt.prototype.readFlatPosList), coordinates: Gt(Ae.prototype.readFlatCoordinates) } }, lt.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml": { interior: lt.prototype.interiorParser, exterior: lt.prototype.exteriorParser } }, lt.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml": { Point: Gt(Mt.prototype.readPoint), MultiPoint: Gt(Mt.prototype.readMultiPoint), LineString: Gt(Mt.prototype.readLineString), MultiLineString: Gt(Mt.prototype.readMultiLineString), LinearRing: Gt(Mt.prototype.readLinearRing), Polygon: Gt(Mt.prototype.readPolygon), MultiPolygon: Gt(Mt.prototype.readMultiPolygon), Surface: Gt(lt.prototype.readSurface), MultiSurface: Gt(lt.prototype.readMultiSurface), Curve: Gt(lt.prototype.readCurve), MultiCurve: Gt(lt.prototype.readMultiCurve), Envelope: Gt(lt.prototype.readEnvelope) } }, lt.prototype.MULTICURVE_PARSERS = { "http://www.opengis.net/gml": { curveMember: Tt(lt.prototype.curveMemberParser), curveMembers: Tt(lt.prototype.curveMemberParser) } }, lt.prototype.MULTISURFACE_PARSERS = { "http://www.opengis.net/gml": { surfaceMember: Tt(lt.prototype.surfaceMemberParser), surfaceMembers: Tt(lt.prototype.surfaceMemberParser) } }, lt.prototype.CURVEMEMBER_PARSERS = { "http://www.opengis.net/gml": { LineString: Tt(Mt.prototype.readLineString), Curve: Tt(lt.prototype.readCurve) } }, lt.prototype.SURFACEMEMBER_PARSERS = { "http://www.opengis.net/gml": { Polygon: Tt(Mt.prototype.readPolygon), Surface: Tt(lt.prototype.readSurface) } }, lt.prototype.SURFACE_PARSERS = { "http://www.opengis.net/gml": { patches: Gt(lt.prototype.readPatch) } }, lt.prototype.CURVE_PARSERS = { "http://www.opengis.net/gml": { segments: Gt(lt.prototype.readSegment) } }, lt.prototype.ENVELOPE_PARSERS = { "http://www.opengis.net/gml": { lowerCorner: Tt(lt.prototype.readFlatPosList), upperCorner: Tt(lt.prototype.readFlatPosList) } }, lt.prototype.PATCHES_PARSERS = { "http://www.opengis.net/gml": { PolygonPatch: Gt(lt.prototype.readPolygonPatch) } }, lt.prototype.SEGMENTS_PARSERS = { "http://www.opengis.net/gml": { LineStringSegment: Im(lt.prototype.readLineStringSegment) } }, Mt.prototype.RING_PARSERS = { "http://www.opengis.net/gml": { LinearRing: Gt(Mt.prototype.readFlatLinearRing), Ring: Gt(lt.prototype.readFlatCurveRing) } }, lt.prototype.writeFeatures, lt.prototype.RING_SERIALIZERS = { "http://www.opengis.net/gml": { exterior: U(lt.prototype.writeRing), interior: U(lt.prototype.writeRing) } }, lt.prototype.ENVELOPE_SERIALIZERS = { "http://www.opengis.net/gml": { lowerCorner: U(Yt), upperCorner: U(Yt) } }, lt.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { surfaceMember: U(lt.prototype.writeSurfaceOrPolygonMember), polygonMember: U(lt.prototype.writeSurfaceOrPolygonMember) } }, lt.prototype.POINTMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { pointMember: U(lt.prototype.writePointMember) } }, lt.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { lineStringMember: U(lt.prototype.writeLineStringOrCurveMember), curveMember: U(lt.prototype.writeLineStringOrCurveMember) } }, lt.prototype.GEOMETRY_SERIALIZERS = { "http://www.opengis.net/gml": { Curve: U(lt.prototype.writeCurveOrLineString), MultiCurve: U(lt.prototype.writeMultiCurveOrLineString), Point: U(lt.prototype.writePoint), MultiPoint: U(lt.prototype.writeMultiPoint), LineString: U(lt.prototype.writeCurveOrLineString), MultiLineString: U(lt.prototype.writeMultiCurveOrLineString), LinearRing: U(lt.prototype.writeLinearRing), Polygon: U(lt.prototype.writeSurfaceOrPolygon), MultiPolygon: U(lt.prototype.writeMultiSurfaceOrPolygon), Surface: U(lt.prototype.writeSurfaceOrPolygon), MultiSurface: U(lt.prototype.writeMultiSurfaceOrPolygon), Envelope: U(lt.prototype.writeEnvelope) } };
      const OC = lt;
      OC.prototype.writeFeatures, OC.prototype.writeFeaturesNode;
      const ln = [null, "http://www.topografix.com/GPX/1/0", "http://www.topografix.com/GPX/1/1"], tht = "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd", eht = { rte: kQ, trk: FQ, wpt: QQ }, nht = K(ln, { rte: Tt(kQ), trk: Tt(FQ), wpt: Tt(QQ) }), iht = K(ln, { text: O(at, "linkText"), type: O(at, "linkType") }), rht = K(ln, { name: O(at), email: Dht, link: WA }), aht = K(ln, { name: O(at), desc: O(at), author: O(Bht), copyright: O(Tht), link: WA, time: O(Em), keywords: O(at), bounds: Mht, extensions: wm }), oht = K(ln, { year: O(mn), license: O(at) }), sht = K(ln, { rte: U(Nht), trk: U(kht), wpt: U(Qht) });
      class lht extends YA {
        constructor(t) {
          super(), t = t || {}, this.dataProjection = Vt("EPSG:4326"), this.readExtensions_ = t.readExtensions;
        }
        handleReadExtensions_(t) {
          t || (t = []);
          for (let e = 0, i = t.length; e < i; ++e) {
            const r = t[e];
            if (this.readExtensions_) {
              const a = r.get("extensionsNode_") || null;
              this.readExtensions_(r, a);
            }
            r.set("extensionsNode_", void 0);
          }
        }
        readMetadata(t) {
          return t ? typeof t == "string" ? this.readMetadataFromDocument(ea(t)) : ta(t) ? this.readMetadataFromDocument(t) : this.readMetadataFromNode(t) : null;
        }
        readMetadataFromDocument(t) {
          for (let e = t.firstChild; e; e = e.nextSibling) if (e.nodeType === Node.ELEMENT_NODE) {
            const i = this.readMetadataFromNode(e);
            if (i) return i;
          }
          return null;
        }
        readMetadataFromNode(t) {
          if (!ln.includes(t.namespaceURI)) return null;
          for (let e = t.firstElementChild; e; e = e.nextElementSibling) if (ln.includes(e.namespaceURI) && e.localName === "metadata") return rt({}, aht, e, []);
          return null;
        }
        readFeatureFromNode(t, e) {
          if (!ln.includes(t.namespaceURI)) return null;
          const i = eht[t.localName];
          if (!i) return null;
          const r = i(t, [this.getReadOptions(t, e)]);
          return r ? (this.handleReadExtensions_([r]), r) : null;
        }
        readFeaturesFromNode(t, e) {
          if (!ln.includes(t.namespaceURI)) return [];
          if (t.localName == "gpx") {
            const i = rt([], nht, t, [this.getReadOptions(t, e)]);
            return i ? (this.handleReadExtensions_(i), i) : [];
          }
          return [];
        }
        writeFeaturesNode(t, e) {
          e = this.adaptOptions(e);
          const i = $t("http://www.topografix.com/GPX/1/1", "gpx");
          return i.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xsi", Hu), i.setAttributeNS(Hu, "xsi:schemaLocation", tht), i.setAttribute("version", "1.1"), i.setAttribute("creator", "OpenLayers"), Xt({ node: i }, sht, bht, t, [e]), i;
        }
      }
      const uht = K(ln, { name: O(at), cmt: O(at), desc: O(at), src: O(at), link: WA, number: O(mn), extensions: wm, type: O(at), rtept: Rht }), hht = K(ln, { ele: O(me), time: O(Em) }), cht = K(ln, { name: O(at), cmt: O(at), desc: O(at), src: O(at), link: WA, number: O(mn), type: O(at), extensions: wm, trkseg: Pht }), fht = K(ln, { trkpt: Lht }), ght = K(ln, { ele: O(me), time: O(Em) }), dht = K(ln, { ele: O(me), time: O(Em), magvar: O(me), geoidheight: O(me), name: O(at), cmt: O(at), desc: O(at), src: O(at), link: WA, sym: O(at), type: O(at), fix: O(at), sat: O(mn), hdop: O(me), vdop: O(me), pdop: O(me), ageofdgpsdata: O(me), dgpsid: O(mn), extensions: wm }), Aht = ["text", "type"], pht = K(ln, { text: U(Yt), type: U(Yt) }), vht = K(ln, ["name", "cmt", "desc", "src", "link", "number", "type", "rtept"]), yht = K(ln, { name: U(Yt), cmt: U(Yt), desc: U(Yt), src: U(Yt), link: U(UC), number: U(xm), type: U(Yt), rtept: PQ(U(VC)) }), mht = K(ln, ["ele", "time"]), _ht = K(ln, ["name", "cmt", "desc", "src", "link", "number", "type", "trkseg"]), Iht = K(ln, { name: U(Yt), cmt: U(Yt), desc: U(Yt), src: U(Yt), link: U(UC), number: U(xm), type: U(Yt), trkseg: PQ(U(Fht)) }), Eht = pn("trkpt"), xht = K(ln, { trkpt: U(VC) }), wht = K(ln, ["ele", "time", "magvar", "geoidheight", "name", "cmt", "desc", "src", "link", "sym", "type", "fix", "sat", "hdop", "vdop", "pdop", "ageofdgpsdata", "dgpsid"]), Cht = K(ln, { ele: U(dr), time: U(Xut), magvar: U(dr), geoidheight: U(dr), name: U(Yt), cmt: U(Yt), desc: U(Yt), src: U(Yt), link: U(UC), sym: U(Yt), type: U(Yt), fix: U(Yt), sat: U(xm), hdop: U(dr), vdop: U(dr), pdop: U(dr), ageofdgpsdata: U(dr), dgpsid: U(xm) }), Sht = { Point: "wpt", LineString: "rte", MultiLineString: "trk" };
      function bht(n, t, e) {
        const i = n.getGeometry();
        if (i) {
          const r = Sht[i.getType()];
          if (r) {
            const a = t[t.length - 1].node;
            return $t(a.namespaceURI, r);
          }
        }
      }
      function zC(n, t, e, i) {
        return n.push(parseFloat(e.getAttribute("lon")), parseFloat(e.getAttribute("lat"))), "ele" in i ? (n.push(i.ele), delete i.ele, t.hasZ = true) : n.push(0), "time" in i ? (n.push(i.time), delete i.time, t.hasM = true) : n.push(0), n;
      }
      function GC(n, t, e) {
        let i = "XY", r = 2;
        if (n.hasZ && n.hasM ? (i = "XYZM", r = 4) : n.hasZ ? (i = "XYZ", r = 3) : n.hasM && (i = "XYM", r = 3), r !== 4) {
          for (let a = 0, o = t.length / 4; a < o; a++) t[a * r] = t[a * 4], t[a * r + 1] = t[a * 4 + 1], n.hasZ && (t[a * r + 2] = t[a * 4 + 2]), n.hasM && (t[a * r + 2] = t[a * 4 + 3]);
          if (t.length = t.length / 4 * r, e) for (let a = 0, o = e.length; a < o; a++) e[a] = e[a] / 4 * r;
        }
        return i;
      }
      function Bht(n, t) {
        const e = rt({}, rht, n, t);
        if (e) return e;
      }
      function Tht(n, t) {
        const e = rt({}, oht, n, t);
        if (e) {
          const i = n.getAttribute("author");
          return i !== null && (e.author = i), e;
        }
      }
      function Mht(n, t) {
        const e = t[t.length - 1], i = n.getAttribute("minlat"), r = n.getAttribute("minlon"), a = n.getAttribute("maxlat"), o = n.getAttribute("maxlon");
        r !== null && i !== null && o !== null && a !== null && (e.bounds = [[parseFloat(r), parseFloat(i)], [parseFloat(o), parseFloat(a)]]);
      }
      function Dht(n, t) {
        const e = t[t.length - 1], i = n.getAttribute("id"), r = n.getAttribute("domain");
        i !== null && r !== null && (e.email = `${i}@${r}`);
      }
      function WA(n, t) {
        const e = t[t.length - 1], i = n.getAttribute("href");
        i !== null && (e.link = i), gr(iht, n, t);
      }
      function wm(n, t) {
        const e = t[t.length - 1];
        e.extensionsNode_ = n;
      }
      function Rht(n, t) {
        const e = rt({}, hht, n, t);
        if (e) {
          const i = t[t.length - 1], r = i.flatCoordinates, a = i.layoutOptions;
          zC(r, a, n, e);
        }
      }
      function Lht(n, t) {
        const e = rt({}, ght, n, t);
        if (e) {
          const i = t[t.length - 1], r = i.flatCoordinates, a = i.layoutOptions;
          zC(r, a, n, e);
        }
      }
      function Pht(n, t) {
        const e = t[t.length - 1];
        gr(fht, n, t);
        const i = e.flatCoordinates;
        e.ends.push(i.length);
      }
      function kQ(n, t) {
        const e = t[0], i = rt({ flatCoordinates: [], layoutOptions: {} }, uht, n, t);
        if (!i) return;
        const r = i.flatCoordinates;
        delete i.flatCoordinates;
        const a = i.layoutOptions;
        delete i.layoutOptions;
        const o = GC(a, r), s = new be(r, o);
        sn(s, false, e);
        const l = new xe(s);
        return l.setProperties(i, true), l;
      }
      function FQ(n, t) {
        const e = t[0], i = rt({ flatCoordinates: [], ends: [], layoutOptions: {} }, cht, n, t);
        if (!i) return;
        const r = i.flatCoordinates;
        delete i.flatCoordinates;
        const a = i.ends;
        delete i.ends;
        const o = i.layoutOptions;
        delete i.layoutOptions;
        const s = GC(o, r, a), l = new ri(r, s, a);
        sn(l, false, e);
        const u = new xe(l);
        return u.setProperties(i, true), u;
      }
      function QQ(n, t) {
        const e = t[0], i = rt({}, dht, n, t);
        if (!i) return;
        const r = {}, a = zC([], r, n, i), o = GC(r, a), s = new Oe(a, o);
        sn(s, false, e);
        const l = new xe(s);
        return l.setProperties(i, true), l;
      }
      function UC(n, t, e) {
        n.setAttribute("href", t);
        const r = e[e.length - 1].properties, a = [r.linkText, r.linkType];
        Xt({ node: n }, pht, ai, a, e, Aht);
      }
      function VC(n, t, e) {
        const i = e[e.length - 1], a = i.node.namespaceURI, o = i.properties;
        switch (n.setAttributeNS(null, "lat", String(t[1])), n.setAttributeNS(null, "lon", String(t[0])), i.geometryLayout) {
          case "XYZM":
            t[3] !== 0 && (o.time = t[3]);
          case "XYZ":
            t[2] !== 0 && (o.ele = t[2]);
            break;
          case "XYM":
            t[2] !== 0 && (o.time = t[2]);
            break;
        }
        const l = n.nodeName == "rtept" ? mht[a] : wht[a], u = fr(o, l);
        Xt({ node: n, properties: o }, Cht, ai, u, e, l);
      }
      function Nht(n, t, e) {
        const i = e[0], r = t.getProperties(), a = { node: n };
        a.properties = r;
        const o = t.getGeometry();
        if (o.getType() == "LineString") {
          const h = sn(o, true, i);
          a.geometryLayout = h.getLayout(), r.rtept = h.getCoordinates();
        }
        const s = e[e.length - 1].node, l = vht[s.namespaceURI], u = fr(r, l);
        Xt(a, yht, ai, u, e, l);
      }
      function kht(n, t, e) {
        const i = e[0], r = t.getProperties(), a = { node: n };
        a.properties = r;
        const o = t.getGeometry();
        if (o.getType() == "MultiLineString") {
          const h = sn(o, true, i);
          r.trkseg = h.getLineStrings();
        }
        const s = e[e.length - 1].node, l = _ht[s.namespaceURI], u = fr(r, l);
        Xt(a, Iht, ai, u, e, l);
      }
      function Fht(n, t, e) {
        const i = { node: n };
        i.geometryLayout = t.getLayout(), i.properties = {}, Xt(i, xht, Eht, t.getCoordinates(), e);
      }
      function Qht(n, t, e) {
        const i = e[0], r = e[e.length - 1];
        r.properties = t.getProperties();
        const a = t.getGeometry();
        if (a.getType() == "Point") {
          const o = sn(a, true, i);
          r.geometryLayout = o.getLayout(), VC(n, o.getCoordinates(), e);
        }
      }
      class jC extends qA {
        constructor() {
          super();
        }
        getType() {
          return "text";
        }
        readFeature(t, e) {
          return this.readFeatureFromText(Cm(t), this.adaptOptions(e));
        }
        readFeatureFromText(t, e) {
          return Qt();
        }
        readFeatures(t, e) {
          return this.readFeaturesFromText(Cm(t), this.adaptOptions(e));
        }
        readFeaturesFromText(t, e) {
          return Qt();
        }
        readGeometry(t, e) {
          return this.readGeometryFromText(Cm(t), this.adaptOptions(e));
        }
        readGeometryFromText(t, e) {
          return Qt();
        }
        readProjection(t) {
          return this.readProjectionFromText(Cm(t));
        }
        readProjectionFromText(t) {
          return this.dataProjection;
        }
        writeFeature(t, e) {
          return this.writeFeatureText(t, this.adaptOptions(e));
        }
        writeFeatureText(t, e) {
          return Qt();
        }
        writeFeatures(t, e) {
          return this.writeFeaturesText(t, this.adaptOptions(e));
        }
        writeFeaturesText(t, e) {
          return Qt();
        }
        writeGeometry(t, e) {
          return this.writeGeometryText(t, this.adaptOptions(e));
        }
        writeGeometryText(t, e) {
          return Qt();
        }
      }
      function Cm(n) {
        return typeof n == "string" ? n : "";
      }
      const Oht = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/, zht = /^H.([A-Z]{3}).*?:(.*)/, Ght = /^HFDTE(\d{2})(\d{2})(\d{2})/, Uht = /^HFDTEDATE:(\d{2})(\d{2})(\d{2}),(\d{2})/, Vht = /\r\n|\r|\n/;
      class jht extends jC {
        constructor(t) {
          super(), t = t || {}, this.dataProjection = Vt("EPSG:4326"), this.altitudeMode_ = t.altitudeMode ? t.altitudeMode : "none", this.lad_ = false, this.lod_ = false, this.ladStart_ = 0, this.ladStop_ = 0, this.lodStart_ = 0, this.lodStop_ = 0;
        }
        readFeatureFromText(t, e) {
          const i = this.altitudeMode_, r = t.split(Vht), a = {}, o = [];
          let s = 2e3, l = 0, u = 1, h = -1, c, f;
          for (c = 0, f = r.length; c < f; ++c) {
            const p = r[c];
            let v;
            if (p.charAt(0) == "B") {
              if (v = Oht.exec(p), v) {
                const y = parseInt(v[1], 10), m = parseInt(v[2], 10), _ = parseInt(v[3], 10);
                let E = parseInt(v[4], 10) + parseInt(v[5], 10) / 6e4;
                this.lad_ && (E += parseInt(p.slice(this.ladStart_, this.ladStop_), 10) / 6e4 / _i(10, this.ladStop_ - this.ladStart_)), v[6] == "S" && (E = -E);
                let I = parseInt(v[7], 10) + parseInt(v[8], 10) / 6e4;
                if (this.lod_ && (I += parseInt(p.slice(this.lodStart_, this.lodStop_), 10) / 6e4 / _i(10, this.lodStop_ - this.lodStart_)), v[9] == "W" && (I = -I), o.push(I, E), i != "none") {
                  let w;
                  i == "gps" ? w = parseInt(v[11], 10) : i == "barometric" ? w = parseInt(v[12], 10) : w = 0, o.push(w);
                }
                let x = Date.UTC(s, l, u, y, m, _);
                x < h && (x = Date.UTC(s, l, u + 1, y, m, _)), o.push(x / 1e3), h = x;
              }
            } else if (p.charAt(0) == "H") v = Uht.exec(p), v ? (u = parseInt(v[1], 10), l = parseInt(v[2], 10) - 1, s = 2e3 + parseInt(v[3], 10)) : (v = Ght.exec(p), v ? (u = parseInt(v[1], 10), l = parseInt(v[2], 10) - 1, s = 2e3 + parseInt(v[3], 10)) : (v = zht.exec(p), v && (a[v[1]] = v[2].trim())));
            else if (p.charAt(0) == "I") {
              const y = parseInt(p.slice(1, 3), 10);
              for (let m = 0; m < y; m++) {
                const _ = p.slice(7 + m * 7, 10 + m * 7);
                if (_ === "LAD" || _ === "LOD") {
                  const E = parseInt(p.slice(3 + m * 7, 5 + m * 7), 10) - 1, I = parseInt(p.slice(5 + m * 7, 7 + m * 7), 10);
                  _ === "LAD" ? (this.lad_ = true, this.ladStart_ = E, this.ladStop_ = I) : _ === "LOD" && (this.lod_ = true, this.lodStart_ = E, this.lodStop_ = I);
                }
              }
            }
          }
          if (o.length === 0) return null;
          const g = i == "none" ? "XYM" : "XYZM", d = new be(o, g), A = new xe(sn(d, false, e));
          return A.setProperties(a, true), A;
        }
        readFeaturesFromText(t, e) {
          const i = this.readFeatureFromText(t, e);
          return i ? [i] : [];
        }
      }
      const Is = ["http://www.google.com/kml/ext/2.2"], Lt = [null, "http://earth.google.com/kml/2.0", "http://earth.google.com/kml/2.1", "http://earth.google.com/kml/2.2", "http://www.opengis.net/kml/2.2"], qht = "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd", OQ = { fraction: "fraction", pixels: "pixels", insetPixels: "pixels" }, Hht = K(Lt, { ExtendedData: eO, Region: nO, MultiGeometry: O($Q, "geometry"), LineString: O(ZQ, "geometry"), LinearRing: O(KQ, "geometry"), Point: O(JQ, "geometry"), Polygon: O(tO, "geometry"), Style: O($C), StyleMap: Tct, address: O(at), description: O(at), name: O(at), open: O(Rl), phoneNumber: O(at), styleUrl: O(qQ), visibility: O(Rl) }, K(Is, { MultiTrack: O(pct, "geometry"), Track: O(XQ, "geometry") })), Yht = K(Lt, { ExtendedData: eO, Region: nO, Link: Gct, address: O(at), description: O(at), name: O(at), open: O(Rl), phoneNumber: O(at), visibility: O(Rl) }), Wht = K(Lt, { href: O(jQ) }), Xht = K(Lt, { Altitude: O(me), Longitude: O(me), Latitude: O(me), Tilt: O(me), AltitudeMode: O(at), Heading: O(me), Roll: O(me) }), zQ = K(Lt, { LatLonAltBox: Pct, Lod: kct }), Zht = K(Lt, ["Document", "Placemark"]), Kht = K(Lt, { Document: U(Xct), Placemark: U(lO) });
      let Vf, Sm = null, qC, XA, ZA, KA, bm, HC = null, YC, WC = null, XC, Yu = null, GQ = null, ZC = null;
      function Bm(n) {
        return 32 / Math.min(n[0], n[1]);
      }
      function $ht() {
        Vf = [255, 255, 255, 1], Sm = new ye({ color: Vf }), qC = [20, 2], XA = "pixels", ZA = "pixels", KA = [64, 64], bm = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png", HC = new Rr({ anchor: qC, anchorOrigin: "bottom-left", anchorXUnits: XA, anchorYUnits: ZA, crossOrigin: "anonymous", rotation: 0, scale: Bm(KA), size: KA, src: bm }), YC = "NO_IMAGE", WC = new Ze({ color: Vf, width: 1 }), XC = new Ze({ color: [51, 51, 51, 1], width: 2 }), Yu = new Ei({ font: "bold 16px Helvetica", fill: Sm, stroke: XC, scale: 0.8 }), GQ = new de({ fill: Sm, image: HC, text: Yu, stroke: WC, zIndex: 0 }), ZC = [GQ];
      }
      let Tm;
      function Jht(n) {
        return n;
      }
      class tct extends YA {
        constructor(t) {
          super(), t = t || {}, ZC || $ht(), this.dataProjection = Vt("EPSG:4326"), this.defaultStyle_ = t.defaultStyle ? t.defaultStyle : ZC, this.extractStyles_ = t.extractStyles !== void 0 ? t.extractStyles : true, this.writeStyles_ = t.writeStyles !== void 0 ? t.writeStyles : true, this.sharedStyles_ = {}, this.showPointNames_ = t.showPointNames !== void 0 ? t.showPointNames : true, this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : "anonymous", this.iconUrlFunction_ = t.iconUrlFunction ? t.iconUrlFunction : Jht, this.supportedMediaTypes = ["application/vnd.google-earth.kml+xml"];
        }
        readDocumentOrFolder_(t, e) {
          const i = K(Lt, { Document: Im(this.readDocumentOrFolder_, this), Folder: Im(this.readDocumentOrFolder_, this), Placemark: Tt(this.readPlacemark_, this), Style: this.readSharedStyle_.bind(this), StyleMap: this.readSharedStyleMap_.bind(this) }), r = rt([], i, t, e, this);
          if (r) return r;
        }
        readPlacemark_(t, e) {
          const i = rt({ geometry: null }, Hht, t, e, this);
          if (!i) return;
          const r = new xe(), a = t.getAttribute("id");
          a !== null && r.setId(a);
          const o = e[0], s = i.geometry;
          if (s && sn(s, false, o), r.setGeometry(s), delete i.geometry, this.extractStyles_) {
            const l = i.Style, u = i.styleUrl, h = nct(l, u, this.defaultStyle_, this.sharedStyles_, this.showPointNames_);
            r.setStyle(h);
          }
          return delete i.Style, r.setProperties(i, true), r;
        }
        readSharedStyle_(t, e) {
          const i = t.getAttribute("id");
          if (i !== null) {
            const r = $C.call(this, t, e);
            if (r) {
              let a, o = t.baseURI;
              (!o || o == "about:blank") && (o = window.location.href), o ? a = new URL("#" + i, o).href : a = "#" + i, this.sharedStyles_[a] = r;
            }
          }
        }
        readSharedStyleMap_(t, e) {
          const i = t.getAttribute("id");
          if (i === null) return;
          const r = YQ.call(this, t, e);
          if (!r) return;
          let a, o = t.baseURI;
          (!o || o == "about:blank") && (o = window.location.href), o ? a = new URL("#" + i, o).href : a = "#" + i, this.sharedStyles_[a] = r;
        }
        readFeatureFromNode(t, e) {
          if (!Lt.includes(t.namespaceURI)) return null;
          const i = this.readPlacemark_(t, [this.getReadOptions(t, e)]);
          return i || null;
        }
        readFeaturesFromNode(t, e) {
          if (!Lt.includes(t.namespaceURI)) return [];
          let i;
          const r = t.localName;
          if (r == "Document" || r == "Folder") return i = this.readDocumentOrFolder_(t, [this.getReadOptions(t, e)]), i || [];
          if (r == "Placemark") {
            const a = this.readPlacemark_(t, [this.getReadOptions(t, e)]);
            return a ? [a] : [];
          }
          if (r == "kml") {
            i = [];
            for (let a = t.firstElementChild; a; a = a.nextElementSibling) {
              const o = this.readFeaturesFromNode(a, e);
              o && De(i, o);
            }
            return i;
          }
          return [];
        }
        readName(t) {
          if (t) {
            if (typeof t == "string") {
              const e = ea(t);
              return this.readNameFromDocument(e);
            }
            return ta(t) ? this.readNameFromDocument(t) : this.readNameFromNode(t);
          }
        }
        readNameFromDocument(t) {
          for (let e = t.firstChild; e; e = e.nextSibling) if (e.nodeType == Node.ELEMENT_NODE) {
            const i = this.readNameFromNode(e);
            if (i) return i;
          }
        }
        readNameFromNode(t) {
          for (let e = t.firstElementChild; e; e = e.nextElementSibling) if (Lt.includes(e.namespaceURI) && e.localName == "name") return at(e);
          for (let e = t.firstElementChild; e; e = e.nextElementSibling) {
            const i = e.localName;
            if (Lt.includes(e.namespaceURI) && (i == "Document" || i == "Folder" || i == "Placemark" || i == "kml")) {
              const r = this.readNameFromNode(e);
              if (r) return r;
            }
          }
        }
        readNetworkLinks(t) {
          const e = [];
          if (typeof t == "string") {
            const i = ea(t);
            De(e, this.readNetworkLinksFromDocument(i));
          } else ta(t) ? De(e, this.readNetworkLinksFromDocument(t)) : De(e, this.readNetworkLinksFromNode(t));
          return e;
        }
        readNetworkLinksFromDocument(t) {
          const e = [];
          for (let i = t.firstChild; i; i = i.nextSibling) i.nodeType == Node.ELEMENT_NODE && De(e, this.readNetworkLinksFromNode(i));
          return e;
        }
        readNetworkLinksFromNode(t) {
          const e = [];
          for (let i = t.firstElementChild; i; i = i.nextElementSibling) if (Lt.includes(i.namespaceURI) && i.localName == "NetworkLink") {
            const r = rt({}, Yht, i, []);
            e.push(r);
          }
          for (let i = t.firstElementChild; i; i = i.nextElementSibling) {
            const r = i.localName;
            Lt.includes(i.namespaceURI) && (r == "Document" || r == "Folder" || r == "kml") && De(e, this.readNetworkLinksFromNode(i));
          }
          return e;
        }
        readRegion(t) {
          const e = [];
          if (typeof t == "string") {
            const i = ea(t);
            De(e, this.readRegionFromDocument(i));
          } else ta(t) ? De(e, this.readRegionFromDocument(t)) : De(e, this.readRegionFromNode(t));
          return e;
        }
        readRegionFromDocument(t) {
          const e = [];
          for (let i = t.firstChild; i; i = i.nextSibling) i.nodeType == Node.ELEMENT_NODE && De(e, this.readRegionFromNode(i));
          return e;
        }
        readRegionFromNode(t) {
          const e = [];
          for (let i = t.firstElementChild; i; i = i.nextElementSibling) if (Lt.includes(i.namespaceURI) && i.localName == "Region") {
            const r = rt({}, zQ, i, []);
            e.push(r);
          }
          for (let i = t.firstElementChild; i; i = i.nextElementSibling) {
            const r = i.localName;
            Lt.includes(i.namespaceURI) && (r == "Document" || r == "Folder" || r == "kml") && De(e, this.readRegionFromNode(i));
          }
          return e;
        }
        readCamera(t) {
          const e = [];
          if (typeof t == "string") {
            const i = ea(t);
            De(e, this.readCameraFromDocument(i));
          } else ta(t) ? De(e, this.readCameraFromDocument(t)) : De(e, this.readCameraFromNode(t));
          return e;
        }
        readCameraFromDocument(t) {
          const e = [];
          for (let i = t.firstChild; i; i = i.nextSibling) i.nodeType === Node.ELEMENT_NODE && De(e, this.readCameraFromNode(i));
          return e;
        }
        readCameraFromNode(t) {
          const e = [];
          for (let i = t.firstElementChild; i; i = i.nextElementSibling) if (Lt.includes(i.namespaceURI) && i.localName === "Camera") {
            const r = rt({}, Xht, i, []);
            e.push(r);
          }
          for (let i = t.firstElementChild; i; i = i.nextElementSibling) {
            const r = i.localName;
            Lt.includes(i.namespaceURI) && (r === "Document" || r === "Folder" || r === "Placemark" || r === "kml") && De(e, this.readCameraFromNode(i));
          }
          return e;
        }
        writeFeaturesNode(t, e) {
          e = this.adaptOptions(e);
          const i = $t(Lt[4], "kml"), r = "http://www.w3.org/2000/xmlns/";
          i.setAttributeNS(r, "xmlns:gx", Is[0]), i.setAttributeNS(r, "xmlns:xsi", Hu), i.setAttributeNS(Hu, "xsi:schemaLocation", qht);
          const a = { node: i }, o = {};
          t.length > 1 ? o.Document = t : t.length == 1 && (o.Placemark = t[0]);
          const s = Zht[i.namespaceURI], l = fr(o, s);
          return Xt(a, Kht, ai, l, [e], s, this), i;
        }
      }
      function ect(n, t) {
        const e = [0, 0];
        let i = "start";
        const r = n.getImage();
        if (r) {
          const s = r.getSize();
          if (s && s.length == 2) {
            const l = r.getScaleArray(), u = r.getAnchor();
            e[0] = l[0] * (s[0] - u[0]), e[1] = l[1] * (s[1] / 2 - u[1]), i = "left";
          }
        }
        let a = n.getText();
        return a ? (a = a.clone(), a.setFont(a.getFont() || Yu.getFont()), a.setScale(a.getScale() || Yu.getScale()), a.setFill(a.getFill() || Yu.getFill()), a.setStroke(a.getStroke() || XC)) : a = Yu.clone(), a.setText(t), a.setOffsetX(e[0]), a.setOffsetY(e[1]), a.setTextAlign(i), new de({ image: r, text: a });
      }
      function nct(n, t, e, i, r) {
        return function(a, o) {
          let s = r, l = "", u = [];
          if (s) {
            const c = a.getGeometry();
            if (c) if (c instanceof yn) u = c.getGeometriesArrayRecursive().filter(function(f) {
              const g = f.getType();
              return g === "Point" || g === "MultiPoint";
            }), s = u.length > 0;
            else {
              const f = c.getType();
              s = f === "Point" || f === "MultiPoint";
            }
          }
          s && (l = a.get("name"), s = s && !!l, s && /&[^&]+;/.test(l) && (Tm || (Tm = document.createElement("textarea")), Tm.innerHTML = l, l = Tm.value));
          let h = e;
          if (n ? h = n : t && (h = UQ(t, e, i)), s) {
            const c = ect(h[0], l);
            if (u.length > 0) {
              c.setGeometry(new yn(u));
              const f = new de({ geometry: h[0].getGeometry(), image: null, fill: h[0].getFill(), stroke: h[0].getStroke(), text: null });
              return [c, f].concat(h.slice(1));
            }
            return c;
          }
          return h;
        };
      }
      function UQ(n, t, e) {
        return Array.isArray(n) ? n : typeof n == "string" ? UQ(e[n], t, e) : t;
      }
      function Mm(n) {
        const t = Gi(n, false), e = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(t);
        if (e) {
          const i = e[1];
          return [parseInt(i.substr(6, 2), 16), parseInt(i.substr(4, 2), 16), parseInt(i.substr(2, 2), 16), parseInt(i.substr(0, 2), 16) / 255];
        }
      }
      function VQ(n) {
        let t = Gi(n, false);
        const e = [];
        t = t.replace(/\s*,\s*/g, ",");
        const i = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
        let r;
        for (; r = i.exec(t); ) {
          const a = parseFloat(r[1]), o = parseFloat(r[2]), s = r[3] ? parseFloat(r[3]) : 0;
          e.push(a, o, s), t = t.substr(r[0].length);
        }
        if (t === "") return e;
      }
      function jQ(n) {
        const t = Gi(n, false).trim();
        let e = n.baseURI;
        return (!e || e == "about:blank") && (e = window.location.href), e ? new URL(t, e).href : t;
      }
      function qQ(n) {
        const t = Gi(n, false).trim().replace(/^(?!.*#)/, "#");
        let e = n.baseURI;
        return (!e || e == "about:blank") && (e = window.location.href), e ? new URL(t, e).href : t;
      }
      function ict(n) {
        const t = n.getAttribute("xunits"), e = n.getAttribute("yunits");
        let i;
        return t !== "insetPixels" ? e !== "insetPixels" ? i = "bottom-left" : i = "top-left" : e !== "insetPixels" ? i = "bottom-right" : i = "top-right", { x: parseFloat(n.getAttribute("x")), xunits: OQ[t], y: parseFloat(n.getAttribute("y")), yunits: OQ[e], origin: i };
      }
      function HQ(n) {
        return me(n);
      }
      const rct = K(Lt, { Pair: Bct });
      function YQ(n, t) {
        return rt(void 0, rct, n, t, this);
      }
      const act = K(Lt, { Icon: O(mct), color: O(Mm), heading: O(me), hotSpot: O(ict), scale: O(HQ) });
      function oct(n, t) {
        const e = rt({}, act, n, t);
        if (!e) return;
        const i = t[t.length - 1], r = "Icon" in e ? e.Icon : {}, a = !("Icon" in e) || Object.keys(r).length > 0;
        let o;
        const s = r.href;
        s ? o = s : a && (o = bm);
        let l, u, h, c = "bottom-left";
        const f = e.hotSpot;
        f ? (l = [f.x, f.y], u = f.xunits, h = f.yunits, c = f.origin) : /^https?:\/\/maps\.(?:google|gstatic)\.com\//.test(o) && (o.includes("pushpin") ? (l = qC, u = XA, h = ZA) : o.includes("arrow-reverse") ? (l = [54, 42], u = XA, h = ZA) : o.includes("paddle") && (l = [32, 1], u = XA, h = ZA));
        let g;
        const d = r.x, A = r.y;
        d !== void 0 && A !== void 0 && (g = [d, A]);
        let p;
        const v = r.w, y = r.h;
        v !== void 0 && y !== void 0 && (p = [v, y]);
        let m;
        const _ = e.heading;
        _ !== void 0 && (m = sl(_));
        const E = e.scale, I = e.color;
        if (a) {
          o == bm && (p = KA);
          const x = new Rr({ anchor: l, anchorOrigin: c, anchorXUnits: u, anchorYUnits: h, crossOrigin: this.crossOrigin_, offset: g, offsetOrigin: "bottom-left", rotation: m, scale: E, size: p, src: this.iconUrlFunction_(o), color: I }), w = x.getScaleArray()[0], C = x.getSize();
          if (C === null) {
            const S = x.getImageState();
            if (S === Bt.IDLE || S === Bt.LOADING) {
              const b = function() {
                const B = x.getImageState();
                if (!(B === Bt.IDLE || B === Bt.LOADING)) {
                  const T = x.getSize();
                  if (T && T.length == 2) {
                    const D = Bm(T);
                    x.setScale(w * D);
                  }
                  x.unlistenImageChange(b);
                }
              };
              x.listenImageChange(b), S === Bt.IDLE && x.load();
            }
          } else if (C.length == 2) {
            const S = Bm(C);
            x.setScale(w * S);
          }
          i.imageStyle = x;
        } else i.imageStyle = YC;
      }
      const sct = K(Lt, { color: O(Mm), scale: O(HQ) });
      function lct(n, t) {
        const e = rt({}, sct, n, t);
        if (!e) return;
        const i = t[t.length - 1], r = new Ei({ fill: new ye({ color: "color" in e ? e.color : Vf }), scale: e.scale });
        i.textStyle = r;
      }
      const uct = K(Lt, { color: O(Mm), width: O(me) });
      function hct(n, t) {
        const e = rt({}, uct, n, t);
        if (!e) return;
        const i = t[t.length - 1], r = new Ze({ color: "color" in e ? e.color : Vf, width: "width" in e ? e.width : 1 });
        i.strokeStyle = r;
      }
      const cct = K(Lt, { color: O(Mm), fill: O(Rl), outline: O(Rl) });
      function fct(n, t) {
        const e = rt({}, cct, n, t);
        if (!e) return;
        const i = t[t.length - 1], r = new ye({ color: "color" in e ? e.color : Vf });
        i.fillStyle = r;
        const a = e.fill;
        a !== void 0 && (i.fill = a);
        const o = e.outline;
        o !== void 0 && (i.outline = o);
      }
      const gct = K(Lt, { coordinates: Gt(VQ) });
      function WQ(n, t) {
        return rt(null, gct, n, t);
      }
      function dct(n, t) {
        const i = t[t.length - 1].coordinates, r = Gi(n, false), o = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i.exec(r);
        if (o) {
          const s = parseFloat(o[1]), l = parseFloat(o[2]), u = parseFloat(o[3]);
          i.push([s, l, u]);
        } else i.push([]);
      }
      const Act = K(Is, { Track: Tt(XQ) });
      function pct(n, t) {
        const e = rt([], Act, n, t);
        if (e) return new ri(e);
      }
      const vct = K(Lt, { when: Uct }, K(Is, { coord: dct }));
      function XQ(n, t) {
        const e = rt({ coordinates: [], whens: [] }, vct, n, t);
        if (!e) return;
        const i = [], r = e.coordinates, a = e.whens;
        for (let o = 0, s = Math.min(r.length, a.length); o < s; ++o) r[o].length == 3 && i.push(r[o][0], r[o][1], r[o][2], a[o]);
        return new be(i, "XYZM");
      }
      const yct = K(Lt, { href: O(jQ) }, K(Is, { x: O(me), y: O(me), w: O(me), h: O(me) }));
      function mct(n, t) {
        const e = rt({}, yct, n, t);
        return e || null;
      }
      const _ct = K(Lt, { coordinates: Gt(VQ) });
      function KC(n, t) {
        return rt(null, _ct, n, t);
      }
      const Dm = K(Lt, { extrude: O(Rl), tessellate: O(Rl), altitudeMode: O(at) });
      function ZQ(n, t) {
        const e = rt({}, Dm, n, t), i = KC(n, t);
        if (i) {
          const r = new be(i, "XYZ");
          return r.setProperties(e, true), r;
        }
      }
      function KQ(n, t) {
        const e = rt({}, Dm, n, t), i = KC(n, t);
        if (i) {
          const r = new Sn(i, "XYZ", [i.length]);
          return r.setProperties(e, true), r;
        }
      }
      const Ict = K(Lt, { LineString: Tt(ZQ), LinearRing: Tt(KQ), MultiGeometry: Tt($Q), Point: Tt(JQ), Polygon: Tt(tO) });
      function $Q(n, t) {
        const e = rt([], Ict, n, t);
        if (!e) return null;
        if (e.length === 0) return new yn(e);
        let i, r = true;
        const a = e[0].getType();
        let o;
        for (let s = 1, l = e.length; s < l; ++s) if (o = e[s], o.getType() != a) {
          r = false;
          break;
        }
        if (r) {
          let s, l;
          if (a == "Point") {
            const u = e[0];
            s = u.getLayout(), l = u.getFlatCoordinates();
            for (let h = 1, c = e.length; h < c; ++h) o = e[h], De(l, o.getFlatCoordinates());
            i = new sr(l, s), JC(i, e);
          } else if (a == "LineString") i = new ri(e), JC(i, e);
          else if (a == "Polygon") i = new Ci(e), JC(i, e);
          else if (a == "GeometryCollection" || a.startsWith("Multi")) i = new yn(e);
          else throw new Error("Unknown geometry type found");
        } else i = new yn(e);
        return i;
      }
      function JQ(n, t) {
        const e = rt({}, Dm, n, t), i = KC(n, t);
        if (i) {
          const r = new Oe(i, "XYZ");
          return r.setProperties(e, true), r;
        }
      }
      const Ect = K(Lt, { innerBoundaryIs: Qct, outerBoundaryIs: zct });
      function tO(n, t) {
        const e = rt({}, Dm, n, t), i = rt([null], Ect, n, t);
        if (i && i[0]) {
          const r = i[0], a = [r.length];
          for (let s = 1, l = i.length; s < l; ++s) De(r, i[s]), a.push(r.length);
          const o = new Sn(r, "XYZ", a);
          return o.setProperties(e, true), o;
        }
      }
      const xct = K(Lt, { IconStyle: oct, LabelStyle: lct, LineStyle: hct, PolyStyle: fct });
      function $C(n, t) {
        const e = rt({}, xct, n, t, this);
        if (!e) return null;
        let i = "fillStyle" in e ? e.fillStyle : Sm;
        const r = e.fill;
        r !== void 0 && !r && (i = null);
        let a;
        "imageStyle" in e ? e.imageStyle != YC && (a = e.imageStyle) : a = HC;
        const o = "textStyle" in e ? e.textStyle : Yu, s = "strokeStyle" in e ? e.strokeStyle : WC, l = e.outline;
        return l !== void 0 && !l ? [new de({ geometry: function(u) {
          const h = u.getGeometry(), c = h.getType();
          if (c === "GeometryCollection") {
            const f = h;
            return new yn(f.getGeometriesArrayRecursive().filter(function(g) {
              const d = g.getType();
              return d !== "Polygon" && d !== "MultiPolygon";
            }));
          }
          if (c !== "Polygon" && c !== "MultiPolygon") return h;
        }, fill: i, image: a, stroke: s, text: o, zIndex: void 0 }), new de({ geometry: function(u) {
          const h = u.getGeometry(), c = h.getType();
          if (c === "GeometryCollection") {
            const f = h;
            return new yn(f.getGeometriesArrayRecursive().filter(function(g) {
              const d = g.getType();
              return d === "Polygon" || d === "MultiPolygon";
            }));
          }
          if (c === "Polygon" || c === "MultiPolygon") return h;
        }, fill: i, stroke: null, zIndex: void 0 })] : [new de({ fill: i, image: a, stroke: s, text: o, zIndex: void 0 })];
      }
      function JC(n, t) {
        const e = t.length, i = new Array(t.length), r = new Array(t.length), a = new Array(t.length);
        let o, s, l;
        o = false, s = false, l = false;
        for (let u = 0; u < e; ++u) {
          const h = t[u];
          i[u] = h.get("extrude"), r[u] = h.get("tessellate"), a[u] = h.get("altitudeMode"), o = o || i[u] !== void 0, s = s || r[u] !== void 0, l = l || a[u];
        }
        o && n.set("extrude", i), s && n.set("tessellate", r), l && n.set("altitudeMode", a);
      }
      const wct = K(Lt, { displayName: O(at), value: O(at) });
      function Cct(n, t) {
        const e = n.getAttribute("name");
        gr(wct, n, t);
        const i = t[t.length - 1];
        e && i.displayName ? i[e] = { value: i.value, displayName: i.displayName, toString: function() {
          return i.value;
        } } : e !== null ? i[e] = i.value : i.displayName !== null && (i[i.displayName] = i.value), delete i.value;
      }
      const Sct = K(Lt, { Data: Cct, SchemaData: Dct });
      function eO(n, t) {
        gr(Sct, n, t);
      }
      function nO(n, t) {
        gr(zQ, n, t);
      }
      const bct = K(Lt, { Style: O($C), key: O(at), styleUrl: O(qQ) });
      function Bct(n, t) {
        const e = rt({}, bct, n, t, this);
        if (!e) return;
        const i = e.key;
        if (i && i == "normal") {
          const r = e.styleUrl;
          r && (t[t.length - 1] = r);
          const a = e.Style;
          a && (t[t.length - 1] = a);
        }
      }
      function Tct(n, t) {
        const e = YQ.call(this, n, t);
        if (!e) return;
        const i = t[t.length - 1];
        if (Array.isArray(e)) i.Style = e;
        else if (typeof e == "string") i.styleUrl = e;
        else throw new Error("`styleMapValue` has an unknown type");
      }
      const Mct = K(Lt, { SimpleData: Rct });
      function Dct(n, t) {
        gr(Mct, n, t);
      }
      function Rct(n, t) {
        const e = n.getAttribute("name");
        if (e !== null) {
          const i = at(n), r = t[t.length - 1];
          r[e] = i;
        }
      }
      const Lct = K(Lt, { altitudeMode: O(at), minAltitude: O(me), maxAltitude: O(me), north: O(me), south: O(me), east: O(me), west: O(me) });
      function Pct(n, t) {
        const e = rt({}, Lct, n, t);
        if (!e) return;
        const i = t[t.length - 1], r = [parseFloat(e.west), parseFloat(e.south), parseFloat(e.east), parseFloat(e.north)];
        i.extent = r, i.altitudeMode = e.altitudeMode, i.minAltitude = parseFloat(e.minAltitude), i.maxAltitude = parseFloat(e.maxAltitude);
      }
      const Nct = K(Lt, { minLodPixels: O(me), maxLodPixels: O(me), minFadeExtent: O(me), maxFadeExtent: O(me) });
      function kct(n, t) {
        const e = rt({}, Nct, n, t);
        if (!e) return;
        const i = t[t.length - 1];
        i.minLodPixels = parseFloat(e.minLodPixels), i.maxLodPixels = parseFloat(e.maxLodPixels), i.minFadeExtent = parseFloat(e.minFadeExtent), i.maxFadeExtent = parseFloat(e.maxFadeExtent);
      }
      const Fct = K(Lt, { LinearRing: Tt(WQ) });
      function Qct(n, t) {
        const e = rt([], Fct, n, t);
        e.length > 0 && t[t.length - 1].push(...e);
      }
      const Oct = K(Lt, { LinearRing: Gt(WQ) });
      function zct(n, t) {
        const e = rt(void 0, Oct, n, t);
        if (e) {
          const i = t[t.length - 1];
          i[0] = e;
        }
      }
      function Gct(n, t) {
        gr(Wht, n, t);
      }
      function Uct(n, t) {
        const i = t[t.length - 1].whens, r = Gi(n, false), a = Date.parse(r);
        i.push(isNaN(a) ? 0 : a);
      }
      function Rm(n, t) {
        const e = hl(t), r = [(e.length == 4 ? e[3] : 1) * 255, e[2], e[1], e[0]];
        for (let a = 0; a < 4; ++a) {
          const o = Math.floor(r[a]).toString(16);
          r[a] = o.length == 1 ? "0" + o : o;
        }
        Yt(n, r.join(""));
      }
      function Vct(n, t, e) {
        const i = e[e.length - 1], r = i.layout, a = i.stride;
        let o;
        if (r == "XY" || r == "XYM") o = 2;
        else if (r == "XYZ" || r == "XYZM") o = 3;
        else throw new Error("Invalid geometry layout");
        const s = t.length;
        let l = "";
        if (s > 0) {
          l += t[0];
          for (let u = 1; u < o; ++u) l += "," + t[u];
          for (let u = a; u < s; u += a) {
            l += " " + t[u];
            for (let h = 1; h < o; ++h) l += "," + t[u + h];
          }
        }
        Yt(n, l);
      }
      const Lm = K(Lt, { Data: U(jct), value: U(Hct), displayName: U(qct) });
      function jct(n, t, e) {
        n.setAttribute("name", t.name);
        const i = { node: n }, r = t.value;
        typeof r == "object" ? (r !== null && r.displayName && Xt(i, Lm, ai, [r.displayName], e, ["displayName"]), r !== null && r.value && Xt(i, Lm, ai, [r.value], e, ["value"])) : Xt(i, Lm, ai, [r], e, ["value"]);
      }
      function qct(n, t) {
        Wut(n, t);
      }
      function Hct(n, t) {
        Yt(n, t);
      }
      const Yct = K(Lt, { Placemark: U(lO) }), Wct = function(n, t, e) {
        const i = t[t.length - 1].node;
        return $t(i.namespaceURI, "Placemark");
      };
      function Xct(n, t, e) {
        Xt({ node: n }, Yct, Wct, t, e, void 0, this);
      }
      const Zct = pn("Data");
      function Kct(n, t, e) {
        const i = { node: n }, r = t.names, a = t.values, o = r.length;
        for (let s = 0; s < o; s++) Xt(i, Lm, Zct, [{ name: r[s], value: a[s] }], e);
      }
      const iO = K(Lt, ["href"], K(Is, ["x", "y", "w", "h"])), rO = K(Lt, { href: U(Yt) }, K(Is, { x: U(dr), y: U(dr), w: U(dr), h: U(dr) })), $ct = function(n, t, e) {
        return $t(Is[0], "gx:" + e);
      };
      function Jct(n, t, e) {
        const i = { node: n }, r = e[e.length - 1].node;
        let a = iO[r.namespaceURI], o = fr(t, a);
        Xt(i, rO, ai, o, e, a), a = iO[Is[0]], o = fr(t, a), Xt(i, rO, $ct, o, e, a);
      }
      const tft = K(Lt, ["scale", "heading", "Icon", "color", "hotSpot"]), eft = K(Lt, { Icon: U(Jct), color: U(Rm), heading: U(dr), hotSpot: U(Bft), scale: U(cO) });
      function nft(n, t, e) {
        const i = { node: n }, r = {}, a = t.getSrc(), o = t.getSize(), s = t.getImageSize(), l = { href: a };
        if (o) {
          l.w = o[0], l.h = o[1];
          const p = t.getAnchor(), v = t.getOrigin();
          if (v && s && v[0] !== 0 && v[1] !== o[1] && (l.x = v[0], l.y = s[1] - (v[1] + o[1])), p && (p[0] !== o[0] / 2 || p[1] !== o[1] / 2)) {
            const y = { x: p[0], xunits: "pixels", y: o[1] - p[1], yunits: "pixels" };
            r.hotSpot = y;
          }
        }
        r.Icon = l;
        let u = t.getScaleArray()[0], h = o;
        if (h === null && (h = KA), h.length == 2) {
          const p = Bm(h);
          u = u / p;
        }
        u !== 1 && (r.scale = u);
        const c = t.getRotation();
        c !== 0 && (r.heading = c);
        const f = t.getColor();
        f && (r.color = f);
        const g = e[e.length - 1].node, d = tft[g.namespaceURI], A = fr(r, d);
        Xt(i, eft, ai, A, e, d);
      }
      const ift = K(Lt, ["color", "scale"]), rft = K(Lt, { color: U(Rm), scale: U(cO) });
      function aft(n, t, e) {
        const i = { node: n }, r = {}, a = t.getFill();
        a && (r.color = a.getColor());
        const o = t.getScale();
        o && o !== 1 && (r.scale = o);
        const s = e[e.length - 1].node, l = ift[s.namespaceURI], u = fr(r, l);
        Xt(i, rft, ai, u, e, l);
      }
      const oft = K(Lt, ["color", "width"]), sft = K(Lt, { color: U(Rm), width: U(dr) });
      function lft(n, t, e) {
        const i = { node: n }, r = { color: t.getColor(), width: Number(t.getWidth()) || 1 }, a = e[e.length - 1].node, o = oft[a.namespaceURI], s = fr(r, o);
        Xt(i, sft, ai, s, e, o);
      }
      const uft = { Point: "Point", LineString: "LineString", LinearRing: "LinearRing", Polygon: "Polygon", MultiPoint: "MultiGeometry", MultiLineString: "MultiGeometry", MultiPolygon: "MultiGeometry", GeometryCollection: "MultiGeometry" }, aO = function(n, t, e) {
        if (n) {
          const i = t[t.length - 1].node;
          return $t(i.namespaceURI, uft[n.getType()]);
        }
      }, hft = pn("Point"), cft = pn("LineString"), fft = pn("LinearRing"), gft = pn("Polygon"), dft = K(Lt, { LineString: U(jf), Point: U(jf), Polygon: U(hO), GeometryCollection: U(oO) });
      function oO(n, t, e) {
        const i = { node: n }, r = t.getType();
        let a = [], o;
        if (r === "GeometryCollection") t.getGeometriesArrayRecursive().forEach(function(s) {
          const l = s.getType();
          if (l === "MultiPoint") a = a.concat(s.getPoints());
          else if (l === "MultiLineString") a = a.concat(s.getLineStrings());
          else if (l === "MultiPolygon") a = a.concat(s.getPolygons());
          else if (l === "Point" || l === "LineString" || l === "Polygon") a.push(s);
          else throw new Error("Unknown geometry type");
        }), o = aO;
        else if (r === "MultiPoint") a = t.getPoints(), o = hft;
        else if (r === "MultiLineString") a = t.getLineStrings(), o = cft;
        else if (r === "MultiPolygon") a = t.getPolygons(), o = gft;
        else throw new Error("Unknown geometry type");
        Xt(i, dft, o, a, e);
      }
      const Aft = K(Lt, { LinearRing: U(jf) });
      function sO(n, t, e) {
        Xt({ node: n }, Aft, fft, [t], e);
      }
      const tS = K(Lt, { ExtendedData: U(Kct), MultiGeometry: U(oO), LineString: U(jf), LinearRing: U(jf), Point: U(jf), Polygon: U(hO), Style: U(bft), address: U(Yt), description: U(Yt), name: U(Yt), open: U(Uf), phoneNumber: U(Yt), styleUrl: U(Yt), visibility: U(Uf) }), pft = K(Lt, ["name", "open", "visibility", "address", "phoneNumber", "description", "styleUrl", "Style"]), vft = pn("ExtendedData");
      function lO(n, t, e) {
        const i = { node: n };
        t.getId() && n.setAttribute("id", t.getId());
        const r = t.getProperties(), a = { address: 1, description: 1, name: 1, open: 1, phoneNumber: 1, styleUrl: 1, visibility: 1 };
        a[t.getGeometryName()] = 1;
        const o = Object.keys(r || {}).sort().filter(function(g) {
          return !a[g];
        }), s = t.getStyleFunction();
        if (s) {
          const g = s(t, 0);
          if (g) {
            const d = Array.isArray(g) ? g : [g];
            let A = d;
            if (t.getGeometry() && (A = d.filter(function(p) {
              const v = p.getGeometryFunction()(t);
              if (v) {
                const y = v.getType();
                return y === "GeometryCollection" ? v.getGeometriesArrayRecursive().filter(function(m) {
                  const _ = m.getType();
                  return _ === "Point" || _ === "MultiPoint";
                }).length : y === "Point" || y === "MultiPoint";
              }
            })), this.writeStyles_) {
              let p = d, v = d;
              t.getGeometry() && (p = d.filter(function(y) {
                const m = y.getGeometryFunction()(t);
                if (m) {
                  const _ = m.getType();
                  return _ === "GeometryCollection" ? m.getGeometriesArrayRecursive().filter(function(E) {
                    const I = E.getType();
                    return I === "LineString" || I === "MultiLineString";
                  }).length : _ === "LineString" || _ === "MultiLineString";
                }
              }), v = d.filter(function(y) {
                const m = y.getGeometryFunction()(t);
                if (m) {
                  const _ = m.getType();
                  return _ === "GeometryCollection" ? m.getGeometriesArrayRecursive().filter(function(E) {
                    const I = E.getType();
                    return I === "Polygon" || I === "MultiPolygon";
                  }).length : _ === "Polygon" || _ === "MultiPolygon";
                }
              })), r.Style = { pointStyles: A, lineStyles: p, polyStyles: v };
            }
            if (A.length && r.name === void 0) {
              const p = A[0].getText();
              p && (r.name = p.getText());
            }
          }
        }
        const l = e[e.length - 1].node, u = pft[l.namespaceURI], h = fr(r, u);
        if (Xt(i, tS, ai, h, e, u), o.length > 0) {
          const g = fr(r, o);
          Xt(i, tS, vft, [{ names: o, values: g }], e);
        }
        const c = e[0];
        let f = t.getGeometry();
        f && (f = sn(f, true, c)), Xt(i, tS, aO, [f], e);
      }
      const yft = K(Lt, ["extrude", "tessellate", "altitudeMode", "coordinates"]), mft = K(Lt, { extrude: U(Uf), tessellate: U(Uf), altitudeMode: U(Yt), coordinates: U(Vct) });
      function jf(n, t, e) {
        const i = t.getFlatCoordinates(), r = { node: n };
        r.layout = t.getLayout(), r.stride = t.getStride();
        const a = t.getProperties();
        a.coordinates = i;
        const o = e[e.length - 1].node, s = yft[o.namespaceURI], l = fr(a, s);
        Xt(r, mft, ai, l, e, s);
      }
      const _ft = K(Lt, ["color", "fill", "outline"]), uO = K(Lt, { outerBoundaryIs: U(sO), innerBoundaryIs: U(sO) }), Ift = pn("innerBoundaryIs"), Eft = pn("outerBoundaryIs");
      function hO(n, t, e) {
        const i = t.getLinearRings(), r = i.shift(), a = { node: n };
        Xt(a, uO, Ift, i, e), Xt(a, uO, Eft, [r], e);
      }
      const xft = K(Lt, { color: U(Rm), fill: U(Uf), outline: U(Uf) });
      function wft(n, t, e) {
        const i = { node: n }, r = t.getFill(), a = t.getStroke(), o = { color: r ? r.getColor() : void 0, fill: r ? void 0 : false, outline: a ? void 0 : false }, s = e[e.length - 1].node, l = _ft[s.namespaceURI], u = fr(o, l);
        Xt(i, xft, ai, u, e, l);
      }
      function cO(n, t) {
        dr(n, Math.round(t * 1e6) / 1e6);
      }
      const Cft = K(Lt, ["IconStyle", "LabelStyle", "LineStyle", "PolyStyle"]), Sft = K(Lt, { IconStyle: U(nft), LabelStyle: U(aft), LineStyle: U(lft), PolyStyle: U(wft) });
      function bft(n, t, e) {
        const i = { node: n }, r = {};
        if (t.pointStyles.length) {
          const l = t.pointStyles[0].getText();
          l && (r.LabelStyle = l);
          const u = t.pointStyles[0].getImage();
          u && typeof u.getSrc == "function" && (r.IconStyle = u);
        }
        if (t.lineStyles.length) {
          const l = t.lineStyles[0].getStroke();
          l && (r.LineStyle = l);
        }
        if (t.polyStyles.length) {
          const l = t.polyStyles[0].getStroke();
          l && !r.LineStyle && (r.LineStyle = l), r.PolyStyle = t.polyStyles[0];
        }
        const a = e[e.length - 1].node, o = Cft[a.namespaceURI], s = fr(r, o);
        Xt(i, Sft, ai, s, e, o);
      }
      function Bft(n, t) {
        n.setAttribute("x", String(t.x)), n.setAttribute("y", String(t.y)), n.setAttribute("xunits", t.xunits), n.setAttribute("yunits", t.yunits);
      }
      const eS = 65536 * 65536, fO = 1 / eS, Tft = 12, gO = typeof TextDecoder == "undefined" ? null : new TextDecoder("utf-8"), nS = 0, Pm = 1, $A = 2, Nm = 5;
      class Mft {
        constructor(t = new Uint8Array(16)) {
          this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        readFields(t, e, i = this.length) {
          for (; this.pos < i; ) {
            const r = this.readVarint(), a = r >> 3, o = this.pos;
            this.type = r & 7, t(a, e, this), this.pos === o && this.skip(r);
          }
          return e;
        }
        readMessage(t, e) {
          return this.readFields(t, e, this.readVarint() + this.pos);
        }
        readFixed32() {
          const t = this.dataView.getUint32(this.pos, true);
          return this.pos += 4, t;
        }
        readSFixed32() {
          const t = this.dataView.getInt32(this.pos, true);
          return this.pos += 4, t;
        }
        readFixed64() {
          const t = this.dataView.getUint32(this.pos, true) + this.dataView.getUint32(this.pos + 4, true) * eS;
          return this.pos += 8, t;
        }
        readSFixed64() {
          const t = this.dataView.getUint32(this.pos, true) + this.dataView.getInt32(this.pos + 4, true) * eS;
          return this.pos += 8, t;
        }
        readFloat() {
          const t = this.dataView.getFloat32(this.pos, true);
          return this.pos += 4, t;
        }
        readDouble() {
          const t = this.dataView.getFloat64(this.pos, true);
          return this.pos += 8, t;
        }
        readVarint(t) {
          const e = this.buf;
          let i, r;
          return r = e[this.pos++], i = r & 127, r < 128 || (r = e[this.pos++], i |= (r & 127) << 7, r < 128) || (r = e[this.pos++], i |= (r & 127) << 14, r < 128) || (r = e[this.pos++], i |= (r & 127) << 21, r < 128) ? i : (r = e[this.pos], i |= (r & 15) << 28, Dft(i, t, this));
        }
        readVarint64() {
          return this.readVarint(true);
        }
        readSVarint() {
          const t = this.readVarint();
          return t % 2 === 1 ? (t + 1) / -2 : t / 2;
        }
        readBoolean() {
          return !!this.readVarint();
        }
        readString() {
          const t = this.readVarint() + this.pos, e = this.pos;
          return this.pos = t, t - e >= Tft && gO ? gO.decode(this.buf.subarray(e, t)) : jft(this.buf, e, t);
        }
        readBytes() {
          const t = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, t);
          return this.pos = t, e;
        }
        readPackedVarint(t = [], e) {
          const i = this.readPackedEnd();
          for (; this.pos < i; ) t.push(this.readVarint(e));
          return t;
        }
        readPackedSVarint(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readSVarint());
          return t;
        }
        readPackedBoolean(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readBoolean());
          return t;
        }
        readPackedFloat(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readFloat());
          return t;
        }
        readPackedDouble(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readDouble());
          return t;
        }
        readPackedFixed32(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readFixed32());
          return t;
        }
        readPackedSFixed32(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readSFixed32());
          return t;
        }
        readPackedFixed64(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readFixed64());
          return t;
        }
        readPackedSFixed64(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readSFixed64());
          return t;
        }
        readPackedEnd() {
          return this.type === $A ? this.readVarint() + this.pos : this.pos + 1;
        }
        skip(t) {
          const e = t & 7;
          if (e === nS) for (; this.buf[this.pos++] > 127; ) ;
          else if (e === $A) this.pos = this.readVarint() + this.pos;
          else if (e === Nm) this.pos += 4;
          else if (e === Pm) this.pos += 8;
          else throw new Error(`Unimplemented type: ${e}`);
        }
        writeTag(t, e) {
          this.writeVarint(t << 3 | e);
        }
        realloc(t) {
          let e = this.length || 16;
          for (; e < this.pos + t; ) e *= 2;
          if (e !== this.length) {
            const i = new Uint8Array(e);
            i.set(this.buf), this.buf = i, this.dataView = new DataView(i.buffer), this.length = e;
          }
        }
        finish() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }
        writeFixed32(t) {
          this.realloc(4), this.dataView.setInt32(this.pos, t, true), this.pos += 4;
        }
        writeSFixed32(t) {
          this.realloc(4), this.dataView.setInt32(this.pos, t, true), this.pos += 4;
        }
        writeFixed64(t) {
          this.realloc(8), this.dataView.setInt32(this.pos, t & -1, true), this.dataView.setInt32(this.pos + 4, Math.floor(t * fO), true), this.pos += 8;
        }
        writeSFixed64(t) {
          this.realloc(8), this.dataView.setInt32(this.pos, t & -1, true), this.dataView.setInt32(this.pos + 4, Math.floor(t * fO), true), this.pos += 8;
        }
        writeVarint(t) {
          if (t = +t || 0, t > 268435455 || t < 0) {
            Rft(t, this);
            return;
          }
          this.realloc(4), this.buf[this.pos++] = t & 127 | (t > 127 ? 128 : 0), !(t <= 127) && (this.buf[this.pos++] = (t >>>= 7) & 127 | (t > 127 ? 128 : 0), !(t <= 127) && (this.buf[this.pos++] = (t >>>= 7) & 127 | (t > 127 ? 128 : 0), !(t <= 127) && (this.buf[this.pos++] = t >>> 7 & 127)));
        }
        writeSVarint(t) {
          this.writeVarint(t < 0 ? -t * 2 - 1 : t * 2);
        }
        writeBoolean(t) {
          this.writeVarint(+t);
        }
        writeString(t) {
          t = String(t), this.realloc(t.length * 4), this.pos++;
          const e = this.pos;
          this.pos = qft(this.buf, t, this.pos);
          const i = this.pos - e;
          i >= 128 && dO(e, i, this), this.pos = e - 1, this.writeVarint(i), this.pos += i;
        }
        writeFloat(t) {
          this.realloc(4), this.dataView.setFloat32(this.pos, t, true), this.pos += 4;
        }
        writeDouble(t) {
          this.realloc(8), this.dataView.setFloat64(this.pos, t, true), this.pos += 8;
        }
        writeBytes(t) {
          const e = t.length;
          this.writeVarint(e), this.realloc(e);
          for (let i = 0; i < e; i++) this.buf[this.pos++] = t[i];
        }
        writeRawMessage(t, e) {
          this.pos++;
          const i = this.pos;
          t(e, this);
          const r = this.pos - i;
          r >= 128 && dO(i, r, this), this.pos = i - 1, this.writeVarint(r), this.pos += r;
        }
        writeMessage(t, e, i) {
          this.writeTag(t, $A), this.writeRawMessage(e, i);
        }
        writePackedVarint(t, e) {
          e.length && this.writeMessage(t, Nft, e);
        }
        writePackedSVarint(t, e) {
          e.length && this.writeMessage(t, kft, e);
        }
        writePackedBoolean(t, e) {
          e.length && this.writeMessage(t, Oft, e);
        }
        writePackedFloat(t, e) {
          e.length && this.writeMessage(t, Fft, e);
        }
        writePackedDouble(t, e) {
          e.length && this.writeMessage(t, Qft, e);
        }
        writePackedFixed32(t, e) {
          e.length && this.writeMessage(t, zft, e);
        }
        writePackedSFixed32(t, e) {
          e.length && this.writeMessage(t, Gft, e);
        }
        writePackedFixed64(t, e) {
          e.length && this.writeMessage(t, Uft, e);
        }
        writePackedSFixed64(t, e) {
          e.length && this.writeMessage(t, Vft, e);
        }
        writeBytesField(t, e) {
          this.writeTag(t, $A), this.writeBytes(e);
        }
        writeFixed32Field(t, e) {
          this.writeTag(t, Nm), this.writeFixed32(e);
        }
        writeSFixed32Field(t, e) {
          this.writeTag(t, Nm), this.writeSFixed32(e);
        }
        writeFixed64Field(t, e) {
          this.writeTag(t, Pm), this.writeFixed64(e);
        }
        writeSFixed64Field(t, e) {
          this.writeTag(t, Pm), this.writeSFixed64(e);
        }
        writeVarintField(t, e) {
          this.writeTag(t, nS), this.writeVarint(e);
        }
        writeSVarintField(t, e) {
          this.writeTag(t, nS), this.writeSVarint(e);
        }
        writeStringField(t, e) {
          this.writeTag(t, $A), this.writeString(e);
        }
        writeFloatField(t, e) {
          this.writeTag(t, Nm), this.writeFloat(e);
        }
        writeDoubleField(t, e) {
          this.writeTag(t, Pm), this.writeDouble(e);
        }
        writeBooleanField(t, e) {
          this.writeVarintField(t, +e);
        }
      }
      function Dft(n, t, e) {
        const i = e.buf;
        let r, a;
        if (a = i[e.pos++], r = (a & 112) >> 4, a < 128 || (a = i[e.pos++], r |= (a & 127) << 3, a < 128) || (a = i[e.pos++], r |= (a & 127) << 10, a < 128) || (a = i[e.pos++], r |= (a & 127) << 17, a < 128) || (a = i[e.pos++], r |= (a & 127) << 24, a < 128) || (a = i[e.pos++], r |= (a & 1) << 31, a < 128)) return qf(n, r, t);
        throw new Error("Expected varint not more than 10 bytes");
      }
      function qf(n, t, e) {
        return e ? t * 4294967296 + (n >>> 0) : (t >>> 0) * 4294967296 + (n >>> 0);
      }
      function Rft(n, t) {
        let e, i;
        if (n >= 0 ? (e = n % 4294967296 | 0, i = n / 4294967296 | 0) : (e = ~(-n % 4294967296), i = ~(-n / 4294967296), e ^ 4294967295 ? e = e + 1 | 0 : (e = 0, i = i + 1 | 0)), n >= 18446744073709552e3 || n < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
        t.realloc(10), Lft(e, i, t), Pft(i, t);
      }
      function Lft(n, t, e) {
        e.buf[e.pos++] = n & 127 | 128, n >>>= 7, e.buf[e.pos++] = n & 127 | 128, n >>>= 7, e.buf[e.pos++] = n & 127 | 128, n >>>= 7, e.buf[e.pos++] = n & 127 | 128, n >>>= 7, e.buf[e.pos] = n & 127;
      }
      function Pft(n, t) {
        const e = (n & 7) << 4;
        t.buf[t.pos++] |= e | ((n >>>= 3) ? 128 : 0), n && (t.buf[t.pos++] = n & 127 | ((n >>>= 7) ? 128 : 0), n && (t.buf[t.pos++] = n & 127 | ((n >>>= 7) ? 128 : 0), n && (t.buf[t.pos++] = n & 127 | ((n >>>= 7) ? 128 : 0), n && (t.buf[t.pos++] = n & 127 | ((n >>>= 7) ? 128 : 0), n && (t.buf[t.pos++] = n & 127)))));
      }
      function dO(n, t, e) {
        const i = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (Math.LN2 * 7));
        e.realloc(i);
        for (let r = e.pos - 1; r >= n; r--) e.buf[r + i] = e.buf[r];
      }
      function Nft(n, t) {
        for (let e = 0; e < n.length; e++) t.writeVarint(n[e]);
      }
      function kft(n, t) {
        for (let e = 0; e < n.length; e++) t.writeSVarint(n[e]);
      }
      function Fft(n, t) {
        for (let e = 0; e < n.length; e++) t.writeFloat(n[e]);
      }
      function Qft(n, t) {
        for (let e = 0; e < n.length; e++) t.writeDouble(n[e]);
      }
      function Oft(n, t) {
        for (let e = 0; e < n.length; e++) t.writeBoolean(n[e]);
      }
      function zft(n, t) {
        for (let e = 0; e < n.length; e++) t.writeFixed32(n[e]);
      }
      function Gft(n, t) {
        for (let e = 0; e < n.length; e++) t.writeSFixed32(n[e]);
      }
      function Uft(n, t) {
        for (let e = 0; e < n.length; e++) t.writeFixed64(n[e]);
      }
      function Vft(n, t) {
        for (let e = 0; e < n.length; e++) t.writeSFixed64(n[e]);
      }
      function jft(n, t, e) {
        let i = "", r = t;
        for (; r < e; ) {
          const a = n[r];
          let o = null, s = a > 239 ? 4 : a > 223 ? 3 : a > 191 ? 2 : 1;
          if (r + s > e) break;
          let l, u, h;
          s === 1 ? a < 128 && (o = a) : s === 2 ? (l = n[r + 1], (l & 192) === 128 && (o = (a & 31) << 6 | l & 63, o <= 127 && (o = null))) : s === 3 ? (l = n[r + 1], u = n[r + 2], (l & 192) === 128 && (u & 192) === 128 && (o = (a & 15) << 12 | (l & 63) << 6 | u & 63, (o <= 2047 || o >= 55296 && o <= 57343) && (o = null))) : s === 4 && (l = n[r + 1], u = n[r + 2], h = n[r + 3], (l & 192) === 128 && (u & 192) === 128 && (h & 192) === 128 && (o = (a & 15) << 18 | (l & 63) << 12 | (u & 63) << 6 | h & 63, (o <= 65535 || o >= 1114112) && (o = null))), o === null ? (o = 65533, s = 1) : o > 65535 && (o -= 65536, i += String.fromCharCode(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), i += String.fromCharCode(o), r += s;
        }
        return i;
      }
      function qft(n, t, e) {
        for (let i = 0, r, a; i < t.length; i++) {
          if (r = t.charCodeAt(i), r > 55295 && r < 57344) if (a) if (r < 56320) {
            n[e++] = 239, n[e++] = 191, n[e++] = 189, a = r;
            continue;
          } else r = a - 55296 << 10 | r - 56320 | 65536, a = null;
          else {
            r > 56319 || i + 1 === t.length ? (n[e++] = 239, n[e++] = 191, n[e++] = 189) : a = r;
            continue;
          }
          else a && (n[e++] = 239, n[e++] = 191, n[e++] = 189, a = null);
          r < 128 ? n[e++] = r : (r < 2048 ? n[e++] = r >> 6 | 192 : (r < 65536 ? n[e++] = r >> 12 | 224 : (n[e++] = r >> 18 | 240, n[e++] = r >> 12 & 63 | 128), n[e++] = r >> 6 & 63 | 128), n[e++] = r & 63 | 128);
        }
        return e;
      }
      class Hft extends qA {
        constructor(t) {
          super(), t = t || {}, this.dataProjection = new rr({ code: "", units: "tile-pixels" }), this.featureClass = t.featureClass ? t.featureClass : ki, this.geometryName_ = t.geometryName, this.layerName_ = t.layerName ? t.layerName : "layer", this.layers_ = t.layers ? t.layers : null, this.idProperty_ = t.idProperty, this.supportedMediaTypes = ["application/vnd.mapbox-vector-tile", "application/x-protobuf"];
        }
        readRawGeometry_(t, e, i, r) {
          t.pos = e.geometry;
          const a = t.readVarint() + t.pos;
          let o = 1, s = 0, l = 0, u = 0, h = 0, c = 0;
          for (; t.pos < a; ) {
            if (!s) {
              const f = t.readVarint();
              o = f & 7, s = f >> 3;
            }
            if (s--, o === 1 || o === 2) l += t.readSVarint(), u += t.readSVarint(), o === 1 && h > c && (r.push(h), c = h), i.push(l, u), h += 2;
            else if (o === 7) h > c && (i.push(i[c], i[c + 1]), h += 2);
            else throw new Error("Invalid command found in the PBF");
          }
          h > c && (r.push(h), c = h);
        }
        createFeature_(t, e, i) {
          const r = e.type;
          if (r === 0) return null;
          let a;
          const o = e.properties;
          let s;
          this.idProperty_ ? (s = o[this.idProperty_], delete o[this.idProperty_]) : s = e.id, o[this.layerName_] = e.layer.name;
          const l = [], u = [];
          this.readRawGeometry_(t, e, l, u);
          const h = Kft(r, u.length);
          if (this.featureClass === ki) a = new this.featureClass(h, l, u, 2, o, s), a.transform(i.dataProjection);
          else {
            let c;
            if (h == "Polygon") {
              const d = dP(l, u);
              c = d.length > 1 ? new Ci(l, "XY", d) : new Sn(l, "XY", u);
            } else c = h === "Point" ? new Oe(l, "XY") : h === "LineString" ? new be(l, "XY") : h === "MultiPoint" ? new sr(l, "XY") : h === "MultiLineString" ? new ri(l, "XY", u) : null;
            const f = this.featureClass;
            a = new f(), this.geometryName_ && a.setGeometryName(this.geometryName_);
            const g = sn(c, false, i);
            a.setGeometry(g), s !== void 0 && a.setId(s), a.setProperties(o, true);
          }
          return a;
        }
        getType() {
          return "arraybuffer";
        }
        readFeatures(t, e) {
          const i = this.layers_;
          e = this.adaptOptions(e);
          const r = Vt(e.dataProjection);
          r.setWorldExtent(e.extent), e.dataProjection = r;
          const a = new Mft(t), o = a.readFields(Yft, {}), s = [];
          for (const l in o) {
            if (i && !i.includes(l)) continue;
            const u = o[l], h = u ? [0, 0, u.extent, u.extent] : null;
            r.setExtent(h);
            for (let c = 0, f = u.length; c < f; ++c) {
              const g = Zft(a, u, c), d = this.createFeature_(a, g, e);
              d !== null && s.push(d);
            }
          }
          return s;
        }
        readProjection(t) {
          return this.dataProjection;
        }
        setLayers(t) {
          this.layers_ = t;
        }
      }
      function Yft(n, t, e) {
        if (n === 3) {
          const i = { keys: [], values: [], features: [] }, r = e.readVarint() + e.pos;
          e.readFields(Wft, i, r), i.length = i.features.length, i.length && (t[i.name] = i);
        }
      }
      function Wft(n, t, e) {
        if (n === 15) t.version = e.readVarint();
        else if (n === 1) t.name = e.readString();
        else if (n === 5) t.extent = e.readVarint();
        else if (n === 2) t.features.push(e.pos);
        else if (n === 3) t.keys.push(e.readString());
        else if (n === 4) {
          let i = null;
          const r = e.readVarint() + e.pos;
          for (; e.pos < r; ) n = e.readVarint() >> 3, i = n === 1 ? e.readString() : n === 2 ? e.readFloat() : n === 3 ? e.readDouble() : n === 4 ? e.readVarint64() : n === 5 ? e.readVarint() : n === 6 ? e.readSVarint() : n === 7 ? e.readBoolean() : null;
          t.values.push(i);
        }
      }
      function Xft(n, t, e) {
        if (n == 1) t.id = e.readVarint();
        else if (n == 2) {
          const i = e.readVarint() + e.pos;
          for (; e.pos < i; ) {
            const r = t.layer.keys[e.readVarint()], a = t.layer.values[e.readVarint()];
            t.properties[r] = a;
          }
        } else n == 3 ? t.type = e.readVarint() : n == 4 && (t.geometry = e.pos);
      }
      function Zft(n, t, e) {
        n.pos = t.features[e];
        const i = n.readVarint() + n.pos, r = { layer: t, type: 0, properties: {} };
        return n.readFields(Xft, r, i), r;
      }
      function Kft(n, t) {
        let e;
        return n === 1 ? e = t === 1 ? "Point" : "MultiPoint" : n === 2 ? e = t === 1 ? "LineString" : "MultiLineString" : n === 3 && (e = "Polygon"), e;
      }
      class iS {
        read(t) {
          if (!t) return null;
          if (typeof t == "string") {
            const e = ea(t);
            return this.readFromDocument(e);
          }
          return ta(t) ? this.readFromDocument(t) : this.readFromNode(t);
        }
        readFromDocument(t) {
          for (let e = t.firstChild; e; e = e.nextSibling) if (e.nodeType == Node.ELEMENT_NODE) return this.readFromNode(e);
          return null;
        }
        readFromNode(t) {
          Qt();
        }
      }
      const $ft = "http://www.w3.org/1999/xlink";
      function Hf(n) {
        return n.getAttributeNS($ft, "href");
      }
      const Ar = [null, "http://www.opengis.net/ows/1.1"], Jft = K(Ar, { ServiceIdentification: O(xgt), ServiceProvider: O(Cgt), OperationsMetadata: O(Igt) });
      class AO extends iS {
        constructor() {
          super();
        }
        readFromNode(t) {
          const e = rt({}, Jft, t, []);
          return e || null;
        }
      }
      const tgt = K(Ar, { DeliveryPoint: O(at), City: O(at), AdministrativeArea: O(at), PostalCode: O(at), Country: O(at), ElectronicMailAddress: O(at) }), egt = K(Ar, { Value: Ge(Sgt) }), ngt = K(Ar, { AllowedValues: O(dgt) }), igt = K(Ar, { Phone: O(Egt), Address: O(ggt) }), rgt = K(Ar, { HTTP: O(mgt) }), agt = K(Ar, { Get: Ge(ygt), Post: void 0 }), ogt = K(Ar, { DCP: O(vgt) }), sgt = K(Ar, { Operation: _gt }), lgt = K(Ar, { Voice: O(at), Facsimile: O(at) }), ugt = K(Ar, { Constraint: Ge(Agt) }), hgt = K(Ar, { IndividualName: O(at), PositionName: O(at), ContactInfo: O(pgt) }), cgt = K(Ar, { Abstract: O(at), AccessConstraints: O(at), Fees: O(at), Title: O(at), ServiceTypeVersion: O(at), ServiceType: O(at) }), fgt = K(Ar, { ProviderName: O(at), ProviderSite: O(Hf), ServiceContact: O(wgt) });
      function ggt(n, t) {
        return rt({}, tgt, n, t);
      }
      function dgt(n, t) {
        return rt({}, egt, n, t);
      }
      function Agt(n, t) {
        const e = n.getAttribute("name");
        if (e) return rt({ name: e }, ngt, n, t);
      }
      function pgt(n, t) {
        return rt({}, igt, n, t);
      }
      function vgt(n, t) {
        return rt({}, rgt, n, t);
      }
      function ygt(n, t) {
        const e = Hf(n);
        if (e) return rt({ href: e }, ugt, n, t);
      }
      function mgt(n, t) {
        return rt({}, agt, n, t);
      }
      function _gt(n, t) {
        const e = n.getAttribute("name"), i = rt({}, ogt, n, t);
        if (!i) return;
        const r = t[t.length - 1];
        r[e] = i;
      }
      function Igt(n, t) {
        return rt({}, sgt, n, t);
      }
      function Egt(n, t) {
        return rt({}, lgt, n, t);
      }
      function xgt(n, t) {
        return rt({}, cgt, n, t);
      }
      function wgt(n, t) {
        return rt({}, hgt, n, t);
      }
      function Cgt(n, t) {
        return rt({}, fgt, n, t);
      }
      function Sgt(n, t) {
        return at(n);
      }
      function pO(n, t, e, i, r, a) {
        r !== void 0 ? (r = r, a = a !== void 0 ? a : 0) : (r = [], a = 0);
        let o = t;
        for (; o < e; ) {
          const s = n[o++];
          r[a++] = n[o++], r[a++] = s;
          for (let l = 2; l < i; ++l) r[a++] = n[o++];
        }
        return r.length = a, r;
      }
      let bgt = class extends jC {
        constructor(t) {
          super(), t = t || {}, this.dataProjection = Vt("EPSG:4326"), this.factor_ = t.factor ? t.factor : 1e5, this.geometryLayout_ = t.geometryLayout ? t.geometryLayout : "XY";
        }
        readFeatureFromText(t, e) {
          const i = this.readGeometryFromText(t, e);
          return new xe(i);
        }
        readFeaturesFromText(t, e) {
          return [this.readFeatureFromText(t, e)];
        }
        readGeometryFromText(t, e) {
          const i = Hd(this.geometryLayout_), r = Tgt(t, i, this.factor_);
          pO(r, 0, r.length, i, r);
          const a = ss(r, 0, r.length, i), o = new be(a, this.geometryLayout_);
          return sn(o, false, this.adaptOptions(e));
        }
        writeFeatureText(t, e) {
          const i = t.getGeometry();
          if (i) return this.writeGeometryText(i, e);
          throw new Error("Expected `feature` to have a geometry");
        }
        writeFeaturesText(t, e) {
          return this.writeFeatureText(t[0], e);
        }
        writeGeometryText(t, e) {
          t = sn(t, true, this.adaptOptions(e));
          const i = t.getFlatCoordinates(), r = t.getStride();
          return pO(i, 0, i.length, r, i), Bgt(i, r, this.factor_);
        }
      };
      function Bgt(n, t, e) {
        e = e || 1e5;
        let i;
        const r = new Array(t);
        for (i = 0; i < t; ++i) r[i] = 0;
        for (let a = 0, o = n.length; a < o; ) for (i = 0; i < t; ++i, ++a) {
          const s = n[a], l = s - r[i];
          r[i] = s, n[a] = l;
        }
        return Mgt(n, e);
      }
      function Tgt(n, t, e) {
        e = e || 1e5;
        let i;
        const r = new Array(t);
        for (i = 0; i < t; ++i) r[i] = 0;
        const a = Dgt(n, e);
        for (let o = 0, s = a.length; o < s; ) for (i = 0; i < t; ++i, ++o) r[i] += a[o], a[o] = r[i];
        return a;
      }
      function Mgt(n, t) {
        t = t || 1e5;
        for (let e = 0, i = n.length; e < i; ++e) n[e] = Math.round(n[e] * t);
        return Rgt(n);
      }
      function Dgt(n, t) {
        t = t || 1e5;
        const e = Lgt(n);
        for (let i = 0, r = e.length; i < r; ++i) e[i] /= t;
        return e;
      }
      function Rgt(n) {
        for (let t = 0, e = n.length; t < e; ++t) {
          const i = n[t];
          n[t] = i < 0 ? ~(i << 1) : i << 1;
        }
        return Pgt(n);
      }
      function Lgt(n) {
        const t = Ngt(n);
        for (let e = 0, i = t.length; e < i; ++e) {
          const r = t[e];
          t[e] = r & 1 ? ~(r >> 1) : r >> 1;
        }
        return t;
      }
      function Pgt(n) {
        let t = "";
        for (let e = 0, i = n.length; e < i; ++e) t += kgt(n[e]);
        return t;
      }
      function Ngt(n) {
        const t = [];
        let e = 0, i = 0;
        for (let r = 0, a = n.length; r < a; ++r) {
          const o = n.charCodeAt(r) - 63;
          e |= (o & 31) << i, o < 32 ? (t.push(e), e = 0, i = 0) : i += 5;
        }
        return t;
      }
      function kgt(n) {
        let t, e = "";
        for (; n >= 32; ) t = (32 | n & 31) + 63, e += String.fromCharCode(t), n >>= 5;
        return t = n + 63, e += String.fromCharCode(t), e;
      }
      class Fgt extends PC {
        constructor(t) {
          super(), t = t || {}, this.layerName_ = t.layerName, this.layers_ = t.layers ? t.layers : null, this.dataProjection = Vt(t.dataProjection ? t.dataProjection : "EPSG:4326");
        }
        readFeaturesFromObject(t, e) {
          if (t.type == "Topology") {
            const i = t;
            let r, a = null, o = null;
            i.transform && (r = i.transform, a = r.scale, o = r.translate);
            const s = i.arcs;
            r && Hgt(s, a, o);
            const l = [], u = i.objects, h = this.layerName_;
            let c;
            for (const f in u) this.layers_ && !this.layers_.includes(f) || (u[f].type === "GeometryCollection" ? (c = u[f], l.push.apply(l, qgt(c, s, a, o, h, f, e))) : (c = u[f], l.push(vO(c, s, a, o, h, f, e))));
            return l;
          }
          return [];
        }
        readProjectionFromObject(t) {
          return this.dataProjection;
        }
      }
      const Qgt = { Point: Ogt, LineString: Ggt, Polygon: Vgt, MultiPoint: zgt, MultiLineString: Ugt, MultiPolygon: jgt };
      function km(n, t) {
        const e = [];
        let i;
        for (let r = 0, a = n.length; r < a; ++r) if (i = n[r], r > 0 && e.pop(), i >= 0) {
          const o = t[i];
          for (let s = 0, l = o.length; s < l; ++s) e.push(o[s].slice(0));
        } else {
          const o = t[~i];
          for (let s = o.length - 1; s >= 0; --s) e.push(o[s].slice(0));
        }
        return e;
      }
      function Ogt(n, t, e) {
        const i = n.coordinates;
        return t && e && rS(i, t, e), new Oe(i);
      }
      function zgt(n, t, e) {
        const i = n.coordinates;
        if (t && e) for (let r = 0, a = i.length; r < a; ++r) rS(i[r], t, e);
        return new sr(i);
      }
      function Ggt(n, t) {
        const e = km(n.arcs, t);
        return new be(e);
      }
      function Ugt(n, t) {
        const e = [];
        for (let i = 0, r = n.arcs.length; i < r; ++i) e[i] = km(n.arcs[i], t);
        return new ri(e);
      }
      function Vgt(n, t) {
        const e = [];
        for (let i = 0, r = n.arcs.length; i < r; ++i) e[i] = km(n.arcs[i], t);
        return new Sn(e);
      }
      function jgt(n, t) {
        const e = [];
        for (let i = 0, r = n.arcs.length; i < r; ++i) {
          const a = n.arcs[i], o = [];
          for (let s = 0, l = a.length; s < l; ++s) o[s] = km(a[s], t);
          e[i] = o;
        }
        return new Ci(e);
      }
      function qgt(n, t, e, i, r, a, o) {
        const s = n.geometries, l = [];
        for (let u = 0, h = s.length; u < h; ++u) l[u] = vO(s[u], t, e, i, r, a, o);
        return l;
      }
      function vO(n, t, e, i, r, a, o) {
        let s = null;
        const l = n.type;
        if (l) {
          const c = Qgt[l];
          l === "Point" || l === "MultiPoint" ? s = c(n, e, i) : s = c(n, t), s = sn(s, false, o);
        }
        const u = new xe({ geometry: s });
        n.id !== void 0 && u.setId(n.id);
        let h = n.properties;
        return r && (h || (h = {}), h[r] = a), h && u.setProperties(h, true), u;
      }
      function Hgt(n, t, e) {
        for (let i = 0, r = n.length; i < r; ++i) Ygt(n[i], t, e);
      }
      function Ygt(n, t, e) {
        let i = 0, r = 0;
        for (let a = 0, o = n.length; a < o; ++a) {
          const s = n[a];
          i += s[0], r += s[1], s[0] = i, s[1] = r, rS(s, t, e);
        }
      }
      function rS(n, t, e) {
        n[0] = n[0] * t[0] + e[0], n[1] = n[1] * t[1] + e[1];
      }
      class Re extends lt {
        constructor(t) {
          t = t || {}, super(t), this.schemaLocation = t.schemaLocation ? t.schemaLocation : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
        }
        writeGeometryElement(t, e, i) {
          const r = i[i.length - 1];
          i[i.length - 1] = Object.assign({ multiCurve: true, multiSurface: true }, r), super.writeGeometryElement(t, e, i);
        }
      }
      Re.prototype.namespace = "http://www.opengis.net/gml/3.2", Re.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml/3.2": { pos: Gt(lt.prototype.readFlatPos), posList: Gt(lt.prototype.readFlatPosList), coordinates: Gt(Ae.prototype.readFlatCoordinates) } }, Re.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml/3.2": { interior: lt.prototype.interiorParser, exterior: lt.prototype.exteriorParser } }, Re.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml/3.2": { Point: Gt(Mt.prototype.readPoint), MultiPoint: Gt(Mt.prototype.readMultiPoint), LineString: Gt(Mt.prototype.readLineString), MultiLineString: Gt(Mt.prototype.readMultiLineString), LinearRing: Gt(Mt.prototype.readLinearRing), Polygon: Gt(Mt.prototype.readPolygon), MultiPolygon: Gt(Mt.prototype.readMultiPolygon), Surface: Gt(Re.prototype.readSurface), MultiSurface: Gt(lt.prototype.readMultiSurface), Curve: Gt(Re.prototype.readCurve), MultiCurve: Gt(lt.prototype.readMultiCurve), Envelope: Gt(Re.prototype.readEnvelope) } }, Re.prototype.MULTICURVE_PARSERS = { "http://www.opengis.net/gml/3.2": { curveMember: Tt(lt.prototype.curveMemberParser), curveMembers: Tt(lt.prototype.curveMemberParser) } }, Re.prototype.MULTISURFACE_PARSERS = { "http://www.opengis.net/gml/3.2": { surfaceMember: Tt(lt.prototype.surfaceMemberParser), surfaceMembers: Tt(lt.prototype.surfaceMemberParser) } }, Re.prototype.CURVEMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { LineString: Tt(Mt.prototype.readLineString), Curve: Tt(lt.prototype.readCurve) } }, Re.prototype.SURFACEMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { Polygon: Tt(Mt.prototype.readPolygon), Surface: Tt(lt.prototype.readSurface) } }, Re.prototype.SURFACE_PARSERS = { "http://www.opengis.net/gml/3.2": { patches: Gt(lt.prototype.readPatch) } }, Re.prototype.CURVE_PARSERS = { "http://www.opengis.net/gml/3.2": { segments: Gt(lt.prototype.readSegment) } }, Re.prototype.ENVELOPE_PARSERS = { "http://www.opengis.net/gml/3.2": { lowerCorner: Tt(lt.prototype.readFlatPosList), upperCorner: Tt(lt.prototype.readFlatPosList) } }, Re.prototype.PATCHES_PARSERS = { "http://www.opengis.net/gml/3.2": { PolygonPatch: Gt(lt.prototype.readPolygonPatch) } }, Re.prototype.SEGMENTS_PARSERS = { "http://www.opengis.net/gml/3.2": { LineStringSegment: Im(lt.prototype.readLineStringSegment) } }, Re.prototype.MULTIPOINT_PARSERS = { "http://www.opengis.net/gml/3.2": { pointMember: Tt(Mt.prototype.pointMemberParser), pointMembers: Tt(Mt.prototype.pointMemberParser) } }, Re.prototype.MULTILINESTRING_PARSERS = { "http://www.opengis.net/gml/3.2": { lineStringMember: Tt(Mt.prototype.lineStringMemberParser), lineStringMembers: Tt(Mt.prototype.lineStringMemberParser) } }, Re.prototype.MULTIPOLYGON_PARSERS = { "http://www.opengis.net/gml/3.2": { polygonMember: Tt(Mt.prototype.polygonMemberParser), polygonMembers: Tt(Mt.prototype.polygonMemberParser) } }, Re.prototype.POINTMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { Point: Tt(Mt.prototype.readFlatCoordinatesFromNode) } }, Re.prototype.LINESTRINGMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { LineString: Tt(Mt.prototype.readLineString) } }, Re.prototype.POLYGONMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { Polygon: Tt(Mt.prototype.readPolygon) } }, Re.prototype.RING_PARSERS = { "http://www.opengis.net/gml/3.2": { LinearRing: Gt(Mt.prototype.readFlatLinearRing), Ring: Gt(Re.prototype.readFlatCurveRing) } }, Re.prototype.RING_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { exterior: U(lt.prototype.writeRing), interior: U(lt.prototype.writeRing) } }, Re.prototype.ENVELOPE_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { lowerCorner: U(Yt), upperCorner: U(Yt) } }, Re.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { surfaceMember: U(lt.prototype.writeSurfaceOrPolygonMember), polygonMember: U(lt.prototype.writeSurfaceOrPolygonMember) } }, Re.prototype.POINTMEMBER_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { pointMember: U(lt.prototype.writePointMember) } }, Re.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { lineStringMember: U(lt.prototype.writeLineStringOrCurveMember), curveMember: U(lt.prototype.writeLineStringOrCurveMember) } }, Re.prototype.GEOMETRY_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { Curve: U(lt.prototype.writeCurveOrLineString), MultiCurve: U(lt.prototype.writeMultiCurveOrLineString), Point: U(Re.prototype.writePoint), MultiPoint: U(lt.prototype.writeMultiPoint), LineString: U(lt.prototype.writeCurveOrLineString), MultiLineString: U(lt.prototype.writeMultiCurveOrLineString), LinearRing: U(lt.prototype.writeLinearRing), Polygon: U(lt.prototype.writeSurfaceOrPolygon), MultiPolygon: U(lt.prototype.writeMultiSurfaceOrPolygon), Surface: U(lt.prototype.writeSurfaceOrPolygon), MultiSurface: U(lt.prototype.writeMultiSurfaceOrPolygon), Envelope: U(lt.prototype.writeEnvelope) } };
      class yO {
        constructor(t) {
          this.tagName_ = t;
        }
        getTagName() {
          return this.tagName_;
        }
      }
      class Wgt extends yO {
        constructor(t, e) {
          super(t), this.conditions = e, he(this.conditions.length >= 2, "At least 2 conditions are required");
        }
      }
      class Xgt extends Wgt {
        constructor(t) {
          super("And", Array.prototype.slice.call(arguments));
        }
      }
      class Zgt extends yO {
        constructor(t, e, i) {
          if (super("BBOX"), this.geometryName = t, this.extent = e, e.length !== 4) throw new Error("Expected an extent with four values ([minX, minY, maxX, maxY])");
          this.srsName = i;
        }
      }
      function Kgt(n) {
        const t = [null].concat(Array.prototype.slice.call(arguments));
        return new (Function.prototype.bind.apply(Xgt, t))();
      }
      function $gt(n, t, e) {
        return new Zgt(n, t, e);
      }
      const mO = { "http://www.opengis.net/gml": { boundedBy: O(Mt.prototype.readExtentElement, "bounds") }, "http://www.opengis.net/wfs/2.0": { member: Tt(Mt.prototype.readFeaturesInternal) } }, Jgt = { "http://www.opengis.net/wfs": { totalInserted: O(mn), totalUpdated: O(mn), totalDeleted: O(mn) }, "http://www.opengis.net/wfs/2.0": { totalInserted: O(mn), totalUpdated: O(mn), totalDeleted: O(mn) } }, tdt = { "http://www.opengis.net/wfs": { TransactionSummary: O(wO, "transactionSummary"), InsertResults: O(SO, "insertIds") }, "http://www.opengis.net/wfs/2.0": { TransactionSummary: O(wO, "transactionSummary"), InsertResults: O(SO, "insertIds") } }, edt = { "http://www.opengis.net/wfs": { PropertyName: U(Yt) }, "http://www.opengis.net/wfs/2.0": { PropertyName: U(Yt) } }, _O = { "http://www.opengis.net/wfs": { Insert: U(bO), Update: U(MO), Delete: U(TO), Property: U(DO), Native: U(RO) }, "http://www.opengis.net/wfs/2.0": { Insert: U(bO), Update: U(MO), Delete: U(TO), Property: U(DO), Native: U(RO) } }, IO = "feature", aS = "http://www.w3.org/2000/xmlns/", oS = { "2.0.0": "http://www.opengis.net/ogc/1.1", "1.1.0": "http://www.opengis.net/ogc", "1.0.0": "http://www.opengis.net/ogc" }, sS = { "2.0.0": "http://www.opengis.net/wfs/2.0", "1.1.0": "http://www.opengis.net/wfs", "1.0.0": "http://www.opengis.net/wfs" }, lS = { "2.0.0": "http://www.opengis.net/fes/2.0", "1.1.0": "http://www.opengis.net/fes", "1.0.0": "http://www.opengis.net/fes" }, EO = { "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd", "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd", "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd" }, uS = { "2.0.0": Re, "1.1.0": lt, "1.0.0": Ae }, ndt = "1.1.0";
      class xO extends YA {
        constructor(t) {
          super(), t = t || {}, this.version_ = t.version ? t.version : ndt, this.featureType_ = t.featureType, this.featureNS_ = t.featureNS, this.gmlFormat_ = t.gmlFormat ? t.gmlFormat : new uS[this.version_](), this.schemaLocation_ = t.schemaLocation ? t.schemaLocation : EO[this.version_];
        }
        getFeatureType() {
          return this.featureType_;
        }
        setFeatureType(t) {
          this.featureType_ = t;
        }
        readFeaturesFromNode(t, e) {
          const i = { node: t };
          Object.assign(i, { featureType: this.featureType_, featureNS: this.featureNS_ }), Object.assign(i, this.getReadOptions(t, e || {}));
          const r = [i];
          let a;
          this.version_ === "2.0.0" ? a = mO : a = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
          let o = rt([], a, t, r, this.gmlFormat_);
          return o || (o = []), o;
        }
        readTransactionResponse(t) {
          if (t) {
            if (typeof t == "string") {
              const e = ea(t);
              return this.readTransactionResponseFromDocument(e);
            }
            return ta(t) ? this.readTransactionResponseFromDocument(t) : this.readTransactionResponseFromNode(t);
          }
        }
        readFeatureCollectionMetadata(t) {
          if (t) {
            if (typeof t == "string") {
              const e = ea(t);
              return this.readFeatureCollectionMetadataFromDocument(e);
            }
            return ta(t) ? this.readFeatureCollectionMetadataFromDocument(t) : this.readFeatureCollectionMetadataFromNode(t);
          }
        }
        readFeatureCollectionMetadataFromDocument(t) {
          for (let e = t.firstChild; e; e = e.nextSibling) if (e.nodeType == Node.ELEMENT_NODE) return this.readFeatureCollectionMetadataFromNode(e);
        }
        readFeatureCollectionMetadataFromNode(t) {
          const e = {}, i = _s(t.getAttribute("numberOfFeatures"));
          return e.numberOfFeatures = i, rt(e, mO, t, [], this.gmlFormat_);
        }
        readTransactionResponseFromDocument(t) {
          for (let e = t.firstChild; e; e = e.nextSibling) if (e.nodeType == Node.ELEMENT_NODE) return this.readTransactionResponseFromNode(e);
        }
        readTransactionResponseFromNode(t) {
          return rt({}, tdt, t, []);
        }
        writeGetFeature(t) {
          const e = $t(sS[this.version_], "GetFeature");
          e.setAttribute("service", "WFS"), e.setAttribute("version", this.version_), t.handle && e.setAttribute("handle", t.handle), t.outputFormat && e.setAttribute("outputFormat", t.outputFormat), t.maxFeatures !== void 0 && e.setAttribute("maxFeatures", String(t.maxFeatures)), t.resultType && e.setAttribute("resultType", t.resultType), t.startIndex !== void 0 && e.setAttribute("startIndex", String(t.startIndex)), t.count !== void 0 && e.setAttribute("count", String(t.count)), t.viewParams !== void 0 && e.setAttribute("viewParams", t.viewParams), e.setAttributeNS(Hu, "xsi:schemaLocation", this.schemaLocation_);
          const i = { node: e };
          if (Object.assign(i, { version: this.version_, srsName: t.srsName, featureNS: t.featureNS ? t.featureNS : this.featureNS_, featurePrefix: t.featurePrefix, propertyNames: t.propertyNames ? t.propertyNames : [] }), he(Array.isArray(t.featureTypes), "`options.featureTypes` must be an Array"), typeof t.featureTypes[0] == "string") {
            let r = t.filter;
            t.bbox && (he(t.geometryName, "`options.geometryName` must also be provided when `options.bbox` is set"), r = this.combineBboxAndFilter(t.geometryName, t.bbox, t.srsName, r)), Object.assign(i, { geometryName: t.geometryName, filter: r }), UO(e, t.featureTypes, [i]);
          } else t.featureTypes.forEach((r) => {
            const a = this.combineBboxAndFilter(r.geometryName, r.bbox, t.srsName, t.filter);
            Object.assign(i, { geometryName: r.geometryName, filter: a }), UO(e, [r.name], [i]);
          });
          return e;
        }
        combineBboxAndFilter(t, e, i, r) {
          const a = $gt(t, e, i);
          return r ? Kgt(r, a) : a;
        }
        writeTransaction(t, e, i, r) {
          const a = [], o = r.version ? r.version : this.version_, s = $t(sS[o], "Transaction");
          s.setAttribute("service", "WFS"), s.setAttribute("version", o);
          let l;
          r && (l = r.gmlOptions ? r.gmlOptions : {}, r.handle && s.setAttribute("handle", r.handle)), s.setAttributeNS(Hu, "xsi:schemaLocation", EO[o]);
          const u = idt(s, l, o, r);
          return t && Fm("Insert", t, a, u), e && Fm("Update", e, a, u), i && Fm("Delete", i, a, u), r.nativeElements && Fm("Native", r.nativeElements, a, u), s;
        }
        readProjectionFromDocument(t) {
          for (let e = t.firstChild; e; e = e.nextSibling) if (e.nodeType == Node.ELEMENT_NODE) return this.readProjectionFromNode(e);
          return null;
        }
        readProjectionFromNode(t) {
          if (t.firstElementChild && t.firstElementChild.firstElementChild) {
            t = t.firstElementChild.firstElementChild;
            for (let e = t.firstElementChild; e; e = e.nextElementSibling) if (!(e.childNodes.length === 0 || e.childNodes.length === 1 && e.firstChild.nodeType === 3)) {
              const i = [{}];
              return this.gmlFormat_.readGeometryElement(e, i), Vt(i.pop().srsName);
            }
          }
          return null;
        }
      }
      function idt(n, t, e, i) {
        const r = i.featurePrefix ? i.featurePrefix : IO;
        let a;
        return e === "1.0.0" ? a = 2 : e === "1.1.0" ? a = 3 : e === "2.0.0" && (a = 3.2), Object.assign({ node: n }, { version: e, featureNS: i.featureNS, featureType: i.featureType, featurePrefix: r, gmlVersion: a, hasZ: i.hasZ, srsName: i.srsName }, t);
      }
      function Fm(n, t, e, i) {
        Xt(i, _O, pn(n), t, e);
      }
      function wO(n, t) {
        return rt({}, Jgt, n, t);
      }
      const rdt = { "http://www.opengis.net/ogc": { FeatureId: Tt(function(n, t) {
        return n.getAttribute("fid");
      }) }, "http://www.opengis.net/ogc/1.1": { FeatureId: Tt(function(n, t) {
        return n.getAttribute("fid");
      }) } };
      function CO(n, t) {
        gr(rdt, n, t);
      }
      const adt = { "http://www.opengis.net/wfs": { Feature: CO }, "http://www.opengis.net/wfs/2.0": { Feature: CO } };
      function SO(n, t) {
        return rt([], adt, n, t);
      }
      function bO(n, t, e) {
        const i = e[e.length - 1], r = i.featureType, a = i.featureNS, o = i.gmlVersion, s = $t(a, r);
        n.appendChild(s), o === 2 ? Ae.prototype.writeFeatureElement(s, t, e) : o === 3 ? lt.prototype.writeFeatureElement(s, t, e) : Re.prototype.writeFeatureElement(s, t, e);
      }
      function BO(n, t, e) {
        const r = e[e.length - 1].version, a = oS[r], o = $t(a, "Filter"), s = $t(a, "FeatureId");
        o.appendChild(s), s.setAttribute("fid", t), n.appendChild(o);
      }
      function hS(n, t) {
        n = n || IO;
        const e = n + ":";
        return t.startsWith(e) ? t : e + t;
      }
      function TO(n, t, e) {
        const i = e[e.length - 1];
        he(t.getId() !== void 0, "Features must have an id set");
        const r = i.featureType, a = i.featurePrefix, o = i.featureNS, s = hS(a, r);
        n.setAttribute("typeName", s), n.setAttributeNS(aS, "xmlns:" + a, o);
        const l = t.getId();
        l !== void 0 && BO(n, l, e);
      }
      function MO(n, t, e) {
        const i = e[e.length - 1];
        he(t.getId() !== void 0, "Features must have an id set");
        const r = i.version, a = i.featureType, o = i.featurePrefix, s = i.featureNS, l = hS(o, a), u = t.getGeometryName();
        n.setAttribute("typeName", l), n.setAttributeNS(aS, "xmlns:" + o, s);
        const h = t.getId();
        if (h !== void 0) {
          const c = t.getKeys(), f = [];
          for (let g = 0, d = c.length; g < d; g++) {
            const A = t.get(c[g]);
            if (A !== void 0) {
              let p = c[g];
              A && typeof A.getSimplifiedGeometry == "function" && (p = u), f.push({ name: p, value: A });
            }
          }
          Xt({ version: r, gmlVersion: i.gmlVersion, node: n, hasZ: i.hasZ, srsName: i.srsName }, _O, pn("Property"), f, e), BO(n, h, e);
        }
      }
      function DO(n, t, e) {
        const i = e[e.length - 1], r = i.version, a = sS[r], s = $t(a, r === "2.0.0" ? "ValueReference" : "Name"), l = i.gmlVersion;
        if (n.appendChild(s), Yt(s, t.name), t.value !== void 0 && t.value !== null) {
          const u = $t(a, "Value");
          n.appendChild(u), t.value && typeof t.value.getSimplifiedGeometry == "function" ? l === 2 ? Ae.prototype.writeGeometryElement(u, t.value, e) : l === 3 ? lt.prototype.writeGeometryElement(u, t.value, e) : Re.prototype.writeGeometryElement(u, t.value, e) : Yt(u, t.value);
        }
      }
      function RO(n, t, e) {
        t.vendorId && n.setAttribute("vendorId", t.vendorId), t.safeToIgnore !== void 0 && n.setAttribute("safeToIgnore", String(t.safeToIgnore)), t.value !== void 0 && Yt(n, t.value);
      }
      const Qm = { "http://www.opengis.net/wfs": { Query: U(LO) }, "http://www.opengis.net/wfs/2.0": { Query: U(LO) }, "http://www.opengis.net/ogc": { During: U(kO), And: U(Om), Or: U(Om), Not: U(FO), BBOX: U(PO), Contains: U(Ll), Intersects: U(Ll), Within: U(Ll), DWithin: U(NO), PropertyIsEqualTo: U(ia), PropertyIsNotEqualTo: U(ia), PropertyIsLessThan: U(ia), PropertyIsLessThanOrEqualTo: U(ia), PropertyIsGreaterThan: U(ia), PropertyIsGreaterThanOrEqualTo: U(ia), PropertyIsNull: U(QO), PropertyIsBetween: U(OO), PropertyIsLike: U(zO) }, "http://www.opengis.net/fes/2.0": { During: U(kO), And: U(Om), Or: U(Om), Not: U(FO), BBOX: U(PO), Contains: U(Ll), Disjoint: U(Ll), Intersects: U(Ll), ResourceId: U(sdt), Within: U(Ll), DWithin: U(NO), PropertyIsEqualTo: U(ia), PropertyIsNotEqualTo: U(ia), PropertyIsLessThan: U(ia), PropertyIsLessThanOrEqualTo: U(ia), PropertyIsGreaterThan: U(ia), PropertyIsGreaterThanOrEqualTo: U(ia), PropertyIsNull: U(QO), PropertyIsBetween: U(OO), PropertyIsLike: U(zO) } };
      function LO(n, t, e) {
        const i = e[e.length - 1], r = i.version, a = i.featurePrefix, o = i.featureNS, s = i.propertyNames, l = i.srsName;
        let u;
        a ? u = hS(a, t) : u = t;
        let h;
        r === "2.0.0" ? h = "typeNames" : h = "typeName", n.setAttribute(h, u), l && n.setAttribute("srsName", l), o && n.setAttributeNS(aS, "xmlns:" + a, o);
        const c = Object.assign({}, i);
        c.node = n, Xt(c, edt, pn("PropertyName"), s, e);
        const f = i.filter;
        if (f) {
          const g = $t(Um(r), "Filter");
          n.appendChild(g), odt(g, f, e);
        }
      }
      function odt(n, t, e) {
        const i = e[e.length - 1], r = { node: n };
        Object.assign(r, { context: i }), Xt(r, Qm, pn(t.getTagName()), [t], e);
      }
      function PO(n, t, e) {
        const i = e[e.length - 1], a = i.context.version;
        i.srsName = t.srsName;
        const o = uS[a];
        Yf(a, n, t.geometryName), o.prototype.writeGeometryElement(n, t.extent, e);
      }
      function sdt(n, t, e) {
        n.setAttribute("rid", t.rid);
      }
      function Ll(n, t, e) {
        const i = e[e.length - 1], a = i.context.version;
        i.srsName = t.srsName;
        const o = uS[a];
        Yf(a, n, t.geometryName), o.prototype.writeGeometryElement(n, t.geometry, e);
      }
      function NO(n, t, e) {
        const a = e[e.length - 1].context.version;
        Ll(n, t, e);
        const o = $t(Um(a), "Distance");
        Yt(o, t.distance.toString()), a === "2.0.0" ? o.setAttribute("uom", t.unit) : o.setAttribute("units", t.unit), n.appendChild(o);
      }
      function kO(n, t, e) {
        const a = e[e.length - 1].context.version;
        zm(lS[a], "ValueReference", n, t.propertyName);
        const o = $t(ms, "TimePeriod");
        n.appendChild(o);
        const s = $t(ms, "begin");
        o.appendChild(s), GO(s, t.begin);
        const l = $t(ms, "end");
        o.appendChild(l), GO(l, t.end);
      }
      function Om(n, t, e) {
        const r = e[e.length - 1].context, a = { node: n };
        Object.assign(a, { context: r });
        const o = t.conditions;
        for (let s = 0, l = o.length; s < l; ++s) {
          const u = o[s];
          Xt(a, Qm, pn(u.getTagName()), [u], e);
        }
      }
      function FO(n, t, e) {
        const r = e[e.length - 1].context, a = { node: n };
        Object.assign(a, { context: r });
        const o = t.condition;
        Xt(a, Qm, pn(o.getTagName()), [o], e);
      }
      function ia(n, t, e) {
        const a = e[e.length - 1].context.version;
        t.matchCase !== void 0 && n.setAttribute("matchCase", t.matchCase.toString()), Yf(a, n, t.propertyName), Gm(a, n, "" + t.expression);
      }
      function QO(n, t, e) {
        const a = e[e.length - 1].context.version;
        Yf(a, n, t.propertyName);
      }
      function OO(n, t, e) {
        const a = e[e.length - 1].context.version, o = Um(a);
        Yf(a, n, t.propertyName);
        const s = $t(o, "LowerBoundary");
        n.appendChild(s), Gm(a, s, "" + t.lowerBoundary);
        const l = $t(o, "UpperBoundary");
        n.appendChild(l), Gm(a, l, "" + t.upperBoundary);
      }
      function zO(n, t, e) {
        const a = e[e.length - 1].context.version;
        n.setAttribute("wildCard", t.wildCard), n.setAttribute("singleChar", t.singleChar), n.setAttribute("escapeChar", t.escapeChar), t.matchCase !== void 0 && n.setAttribute("matchCase", t.matchCase.toString()), Yf(a, n, t.propertyName), Gm(a, n, "" + t.pattern);
      }
      function zm(n, t, e, i) {
        const r = $t(n, t);
        Yt(r, i), e.appendChild(r);
      }
      function Gm(n, t, e) {
        zm(Um(n), "Literal", t, e);
      }
      function Yf(n, t, e) {
        n === "2.0.0" ? zm(lS[n], "ValueReference", t, e) : zm(oS[n], "PropertyName", t, e);
      }
      function GO(n, t) {
        const e = $t(ms, "TimeInstant");
        n.appendChild(e);
        const i = $t(ms, "timePosition");
        e.appendChild(i), Yt(i, t);
      }
      function UO(n, t, e) {
        const i = e[e.length - 1], r = Object.assign({}, i);
        r.node = n, Xt(r, Qm, pn("Query"), t, e);
      }
      function Um(n) {
        let t;
        return n === "2.0.0" ? t = lS[n] : t = oS[n], t;
      }
      const We = { POINT: 1, LINE_STRING: 2, POLYGON: 3, MULTI_POINT: 4, MULTI_LINE_STRING: 5, MULTI_POLYGON: 6, GEOMETRY_COLLECTION: 7, POLYHEDRAL_SURFACE: 15, TIN: 16, TRIANGLE: 17 };
      class VO {
        constructor(t) {
          this.view_ = t, this.pos_ = 0, this.initialized_ = false, this.isLittleEndian_ = false, this.hasZ_ = false, this.hasM_ = false, this.srid_ = null, this.layout_ = "XY";
        }
        readUint8() {
          return this.view_.getUint8(this.pos_++);
        }
        readUint32(t) {
          return this.view_.getUint32((this.pos_ += 4) - 4, t !== void 0 ? t : this.isLittleEndian_);
        }
        readDouble(t) {
          return this.view_.getFloat64((this.pos_ += 8) - 8, t !== void 0 ? t : this.isLittleEndian_);
        }
        readPoint() {
          const t = [];
          return t.push(this.readDouble()), t.push(this.readDouble()), this.hasZ_ && t.push(this.readDouble()), this.hasM_ && t.push(this.readDouble()), t;
        }
        readLineString() {
          const t = this.readUint32(), e = [];
          for (let i = 0; i < t; i++) e.push(this.readPoint());
          return e;
        }
        readPolygon() {
          const t = this.readUint32(), e = [];
          for (let i = 0; i < t; i++) e.push(this.readLineString());
          return e;
        }
        readWkbHeader(t) {
          const i = this.readUint8() > 0, r = this.readUint32(i), a = Math.floor((r & 268435455) / 1e3), o = !!(r & 2147483648) || a === 1 || a === 3, s = !!(r & 1073741824) || a === 2 || a === 3, l = !!(r & 536870912), u = (r & 268435455) % 1e3, h = ["XY", o ? "Z" : "", s ? "M" : ""].join(""), c = l ? this.readUint32(i) : null;
          if (t !== void 0 && t !== u) throw new Error("Unexpected WKB geometry type " + u);
          if (this.initialized_) {
            if (this.isLittleEndian_ !== i) throw new Error("Inconsistent endian");
            if (this.layout_ !== h) throw new Error("Inconsistent geometry layout");
            if (c && this.srid_ !== c) throw new Error("Inconsistent coordinate system (SRID)");
          } else this.isLittleEndian_ = i, this.hasZ_ = o, this.hasM_ = s, this.layout_ = h, this.srid_ = c, this.initialized_ = true;
          return u;
        }
        readWkbPayload(t) {
          switch (t) {
            case We.POINT:
              return this.readPoint();
            case We.LINE_STRING:
              return this.readLineString();
            case We.POLYGON:
            case We.TRIANGLE:
              return this.readPolygon();
            case We.MULTI_POINT:
              return this.readMultiPoint();
            case We.MULTI_LINE_STRING:
              return this.readMultiLineString();
            case We.MULTI_POLYGON:
            case We.POLYHEDRAL_SURFACE:
            case We.TIN:
              return this.readMultiPolygon();
            case We.GEOMETRY_COLLECTION:
              return this.readGeometryCollection();
            default:
              throw new Error("Unsupported WKB geometry type " + t + " is found");
          }
        }
        readWkbBlock(t) {
          return this.readWkbPayload(this.readWkbHeader(t));
        }
        readWkbCollection(t, e) {
          const i = this.readUint32(), r = [];
          for (let a = 0; a < i; a++) {
            const o = t.call(this, e);
            o && r.push(o);
          }
          return r;
        }
        readMultiPoint() {
          return this.readWkbCollection(this.readWkbBlock, We.POINT);
        }
        readMultiLineString() {
          return this.readWkbCollection(this.readWkbBlock, We.LINE_STRING);
        }
        readMultiPolygon() {
          return this.readWkbCollection(this.readWkbBlock, We.POLYGON);
        }
        readGeometryCollection() {
          return this.readWkbCollection(this.readGeometry);
        }
        readGeometry() {
          const t = this.readWkbHeader(), e = this.readWkbPayload(t);
          switch (t) {
            case We.POINT:
              return new Oe(e, this.layout_);
            case We.LINE_STRING:
              return new be(e, this.layout_);
            case We.POLYGON:
            case We.TRIANGLE:
              return new Sn(e, this.layout_);
            case We.MULTI_POINT:
              return new sr(e, this.layout_);
            case We.MULTI_LINE_STRING:
              return new ri(e, this.layout_);
            case We.MULTI_POLYGON:
            case We.POLYHEDRAL_SURFACE:
            case We.TIN:
              return new Ci(e, this.layout_);
            case We.GEOMETRY_COLLECTION:
              return new yn(e);
            default:
              return null;
          }
        }
        getSrid() {
          return this.srid_;
        }
      }
      class ldt {
        constructor(t) {
          t = t || {}, this.layout_ = t.layout, this.isLittleEndian_ = t.littleEndian !== false, this.isEWKB_ = t.ewkb !== false, this.writeQueue_ = [], this.nodata_ = Object.assign({ X: 0, Y: 0, Z: 0, M: 0 }, t.nodata);
        }
        writeUint8(t) {
          this.writeQueue_.push([1, t]);
        }
        writeUint32(t) {
          this.writeQueue_.push([4, t]);
        }
        writeDouble(t) {
          this.writeQueue_.push([8, t]);
        }
        writePoint(t, e) {
          const i = Object.assign.apply(null, e.split("").map((r, a) => ({ [r]: t[a] })));
          for (const r of this.layout_) this.writeDouble(r in i ? i[r] : this.nodata_[r]);
        }
        writeLineString(t, e) {
          this.writeUint32(t.length);
          for (let i = 0; i < t.length; i++) this.writePoint(t[i], e);
        }
        writePolygon(t, e) {
          this.writeUint32(t.length);
          for (let i = 0; i < t.length; i++) this.writeLineString(t[i], e);
        }
        writeWkbHeader(t, e) {
          t %= 1e3, this.layout_.includes("Z") && (t += this.isEWKB_ ? 2147483648 : 1e3), this.layout_.includes("M") && (t += this.isEWKB_ ? 1073741824 : 2e3), this.isEWKB_ && Number.isInteger(e) && (t |= 536870912), this.writeUint8(this.isLittleEndian_ ? 1 : 0), this.writeUint32(t), this.isEWKB_ && Number.isInteger(e) && this.writeUint32(e);
        }
        writeMultiPoint(t, e) {
          this.writeUint32(t.length);
          for (let i = 0; i < t.length; i++) this.writeWkbHeader(1), this.writePoint(t[i], e);
        }
        writeMultiLineString(t, e) {
          this.writeUint32(t.length);
          for (let i = 0; i < t.length; i++) this.writeWkbHeader(2), this.writeLineString(t[i], e);
        }
        writeMultiPolygon(t, e) {
          this.writeUint32(t.length);
          for (let i = 0; i < t.length; i++) this.writeWkbHeader(3), this.writePolygon(t[i], e);
        }
        writeGeometryCollection(t) {
          this.writeUint32(t.length);
          for (let e = 0; e < t.length; e++) this.writeGeometry(t[e]);
        }
        findMinimumLayout(t, e = "XYZM") {
          const i = (r, a) => r === a ? r : r === "XYZM" ? a : a === "XYZM" ? r : "XY";
          if (t instanceof Ra) return i(t.getLayout(), e);
          if (t instanceof yn) {
            const r = t.getGeometriesArray();
            for (let a = 0; a < r.length && e !== "XY"; a++) e = this.findMinimumLayout(r[a], e);
          }
          return e;
        }
        writeGeometry(t, e) {
          const i = { Point: We.POINT, LineString: We.LINE_STRING, Polygon: We.POLYGON, MultiPoint: We.MULTI_POINT, MultiLineString: We.MULTI_LINE_STRING, MultiPolygon: We.MULTI_POLYGON, GeometryCollection: We.GEOMETRY_COLLECTION }, r = t.getType(), a = i[r];
          if (!a) throw new Error("GeometryType " + r + " is not supported");
          this.layout_ || (this.layout_ = this.findMinimumLayout(t)), this.writeWkbHeader(a, e), t instanceof Ra ? { Point: this.writePoint, LineString: this.writeLineString, Polygon: this.writePolygon, MultiPoint: this.writeMultiPoint, MultiLineString: this.writeMultiLineString, MultiPolygon: this.writeMultiPolygon }[r].call(this, t.getCoordinates(), t.getLayout()) : t instanceof yn && this.writeGeometryCollection(t.getGeometriesArray());
        }
        getBuffer() {
          const t = this.writeQueue_.reduce((a, o) => a + o[0], 0), e = new ArrayBuffer(t), i = new DataView(e);
          let r = 0;
          return this.writeQueue_.forEach((a) => {
            switch (a[0]) {
              case 1:
                i.setUint8(r, a[1]);
                break;
              case 4:
                i.setUint32(r, a[1], this.isLittleEndian_);
                break;
              case 8:
                i.setFloat64(r, a[1], this.isLittleEndian_);
                break;
            }
            r += a[0];
          }), e;
        }
      }
      class udt extends qA {
        constructor(t) {
          super(), t = t || {}, this.splitCollection = !!t.splitCollection, this.viewCache_ = null, this.hex_ = t.hex !== false, this.littleEndian_ = t.littleEndian !== false, this.ewkb_ = t.ewkb !== false, this.layout_ = t.geometryLayout, this.nodataZ_ = t.nodataZ || 0, this.nodataM_ = t.nodataM || 0, this.srid_ = t.srid;
        }
        getType() {
          return this.hex_ ? "text" : "arraybuffer";
        }
        readFeature(t, e) {
          return new xe({ geometry: this.readGeometry(t, e) });
        }
        readFeatures(t, e) {
          let i = [];
          const r = this.readGeometry(t, e);
          return this.splitCollection && r instanceof yn ? i = r.getGeometriesArray() : i = [r], i.map((a) => new xe({ geometry: a }));
        }
        readGeometry(t, e) {
          const i = jO(t);
          if (!i) return null;
          const a = new VO(i).readGeometry();
          return this.viewCache_ = i, e = this.getReadOptions(t, e), this.viewCache_ = null, sn(a, false, e);
        }
        readProjection(t) {
          const e = this.viewCache_ || jO(t);
          if (!e) return;
          const i = new VO(e);
          return i.readWkbHeader(), i.getSrid() && Vt("EPSG:" + i.getSrid()) || void 0;
        }
        writeFeature(t, e) {
          return this.writeGeometry(t.getGeometry(), e);
        }
        writeFeatures(t, e) {
          return this.writeGeometry(new yn(t.map((i) => i.getGeometry())), e);
        }
        writeGeometry(t, e) {
          e = this.adaptOptions(e);
          const i = new ldt({ layout: this.layout_, littleEndian: this.littleEndian_, ewkb: this.ewkb_, nodata: { Z: this.nodataZ_, M: this.nodataM_ } });
          let r = Number.isInteger(this.srid_) ? Number(this.srid_) : null;
          if (this.srid_ !== false && !Number.isInteger(this.srid_)) {
            const o = e.dataProjection && Vt(e.dataProjection);
            if (o) {
              const s = o.getCode();
              s.startsWith("EPSG:") && (r = Number(s.substring(5)));
            }
          }
          i.writeGeometry(sn(t, true, e), r);
          const a = i.getBuffer();
          return this.hex_ ? hdt(a) : a;
        }
      }
      function hdt(n) {
        const t = new Uint8Array(n);
        return Array.from(t.values()).map((e) => (e < 16 ? "0" : "") + Number(e).toString(16).toUpperCase()).join("");
      }
      function cdt(n) {
        const t = new Uint8Array(n.length / 2);
        for (let e = 0; e < n.length / 2; e++) t[e] = parseInt(n.substr(e * 2, 2), 16);
        return new DataView(t.buffer);
      }
      function jO(n) {
        return typeof n == "string" ? cdt(n) : ArrayBuffer.isView(n) ? n instanceof DataView ? n : new DataView(n.buffer, n.byteOffset, n.byteLength) : n instanceof ArrayBuffer ? new DataView(n) : null;
      }
      const fdt = { POINT: Oe, LINESTRING: be, POLYGON: Sn, MULTIPOINT: sr, MULTILINESTRING: ri, MULTIPOLYGON: Ci }, qO = "EMPTY", HO = "Z", YO = "M", gdt = "ZM", Ue = { START: 0, TEXT: 1, LEFT_PAREN: 2, RIGHT_PAREN: 3, NUMBER: 4, COMMA: 5, EOF: 6 }, ddt = { Point: "POINT", LineString: "LINESTRING", Polygon: "POLYGON", MultiPoint: "MULTIPOINT", MultiLineString: "MULTILINESTRING", MultiPolygon: "MULTIPOLYGON", GeometryCollection: "GEOMETRYCOLLECTION", Circle: "CIRCLE" };
      class Adt {
        constructor(t) {
          this.wkt = t, this.index_ = -1;
        }
        isAlpha_(t) {
          return t >= "a" && t <= "z" || t >= "A" && t <= "Z";
        }
        isNumeric_(t, e) {
          return e = e !== void 0 ? e : false, t >= "0" && t <= "9" || t == "." && !e;
        }
        isWhiteSpace_(t) {
          return t == " " || t == "	" || t == "\r" || t == `
`;
        }
        nextChar_() {
          return this.wkt.charAt(++this.index_);
        }
        nextToken() {
          const t = this.nextChar_(), e = this.index_;
          let i = t, r;
          if (t == "(") r = Ue.LEFT_PAREN;
          else if (t == ",") r = Ue.COMMA;
          else if (t == ")") r = Ue.RIGHT_PAREN;
          else if (this.isNumeric_(t) || t == "-") r = Ue.NUMBER, i = this.readNumber_();
          else if (this.isAlpha_(t)) r = Ue.TEXT, i = this.readText_();
          else {
            if (this.isWhiteSpace_(t)) return this.nextToken();
            if (t === "") r = Ue.EOF;
            else throw new Error("Unexpected character: " + t);
          }
          return { position: e, value: i, type: r };
        }
        readNumber_() {
          let t;
          const e = this.index_;
          let i = false, r = false;
          do
            t == "." ? i = true : (t == "e" || t == "E") && (r = true), t = this.nextChar_();
          while (this.isNumeric_(t, i) || !r && (t == "e" || t == "E") || r && (t == "-" || t == "+"));
          return parseFloat(this.wkt.substring(e, this.index_--));
        }
        readText_() {
          let t;
          const e = this.index_;
          do
            t = this.nextChar_();
          while (this.isAlpha_(t));
          return this.wkt.substring(e, this.index_--).toUpperCase();
        }
      }
      class pdt {
        constructor(t) {
          this.lexer_ = t, this.token_ = { position: 0, type: Ue.START }, this.layout_ = "XY";
        }
        consume_() {
          this.token_ = this.lexer_.nextToken();
        }
        isTokenType(t) {
          return this.token_.type == t;
        }
        match(t) {
          const e = this.isTokenType(t);
          return e && this.consume_(), e;
        }
        parse() {
          return this.consume_(), this.parseGeometry_();
        }
        parseGeometryLayout_() {
          let t = "XY";
          const e = this.token_;
          if (this.isTokenType(Ue.TEXT)) {
            const i = e.value;
            i === HO ? t = "XYZ" : i === YO ? t = "XYM" : i === gdt && (t = "XYZM"), t !== "XY" && this.consume_();
          }
          return t;
        }
        parseGeometryCollectionText_() {
          if (this.match(Ue.LEFT_PAREN)) {
            const t = [];
            do
              t.push(this.parseGeometry_());
            while (this.match(Ue.COMMA));
            if (this.match(Ue.RIGHT_PAREN)) return t;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parsePointText_() {
          if (this.match(Ue.LEFT_PAREN)) {
            const t = this.parsePoint_();
            if (this.match(Ue.RIGHT_PAREN)) return t;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parseLineStringText_() {
          if (this.match(Ue.LEFT_PAREN)) {
            const t = this.parsePointList_();
            if (this.match(Ue.RIGHT_PAREN)) return t;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parsePolygonText_() {
          if (this.match(Ue.LEFT_PAREN)) {
            const t = this.parseLineStringTextList_();
            if (this.match(Ue.RIGHT_PAREN)) return t;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parseMultiPointText_() {
          if (this.match(Ue.LEFT_PAREN)) {
            let t;
            if (this.token_.type == Ue.LEFT_PAREN ? t = this.parsePointTextList_() : t = this.parsePointList_(), this.match(Ue.RIGHT_PAREN)) return t;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parseMultiLineStringText_() {
          if (this.match(Ue.LEFT_PAREN)) {
            const t = this.parseLineStringTextList_();
            if (this.match(Ue.RIGHT_PAREN)) return t;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parseMultiPolygonText_() {
          if (this.match(Ue.LEFT_PAREN)) {
            const t = this.parsePolygonTextList_();
            if (this.match(Ue.RIGHT_PAREN)) return t;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parsePoint_() {
          const t = [], e = this.layout_.length;
          for (let i = 0; i < e; ++i) {
            const r = this.token_;
            if (this.match(Ue.NUMBER)) t.push(r.value);
            else break;
          }
          if (t.length == e) return t;
          throw new Error(this.formatErrorMessage_());
        }
        parsePointList_() {
          const t = [this.parsePoint_()];
          for (; this.match(Ue.COMMA); ) t.push(this.parsePoint_());
          return t;
        }
        parsePointTextList_() {
          const t = [this.parsePointText_()];
          for (; this.match(Ue.COMMA); ) t.push(this.parsePointText_());
          return t;
        }
        parseLineStringTextList_() {
          const t = [this.parseLineStringText_()];
          for (; this.match(Ue.COMMA); ) t.push(this.parseLineStringText_());
          return t;
        }
        parsePolygonTextList_() {
          const t = [this.parsePolygonText_()];
          for (; this.match(Ue.COMMA); ) t.push(this.parsePolygonText_());
          return t;
        }
        isEmptyGeometry_() {
          const t = this.isTokenType(Ue.TEXT) && this.token_.value == qO;
          return t && this.consume_(), t;
        }
        formatErrorMessage_() {
          return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
        }
        parseGeometry_() {
          const t = this.token_;
          if (this.match(Ue.TEXT)) {
            const e = t.value;
            this.layout_ = this.parseGeometryLayout_();
            const i = this.isEmptyGeometry_();
            if (e == "GEOMETRYCOLLECTION") {
              if (i) return new yn([]);
              const o = this.parseGeometryCollectionText_();
              return new yn(o);
            }
            const r = fdt[e];
            if (!r) throw new Error("Invalid geometry type: " + e);
            let a;
            if (i) e == "POINT" ? a = [NaN, NaN] : a = [];
            else switch (e) {
              case "POINT": {
                a = this.parsePointText_();
                break;
              }
              case "LINESTRING": {
                a = this.parseLineStringText_();
                break;
              }
              case "POLYGON": {
                a = this.parsePolygonText_();
                break;
              }
              case "MULTIPOINT": {
                a = this.parseMultiPointText_();
                break;
              }
              case "MULTILINESTRING": {
                a = this.parseMultiLineStringText_();
                break;
              }
              case "MULTIPOLYGON": {
                a = this.parseMultiPolygonText_();
                break;
              }
            }
            return new r(a, this.layout_);
          }
          throw new Error(this.formatErrorMessage_());
        }
      }
      class vdt extends jC {
        constructor(t) {
          super(), t = t || {}, this.splitCollection_ = t.splitCollection !== void 0 ? t.splitCollection : false;
        }
        parse_(t) {
          const e = new Adt(t);
          return new pdt(e).parse();
        }
        readFeatureFromText(t, e) {
          const i = this.readGeometryFromText(t, e), r = new xe();
          return r.setGeometry(i), r;
        }
        readFeaturesFromText(t, e) {
          let i = [];
          const r = this.readGeometryFromText(t, e);
          this.splitCollection_ && r.getType() == "GeometryCollection" ? i = r.getGeometriesArray() : i = [r];
          const a = [];
          for (let o = 0, s = i.length; o < s; ++o) {
            const l = new xe();
            l.setGeometry(i[o]), a.push(l);
          }
          return a;
        }
        readGeometryFromText(t, e) {
          const i = this.parse_(t);
          return sn(i, false, e);
        }
        writeFeatureText(t, e) {
          const i = t.getGeometry();
          return i ? this.writeGeometryText(i, e) : "";
        }
        writeFeaturesText(t, e) {
          if (t.length == 1) return this.writeFeatureText(t[0], e);
          const i = [];
          for (let a = 0, o = t.length; a < o; ++a) i.push(t[a].getGeometry());
          const r = new yn(i);
          return this.writeGeometryText(r, e);
        }
        writeGeometryText(t, e) {
          return ZO(sn(t, true, e));
        }
      }
      function WO(n) {
        const t = n.getCoordinates();
        return t.length === 0 ? "" : t.join(" ");
      }
      function ydt(n) {
        const t = [], e = n.getPoints();
        for (let i = 0, r = e.length; i < r; ++i) t.push("(" + WO(e[i]) + ")");
        return t.join(",");
      }
      function mdt(n) {
        const t = [], e = n.getGeometries();
        for (let i = 0, r = e.length; i < r; ++i) t.push(ZO(e[i]));
        return t.join(",");
      }
      function cS(n) {
        const t = n.getCoordinates(), e = [];
        for (let i = 0, r = t.length; i < r; ++i) e.push(t[i].join(" "));
        return e.join(",");
      }
      function _dt(n) {
        const t = [], e = n.getLineStrings();
        for (let i = 0, r = e.length; i < r; ++i) t.push("(" + cS(e[i]) + ")");
        return t.join(",");
      }
      function XO(n) {
        const t = [], e = n.getLinearRings();
        for (let i = 0, r = e.length; i < r; ++i) t.push("(" + cS(e[i]) + ")");
        return t.join(",");
      }
      function Idt(n) {
        const t = [], e = n.getPolygons();
        for (let i = 0, r = e.length; i < r; ++i) t.push("(" + XO(e[i]) + ")");
        return t.join(",");
      }
      function Edt(n) {
        const t = n.getLayout();
        let e = "";
        return (t === "XYZ" || t === "XYZM") && (e += HO), (t === "XYM" || t === "XYZM") && (e += YO), e;
      }
      const xdt = { Point: WO, LineString: cS, Polygon: XO, MultiPoint: ydt, MultiLineString: _dt, MultiPolygon: Idt, GeometryCollection: mdt };
      function ZO(n) {
        const t = n.getType(), e = xdt[t], i = e(n);
        let r = ddt[t];
        if (typeof n.getFlatCoordinates == "function") {
          const a = Edt(n);
          a.length > 0 && (r += " " + a);
        }
        return i.length === 0 ? r + " " + qO : r + "(" + i + ")";
      }
      const On = [null, "http://www.opengis.net/wms"];
      function Wf(n) {
        return Vy(n[0].version, "1.3") >= 0;
      }
      const wdt = K(On, { Service: O(Ydt), Capability: O(Hdt) }), KO = { Request: O(nAt), Exception: O(Kdt), Layer: O($dt) }, Cdt = K(On, zt(st({}, KO), { UserDefinedSymbolization: O(jdt) })), Sdt = K(On, KO);
      class bdt extends iS {
        constructor() {
          super(), this.version = void 0;
        }
        readFromNode(t) {
          this.version = t.getAttribute("version").trim();
          const e = rt({ version: this.version }, wdt, t, []);
          return e || null;
        }
      }
      const $O = { Name: O(at), Title: O(at), Abstract: O(at), KeywordList: O(r3), OnlineResource: O(Hf), ContactInformation: O(Wdt), Fees: O(at), AccessConstraints: O(at) }, Bdt = K(On, $O), Tdt = K(On, zt(st({}, $O), { LayerLimit: O(mn), MaxWidth: O(mn), MaxHeight: O(mn) })), Mdt = K(On, { ContactPersonPrimary: O(Xdt), ContactPosition: O(at), ContactAddress: O(Zdt), ContactVoiceTelephone: O(at), ContactFacsimileTelephone: O(at), ContactElectronicMailAddress: O(at) }), Ddt = K(On, { ContactPerson: O(at), ContactOrganization: O(at) }), Rdt = K(On, { AddressType: O(at), Address: O(at), City: O(at), StateOrProvince: O(at), PostCode: O(at), Country: O(at) }), Ldt = K(On, { Format: Tt(at) }), JO = { Name: O(at), Title: O(at), Abstract: O(at), KeywordList: O(r3), BoundingBox: Ge(n3), Dimension: Ge(Jdt), Attribution: O(Vdt), AuthorityURL: Ge(aAt), Identifier: Ge(at), MetadataURL: Ge(oAt), DataURL: Ge(Es), FeatureListURL: Ge(Es), Style: Ge(sAt), Layer: Ge(Vm) }, t3 = K(On, zt(st({}, JO), { SRS: Ge(at), Extent: O(tAt), ScaleHint: Ge(eAt), LatLonBoundingBox: O((n, t) => n3(n, t, false)), Layer: Ge(Vm) })), e3 = K(On, zt(st({}, JO), { CRS: Ge(at), EX_GeographicBoundingBox: O(qdt), MinScaleDenominator: O(me), MaxScaleDenominator: O(me), Layer: Ge(Vm) })), Pdt = K(On, { Title: O(at), OnlineResource: O(Hf), LogoURL: O(i3) }), Ndt = K(On, { westBoundLongitude: O(me), eastBoundLongitude: O(me), southBoundLatitude: O(me), northBoundLatitude: O(me) }), kdt = K(On, { GetCapabilities: O(fS), GetMap: O(fS), GetFeatureInfo: O(fS) }), Fdt = K(On, { Format: Ge(at), DCPType: Ge(iAt) }), Qdt = K(On, { HTTP: O(rAt) }), Odt = K(On, { Get: O(Es), Post: O(Es) }), zdt = K(On, { Name: O(at), Title: O(at), Abstract: O(at), LegendURL: Ge(i3), StyleSheetURL: O(Es), StyleURL: O(Es) }), Gdt = K(On, { Format: O(at), OnlineResource: O(Hf) }), Udt = K(On, { Keyword: Tt(at) });
      function Vdt(n, t) {
        return rt({}, Pdt, n, t);
      }
      function jdt(n, t) {
        return { SupportSLD: !!na(n.getAttribute("UserDefinedSymbolization")), UserLayer: !!na(n.getAttribute("UserLayer")), UserStyle: !!na(n.getAttribute("UserStyle")), RemoteWFS: !!na(n.getAttribute("RemoteWFS")) };
      }
      function n3(n, t, e = true) {
        const i = [Qa(n.getAttribute("minx")), Qa(n.getAttribute("miny")), Qa(n.getAttribute("maxx")), Qa(n.getAttribute("maxy"))], r = [Qa(n.getAttribute("resx")), Qa(n.getAttribute("resy"))], a = { extent: i, res: r };
        return e && (Wf(t) ? a.crs = n.getAttribute("CRS") : a.srs = n.getAttribute("SRS")), a;
      }
      function qdt(n, t) {
        const e = rt({}, Ndt, n, t);
        if (!e) return;
        const i = e.westBoundLongitude, r = e.southBoundLatitude, a = e.eastBoundLongitude, o = e.northBoundLatitude;
        if (!(i === void 0 || r === void 0 || a === void 0 || o === void 0)) return [i, r, a, o];
      }
      function Hdt(n, t) {
        return rt({}, Wf(t) ? Sdt : Cdt, n, t);
      }
      function Ydt(n, t) {
        return rt({}, Wf(t) ? Tdt : Bdt, n, t);
      }
      function Wdt(n, t) {
        return rt({}, Mdt, n, t);
      }
      function Xdt(n, t) {
        return rt({}, Ddt, n, t);
      }
      function Zdt(n, t) {
        return rt({}, Rdt, n, t);
      }
      function Kdt(n, t) {
        return rt([], Ldt, n, t);
      }
      function $dt(n, t) {
        const e = rt({}, Wf(t) ? e3 : t3, n, t);
        return e.Layer === void 0 ? Object.assign(e, Vm(n, t)) : e;
      }
      function Vm(n, t) {
        const e = Wf(t), i = t[t.length - 1], r = rt({}, e ? e3 : t3, n, t);
        if (!r) return;
        let a = na(n.getAttribute("queryable"));
        a === void 0 && (a = i.queryable), r.queryable = a !== void 0 ? a : false;
        let o = _s(n.getAttribute("cascaded"));
        o === void 0 && (o = i.cascaded), r.cascaded = o;
        let s = na(n.getAttribute("opaque"));
        s === void 0 && (s = i.opaque), r.opaque = s !== void 0 ? s : false;
        let l = na(n.getAttribute("noSubsets"));
        l === void 0 && (l = i.noSubsets), r.noSubsets = l !== void 0 ? l : false;
        let u = Qa(n.getAttribute("fixedWidth"));
        u || (u = i.fixedWidth), r.fixedWidth = u;
        let h = Qa(n.getAttribute("fixedHeight"));
        h || (h = i.fixedHeight), r.fixedHeight = h;
        const c = ["Style", "AuthorityURL"];
        e ? c.push("CRS") : c.push("SRS", "Dimension"), c.forEach(function(g) {
          if (g in i) {
            const d = r[g] || [];
            r[g] = d.concat(i[g]);
          }
        });
        const f = ["BoundingBox", "Attribution"];
        return e ? f.push("Dimension", "EX_GeographicBoundingBox", "MinScaleDenominator", "MaxScaleDenominator") : f.push("LatLonBoundingBox", "ScaleHint", "Extent"), f.forEach(function(g) {
          if (!(g in r)) {
            const d = i[g];
            r[g] = d;
          }
        }), r;
      }
      function Jdt(n, t) {
        const e = { name: n.getAttribute("name"), units: n.getAttribute("units"), unitSymbol: n.getAttribute("unitSymbol") };
        return Wf(t) && Object.assign(e, { default: n.getAttribute("default"), multipleValues: na(n.getAttribute("multipleValues")), nearestValue: na(n.getAttribute("nearestValue")), current: na(n.getAttribute("current")), values: at(n) }), e;
      }
      function tAt(n, t) {
        return { name: n.getAttribute("name"), default: n.getAttribute("default"), nearestValue: na(n.getAttribute("nearestValue")) };
      }
      function eAt(n, t) {
        return { min: Qa(n.getAttribute("min")), max: Qa(n.getAttribute("max")) };
      }
      function Es(n, t) {
        return rt({}, Gdt, n, t);
      }
      function nAt(n, t) {
        return rt({}, kdt, n, t);
      }
      function iAt(n, t) {
        return rt({}, Qdt, n, t);
      }
      function rAt(n, t) {
        return rt({}, Odt, n, t);
      }
      function fS(n, t) {
        return rt({}, Fdt, n, t);
      }
      function i3(n, t) {
        const e = Es(n, t);
        if (e) {
          const i = [_s(n.getAttribute("width")), _s(n.getAttribute("height"))];
          return e.size = i, e;
        }
      }
      function aAt(n, t) {
        const e = Es(n, t);
        if (e) return e.name = n.getAttribute("name"), e;
      }
      function oAt(n, t) {
        const e = Es(n, t);
        if (e) return e.type = n.getAttribute("type"), e;
      }
      function sAt(n, t) {
        return rt({}, zdt, n, t);
      }
      function r3(n, t) {
        return rt([], Udt, n, t);
      }
      const lAt = "_feature", uAt = "_layer";
      class hAt extends YA {
        constructor(t) {
          super(), t = t || {}, this.featureNS_ = "http://mapserver.gis.umn.edu/mapserver", this.gmlFormat_ = new Ae(), this.layers_ = t.layers ? t.layers : null;
        }
        getLayers() {
          return this.layers_;
        }
        setLayers(t) {
          this.layers_ = t;
        }
        readFeatures_(t, e) {
          t.setAttribute("namespaceURI", this.featureNS_);
          const i = t.localName;
          let r = [];
          if (t.childNodes.length === 0) return r;
          if (i == "msGMLOutput") for (let a = 0, o = t.childNodes.length; a < o; a++) {
            const s = t.childNodes[a];
            if (s.nodeType !== Node.ELEMENT_NODE) continue;
            const l = s, u = e[0], h = uAt, c = l.localName.replace(h, "");
            if (this.layers_ && !this.layers_.includes(c)) continue;
            const f = c + lAt;
            u.featureType = f, u.featureNS = this.featureNS_;
            const g = {};
            g[f] = Tt(this.gmlFormat_.readFeatureElement, this.gmlFormat_);
            const d = K([u.featureNS, null], g);
            l.setAttribute("namespaceURI", this.featureNS_);
            const A = rt([], d, l, e, this.gmlFormat_);
            A && De(r, A);
          }
          if (i == "FeatureCollection") {
            const a = rt([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, t, [{}], this.gmlFormat_);
            a && (r = a);
          }
          return r;
        }
        readFeaturesFromNode(t, e) {
          const i = {};
          return e && Object.assign(i, this.getReadOptions(t, e)), this.readFeatures_(t, [i]);
        }
      }
      const Io = [null, "http://www.opengis.net/wmts/1.0"], Xf = [null, "http://www.opengis.net/ows/1.1"], cAt = K(Io, { Contents: O(EAt) });
      class fAt extends iS {
        constructor() {
          super(), this.owsParser_ = new AO();
        }
        readFromNode(t) {
          let e = t.getAttribute("version");
          e && (e = e.trim());
          let i = this.owsParser_.readFromNode(t);
          return i ? (i.version = e, i = rt(i, cAt, t, []), i || null) : null;
        }
      }
      const gAt = K(Io, { Layer: Ge(xAt), TileMatrixSet: Ge(wAt) }), dAt = K(Io, { Style: Ge(CAt), Format: Ge(at), TileMatrixSetLink: Ge(SAt), Dimension: Ge(bAt), ResourceURL: Ge(BAt) }, K(Xf, { Title: O(at), Abstract: O(at), WGS84BoundingBox: O(o3), BoundingBox: Ge(TAt), Identifier: O(at) })), AAt = K(Io, { LegendURL: Ge(MAt) }, K(Xf, { Title: O(at), Identifier: O(at) })), pAt = K(Io, { TileMatrixSet: O(at), TileMatrixSetLimits: O(RAt) }), vAt = K(Io, { TileMatrixLimits: Tt(LAt) }), yAt = K(Io, { TileMatrix: O(at), MinTileRow: O(mn), MaxTileRow: O(mn), MinTileCol: O(mn), MaxTileCol: O(mn) }), mAt = K(Io, { Default: O(at), Value: Ge(at) }, K(Xf, { Identifier: O(at) })), a3 = K(Xf, { LowerCorner: Tt(gS), UpperCorner: Tt(gS) }), _At = K(Io, { WellKnownScaleSet: O(at), TileMatrix: Ge(DAt) }, K(Xf, { SupportedCRS: O(at), Identifier: O(at), BoundingBox: O(o3) })), IAt = K(Io, { TopLeftCorner: O(gS), ScaleDenominator: O(me), TileWidth: O(mn), TileHeight: O(mn), MatrixWidth: O(mn), MatrixHeight: O(mn) }, K(Xf, { Identifier: O(at) }));
      function EAt(n, t) {
        return rt({}, gAt, n, t);
      }
      function xAt(n, t) {
        return rt({}, dAt, n, t);
      }
      function wAt(n, t) {
        return rt({}, _At, n, t);
      }
      function CAt(n, t) {
        const e = rt({}, AAt, n, t);
        if (!e) return;
        const i = n.getAttribute("isDefault") === "true";
        return e.isDefault = i, e;
      }
      function SAt(n, t) {
        return rt({}, pAt, n, t);
      }
      function bAt(n, t) {
        return rt({}, mAt, n, t);
      }
      function BAt(n, t) {
        const e = n.getAttribute("format"), i = n.getAttribute("template"), r = n.getAttribute("resourceType"), a = {};
        return e && (a.format = e), i && (a.template = i), r && (a.resourceType = r), a;
      }
      function o3(n, t) {
        const e = rt([], a3, n, t);
        if (e.length == 2) return Vn(e);
      }
      function TAt(n, t) {
        const e = n.getAttribute("crs"), i = rt([], a3, n, t);
        if (i.length == 2) return { extent: Vn(i), crs: e };
      }
      function MAt(n, t) {
        const e = {};
        return e.format = n.getAttribute("format"), e.href = Hf(n), e;
      }
      function gS(n, t) {
        const e = at(n).split(/\s+/);
        if (!e || e.length != 2) return;
        const i = +e[0], r = +e[1];
        if (!(isNaN(i) || isNaN(r))) return [i, r];
      }
      function DAt(n, t) {
        return rt({}, IAt, n, t);
      }
      function RAt(n, t) {
        return rt([], vAt, n, t);
      }
      function LAt(n, t) {
        return rt({}, yAt, n, t);
      }
      const PAt = Object.freeze(Object.defineProperty({ __proto__: null, EsriJSON: put, GML: OC, GPX: lht, GeoJSON: zf, IGC: jht, IIIFInfo: Flt, KML: tct, MVT: Hft, OWS: AO, Polyline: bgt, TopoJSON: Fgt, WFS: xO, WKB: udt, WKT: vdt, WMSCapabilities: bdt, WMSGetFeatureInfo: hAt, WMTSCapabilities: fAt }, Symbol.toStringTag, { value: "Module" })), NAt = (n) => {
        if (!n) return new Mr({ radius: 2 });
        const t = { radius: n.radius || 2, fill: new ye(n.fill || { color: "blue" }), stroke: new Ze(n.stroke || { color: "white" }) };
        return new Mr(t);
      }, kAt = (n) => {
        const t = st({ font: "14px sans-serif", padding: [2, 5, 2, 5] }, n), e = new Ei(t);
        if (n.text && e.setText(n.text), Tn(n, "fill")) {
          const i = new ye(n.fill);
          e.setFill(i);
        }
        if (Tn(n, "backgroundFill")) {
          const i = new ye(n.backgroundFill);
          e.setBackgroundFill(i);
        }
        if (Tn(n, "stroke")) {
          const i = new Ze(n.stroke);
          e.setStroke(i);
        }
        if (Tn(n, "backgroundStroke")) {
          const i = new Ze(n.backgroundStroke);
          e.setBackgroundStroke(i);
        }
        return e;
      }, Wu = (n) => {
        var e, i;
        const t = new de();
        if (Tn(n, "fill") ? t.setFill(new ye(n.fill)) : t.setFill(new ye({ color: "rgba(67,126,255,0.15)" })), Tn(n, "stroke") ? t.setStroke(new Ze(n.stroke)) : t.setStroke(new Ze({ color: "rgba(67,126,255,1)", width: 1 })), Tn(n, "icon") && t.setImage(new Rr(n.icon)), Tn(n, "circle")) {
          const r = NAt(n.circle);
          t.setImage(r);
        }
        if (Tn(n, "text")) {
          const r = n.text;
          if (r) {
            const a = kAt(r);
            t.setText(a);
          }
        }
        if (Tn(n, "shape")) {
          let r, a;
          if (Tn(n.shape, "fill") && (r = new ye((e = n.shape) == null ? void 0 : e.fill)), Tn(n.shape, "stroke") && (a = new Ze((i = n.shape) == null ? void 0 : i.stroke)), n.shape) {
            const o = zt(st({}, n.shape), { stroke: a, fill: r }), s = new Nu(o);
            t.setImage(s);
          }
        }
        return t;
      }, jm = (n, t, e) => {
        const i = Wu(t);
        n.setStyle(i), Tn(t, "styleFunction") ? n.setStyle(function(r, a) {
          return t.styleFunction && t.styleFunction(r, a, e, i);
        }) : n.setStyle(i);
      }, qm = N.defineComponent({ name: "OlVector", __name: "index", props: { layerId: { default: `vector-layer-${qu()}` }, source: { default: void 0 }, layerStyle: { default: () => OF() }, featureStyle: { default: void 0 }, modify: { type: Boolean, default: false }, className: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, renderOrder: {}, renderBuffer: {}, map: {}, declutter: { type: [String, Number, Boolean] }, background: {}, updateWhileAnimating: { type: Boolean }, updateWhileInteracting: { type: Boolean }, properties: {} }, emits: ["singleclick", "pointermove", "sourceready", "featuresloadend", "featuresloadstart", "addfeature", "modifyend", "modifystart", "change"], setup(n, { expose: t, emit: e }) {
        const i = n, r = N.inject("VMap"), a = N.unref(r).map;
        let o = N.shallowRef(), s = N.shallowRef(), l = N.ref([]);
        const u = ["singleclick", "pointermove"], h = e;
        let c = N.ref(false), f = N.shallowRef(void 0);
        N.provide("ParentLayer", o), N.watchEffect(() => {
          Dl(o.value, i);
        }), N.watch(() => i.visible, (w) => {
          var C;
          o.value && ((C = f.value) == null || C.setActive(w));
        }), N.watch(() => i.layerStyle, (w) => {
          var C;
          (C = o.value) == null || C.setStyle(w);
        }, { deep: true }), N.watch(() => i.source, () => {
          var w;
          (w = s.value) == null || w.clear(), o.value && a.removeLayer(o.value), v();
        });
        const g = a.getView().getProjection().getMetersPerUnit(), d = (w) => {
          w.on("modifyend", (C) => {
            h("modifyend", zt(st({}, C), { metersPerUnit: g }));
          }), w.on("modifystart", (C) => {
            h("modifystart", zt(st({}, C), { metersPerUnit: g }));
          });
        }, A = () => {
          o && i.modify && (f.value = new gw({ hitDetection: o.value, source: s.value }), a.addInteraction(f.value), d(f.value));
        }, p = () => {
          var w, C, S, b, B, T, D, R, L, k, P, F, Q, z, j, $, G, tt;
          if ((w = i.source) != null && w.featureFormat) {
            if ((C = i.source) != null && C.url && (((S = i.source) == null ? void 0 : S.featureFormat) === "GeoJSON" || ((b = i.source) == null ? void 0 : b.featureFormat) === "EsriJSON" || ((B = i.source) == null ? void 0 : B.featureFormat) === "TopoJSON")) {
              let J = { dataProjection: void 0, featureProjection: void 0 };
              return ((D = (T = i.source) == null ? void 0 : T.formatOptions) != null && D.dataProjection || (L = (R = i.source) == null ? void 0 : R.formatOptions) != null && L.featureProjection) && ((P = (k = i.source) == null ? void 0 : k.formatOptions) != null && P.dataProjection && (J.dataProjection = new rr((Q = (F = i.source) == null ? void 0 : F.formatOptions) == null ? void 0 : Q.dataProjection)), (j = (z = i.source) == null ? void 0 : z.formatOptions) != null && j.featureProjection && (J.featureProjection = new rr((G = ($ = i.source) == null ? void 0 : $.formatOptions) == null ? void 0 : G.featureProjection))), new $r({ url: i.source.url, format: new PAt[(tt = i.source) == null ? void 0 : tt.featureFormat](st(st({}, i.source.formatOptions), J)) });
            }
          } else return new $r(i.source);
        }, v = () => {
          var C;
          s.value = p(), (C = s.value) == null || C.on("addfeature", (S) => {
            h("addfeature", S);
          });
          const w = i.layerStyle;
          !w || Object.keys(w).length, i.featureStyle ? o.value = new Kr(zt(st({}, i), { source: s.value, style: (S) => jm(S, i.featureStyle, a) })) : o.value = new Kr(zt(st({}, i), { source: s.value, style: w })), o.value.set("id", i.layerId), a.addLayer(o.value), u.forEach((S) => {
            l.value.push(a.on(S, (b) => {
              y(S, b);
            }));
          }), o.value.on("sourceready", (S) => {
            c.value = true, h("sourceready", S);
          }), s.value && setTimeout(() => {
            A();
          }, 0);
        }, y = (w, C) => {
          const { pixel: S } = C, b = m(S);
          zt(st({}, C), { feature: b }), h(w, C, b);
        }, m = (w) => a.forEachFeatureAtPixel(w, (C) => C, { layerFilter: (C) => {
          var S;
          return C.get("id") === ((S = o.value) == null ? void 0 : S.get("id"));
        } }), _ = () => {
          l.value.forEach((w) => {
            rl(w);
          });
        }, E = (w) => {
          var C;
          return (C = s.value) == null ? void 0 : C.getFeatureById(w);
        };
        return t({ getFeatureById: E, removeFeatureById: (w) => {
          var S;
          const C = E(w);
          C && ((S = s.value) == null || S.removeFeature(C));
        }, getSource: () => s.value, getLayer: () => o.value }), N.onMounted(() => {
          v();
        }), N.onBeforeUnmount(() => {
          _();
        }), (w, C) => N.unref(c) ? N.renderSlot(w.$slots, "default", { key: 0 }) : N.createCommentVNode("", true);
      } }), FAt = (n) => n.component(qm.name || "OlVector", qm), QAt = Object.prototype.hasOwnProperty, Xu = typeof Symbol != "undefined" ? Symbol.toStringTag : void 0;
      function OAt(n) {
        if (n === null) return n === void 0 ? "[object Undefined]" : "[object Null]";
        if (!(Xu && Xu in Object(n))) return toString.call(n);
        const t = QAt.call(n, Xu), e = n[Xu];
        let i = false;
        try {
          n[Xu] = void 0, i = true;
        } catch (a) {
        }
        const r = Object.prototype.toString.call(n);
        return i && (t ? n[Xu] = e : delete n[Xu]), r;
      }
      function JA(n) {
        if (!zAt(n)) return false;
        const t = OAt(n);
        return t === "[object Function]" || t === "[object AsyncFunction]" || t === "[object GeneratorFunction]" || t === "[object Proxy]";
      }
      function zAt(n) {
        const t = typeof n;
        return n !== null && (t === "object" || t === "function");
      }
      function GAt(n) {
        return n == null ? false : typeof n == "string" || n.constructor !== null && n.constructor === String;
      }
      function dS(n) {
        return Object.prototype.toString.call(n) === "[object Number]" && !isNaN(n);
      }
      function UAt(n) {
        return Array.isArray(n);
      }
      function AS(n, ...t) {
        return Object.assign(n, ...t);
      }
      function yzt(n, t) {
      }
      const s3 = {};
      function VAt(n, t) {
        s3[t] || (s3[t] = true);
      }
      function jAt(n, t) {
        return n - t * Math.floor(n / t);
      }
      function Eo(n) {
        return n != null && !isNaN(n);
      }
      function qAt(n, t = {}) {
        let e, i;
        if (n.forEach(function(o) {
          switch (o.header.parameterCategory + "," + o.header.parameterNumber) {
            case "1,2":
            case "2,2":
              e = o;
              break;
            case "1,3":
            case "2,3":
              i = o;
              break;
          }
        }), !i || !e) return;
        const r = e.header;
        return new l3(st({ xmin: r.lo1, ymin: r.la1, xmax: r.lo2, ymax: r.la2, deltaX: r.dx, deltaY: r.dy, cols: r.nx, rows: r.ny, us: e.data, vs: i.data }, t));
      }
      class pS {
        constructor(t, e) {
          this.u = t, this.v = e, this.m = this.magnitude();
        }
        magnitude() {
          return Math.sqrt(_i(this.u, 2) + _i(this.v, 2));
        }
        directionTo() {
          let e = Math.atan2(this.u, this.v) * (180 / Math.PI);
          return e < 0 && (e += 360), e;
        }
        directionFrom() {
          return (this.directionTo() + 180) % 360;
        }
      }
      class l3 {
        constructor(t) {
          this.grid = [], this.xmin = t.xmin, this.xmax = t.xmax, this.ymin = t.ymin, this.ymax = t.ymax, this.cols = t.cols, this.rows = t.rows, this.us = t.us, this.vs = t.vs, this.deltaX = t.deltaX, this.deltaY = t.deltaY, this.flipY = !!t.flipY, this.ymin = Math.min(t.ymax, t.ymin), this.ymax = Math.max(t.ymax, t.ymin), this.deltaY < 0 && this.ymin < this.ymax || t.flipY === void 0 && (this.flipY = true), this.isFields = true;
          const e = Math.ceil((this.xmax - this.xmin) / t.deltaX), i = Math.ceil((this.ymax - this.ymin) / t.deltaY);
          e !== this.cols || this.rows, this.isContinuous = Math.floor(this.cols * t.deltaX) >= 360, this.translateX = "translateX" in t ? t.translateX : this.xmax > 180, "wrappedX" in t && VAt("[wind-core]: ", "`wrappedX` namespace will deprecated please use `translateX` instead"), this.wrapX = !!t.wrapX, this.grid = this.buildGrid(), this.range = this.calculateRange();
        }
        buildGrid() {
          const t = [];
          let e = 0;
          const { rows: i, cols: r, us: a, vs: o } = this;
          for (let s = 0; s < i; s++) {
            const l = [];
            for (let u = 0; u < r; u++, e++) {
              const h = a[e], c = o[e], f = this.isValid(h) && this.isValid(c);
              l[u] = f ? new pS(h, c) : null;
            }
            this.isContinuous && l.push(l[0]), t[s] = l;
          }
          return t;
        }
        release() {
          this.grid = [];
        }
        extent() {
          return [this.xmin, this.ymin, this.xmax, this.ymax];
        }
        bilinearInterpolateVector(t, e, i, r, a, o) {
          const s = 1 - t, l = 1 - e, u = s * l, h = t * l, c = s * e, f = t * e, g = i.u * u + r.u * h + a.u * c + o.u * f, d = i.v * u + r.v * h + a.v * c + o.v * f;
          return new pS(g, d);
        }
        calculateRange() {
          if (!this.grid || !this.grid[0]) return;
          const t = this.grid.length, e = this.grid[0].length;
          let i, r;
          for (let a = 0; a < t; a++) for (let o = 0; o < e; o++) {
            const s = this.grid[a][o];
            if (s !== null) {
              const l = s.m || s.magnitude();
              i === void 0 ? i = l : r === void 0 ? (r = l, i = Math.min(i, r), r = Math.max(i, r)) : (i = Math.min(l, i), r = Math.max(l, r));
            }
          }
          return [i, r];
        }
        isValid(t) {
          return t != null;
        }
        getWrappedLongitudes() {
          let t = this.xmin, e = this.xmax;
          return this.translateX && (this.isContinuous ? (t = -180, e = 180) : (e = this.xmax - 360, t = this.xmin - 360)), [t, e];
        }
        contains(t, e) {
          const [i, r] = this.getWrappedLongitudes();
          r > 180 && t >= -180 && t <= r - 360 ? t += 360 : i < -180 && t <= 180 && t >= i + 360 && (t -= 360);
          const a = t >= i && t <= r;
          let o;
          return this.deltaY >= 0 ? o = e >= this.ymin && e <= this.ymax : o = e >= this.ymax && e <= this.ymin, a && o;
        }
        getDecimalIndexes(t, e) {
          const i = jAt(t - this.xmin, 360) / this.deltaX;
          if (this.flipY) {
            const r = (this.ymax - e) / this.deltaY;
            return [i, r];
          } else {
            const r = (this.ymin + e) / this.deltaY;
            return [i, r];
          }
        }
        valueAt(t, e) {
          let i = false;
          if ((this.wrapX || this.contains(t, e)) && (i = true), !i) return null;
          const r = this.getDecimalIndexes(t, e), a = Math.floor(r[0]), o = Math.floor(r[1]), s = this.clampColumnIndex(a), l = this.clampRowIndex(o);
          return this.valueAtIndexes(s, l);
        }
        interpolatedValueAt(t, e) {
          let i = false;
          if ((this.wrapX || this.contains(t, e)) && (i = true), !i) return null;
          const [r, a] = this.getDecimalIndexes(t, e);
          return this.interpolatePoint(r, a);
        }
        hasValueAt(t, e) {
          return this.valueAt(t, e) !== null;
        }
        interpolatePoint(t, e) {
          const i = this.getFourSurroundingIndexes(t, e), [r, a, o, s] = i, l = this.getFourSurroundingValues(r, a, o, s);
          if (l) {
            const [u, h, c, f] = l;
            return this.bilinearInterpolateVector(t - r, e - o, u, h, c, f);
          }
          return null;
        }
        clampColumnIndex(t) {
          let e = t;
          t < 0 && (e = 0);
          const i = this.cols - 1;
          return t > i && (e = i), e;
        }
        clampRowIndex(t) {
          let e = t;
          t < 0 && (e = 0);
          const i = this.rows - 1;
          return t > i && (e = i), e;
        }
        getFourSurroundingIndexes(t, e) {
          const i = Math.floor(t);
          let r = i + 1;
          this.isContinuous && r >= this.cols && (r = 0), r = this.clampColumnIndex(r);
          const a = this.clampRowIndex(Math.floor(e)), o = this.clampRowIndex(a + 1);
          return [i, r, a, o];
        }
        getFourSurroundingValues(t, e, i, r) {
          let a;
          if (a = this.grid[i]) {
            const o = a[t], s = a[e];
            if (this.isValid(o) && this.isValid(s) && (a = this.grid[r])) {
              const l = a[t], u = a[e];
              if (this.isValid(l) && this.isValid(u)) return [o, s, l, u];
            }
          }
          return null;
        }
        valueAtIndexes(t, e) {
          return this.grid[e][t];
        }
        lonLatAtIndexes(t, e) {
          const i = this.longitudeAtX(t), r = this.latitudeAtY(e);
          return [i, r];
        }
        longitudeAtX(t) {
          const e = this.deltaX / 2;
          let i = this.xmin + e + t * this.deltaX;
          return this.translateX && (i = i > 180 ? i - 360 : i), i;
        }
        latitudeAtY(t) {
          const e = this.deltaY / 2;
          return this.ymax - e - t * this.deltaY;
        }
        randomize(t = {}, e, i, r) {
          const a = Math.random() * (e || this.cols) | 0, o = Math.random() * (i || this.rows) | 0, s = r([a, o]);
          return s !== null ? (t.x = s[0], t.y = s[1]) : (t.x = this.longitudeAtX(a), t.y = this.latitudeAtY(o)), t;
        }
        checkFields() {
          return this.isFields;
        }
      }
      const u3 = { globalAlpha: 0.9, lineWidth: 1, colorScale: "#fff", velocityScale: 1 / 25, maxAge: 90, paths: 800, frameRate: 20, useCoordsDraw: true };
      function h3(n, t, e, i) {
        return Math.max(0, Math.min(i.length - 1, Math.round((n - t) / (e - t) * (i.length - 1))));
      }
      const mL = class mL {
        constructor(t, e, i) {
          if (this.particles = [], this.generated = false, this.ctx = t, !this.ctx) throw new Error("ctx error");
          this.animate = this.animate.bind(this), this.setOptions(e), i && this.updateData(i);
        }
        setOptions(t) {
          this.options = st(st({}, u3), t);
          const { width: e, height: i } = this.ctx.canvas;
          "particleAge" in t && !("maxAge" in t) && dS(this.options.particleAge) && (this.options.maxAge = this.options.particleAge), "particleMultiplier" in t && !("paths" in t) && dS(this.options.particleMultiplier) && (this.options.paths = Math.round(e * i * this.options.particleMultiplier)), this.prerender();
        }
        getOptions() {
          return this.options;
        }
        updateData(t) {
          this.field = t, this.generated && (this.particles = this.prepareParticlePaths());
        }
        project(...t) {
          throw new Error("project must be overriden");
        }
        unproject(...t) {
          throw new Error("unproject must be overriden");
        }
        intersectsCoordinate(t) {
          throw new Error("must be overriden");
        }
        clearCanvas() {
          this.stop(), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.forceStop = false;
        }
        isStop() {
          return !this.starting;
        }
        start() {
          this.starting = true, this.forceStop = false, this.then = Date.now(), this.animate();
        }
        stop() {
          cancelAnimationFrame(this.animationLoop), this.starting = false, this.forceStop = true;
        }
        animate() {
          this.animationLoop && cancelAnimationFrame(this.animationLoop), this.animationLoop = requestAnimationFrame(this.animate);
          const t = Date.now(), e = t - this.then;
          e > this.options.frameRate && (this.then = t - e % this.options.frameRate, this.render());
        }
        prerender() {
          this.generated = false, this.field && (this.particles = this.prepareParticlePaths(), this.generated = true, !this.starting && !this.forceStop && (this.starting = true, this.then = Date.now(), this.animate()));
        }
        render() {
          this.moveParticles(), this.drawParticles(), this.postrender();
        }
        postrender() {
        }
        moveParticles() {
          const { width: t, height: e } = this.ctx.canvas, i = this.particles, r = this.options.maxAge, a = JA(this.options.velocityScale) ? this.options.velocityScale() : this.options.velocityScale;
          let o = 0;
          const s = i.length;
          for (; o < s; o++) {
            const l = i[o];
            l.age > r && (l.age = 0, this.field.randomize(l, t, e, this.unproject));
            const u = l.x, h = l.y, c = this.field.interpolatedValueAt(u, h);
            if (c === null) l.age = r;
            else {
              const f = u + c.u * a, g = h + c.v * a;
              this.field.hasValueAt(f, g) ? (l.xt = f, l.yt = g, l.m = c.m) : (l.x = f, l.y = g, l.age = r);
            }
            l.age++;
          }
        }
        fadeIn() {
          const t = this.ctx.globalCompositeOperation;
          this.ctx.globalCompositeOperation = "destination-in", this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.globalCompositeOperation = t;
        }
        drawParticles() {
          const t = this.particles;
          this.fadeIn(), this.ctx.globalAlpha = this.options.globalAlpha, this.ctx.fillStyle = `rgba(0, 0, 0, ${this.options.globalAlpha})`, this.ctx.lineWidth = dS(this.options.lineWidth) ? this.options.lineWidth : 1, this.ctx.strokeStyle = GAt(this.options.colorScale) ? this.options.colorScale : "#fff";
          let e = 0;
          const i = t.length;
          if (this.field && i > 0) {
            let r, a;
            for (Eo(this.options.minVelocity) && Eo(this.options.maxVelocity) ? (r = this.options.minVelocity, a = this.options.maxVelocity) : [r, a] = this.field.range; e < i; e++) this[this.options.useCoordsDraw ? "drawCoordsParticle" : "drawPixelParticle"](t[e], r, a);
          }
        }
        drawPixelParticle(t, e, i) {
          const r = [t.x, t.y], a = [t.xt, t.yt];
          if (a && r && Eo(a[0]) && Eo(a[1]) && Eo(r[0]) && Eo(r[1]) && t.age <= this.options.maxAge) {
            if (this.ctx.beginPath(), this.ctx.moveTo(r[0], r[1]), this.ctx.lineTo(a[0], a[1]), JA(this.options.colorScale)) this.ctx.strokeStyle = this.options.colorScale(t.m);
            else if (Array.isArray(this.options.colorScale)) {
              const o = h3(t.m, e, i, this.options.colorScale);
              this.ctx.strokeStyle = this.options.colorScale[o];
            }
            JA(this.options.lineWidth) && (this.ctx.lineWidth = this.options.lineWidth(t.m)), t.x = t.xt, t.y = t.yt, this.ctx.stroke();
          }
        }
        drawCoordsParticle(t, e, i) {
          const r = [t.x, t.y], a = [t.xt, t.yt];
          if (a && r && Eo(a[0]) && Eo(a[1]) && Eo(r[0]) && Eo(r[1]) && this.intersectsCoordinate(a) && t.age <= this.options.maxAge) {
            const o = this.project(r), s = this.project(a);
            if (o && s) {
              if (this.ctx.beginPath(), this.ctx.moveTo(o[0], o[1]), this.ctx.lineTo(s[0], s[1]), t.x = t.xt, t.y = t.yt, JA(this.options.colorScale)) this.ctx.strokeStyle = this.options.colorScale(t.m);
              else if (Array.isArray(this.options.colorScale)) {
                const l = h3(t.m, e, i, this.options.colorScale);
                this.ctx.strokeStyle = this.options.colorScale[l];
              }
              JA(this.options.lineWidth) && (this.ctx.lineWidth = this.options.lineWidth(t.m)), this.ctx.stroke();
            }
          }
        }
        prepareParticlePaths() {
          const { width: t, height: e } = this.ctx.canvas, i = typeof this.options.paths == "function" ? this.options.paths(this) : this.options.paths, r = [];
          if (!this.field) return [];
          let a = 0;
          for (; a < i; a++) r.push(this.field.randomize({ age: this.randomize() }, t, e, this.unproject));
          return r;
        }
        randomize() {
          return Math.floor(Math.random() * this.options.maxAge);
        }
      };
      mL.Field = l3;
      let vS = mL;
      const c3 = { ANIMATING: 0, INTERACTING: 1 };
      class HAt extends y0 {
        constructor(t) {
          super(t), this.pixelTransform = wn(), this.inversePixelTransform = wn();
        }
        useContainer(t, e, i) {
          super.useContainer(null, e, i);
        }
        getBackground(t) {
          return super.getBackground ? super.getBackground(t) : "";
        }
        prepareFrame(t) {
          var o, s;
          const e = t.layerStatesArray[t.layerIndex], i = t.viewState, r = t.viewHints;
          let a = t.extent;
          return e.extent !== void 0 && (a = ei(a, Ni(e.extent, i.projection))), !r[c3.ANIMATING] && !t.animate && !r[c3.INTERACTING] && !ns(a) ? ((s = (o = this.wind) == null ? void 0 : o.isStop) != null && s.call(o) && this.wind.start(), true) : this.getLayer().get("forceRender");
        }
        prepareContainer(t, e) {
          const i = t.size, r = t.viewState.rotation, a = t.pixelRatio, o = Math.round(i[0] * a), s = Math.round(i[1] * a);
          Sr(this.pixelTransform, t.size[0] / 2, t.size[1] / 2, 1 / a, 1 / a, r, -o / 2, -s / 2), Oy(this.inversePixelTransform, this.pixelTransform);
          const l = RL(this.pixelTransform);
          if (this.useContainer(e, l, this.getBackground(t)), !this.containerReused) {
            const u = this.context.canvas;
            (u.width != o || u.height != s) && (u.width = o, u.height = s), l !== u.style.transform && (u.style.transform = l);
          }
        }
        getRenderContext(t) {
          return this.context;
        }
        renderFrame(t, e) {
          const i = t.layerStatesArray[t.layerIndex], r = t.viewState;
          this.prepareContainer(t, e);
          const a = this.getRenderContext(t);
          a.imageSmoothingEnabled = false, this.preRender(a, t);
          let o = false, s = true;
          if (i.extent) {
            const c = Ni(i.extent, r.projection);
            s = hi(c, t.extent), o = s && !br(c, t.extent), o && this.clipUnrotated(a, t, c);
          }
          const l = this.getLayer(), u = l.getWindOptions(), h = l.getData();
          return this.execute(this.context, t, u, h), this.postRender(this.context, t), o && a.restore(), a.imageSmoothingEnabled = true, this.container;
        }
        setOptions(t) {
          this.wind && this.wind.setOptions(t);
        }
        setData(t) {
          this.wind && this.wind.updateData(t);
        }
        execute(t, e, i, r) {
          this.wind || (this.wind = new vS(t, i, r), this.wind.project = this.getPixelFromCoordinateInternal.bind(this), this.wind.unproject = this.getCoordinateFromPixel.bind(this), this.wind.intersectsCoordinate = this.intersectsCoordinate.bind(this), this.wind.postrender = () => {
          }, this.wind.prerender());
        }
        getPixelFromCoordinateInternal(t) {
          const e = this.frameState;
          if (e) {
            const i = e.viewState, r = e.pixelRatio, a = as(t, "EPSG:4326", i.projection), o = qe(a, i.projection), s = gn(e.coordinateToPixelTransform, o.slice(0, 2));
            return [s[0] * r, s[1] * r];
          } else return null;
        }
        getCoordinateFromPixel(t) {
          const e = this.frameState;
          if (e) {
            const i = e.viewState, r = gn(e.pixelToCoordinateTransform, t.slice(0, 2)), a = os(r, i.projection), o = as(a, i.projection, "EPSG:4326");
            return [o[0], o[1]];
          } else return null;
        }
        intersectsCoordinate(t) {
          const e = this.frameState;
          if (e) {
            const i = e.viewState, r = as(t, "EPSG:4326", i.projection), a = qe(r, i.projection);
            return Wr(e.extent, a.slice(0, 2));
          }
          return true;
        }
      }
      const YAt = { forceRender: true, windOptions: {} };
      class WAt extends Yc {
        constructor(t, e) {
          const i = AS({}, YAt, e);
          super(i), this.options = i, this.className_ = e.className !== void 0 ? e.className : "wind-layer", this.pickWindOptions(), t && this.setData(t, e.fieldOptions);
        }
        appendTo(t) {
          t.addLayer(this);
        }
        onAdd() {
          var e;
          const t = this.getRenderer();
          t && ((e = t.wind) == null || e.start());
        }
        onRemove() {
          const t = this.getRenderer();
          t && t.wind.stop();
        }
        createRenderer() {
          return new HAt(this);
        }
        getRenderer() {
          return super.getRenderer();
        }
        pickWindOptions() {
          Object.keys(u3).forEach((t) => {
            t in this.options && (this.options.windOptions === void 0 && (this.options.windOptions = {}), this.options.windOptions[t] = this.options[t]);
          });
        }
        getData() {
          return this.field;
        }
        setData(t, e = {}) {
          t && t.checkFields && t.checkFields() ? this.field = t : UAt(t) && (this.field = qAt(t, e));
          const i = this.getRenderer();
          return i && this.field && i.setData(this.field), this.changed(), this;
        }
        setWindOptions(t) {
          const e = this.options.windOptions || {};
          this.options = AS(this.options, { windOptions: AS(e, t || {}) });
          const i = this.getRenderer();
          if (i) {
            const r = this.options.windOptions;
            i.setOptions(r);
          }
          this.changed();
        }
        getWindOptions() {
          return this.options.windOptions || {};
        }
        render(t, e) {
          const i = this.getRenderer();
          return i && i.prepareFrame(t) ? (this.rendered = true, i.renderFrame(t, e)) : null;
        }
        setMapInternal(t) {
          super.setMapInternal(t), t ? this.onAdd() : this.onRemove();
        }
        setMap(t) {
          super.setMap(t), t ? this.onAdd() : this.onRemove();
        }
      }
      const yS = N.defineComponent({ name: "OlWind", __name: "index", props: { layerId: {}, data: {}, forceRender: { type: Boolean, default: true }, windOptions: {}, fieldOptions: {}, className: {}, opacity: {}, visible: { type: Boolean }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, renderOrder: {}, renderBuffer: {}, map: {}, declutter: { type: [String, Number, Boolean] }, background: {}, updateWhileAnimating: { type: Boolean }, updateWhileInteracting: { type: Boolean }, properties: {} }, emits: ["mount", "singleclick", "pointermove"], setup(n, { expose: t, emit: e }) {
        const i = N.inject("VMap"), r = N.unref(i).map, a = n, o = N.shallowRef(), s = e;
        function l(A) {
          if (A < 0.3) return 0;
          if (A >= 0.3 && A < 1.6) return 1;
          if (A >= 1.6 && A < 3.4) return 2;
          if (A >= 3.4 && A < 5.5) return 3;
          if (A >= 5.5 && A < 8) return 4;
          if (A >= 8 && A < 10.8) return 5;
          if (A >= 10.8 && A < 13.9) return 6;
          if (A >= 13.9 && A < 17.2) return 7;
          if (A >= 17.2 && A < 20.8) return 8;
          if (A >= 20.8 && A < 24.5) return 9;
          if (A >= 24.5 && A < 28.5) return 10;
          if (A >= 28.5 && A < 32.7) return 11;
          if (A >= 32.7 && A < 37) return 12;
          if (A >= 37 && A < 41.5) return 13;
          if (A >= 41.5 && A < 46.2) return 14;
          if (A >= 46.2 && A < 51) return 15;
          if (A >= 51 && A < 56.1) return 16;
          if (A >= 56.1 && A < 61.2) return 17;
          if (A >= 61.2) return 18;
        }
        function u(A) {
          if (A >= 0 && A <= 22.5 || A <= 360 && A > 337.5) return "";
          if (A <= 337.5 && A > 292.5) return "";
          if (A <= 292.5 && A > 247.5) return "";
          if (A <= 247.5 && A > 202.5) return "";
          if (A <= 202.5 && A > 157.5) return "";
          if (A <= 157.5 && A > 112.5) return "";
          if (A <= 112.5 && A > 67.5) return "";
          if (A <= 67.5 && A > 22.5) return "";
        }
        const h = () => {
          o.value = new WAt(a.data, { windOptions: a.windOptions, forceRender: a.forceRender, fieldOptions: a.fieldOptions }), Dl(o.value, a).onMounted(), o.value.setMap(r), r.on("singleclick", (A) => {
            const p = c(A), v = Object.assign({}, st({}, A), { coordinate: A.coordinate, pixel: A.pixel });
            s("singleclick", zt(st({}, v), { data: p }));
          }), r.on("pointermove", (A) => {
            const p = c(A), v = Object.assign({}, st({}, A), { coordinate: A.coordinate, pixel: A.pixel });
            s("pointermove", zt(st({}, v), { data: p }));
          }), s("mount", o.value);
        }, c = (A) => {
          var y;
          const v = ((y = o.value) == null ? void 0 : y.field).valueAt(A.coordinate[0], A.coordinate[1]);
          if (v) {
            const { u: m, v: _, m: E } = v, I = new pS(m, _);
            return { u: m, v: _, m: E, directionTo: I.directionTo(), directionFrom: I.directionFrom(), windLevel: `${l(E)}`, windDirection: u(I.directionFrom()) };
          } else return null;
        };
        N.watch(() => a.data, (A) => {
          var p;
          (p = o.value) == null || p.setData(A);
        }, { deep: true }), N.watch(() => a.windOptions, (A) => {
          var p;
          A && ((p = o.value) == null || p.setWindOptions(A));
        }, { deep: true }), N.watchEffect(() => {
          Dl(o.value, a);
        });
        const f = () => {
          r == null || r.removeLayer(o.value), o.value = null;
        };
        return t({ getData: () => {
          var A;
          return (A = o.value) == null ? void 0 : A.getData();
        }, getWindOptions: () => {
          var A;
          return (A = o.value) == null ? void 0 : A.getWindOptions();
        } }), N.onMounted(() => {
          h();
        }), N.onUnmounted(() => {
          f();
        }), (A, p) => N.renderSlot(A.$slots, "default");
      } }), XAt = (n) => n.component(yS.name || "OlWind", yS), mS = N.defineComponent({ name: "OlWfs", __name: "index", props: { options: { default: () => ({ featureNS: "", featurePrefix: "", featureTypes: [], outputFormat: "application/json", maxFeatures: 1 / 0 }) } }, setup(n) {
        const t = N.inject("ParentLayer"), e = n, i = () => {
          const r = new xO().writeGetFeature(zt(st({}, e.options), { outputFormat: "application/json" }));
          fetch(e.options.featureNS, { method: "POST", body: new XMLSerializer().serializeToString(r) }).then(function(a) {
            return a.json();
          }).then((a) => {
            var s;
            const o = new zf().readFeatures(a);
            if (t && N.unref(t)) {
              const l = (s = N.unref(t)) == null ? void 0 : s.getSource();
              l && l.addFeatures(o);
            }
          });
        };
        return N.onMounted(() => {
          i();
        }), (r, a) => N.renderSlot(r.$slots, "default");
      } }), ZAt = (n) => n.component(mS.name || "OlWfs", mS), _S = N.defineComponent({ name: "OlWms", __name: "index", props: { tileGrid: {}, attributions: {}, attributionsCollapsible: { type: Boolean }, cacheSize: {}, crossOrigin: {}, interpolate: { type: Boolean }, params: {}, gutter: {}, hidpi: { type: Boolean }, projection: {}, reprojectionErrorThreshold: {}, tileClass: {}, serverType: {}, tileLoadFunction: {}, url: {}, urls: {}, wrapX: { type: Boolean }, transition: {}, zDirection: {}, imageLoadFunction: {}, ratio: {}, resolutions: {} }, emits: ["singleclick"], setup(n, { emit: t }) {
        const e = N.inject("VMap"), i = N.unref(e).map, r = N.inject("ParentTileLayer"), a = n, o = t, s = () => {
          var l;
          if (r.value) {
            const u = (l = r.value) == null ? void 0 : l.get("layerTypeName");
            let h, c;
            if (a.tileGrid && (h = new Rf(a.tileGrid)), u === "ImageLayer") {
              const f = zt(st({}, a), { tileGrid: h });
              c = new qlt(f), r.value.setSource(c);
            } else if (u === "TileLayer") {
              const f = zt(st({}, a), { tileGrid: h });
              c = new Klt(f), r.value.setSource(c);
            }
            if (!c) return;
            i.on("pointermove", function(f) {
              if (f.dragging) return;
              const g = r.value.getData(f.pixel), d = g && g[3] > 0;
              i.getTargetElement().style.cursor = d ? "pointer" : "";
            }), i.on("singleclick", (f) => {
              const g = i.getView(), d = g.getResolution();
              if (!d) return;
              const A = c == null ? void 0 : c.getFeatureInfoUrl(f.coordinate, d, g.getProjection().getCode(), { INFO_FORMAT: "application/json" });
              A && fetch(A).then((p) => p.json()).then((p) => {
                o("singleclick", f, p);
              });
            });
          }
        };
        return N.onMounted(() => {
          s();
        }), (l, u) => N.renderSlot(l.$slots, "default");
      } }), KAt = (n) => n.component(_S.name || "OlWms", _S), IS = N.defineComponent({ name: "OlHeatmap", __name: "index", props: { layerId: { default: `vector-layer-${qu()}` }, source: {}, className: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, gradient: { default: () => ["#00f", "#0ff", "#0f0", "#ff0", "#f00"] }, radius: { default: 8 }, blur: { default: 15 }, weight: { type: [String, Function], default: "weight" }, properties: {} }, emits: ["singleclick", "pointermove", "sourceready", "featuresloadend", "featuresloadstart", "addfeature"], setup(n, { emit: t }) {
        const e = n, i = N.inject("VMap"), r = N.unref(i).map;
        let a = N.shallowRef(), o = N.shallowRef(), s = N.ref([]);
        const l = ["singleclick", "pointermove"], u = t;
        let h = N.ref(false);
        N.provide("ParentLayer", a), N.watchEffect(() => {
          Dl(a.value, e);
        }), N.watch(() => e.blur, (A) => {
          var p;
          (a.value || A === 0) && ((p = a.value) == null || p.setBlur(A));
        }), N.watch(() => e.radius, (A) => {
          var p;
          (a.value || A === 0) && ((p = a.value) == null || p.setRadius(A));
        }), N.watch(() => e.gradient, (A) => {
          var p;
          a.value && ((p = a.value) == null || p.setGradient(A));
        }, { deep: true }), N.watch(() => e.source, () => {
          var A;
          (A = o.value) == null || A.clear(), a.value && r.removeLayer(a.value), c();
        });
        const c = () => {
          o.value = new $r(st({}, e.source)), o.value.once("addfeature", () => {
            u("addfeature", a.value, o.value);
          }), a.value = new sut(zt(st({}, e), { source: o.value })), a.value.set("id", e.layerId), r.addLayer(a.value), l.forEach((A) => {
            s.value.push(r.on(A, (p) => {
              f(A, p);
            }));
          }), a.value.on("sourceready", () => {
            h.value = true, u("sourceready", a.value);
          });
        }, f = (A, p) => {
          const { pixel: v } = p, y = g(v);
          u(A, p, y);
        }, g = (A) => r.forEachFeatureAtPixel(A, (p) => p, { layerFilter: (p) => {
          var v;
          return p.get("id") === ((v = a.value) == null ? void 0 : v.get("id"));
        } }), d = () => {
          s.value.forEach((A) => {
            rl(A);
          });
        };
        return N.onMounted(() => {
          c();
        }), N.onBeforeUnmount(() => {
          d();
        }), (A, p) => N.unref(h) ? N.renderSlot(A.$slots, "default", { key: 0 }) : N.createCommentVNode("", true);
      } }), $At = (n) => n.component(IS.name || "OlHeatmap", IS), ES = N.defineComponent({ name: "OlTiff", __name: "index", props: { source: {}, layerStyle: {}, className: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, preload: {}, sources: {}, map: {}, useInterimTilesOnError: { type: Boolean }, cacheSize: {}, properties: {} }, setup(n) {
        const t = n, e = N.inject("VMap"), i = N.unref(e).map, r = new EQ(t.source), a = new Kw(zt(st({}, t), { source: r }));
        return N.watchEffect(() => {
          Dl(a, t);
        }), N.onMounted(() => {
          i.addLayer(a);
        }), (o, s) => N.renderSlot(o.$slots, "default");
      } }), JAt = (n) => n.component(ES.name || "OlTiff", ES), f3 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], xS = 1, tp = 8;
      class wS {
        static from(t) {
          if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
          const [e, i] = new Uint8Array(t, 0, 2);
          if (e !== 219) throw new Error("Data does not appear to be in a KDBush format.");
          const r = i >> 4;
          if (r !== xS) throw new Error(`Got v${r} data when expected v${xS}.`);
          const a = f3[i & 15];
          if (!a) throw new Error("Unrecognized array type.");
          const [o] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
          return new wS(s, o, a, t);
        }
        constructor(t, e = 64, i = Float64Array, r) {
          if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
          this.numItems = +t, this.nodeSize = Math.min(Math.max(+e, 2), 65535), this.ArrayType = i, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
          const a = f3.indexOf(this.ArrayType), o = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
          if (a < 0) throw new Error(`Unexpected typed array class: ${i}.`);
          r && r instanceof ArrayBuffer ? (this.data = r, this.ids = new this.IndexArrayType(this.data, tp, t), this.coords = new this.ArrayType(this.data, tp + s + l, t * 2), this._pos = t * 2, this._finished = true) : (this.data = new ArrayBuffer(tp + o + s + l), this.ids = new this.IndexArrayType(this.data, tp, t), this.coords = new this.ArrayType(this.data, tp + s + l, t * 2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, (xS << 4) + a]), new Uint16Array(this.data, 2, 1)[0] = e, new Uint32Array(this.data, 4, 1)[0] = t);
        }
        add(t, e) {
          const i = this._pos >> 1;
          return this.ids[i] = i, this.coords[this._pos++] = t, this.coords[this._pos++] = e, i;
        }
        finish() {
          const t = this._pos >> 1;
          if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
          return CS(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
        }
        range(t, e, i, r) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: a, coords: o, nodeSize: s } = this, l = [0, a.length - 1, 0], u = [];
          for (; l.length; ) {
            const h = l.pop() || 0, c = l.pop() || 0, f = l.pop() || 0;
            if (c - f <= s) {
              for (let p = f; p <= c; p++) {
                const v = o[2 * p], y = o[2 * p + 1];
                v >= t && v <= i && y >= e && y <= r && u.push(a[p]);
              }
              continue;
            }
            const g = f + c >> 1, d = o[2 * g], A = o[2 * g + 1];
            d >= t && d <= i && A >= e && A <= r && u.push(a[g]), (h === 0 ? t <= d : e <= A) && (l.push(f), l.push(g - 1), l.push(1 - h)), (h === 0 ? i >= d : r >= A) && (l.push(g + 1), l.push(c), l.push(1 - h));
          }
          return u;
        }
        within(t, e, i) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: r, coords: a, nodeSize: o } = this, s = [0, r.length - 1, 0], l = [], u = i * i;
          for (; s.length; ) {
            const h = s.pop() || 0, c = s.pop() || 0, f = s.pop() || 0;
            if (c - f <= o) {
              for (let p = f; p <= c; p++) d3(a[2 * p], a[2 * p + 1], t, e) <= u && l.push(r[p]);
              continue;
            }
            const g = f + c >> 1, d = a[2 * g], A = a[2 * g + 1];
            d3(d, A, t, e) <= u && l.push(r[g]), (h === 0 ? t - i <= d : e - i <= A) && (s.push(f), s.push(g - 1), s.push(1 - h)), (h === 0 ? t + i >= d : e + i >= A) && (s.push(g + 1), s.push(c), s.push(1 - h));
          }
          return l;
        }
      }
      function CS(n, t, e, i, r, a) {
        if (r - i <= e) return;
        const o = i + r >> 1;
        g3(n, t, o, i, r, a), CS(n, t, e, i, o - 1, 1 - a), CS(n, t, e, o + 1, r, 1 - a);
      }
      function g3(n, t, e, i, r, a) {
        for (; r > i; ) {
          if (r - i > 600) {
            const u = r - i + 1, h = e - i + 1, c = Math.log(u), f = 0.5 * Math.exp(2 * c / 3), g = 0.5 * Math.sqrt(c * f * (u - f) / u) * (h - u / 2 < 0 ? -1 : 1), d = Math.max(i, Math.floor(e - h * f / u + g)), A = Math.min(r, Math.floor(e + (u - h) * f / u + g));
            g3(n, t, e, d, A, a);
          }
          const o = t[2 * e + a];
          let s = i, l = r;
          for (ep(n, t, i, e), t[2 * r + a] > o && ep(n, t, i, r); s < l; ) {
            for (ep(n, t, s, l), s++, l--; t[2 * s + a] < o; ) s++;
            for (; t[2 * l + a] > o; ) l--;
          }
          t[2 * i + a] === o ? ep(n, t, i, l) : (l++, ep(n, t, l, r)), l <= e && (i = l + 1), e <= l && (r = l - 1);
        }
      }
      function ep(n, t, e, i) {
        SS(n, e, i), SS(t, 2 * e, 2 * i), SS(t, 2 * e + 1, 2 * i + 1);
      }
      function SS(n, t, e) {
        const i = n[t];
        n[t] = n[e], n[e] = i;
      }
      function d3(n, t, e, i) {
        const r = n - e, a = t - i;
        return r * r + a * a;
      }
      const tpt = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (n) => n }, A3 = Math.fround || /* @__PURE__ */ ((n) => (t) => (n[0] = +t, n[0]))(new Float32Array(1)), Zu = 2, Pl = 3, bS = 4, Nl = 5, p3 = 6;
      class ept {
        constructor(t) {
          this.options = Object.assign(Object.create(tpt), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(t) {
          const { log: e, minZoom: i, maxZoom: r } = this.options, a = `prepare ${t.length} points`;
          this.points = t;
          const o = [];
          for (let l = 0; l < t.length; l++) {
            const u = t[l];
            if (!u.geometry) continue;
            const [h, c] = u.geometry.coordinates, f = A3(Hm(h)), g = A3(Ym(c));
            o.push(f, g, 1 / 0, l, -1, 1), this.options.reduce && o.push(0);
          }
          let s = this.trees[r + 1] = this._createTree(o);
          for (let l = r; l >= i; l--) {
            const u = +Date.now();
            s = this.trees[l] = this._createTree(this._cluster(s, l));
          }
          return this;
        }
        getClusters(t, e) {
          let i = ((t[0] + 180) % 360 + 360) % 360 - 180;
          const r = Math.max(-90, Math.min(90, t[1]));
          let a = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
          const o = Math.max(-90, Math.min(90, t[3]));
          if (t[2] - t[0] >= 360) i = -180, a = 180;
          else if (i > a) {
            const c = this.getClusters([i, r, 180, o], e), f = this.getClusters([-180, r, a, o], e);
            return c.concat(f);
          }
          const s = this.trees[this._limitZoom(e)], l = s.range(Hm(i), Ym(o), Hm(a), Ym(r)), u = s.data, h = [];
          for (const c of l) {
            const f = this.stride * c;
            h.push(u[f + Nl] > 1 ? v3(u, f, this.clusterProps) : this.points[u[f + Pl]]);
          }
          return h;
        }
        getChildren(t) {
          const e = this._getOriginId(t), i = this._getOriginZoom(t), r = "No cluster with the specified id.", a = this.trees[i];
          if (!a) throw new Error(r);
          const o = a.data;
          if (e * this.stride >= o.length) throw new Error(r);
          const s = this.options.radius / (this.options.extent * Math.pow(2, i - 1)), l = o[e * this.stride], u = o[e * this.stride + 1], h = a.within(l, u, s), c = [];
          for (const f of h) {
            const g = f * this.stride;
            o[g + bS] === t && c.push(o[g + Nl] > 1 ? v3(o, g, this.clusterProps) : this.points[o[g + Pl]]);
          }
          if (c.length === 0) throw new Error(r);
          return c;
        }
        getLeaves(t, e, i) {
          e = e || 10, i = i || 0;
          const r = [];
          return this._appendLeaves(r, t, e, i, 0), r;
        }
        getTile(t, e, i) {
          const r = this.trees[this._limitZoom(t)], a = Math.pow(2, t), { extent: o, radius: s } = this.options, l = s / o, u = (i - l) / a, h = (i + 1 + l) / a, c = { features: [] };
          return this._addTileFeatures(r.range((e - l) / a, u, (e + 1 + l) / a, h), r.data, e, i, a, c), e === 0 && this._addTileFeatures(r.range(1 - l / a, u, 1, h), r.data, a, i, a, c), e === a - 1 && this._addTileFeatures(r.range(0, u, l / a, h), r.data, -1, i, a, c), c.features.length ? c : null;
        }
        getClusterExpansionZoom(t) {
          let e = this._getOriginZoom(t) - 1;
          for (; e <= this.options.maxZoom; ) {
            const i = this.getChildren(t);
            if (e++, i.length !== 1) break;
            t = i[0].properties.cluster_id;
          }
          return e;
        }
        _appendLeaves(t, e, i, r, a) {
          const o = this.getChildren(e);
          for (const s of o) {
            const l = s.properties;
            if (l && l.cluster ? a + l.point_count <= r ? a += l.point_count : a = this._appendLeaves(t, l.cluster_id, i, r, a) : a < r ? a++ : t.push(s), t.length === i) break;
          }
          return a;
        }
        _createTree(t) {
          const e = new wS(t.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let i = 0; i < t.length; i += this.stride) e.add(t[i], t[i + 1]);
          return e.finish(), e.data = t, e;
        }
        _addTileFeatures(t, e, i, r, a, o) {
          for (const s of t) {
            const l = s * this.stride, u = e[l + Nl] > 1;
            let h, c, f;
            if (u) h = y3(e, l, this.clusterProps), c = e[l], f = e[l + 1];
            else {
              const A = this.points[e[l + Pl]];
              h = A.properties;
              const [p, v] = A.geometry.coordinates;
              c = Hm(p), f = Ym(v);
            }
            const g = { type: 1, geometry: [[Math.round(this.options.extent * (c * a - i)), Math.round(this.options.extent * (f * a - r))]], tags: h };
            let d;
            u || this.options.generateId ? d = e[l + Pl] : d = this.points[e[l + Pl]].id, d !== void 0 && (g.id = d), o.features.push(g);
          }
        }
        _limitZoom(t) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
        }
        _cluster(t, e) {
          const { radius: i, extent: r, reduce: a, minPoints: o } = this.options, s = i / (r * Math.pow(2, e)), l = t.data, u = [], h = this.stride;
          for (let c = 0; c < l.length; c += h) {
            if (l[c + Zu] <= e) continue;
            l[c + Zu] = e;
            const f = l[c], g = l[c + 1], d = t.within(l[c], l[c + 1], s), A = l[c + Nl];
            let p = A;
            for (const v of d) {
              const y = v * h;
              l[y + Zu] > e && (p += l[y + Nl]);
            }
            if (p > A && p >= o) {
              let v = f * A, y = g * A, m, _ = -1;
              const E = ((c / h | 0) << 5) + (e + 1) + this.points.length;
              for (const I of d) {
                const x = I * h;
                if (l[x + Zu] <= e) continue;
                l[x + Zu] = e;
                const w = l[x + Nl];
                v += l[x] * w, y += l[x + 1] * w, l[x + bS] = E, a && (m || (m = this._map(l, c, true), _ = this.clusterProps.length, this.clusterProps.push(m)), a(m, this._map(l, x)));
              }
              l[c + bS] = E, u.push(v / p, y / p, 1 / 0, E, -1, p), a && u.push(_);
            } else {
              for (let v = 0; v < h; v++) u.push(l[c + v]);
              if (p > 1) for (const v of d) {
                const y = v * h;
                if (!(l[y + Zu] <= e)) {
                  l[y + Zu] = e;
                  for (let m = 0; m < h; m++) u.push(l[y + m]);
                }
              }
            }
          }
          return u;
        }
        _getOriginId(t) {
          return t - this.points.length >> 5;
        }
        _getOriginZoom(t) {
          return (t - this.points.length) % 32;
        }
        _map(t, e, i) {
          if (t[e + Nl] > 1) {
            const o = this.clusterProps[t[e + p3]];
            return i ? Object.assign({}, o) : o;
          }
          const r = this.points[t[e + Pl]].properties, a = this.options.map(r);
          return i && a === r ? Object.assign({}, a) : a;
        }
      }
      function v3(n, t, e) {
        return { type: "Feature", id: n[t + Pl], properties: y3(n, t, e), geometry: { type: "Point", coordinates: [npt(n[t]), ipt(n[t + 1])] } };
      }
      function y3(n, t, e) {
        const i = n[t + Nl], r = i >= 1e4 ? `${Math.round(i / 1e3)}k` : i >= 1e3 ? `${Math.round(i / 100) / 10}k` : i, a = n[t + p3], o = a === -1 ? {} : Object.assign({}, e[a]);
        return Object.assign(o, { cluster: true, cluster_id: n[t + Pl], point_count: i, point_count_abbreviated: r });
      }
      function Hm(n) {
        return n / 360 + 0.5;
      }
      function Ym(n) {
        const t = Math.sin(n * Math.PI / 180), e = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
        return e < 0 ? 0 : e > 1 ? 1 : e;
      }
      function npt(n) {
        return (n - 0.5) * 360;
      }
      function ipt(n) {
        const t = (180 - n * 360) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
      }
      const Ku = N.defineComponent({ name: "OlFeature", props: { geometries: { type: Array, default: void 0 }, geoJson: { type: Object, default: void 0 }, options: { type: Object, default: void 0 } }, setup(n, { expose: t }) {
        const e = N.inject("VMap"), i = N.unref(e).map, r = N.inject("ParentLayer");
        let a, o = N.ref();
        const s = () => {
          let v = r.value.getSource();
          if (r.value.get("cluster") && r.value.getSource() && (v = r.value.getSource().getSource()), v) {
            const y = r.value.get("superCluster");
            if (y) {
              a = new ept(y);
              let m = [];
              n.geoJson && m.push(...u("Point")), n.geometries && n.geometries.length > 0 && m.push(...d("Point"));
              const _ = new zf().writeFeaturesObject(m);
              a.load(_.features);
              const E = i.getView().calculateExtent(i.getSize()), I = a.getClusters(E, i.getView().getZoom() || 0), x = new zf().readFeatures({ type: "FeatureCollection", features: I }).map((w) => {
                const C = w.get("properties");
                if (C && typeof C == "object") for (const S in C) Object.prototype.hasOwnProperty.call(C, S) && w.set(S, C[S]);
                return w;
              });
              v.addFeatures(x), i.on("precompose", () => {
                const w = i.getView().calculateExtent(i.getSize()), S = { type: "FeatureCollection", features: a.getClusters(w, i.getView().getZoom() || 0) }, b = r.value.getSource();
                b && (b.clear(), b.addFeatures(new zf().readFeatures(S).map((B) => {
                  const T = B.get("properties");
                  if (T && typeof T == "object") for (const R in T) Object.prototype.hasOwnProperty.call(T, R) && B.set(R, T[R]);
                  const D = B.get("style");
                  return D && jm(B, D, i), B;
                })));
              });
            } else n.geoJson && l(v, r.value.get("cluster") ? "Point" : void 0), n.geometries && n.geometries.length > 0 && f(v, r.value.get("cluster") ? "Point" : void 0);
          }
        }, l = (v, y) => {
          const m = u(y);
          m && m.length > 0 && (o.value = m, v.addFeatures(m));
        }, u = (v) => {
          let y, m, _;
          const E = v ? h(v) : n.geoJson, I = n.options;
          return I && I.dataProjection && (y = new rr(I.dataProjection)), I && I.featureProjection && (m = new rr(I.featureProjection)), I && I.extent && (_ = I.extent), new zf().readFeatures(E, I ? { extent: _, dataProjection: y, featureProjection: m } : void 0).map((w) => {
            const C = w.get("style"), S = w.get("id");
            return C && jm(w, C, i), S && !w.getId() && w.setId(S), w;
          });
        }, h = (v) => {
          const y = n.geoJson;
          if (y) return y.type === "FeatureCollection" ? { type: "FeatureCollection", features: y.features.filter((m) => m.geometry.type === v) } : y.type === "Feature" ? y.geometry.type === v ? y : null : y.type === v ? y : null;
        }, c = (v) => {
          const y = i.getView().getProjection().getMetersPerUnit();
          return v && y ? v / y : 0;
        }, f = (v, y) => {
          const m = d(y);
          m && m.length > 0 && (o.value = m, v.addFeatures(m));
        }, g = (v) => {
          if (v.type === "Point") return new Oe(v.geometry.coordinates);
          if (v.type === "MultiPoint") return new sr(v.geometry.coordinates);
          if (v.type === "Circle") {
            const y = v.geometry, m = c(y.radius);
            return new AA(y.center, m);
          } else {
            if (v.type === "Polygon") return new Sn(v.geometry.coordinates);
            if (v.type === "LineString") return new be(v.geometry.coordinates);
            if (v.type === "MultiPolygon") return new Ci(v.geometry.coordinates);
            if (v.type === "MultiLineString") return new ri(v.geometry.coordinates);
            if (v.type === "LinearRing") return new ao(v.geometry.coordinates);
          }
        }, d = (v) => {
          const y = n.geometries;
          if (!y) return [];
          let m = [];
          return y.forEach((_) => {
            if (_.type === "GeometryCollection") {
              let E = [];
              _.geometry.geometries.forEach((x) => {
                const w = v || _.type, C = g({ type: w, geometry: x });
                C && E.push(C);
              });
              const I = new yn(E);
              m.push(new xe(st({ geometry: I }, _.properties)));
            } else {
              if (v && _.type !== v) return;
              const E = new xe(st({ geometry: g(_) }, _.properties));
              m.push(E);
            }
          }), m.map((_) => {
            const E = _.get("style"), I = _.get("id");
            return E && jm(_, E, i), I && !_.getId() && _.setId(I), _;
          });
        }, A = (v, y, m) => {
          if (a) return a.getLeaves(v, y, m);
          throw new Error("SuperCluster is not initialized");
        }, p = (v) => {
          var m;
          if (!r) return;
          let y = r.value.getSource();
          r.value.get("cluster") && r.value.getSource() && (y = r.value.getSource().getSource()), o.value && (y == null || y.removeFeatures((m = o.value) != null ? m : [])), v && s();
        };
        return N.watch(() => n.geoJson, (v) => {
          p(v);
        }, { deep: true }), N.watch(() => n.geometries, (v) => {
          p(v);
        }, { deep: true }), N.onMounted(() => {
          r && s();
        }), t({ getLeaves: A }), { getLeaves: A };
      }, render() {
        return null;
      } }), rpt = (n) => n.component(Ku.name || "OlFeature", Ku), BS = N.defineComponent({ name: "OlCluster", __name: "index", props: { layerId: { default: `vector-layer-${qu()}` }, source: {}, clusterOptions: { default: () => ({}) }, clusterStyle: { default: () => ({}) }, layerStyle: { default: () => ({}) }, superCluster: { default: void 0 }, className: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, renderOrder: {}, renderBuffer: {}, map: {}, declutter: { type: [String, Number, Boolean] }, style: {}, background: {}, updateWhileAnimating: { type: Boolean }, updateWhileInteracting: { type: Boolean }, properties: {} }, emits: ["singleclick", "pointermove", "sourceready", "featuresloadend", "featuresloadstart", "addfeature"], setup(n, { emit: t }) {
        const e = n, i = N.inject("VMap"), r = N.unref(i).map;
        let a = N.shallowRef(), o = N.shallowRef(), s = N.shallowRef(), l = N.ref([]);
        const u = ["singleclick", "pointermove"], h = t;
        let c = N.ref(false);
        N.provide("ParentLayer", a), N.watchEffect(() => {
          Dl(a.value, e);
        });
        const f = (v, y) => {
          const m = zt(st({}, v.text), { text: y });
          return zt(st({}, v), { text: m });
        }, g = () => {
          var v, y, m, _;
          if (o.value = new $r(st({}, e.source)), e.superCluster) {
            const E = {}, I = ((y = (v = s == null ? void 0 : s.value) == null ? void 0 : v.getSource()) == null ? void 0 : y.getFeatures().length) || 0;
            a.value = new Kr(zt(st({}, e), { source: o.value, style: (x) => {
              const w = x.get("cluster") || 0, C = x.get("point_count_abbreviated") || 0;
              let S = E[C];
              if (w) {
                if (!S) {
                  let b = {};
                  b = { image: new Mr({ radius: 4, fill: new ye({ color: "blue" }) }), text: new Ei({ font: "16px sans-serif", text: C.toString() }) }, e.clusterStyle ? (b = e.clusterStyle, b instanceof Array ? (b.forEach((B) => {
                    let T = 0, D = I;
                    if (Tn(B, "min") || Tn(B, "max")) T = B.min, D = B.max, T < C && C <= D && (b = f(B, C.toString()));
                    else if (I > 0) {
                      const R = I / b.style.length;
                      for (let L = 0; L < b.style.length; L++) T = L * R, D = R * (L + 1), T < C && C <= D && (b = f(b.style[L], C.toString()));
                    }
                  }), S = Wu(b)) : (b = f(b, C.toString()), S = Wu(b))) : S = new de(b), E[C] = S;
                }
              } else S = Wu(e.layerStyle);
              return S;
            } })), a.value.set("superCluster", e.superCluster);
          } else {
            s.value = new Oot(zt(st({}, e.clusterOptions), { source: o.value }));
            const E = {}, I = ((_ = (m = s == null ? void 0 : s.value) == null ? void 0 : m.getSource()) == null ? void 0 : _.getFeatures().length) || 0;
            a.value = new Kr(zt(st({}, e), { source: s.value, style: function(x) {
              const w = x.get("features").length;
              let C = E[w];
              if (w > 1) {
                if (!C) {
                  let S = {};
                  S = e.clusterStyle, !S || Object.keys(S).length === 0 ? (S = { image: new Mr({ radius: 20, stroke: new Ze({ color: "#fff" }), fill: new ye({ color: "#3399CC" }) }), text: new Ei({ font: "16px sans-serif", text: w.toString(), fill: new ye({ color: "#fff" }) }) }, C = new de(S)) : S instanceof Array ? (S.forEach((b) => {
                    let B = 0, T = I;
                    if (Tn(b, "min") || Tn(b, "max")) B = b.min, T = b.max, B < w && w <= T && (S = f(b, w.toString()));
                    else if (I > 0) {
                      const D = I / S.style.length;
                      for (let R = 0; R < S.style.length; R++) B = R * D, T = D * (R + 1), B < w && w <= T && (S = f(S.style[R], w.toString()));
                    }
                  }), C = Wu(S)) : (S = f(S, w.toString()), C = Wu(S)), E[w] = C;
                }
              } else C = Wu(e.layerStyle);
              return C;
            } })), a.value.set("cluster", true);
          }
          a.value.set("id", e.layerId), r.addLayer(a.value), u.forEach((E) => {
            l.value.push(r.on(E, (I) => {
              d(E, I);
            }));
          }), a.value.on("sourceready", () => {
            c.value = true, h("sourceready", a.value);
          });
        }, d = (v, y) => {
          const { pixel: m } = y, _ = A(m);
          h(v, y, _);
        }, A = (v) => r.forEachFeatureAtPixel(v, (y) => y, { layerFilter: (y) => {
          var m;
          return y.get("id") === ((m = a.value) == null ? void 0 : m.get("id"));
        } }), p = () => {
          l.value.forEach((v) => {
            rl(v);
          });
        };
        return N.onMounted(() => {
          g();
        }), N.onBeforeUnmount(() => {
          p();
        }), (v, y) => N.unref(c) ? N.renderSlot(v.$slots, "default", { key: 0 }) : N.createCommentVNode("", true);
      } }), apt = (n) => n.component(BS.name || "OlCluster", BS), TS = N.defineComponent({ name: "OlOverlay", __name: "index", props: { overlayId: { default: `overlay-${qu()}` }, data: { default: () => ({}) }, id: {}, element: {}, offset: { default: () => [0, 0] }, position: { default: void 0 }, positioning: {}, stopEvent: { type: Boolean }, insertFirst: { type: Boolean }, autoPan: { type: [Boolean, Object] }, className: {} }, emits: ["load"], setup(n, { emit: t }) {
        const e = n;
        let i = N.shallowRef();
        const r = N.inject("VMap"), a = N.unref(r).map, o = t, s = `overlay-el-${qu()}`;
        N.watch(() => e.position, (u) => {
          i.value.setPosition(u);
        }, { deep: true, immediate: false });
        const l = () => {
          let u = e.element ? e.element : document.getElementById(s.toString());
          const h = zt(st({}, e), { id: e.overlayId, element: u });
          i.value = new kN(h);
          const c = st({}, h);
          for (const f in c) Object.prototype.hasOwnProperty.call(c, f) && i.value.set(f, c[f]);
          a.addOverlay(i.value), o("load", i.value, a);
        };
        return N.onMounted(() => {
          l();
        }), (u, h) => (N.openBlock(), N.createElementBlock("div", N.mergeProps({ id: s, ref: "overlayRef" }, u.$attrs), [N.renderSlot(u.$slots, "default", { data: u.data })], 16));
      } }), opt = (n) => n.component(TS.name || "OlOverlay", TS), MS = N.defineComponent({ name: "OlOverview", __name: "index", props: { className: {}, collapsed: { type: Boolean, default: false }, collapseLabel: {}, collapsible: { type: Boolean, default: true }, label: {}, layers: {}, render: {}, rotateWithView: { type: Boolean }, target: {}, tipLabel: {}, view: {}, tileType: { default: "TDT" }, layerId: { default: `tile-layer-${qu()}` }, source: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, preload: {}, map: {}, useInterimTilesOnError: { type: Boolean }, properties: {}, cacheSize: {} }, setup(n) {
        const t = n, { init: e, setOverviewMapOptions: i } = TQ(t);
        return N.onMounted(() => {
          i(st({}, t)).then(() => {
            e(true);
          });
        }), (r, a) => N.renderSlot(r.$slots, "default");
      } }), spt = (n) => n.component(MS.name || "OlOverview", MS), lpt = { class: "form-item" }, upt = { class: "form-item" }, hpt = N.defineComponent({ __name: "index", props: { type: { default: "Point" }, feature: { default: void 0 }, pinClass: { default: "overlay-pin" }, titleClass: { default: "" }, bodyClass: { default: "" }, footerClass: { default: "" } }, emits: ["save"], setup(n, { emit: t }) {
        const e = N.inject("VMap"), i = N.unref(e).map, r = N.inject("ParentLayer"), a = n, o = { Point: "", Polygon: "" };
        let s = N.ref(void 0);
        const l = (p) => {
          var v;
          if (p) {
            if (p.get("type") === "Point") return (v = p.getGeometry()) == null ? void 0 : v.getCoordinates();
            {
              const { topCenter: y } = AF(p.getGeometry());
              return y;
            }
          }
        };
        N.watch(() => a.feature, (p) => {
          u.value = "", h.value = "", c.value = void 0, s.value = void 0, p && (f.value = p.get("type") ? p.get("type") : a.type, s.value = l(p));
        });
        let u = N.shallowRef(""), h = N.shallowRef(""), c = N.shallowRef(void 0), f = N.shallowRef("Point");
        const g = t, d = () => {
          var m;
          const p = c.value ? c.value : a.feature;
          p == null || p.set("name", u.value), p == null || p.set("remark", h.value), p == null || p.set("type", (m = p == null ? void 0 : p.get("type")) != null ? m : a.type), p == null || p.set("position", l(p));
          const v = (p == null ? void 0 : p.getStyle()) || new de({ fill: new ye({ color: "rgba(255, 255, 255, 0.6)" }), stroke: new Ze({ color: "#319FD3", width: 1 }), image: new Rr({ anchor: [0.5, 46], anchorXUnits: "fraction", anchorYUnits: "pixels", src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADdElEQVRYR8WWXYjcVBiG3zfJGb1oq4todXZnVOpsMlbRLtQK1p+CVNAbERQEqUVEVPy58EIpqFAQwasqVOhFWdrSIuiNUAQR/3ApVIr0hzozu93KJtktsgWRxeLmJPlKho52JzOTZIo2t+d7v/c5b76cHOIqP7zK/igEIADPlNWGyJBHQY4DHANlUcBZI4p/MubDqRqwXGRTuQAEUM0x9TIMvkXg1r4GIosA3rE9PUlA8oBkAsyO4Dq9Sh0GuTlPw3aN4Os1UfBUeQEXsjQDAZKdtypqCuR9WY3S63JcLelH1v2BPwdpBwI0q+pjgG8UN+8o5Ijt6gcJxP169AVorsXtKKkZkGYvsQDnKDIPYEO/mrYuxnOOHxwsDNCoqj0EX0oJRc4jlmec+fD7ZK09I6vVdgA7Aa7prhfBdN0L7EIAApjNqlokOHK5UCCBBU7U3OB0d8NWRW0U4CjIVKomsL7mBr/2guj5ChqjGKdZaqV3I7vrnn6t324aFXWI5LM9UnvB8fRkboDpivVQTOPHbgEh22xXHxgAsJ1kykgQ76i74Ye5AZqj1haYxncpQSwvOr7e2w+gVVXbBNyXSq4owGwZVW2V5nq8gs/qnk5HfKmwVVWfCPh6Krk4esL2o69yJ5AUNiqlaRK1FSIRgfBexw9OdjdL5gamOkWw1DW4emRZj9z8O/4qCGDtII0P0iJJTrb31JLe1znlZsashyPyc5A3pgcQXzpe8GShzzApPnsT1i5fo3ySVk+xSCTEcYBlArf0NYhlk+3rnwsDJIJWRU0KmRwyQz0i8k3d01sHiQf+C9rDaKqzA4/aAd2NWO4f9/XRoQESYbOidoN8dYgIvnDc4OksXeZ9oDGKG2iqMwCvz2r277osW6Gu3bEAL0uTCXAphVdAfprVrLPOOH7f9sOdeepzASR3wWZVHSM4kaNpy3aDuwiEOWrzX0pnymoiMnGs199uxcETx1vqfvhDHvOkJlcCnWbNMbULBt/s11xE9tc9/Xxe88IAv92Ga/+OSidIjHebCDDHC8Hdznks/WcA7cNpVN0jBn4BaayIPowfqC+ER4qYF07gn1dRsd4Fjcun/CPHDd4uaj40QPJVtKqlwwAeB+Rb29WPEYj+N4DEKLmMBqvUlBh6651zODeM+dAJdMxOA6X1QDCs+RUDXIlxR3sRcjswMD6XvKYAAAAASUVORK5CYII=" }) }), y = (v == null ? void 0 : v.getText()) || new Ei({ font: "16px Calibri,sans-serif", fill: new ye({ color: "#000" }), padding: [2, 2, 2, 2], backgroundFill: new ye({ color: "#fff" }) });
          y.setText(u.value), v.setText(y), p == null || p.setStyle(v), g("save", { name: u.value, remark: h.value, type: f.value, feature: p }), s.value = void 0, u.value = "", h.value = "";
        }, A = (p) => i.forEachFeatureAtPixel(p, (v) => v, { layerFilter: (v) => {
          var y;
          return v.get("id") === ((y = r.value) == null ? void 0 : y.get("id"));
        } });
        return N.onMounted(() => {
          r.value && i.on("singleclick", (p) => {
            const v = A(p.pixel);
            if (v) {
              c.value = v;
              const y = v.get("type"), m = v.get("name"), _ = v.get("remark");
              c.value.set("type", y), c.value.set("name", m), f.value = y, u.value = m, h.value = _, v.get("position") && (s.value = v.get("position"));
            }
          });
        }), (p, v) => {
          const y = N.resolveComponent("ol-overlay");
          return N.openBlock(), N.createBlock(y, { "class-name": a.pinClass, position: N.unref(s), offset: [0, -30], positioning: "bottom-center" }, { default: N.withCtx(() => [N.createElementVNode("div", { class: N.normalizeClass(["title", a.titleClass]) }, "" + N.toDisplayString(o[N.unref(f)]), 3), N.createElementVNode("div", { class: N.normalizeClass(["body", a.bodyClass]) }, [N.createElementVNode("div", lpt, [v[2] || (v[2] = N.createElementVNode("label", { for: "name" }, ":", -1)), N.withDirectives(N.createElementVNode("input", { "onUpdate:modelValue": v[0] || (v[0] = (m) => N.isRef(u) ? u.value = m : u = m), type: "text" }, null, 512), [[N.vModelText, N.unref(u)]])]), N.createElementVNode("div", upt, [v[3] || (v[3] = N.createElementVNode("label", { for: "remark" }, ":", -1)), N.withDirectives(N.createElementVNode("input", { "onUpdate:modelValue": v[1] || (v[1] = (m) => N.isRef(h) ? h.value = m : h = m), type: "text" }, null, 512), [[N.vModelText, N.unref(h)]])])], 2), N.createElementVNode("div", { class: N.normalizeClass(["footer", a.footerClass]) }, [N.createElementVNode("button", { class: "btn-ok", onClick: d }, "")], 2)]), _: 1 }, 8, ["class-name", "position"]);
        };
      } }), DS = N.defineComponent({ name: "OlDraw", props: { type: { type: String, default: "" }, snap: { type: Boolean, default: false }, modify: { type: Boolean, default: false }, pin: { type: Boolean, default: false }, pinClass: { type: String, default: "" }, pinTitleClass: { type: [Array, String], default: "" }, pinBodyClass: { type: [Array, String], default: "" }, pinFooterClass: { type: [Array, String], default: "" } }, emits: ["drawend", "drawstart", "modifyend", "modifystart", "savePin"], setup(n, { expose: t, emit: e }) {
        const i = N.inject("VMap"), r = N.unref(i).map, a = N.inject("ParentLayer");
        let o = N.shallowRef(), s, l, u = N.shallowRef(void 0);
        const h = (v) => {
          v.on("drawend", (y) => {
            e("drawend", y), n.pin && (u.value = y.feature, f());
          }), v.on("drawstart", (y) => {
            e("drawstart", y);
          });
        }, c = (v) => {
          v.on("modifyend", (y) => {
            e("modifyend", y);
          }), v.on("modifystart", (y) => {
            e("modifystart", y);
          });
        }, f = () => {
          o.value && r.removeInteraction(o.value), l && r.removeInteraction(l), s && r.removeInteraction(s);
        }, g = () => {
          if (f(), u.value = void 0, n.type) {
            let v;
            const y = a.value.getSource();
            let m;
            n.type === "Rectangle" ? (m = "Circle", v = { source: y, type: m, geometryFunction: PJ() }) : n.type === "Square" ? (m = "Circle", v = { source: y, type: m, geometryFunction: LJ(4) }) : (m = n.type, v = { source: y, type: m }), o.value = new UN(v), o.value.set("interactions_name", "Draw"), r.addInteraction(o.value), h(o.value), n.snap && (l = new zJ({ source: y }), l.set("interactions_name", "Snap"), r.addInteraction(l)), n.modify && (s = new gw({ source: y }), s.set("interactions_name", "Modify"), r.addInteraction(s), c(s));
          }
        }, d = () => {
          u.value = void 0, a.value.getSource().clear();
        }, A = (v) => {
          var y;
          (y = o.value) == null || y.setActive(v);
        };
        return N.watch(() => n.type, () => {
          u.value = void 0, g();
        }), N.onMounted(() => {
          g();
        }), t({ clear: d, setActive: A }), { render: () => {
          if (n.pin) {
            let v;
            if (!n.type) return null;
            if (n.type === "Point") v = "Point";
            else if (["Polygon", "Rectangle", "Square", "Circle"].includes(n.type)) v = "Polygon";
            else return null;
            return N.h("div", {}, [N.h(hpt, { name: "default", type: v, feature: u.value, pinClass: n.pinClass, titleClass: n.pinTitleClass, bodyClass: n.pinBodyClass, footerClass: n.pinFooterClass, onSave: (y) => {
              e("savePin", y);
            } })]);
          } else return null;
        }, clear: d, setActive: A };
      }, render() {
        return this.render();
      } }), cpt = (n) => n.component(DS.name || "OlDraw", DS), RS = N.defineComponent({ name: "OlMeasure", props: { type: { type: String, default: "" }, showSegments: { type: Boolean, default: false }, clearPrevious: { type: Boolean, default: false } }, setup(n, { expose: t, emit: e }) {
        const i = N.inject("VMap"), r = N.unref(i).map, a = N.inject("ParentLayer"), o = N.unref(a).getSource(), s = new de({ fill: new ye({ color: "rgba(255, 255, 255, 0.2)" }), stroke: new Ze({ color: "rgba(0, 0, 0, 0.5)", lineDash: [10, 10], width: 2 }), image: new Mr({ radius: 5, stroke: new Ze({ color: "rgba(0, 0, 0, 0.7)" }), fill: new ye({ color: "rgba(255, 255, 255, 0.2)" }) }) }), l = new de({ text: new Ei({ font: "14px Calibri,sans-serif", fill: new ye({ color: "rgba(255, 255, 255, 1)" }), backgroundFill: new ye({ color: "rgba(0, 0, 0, 0.7)" }), padding: [3, 3, 3, 3], textBaseline: "bottom", offsetY: -15 }), image: new Nu({ radius: 8, points: 3, angle: Math.PI, displacement: [0, 10], fill: new ye({ color: "rgba(0, 0, 0, 0.7)" }) }) }), u = new de({ text: new Ei({ font: "12px Calibri,sans-serif", fill: new ye({ color: "rgba(255, 255, 255, 1)" }), backgroundFill: new ye({ color: "rgba(0, 0, 0, 0.4)" }), padding: [2, 2, 2, 2], textAlign: "left", offsetX: 15 }) }), h = new de({ image: new Mr({ radius: 5, stroke: new Ze({ color: "rgba(0, 0, 0, 0.7)" }), fill: new ye({ color: "rgba(0, 0, 0, 0.4)" }) }), text: new Ei({ text: "", font: "12px Calibri,sans-serif", fill: new ye({ color: "rgba(255, 255, 255, 1)" }), backgroundFill: new ye({ color: "rgba(0, 0, 0, 0.7)" }), padding: [2, 2, 2, 2], textAlign: "left", offsetX: 15 }) }), c = new de({ text: new Ei({ font: "12px Calibri,sans-serif", fill: new ye({ color: "rgba(255, 255, 255, 1)" }), backgroundFill: new ye({ color: "rgba(0, 0, 0, 0.4)" }), padding: [2, 2, 2, 2], textBaseline: "bottom", offsetY: -12 }), image: new Nu({ radius: 6, points: 3, angle: Math.PI, displacement: [0, 8], fill: new ye({ color: "rgba(0, 0, 0, 0.4)" }) }) }), f = [c];
        let g, d, A;
        const p = function(x) {
          const w = qL(x, { projection: N.unref(r).getView().getProjection() });
          let C;
          return w > 100 ? C = Math.round(w / 1e3 * 100) / 100 + " km" : C = Math.round(w * 100) / 100 + " m", C;
        }, v = function(x) {
          const w = HL(x, { projection: N.unref(r).getView().getProjection() });
          let C;
          return w > 1e4 ? C = Math.round(w / 1e6 * 100) / 100 + " km" : C = Math.round(w * 100) / 100 + " m", C;
        }, y = (x, w, C, S) => {
          var k, P, F;
          const b = [], B = x.getGeometry();
          if (!B) return new de();
          const T = B.getType();
          let D, R, L;
          if ((!C || C === T || T === "Point") && (b.push(s), T === "Polygon" ? (D = B.getInteriorPoint(), R = v(B), L = new be(B.getCoordinates()[0])) : T === "LineString" && (D = new Oe(B.getLastCoordinate()), R = p(B), L = B)), w && L) {
            let Q = 0;
            if (!L) return new de();
            L.forEachSegment(function(z, j) {
              const $ = new be([z, j]), G = p($);
              f.length - 1 < Q && f.push(c.clone());
              const tt = new Oe($.getCoordinateAt(0.5)), J = f[Q];
              if (J) {
                J.setGeometry(tt);
                const et = J.getText();
                et == null || et.setText(G), b.push(f[Q]), Q++;
              }
            });
          }
          if (R) {
            l.setGeometry(D);
            const Q = l.getText();
            Q == null || Q.setText(R), b.push(l);
          }
          return S && T === "Point" && !((P = (k = d.getOverlay()) == null ? void 0 : k.getSource()) != null && P.getFeatures().length) && (A = B, (F = u.getText()) == null || F.setText(S), b.push(u)), b;
        }, m = () => {
          const x = n.type === "area" ? "Polygon" : "LineString", w = " " + (n.type === "area" ? "" : ""), C = "";
          let S = C;
          g = new UN({ source: o, type: x, style: function(b) {
            return y(b, n.showSegments, x, S);
          } }), g.on("drawstart", function() {
            n.clearPrevious && o.clear(), d.setActive(false), S = w;
          }), g.on("drawend", function() {
            h.setGeometry(A), d.setActive(true), r.once("pointermove", function() {
              h.setGeometry("");
            }), S = C;
          }), d.setActive(true), r.addInteraction(g);
        }, _ = () => {
          d = new gw({ source: o, style: h }), a.value.setStyle((x) => y(x, n.showSegments)), r.addInteraction(d), n.type && m();
        }, E = () => {
          a.value.getSource().clear();
        }, I = (x) => {
          g.setActive(x);
        };
        return N.watch(() => n.type, (x) => {
          r.removeInteraction(g), x && m();
        }), N.onMounted(() => {
          _();
        }), t({ clear: E, setActive: I }), { clear: E, setActive: I };
      }, render() {
        return null;
      } }), fpt = (n) => n.component(RS.name || "OlMeasure", RS);
      var m3 = { exports: {} };
      (function(n) {
        (function() {
          function t(s, l) {
            var u = s.x - l.x, h = s.y - l.y;
            return u * u + h * h;
          }
          function e(s, l, u) {
            var h = l.x, c = l.y, f = u.x - h, g = u.y - c;
            if (f !== 0 || g !== 0) {
              var d = ((s.x - h) * f + (s.y - c) * g) / (f * f + g * g);
              d > 1 ? (h = u.x, c = u.y) : d > 0 && (h += f * d, c += g * d);
            }
            return f = s.x - h, g = s.y - c, f * f + g * g;
          }
          function i(s, l) {
            for (var u = s[0], h = [u], c, f = 1, g = s.length; f < g; f++) c = s[f], t(c, u) > l && (h.push(c), u = c);
            return u !== c && h.push(c), h;
          }
          function r(s, l, u, h, c) {
            for (var f = h, g, d = l + 1; d < u; d++) {
              var A = e(s[d], s[l], s[u]);
              A > f && (g = d, f = A);
            }
            f > h && (g - l > 1 && r(s, l, g, h, c), c.push(s[g]), u - g > 1 && r(s, g, u, h, c));
          }
          function a(s, l) {
            var u = s.length - 1, h = [s[0]];
            return r(s, 0, u, l, h), h.push(s[u]), h;
          }
          function o(s, l, u) {
            if (s.length <= 2) return s;
            var h = l !== void 0 ? l * l : 1;
            return s = u ? s : i(s, h), s = a(s, h), s;
          }
          n.exports = o, n.exports.default = o;
        })();
      })(m3);
      var gpt = m3.exports;
      const dpt = UA(gpt);
      class Wm {
        constructor(t, e) {
          Kt(this, "min", { x: 0, y: 0 });
          Kt(this, "max", { x: 0, y: 0 });
          this.min = t, this.max = e;
        }
        intersects(t) {
          const e = this.min, i = this.max, r = t.min, a = t.max;
          return a.x <= e.x || r.x >= i.x || a.y <= e.y || r.y >= i.y;
        }
      }
      class _3 extends Kr {
        constructor(e) {
          var r;
          const i = Object.assign({}, e);
          delete i.map;
          super(i);
          Kt(this, "map");
          Kt(this, "pointsArr", []);
          Kt(this, "zoom", 1);
          Kt(this, "textBounds", []);
          Kt(this, "styleOptions", { fillColor: "rgb(26,58,91,0.6)", strokeColor: "rgb(26,58,91)", textColor: "white", fontCss: "bolder 15px sans-serif", boxWidth: 50 });
          Kt(this, "textViewCom", []);
          Kt(this, "source");
          this.map = e.map, this.pointsArr = e.pointsArr ? e.pointsArr : this.pointsArr, this.zoom = e.zoom ? e.zoom : 1, this.styleOptions = e.styleOptions ? e.styleOptions : this.styleOptions, this.source = this.getSource() || new $r(), this.setSource(this.source), (r = this.map) == null || r.on("moveend", (a) => {
            this.moveEnd();
          });
        }
        moveEnd() {
          var i, r;
          (((r = (i = this.map) == null ? void 0 : i.getView()) == null ? void 0 : r.getZoom()) || 0) >= this.zoom ? this.drawText().then(() => {
            this.source.clear();
            const a = this.get("textComponent");
            a && a.length > 0 && a.forEach((o) => {
              var s, l;
              (s = this.getSource()) == null || s.addFeature(o.polyline), (l = this.getSource()) == null || l.addFeature(o.textBack);
            });
          }) : this.source.clear();
        }
        drawText() {
          return Rt(this, null, function* () {
            var a;
            const e = this.styleOptions, r = document.createElement("canvas").getContext("2d");
            r && (e.fontCss && (r.font = e.fontCss), (a = this.map) == null || a.once("postrender", () => Rt(this, null, function* () {
              const o = [];
              this.pointsArr.forEach((s) => {
                var h, c, f, g, d, A, p, v;
                const l = JL(s.position, "EPSG:4326"), u = ((h = this.map) == null ? void 0 : h.getPixelFromCoordinate(l)) || [0, 0];
                if (Wr(((c = this.map) == null ? void 0 : c.getView().calculateExtent()) || [0, 0], l)) {
                  s.text = s.text || "";
                  let y = e.boxWidth || Math.ceil(r.measureText(s.text).width);
                  y += 30;
                  const m = u[0] + 10, _ = u[0] + y, E = u[1] - 40, I = u[1] - 10, x = [m, Number(((E + I) / 2).toFixed(0))], w = { x: m, y: E }, C = { x: _, y: I }, S = new Wm(w, C), b = u[0] - y, B = u[0] - 10, T = u[1] - 40, D = u[1] - 10, R = [B, Number(((T + D) / 2).toFixed(0))], L = { x: b, y: T }, k = { x: B, y: D }, P = new Wm(L, k), F = u[0] - y, Q = u[0] - 10, z = u[1] + 10, j = u[1] + 40, $ = [Q, Number(((z + j) / 2).toFixed(0))], G = { x: F, y: z }, tt = { x: Q, y: j }, J = new Wm(G, tt), et = u[0] + 10, nt = u[0] + y, gt = u[1] + 10, H = u[1] + 40, W = [et, Number(((gt + H) / 2).toFixed(0))], it = { x: et, y: gt }, kt = { x: nt, y: H }, vt = new Wm(it, kt), St = { bound: S, minx: m, miny: E, maxx: _, maxy: I, polylineCenter: x }, bt = { bound: P, minx: b, miny: T, maxx: B, maxy: D, polylineCenter: R }, Ee = { bound: J, minx: F, miny: z, maxx: Q, maxy: j, polylineCenter: $ }, rn = { bound: vt, minx: et, miny: gt, maxx: nt, maxy: H, polylineCenter: W }, Ie = /* @__PURE__ */ new Map([["rightTopBounds", St], ["leftTopBounds", bt], ["leftBomBounds", Ee], ["rightBomBounds", rn]]);
                  let fn = true, an = 0, wr = 0, Cr = 0, Jo = 0, kn = [0, 0], Td = "";
                  for (const [Dy, eo] of Ie) {
                    for (let Ld = 0; Ld < this.textBounds.length && (fn = this.textBounds[Ld].intersects(eo.bound), !!fn); Ld++) ;
                    fn && (Td = Dy);
                  }
                  if (!fn) return;
                  for (const [Dy, eo] of Ie) Dy === Td && (this.textBounds.push(eo.bound), kn = eo.polylineCenter, an = eo.minx, wr = eo.miny, Cr = eo.maxx, Jo = eo.maxy);
                  const Ty = ((f = this.map) == null ? void 0 : f.getCoordinateFromPixel([an, wr])) || [], Md = ((g = this.map) == null ? void 0 : g.getCoordinateFromPixel([Cr, wr])) || [], Dd = ((d = this.map) == null ? void 0 : d.getCoordinateFromPixel([Cr, Jo])) || [], _L = ((A = this.map) == null ? void 0 : A.getCoordinateFromPixel([an, Jo])) || [], Rd = new xe(new Sn([[Ty, Md, Dd, _L]]));
                  Rd.setStyle(new de({ text: new Ei({ font: e.fontCss, fill: new ye({ color: e.textColor }), backgroundFill: new ye({ color: e.fillColor }), backgroundStroke: new Ze({ color: e.strokeColor }), offsetY: 0.5, overflow: true }) })), (p = Rd.getStyle().getText()) == null || p.setText(s.text);
                  const My = ((v = this.map) == null ? void 0 : v.getCoordinateFromPixel(kn)) || [0, 0], OE = new xe(new be([s.position, My]));
                  OE.setStyle(new de({ stroke: new Ze({ color: e.strokeColor }) })), o.push({ textBack: Rd, polyline: OE, text: s.text });
                }
              }), this.set("textComponent", o);
            })));
          });
        }
        keepVisible() {
          if (this.textViewCom = this.get("invisible"), !!this.textViewCom) for (let e = this.textViewCom.length - 1; e >= 0; e--) {
            const i = this.textViewCom[e];
            this.textVisibility(i.text, false);
          }
        }
        textVisibility(e, i) {
          var s, l, u, h, c;
          let r = this.getObjectByText(e);
          this.textViewCom = this.get("invisible");
          let a = false, o = 0;
          if (this.textViewCom instanceof Array) for (let f = ((s = this.textViewCom) == null ? void 0 : s.length) - 1; f >= 0; f--) {
            let g = this.textViewCom[f];
            e === g.text && (a = true, o = f);
          }
          if (r.length > 0) for (let f = r.length - 1; f >= 0; f--) {
            let g = r[f];
            if (!i) this.textViewCom instanceof Array ? !a && this.textViewCom.push(g) : this.set("invisible", [g]), (l = g.textBack) == null || l.setStyle(void 0), (u = g.polyline) == null || u.setStyle(void 0);
            else if (this.textViewCom instanceof Array && a) {
              this.textViewCom.splice(o, 1);
              let d = this.getObjectByText(g.text);
              for (let A = d.length - 1; A >= 0; A--) (h = d[A].textBack) == null || h.setStyle(void 0), (c = d[A].polyline) == null || c.setStyle(void 0);
            }
          }
          else i ? a && this.textViewCom.splice(o, 1) : this.textViewCom instanceof Array ? !a && this.textViewCom.push({ text: e }) : this.set("invisible", [{ text: e }]);
        }
        getObjectByText(e) {
          const i = this.get("textComponent"), r = [];
          for (let a = (i == null ? void 0 : i.length) - 1; a >= 0; a--) {
            const o = i[a];
            o.text === e && r.push(o);
          }
          return r;
        }
      }
      var kr = 63710088e-1, I3 = { centimeters: kr * 100, centimetres: kr * 100, degrees: 360 / (2 * Math.PI), feet: kr * 3.28084, inches: kr * 39.37, kilometers: kr / 1e3, kilometres: kr / 1e3, meters: kr, metres: kr, miles: kr / 1609.344, millimeters: kr * 1e3, millimetres: kr * 1e3, nauticalmiles: kr / 1852, radians: 1, yards: kr * 1.0936 };
      function E3(n, t, e = {}) {
        const i = { type: "Feature" };
        return (e.id === 0 || e.id) && (i.id = e.id), e.bbox && (i.bbox = e.bbox), i.properties = t || {}, i.geometry = n, i;
      }
      function Apt(n, t, e = {}) {
        if (!n) throw new Error("coordinates is required");
        if (!Array.isArray(n)) throw new Error("coordinates must be an Array");
        if (n.length < 2) throw new Error("coordinates must be at least 2 numbers long");
        if (!x3(n[0]) || !x3(n[1])) throw new Error("coordinates must contain numbers");
        return E3({ type: "Point", coordinates: n }, t, e);
      }
      function np(n, t, e = {}) {
        if (n.length < 2) throw new Error("coordinates must be an array of two or more positions");
        return E3({ type: "LineString", coordinates: n }, t, e);
      }
      function ppt(n, t = "kilometers") {
        const e = I3[t];
        if (!e) throw new Error(t + " units is invalid");
        return n * e;
      }
      function vpt(n, t = "kilometers") {
        const e = I3[t];
        if (!e) throw new Error(t + " units is invalid");
        return n / e;
      }
      function LS(n) {
        return n % (2 * Math.PI) * 180 / Math.PI;
      }
      function Oa(n) {
        return n % 360 * Math.PI / 180;
      }
      function x3(n) {
        return !isNaN(n) && n !== null && !Array.isArray(n);
      }
      function ypt(n) {
        return n !== null && typeof n == "object" && !Array.isArray(n);
      }
      function ip(n) {
        if (!n) throw new Error("coord is required");
        if (!Array.isArray(n)) {
          if (n.type === "Feature" && n.geometry !== null && n.geometry.type === "Point") return [...n.geometry.coordinates];
          if (n.type === "Point") return [...n.coordinates];
        }
        if (Array.isArray(n) && n.length >= 2 && !Array.isArray(n[0]) && !Array.isArray(n[1])) return [...n];
        throw new Error("coord must be GeoJSON Point or an Array of numbers");
      }
      function PS(n, t, e = {}) {
        if (e.final === true) return mpt(n, t);
        const i = ip(n), r = ip(t), a = Oa(i[0]), o = Oa(r[0]), s = Oa(i[1]), l = Oa(r[1]), u = Math.sin(o - a) * Math.cos(l), h = Math.cos(s) * Math.sin(l) - Math.sin(s) * Math.cos(l) * Math.cos(o - a);
        return LS(Math.atan2(u, h));
      }
      function mpt(n, t) {
        let e = PS(t, n);
        return e = (e + 180) % 360, e;
      }
      function w3(n, t, e, i = {}) {
        const r = ip(n), a = Oa(r[0]), o = Oa(r[1]), s = Oa(e), l = vpt(t, i.units), u = Math.asin(Math.sin(o) * Math.cos(l) + Math.cos(o) * Math.sin(l) * Math.cos(s)), h = a + Math.atan2(Math.sin(s) * Math.sin(l) * Math.cos(o), Math.cos(l) - Math.sin(o) * Math.sin(u)), c = LS(h), f = LS(u);
        return Apt([c, f], i.properties);
      }
      function _pt(n, t, e = {}) {
        var i = ip(n), r = ip(t), a = Oa(r[1] - i[1]), o = Oa(r[0] - i[0]), s = Oa(i[1]), l = Oa(r[1]), u = Math.pow(Math.sin(a / 2), 2) + Math.pow(Math.sin(o / 2), 2) * Math.cos(s) * Math.cos(l);
        return ppt(2 * Math.atan2(Math.sqrt(u), Math.sqrt(1 - u)), e.units);
      }
      function Ipt(n, t, e, i) {
        if (i = i || {}, !ypt(i)) throw new Error("options is invalid");
        var r, a = [];
        if (n.type === "Feature") r = n.geometry.coordinates;
        else if (n.type === "LineString") r = n.coordinates;
        else throw new Error("input must be a LineString Feature or Geometry");
        for (var o = r.length, s = 0, l, u, h, c = 0; c < r.length && !(t >= s && c === r.length - 1); c++) {
          if (s > t && a.length === 0) {
            if (l = t - s, !l) return a.push(r[c]), np(a);
            u = PS(r[c], r[c - 1]) - 180, h = w3(r[c], l, u, i), a.push(h.geometry.coordinates);
          }
          if (s >= e) return l = e - s, l ? (u = PS(r[c], r[c - 1]) - 180, h = w3(r[c], l, u, i), a.push(h.geometry.coordinates), np(a)) : (a.push(r[c]), np(a));
          if (s >= t && a.push(r[c]), c === r.length - 1) return np(a);
          s += _pt(r[c], r[c + 1], i);
        }
        if (s < t && r.length === o) throw new Error("Start position is beyond line");
        var f = r[r.length - 1];
        return np([f, f]);
      }
      class Ept {
        constructor(t) {
          Kt(this, "_operators");
          Kt(this, "_carIcon");
          Kt(this, "_direction");
          Kt(this, "_map");
          Kt(this, "_status");
          Kt(this, "_pathInfo");
          Kt(this, "_bubble");
          Kt(this, "_moving");
          Kt(this, "_tracePointsModePlay");
          Kt(this, "_lineLayer");
          Kt(this, "_movePath");
          Kt(this, "_originPath");
          Kt(this, "_revealLayer");
          Kt(this, "_showTracePoint");
          Kt(this, "_nodesLayer");
          Kt(this, "_moveNodes");
          Kt(this, "_timeStep");
          Kt(this, "_speed");
          Kt(this, "_speedUp");
          Kt(this, "_nowTime");
          Kt(this, "_moveIdx");
          Kt(this, "_animateLayer");
          Kt(this, "_animateLine");
          Kt(this, "_group");
          Kt(this, "_labelVisible");
          Kt(this, "_traceEvent");
          Kt(this, "_simplifyEvent");
          Kt(this, "_eventType");
          Kt(this, "_animateStart");
          Kt(this, "_textLayer");
          Kt(this, "_moveListener");
          Kt(this, "_step");
          Kt(this, "_viewCode");
          Kt(this, "_defaultStyles");
          Kt(this, "_nodesCollection");
          Kt(this, "_nodeInfos");
          Kt(this, "_visible");
          var f;
          t = t || {};
          const e = t.bubble !== void 0 ? t.bubble : false, i = t.showTracePoint ? t.showTracePoint : false, r = t.tracePointsModePlay ? t.tracePointsModePlay : "animation", a = t.mapObj !== void 0 ? t.mapObj : null, o = t.path !== void 0 ? t.path : [], s = t.options, l = Date.now();
          !t.path || t.path.length < 1, this._operators = { carIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAVCAYAAADfLRcdAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDE0IDc5LjE1Njc5NywgMjAxNC8wOC8yMC0wOTo1MzowMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkQ0RkExMTQ2Rjc4NzExRTQ4QkI3QTA2OTk3QzQ4M0IzIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkQ0RkExMTQ3Rjc4NzExRTQ4QkI3QTA2OTk3QzQ4M0IzIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RDRGQTExNDRGNzg3MTFFNDhCQjdBMDY5OTdDNDgzQjMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RDRGQTExNDVGNzg3MTFFNDhCQjdBMDY5OTdDNDgzQjMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz62sMp6AAAFiklEQVR42tRXW2wUVRj+zpmZvc4uS2mhhQK21FLshoKGWkBMSAwQSVBf0QfiJciDLya+8KAx8RJfeJV440GJaDAmGGKUmAASI+GhDQ1a7t1Kb1tot7s7uzvX4z8zC+12bdHVkDjJn5md/c853/nO918GeEDXkfe2f5+9+KzxxeuQap2D/RPn5BO7Aowxns/n9Ju958Q8PjL5yIxz4+KZk86spRLG5Y1T/Zfbf31sz7HN/xqsuIo4THwgStgr8lBtDcwxwQxa0rKB4WkFBcOGpgNSwIFusYoJjv0ATOQYdm9lWBQX4Iz2I8iDxhsGMDSm4mx/FJ3LR/HWi4ASokEmmeYj4UG6K/Tock9jSjxRjG/PRCrADn4SHVi8ttTOGM0sHAguIRKyCSlgF4HsOPDxKY7T4zvQ3NqFYmYSsbp6BEKhe0Bt08LR41/CsSzse34fZEWBbdPGtCxKWhoxeQiNketIhHOYyEgYGAqgc/UU3n5VgbA5iBQyAccWYLKCYLOCnLmLNrhNJHte5h7Ys/ubIlsPjGp3F/3tViOefEVCOCJjSYKjqZ6jdTnwdI+Fp5IppCaAvmsKxiZlondGCYQLJ34S2Ngp0LMBqFMFHmmxUb+U4+DhNpz4WYIlhWgTAWKIAHGOyVQKR98dx45uYoXTKZGRA/S0BT1n+6cd74G8qNlRO76WmNXLHI/R8nXom7U4eqENJdNAUSczdJR0HW/s1HDwhavehMIDx2BbtChj4Ip7hvDeuyYp7pHSe9l//8yBNTh/MwhOALnrf/fu2GhWBnDms+IMWMk1eOM8IxVYsV2QMl9F+Wyg7tV3hTxZZdw5BHZLlzEjdJpEJn0FVeaZEvYtEPF/yyECMivm9+6hDdoOLJKKSTIxPLNh0USXLnN6XiCqluiQE9Ok5dXTfO5/wxN2lb9D7LYtz9ectjat1wioQSdhklmkTdN7NuguB6O4cInhdobPM9oNnAFg1UtSlUc2J+5FuEuw+yyIBTVUqBnsyiYNsUiUpOOza7msEmg3KCUKxOvDAvUJZ/4JBKUlnmdVYHXzL9KnEEioVs1gFbmIjofbEVdjPleOQ8zaHruCIIxO3C/du/nNgDz3tUWpIzAnATNKZ6SFKi3/7UuYXgA9vqkbBun/xuAgbo0OwyESbLKcJhauT+765FIFVuaiapi7e/CAv2hNpUchEhxkclliWcGa1lY82rXBA/Hdt8cxli5XgXnHc28vVWCDgWqhu+kpk5eRiNYG1rTCsOjohRtYrgQoZVmZKciyjKYlDejZOHyfyk+5kM67CllcZeWBvrlAGU2aL0Vq1uwfo1EPbIlqrmGY0F0z3WfK41oOHQ8tlA1cGFE6BFVUeaxcVj2IB4O4NqLWDPb8RZU2WyKAZZBkJQJsUoAVs5Po7lwoGxAeaR01Fp/aXAhWEf5d7Y4X/XPBnusLVOjdomZGzwvPzKJvRsH/bZXcGj8z/sPjEeSKBWJU98B6DNN9enwMmzflEJDn32hxiMOciJKWUovkXw43qrN7g53dWbx/pB/hsIS6ONBRz9DSBGxoc+u1QCot0HtNxshtmbojp6I3OHmaoWudg571lOpiDpKtDhoaOVqWljB+I0xlWYFpu5o1vPSlpdM49OYcRnkchdQUrHLBVBq2UOgpDu9Cwe+6Dsf765Jap9fPubRJ1MgEK7uuj04xfN6XBFOXUe9WBAuGPS3fY5vQ3kmPeRVq6YqVVG4l74Qc26Tw0NCcyCC54g4a4yZ+H4njythibGm5gndeo+ChVtM2yl0XrRmKUC1vYDD4Hmjmc6Ju1W5eUz+rUT9bmK+f/ZH62eycfrbsQRL1+9le6mebqZ/dT6xF3XMmm/KlyWNelvMbGPK3pfpieNvtyP/yS+GBXf/FN9ifAgwAIOzB+qcKmLcAAAAASUVORK5CYII=", speed: 1e3, timeStep: 1, startIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADb0lEQVRYR8WWW4jcZBzFz8lukn1Si5fOjKK20NmEKtoFL+C1IBX0RQQFQeoiIipeHnxQCioURPBJhQo+yFJFEfRFKIKIN1wKFZGqtJPZbgtFTWa7i1LFy+bbyZHsztJ1MpkkI9I85vufc375/798CXGWL57lfFQDENgw/g4Qt0loQroE5CKl410r+WphPJkF55erPFQ5AMFuGO8RiU+TuCwvQNAioWdDuz0DQmVACgE2aeu5E8Y9QODGMoZpjaSP6fx2d8jwzyLNcADBrht/lsC1RUYD1g//ZS/f+itPnB6mHQpQj71XCT45QnhPooOhHdwEIsnzyAXYrMktluExgmODxJIiED8D2JFXszaO5P7Ibb9TGaAee28QfLhfKGhJ1L0du/15ura2R+xpgHsJnpMJkuZCN5isBiCMNYy/mPr3CeNEnOq4R4/0G9bi5jWEdYhgpquJzPaOO390EMTAEVwgr+kYtrMC7Qud4PG8p6nH3rsE7+tfT5A82HHaM6UB6sa/mcKX2fZjd+S03s4DqMXetAVmgkTtiezgpdIANTO505L12QDBQ6HTejMfwN9tAfsz4FUBGtp6KYx7csAI3gudINPi9bpa7L1mgU9kRmDhzs5466PSHUgLG8v+HIhtG0WC1JWuPuW2v+836+2bHwA4/9bAJPYvmxa48EclgLrx9lB8cUAXTgt6/m/b7F8/5WrGu4XC+wQvzLRf+DByW3dVew0BXKQtm8fMxE8ExgceRFAXwGEIDZL1vIAE3es6ztzXlQFWxxB7MwCn88RF9wV9EjnBrmF1Q78F6WaUcU4MO2qHmXexcv2Cc+zQyABrXfD3AXis6Gmzs9cHkRvcU6Qr/B+4WN75MpwHcF6R2Zl1LcM220Ie/7FIUwiQGtTiyUctWK8Xma2vJ9QLHTvYW6a+FAAE1o33DcGpQlOpHTrBFSBWCmuB8j+ljdifEpRCDIVOqJ0dO/iiTHhaU64DPbd67L9C4Kk8c0FvRU7wQNnwygDQ5RONeOI7kM0BJ95J4yRXLrH9+/8HkJ6QcfOqMVjfErQ2Bq1QN5yyg4NVwqt3oOdeM/5zlnBmlwsvh27rmarhIwOsvhWxf4DEHQA+De3W7SDSb0Plq9Im3Oi+9jPqzBqbu5bYiion9wQjA6zqtd0Bj8Sjho8+gv+S2Kf9B1+VRDBEEbAnAAAAAElFTkSuQmCC", endIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADdElEQVRYR8WWXYjcVBiG3zfJGb1oq4todXZnVOpsMlbRLtQK1p+CVNAbERQEqUVEVPy58EIpqFAQwasqVOhFWdrSIuiNUAQR/3ApVIr0hzozu93KJtktsgWRxeLmJPlKho52JzOTZIo2t+d7v/c5b76cHOIqP7zK/igEIADPlNWGyJBHQY4DHANlUcBZI4p/MubDqRqwXGRTuQAEUM0x9TIMvkXg1r4GIosA3rE9PUlA8oBkAsyO4Dq9Sh0GuTlPw3aN4Os1UfBUeQEXsjQDAZKdtypqCuR9WY3S63JcLelH1v2BPwdpBwI0q+pjgG8UN+8o5Ijt6gcJxP169AVorsXtKKkZkGYvsQDnKDIPYEO/mrYuxnOOHxwsDNCoqj0EX0oJRc4jlmec+fD7ZK09I6vVdgA7Aa7prhfBdN0L7EIAApjNqlokOHK5UCCBBU7U3OB0d8NWRW0U4CjIVKomsL7mBr/2guj5ChqjGKdZaqV3I7vrnn6t324aFXWI5LM9UnvB8fRkboDpivVQTOPHbgEh22xXHxgAsJ1kykgQ76i74Ye5AZqj1haYxncpQSwvOr7e2w+gVVXbBNyXSq4owGwZVW2V5nq8gs/qnk5HfKmwVVWfCPh6Krk4esL2o69yJ5AUNiqlaRK1FSIRgfBexw9OdjdL5gamOkWw1DW4emRZj9z8O/4qCGDtII0P0iJJTrb31JLe1znlZsashyPyc5A3pgcQXzpe8GShzzApPnsT1i5fo3ySVk+xSCTEcYBlArf0NYhlk+3rnwsDJIJWRU0KmRwyQz0i8k3d01sHiQf+C9rDaKqzA4/aAd2NWO4f9/XRoQESYbOidoN8dYgIvnDc4OksXeZ9oDGKG2iqMwCvz2r277osW6Gu3bEAL0uTCXAphVdAfprVrLPOOH7f9sOdeepzASR3wWZVHSM4kaNpy3aDuwiEOWrzX0pnymoiMnGs199uxcETx1vqfvhDHvOkJlcCnWbNMbULBt/s11xE9tc9/Xxe88IAv92Ga/+OSidIjHebCDDHC8Hdznks/WcA7cNpVN0jBn4BaayIPowfqC+ER4qYF07gn1dRsd4Fjcun/CPHDd4uaj40QPJVtKqlwwAeB+Rb29WPEYj+N4DEKLmMBqvUlBh6651zODeM+dAJdMxOA6X1QDCs+RUDXIlxR3sRcjswMD6XvKYAAAAASUVORK5CYII=", showInfoWin: false, arrowPixel: 0.2, textStyle: {} }, this._operators = st(st({}, this._operators), s);
          const u = new ye({ color: "rgba(255,255,255,0.4)" }), h = new Ze({ color: "#3399CC", width: 1.25 });
          this._defaultStyles = [new de({ image: new Mr({ fill: u, stroke: h, radius: 5 }), fill: u, stroke: h })], this._nodesCollection = null, this._nodeInfos = [];
          const c = new Rr({ src: this._operators.carIcon, scale: 1, anchor: [0.5, 0.5], offset: [0, 0] });
          c.load(), this._carIcon = new de({ image: c }), this._direction = 0, a && (this._map = a), this._viewCode = (f = this._map) == null ? void 0 : f.getView().getProjection().getCode(), this._status = "stop", this._pathInfo = o, this._bubble = e, this._moving = false, this._tracePointsModePlay = r, this._visible = t.visible, this._lineLayer = new Kr({ source: new $r({ features: [], strategy: _0 }), properties: { vzBelong: "vzTrackPath", vzTime: l } }), this._movePath = [], this._lineLayer.set("projection", this._viewCode, true), this._lineLayer.set("track-type", "trackPath"), this._movePath = [], this._originPath = null, this._revealLayer = new Kr({ source: new $r({ features: [], strategy: _0 }), properties: { vzBelong: "vzTrackPath", vzTime: l } }), this._revealLayer.set("projection", this._viewCode, true), this._revealLayer.set("track-type", "trackReveal"), this._showTracePoint = i, this._nodesLayer = new Kr({ source: new $r({ features: [], strategy: _0 }), style: null, properties: { vzBelong: "vzTrackPath", vzTime: l }, visible: this._visible }), this._nodesLayer.set("projection", this._viewCode, true), this._nodesLayer.set("track-type", "trackNodes"), this._nodesLayer.setVisible(this._showTracePoint), this._moveNodes = [], this._speed = this._operators.speed, this._timeStep = this._operators.timeStep, this._speedUp = 1, this._nowTime = null, this._moveIdx = 1, this._animateLayer = new Kr({ source: new $r({ features: [], strategy: _0 }), style: new de({ stroke: new Ze({ color: "red", width: 2 }) }), properties: { vzBelong: "vzTrackPath", vzTime: l } }), this._animateLayer.set("projection", this._viewCode, true), this._animateLayer.set("track-type", "trackAnimate"), this._animateLine = new xe({ geometry: new be([]) }), this._group = new Pr({ layers: [this._lineLayer, this._revealLayer, this._nodesLayer, this._animateLayer], zIndex: 99, properties: { type: "vzTrackPath", vzTime: l }, visible: this._visible }), this._labelVisible = t.labelVisible || false, a == null || a.addLayer(this._group), this._traceEvent = a == null ? void 0 : a.on(["singleclick", "pointermove"], (g) => {
            this.eventListener(g);
          }), this._eventType = ["nodeClick", "nodeMouseover", "nodeMouseout", "pathClick", "pathMouseover", "pathMouseout", "move"], this._animateStart = new xe(), this._textLayer = null, this._moveListener = null, this._step = 0, this._simplifyEvent = a == null ? void 0 : a.getView().on("change:resolution", (g) => {
            Number.isInteger(g.target.getZoom()) && this.simplifyOpera(g);
          }), this.initLinesAndMarkers();
        }
        simplifyOpera(t) {
          var h, c;
          let e;
          const i = t.target.getProjection().getCode(), r = this._viewCode !== i, a = t.target.getResolution();
          e = this._nodesCollection ? this._nodesCollection.map((f) => {
            var d, A;
            if (r && f.get("isSimplify") === false) {
              const p = (d = f.getGeometry()) == null ? void 0 : d.transform(this._viewCode, i);
              p instanceof Oe && f.setGeometry(p);
            }
            const g = (A = f.getGeometry()) == null ? void 0 : A.getCoordinates();
            return { x: g[0] / a, y: g[1] / a, idx: f.get("node_idx") };
          }) : [], r && (this._viewCode = i);
          const o = dpt(e, 2, false), s = [], l = [];
          o.forEach((f) => {
            s.push([f.x * a, f.y * a]), l.push(f == null ? void 0 : f.idx);
          }), this._originPath instanceof be && this._originPath.setCoordinates(s), !this._moving && this._status !== "moving" && this._moveListener !== null && this._tracePointsModePlay === "animation" && this._originPath instanceof be && ((h = this._animateLine.getGeometry()) == null || h.setCoordinates(s.slice(0, l.indexOf(this._moveIdx) + 1).concat([this._animateStart.getGeometry().getCoordinates()]))), (c = this._nodesLayer.getSource()) == null || c.clear(), new Promise((f) => {
            var g;
            this._nodeInfos = [], this._nodesLayer.getVisible() && ((g = this._nodesCollection) == null || g.forEach((d, A) => {
              d.set("isSimplify", false), d.setStyle(null), l.includes(A + 1) && (d.set("isSimplify", true), d.setStyle(this._defaultStyles), this._nodeInfos.push(d));
            })), f(this._nodeInfos);
          }).then((f) => {
            var g;
            (g = this._nodesLayer.getSource()) == null || g.addFeatures(f);
          });
        }
        eventListener(t) {
          var i, r, a, o, s, l, u, h, c;
          if ((i = this._map) == null ? void 0 : i.hasFeatureAtPixel(t.pixel, { layerFilter: function(f) {
            return f.get("track-type") === "trackPath" || f.get("track-type") === "trackNodes";
          }, hitTolerance: 0 })) {
            this._moveNodes = ((r = this._map) == null ? void 0 : r.getFeaturesAtPixel(t.pixel, { layerFilter: function(d) {
              return d.get("track-type") === "trackNodes";
            }, hitTolerance: 0 })) || [], this._movePath = ((a = this._map) == null ? void 0 : a.getFeaturesAtPixel(t.pixel, { layerFilter: function(d) {
              return d.get("track-type") === "trackPath";
            }, hitTolerance: 0 })) || [];
            const f = this._moveNodes.map((d) => d.getProperties()), g = this._movePath.map((d) => d);
            switch (t.type) {
              case "singleclick":
                f.length >= 1 && ((o = this._map) == null || o.dispatchEvent({ type: "nodeClick", target: this._bubble ? [f[0]] : f, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
                  throw new Error("Function not implemented.");
                }, stopPropagation: function() {
                  throw new Error("Function not implemented.");
                } })), g.length >= 1 && ((s = this._map) == null || s.dispatchEvent({ type: "pathClick", target: this._bubble ? [g[0]] : g, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
                  throw new Error("Function not implemented.");
                }, stopPropagation: function() {
                  throw new Error("Function not implemented.");
                } }));
                break;
              case "pointermove":
                f.length >= 1 && ((l = this._map) == null || l.dispatchEvent({ type: "nodeMouseover", target: this._bubble ? [f[0]] : f, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
                  throw new Error("Function not implemented.");
                }, stopPropagation: function() {
                  throw new Error("Function not implemented.");
                } })), g.length >= 1 && ((u = this._map) == null || u.dispatchEvent({ type: "pathMouseover", target: this._bubble ? [g[0]] : g, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
                  throw new Error("Function not implemented.");
                }, stopPropagation: function() {
                  throw new Error("Function not implemented.");
                } }));
                break;
            }
          } else {
            const f = this._moveNodes.map((d) => d.getProperties());
            this._moveNodes.length > 0 && this._moveNodes.splice(0, this._moveNodes.length), t.type === "pointermove" && f.length > 0 && ((h = this._map) == null || h.dispatchEvent({ type: "nodeMouseout", target: this._bubble ? [f[0]] : f, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
              throw new Error("Function not implemented.");
            }, stopPropagation: function() {
              throw new Error("Function not implemented.");
            } }));
            const g = this._movePath.map((d) => d);
            this._movePath.length > 0 && this._movePath.splice(0, this._movePath.length), t.type === "pointermove" && g.length > 0 && ((c = this._map) == null || c.dispatchEvent({ type: "pathMouseout", target: this._bubble ? [g[0]] : g, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
              throw new Error("Function not implemented.");
            }, stopPropagation: function() {
              throw new Error("Function not implemented.");
            } }));
          }
        }
        initLinesAndMarkers() {
          var u, h, c, f, g, d, A;
          const t = (u = this._pathInfo) == null ? void 0 : u.map((p) => [p.longitude, p.latitude]), e = [], i = [];
          let r = 0;
          for (const p of t) {
            const v = new xe({ geometry: new Oe(JL(p, this._viewCode)) });
            let y = null;
            if (this._pathInfo && (y = this._pathInfo[r]), y && (y.node_idx = r + 1, y.isSimplify = false, v.setProperties(y, true), v.setId("tackNode-" + y.node_idx)), r === 0) {
              const m = v.clone();
              this._animateStart = v.clone(), this._animateStart.setId("moveCarFeature"), m.setStyle(new de({ image: new Rr({ src: this._operators.startIcon, anchor: [0.5, 1] }), text: new Ei({ text: "" }) })), (h = this._revealLayer.getSource()) == null || h.addFeature(m);
            } else if (this._pathInfo && r === this._pathInfo.length - 1) {
              const m = v.clone();
              m.setStyle(new de({ image: new Rr({ src: this._operators.endIcon, anchor: [0.5, 1] }), text: new Ei({ text: "" }) })), (c = this._revealLayer.getSource()) == null || c.addFeature(m);
            }
            i.push(v), r++;
          }
          const a = new be(t);
          this._originPath = a.transform("EPSG:4326", this._viewCode);
          const o = new xe({ geometry: this._originPath }), s = new de({ image: new Rr({ src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABfUlEQVQ4T3WTTSvFYRDFf8dLKIqytFckthTpJkQWlyhF2fgEVr6BheytpChEsqB08xbZWPgOJAs7ieRlNMzV//75P7vnmZkz58ycR2ZWD7QBF5KM1DGzTuBO0k065neZ2S3QBGwAU5I+iolmNgrsAI9An6SrNIgDnAE9EdgFJiS9+93MuoEToBx4AgYkXSZBHKAWOAS6IrAP5CW9BUge2AIqgJdg8guiSKoBDoDeDJBhwNlVBsiQpNPvGST0VgF7TjPeCsCIpNdo0g84O2fibx4r/AJEUjVwlJDjXbybU/eZjAGbMROXmC8BiKQ64BxoDyYLkuYTTCeB9WD/9B9AA3AMdGQAzALLAfCcluDF3r01itMS5oDFiP3MIUHNi90T7ko/XjyYGOIMsFJSXByimTVGQbFzegOuew0o+7PGKL4AmjM8MA2shua/RjIzX1suw8pucZfiUjOt/AC4BHfaeOoz+d63oziX9Zla3CzAkqTP9G8zM4/dS7r+7zt/Aaattn1kX8VgAAAAAElFTkSuQmCC", anchor: [0.75, 0.5], scale: 0.7, rotateWithView: false }) });
          o.set("arrow", [new de({ stroke: new Ze({ color: "rgba(0, 0, 255, 0.6)", width: 10 }) }), s]), o.set("mainView", (f = this._map) == null ? void 0 : f.getView()), o.setStyle((p, v) => xpt(p, v)), e.push(o), (g = this._lineLayer.getSource()) == null || g.addFeatures(e), this._nodesCollection = i, (A = (d = this._animateLayer) == null ? void 0 : d.getSource()) == null || A.addFeature(this._animateLine), o.get("mainView") !== void 0 && o.get("mainView").dispatchEvent("change:resolution");
          const l = this._labelVisible;
          this.labelVisible(l);
        }
        labelVisible(t) {
          var e, i;
          if (t && !this._textLayer) {
            const r = (e = this._pathInfo) == null ? void 0 : e.map((a) => ({ position: [a.longitude, a.latitude], text: a.gnssTime }));
            if (this._textLayer = new _3({ map: this._map, pointsArr: r, zoom: 12, zIndex: 99 }), this._textLayer) {
              this._textLayer.set("id", "pathLabelLayer" + (/* @__PURE__ */ new Date()).getTime());
              let a = this._group.getLayers().getArray();
              a.push(this._textLayer), this._group.setLayers(new Pr({ layers: a }).getLayers());
            }
          } else (i = this._textLayer) == null || i.setVisible(t);
          this._group.set("labelVisible", t || false);
        }
        start(t) {
          var e, i;
          this._pathInfo && this._pathInfo.length < 1 || ((this._moving || this._status === "pause") && this.stop(), this._moveIdx = t || 1, this._moving = true, this._status = "moving", this._nowTime = Date.now(), this._tracePointsModePlay === "skip" ? (this._moveListener = this._lineLayer.on("postrender", (r) => {
            this.tracePointsPlay(r);
          }), (e = this._map) == null || e.render()) : this._tracePointsModePlay === "animation" && (this._step = 0, this._moveListener = this._lineLayer.on("postrender", (r) => {
            this.animationPlay(r);
          }), (i = this._map) == null || i.render()));
        }
        stop() {
          var e, i, r, a;
          this._moveIdx = 1, this._status = "stop", this._moving = false, this._step = 0, this._moveListener !== null && (rl(this._moveListener), this._moveListener = null);
          const t = (e = this._animateLayer.getSource()) == null ? void 0 : e.getFeatureById("moveCarFeature");
          t && ((i = this._animateLayer.getSource()) == null || i.removeFeature(t)), (r = this._animateLine.getGeometry()) == null || r.setCoordinates([]), this._originPath instanceof be && ((a = this._animateStart.getGeometry()) == null || a.setCoordinates(this._originPath.getFirstCoordinate()));
        }
        pause() {
          this._status = "pause", this._moving = false;
        }
        resume() {
          this._status = "moving", this._moving = true;
        }
        tracePointsPlay(t) {
          var a, o, s, l, u, h, c, f, g, d;
          const e = t.frameState;
          if (!e) return;
          const i = this._nodesCollection ? this._nodesCollection.map((A) => A.getGeometry().getCoordinates()) : [], r = (e.time - (this._nowTime || 0)) / 1e3 % 60;
          if (this._moving && (this._moveIdx === 1 || r >= (this._timeStep || 1))) {
            this._nowTime = e.time;
            let A = this._moveIdx === 1 ? this._speedUp : this._moveIdx + this._speedUp, p = null;
            const v = this._animateLine.getGeometry();
            if (i && this._moveIdx === i.length) {
              this.stop();
              return;
            }
            if (i && A >= i.length && this._moveIdx < i.length) {
              A = i.length;
              let E = null;
              i && (E = new xe(new Oe(i[A - 1]))), p = E;
              const I = i[A - 1][0] - i[A - 2][0], x = i[A - 1][1] - i[A - 2][1], w = Math.atan2(x, I);
              this._direction !== w && (this._direction = w), (o = (a = this._carIcon) == null ? void 0 : a.getImage()) == null || o.setRotation(-this._direction + 2 * Math.PI);
              for (let C = i.length - this._moveIdx; C > 0; --C) A !== 0 && A - C <= i.length - 1 && (v == null || v.appendCoordinate(i[A - C]));
            } else if (i && A < i.length && this._moveIdx < i.length) {
              let E = null;
              if (i && (E = new xe(new Oe(i[A - 1]))), p = E, i && A !== i.length - 1) {
                const I = i[A][0] - i[A - 1][0], x = i[A][1] - i[A - 1][1], w = Math.atan2(x, I);
                this._direction !== w && (this._direction = w), (l = (s = this._carIcon) == null ? void 0 : s.getImage()) == null || l.setRotation(-this._direction + 2 * Math.PI);
              }
              for (let I = this._speedUp; I > 0; --I) A !== 0 && A - I <= i.length - 1 && (v == null || v.appendCoordinate(i[A - I]));
            }
            this._animateStart.setStyle(this._carIcon), this._animateStart.getGeometry().setCoordinates(((u = p == null ? void 0 : p.getGeometry()) == null ? void 0 : u.getCoordinates()) || [0, 0]), ((h = this._animateLayer.getSource()) == null ? void 0 : h.getFeatureById("moveCarFeature")) || (f = (c = this._animateLayer) == null ? void 0 : c.getSource()) == null || f.addFeature(this._animateStart), this._moveIdx = A;
            const m = (g = this._map) == null ? void 0 : g.getView().getProjection().getCode(), _ = { index: this._moveIdx, status: this._status, position: i[A - 1], lngLat: tP(this._animateStart.getGeometry().getCoordinates(), m), passNode: this._nodesCollection ? this._nodesCollection[A - 1] : void 0, length: v == null ? void 0 : v.getLength() };
            this._animateLayer.dispatchEvent({ type: "move", target: _, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
              throw new Error("Function not implemented.");
            }, stopPropagation: function() {
              throw new Error("Function not implemented.");
            } });
          }
          (d = this._map) == null || d.render();
        }
        animationPlay(t) {
          var i, r, a, o, s, l;
          let e = 0;
          if (t.frameState) {
            if (this._nowTime = t.frameState.time, this._originPath instanceof be && this._moving && this._step !== void 0 && this._step <= 1) {
              const u = this._originPath.clone();
              u.transform(this._viewCode, "EPSG:3857");
              const h = u.getLength(), c = this._animateLine.getGeometry(), f = this._originPath.clone();
              if (this._step !== 0) {
                const m = { geometry: { coordinates: f.getCoordinates(), type: "LineString" }, properties: {}, type: "Feature" };
                e = h * this._step;
                const _ = Ipt(m, 0, e / 1e3, { units: "kilometers" });
                f.setCoordinates(_.geometry.coordinates), f.transform("EPSG:4326", this._viewCode);
                const E = f.getCoordinates();
                c == null || c.setCoordinates(E);
                let I = 0, x = 0;
                if (E.length > 2) {
                  const C = E[E.length - 2], S = E[E.length - 1];
                  I = C[0] - S[0], x = C[1] - S[1];
                  const b = Math.atan2(x, I);
                  this._direction !== b && (this._direction = b), (r = (i = this._carIcon) == null ? void 0 : i.getImage()) == null || r.setRotation(-this._direction + Math.PI);
                }
                this._animateStart.setStyle(this._carIcon), this._animateStart.getGeometry().setCoordinates(f.getLastCoordinate()), ((a = this._animateLayer.getSource()) == null ? void 0 : a.getFeatureById("moveCarFeature")) || (o = this._animateLayer.getSource()) == null || o.addFeature(this._animateStart);
              }
              const g = c == null ? void 0 : c.getLength();
              let d = 0, A = 0;
              const p = new be([]);
              this._originPath.forEachSegment(function(m, _) {
                p.setCoordinates([m, _]), A <= g && (A += p.getLength(), d++);
              }), this._moveIdx = this._nodeInfos[d - 1].get("node_idx"), this._step += 5 * 1e-7 * (this._speed || 0);
              const v = (s = this._map) == null ? void 0 : s.getView().getProjection().getCode(), y = { index: this._moveIdx, status: this._status, speed: this._speed, position: this._animateStart.getGeometry().getCoordinates(), lngLat: tP(this._animateStart.getGeometry().getCoordinates(), v), passNode: this._nodesCollection ? this._nodesCollection[this._moveIdx - 1] : void 0, length: g };
              this._animateLayer.dispatchEvent({ type: "move", target: y, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
                throw new Error("Function not implemented.");
              }, stopPropagation: function() {
                throw new Error("Function not implemented.");
              } });
            }
            if (this._moving && this._step && this._step >= 1) {
              this.stop();
              return;
            }
            (l = this._map) == null || l.render();
          }
        }
        setFitView(t) {
          var e;
          this._originPath !== null && t && ((e = this._map) == null || e.getView().fit(this._originPath));
        }
        getPaths() {
          return this._pathInfo;
        }
        setPaths(t) {
          this.clearPaths(), this._pathInfo = t, this.initLinesAndMarkers();
        }
        clearPaths() {
          this._moving && this.stop(), this._group.getLayersArray().forEach((t) => {
            (t instanceof Kr || t instanceof _3) && t.getSource().clear();
          });
        }
        destroy() {
          var t, e, i;
          this._moving && this.stop(), this.clearPaths(), rl(this._traceEvent || []), (i = this._map) == null || i.getView().removeEventListener("change:resolution", (t = this._simplifyEvent) != null && t.listener ? (e = this._simplifyEvent) == null ? void 0 : e.listener : () => {
          });
        }
        getSpeed() {
          return this._speed;
        }
        setSpeed(t) {
          this._speed = t;
        }
        getSpeedUp() {
          return this._speedUp;
        }
        setSpeedUp(t) {
          this._speedUp = t, this._speed = (this._speed || 0) * t;
        }
        getPercent() {
          return this._step > 0 ? Number(this._step.toPrecision(3)) : 0;
        }
        setPercent(t) {
          t <= 1 && t >= 0 && (this._step = t);
        }
        setTraceLineStyle(t) {
          var a;
          t = t || {};
          const e = t.lineColor ? t.lineColor : "rgba(0, 0, 255, 0.6)", i = t.lineWidth ? t.lineWidth : 10, r = (a = this._lineLayer.getSource()) == null ? void 0 : a.getFeatures();
          r == null || r.forEach((o) => {
            o.get("arrow")[0].setStroke(new Ze({ color: e, width: i }));
          }), this._lineLayer.changed();
        }
        setPassLineStyle(t) {
          t = t || {};
          const e = t.lineColor ? t.lineColor : "red", i = t.lineWidth ? t.lineWidth : 2, r = new de({ stroke: new Ze({ color: e, width: i }) });
          this._animateLayer.setStyle(r), this._animateLayer.changed();
        }
        setTraceNodeStyle(t) {
          var l;
          t = t || {};
          const e = t.fillColor ? t.fillColor : "rgba(255,255,255,0.4)", i = t.lineColor ? t.lineColor : "#3399CC", r = t.lineWidth ? t.lineWidth : 1.25, a = t.size ? t.size : 5, o = new ye({ color: e }), s = new Ze({ color: i, width: r });
          this._defaultStyles = [new de({ image: new Mr({ fill: o, stroke: s, radius: a }), fill: o, stroke: s })], (l = this._nodesLayer.getSource()) == null || l.getFeatures().forEach((u) => {
            u.setStyle(this._defaultStyles), u.changed();
          });
        }
        getEvents() {
          return this._eventType;
        }
        on(t, e) {
          var r;
          if (this._eventType.includes(t)) return t === "move" ? this._animateLayer.on(t, e) : (r = this._map) == null ? void 0 : r.on(t, e);
        }
        once(t, e) {
          var r;
          if (this._eventType.includes(t)) return t === "move" ? this._animateLayer.once(t, e) : (r = this._map) == null ? void 0 : r.once(t, e);
        }
        un(t, e) {
          var r;
          if (this._eventType.includes(t)) return t === "move" ? this._animateLayer.un(t, e) : (r = this._map) == null ? void 0 : r.un(t, e);
        }
      }
      function xpt(n, t) {
        const e = n.get("arrow"), i = n.get("mainView"), r = [e[0]], a = n.getGeometry();
        if (a && a instanceof be) {
          const o = a.getLength(), s = 200 * (t || 0) / o;
          for (let l = 0; l <= 1; l += s) {
            const u = a.getCoordinateAt(l);
            if (Wr(i.calculateExtent(), u)) {
              const c = a.getCoordinateAt(l + 5e-5), f = c[0] - u[0], g = c[1] - u[1], d = Math.atan2(g, f);
              if (l !== 0) {
                const A = e[1].clone();
                A.setGeometry(new Oe(u)), A.getImage().setRotation(-d + 2 * Math.PI), r.push(A);
              }
            }
          }
        }
        return r;
      }
      const NS = N.defineComponent({ name: "OlPath", props: { bubble: { type: Boolean, default: true }, showTracePoint: { type: Boolean, default: true }, tracePointsModePlay: { type: String, default: "" }, path: { type: Array, default: () => [] }, options: { type: Object, default: () => ({}) }, autoPlay: { type: Boolean, default: false }, visible: { type: Boolean, default: true }, labelVisible: { type: Boolean, default: false } }, emits: ["load", "nodeClick", "nodeMouseover", "nodeMouseout", "pathClick", "pathMouseover", "pathMouseout", "move"], setup(n, { expose: t, emit: e }) {
        const i = N.inject("VMap"), r = N.unref(i).map;
        let a = N.shallowRef();
        N.watch(() => n.visible, (I) => {
          const x = r.getLayerGroup();
          if (x) {
            const C = x.getLayers().getArray().find((S) => S.get("type") === "vzTrackPath");
            C && C.setVisible(I);
          }
        }), N.watch(() => n.labelVisible, (I) => {
          const x = r.getLayerGroup();
          if (x) {
            const C = x.getLayers().getArray().find((S) => S.get("type") === "vzTrackPath");
            C && C.getLayersArray().forEach((S) => {
              S.get("id") && S.get("id").indexOf("pathLabelLayer") > -1 && S.setVisible(I);
            });
          }
        });
        const o = (I) => {
          var x, w, C, S, b, B, T;
          if (I && I.length > 0 || n.path && n.path.length > 0) {
            const D = zt(st({}, n), { mapObj: r, path: I || n.path }), R = new Ept(D);
            R.setTraceLineStyle({ lineColor: ((x = D.options) == null ? void 0 : x.lineColor) || "rgba(0, 0, 255, 0.6)", lineWidth: ((w = D.options) == null ? void 0 : w.lineWidth) || 10 }), R.setPassLineStyle({ lineColor: ((C = D.options) == null ? void 0 : C.passLineColor) || "red", lineWidth: ((S = D.options) == null ? void 0 : S.passLineWidth) || 2 }), R.setTraceNodeStyle({ lineColor: ((b = D.options) == null ? void 0 : b.nodeStrokeColor) || "#3399CC", lineWidth: ((B = D.options) == null ? void 0 : B.nodeStrokeWidth) || 1.25, fillColor: ((T = D.options) == null ? void 0 : T.nodeFillColor) || "rgba(255,255,255,0.4)" }), a.value = R, a.value.getEvents().forEach((L) => {
              var k;
              (k = a.value) == null || k.on(L, (P) => {
                e(L, P);
              });
            }), e("load", a), n.autoPlay && s();
          }
        }, s = (I) => {
          var x;
          (x = a.value) == null || x.start(I);
        }, l = () => {
          var I;
          (I = a.value) == null || I.stop();
        }, u = () => {
          var I;
          (I = a.value) == null || I.pause();
        }, h = () => {
          var I;
          (I = a.value) == null || I.resume();
        }, c = () => {
          var I;
          return (I = a.value) == null ? void 0 : I._status;
        }, f = () => {
          var I;
          (I = a.value) == null || I.destroy();
        }, g = (I) => {
          var x;
          (x = a.value) == null || x.setFitView(I);
        }, d = () => {
          var I;
          return (I = a.value) == null ? void 0 : I.getPaths();
        }, A = (I) => {
          var x;
          (x = a.value) == null || x.setPaths(I);
        }, p = () => {
          var I;
          return (I = a.value) == null ? void 0 : I.getSpeed();
        }, v = (I) => {
          var x;
          (x = a.value) == null || x.setSpeed(I);
        }, y = () => {
          var I;
          return (I = a.value) == null ? void 0 : I.getSpeedUp();
        }, m = (I) => {
          var x;
          (x = a.value) == null || x.setSpeedUp(I);
        }, _ = () => {
          var I;
          return (I = a.value) == null ? void 0 : I.getPercent();
        }, E = (I) => {
          var x;
          (x = a.value) == null || x.setPercent(I);
        };
        N.onMounted(() => {
          o();
        }), t({ init: o, start: s, stop: l, pause: u, resume: h, getStatus: c, destroy: f, setFitView: g, getPaths: d, setPaths: A, getSpeed: p, setSpeed: v, getSpeedUp: y, setSpeedUp: m, getPercent: _, setPercent: E });
      }, render() {
        return null;
      } }), wpt = (n) => n.component(NS.name || "OlPath", NS);
      var Cpt = Error, Spt = EvalError, bpt = RangeError, Bpt = ReferenceError, C3 = SyntaxError, rp = TypeError, Tpt = URIError, Mpt = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return false;
        if (typeof Symbol.iterator == "symbol") return true;
        var t = {}, e = Symbol("test"), i = Object(e);
        if (typeof e == "string" || Object.prototype.toString.call(e) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]") return false;
        var r = 42;
        t[e] = r;
        for (e in t) return false;
        if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0) return false;
        var a = Object.getOwnPropertySymbols(t);
        if (a.length !== 1 || a[0] !== e || !Object.prototype.propertyIsEnumerable.call(t, e)) return false;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
          var o = Object.getOwnPropertyDescriptor(t, e);
          if (o.value !== r || o.enumerable !== true) return false;
        }
        return true;
      }, S3 = typeof Symbol != "undefined" && Symbol, Dpt = Mpt, Rpt = function() {
        return typeof S3 != "function" || typeof Symbol != "function" || typeof S3("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : Dpt();
      }, kS = { __proto__: null, foo: {} }, Lpt = Object, Ppt = function() {
        return { __proto__: kS }.foo === kS.foo && !(kS instanceof Lpt);
      }, Npt = "Function.prototype.bind called on incompatible ", kpt = Object.prototype.toString, Fpt = Math.max, Qpt = "[object Function]", b3 = function(t, e) {
        for (var i = [], r = 0; r < t.length; r += 1) i[r] = t[r];
        for (var a = 0; a < e.length; a += 1) i[a + t.length] = e[a];
        return i;
      }, Opt = function(t, e) {
        for (var i = [], r = e, a = 0; r < t.length; r += 1, a += 1) i[a] = t[r];
        return i;
      }, zpt = function(n, t) {
        for (var e = "", i = 0; i < n.length; i += 1) e += n[i], i + 1 < n.length && (e += t);
        return e;
      }, Gpt = function(t) {
        var e = this;
        if (typeof e != "function" || kpt.apply(e) !== Qpt) throw new TypeError(Npt + e);
        for (var i = Opt(arguments, 1), r, a = function() {
          if (this instanceof r) {
            var h = e.apply(this, b3(i, arguments));
            return Object(h) === h ? h : this;
          }
          return e.apply(t, b3(i, arguments));
        }, o = Fpt(0, e.length - i.length), s = [], l = 0; l < o; l++) s[l] = "$" + l;
        if (r = Function("binder", "return function (" + zpt(s, ",") + "){ return binder.apply(this,arguments); }")(a), e.prototype) {
          var u = function() {
          };
          u.prototype = e.prototype, r.prototype = new u(), u.prototype = null;
        }
        return r;
      }, Upt = Gpt, FS = Function.prototype.bind || Upt, Vpt = Function.prototype.call, jpt = Object.prototype.hasOwnProperty, qpt = FS, Hpt = qpt.call(Vpt, jpt), we, Ypt = Cpt, Wpt = Spt, Xpt = bpt, Zpt = Bpt, Zf = C3, Kf = rp, Kpt = Tpt, B3 = Function, QS = function(n) {
        try {
          return B3('"use strict"; return (' + n + ").constructor;")();
        } catch (t) {
        }
      }, $u = Object.getOwnPropertyDescriptor;
      if ($u) try {
        $u({}, "");
      } catch (n) {
        $u = null;
      }
      var OS = function() {
        throw new Kf();
      }, $pt = $u ? function() {
        try {
          return arguments.callee, OS;
        } catch (n) {
          try {
            return $u(arguments, "callee").get;
          } catch (t) {
            return OS;
          }
        }
      }() : OS, $f = Rpt(), Jpt = Ppt(), oi = Object.getPrototypeOf || (Jpt ? function(n) {
        return n.__proto__;
      } : null), Jf = {}, tvt = typeof Uint8Array == "undefined" || !oi ? we : oi(Uint8Array), Ju = { __proto__: null, "%AggregateError%": typeof AggregateError == "undefined" ? we : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer == "undefined" ? we : ArrayBuffer, "%ArrayIteratorPrototype%": $f && oi ? oi([][Symbol.iterator]()) : we, "%AsyncFromSyncIteratorPrototype%": we, "%AsyncFunction%": Jf, "%AsyncGenerator%": Jf, "%AsyncGeneratorFunction%": Jf, "%AsyncIteratorPrototype%": Jf, "%Atomics%": typeof Atomics == "undefined" ? we : Atomics, "%BigInt%": typeof BigInt == "undefined" ? we : BigInt, "%BigInt64Array%": typeof BigInt64Array == "undefined" ? we : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array == "undefined" ? we : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView == "undefined" ? we : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Ypt, "%eval%": eval, "%EvalError%": Wpt, "%Float32Array%": typeof Float32Array == "undefined" ? we : Float32Array, "%Float64Array%": typeof Float64Array == "undefined" ? we : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry == "undefined" ? we : FinalizationRegistry, "%Function%": B3, "%GeneratorFunction%": Jf, "%Int8Array%": typeof Int8Array == "undefined" ? we : Int8Array, "%Int16Array%": typeof Int16Array == "undefined" ? we : Int16Array, "%Int32Array%": typeof Int32Array == "undefined" ? we : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": $f && oi ? oi(oi([][Symbol.iterator]())) : we, "%JSON%": typeof JSON == "object" ? JSON : we, "%Map%": typeof Map == "undefined" ? we : Map, "%MapIteratorPrototype%": typeof Map == "undefined" || !$f || !oi ? we : oi((/* @__PURE__ */ new Map())[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise == "undefined" ? we : Promise, "%Proxy%": typeof Proxy == "undefined" ? we : Proxy, "%RangeError%": Xpt, "%ReferenceError%": Zpt, "%Reflect%": typeof Reflect == "undefined" ? we : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set == "undefined" ? we : Set, "%SetIteratorPrototype%": typeof Set == "undefined" || !$f || !oi ? we : oi((/* @__PURE__ */ new Set())[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer == "undefined" ? we : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": $f && oi ? oi(""[Symbol.iterator]()) : we, "%Symbol%": $f ? Symbol : we, "%SyntaxError%": Zf, "%ThrowTypeError%": $pt, "%TypedArray%": tvt, "%TypeError%": Kf, "%Uint8Array%": typeof Uint8Array == "undefined" ? we : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray == "undefined" ? we : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array == "undefined" ? we : Uint16Array, "%Uint32Array%": typeof Uint32Array == "undefined" ? we : Uint32Array, "%URIError%": Kpt, "%WeakMap%": typeof WeakMap == "undefined" ? we : WeakMap, "%WeakRef%": typeof WeakRef == "undefined" ? we : WeakRef, "%WeakSet%": typeof WeakSet == "undefined" ? we : WeakSet };
      if (oi) try {
        null.error;
      } catch (n) {
        var evt = oi(oi(n));
        Ju["%Error.prototype%"] = evt;
      }
      var nvt = function n(t) {
        var e;
        if (t === "%AsyncFunction%") e = QS("async function () {}");
        else if (t === "%GeneratorFunction%") e = QS("function* () {}");
        else if (t === "%AsyncGeneratorFunction%") e = QS("async function* () {}");
        else if (t === "%AsyncGenerator%") {
          var i = n("%AsyncGeneratorFunction%");
          i && (e = i.prototype);
        } else if (t === "%AsyncIteratorPrototype%") {
          var r = n("%AsyncGenerator%");
          r && oi && (e = oi(r.prototype));
        }
        return Ju[t] = e, e;
      }, T3 = { __proto__: null, "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, ap = FS, Xm = Hpt, ivt = ap.call(Function.call, Array.prototype.concat), rvt = ap.call(Function.apply, Array.prototype.splice), M3 = ap.call(Function.call, String.prototype.replace), Zm = ap.call(Function.call, String.prototype.slice), avt = ap.call(Function.call, RegExp.prototype.exec), ovt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, svt = /\\(\\)?/g, lvt = function(t) {
        var e = Zm(t, 0, 1), i = Zm(t, -1);
        if (e === "%" && i !== "%") throw new Zf("invalid intrinsic syntax, expected closing `%`");
        if (i === "%" && e !== "%") throw new Zf("invalid intrinsic syntax, expected opening `%`");
        var r = [];
        return M3(t, ovt, function(a, o, s, l) {
          r[r.length] = s ? M3(l, svt, "$1") : o || a;
        }), r;
      }, uvt = function(t, e) {
        var i = t, r;
        if (Xm(T3, i) && (r = T3[i], i = "%" + r[0] + "%"), Xm(Ju, i)) {
          var a = Ju[i];
          if (a === Jf && (a = nvt(i)), typeof a == "undefined" && !e) throw new Kf("intrinsic " + t + " exists, but is not available. Please file an issue!");
          return { alias: r, name: i, value: a };
        }
        throw new Zf("intrinsic " + t + " does not exist!");
      }, tg = function(t, e) {
        if (typeof t != "string" || t.length === 0) throw new Kf("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof e != "boolean") throw new Kf('"allowMissing" argument must be a boolean');
        if (avt(/^%?[^%]*%?$/, t) === null) throw new Zf("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var i = lvt(t), r = i.length > 0 ? i[0] : "", a = uvt("%" + r + "%", e), o = a.name, s = a.value, l = false, u = a.alias;
        u && (r = u[0], rvt(i, ivt([0, 1], u)));
        for (var h = 1, c = true; h < i.length; h += 1) {
          var f = i[h], g = Zm(f, 0, 1), d = Zm(f, -1);
          if ((g === '"' || g === "'" || g === "`" || d === '"' || d === "'" || d === "`") && g !== d) throw new Zf("property names with quotes must have matching quotes");
          if ((f === "constructor" || !c) && (l = true), r += "." + f, o = "%" + r + "%", Xm(Ju, o)) s = Ju[o];
          else if (s != null) {
            if (!(f in s)) {
              if (!e) throw new Kf("base intrinsic for " + t + " exists, but the property is not available.");
              return;
            }
            if ($u && h + 1 >= i.length) {
              var A = $u(s, f);
              c = !!A, c && "get" in A && !("originalValue" in A.get) ? s = A.get : s = s[f];
            } else c = Xm(s, f), s = s[f];
            c && !l && (Ju[o] = s);
          }
        }
        return s;
      }, D3 = { exports: {} }, zS, R3;
      function GS() {
        if (R3) return zS;
        R3 = 1;
        var n = tg, t = n("%Object.defineProperty%", true) || false;
        if (t) try {
          t({}, "a", { value: 1 });
        } catch (e) {
          t = false;
        }
        return zS = t, zS;
      }
      var hvt = tg, Km = hvt("%Object.getOwnPropertyDescriptor%", true);
      if (Km) try {
        Km([], "length");
      } catch (n) {
        Km = null;
      }
      var L3 = Km, P3 = GS(), cvt = C3, eg = rp, N3 = L3, fvt = function(t, e, i) {
        if (!t || typeof t != "object" && typeof t != "function") throw new eg("`obj` must be an object or a function`");
        if (typeof e != "string" && typeof e != "symbol") throw new eg("`property` must be a string or a symbol`");
        if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new eg("`nonEnumerable`, if provided, must be a boolean or null");
        if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new eg("`nonWritable`, if provided, must be a boolean or null");
        if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new eg("`nonConfigurable`, if provided, must be a boolean or null");
        if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new eg("`loose`, if provided, must be a boolean");
        var r = arguments.length > 3 ? arguments[3] : null, a = arguments.length > 4 ? arguments[4] : null, o = arguments.length > 5 ? arguments[5] : null, s = arguments.length > 6 ? arguments[6] : false, l = !!N3 && N3(t, e);
        if (P3) P3(t, e, { configurable: o === null && l ? l.configurable : !o, enumerable: r === null && l ? l.enumerable : !r, value: i, writable: a === null && l ? l.writable : !a });
        else if (s || !r && !a && !o) t[e] = i;
        else throw new cvt("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }, US = GS(), k3 = function() {
        return !!US;
      };
      k3.hasArrayLengthDefineBug = function() {
        if (!US) return null;
        try {
          return US([], "length", { value: 1 }).length !== 1;
        } catch (t) {
          return true;
        }
      };
      var gvt = k3, dvt = tg, F3 = fvt, Avt = gvt(), Q3 = L3, O3 = rp, pvt = dvt("%Math.floor%"), vvt = function(t, e) {
        if (typeof t != "function") throw new O3("`fn` is not a function");
        if (typeof e != "number" || e < 0 || e > 4294967295 || pvt(e) !== e) throw new O3("`length` must be a positive 32-bit integer");
        var i = arguments.length > 2 && !!arguments[2], r = true, a = true;
        if ("length" in t && Q3) {
          var o = Q3(t, "length");
          o && !o.configurable && (r = false), o && !o.writable && (a = false);
        }
        return (r || a || !i) && (Avt ? F3(t, "length", e, true, true) : F3(t, "length", e)), t;
      };
      (function(n) {
        var t = FS, e = tg, i = vvt, r = rp, a = e("%Function.prototype.apply%"), o = e("%Function.prototype.call%"), s = e("%Reflect.apply%", true) || t.call(o, a), l = GS(), u = e("%Math.max%");
        n.exports = function(f) {
          if (typeof f != "function") throw new r("a function is required");
          var g = s(t, o, arguments);
          return i(g, 1 + u(0, f.length - (arguments.length - 1)), true);
        };
        var h = function() {
          return s(t, a, arguments);
        };
        l ? l(n.exports, "apply", { value: h }) : n.exports.apply = h;
      })(D3);
      var yvt = D3.exports, z3 = tg, G3 = yvt, mvt = G3(z3("String.prototype.indexOf")), _vt = function(t, e) {
        var i = z3(t, !!e);
        return typeof i == "function" && mvt(t, ".prototype.") > -1 ? G3(i) : i;
      };
      const Ivt = lst(rlt);
      var VS = typeof Map == "function" && Map.prototype, jS = Object.getOwnPropertyDescriptor && VS ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, $m = VS && jS && typeof jS.get == "function" ? jS.get : null, U3 = VS && Map.prototype.forEach, qS = typeof Set == "function" && Set.prototype, HS = Object.getOwnPropertyDescriptor && qS ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, Jm = qS && HS && typeof HS.get == "function" ? HS.get : null, V3 = qS && Set.prototype.forEach, Evt = typeof WeakMap == "function" && WeakMap.prototype, op = Evt ? WeakMap.prototype.has : null, xvt = typeof WeakSet == "function" && WeakSet.prototype, sp = xvt ? WeakSet.prototype.has : null, wvt = typeof WeakRef == "function" && WeakRef.prototype, j3 = wvt ? WeakRef.prototype.deref : null, Cvt = Boolean.prototype.valueOf, Svt = Object.prototype.toString, bvt = Function.prototype.toString, Bvt = String.prototype.match, YS = String.prototype.slice, kl = String.prototype.replace, Tvt = String.prototype.toUpperCase, q3 = String.prototype.toLowerCase, H3 = RegExp.prototype.test, Y3 = Array.prototype.concat, xo = Array.prototype.join, Mvt = Array.prototype.slice, W3 = Math.floor, WS = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, XS = Object.getOwnPropertySymbols, ZS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, ng = typeof Symbol == "function" && typeof Symbol.iterator == "object", Ti = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === ng || true) ? Symbol.toStringTag : null, X3 = Object.prototype.propertyIsEnumerable, Z3 = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(n) {
        return n.__proto__;
      } : null);
      function K3(n, t) {
        if (n === 1 / 0 || n === -1 / 0 || n !== n || n && n > -1e3 && n < 1e3 || H3.call(/e/, t)) return t;
        var e = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof n == "number") {
          var i = n < 0 ? -W3(-n) : W3(n);
          if (i !== n) {
            var r = String(i), a = YS.call(t, r.length + 1);
            return kl.call(r, e, "$&_") + "." + kl.call(kl.call(a, /([0-9]{3})/g, "$&_"), /_$/, "");
          }
        }
        return kl.call(t, e, "$&_");
      }
      var KS = Ivt, $3 = KS.custom, J3 = iz($3) ? $3 : null, tz = { __proto__: null, double: '"', single: "'" }, Dvt = { __proto__: null, double: /(["\\])/g, single: /(['\\])/g }, Rvt = function n(t, e, i, r) {
        var a = e || {};
        if (xs(a, "quoteStyle") && !xs(tz, a.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
        if (xs(a, "maxStringLength") && (typeof a.maxStringLength == "number" ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0 : a.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        var o = xs(a, "customInspect") ? a.customInspect : true;
        if (typeof o != "boolean" && o !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        if (xs(a, "indent") && a.indent !== null && a.indent !== "	" && !(parseInt(a.indent, 10) === a.indent && a.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        if (xs(a, "numericSeparator") && typeof a.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        var s = a.numericSeparator;
        if (typeof t == "undefined") return "undefined";
        if (t === null) return "null";
        if (typeof t == "boolean") return t ? "true" : "false";
        if (typeof t == "string") return az(t, a);
        if (typeof t == "number") {
          if (t === 0) return 1 / 0 / t > 0 ? "0" : "-0";
          var l = String(t);
          return s ? K3(t, l) : l;
        }
        if (typeof t == "bigint") {
          var u = String(t) + "n";
          return s ? K3(t, u) : u;
        }
        var h = typeof a.depth == "undefined" ? 5 : a.depth;
        if (typeof i == "undefined" && (i = 0), i >= h && h > 0 && typeof t == "object") return $S(t) ? "[Array]" : "[Object]";
        var c = Zvt(a, i);
        if (typeof r == "undefined") r = [];
        else if (rz(r, t) >= 0) return "[Circular]";
        function f(T, D, R) {
          if (D && (r = Mvt.call(r), r.push(D)), R) {
            var L = { depth: a.depth };
            return xs(a, "quoteStyle") && (L.quoteStyle = a.quoteStyle), n(T, L, i + 1, r);
          }
          return n(T, a, i + 1, r);
        }
        if (typeof t == "function" && !nz(t)) {
          var g = Gvt(t), d = t_(t, f);
          return "[Function" + (g ? ": " + g : " (anonymous)") + "]" + (d.length > 0 ? " { " + xo.call(d, ", ") + " }" : "");
        }
        if (iz(t)) {
          var A = ng ? kl.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : ZS.call(t);
          return typeof t == "object" && !ng ? lp(A) : A;
        }
        if (Yvt(t)) {
          for (var p = "<" + q3.call(String(t.nodeName)), v = t.attributes || [], y = 0; y < v.length; y++) p += " " + v[y].name + "=" + ez(Lvt(v[y].value), "double", a);
          return p += ">", t.childNodes && t.childNodes.length && (p += "..."), p += "</" + q3.call(String(t.nodeName)) + ">", p;
        }
        if ($S(t)) {
          if (t.length === 0) return "[]";
          var m = t_(t, f);
          return c && !Xvt(m) ? "[" + tb(m, c) + "]" : "[ " + xo.call(m, ", ") + " ]";
        }
        if (Nvt(t)) {
          var _ = t_(t, f);
          return !("cause" in Error.prototype) && "cause" in t && !X3.call(t, "cause") ? "{ [" + String(t) + "] " + xo.call(Y3.call("[cause]: " + f(t.cause), _), ", ") + " }" : _.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + xo.call(_, ", ") + " }";
        }
        if (typeof t == "object" && o) {
          if (J3 && typeof t[J3] == "function" && KS) return KS(t, { depth: h - i });
          if (o !== "symbol" && typeof t.inspect == "function") return t.inspect();
        }
        if (Uvt(t)) {
          var E = [];
          return U3 && U3.call(t, function(T, D) {
            E.push(f(D, t, true) + " => " + f(T, t));
          }), oz("Map", $m.call(t), E, c);
        }
        if (qvt(t)) {
          var I = [];
          return V3 && V3.call(t, function(T) {
            I.push(f(T, t));
          }), oz("Set", Jm.call(t), I, c);
        }
        if (Vvt(t)) return JS("WeakMap");
        if (Hvt(t)) return JS("WeakSet");
        if (jvt(t)) return JS("WeakRef");
        if (Fvt(t)) return lp(f(Number(t)));
        if (Ovt(t)) return lp(f(WS.call(t)));
        if (Qvt(t)) return lp(Cvt.call(t));
        if (kvt(t)) return lp(f(String(t)));
        if (typeof window != "undefined" && t === window) return "{ [object Window] }";
        if (typeof globalThis != "undefined" && t === globalThis || typeof aQ != "undefined" && t === aQ) return "{ [object globalThis] }";
        if (!Pvt(t) && !nz(t)) {
          var x = t_(t, f), w = Z3 ? Z3(t) === Object.prototype : t instanceof Object || t.constructor === Object, C = t instanceof Object ? "" : "null prototype", S = !w && Ti && Object(t) === t && Ti in t ? YS.call(Fl(t), 8, -1) : C ? "Object" : "", b = w || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : "", B = b + (S || C ? "[" + xo.call(Y3.call([], S || [], C || []), ": ") + "] " : "");
          return x.length === 0 ? B + "{}" : c ? B + "{" + tb(x, c) + "}" : B + "{ " + xo.call(x, ", ") + " }";
        }
        return String(t);
      };
      function ez(n, t, e) {
        var i = e.quoteStyle || t, r = tz[i];
        return r + n + r;
      }
      function Lvt(n) {
        return kl.call(String(n), /"/g, "&quot;");
      }
      function $S(n) {
        return Fl(n) === "[object Array]" && (!Ti || !(typeof n == "object" && Ti in n));
      }
      function Pvt(n) {
        return Fl(n) === "[object Date]" && (!Ti || !(typeof n == "object" && Ti in n));
      }
      function nz(n) {
        return Fl(n) === "[object RegExp]" && (!Ti || !(typeof n == "object" && Ti in n));
      }
      function Nvt(n) {
        return Fl(n) === "[object Error]" && (!Ti || !(typeof n == "object" && Ti in n));
      }
      function kvt(n) {
        return Fl(n) === "[object String]" && (!Ti || !(typeof n == "object" && Ti in n));
      }
      function Fvt(n) {
        return Fl(n) === "[object Number]" && (!Ti || !(typeof n == "object" && Ti in n));
      }
      function Qvt(n) {
        return Fl(n) === "[object Boolean]" && (!Ti || !(typeof n == "object" && Ti in n));
      }
      function iz(n) {
        if (ng) return n && typeof n == "object" && n instanceof Symbol;
        if (typeof n == "symbol") return true;
        if (!n || typeof n != "object" || !ZS) return false;
        try {
          return ZS.call(n), true;
        } catch (t) {
        }
        return false;
      }
      function Ovt(n) {
        if (!n || typeof n != "object" || !WS) return false;
        try {
          return WS.call(n), true;
        } catch (t) {
        }
        return false;
      }
      var zvt = Object.prototype.hasOwnProperty || function(n) {
        return n in this;
      };
      function xs(n, t) {
        return zvt.call(n, t);
      }
      function Fl(n) {
        return Svt.call(n);
      }
      function Gvt(n) {
        if (n.name) return n.name;
        var t = Bvt.call(bvt.call(n), /^function\s*([\w$]+)/);
        return t ? t[1] : null;
      }
      function rz(n, t) {
        if (n.indexOf) return n.indexOf(t);
        for (var e = 0, i = n.length; e < i; e++) if (n[e] === t) return e;
        return -1;
      }
      function Uvt(n) {
        if (!$m || !n || typeof n != "object") return false;
        try {
          $m.call(n);
          try {
            Jm.call(n);
          } catch (t) {
            return true;
          }
          return n instanceof Map;
        } catch (t) {
        }
        return false;
      }
      function Vvt(n) {
        if (!op || !n || typeof n != "object") return false;
        try {
          op.call(n, op);
          try {
            sp.call(n, sp);
          } catch (t) {
            return true;
          }
          return n instanceof WeakMap;
        } catch (t) {
        }
        return false;
      }
      function jvt(n) {
        if (!j3 || !n || typeof n != "object") return false;
        try {
          return j3.call(n), true;
        } catch (t) {
        }
        return false;
      }
      function qvt(n) {
        if (!Jm || !n || typeof n != "object") return false;
        try {
          Jm.call(n);
          try {
            $m.call(n);
          } catch (t) {
            return true;
          }
          return n instanceof Set;
        } catch (t) {
        }
        return false;
      }
      function Hvt(n) {
        if (!sp || !n || typeof n != "object") return false;
        try {
          sp.call(n, sp);
          try {
            op.call(n, op);
          } catch (t) {
            return true;
          }
          return n instanceof WeakSet;
        } catch (t) {
        }
        return false;
      }
      function Yvt(n) {
        return !n || typeof n != "object" ? false : typeof HTMLElement != "undefined" && n instanceof HTMLElement ? true : typeof n.nodeName == "string" && typeof n.getAttribute == "function";
      }
      function az(n, t) {
        if (n.length > t.maxStringLength) {
          var e = n.length - t.maxStringLength, i = "... " + e + " more character" + (e > 1 ? "s" : "");
          return az(YS.call(n, 0, t.maxStringLength), t) + i;
        }
        var r = Dvt[t.quoteStyle || "single"];
        r.lastIndex = 0;
        var a = kl.call(kl.call(n, r, "\\$1"), /[\x00-\x1f]/g, Wvt);
        return ez(a, "single", t);
      }
      function Wvt(n) {
        var t = n.charCodeAt(0), e = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[t];
        return e ? "\\" + e : "\\x" + (t < 16 ? "0" : "") + Tvt.call(t.toString(16));
      }
      function lp(n) {
        return "Object(" + n + ")";
      }
      function JS(n) {
        return n + " { ? }";
      }
      function oz(n, t, e, i) {
        var r = i ? tb(e, i) : xo.call(e, ", ");
        return n + " (" + t + ") {" + r + "}";
      }
      function Xvt(n) {
        for (var t = 0; t < n.length; t++) if (rz(n[t], `
`) >= 0) return false;
        return true;
      }
      function Zvt(n, t) {
        var e;
        if (n.indent === "	") e = "	";
        else if (typeof n.indent == "number" && n.indent > 0) e = xo.call(Array(n.indent + 1), " ");
        else return null;
        return { base: e, prev: xo.call(Array(t + 1), e) };
      }
      function tb(n, t) {
        if (n.length === 0) return "";
        var e = `
` + t.prev + t.base;
        return e + xo.call(n, "," + e) + `
` + t.prev;
      }
      function t_(n, t) {
        var e = $S(n), i = [];
        if (e) {
          i.length = n.length;
          for (var r = 0; r < n.length; r++) i[r] = xs(n, r) ? t(n[r], n) : "";
        }
        var a = typeof XS == "function" ? XS(n) : [], o;
        if (ng) {
          o = {};
          for (var s = 0; s < a.length; s++) o["$" + a[s]] = a[s];
        }
        for (var l in n) xs(n, l) && (e && String(Number(l)) === l && l < n.length || ng && o["$" + l] instanceof Symbol || (H3.call(/[^\w$]/, l) ? i.push(t(l, n) + ": " + t(n[l], n)) : i.push(l + ": " + t(n[l], n))));
        if (typeof XS == "function") for (var u = 0; u < a.length; u++) X3.call(n, a[u]) && i.push("[" + t(a[u]) + "]: " + t(n[a[u]], n));
        return i;
      }
      var sz = tg, ig = _vt, Kvt = Rvt, $vt = rp, e_ = sz("%WeakMap%", true), n_ = sz("%Map%", true), Jvt = ig("WeakMap.prototype.get", true), tyt = ig("WeakMap.prototype.set", true), eyt = ig("WeakMap.prototype.has", true), nyt = ig("Map.prototype.get", true), iyt = ig("Map.prototype.set", true), ryt = ig("Map.prototype.has", true), eb = function(n, t) {
        for (var e = n, i; (i = e.next) !== null; e = i) if (i.key === t) return e.next = i.next, i.next = n.next, n.next = i, i;
      }, ayt = function(n, t) {
        var e = eb(n, t);
        return e && e.value;
      }, oyt = function(n, t, e) {
        var i = eb(n, t);
        i ? i.value = e : n.next = { key: t, next: n.next, value: e };
      }, syt = function(n, t) {
        return !!eb(n, t);
      }, lyt = function() {
        var t, e, i, r = { assert: function(a) {
          if (!r.has(a)) throw new $vt("Side channel does not contain " + Kvt(a));
        }, get: function(a) {
          if (e_ && a && (typeof a == "object" || typeof a == "function")) {
            if (t) return Jvt(t, a);
          } else if (n_) {
            if (e) return nyt(e, a);
          } else if (i) return ayt(i, a);
        }, has: function(a) {
          if (e_ && a && (typeof a == "object" || typeof a == "function")) {
            if (t) return eyt(t, a);
          } else if (n_) {
            if (e) return ryt(e, a);
          } else if (i) return syt(i, a);
          return false;
        }, set: function(a, o) {
          e_ && a && (typeof a == "object" || typeof a == "function") ? (t || (t = new e_()), tyt(t, a, o)) : n_ ? (e || (e = new n_()), iyt(e, a, o)) : (i || (i = { key: {}, next: null }), oyt(i, a, o));
        } };
        return r;
      }, uyt = String.prototype.replace, hyt = /%20/g, nb = { RFC1738: "RFC1738", RFC3986: "RFC3986" }, ib = { default: nb.RFC3986, formatters: { RFC1738: function(n) {
        return uyt.call(n, hyt, "+");
      }, RFC3986: function(n) {
        return String(n);
      } }, RFC1738: nb.RFC1738, RFC3986: nb.RFC3986 }, cyt = ib, rb = Object.prototype.hasOwnProperty, th = Array.isArray, wo = function() {
        for (var n = [], t = 0; t < 256; ++t) n.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
        return n;
      }(), fyt = function(t) {
        for (; t.length > 1; ) {
          var e = t.pop(), i = e.obj[e.prop];
          if (th(i)) {
            for (var r = [], a = 0; a < i.length; ++a) typeof i[a] != "undefined" && r.push(i[a]);
            e.obj[e.prop] = r;
          }
        }
      }, lz = function(t, e) {
        for (var i = e && e.plainObjects ? { __proto__: null } : {}, r = 0; r < t.length; ++r) typeof t[r] != "undefined" && (i[r] = t[r]);
        return i;
      }, gyt = function n(t, e, i) {
        if (!e) return t;
        if (typeof e != "object" && typeof e != "function") {
          if (th(t)) t.push(e);
          else if (t && typeof t == "object") (i && (i.plainObjects || i.allowPrototypes) || !rb.call(Object.prototype, e)) && (t[e] = true);
          else return [t, e];
          return t;
        }
        if (!t || typeof t != "object") return [t].concat(e);
        var r = t;
        return th(t) && !th(e) && (r = lz(t, i)), th(t) && th(e) ? (e.forEach(function(a, o) {
          if (rb.call(t, o)) {
            var s = t[o];
            s && typeof s == "object" && a && typeof a == "object" ? t[o] = n(s, a, i) : t.push(a);
          } else t[o] = a;
        }), t) : Object.keys(e).reduce(function(a, o) {
          var s = e[o];
          return rb.call(a, o) ? a[o] = n(a[o], s, i) : a[o] = s, a;
        }, r);
      }, dyt = function(t, e) {
        return Object.keys(e).reduce(function(i, r) {
          return i[r] = e[r], i;
        }, t);
      }, Ayt = function(n, t, e) {
        var i = n.replace(/\+/g, " ");
        if (e === "iso-8859-1") return i.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
          return decodeURIComponent(i);
        } catch (r) {
          return i;
        }
      }, ab = 1024, pyt = function(t, e, i, r, a) {
        if (t.length === 0) return t;
        var o = t;
        if (typeof t == "symbol" ? o = Symbol.prototype.toString.call(t) : typeof t != "string" && (o = String(t)), i === "iso-8859-1") return escape(o).replace(/%u[0-9a-f]{4}/gi, function(g) {
          return "%26%23" + parseInt(g.slice(2), 16) + "%3B";
        });
        for (var s = "", l = 0; l < o.length; l += ab) {
          for (var u = o.length >= ab ? o.slice(l, l + ab) : o, h = [], c = 0; c < u.length; ++c) {
            var f = u.charCodeAt(c);
            if (f === 45 || f === 46 || f === 95 || f === 126 || f >= 48 && f <= 57 || f >= 65 && f <= 90 || f >= 97 && f <= 122 || a === cyt.RFC1738 && (f === 40 || f === 41)) {
              h[h.length] = u.charAt(c);
              continue;
            }
            if (f < 128) {
              h[h.length] = wo[f];
              continue;
            }
            if (f < 2048) {
              h[h.length] = wo[192 | f >> 6] + wo[128 | f & 63];
              continue;
            }
            if (f < 55296 || f >= 57344) {
              h[h.length] = wo[224 | f >> 12] + wo[128 | f >> 6 & 63] + wo[128 | f & 63];
              continue;
            }
            c += 1, f = 65536 + ((f & 1023) << 10 | u.charCodeAt(c) & 1023), h[h.length] = wo[240 | f >> 18] + wo[128 | f >> 12 & 63] + wo[128 | f >> 6 & 63] + wo[128 | f & 63];
          }
          s += h.join("");
        }
        return s;
      }, vyt = function(t) {
        for (var e = [{ obj: { o: t }, prop: "o" }], i = [], r = 0; r < e.length; ++r) for (var a = e[r], o = a.obj[a.prop], s = Object.keys(o), l = 0; l < s.length; ++l) {
          var u = s[l], h = o[u];
          typeof h == "object" && h !== null && i.indexOf(h) === -1 && (e.push({ obj: o, prop: u }), i.push(h));
        }
        return fyt(e), t;
      }, yyt = function(t) {
        return Object.prototype.toString.call(t) === "[object RegExp]";
      }, myt = function(t) {
        return !t || typeof t != "object" ? false : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t));
      }, _yt = function(t, e) {
        return [].concat(t, e);
      }, Iyt = function(t, e) {
        if (th(t)) {
          for (var i = [], r = 0; r < t.length; r += 1) i.push(e(t[r]));
          return i;
        }
        return e(t);
      }, uz = { arrayToObject: lz, assign: dyt, combine: _yt, compact: vyt, decode: Ayt, encode: pyt, isBuffer: myt, isRegExp: yyt, maybeMap: Iyt, merge: gyt }, hz = lyt, i_ = uz, up = ib, Eyt = Object.prototype.hasOwnProperty, cz = { brackets: function(t) {
        return t + "[]";
      }, comma: "comma", indices: function(t, e) {
        return t + "[" + e + "]";
      }, repeat: function(t) {
        return t;
      } }, Co = Array.isArray, xyt = Array.prototype.push, fz = function(n, t) {
        xyt.apply(n, Co(t) ? t : [t]);
      }, wyt = Date.prototype.toISOString, gz = up.default, Hn = { addQueryPrefix: false, allowDots: false, allowEmptyArrays: false, arrayFormat: "indices", charset: "utf-8", charsetSentinel: false, commaRoundTrip: false, delimiter: "&", encode: true, encodeDotInKeys: false, encoder: i_.encode, encodeValuesOnly: false, filter: void 0, format: gz, formatter: up.formatters[gz], indices: false, serializeDate: function(t) {
        return wyt.call(t);
      }, skipNulls: false, strictNullHandling: false }, Cyt = function(t) {
        return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint";
      }, ob = {}, Syt = function n(t, e, i, r, a, o, s, l, u, h, c, f, g, d, A, p, v, y) {
        for (var m = t, _ = y, E = 0, I = false; (_ = _.get(ob)) !== void 0 && !I; ) {
          var x = _.get(t);
          if (E += 1, typeof x != "undefined") {
            if (x === E) throw new RangeError("Cyclic object value");
            I = true;
          }
          typeof _.get(ob) == "undefined" && (E = 0);
        }
        if (typeof h == "function" ? m = h(e, m) : m instanceof Date ? m = g(m) : i === "comma" && Co(m) && (m = i_.maybeMap(m, function(Q) {
          return Q instanceof Date ? g(Q) : Q;
        })), m === null) {
          if (o) return u && !p ? u(e, Hn.encoder, v, "key", d) : e;
          m = "";
        }
        if (Cyt(m) || i_.isBuffer(m)) {
          if (u) {
            var w = p ? e : u(e, Hn.encoder, v, "key", d);
            return [A(w) + "=" + A(u(m, Hn.encoder, v, "value", d))];
          }
          return [A(e) + "=" + A(String(m))];
        }
        var C = [];
        if (typeof m == "undefined") return C;
        var S;
        if (i === "comma" && Co(m)) p && u && (m = i_.maybeMap(m, u)), S = [{ value: m.length > 0 ? m.join(",") || null : void 0 }];
        else if (Co(h)) S = h;
        else {
          var b = Object.keys(m);
          S = c ? b.sort(c) : b;
        }
        var B = l ? String(e).replace(/\./g, "%2E") : String(e), T = r && Co(m) && m.length === 1 ? B + "[]" : B;
        if (a && Co(m) && m.length === 0) return T + "[]";
        for (var D = 0; D < S.length; ++D) {
          var R = S[D], L = typeof R == "object" && R && typeof R.value != "undefined" ? R.value : m[R];
          if (!(s && L === null)) {
            var k = f && l ? String(R).replace(/\./g, "%2E") : String(R), P = Co(m) ? typeof i == "function" ? i(T, k) : T : T + (f ? "." + k : "[" + k + "]");
            y.set(t, E);
            var F = hz();
            F.set(ob, y), fz(C, n(L, P, i, r, a, o, s, l, i === "comma" && p && Co(m) ? null : u, h, c, f, g, d, A, p, v, F));
          }
        }
        return C;
      }, byt = function(t) {
        if (!t) return Hn;
        if (typeof t.allowEmptyArrays != "undefined" && typeof t.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof t.encodeDotInKeys != "undefined" && typeof t.encodeDotInKeys != "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
        if (t.encoder !== null && typeof t.encoder != "undefined" && typeof t.encoder != "function") throw new TypeError("Encoder has to be a function.");
        var e = t.charset || Hn.charset;
        if (typeof t.charset != "undefined" && t.charset !== "utf-8" && t.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var i = up.default;
        if (typeof t.format != "undefined") {
          if (!Eyt.call(up.formatters, t.format)) throw new TypeError("Unknown format option provided.");
          i = t.format;
        }
        var r = up.formatters[i], a = Hn.filter;
        (typeof t.filter == "function" || Co(t.filter)) && (a = t.filter);
        var o;
        if (t.arrayFormat in cz ? o = t.arrayFormat : "indices" in t ? o = t.indices ? "indices" : "repeat" : o = Hn.arrayFormat, "commaRoundTrip" in t && typeof t.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        var s = typeof t.allowDots == "undefined" ? t.encodeDotInKeys === true ? true : Hn.allowDots : !!t.allowDots;
        return { addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : Hn.addQueryPrefix, allowDots: s, allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : Hn.allowEmptyArrays, arrayFormat: o, charset: e, charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Hn.charsetSentinel, commaRoundTrip: !!t.commaRoundTrip, delimiter: typeof t.delimiter == "undefined" ? Hn.delimiter : t.delimiter, encode: typeof t.encode == "boolean" ? t.encode : Hn.encode, encodeDotInKeys: typeof t.encodeDotInKeys == "boolean" ? t.encodeDotInKeys : Hn.encodeDotInKeys, encoder: typeof t.encoder == "function" ? t.encoder : Hn.encoder, encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : Hn.encodeValuesOnly, filter: a, format: i, formatter: r, serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : Hn.serializeDate, skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : Hn.skipNulls, sort: typeof t.sort == "function" ? t.sort : null, strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Hn.strictNullHandling };
      }, Byt = function(n, t) {
        var e = n, i = byt(t), r, a;
        typeof i.filter == "function" ? (a = i.filter, e = a("", e)) : Co(i.filter) && (a = i.filter, r = a);
        var o = [];
        if (typeof e != "object" || e === null) return "";
        var s = cz[i.arrayFormat], l = s === "comma" && i.commaRoundTrip;
        r || (r = Object.keys(e)), i.sort && r.sort(i.sort);
        for (var u = hz(), h = 0; h < r.length; ++h) {
          var c = r[h], f = e[c];
          i.skipNulls && f === null || fz(o, Syt(f, c, s, l, i.allowEmptyArrays, i.strictNullHandling, i.skipNulls, i.encodeDotInKeys, i.encode ? i.encoder : null, i.filter, i.sort, i.allowDots, i.serializeDate, i.format, i.formatter, i.encodeValuesOnly, i.charset, u));
        }
        var g = o.join(i.delimiter), d = i.addQueryPrefix === true ? "?" : "";
        return i.charsetSentinel && (i.charset === "iso-8859-1" ? d += "utf8=%26%2310003%3B&" : d += "utf8=%E2%9C%93&"), g.length > 0 ? d + g : "";
      }, rg = uz, sb = Object.prototype.hasOwnProperty, Tyt = Array.isArray, _n = { allowDots: false, allowEmptyArrays: false, allowPrototypes: false, allowSparse: false, arrayLimit: 20, charset: "utf-8", charsetSentinel: false, comma: false, decodeDotInKeys: false, decoder: rg.decode, delimiter: "&", depth: 5, duplicates: "combine", ignoreQueryPrefix: false, interpretNumericEntities: false, parameterLimit: 1e3, parseArrays: true, plainObjects: false, strictDepth: false, strictNullHandling: false }, Myt = function(n) {
        return n.replace(/&#(\d+);/g, function(t, e) {
          return String.fromCharCode(parseInt(e, 10));
        });
      }, dz = function(n, t) {
        return n && typeof n == "string" && t.comma && n.indexOf(",") > -1 ? n.split(",") : n;
      }, Dyt = "utf8=%26%2310003%3B", Ryt = "utf8=%E2%9C%93", Lyt = function(t, e) {
        var i = { __proto__: null }, r = e.ignoreQueryPrefix ? t.replace(/^\?/, "") : t;
        r = r.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
        var a = e.parameterLimit === 1 / 0 ? void 0 : e.parameterLimit, o = r.split(e.delimiter, a), s = -1, l, u = e.charset;
        if (e.charsetSentinel) for (l = 0; l < o.length; ++l) o[l].indexOf("utf8=") === 0 && (o[l] === Ryt ? u = "utf-8" : o[l] === Dyt && (u = "iso-8859-1"), s = l, l = o.length);
        for (l = 0; l < o.length; ++l) if (l !== s) {
          var h = o[l], c = h.indexOf("]="), f = c === -1 ? h.indexOf("=") : c + 1, g, d;
          f === -1 ? (g = e.decoder(h, _n.decoder, u, "key"), d = e.strictNullHandling ? null : "") : (g = e.decoder(h.slice(0, f), _n.decoder, u, "key"), d = rg.maybeMap(dz(h.slice(f + 1), e), function(p) {
            return e.decoder(p, _n.decoder, u, "value");
          })), d && e.interpretNumericEntities && u === "iso-8859-1" && (d = Myt(String(d))), h.indexOf("[]=") > -1 && (d = Tyt(d) ? [d] : d);
          var A = sb.call(i, g);
          A && e.duplicates === "combine" ? i[g] = rg.combine(i[g], d) : (!A || e.duplicates === "last") && (i[g] = d);
        }
        return i;
      }, Pyt = function(n, t, e, i) {
        for (var r = i ? t : dz(t, e), a = n.length - 1; a >= 0; --a) {
          var o, s = n[a];
          if (s === "[]" && e.parseArrays) o = e.allowEmptyArrays && (r === "" || e.strictNullHandling && r === null) ? [] : [].concat(r);
          else {
            o = e.plainObjects ? { __proto__: null } : {};
            var l = s.charAt(0) === "[" && s.charAt(s.length - 1) === "]" ? s.slice(1, -1) : s, u = e.decodeDotInKeys ? l.replace(/%2E/g, ".") : l, h = parseInt(u, 10);
            !e.parseArrays && u === "" ? o = { 0: r } : !isNaN(h) && s !== u && String(h) === u && h >= 0 && e.parseArrays && h <= e.arrayLimit ? (o = [], o[h] = r) : u !== "__proto__" && (o[u] = r);
          }
          r = o;
        }
        return r;
      }, Nyt = function(t, e, i, r) {
        if (t) {
          var a = i.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t, o = /(\[[^[\]]*])/, s = /(\[[^[\]]*])/g, l = i.depth > 0 && o.exec(a), u = l ? a.slice(0, l.index) : a, h = [];
          if (u) {
            if (!i.plainObjects && sb.call(Object.prototype, u) && !i.allowPrototypes) return;
            h.push(u);
          }
          for (var c = 0; i.depth > 0 && (l = s.exec(a)) !== null && c < i.depth; ) {
            if (c += 1, !i.plainObjects && sb.call(Object.prototype, l[1].slice(1, -1)) && !i.allowPrototypes) return;
            h.push(l[1]);
          }
          if (l) {
            if (i.strictDepth === true) throw new RangeError("Input depth exceeded depth option of " + i.depth + " and strictDepth is true");
            h.push("[" + a.slice(l.index) + "]");
          }
          return Pyt(h, e, i, r);
        }
      }, kyt = function(t) {
        if (!t) return _n;
        if (typeof t.allowEmptyArrays != "undefined" && typeof t.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof t.decodeDotInKeys != "undefined" && typeof t.decodeDotInKeys != "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
        if (t.decoder !== null && typeof t.decoder != "undefined" && typeof t.decoder != "function") throw new TypeError("Decoder has to be a function.");
        if (typeof t.charset != "undefined" && t.charset !== "utf-8" && t.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var e = typeof t.charset == "undefined" ? _n.charset : t.charset, i = typeof t.duplicates == "undefined" ? _n.duplicates : t.duplicates;
        if (i !== "combine" && i !== "first" && i !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
        var r = typeof t.allowDots == "undefined" ? t.decodeDotInKeys === true ? true : _n.allowDots : !!t.allowDots;
        return { allowDots: r, allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : _n.allowEmptyArrays, allowPrototypes: typeof t.allowPrototypes == "boolean" ? t.allowPrototypes : _n.allowPrototypes, allowSparse: typeof t.allowSparse == "boolean" ? t.allowSparse : _n.allowSparse, arrayLimit: typeof t.arrayLimit == "number" ? t.arrayLimit : _n.arrayLimit, charset: e, charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : _n.charsetSentinel, comma: typeof t.comma == "boolean" ? t.comma : _n.comma, decodeDotInKeys: typeof t.decodeDotInKeys == "boolean" ? t.decodeDotInKeys : _n.decodeDotInKeys, decoder: typeof t.decoder == "function" ? t.decoder : _n.decoder, delimiter: typeof t.delimiter == "string" || rg.isRegExp(t.delimiter) ? t.delimiter : _n.delimiter, depth: typeof t.depth == "number" || t.depth === false ? +t.depth : _n.depth, duplicates: i, ignoreQueryPrefix: t.ignoreQueryPrefix === true, interpretNumericEntities: typeof t.interpretNumericEntities == "boolean" ? t.interpretNumericEntities : _n.interpretNumericEntities, parameterLimit: typeof t.parameterLimit == "number" ? t.parameterLimit : _n.parameterLimit, parseArrays: t.parseArrays !== false, plainObjects: typeof t.plainObjects == "boolean" ? t.plainObjects : _n.plainObjects, strictDepth: typeof t.strictDepth == "boolean" ? !!t.strictDepth : _n.strictDepth, strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : _n.strictNullHandling };
      }, Fyt = function(n, t) {
        var e = kyt(t);
        if (n === "" || n === null || typeof n == "undefined") return e.plainObjects ? { __proto__: null } : {};
        for (var i = typeof n == "string" ? Lyt(n, e) : n, r = e.plainObjects ? { __proto__: null } : {}, a = Object.keys(i), o = 0; o < a.length; ++o) {
          var s = a[o], l = Nyt(s, i[s], e, typeof n == "string");
          r = rg.merge(r, l, e);
        }
        return e.allowSparse === true ? r : rg.compact(r);
      }, Qyt = Byt, Oyt = Fyt, zyt = ib, Gyt = { formats: zyt, parse: Oyt, stringify: Qyt };
      const Uyt = UA(Gyt), Vyt = function(n) {
        let t = 0;
        for (let e = 0, i = n.length - 1; e < i; ++e) n[e + 1] && (t += Math.sqrt(Math.pow(n[e + 1][0] - n[e][0], 2) + Math.pow(n[e + 1][1] - n[e][1], 2)));
        return t;
      }, jyt = function(n, t) {
        if (!n) return 0;
        let e = { x: n[0], y: n[1] }, i = { x: t[0], y: t[1] };
        const r = Math.abs(i.x - e.x), a = Math.abs(i.y - e.y), o = Math.sqrt(r * r + a * a), s = Math.asin(a / o);
        let l = 0;
        return i.y < e.y && i.x === e.x ? l = Math.PI * 2 / 3 : i.y > e.y && i.x === e.x ? l = Math.PI / 2 : i.y === e.y && i.x < e.x ? l = Math.PI : i.y === e.y && i.x > e.x ? l = 0 : i.y > e.y && i.x > e.x ? l = s : i.y > e.y && i.x < e.x ? l = Math.PI - s : i.y < e.y && i.x < e.x ? l = Math.PI + s : i.y < e.y && i.x > e.x && (l = Math.PI * 2 - s), l;
      }, qyt = function(n) {
        const t = n.map, e = n.pixel, i = n.coordinates, r = [];
        for (let a = 0; a < i.length - 1; a++) {
          const o = i[a], s = i[a + 1], l = t.getPixelFromCoordinate(o), u = t.getPixelFromCoordinate(s), c = Vyt([l, u]), f = Math.floor(c / e), g = jyt(l, u);
          for (let d = 1; d < f + 1; d++) {
            const A = [l[0] + e * d * Math.cos(g), l[1] + e * d * Math.sin(g)], p = t.getCoordinateFromPixel(A);
            r.push({ rotate: g, coordinate: p });
          }
        }
        return r;
      }, Hyt = (n) => {
        const { map: t, layer: e, icon: i } = n;
        if (!e) return;
        const r = e.getSource();
        if (!r) return;
        const a = { pixel: n.pixel || 50, coordinates: n.coordinates, map: t }, o = qyt(a), s = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABfUlEQVQ4T3WTTSvFYRDFf8dLKIqytFckthTpJkQWlyhF2fgEVr6BheytpChEsqB08xbZWPgOJAs7ieRlNMzV//75P7vnmZkz58ycR2ZWD7QBF5KM1DGzTuBO0k065neZ2S3QBGwAU5I+iolmNgrsAI9An6SrNIgDnAE9EdgFJiS9+93MuoEToBx4AgYkXSZBHKAWOAS6IrAP5CW9BUge2AIqgJdg8guiSKoBDoDeDJBhwNlVBsiQpNPvGST0VgF7TjPeCsCIpNdo0g84O2fibx4r/AJEUjVwlJDjXbybU/eZjAGbMROXmC8BiKQ64BxoDyYLkuYTTCeB9WD/9B9AA3AMdGQAzALLAfCcluDF3r01itMS5oDFiP3MIUHNi90T7ko/XjyYGOIMsFJSXByimTVGQbFzegOuew0o+7PGKL4AmjM8MA2shua/RjIzX1suw8pucZfiUjOt/AC4BHfaeOoz+d63oziX9Zla3CzAkqTP9G8zM4/dS7r+7zt/Aaattn1kX8VgAAAAAElFTkSuQmCC", l = 0.5;
        for (let u = 0; u < o.length; u++) {
          const h = o[u].coordinate, c = o[u].rotate, f = new xe({ geometry: new Oe(h) });
          f.setStyle(new de({ image: new Rr(zt(st({ src: s, scale: l }, i), { rotation: c })) })), f.set("isArrow", true), r.addFeature(f);
        }
      }, Az = (n) => {
        if (!n.map || !n.coordinates || n.coordinates.length < 2) return;
        const { layer: t } = n;
        Hyt(zt(st({}, n), { layer: t }));
      }, lb = N.defineComponent({ name: "OlRoute", __name: "index", props: { arrow: { default: 50 }, startStyle: {}, endStyle: {}, lineStyle: {}, stopsStyle: {}, layerId: {}, source: {}, layerStyle: {}, featureStyle: {}, modify: { type: Boolean }, className: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, renderOrder: {}, renderBuffer: {}, map: {}, declutter: { type: [String, Number, Boolean] }, background: {}, updateWhileAnimating: { type: Boolean }, updateWhileInteracting: { type: Boolean }, properties: {}, type: {}, url: {}, method: { default: "get" }, params: {} }, emits: ["resolve"], setup(n, { expose: t, emit: e }) {
        const i = N.inject("VMap"), r = N.unref(i).map, a = n;
        let o = N.ref();
        const s = N.shallowRef();
        let l = N.ref(), u = N.ref(), h = N.ref(), c = N.ref(), f = N.ref(), g = N.ref(false), d = N.ref(), A = N.ref(false), p = N.ref(), v = N.ref(false);
        const y = N.computed(() => g.value && A.value), m = { circle: { radius: 14, fill: { color: "rgba(255, 0, 0, 0.5)" }, stroke: { color: "rgba(255, 0, 0, 1)", width: 2 } }, text: { text: "", font: "bold 16px sans-serif", stroke: { color: "rgba(255, 255, 255, 1)", width: 3 } } }, _ = { circle: { radius: 10, fill: { color: "rgba(255, 140, 0, 0.5)" }, stroke: { color: "rgba(255, 140, 0, 1)", width: 2 } } }, E = { circle: { radius: 15, fill: { color: "rgba(0, 255, 0, 0.5)" }, stroke: { color: "rgba(0, 255, 0, 1)", width: 2 } }, text: { text: "", font: "bold 16px sans-serif", stroke: { color: "rgba(255, 255, 255, 1)", width: 3 } } }, I = { stroke: { color: "rgba(67, 126, 255, 0.6)", width: 10 } }, x = () => {
          let H = st({}, a);
          delete H.method, delete H.arrow, delete H.startStyle, delete H.lineStyle, delete H.endStyle, delete H.stopsStyle, delete H.params, delete H.url, delete H.type, o.value = H;
        };
        N.watchEffect(() => {
          x();
        }), N.onBeforeMount(() => {
          x();
        });
        const w = e, C = (H, W) => Rt(this, null, function* () {
          return fetch(H + "?" + W, { method: "get" }).then((it) => it.json()).then((it) => Promise.resolve(it)).catch((it) => Promise.reject(it));
        }), S = (H, W) => Rt(this, null, function* () {
          return fetch(H, { method: "post", body: JSON.stringify(W) }).then((it) => it.json()).then((it) => Promise.resolve(it)).catch((it) => Promise.reject(it));
        }), b = (H) => Rt(this, null, function* () {
          if (a.url) {
            if (a.method.toUpperCase() === "GET") return C(a.url, H).then((W) => (w("resolve", st({ type: a.type, method: a.method }, W)), Promise.resolve(W))).catch((W) => Promise.reject(W));
            if (a.method.toUpperCase() === "POST") return S(a.url, H).then((W) => W.json()).then((W) => (w("resolve", st({ type: a.type, method: a.method }, W)), Promise.resolve(W))).catch((W) => Promise.reject(W));
          }
        }), B = () => {
          const H = et(f.value, p.value, d.value);
          if (H.length === 0) return;
          const W = H.join(";"), it = zt(st({}, a.params), { stops: W }), kt = new URLSearchParams();
          for (const [vt, St] of Object.entries(it)) kt.append(encodeURIComponent(vt), typeof St == "string" ? St : JSON.stringify(St));
          return a.method === "GET" || a.method === "get" ? kt : it;
        }, T = () => Rt(this, null, function* () {
          const H = B();
          if (H) return b(H);
        }), D = () => Rt(this, null, function* () {
          const { error: H, routes: W, stops: it } = yield T();
          if (H) return new Error(H.message);
          if (W) {
            const vt = W.features[0].geometry.paths[0].map((bt) => [bt[0], bt[1]]);
            let St;
            if (it) {
              let bt = [];
              it.features.forEach((Ie) => {
                const fn = [Ie.geometry.x, Ie.geometry.y];
                bt.push(fn);
              }), F(bt[0]), Q(bt[bt.length - 1]);
              const rn = bt.slice(1, bt.length - 1).map((Ie, fn) => ({ index: fn, coordinate: Ie }));
              z(rn);
            } else St = vt.length - 1, F(vt[0]), Q(vt[St]);
            J(vt);
          }
        }), R = () => Rt(this, null, function* () {
          const { paths: H } = yield L();
          if (H) {
            const { points: W } = H[0];
            J(W.coordinates);
          }
        }), L = () => Rt(this, null, function* () {
          const H = k();
          if (H) return b(H);
        }), k = () => {
          const H = et(f.value, p.value, d.value);
          if (H.length !== 0) if (a.method === "get" || a.method === "GET") {
            let W = Uyt.stringify(a.params), it = "&point=";
            return H.forEach((kt, vt) => {
              it = it + kt[1] + "," + kt[0] + (vt < H.length - 1 ? "&point=" : "");
            }), W = W + it, W;
          } else return zt(st({}, a.params), { points: H });
        }, P = () => {
          a.type === "arcgis" ? D() : a.type === "graphhopper" && R();
        }, F = (H) => {
          var W;
          if ((W = s.value) == null || W.removeFeatureById("start"), H) {
            f.value = H;
            let it = E;
            Tn(a, "startStyle") && a.startStyle && (it = a.startStyle), l.value = { type: "Feature", geometry: { type: "Point", coordinates: H }, properties: { id: "start", style: it } };
          }
        }, Q = (H) => {
          var W;
          if ((W = s.value) == null || W.removeFeatureById("end"), H) {
            d.value = H;
            let it = m;
            Tn(a, "endStyle") && a.endStyle && (it = a.endStyle), u.value = { type: "Feature", geometry: { type: "Point", coordinates: H }, properties: { id: "end", style: it } };
          }
        }, z = (H) => {
          var it;
          const W = (it = s.value) == null ? void 0 : it.getSource();
          if (W) {
            const kt = W.getFeatures();
            kt && kt.length > 0 && kt.forEach((vt) => {
              var St;
              vt.get("isStops") && ((St = s.value) == null || St.removeFeatureById(vt.get("id")));
            });
          }
          if (H && H.length > 0) {
            p.value = H.map((vt) => vt.coordinate);
            let kt = _;
            Tn(a, "stopsStyle") && a.stopsStyle && (kt = a.stopsStyle), h.value = { type: "FeatureCollection", features: H.map((vt) => ({ type: "Feature", geometry: { type: "Point", coordinates: vt.coordinate }, properties: { isStops: true, id: `stop_${vt.index}`, style: kt } })) };
          }
        }, j = (H) => Rt(this, null, function* () {
          g.value = !!H, F(H), nt();
        }), $ = (H) => Rt(this, null, function* () {
          A.value = !!H, Q(H), nt();
        }), G = (H) => Rt(this, null, function* () {
          v.value = !!H, z(H), nt();
        });
        let tt = N.ref([]);
        const J = (H) => {
          var it, kt, vt;
          (it = s.value) == null || it.removeFeatureById("route");
          const W = (kt = s.value) == null ? void 0 : kt.getSource();
          if (W) {
            const St = W.getFeatures();
            St && St.length > 0 && St.forEach((bt) => {
              bt.get("isArrow") && W.removeFeature(bt);
            });
          }
          if (tt.value.forEach((St) => {
            rl(St);
          }), tt.value = [], H) {
            c.value = { type: "Feature", geometry: { type: "LineString", coordinates: H }, properties: { id: "route", style: st(st({}, I), a.lineStyle) } };
            const St = (vt = s.value) == null ? void 0 : vt.getLayer();
            W && a.arrow && (Az({ map: r, coordinates: H, layer: St, pixel: a.arrow }), tt.value.push(St == null ? void 0 : St.on("postrender", () => {
              const bt = r.getView().getZoom();
              W.getFeatures().forEach((Ee) => {
                Ee.get("isArrow") && W.removeFeature(Ee);
              }), bt && Math.round(bt) === bt && Az({ map: r, coordinates: H, layer: St, pixel: a.arrow });
            })));
          }
        }, et = (H, W, it) => {
          let kt = [H];
          return W && W.length > 0 && kt.push(...W), kt.push(it), kt;
        }, nt = () => {
          y.value && P();
        };
        return t({ setStartPoint: j, setEndPoint: $, setStopsPoints: G, reset: nt, clear: () => {
          g.value = false, A.value = false, v.value = false, z(), F(), Q(), J();
        } }), (H, W) => (N.openBlock(), N.createBlock(N.unref(qm), N.mergeProps({ ref_key: "vectorRef", ref: s }, N.unref(o)), { default: N.withCtx(() => [N.createVNode(N.unref(Ku), { "geo-json": N.unref(l) }, null, 8, ["geo-json"]), N.createVNode(N.unref(Ku), { "geo-json": N.unref(u) }, null, 8, ["geo-json"]), N.createVNode(N.unref(Ku), { "geo-json": N.unref(h) }, null, 8, ["geo-json"]), N.createVNode(N.unref(Ku), { "geo-json": N.unref(c) }, null, 8, ["geo-json"])]), _: 1 }, 16));
      } }), Yyt = (n) => n.component(lb.name || "OlRoute", lb);
      var ub = function(n, t) {
        return ub = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
          e.__proto__ = i;
        } || function(e, i) {
          for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]);
        }, ub(n, t);
      };
      function V(n, t) {
        if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        ub(n, t);
        function e() {
          this.constructor = n;
        }
        n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
      }
      var Wyt = /* @__PURE__ */ function() {
        function n() {
          this.firefox = false, this.ie = false, this.edge = false, this.newEdge = false, this.weChat = false;
        }
        return n;
      }(), Xyt = /* @__PURE__ */ function() {
        function n() {
          this.browser = new Wyt(), this.node = false, this.wxa = false, this.worker = false, this.svgSupported = false, this.touchEventsSupported = false, this.pointerEventsSupported = false, this.domSupported = false, this.transformSupported = false, this.transform3dSupported = false, this.hasGlobalWindow = typeof window != "undefined";
        }
        return n;
      }(), ee = new Xyt();
      typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (ee.wxa = true, ee.touchEventsSupported = true) : typeof document == "undefined" && typeof self != "undefined" ? ee.worker = true : typeof navigator == "undefined" || navigator.userAgent.indexOf("Node.js") === 0 ? (ee.node = true, ee.svgSupported = true) : Zyt(navigator.userAgent, ee);
      function Zyt(n, t) {
        var e = t.browser, i = n.match(/Firefox\/([\d.]+)/), r = n.match(/MSIE\s([\d.]+)/) || n.match(/Trident\/.+?rv:(([\d.]+))/), a = n.match(/Edge?\/([\d.]+)/), o = /micromessenger/i.test(n);
        i && (e.firefox = true, e.version = i[1]), r && (e.ie = true, e.version = r[1]), a && (e.edge = true, e.version = a[1], e.newEdge = +a[1].split(".")[0] > 18), o && (e.weChat = true), t.svgSupported = typeof SVGRect != "undefined", t.touchEventsSupported = "ontouchstart" in window && !e.ie && !e.edge, t.pointerEventsSupported = "onpointerdown" in window && (e.edge || e.ie && +e.version >= 11), t.domSupported = typeof document != "undefined";
        var s = document.documentElement.style;
        t.transform3dSupported = (e.ie && "transition" in s || e.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in s) && !("OTransition" in s), t.transformSupported = t.transform3dSupported || e.ie && +e.version >= 9;
      }
      var hb = 12, pz = "sans-serif", Ql = hb + "px " + pz, Kyt = 20, $yt = 100, Jyt = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
      function t0t(n) {
        var t = {};
        if (typeof JSON == "undefined") return t;
        for (var e = 0; e < n.length; e++) {
          var i = String.fromCharCode(e + 32), r = (n.charCodeAt(e) - Kyt) / $yt;
          t[i] = r;
        }
        return t;
      }
      var e0t = t0t(Jyt), Ol = { createCanvas: function() {
        return typeof document != "undefined" && document.createElement("canvas");
      }, measureText: /* @__PURE__ */ function() {
        var n, t;
        return function(e, i) {
          if (!n) {
            var r = Ol.createCanvas();
            n = r && r.getContext("2d");
          }
          if (n) return t !== i && (t = n.font = i || Ql), n.measureText(e);
          e = e || "", i = i || Ql;
          var a = /((?:\d+)?\.?\d*)px/.exec(i), o = a && +a[1] || hb, s = 0;
          if (i.indexOf("mono") >= 0) s = o * e.length;
          else for (var l = 0; l < e.length; l++) {
            var u = e0t[e[l]];
            s += u == null ? o : u * o;
          }
          return { width: s };
        };
      }(), loadImage: function(n, t, e) {
        var i = new Image();
        return i.onload = t, i.onerror = e, i.src = n, i;
      } }, vz = So(["Function", "RegExp", "Date", "Error", "CanvasGradient", "CanvasPattern", "Image", "Canvas"], function(n, t) {
        return n["[object " + t + "]"] = true, n;
      }, {}), yz = So(["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64"], function(n, t) {
        return n["[object " + t + "Array]"] = true, n;
      }, {}), ag = Object.prototype.toString, r_ = Array.prototype, n0t = r_.forEach, i0t = r_.filter, cb = r_.slice, r0t = r_.map, mz = (function() {
      }).constructor, a_ = mz ? mz.prototype : null, fb = "__proto__", a0t = 2311;
      function _z() {
        return a0t++;
      }
      function za() {
        for (var n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];
      }
      function xt(n) {
        if (n == null || typeof n != "object") return n;
        var t = n, e = ag.call(n);
        if (e === "[object Array]") {
          if (!hp(n)) {
            t = [];
            for (var i = 0, r = n.length; i < r; i++) t[i] = xt(n[i]);
          }
        } else if (yz[e]) {
          if (!hp(n)) {
            var a = n.constructor;
            if (a.from) t = a.from(n);
            else {
              t = new a(n.length);
              for (var i = 0, r = n.length; i < r; i++) t[i] = n[i];
            }
          }
        } else if (!vz[e] && !hp(n) && !eh(n)) {
          t = {};
          for (var o in n) n.hasOwnProperty(o) && o !== fb && (t[o] = xt(n[o]));
        }
        return t;
      }
      function qt(n, t, e) {
        if (!_t(t) || !_t(n)) return e ? xt(t) : n;
        for (var i in t) if (t.hasOwnProperty(i) && i !== fb) {
          var r = n[i], a = t[i];
          _t(a) && _t(r) && !X(a) && !X(r) && !eh(a) && !eh(r) && !Iz(a) && !Iz(r) && !hp(a) && !hp(r) ? qt(r, a, e) : (e || !(i in n)) && (n[i] = xt(t[i]));
        }
        return n;
      }
      function gb(n, t) {
        for (var e = n[0], i = 1, r = n.length; i < r; i++) e = qt(e, n[i], t);
        return e;
      }
      function Y(n, t) {
        if (Object.assign) Object.assign(n, t);
        else for (var e in t) t.hasOwnProperty(e) && e !== fb && (n[e] = t[e]);
        return n;
      }
      function Et(n, t, e) {
        for (var i = re(t), r = 0; r < i.length; r++) {
          var a = i[r];
          (e ? t[a] != null : n[a] == null) && (n[a] = t[a]);
        }
        return n;
      }
      function Wt(n, t) {
        if (n) {
          if (n.indexOf) return n.indexOf(t);
          for (var e = 0, i = n.length; e < i; e++) if (n[e] === t) return e;
        }
        return -1;
      }
      function o0t(n, t) {
        var e = n.prototype;
        function i() {
        }
        i.prototype = t.prototype, n.prototype = new i();
        for (var r in e) e.hasOwnProperty(r) && (n.prototype[r] = e[r]);
        n.prototype.constructor = n, n.superClass = t;
      }
      function Mn(n, t, e) {
        if (n = "prototype" in n ? n.prototype : n, t = "prototype" in t ? t.prototype : t, Object.getOwnPropertyNames) for (var i = Object.getOwnPropertyNames(t), r = 0; r < i.length; r++) {
          var a = i[r];
          a !== "constructor" && (e ? t[a] != null : n[a] == null) && (n[a] = t[a]);
        }
        else Et(n, t, e);
      }
      function Mi(n) {
        return !n || typeof n == "string" ? false : typeof n.length == "number";
      }
      function M(n, t, e) {
        if (n && t) if (n.forEach && n.forEach === n0t) n.forEach(t, e);
        else if (n.length === +n.length) for (var i = 0, r = n.length; i < r; i++) t.call(e, n[i], i, n);
        else for (var a in n) n.hasOwnProperty(a) && t.call(e, n[a], a, n);
      }
      function Z(n, t, e) {
        if (!n) return [];
        if (!t) return db(n);
        if (n.map && n.map === r0t) return n.map(t, e);
        for (var i = [], r = 0, a = n.length; r < a; r++) i.push(t.call(e, n[r], r, n));
        return i;
      }
      function So(n, t, e, i) {
        if (n && t) {
          for (var r = 0, a = n.length; r < a; r++) e = t.call(i, e, n[r], r, n);
          return e;
        }
      }
      function Ne(n, t, e) {
        if (!n) return [];
        if (!t) return db(n);
        if (n.filter && n.filter === i0t) return n.filter(t, e);
        for (var i = [], r = 0, a = n.length; r < a; r++) t.call(e, n[r], r, n) && i.push(n[r]);
        return i;
      }
      function s0t(n, t, e) {
        if (n && t) {
          for (var i = 0, r = n.length; i < r; i++) if (t.call(e, n[i], i, n)) return n[i];
        }
      }
      function re(n) {
        if (!n) return [];
        if (Object.keys) return Object.keys(n);
        var t = [];
        for (var e in n) n.hasOwnProperty(e) && t.push(e);
        return t;
      }
      function l0t(n, t) {
        for (var e = [], i = 2; i < arguments.length; i++) e[i - 2] = arguments[i];
        return function() {
          return n.apply(t, e.concat(cb.call(arguments)));
        };
      }
      var ct = a_ && yt(a_.bind) ? a_.call.bind(a_.bind) : l0t;
      function Ot(n) {
        for (var t = [], e = 1; e < arguments.length; e++) t[e - 1] = arguments[e];
        return function() {
          return n.apply(this, t.concat(cb.call(arguments)));
        };
      }
      function X(n) {
        return Array.isArray ? Array.isArray(n) : ag.call(n) === "[object Array]";
      }
      function yt(n) {
        return typeof n == "function";
      }
      function ht(n) {
        return typeof n == "string";
      }
      function o_(n) {
        return ag.call(n) === "[object String]";
      }
      function pe(n) {
        return typeof n == "number";
      }
      function _t(n) {
        var t = typeof n;
        return t === "function" || !!n && t === "object";
      }
      function Iz(n) {
        return !!vz[ag.call(n)];
      }
      function Ui(n) {
        return !!yz[ag.call(n)];
      }
      function eh(n) {
        return typeof n == "object" && typeof n.nodeType == "number" && typeof n.ownerDocument == "object";
      }
      function s_(n) {
        return n.colorStops != null;
      }
      function u0t(n) {
        return n.image != null;
      }
      function Ez(n) {
        return ag.call(n) === "[object RegExp]";
      }
      function nh(n) {
        return n !== n;
      }
      function Dn() {
        for (var n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];
        for (var e = 0, i = n.length; e < i; e++) if (n[e] != null) return n[e];
      }
      function Pt(n, t) {
        return n != null ? n : t;
      }
      function ra(n, t, e) {
        return n != null ? n : t != null ? t : e;
      }
      function db(n) {
        for (var t = [], e = 1; e < arguments.length; e++) t[e - 1] = arguments[e];
        return cb.apply(n, t);
      }
      function Ab(n) {
        if (typeof n == "number") return [n, n, n, n];
        var t = n.length;
        return t === 2 ? [n[0], n[1], n[0], n[1]] : t === 3 ? [n[0], n[1], n[2], n[1]] : n;
      }
      function It(n, t) {
        if (!n) throw new Error(t);
      }
      function Ga(n) {
        return n == null ? null : typeof n.trim == "function" ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
      }
      var xz = "__ec_primitive__";
      function l_(n) {
        n[xz] = true;
      }
      function hp(n) {
        return n[xz];
      }
      var h0t = function() {
        function n() {
          this.data = {};
        }
        return n.prototype.delete = function(t) {
          var e = this.has(t);
          return e && delete this.data[t], e;
        }, n.prototype.has = function(t) {
          return this.data.hasOwnProperty(t);
        }, n.prototype.get = function(t) {
          return this.data[t];
        }, n.prototype.set = function(t, e) {
          return this.data[t] = e, this;
        }, n.prototype.keys = function() {
          return re(this.data);
        }, n.prototype.forEach = function(t) {
          var e = this.data;
          for (var i in e) e.hasOwnProperty(i) && t(e[i], i);
        }, n;
      }(), wz = typeof Map == "function";
      function c0t() {
        return wz ? /* @__PURE__ */ new Map() : new h0t();
      }
      var f0t = function() {
        function n(t) {
          var e = X(t);
          this.data = c0t();
          var i = this;
          t instanceof n ? t.each(r) : t && M(t, r);
          function r(a, o) {
            e ? i.set(a, o) : i.set(o, a);
          }
        }
        return n.prototype.hasKey = function(t) {
          return this.data.has(t);
        }, n.prototype.get = function(t) {
          return this.data.get(t);
        }, n.prototype.set = function(t, e) {
          return this.data.set(t, e), e;
        }, n.prototype.each = function(t, e) {
          this.data.forEach(function(i, r) {
            t.call(e, i, r);
          });
        }, n.prototype.keys = function() {
          var t = this.data.keys();
          return wz ? Array.from(t) : t;
        }, n.prototype.removeKey = function(t) {
          this.data.delete(t);
        }, n;
      }();
      function dt(n) {
        return new f0t(n);
      }
      function u_(n, t) {
        for (var e = new n.constructor(n.length + t.length), i = 0; i < n.length; i++) e[i] = n[i];
        for (var r = n.length, i = 0; i < t.length; i++) e[i + r] = t[i];
        return e;
      }
      function h_(n, t) {
        var e;
        if (Object.create) e = Object.create(n);
        else {
          var i = function() {
          };
          i.prototype = n, e = new i();
        }
        return t && Y(e, t), e;
      }
      function Cz(n) {
        var t = n.style;
        t.webkitUserSelect = "none", t.userSelect = "none", t.webkitTapHighlightColor = "rgba(0,0,0,0)", t["-webkit-touch-callout"] = "none";
      }
      function ft(n, t) {
        return n.hasOwnProperty(t);
      }
      function In() {
      }
      var c_ = 180 / Math.PI;
      function ih(n, t) {
        return n == null && (n = 0), t == null && (t = 0), [n, t];
      }
      function Vi(n, t) {
        return n[0] = t[0], n[1] = t[1], n;
      }
      function ws(n) {
        return [n[0], n[1]];
      }
      function g0t(n, t, e) {
        return n[0] = t, n[1] = e, n;
      }
      function Sz(n, t, e) {
        return n[0] = t[0] + e[0], n[1] = t[1] + e[1], n;
      }
      function pb(n, t, e, i) {
        return n[0] = t[0] + e[0] * i, n[1] = t[1] + e[1] * i, n;
      }
      function rh(n, t, e) {
        return n[0] = t[0] - e[0], n[1] = t[1] - e[1], n;
      }
      function vb(n) {
        return Math.sqrt(d0t(n));
      }
      function d0t(n) {
        return n[0] * n[0] + n[1] * n[1];
      }
      function f_(n, t, e) {
        return n[0] = t[0] * e, n[1] = t[1] * e, n;
      }
      function og(n, t) {
        var e = vb(t);
        return e === 0 ? (n[0] = 0, n[1] = 0) : (n[0] = t[0] / e, n[1] = t[1] / e), n;
      }
      function yb(n, t) {
        return Math.sqrt((n[0] - t[0]) * (n[0] - t[0]) + (n[1] - t[1]) * (n[1] - t[1]));
      }
      var zl = yb;
      function A0t(n, t) {
        return (n[0] - t[0]) * (n[0] - t[0]) + (n[1] - t[1]) * (n[1] - t[1]);
      }
      var ah = A0t;
      function g_(n, t, e, i) {
        return n[0] = t[0] + i * (e[0] - t[0]), n[1] = t[1] + i * (e[1] - t[1]), n;
      }
      function di(n, t, e) {
        var i = t[0], r = t[1];
        return n[0] = e[0] * i + e[2] * r + e[4], n[1] = e[1] * i + e[3] * r + e[5], n;
      }
      function Gl(n, t, e) {
        return n[0] = Math.min(t[0], e[0]), n[1] = Math.min(t[1], e[1]), n;
      }
      function Ul(n, t, e) {
        return n[0] = Math.max(t[0], e[0]), n[1] = Math.max(t[1], e[1]), n;
      }
      var sg = /* @__PURE__ */ function() {
        function n(t, e) {
          this.target = t, this.topTarget = e && e.topTarget;
        }
        return n;
      }(), p0t = function() {
        function n(t) {
          this.handler = t, t.on("mousedown", this._dragStart, this), t.on("mousemove", this._drag, this), t.on("mouseup", this._dragEnd, this);
        }
        return n.prototype._dragStart = function(t) {
          for (var e = t.target; e && !e.draggable; ) e = e.parent || e.__hostTarget;
          e && (this._draggingTarget = e, e.dragging = true, this._x = t.offsetX, this._y = t.offsetY, this.handler.dispatchToElement(new sg(e, t), "dragstart", t.event));
        }, n.prototype._drag = function(t) {
          var e = this._draggingTarget;
          if (e) {
            var i = t.offsetX, r = t.offsetY, a = i - this._x, o = r - this._y;
            this._x = i, this._y = r, e.drift(a, o, t), this.handler.dispatchToElement(new sg(e, t), "drag", t.event);
            var s = this.handler.findHover(i, r, e).target, l = this._dropTarget;
            this._dropTarget = s, e !== s && (l && s !== l && this.handler.dispatchToElement(new sg(l, t), "dragleave", t.event), s && s !== l && this.handler.dispatchToElement(new sg(s, t), "dragenter", t.event));
          }
        }, n.prototype._dragEnd = function(t) {
          var e = this._draggingTarget;
          e && (e.dragging = false), this.handler.dispatchToElement(new sg(e, t), "dragend", t.event), this._dropTarget && this.handler.dispatchToElement(new sg(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null;
        }, n;
      }(), aa = function() {
        function n(t) {
          t && (this._$eventProcessor = t);
        }
        return n.prototype.on = function(t, e, i, r) {
          this._$handlers || (this._$handlers = {});
          var a = this._$handlers;
          if (typeof e == "function" && (r = i, i = e, e = null), !i || !t) return this;
          var o = this._$eventProcessor;
          e != null && o && o.normalizeQuery && (e = o.normalizeQuery(e)), a[t] || (a[t] = []);
          for (var s = 0; s < a[t].length; s++) if (a[t][s].h === i) return this;
          var l = { h: i, query: e, ctx: r || this, callAtLast: i.zrEventfulCallAtLast }, u = a[t].length - 1, h = a[t][u];
          return h && h.callAtLast ? a[t].splice(u, 0, l) : a[t].push(l), this;
        }, n.prototype.isSilent = function(t) {
          var e = this._$handlers;
          return !e || !e[t] || !e[t].length;
        }, n.prototype.off = function(t, e) {
          var i = this._$handlers;
          if (!i) return this;
          if (!t) return this._$handlers = {}, this;
          if (e) {
            if (i[t]) {
              for (var r = [], a = 0, o = i[t].length; a < o; a++) i[t][a].h !== e && r.push(i[t][a]);
              i[t] = r;
            }
            i[t] && i[t].length === 0 && delete i[t];
          } else delete i[t];
          return this;
        }, n.prototype.trigger = function(t) {
          for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
          if (!this._$handlers) return this;
          var r = this._$handlers[t], a = this._$eventProcessor;
          if (r) for (var o = e.length, s = r.length, l = 0; l < s; l++) {
            var u = r[l];
            if (!(a && a.filter && u.query != null && !a.filter(t, u.query))) switch (o) {
              case 0:
                u.h.call(u.ctx);
                break;
              case 1:
                u.h.call(u.ctx, e[0]);
                break;
              case 2:
                u.h.call(u.ctx, e[0], e[1]);
                break;
              default:
                u.h.apply(u.ctx, e);
                break;
            }
          }
          return a && a.afterTrigger && a.afterTrigger(t), this;
        }, n.prototype.triggerWithContext = function(t) {
          for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
          if (!this._$handlers) return this;
          var r = this._$handlers[t], a = this._$eventProcessor;
          if (r) for (var o = e.length, s = e[o - 1], l = r.length, u = 0; u < l; u++) {
            var h = r[u];
            if (!(a && a.filter && h.query != null && !a.filter(t, h.query))) switch (o) {
              case 0:
                h.h.call(s);
                break;
              case 1:
                h.h.call(s, e[0]);
                break;
              case 2:
                h.h.call(s, e[0], e[1]);
                break;
              default:
                h.h.apply(s, e.slice(1, o - 1));
                break;
            }
          }
          return a && a.afterTrigger && a.afterTrigger(t), this;
        }, n;
      }(), v0t = Math.log(2);
      function mb(n, t, e, i, r, a) {
        var o = i + "-" + r, s = n.length;
        if (a.hasOwnProperty(o)) return a[o];
        if (t === 1) {
          var l = Math.round(Math.log((1 << s) - 1 & ~r) / v0t);
          return n[e][l];
        }
        for (var u = i | 1 << e, h = e + 1; i & 1 << h; ) h++;
        for (var c = 0, f = 0, g = 0; f < s; f++) {
          var d = 1 << f;
          d & r || (c += (g % 2 ? -1 : 1) * n[e][f] * mb(n, t - 1, h, u, r | d, a), g++);
        }
        return a[o] = c, c;
      }
      function bz(n, t) {
        var e = [[n[0], n[1], 1, 0, 0, 0, -t[0] * n[0], -t[0] * n[1]], [0, 0, 0, n[0], n[1], 1, -t[1] * n[0], -t[1] * n[1]], [n[2], n[3], 1, 0, 0, 0, -t[2] * n[2], -t[2] * n[3]], [0, 0, 0, n[2], n[3], 1, -t[3] * n[2], -t[3] * n[3]], [n[4], n[5], 1, 0, 0, 0, -t[4] * n[4], -t[4] * n[5]], [0, 0, 0, n[4], n[5], 1, -t[5] * n[4], -t[5] * n[5]], [n[6], n[7], 1, 0, 0, 0, -t[6] * n[6], -t[6] * n[7]], [0, 0, 0, n[6], n[7], 1, -t[7] * n[6], -t[7] * n[7]]], i = {}, r = mb(e, 8, 0, 0, 0, i);
        if (r !== 0) {
          for (var a = [], o = 0; o < 8; o++) for (var s = 0; s < 8; s++) a[s] == null && (a[s] = 0), a[s] += ((o + s) % 2 ? -1 : 1) * mb(e, 7, o === 0 ? 1 : 0, 1 << o, 1 << s, i) / r * t[o];
          return function(l, u, h) {
            var c = u * a[6] + h * a[7] + 1;
            l[0] = (u * a[0] + h * a[1] + a[2]) / c, l[1] = (u * a[3] + h * a[4] + a[5]) / c;
          };
        }
      }
      var Bz = "___zrEVENTSAVED", _b = [];
      function y0t(n, t, e, i, r) {
        return Ib(_b, t, i, r, true) && Ib(n, e, _b[0], _b[1]);
      }
      function Ib(n, t, e, i, r) {
        if (t.getBoundingClientRect && ee.domSupported && !Tz(t)) {
          var a = t[Bz] || (t[Bz] = {}), o = m0t(t, a), s = _0t(o, a, r);
          if (s) return s(n, e, i), true;
        }
        return false;
      }
      function m0t(n, t) {
        var e = t.markers;
        if (e) return e;
        e = t.markers = [];
        for (var i = ["left", "right"], r = ["top", "bottom"], a = 0; a < 4; a++) {
          var o = document.createElement("div"), s = o.style, l = a % 2, u = (a >> 1) % 2;
          s.cssText = ["position: absolute", "visibility: hidden", "padding: 0", "margin: 0", "border-width: 0", "user-select: none", "width:0", "height:0", i[l] + ":0", r[u] + ":0", i[1 - l] + ":auto", r[1 - u] + ":auto", ""].join("!important;"), n.appendChild(o), e.push(o);
        }
        return e;
      }
      function _0t(n, t, e) {
        for (var i = e ? "invTrans" : "trans", r = t[i], a = t.srcCoords, o = [], s = [], l = true, u = 0; u < 4; u++) {
          var h = n[u].getBoundingClientRect(), c = 2 * u, f = h.left, g = h.top;
          o.push(f, g), l = l && a && f === a[c] && g === a[c + 1], s.push(n[u].offsetLeft, n[u].offsetTop);
        }
        return l && r ? r : (t.srcCoords = o, t[i] = e ? bz(s, o) : bz(o, s));
      }
      function Tz(n) {
        return n.nodeName.toUpperCase() === "CANVAS";
      }
      var I0t = /([&<>"'])/g, E0t = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
      function pr(n) {
        return n == null ? "" : (n + "").replace(I0t, function(t, e) {
          return E0t[e];
        });
      }
      var x0t = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, Eb = [], w0t = ee.browser.firefox && +ee.browser.version.split(".")[0] < 39;
      function xb(n, t, e, i) {
        return e = e || {}, i ? Mz(n, t, e) : w0t && t.layerX != null && t.layerX !== t.offsetX ? (e.zrX = t.layerX, e.zrY = t.layerY) : t.offsetX != null ? (e.zrX = t.offsetX, e.zrY = t.offsetY) : Mz(n, t, e), e;
      }
      function Mz(n, t, e) {
        if (ee.domSupported && n.getBoundingClientRect) {
          var i = t.clientX, r = t.clientY;
          if (Tz(n)) {
            var a = n.getBoundingClientRect();
            e.zrX = i - a.left, e.zrY = r - a.top;
            return;
          } else if (Ib(Eb, n, i, r)) {
            e.zrX = Eb[0], e.zrY = Eb[1];
            return;
          }
        }
        e.zrX = e.zrY = 0;
      }
      function wb(n) {
        return n || window.event;
      }
      function oa(n, t, e) {
        if (t = wb(t), t.zrX != null) return t;
        var i = t.type, r = i && i.indexOf("touch") >= 0;
        if (r) {
          var o = i !== "touchend" ? t.targetTouches[0] : t.changedTouches[0];
          o && xb(n, o, t, e);
        } else {
          xb(n, t, t, e);
          var a = C0t(t);
          t.zrDelta = a ? a / 120 : -(t.detail || 0) / 3;
        }
        var s = t.button;
        return t.which == null && s !== void 0 && x0t.test(t.type) && (t.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), t;
      }
      function C0t(n) {
        var t = n.wheelDelta;
        if (t) return t;
        var e = n.deltaX, i = n.deltaY;
        if (e == null || i == null) return t;
        var r = Math.abs(i !== 0 ? i : e), a = i > 0 ? -1 : i < 0 ? 1 : e > 0 ? -1 : 1;
        return 3 * r * a;
      }
      function Cb(n, t, e, i) {
        n.addEventListener(t, e, i);
      }
      function S0t(n, t, e, i) {
        n.removeEventListener(t, e, i);
      }
      var Cs = function(n) {
        n.preventDefault(), n.stopPropagation(), n.cancelBubble = true;
      };
      function Dz(n) {
        return n.which === 2 || n.which === 3;
      }
      var b0t = function() {
        function n() {
          this._track = [];
        }
        return n.prototype.recognize = function(t, e, i) {
          return this._doTrack(t, e, i), this._recognize(t);
        }, n.prototype.clear = function() {
          return this._track.length = 0, this;
        }, n.prototype._doTrack = function(t, e, i) {
          var r = t.touches;
          if (r) {
            for (var a = { points: [], touches: [], target: e, event: t }, o = 0, s = r.length; o < s; o++) {
              var l = r[o], u = xb(i, l, {});
              a.points.push([u.zrX, u.zrY]), a.touches.push(l);
            }
            this._track.push(a);
          }
        }, n.prototype._recognize = function(t) {
          for (var e in Sb) if (Sb.hasOwnProperty(e)) {
            var i = Sb[e](this._track, t);
            if (i) return i;
          }
        }, n;
      }();
      function Rz(n) {
        var t = n[1][0] - n[0][0], e = n[1][1] - n[0][1];
        return Math.sqrt(t * t + e * e);
      }
      function B0t(n) {
        return [(n[0][0] + n[1][0]) / 2, (n[0][1] + n[1][1]) / 2];
      }
      var Sb = { pinch: function(n, t) {
        var e = n.length;
        if (e) {
          var i = (n[e - 1] || {}).points, r = (n[e - 2] || {}).points || i;
          if (r && r.length > 1 && i && i.length > 1) {
            var a = Rz(i) / Rz(r);
            !isFinite(a) && (a = 1), t.pinchScale = a;
            var o = B0t(i);
            return t.pinchX = o[0], t.pinchY = o[1], { type: "pinch", target: n[0].target, event: t };
          }
        }
      } };
      function Fr() {
        return [1, 0, 0, 1, 0, 0];
      }
      function d_(n) {
        return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 1, n[4] = 0, n[5] = 0, n;
      }
      function bb(n, t) {
        return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n;
      }
      function Ss(n, t, e) {
        var i = t[0] * e[0] + t[2] * e[1], r = t[1] * e[0] + t[3] * e[1], a = t[0] * e[2] + t[2] * e[3], o = t[1] * e[2] + t[3] * e[3], s = t[0] * e[4] + t[2] * e[5] + t[4], l = t[1] * e[4] + t[3] * e[5] + t[5];
        return n[0] = i, n[1] = r, n[2] = a, n[3] = o, n[4] = s, n[5] = l, n;
      }
      function bo(n, t, e) {
        return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4] + e[0], n[5] = t[5] + e[1], n;
      }
      function oh(n, t, e, i) {
        i === void 0 && (i = [0, 0]);
        var r = t[0], a = t[2], o = t[4], s = t[1], l = t[3], u = t[5], h = Math.sin(e), c = Math.cos(e);
        return n[0] = r * c + s * h, n[1] = -r * h + s * c, n[2] = a * c + l * h, n[3] = -a * h + c * l, n[4] = c * (o - i[0]) + h * (u - i[1]) + i[0], n[5] = c * (u - i[1]) - h * (o - i[0]) + i[1], n;
      }
      function Bb(n, t, e) {
        var i = e[0], r = e[1];
        return n[0] = t[0] * i, n[1] = t[1] * r, n[2] = t[2] * i, n[3] = t[3] * r, n[4] = t[4] * i, n[5] = t[5] * r, n;
      }
      function lg(n, t) {
        var e = t[0], i = t[2], r = t[4], a = t[1], o = t[3], s = t[5], l = e * o - a * i;
        return l ? (l = 1 / l, n[0] = o * l, n[1] = -a * l, n[2] = -i * l, n[3] = e * l, n[4] = (i * s - o * r) * l, n[5] = (a * r - e * s) * l, n) : null;
      }
      function T0t(n) {
        var t = Fr();
        return bb(t, n), t;
      }
      var Ut = function() {
        function n(t, e) {
          this.x = t || 0, this.y = e || 0;
        }
        return n.prototype.copy = function(t) {
          return this.x = t.x, this.y = t.y, this;
        }, n.prototype.clone = function() {
          return new n(this.x, this.y);
        }, n.prototype.set = function(t, e) {
          return this.x = t, this.y = e, this;
        }, n.prototype.equal = function(t) {
          return t.x === this.x && t.y === this.y;
        }, n.prototype.add = function(t) {
          return this.x += t.x, this.y += t.y, this;
        }, n.prototype.scale = function(t) {
          this.x *= t, this.y *= t;
        }, n.prototype.scaleAndAdd = function(t, e) {
          this.x += t.x * e, this.y += t.y * e;
        }, n.prototype.sub = function(t) {
          return this.x -= t.x, this.y -= t.y, this;
        }, n.prototype.dot = function(t) {
          return this.x * t.x + this.y * t.y;
        }, n.prototype.len = function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, n.prototype.lenSquare = function() {
          return this.x * this.x + this.y * this.y;
        }, n.prototype.normalize = function() {
          var t = this.len();
          return this.x /= t, this.y /= t, this;
        }, n.prototype.distance = function(t) {
          var e = this.x - t.x, i = this.y - t.y;
          return Math.sqrt(e * e + i * i);
        }, n.prototype.distanceSquare = function(t) {
          var e = this.x - t.x, i = this.y - t.y;
          return e * e + i * i;
        }, n.prototype.negate = function() {
          return this.x = -this.x, this.y = -this.y, this;
        }, n.prototype.transform = function(t) {
          if (t) {
            var e = this.x, i = this.y;
            return this.x = t[0] * e + t[2] * i + t[4], this.y = t[1] * e + t[3] * i + t[5], this;
          }
        }, n.prototype.toArray = function(t) {
          return t[0] = this.x, t[1] = this.y, t;
        }, n.prototype.fromArray = function(t) {
          this.x = t[0], this.y = t[1];
        }, n.set = function(t, e, i) {
          t.x = e, t.y = i;
        }, n.copy = function(t, e) {
          t.x = e.x, t.y = e.y;
        }, n.len = function(t) {
          return Math.sqrt(t.x * t.x + t.y * t.y);
        }, n.lenSquare = function(t) {
          return t.x * t.x + t.y * t.y;
        }, n.dot = function(t, e) {
          return t.x * e.x + t.y * e.y;
        }, n.add = function(t, e, i) {
          t.x = e.x + i.x, t.y = e.y + i.y;
        }, n.sub = function(t, e, i) {
          t.x = e.x - i.x, t.y = e.y - i.y;
        }, n.scale = function(t, e, i) {
          t.x = e.x * i, t.y = e.y * i;
        }, n.scaleAndAdd = function(t, e, i, r) {
          t.x = e.x + i.x * r, t.y = e.y + i.y * r;
        }, n.lerp = function(t, e, i, r) {
          var a = 1 - r;
          t.x = a * e.x + r * i.x, t.y = a * e.y + r * i.y;
        }, n;
      }(), A_ = Math.min, p_ = Math.max, sh = new Ut(), lh = new Ut(), uh = new Ut(), hh = new Ut(), cp = new Ut(), fp = new Ut(), Ht = function() {
        function n(t, e, i, r) {
          i < 0 && (t = t + i, i = -i), r < 0 && (e = e + r, r = -r), this.x = t, this.y = e, this.width = i, this.height = r;
        }
        return n.prototype.union = function(t) {
          var e = A_(t.x, this.x), i = A_(t.y, this.y);
          isFinite(this.x) && isFinite(this.width) ? this.width = p_(t.x + t.width, this.x + this.width) - e : this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = p_(t.y + t.height, this.y + this.height) - i : this.height = t.height, this.x = e, this.y = i;
        }, n.prototype.applyTransform = function(t) {
          n.applyTransform(this, this, t);
        }, n.prototype.calculateTransform = function(t) {
          var e = this, i = t.width / e.width, r = t.height / e.height, a = Fr();
          return bo(a, a, [-e.x, -e.y]), Bb(a, a, [i, r]), bo(a, a, [t.x, t.y]), a;
        }, n.prototype.intersect = function(t, e) {
          if (!t) return false;
          t instanceof n || (t = n.create(t));
          var i = this, r = i.x, a = i.x + i.width, o = i.y, s = i.y + i.height, l = t.x, u = t.x + t.width, h = t.y, c = t.y + t.height, f = !(a < l || u < r || s < h || c < o);
          if (e) {
            var g = 1 / 0, d = 0, A = Math.abs(a - l), p = Math.abs(u - r), v = Math.abs(s - h), y = Math.abs(c - o), m = Math.min(A, p), _ = Math.min(v, y);
            a < l || u < r ? m > d && (d = m, A < p ? Ut.set(fp, -A, 0) : Ut.set(fp, p, 0)) : m < g && (g = m, A < p ? Ut.set(cp, A, 0) : Ut.set(cp, -p, 0)), s < h || c < o ? _ > d && (d = _, v < y ? Ut.set(fp, 0, -v) : Ut.set(fp, 0, y)) : m < g && (g = m, v < y ? Ut.set(cp, 0, v) : Ut.set(cp, 0, -y));
          }
          return e && Ut.copy(e, f ? cp : fp), f;
        }, n.prototype.contain = function(t, e) {
          var i = this;
          return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i.height;
        }, n.prototype.clone = function() {
          return new n(this.x, this.y, this.width, this.height);
        }, n.prototype.copy = function(t) {
          n.copy(this, t);
        }, n.prototype.plain = function() {
          return { x: this.x, y: this.y, width: this.width, height: this.height };
        }, n.prototype.isFinite = function() {
          return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
        }, n.prototype.isZero = function() {
          return this.width === 0 || this.height === 0;
        }, n.create = function(t) {
          return new n(t.x, t.y, t.width, t.height);
        }, n.copy = function(t, e) {
          t.x = e.x, t.y = e.y, t.width = e.width, t.height = e.height;
        }, n.applyTransform = function(t, e, i) {
          if (!i) {
            t !== e && n.copy(t, e);
            return;
          }
          if (i[1] < 1e-5 && i[1] > -1e-5 && i[2] < 1e-5 && i[2] > -1e-5) {
            var r = i[0], a = i[3], o = i[4], s = i[5];
            t.x = e.x * r + o, t.y = e.y * a + s, t.width = e.width * r, t.height = e.height * a, t.width < 0 && (t.x += t.width, t.width = -t.width), t.height < 0 && (t.y += t.height, t.height = -t.height);
            return;
          }
          sh.x = uh.x = e.x, sh.y = hh.y = e.y, lh.x = hh.x = e.x + e.width, lh.y = uh.y = e.y + e.height, sh.transform(i), hh.transform(i), lh.transform(i), uh.transform(i), t.x = A_(sh.x, lh.x, uh.x, hh.x), t.y = A_(sh.y, lh.y, uh.y, hh.y);
          var l = p_(sh.x, lh.x, uh.x, hh.x), u = p_(sh.y, lh.y, uh.y, hh.y);
          t.width = l - t.x, t.height = u - t.y;
        }, n;
      }(), Lz = "silent";
      function M0t(n, t, e) {
        return { type: n, event: e, target: t.target, topTarget: t.topTarget, cancelBubble: false, offsetX: e.zrX, offsetY: e.zrY, gestureEvent: e.gestureEvent, pinchX: e.pinchX, pinchY: e.pinchY, pinchScale: e.pinchScale, wheelDelta: e.zrDelta, zrByTouch: e.zrByTouch, which: e.which, stop: D0t };
      }
      function D0t() {
        Cs(this.event);
      }
      var R0t = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.handler = null, e;
        }
        return t.prototype.dispose = function() {
        }, t.prototype.setCursor = function() {
        }, t;
      }(aa), gp = /* @__PURE__ */ function() {
        function n(t, e) {
          this.x = t, this.y = e;
        }
        return n;
      }(), L0t = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"], Tb = new Ht(0, 0, 0, 0), Pz = function(n) {
        V(t, n);
        function t(e, i, r, a, o) {
          var s = n.call(this) || this;
          return s._hovered = new gp(0, 0), s.storage = e, s.painter = i, s.painterRoot = a, s._pointerSize = o, r = r || new R0t(), s.proxy = null, s.setHandlerProxy(r), s._draggingMgr = new p0t(s), s;
        }
        return t.prototype.setHandlerProxy = function(e) {
          this.proxy && this.proxy.dispose(), e && (M(L0t, function(i) {
            e.on && e.on(i, this[i], this);
          }, this), e.handler = this), this.proxy = e;
        }, t.prototype.mousemove = function(e) {
          var i = e.zrX, r = e.zrY, a = kz(this, i, r), o = this._hovered, s = o.target;
          s && !s.__zr && (o = this.findHover(o.x, o.y), s = o.target);
          var l = this._hovered = a ? new gp(i, r) : this.findHover(i, r), u = l.target, h = this.proxy;
          h.setCursor && h.setCursor(u ? u.cursor : "default"), s && u !== s && this.dispatchToElement(o, "mouseout", e), this.dispatchToElement(l, "mousemove", e), u && u !== s && this.dispatchToElement(l, "mouseover", e);
        }, t.prototype.mouseout = function(e) {
          var i = e.zrEventControl;
          i !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", e), i !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: e });
        }, t.prototype.resize = function() {
          this._hovered = new gp(0, 0);
        }, t.prototype.dispatch = function(e, i) {
          var r = this[e];
          r && r.call(this, i);
        }, t.prototype.dispose = function() {
          this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
        }, t.prototype.setCursorStyle = function(e) {
          var i = this.proxy;
          i.setCursor && i.setCursor(e);
        }, t.prototype.dispatchToElement = function(e, i, r) {
          e = e || {};
          var a = e.target;
          if (!(a && a.silent)) {
            for (var o = "on" + i, s = M0t(i, e, r); a && (a[o] && (s.cancelBubble = !!a[o].call(a, s)), a.trigger(i, s), a = a.__hostTarget ? a.__hostTarget : a.parent, !s.cancelBubble); ) ;
            s.cancelBubble || (this.trigger(i, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
              typeof l[o] == "function" && l[o].call(l, s), l.trigger && l.trigger(i, s);
            }));
          }
        }, t.prototype.findHover = function(e, i, r) {
          var a = this.storage.getDisplayList(), o = new gp(e, i);
          if (Nz(a, o, e, i, r), this._pointerSize && !o.target) {
            for (var s = [], l = this._pointerSize, u = l / 2, h = new Ht(e - u, i - u, l, l), c = a.length - 1; c >= 0; c--) {
              var f = a[c];
              f !== r && !f.ignore && !f.ignoreCoarsePointer && (!f.parent || !f.parent.ignoreCoarsePointer) && (Tb.copy(f.getBoundingRect()), f.transform && Tb.applyTransform(f.transform), Tb.intersect(h) && s.push(f));
            }
            if (s.length) for (var g = 4, d = Math.PI / 12, A = Math.PI * 2, p = 0; p < u; p += g) for (var v = 0; v < A; v += d) {
              var y = e + p * Math.cos(v), m = i + p * Math.sin(v);
              if (Nz(s, o, y, m, r), o.target) return o;
            }
          }
          return o;
        }, t.prototype.processGesture = function(e, i) {
          this._gestureMgr || (this._gestureMgr = new b0t());
          var r = this._gestureMgr;
          i === "start" && r.clear();
          var a = r.recognize(e, this.findHover(e.zrX, e.zrY, null).target, this.proxy.dom);
          if (i === "end" && r.clear(), a) {
            var o = a.type;
            e.gestureEvent = o;
            var s = new gp();
            s.target = a.target, this.dispatchToElement(s, o, a.event);
          }
        }, t;
      }(aa);
      M(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(n) {
        Pz.prototype[n] = function(t) {
          var e = t.zrX, i = t.zrY, r = kz(this, e, i), a, o;
          if ((n !== "mouseup" || !r) && (a = this.findHover(e, i), o = a.target), n === "mousedown") this._downEl = o, this._downPoint = [t.zrX, t.zrY], this._upEl = o;
          else if (n === "mouseup") this._upEl = o;
          else if (n === "click") {
            if (this._downEl !== this._upEl || !this._downPoint || zl(this._downPoint, [t.zrX, t.zrY]) > 4) return;
            this._downPoint = null;
          }
          this.dispatchToElement(a, n, t);
        };
      });
      function P0t(n, t, e) {
        if (n[n.rectHover ? "rectContain" : "contain"](t, e)) {
          for (var i = n, r = void 0, a = false; i; ) {
            if (i.ignoreClip && (a = true), !a) {
              var o = i.getClipPath();
              if (o && !o.contain(t, e)) return false;
            }
            i.silent && (r = true);
            var s = i.__hostTarget;
            i = s || i.parent;
          }
          return r ? Lz : true;
        }
        return false;
      }
      function Nz(n, t, e, i, r) {
        for (var a = n.length - 1; a >= 0; a--) {
          var o = n[a], s = void 0;
          if (o !== r && !o.ignore && (s = P0t(o, e, i)) && (!t.topTarget && (t.topTarget = o), s !== Lz)) {
            t.target = o;
            break;
          }
        }
      }
      function kz(n, t, e) {
        var i = n.painter;
        return t < 0 || t > i.getWidth() || e < 0 || e > i.getHeight();
      }
      var Fz = 32, dp = 7;
      function N0t(n) {
        for (var t = 0; n >= Fz; ) t |= n & 1, n >>= 1;
        return n + t;
      }
      function Qz(n, t, e, i) {
        var r = t + 1;
        if (r === e) return 1;
        if (i(n[r++], n[t]) < 0) {
          for (; r < e && i(n[r], n[r - 1]) < 0; ) r++;
          k0t(n, t, r);
        } else for (; r < e && i(n[r], n[r - 1]) >= 0; ) r++;
        return r - t;
      }
      function k0t(n, t, e) {
        for (e--; t < e; ) {
          var i = n[t];
          n[t++] = n[e], n[e--] = i;
        }
      }
      function Oz(n, t, e, i, r) {
        for (i === t && i++; i < e; i++) {
          for (var a = n[i], o = t, s = i, l; o < s; ) l = o + s >>> 1, r(a, n[l]) < 0 ? s = l : o = l + 1;
          var u = i - o;
          switch (u) {
            case 3:
              n[o + 3] = n[o + 2];
            case 2:
              n[o + 2] = n[o + 1];
            case 1:
              n[o + 1] = n[o];
              break;
            default:
              for (; u > 0; ) n[o + u] = n[o + u - 1], u--;
          }
          n[o] = a;
        }
      }
      function Mb(n, t, e, i, r, a) {
        var o = 0, s = 0, l = 1;
        if (a(n, t[e + r]) > 0) {
          for (s = i - r; l < s && a(n, t[e + r + l]) > 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
          l > s && (l = s), o += r, l += r;
        } else {
          for (s = r + 1; l < s && a(n, t[e + r - l]) <= 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
          l > s && (l = s);
          var u = o;
          o = r - l, l = r - u;
        }
        for (o++; o < l; ) {
          var h = o + (l - o >>> 1);
          a(n, t[e + h]) > 0 ? o = h + 1 : l = h;
        }
        return l;
      }
      function Db(n, t, e, i, r, a) {
        var o = 0, s = 0, l = 1;
        if (a(n, t[e + r]) < 0) {
          for (s = r + 1; l < s && a(n, t[e + r - l]) < 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
          l > s && (l = s);
          var u = o;
          o = r - l, l = r - u;
        } else {
          for (s = i - r; l < s && a(n, t[e + r + l]) >= 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
          l > s && (l = s), o += r, l += r;
        }
        for (o++; o < l; ) {
          var h = o + (l - o >>> 1);
          a(n, t[e + h]) < 0 ? l = h : o = h + 1;
        }
        return l;
      }
      function F0t(n, t) {
        var e = dp, i, r, a = 0, o = [];
        i = [], r = [];
        function s(g, d) {
          i[a] = g, r[a] = d, a += 1;
        }
        function l() {
          for (; a > 1; ) {
            var g = a - 2;
            if (g >= 1 && r[g - 1] <= r[g] + r[g + 1] || g >= 2 && r[g - 2] <= r[g] + r[g - 1]) r[g - 1] < r[g + 1] && g--;
            else if (r[g] > r[g + 1]) break;
            h(g);
          }
        }
        function u() {
          for (; a > 1; ) {
            var g = a - 2;
            g > 0 && r[g - 1] < r[g + 1] && g--, h(g);
          }
        }
        function h(g) {
          var d = i[g], A = r[g], p = i[g + 1], v = r[g + 1];
          r[g] = A + v, g === a - 3 && (i[g + 1] = i[g + 2], r[g + 1] = r[g + 2]), a--;
          var y = Db(n[p], n, d, A, 0, t);
          d += y, A -= y, A !== 0 && (v = Mb(n[d + A - 1], n, p, v, v - 1, t), v !== 0 && (A <= v ? c(d, A, p, v) : f(d, A, p, v)));
        }
        function c(g, d, A, p) {
          var v = 0;
          for (v = 0; v < d; v++) o[v] = n[g + v];
          var y = 0, m = A, _ = g;
          if (n[_++] = n[m++], --p === 0) {
            for (v = 0; v < d; v++) n[_ + v] = o[y + v];
            return;
          }
          if (d === 1) {
            for (v = 0; v < p; v++) n[_ + v] = n[m + v];
            n[_ + p] = o[y];
            return;
          }
          for (var E = e, I, x, w; ; ) {
            I = 0, x = 0, w = false;
            do
              if (t(n[m], o[y]) < 0) {
                if (n[_++] = n[m++], x++, I = 0, --p === 0) {
                  w = true;
                  break;
                }
              } else if (n[_++] = o[y++], I++, x = 0, --d === 1) {
                w = true;
                break;
              }
            while ((I | x) < E);
            if (w) break;
            do {
              if (I = Db(n[m], o, y, d, 0, t), I !== 0) {
                for (v = 0; v < I; v++) n[_ + v] = o[y + v];
                if (_ += I, y += I, d -= I, d <= 1) {
                  w = true;
                  break;
                }
              }
              if (n[_++] = n[m++], --p === 0) {
                w = true;
                break;
              }
              if (x = Mb(o[y], n, m, p, 0, t), x !== 0) {
                for (v = 0; v < x; v++) n[_ + v] = n[m + v];
                if (_ += x, m += x, p -= x, p === 0) {
                  w = true;
                  break;
                }
              }
              if (n[_++] = o[y++], --d === 1) {
                w = true;
                break;
              }
              E--;
            } while (I >= dp || x >= dp);
            if (w) break;
            E < 0 && (E = 0), E += 2;
          }
          if (e = E, e < 1 && (e = 1), d === 1) {
            for (v = 0; v < p; v++) n[_ + v] = n[m + v];
            n[_ + p] = o[y];
          } else {
            if (d === 0) throw new Error();
            for (v = 0; v < d; v++) n[_ + v] = o[y + v];
          }
        }
        function f(g, d, A, p) {
          var v = 0;
          for (v = 0; v < p; v++) o[v] = n[A + v];
          var y = g + d - 1, m = p - 1, _ = A + p - 1, E = 0, I = 0;
          if (n[_--] = n[y--], --d === 0) {
            for (E = _ - (p - 1), v = 0; v < p; v++) n[E + v] = o[v];
            return;
          }
          if (p === 1) {
            for (_ -= d, y -= d, I = _ + 1, E = y + 1, v = d - 1; v >= 0; v--) n[I + v] = n[E + v];
            n[_] = o[m];
            return;
          }
          for (var x = e; ; ) {
            var w = 0, C = 0, S = false;
            do
              if (t(o[m], n[y]) < 0) {
                if (n[_--] = n[y--], w++, C = 0, --d === 0) {
                  S = true;
                  break;
                }
              } else if (n[_--] = o[m--], C++, w = 0, --p === 1) {
                S = true;
                break;
              }
            while ((w | C) < x);
            if (S) break;
            do {
              if (w = d - Db(o[m], n, g, d, d - 1, t), w !== 0) {
                for (_ -= w, y -= w, d -= w, I = _ + 1, E = y + 1, v = w - 1; v >= 0; v--) n[I + v] = n[E + v];
                if (d === 0) {
                  S = true;
                  break;
                }
              }
              if (n[_--] = o[m--], --p === 1) {
                S = true;
                break;
              }
              if (C = p - Mb(n[y], o, 0, p, p - 1, t), C !== 0) {
                for (_ -= C, m -= C, p -= C, I = _ + 1, E = m + 1, v = 0; v < C; v++) n[I + v] = o[E + v];
                if (p <= 1) {
                  S = true;
                  break;
                }
              }
              if (n[_--] = n[y--], --d === 0) {
                S = true;
                break;
              }
              x--;
            } while (w >= dp || C >= dp);
            if (S) break;
            x < 0 && (x = 0), x += 2;
          }
          if (e = x, e < 1 && (e = 1), p === 1) {
            for (_ -= d, y -= d, I = _ + 1, E = y + 1, v = d - 1; v >= 0; v--) n[I + v] = n[E + v];
            n[_] = o[m];
          } else {
            if (p === 0) throw new Error();
            for (E = _ - (p - 1), v = 0; v < p; v++) n[E + v] = o[v];
          }
        }
        return { mergeRuns: l, forceMergeRuns: u, pushRun: s };
      }
      function v_(n, t, e, i) {
        e || (e = 0), i || (i = n.length);
        var r = i - e;
        if (!(r < 2)) {
          var a = 0;
          if (r < Fz) {
            a = Qz(n, e, i, t), Oz(n, e, i, e + a, t);
            return;
          }
          var o = F0t(n, t), s = N0t(r);
          do {
            if (a = Qz(n, e, i, t), a < s) {
              var l = r;
              l > s && (l = s), Oz(n, e, e + l, e + a, t), a = l;
            }
            o.pushRun(e, a), o.mergeRuns(), r -= a, e += a;
          } while (r !== 0);
          o.forceMergeRuns();
        }
      }
      var Qr = 1, Ap = 2, ug = 4, zz = false;
      function Rb() {
        zz || (zz = true);
      }
      function Gz(n, t) {
        return n.zlevel === t.zlevel ? n.z === t.z ? n.z2 - t.z2 : n.z - t.z : n.zlevel - t.zlevel;
      }
      var Q0t = function() {
        function n() {
          this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = Gz;
        }
        return n.prototype.traverse = function(t, e) {
          for (var i = 0; i < this._roots.length; i++) this._roots[i].traverse(t, e);
        }, n.prototype.getDisplayList = function(t, e) {
          e = e || false;
          var i = this._displayList;
          return (t || !i.length) && this.updateDisplayList(e), i;
        }, n.prototype.updateDisplayList = function(t) {
          this._displayListLen = 0;
          for (var e = this._roots, i = this._displayList, r = 0, a = e.length; r < a; r++) this._updateAndAddDisplayable(e[r], null, t);
          i.length = this._displayListLen, v_(i, Gz);
        }, n.prototype._updateAndAddDisplayable = function(t, e, i) {
          if (!(t.ignore && !i)) {
            t.beforeUpdate(), t.update(), t.afterUpdate();
            var r = t.getClipPath();
            if (t.ignoreClip) e = null;
            else if (r) {
              e ? e = e.slice() : e = [];
              for (var a = r, o = t; a; ) a.parent = o, a.updateTransform(), e.push(a), o = a, a = a.getClipPath();
            }
            if (t.childrenRef) {
              for (var s = t.childrenRef(), l = 0; l < s.length; l++) {
                var u = s[l];
                t.__dirty && (u.__dirty |= Qr), this._updateAndAddDisplayable(u, e, i);
              }
              t.__dirty = 0;
            } else {
              var h = t;
              e && e.length ? h.__clipPaths = e : h.__clipPaths && h.__clipPaths.length > 0 && (h.__clipPaths = []), isNaN(h.z) && (Rb(), h.z = 0), isNaN(h.z2) && (Rb(), h.z2 = 0), isNaN(h.zlevel) && (Rb(), h.zlevel = 0), this._displayList[this._displayListLen++] = h;
            }
            var c = t.getDecalElement && t.getDecalElement();
            c && this._updateAndAddDisplayable(c, e, i);
            var f = t.getTextGuideLine();
            f && this._updateAndAddDisplayable(f, e, i);
            var g = t.getTextContent();
            g && this._updateAndAddDisplayable(g, e, i);
          }
        }, n.prototype.addRoot = function(t) {
          t.__zr && t.__zr.storage === this || this._roots.push(t);
        }, n.prototype.delRoot = function(t) {
          if (t instanceof Array) {
            for (var e = 0, i = t.length; e < i; e++) this.delRoot(t[e]);
            return;
          }
          var r = Wt(this._roots, t);
          r >= 0 && this._roots.splice(r, 1);
        }, n.prototype.delAllRoots = function() {
          this._roots = [], this._displayList = [], this._displayListLen = 0;
        }, n.prototype.getRoots = function() {
          return this._roots;
        }, n.prototype.dispose = function() {
          this._displayList = null, this._roots = null;
        }, n;
      }(), y_;
      y_ = ee.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(n) {
        return setTimeout(n, 16);
      };
      var pp = { linear: function(n) {
        return n;
      }, quadraticIn: function(n) {
        return n * n;
      }, quadraticOut: function(n) {
        return n * (2 - n);
      }, quadraticInOut: function(n) {
        return (n *= 2) < 1 ? 0.5 * n * n : -0.5 * (--n * (n - 2) - 1);
      }, cubicIn: function(n) {
        return n * n * n;
      }, cubicOut: function(n) {
        return --n * n * n + 1;
      }, cubicInOut: function(n) {
        return (n *= 2) < 1 ? 0.5 * n * n * n : 0.5 * ((n -= 2) * n * n + 2);
      }, quarticIn: function(n) {
        return n * n * n * n;
      }, quarticOut: function(n) {
        return 1 - --n * n * n * n;
      }, quarticInOut: function(n) {
        return (n *= 2) < 1 ? 0.5 * n * n * n * n : -0.5 * ((n -= 2) * n * n * n - 2);
      }, quinticIn: function(n) {
        return n * n * n * n * n;
      }, quinticOut: function(n) {
        return --n * n * n * n * n + 1;
      }, quinticInOut: function(n) {
        return (n *= 2) < 1 ? 0.5 * n * n * n * n * n : 0.5 * ((n -= 2) * n * n * n * n + 2);
      }, sinusoidalIn: function(n) {
        return 1 - Math.cos(n * Math.PI / 2);
      }, sinusoidalOut: function(n) {
        return Math.sin(n * Math.PI / 2);
      }, sinusoidalInOut: function(n) {
        return 0.5 * (1 - Math.cos(Math.PI * n));
      }, exponentialIn: function(n) {
        return n === 0 ? 0 : Math.pow(1024, n - 1);
      }, exponentialOut: function(n) {
        return n === 1 ? 1 : 1 - Math.pow(2, -10 * n);
      }, exponentialInOut: function(n) {
        return n === 0 ? 0 : n === 1 ? 1 : (n *= 2) < 1 ? 0.5 * Math.pow(1024, n - 1) : 0.5 * (-Math.pow(2, -10 * (n - 1)) + 2);
      }, circularIn: function(n) {
        return 1 - Math.sqrt(1 - n * n);
      }, circularOut: function(n) {
        return Math.sqrt(1 - --n * n);
      }, circularInOut: function(n) {
        return (n *= 2) < 1 ? -0.5 * (Math.sqrt(1 - n * n) - 1) : 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1);
      }, elasticIn: function(n) {
        var t, e = 0.1, i = 0.4;
        return n === 0 ? 0 : n === 1 ? 1 : (!e || e < 1 ? (e = 1, t = i / 4) : t = i * Math.asin(1 / e) / (2 * Math.PI), -(e * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - t) * (2 * Math.PI) / i)));
      }, elasticOut: function(n) {
        var t, e = 0.1, i = 0.4;
        return n === 0 ? 0 : n === 1 ? 1 : (!e || e < 1 ? (e = 1, t = i / 4) : t = i * Math.asin(1 / e) / (2 * Math.PI), e * Math.pow(2, -10 * n) * Math.sin((n - t) * (2 * Math.PI) / i) + 1);
      }, elasticInOut: function(n) {
        var t, e = 0.1, i = 0.4;
        return n === 0 ? 0 : n === 1 ? 1 : (!e || e < 1 ? (e = 1, t = i / 4) : t = i * Math.asin(1 / e) / (2 * Math.PI), (n *= 2) < 1 ? -0.5 * (e * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - t) * (2 * Math.PI) / i)) : e * Math.pow(2, -10 * (n -= 1)) * Math.sin((n - t) * (2 * Math.PI) / i) * 0.5 + 1);
      }, backIn: function(n) {
        var t = 1.70158;
        return n * n * ((t + 1) * n - t);
      }, backOut: function(n) {
        var t = 1.70158;
        return --n * n * ((t + 1) * n + t) + 1;
      }, backInOut: function(n) {
        var t = 2.5949095;
        return (n *= 2) < 1 ? 0.5 * (n * n * ((t + 1) * n - t)) : 0.5 * ((n -= 2) * n * ((t + 1) * n + t) + 2);
      }, bounceIn: function(n) {
        return 1 - pp.bounceOut(1 - n);
      }, bounceOut: function(n) {
        return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375;
      }, bounceInOut: function(n) {
        return n < 0.5 ? pp.bounceIn(n * 2) * 0.5 : pp.bounceOut(n * 2 - 1) * 0.5 + 0.5;
      } }, m_ = Math.pow, Vl = Math.sqrt, __ = 1e-8, Uz = 1e-4, Vz = Vl(3), I_ = 1 / 3, Bo = ih(), sa = ih(), hg = ih();
      function jl(n) {
        return n > -__ && n < __;
      }
      function jz(n) {
        return n > __ || n < -__;
      }
      function Yn(n, t, e, i, r) {
        var a = 1 - r;
        return a * a * (a * n + 3 * r * t) + r * r * (r * i + 3 * a * e);
      }
      function qz(n, t, e, i, r) {
        var a = 1 - r;
        return 3 * (((t - n) * a + 2 * (e - t) * r) * a + (i - e) * r * r);
      }
      function E_(n, t, e, i, r, a) {
        var o = i + 3 * (t - e) - n, s = 3 * (e - t * 2 + n), l = 3 * (t - n), u = n - r, h = s * s - 3 * o * l, c = s * l - 9 * o * u, f = l * l - 3 * s * u, g = 0;
        if (jl(h) && jl(c)) if (jl(s)) a[0] = 0;
        else {
          var d = -l / s;
          d >= 0 && d <= 1 && (a[g++] = d);
        }
        else {
          var A = c * c - 4 * h * f;
          if (jl(A)) {
            var p = c / h, d = -s / o + p, v = -p / 2;
            d >= 0 && d <= 1 && (a[g++] = d), v >= 0 && v <= 1 && (a[g++] = v);
          } else if (A > 0) {
            var y = Vl(A), m = h * s + 1.5 * o * (-c + y), _ = h * s + 1.5 * o * (-c - y);
            m < 0 ? m = -m_(-m, I_) : m = m_(m, I_), _ < 0 ? _ = -m_(-_, I_) : _ = m_(_, I_);
            var d = (-s - (m + _)) / (3 * o);
            d >= 0 && d <= 1 && (a[g++] = d);
          } else {
            var E = (2 * h * s - 3 * o * c) / (2 * Vl(h * h * h)), I = Math.acos(E) / 3, x = Vl(h), w = Math.cos(I), d = (-s - 2 * x * w) / (3 * o), v = (-s + x * (w + Vz * Math.sin(I))) / (3 * o), C = (-s + x * (w - Vz * Math.sin(I))) / (3 * o);
            d >= 0 && d <= 1 && (a[g++] = d), v >= 0 && v <= 1 && (a[g++] = v), C >= 0 && C <= 1 && (a[g++] = C);
          }
        }
        return g;
      }
      function Hz(n, t, e, i, r) {
        var a = 6 * e - 12 * t + 6 * n, o = 9 * t + 3 * i - 3 * n - 9 * e, s = 3 * t - 3 * n, l = 0;
        if (jl(o)) {
          if (jz(a)) {
            var u = -s / a;
            u >= 0 && u <= 1 && (r[l++] = u);
          }
        } else {
          var h = a * a - 4 * o * s;
          if (jl(h)) r[0] = -a / (2 * o);
          else if (h > 0) {
            var c = Vl(h), u = (-a + c) / (2 * o), f = (-a - c) / (2 * o);
            u >= 0 && u <= 1 && (r[l++] = u), f >= 0 && f <= 1 && (r[l++] = f);
          }
        }
        return l;
      }
      function ql(n, t, e, i, r, a) {
        var o = (t - n) * r + n, s = (e - t) * r + t, l = (i - e) * r + e, u = (s - o) * r + o, h = (l - s) * r + s, c = (h - u) * r + u;
        a[0] = n, a[1] = o, a[2] = u, a[3] = c, a[4] = c, a[5] = h, a[6] = l, a[7] = i;
      }
      function Yz(n, t, e, i, r, a, o, s, l, u, h) {
        var c, f = 5e-3, g = 1 / 0, d, A, p, v;
        Bo[0] = l, Bo[1] = u;
        for (var y = 0; y < 1; y += 0.05) sa[0] = Yn(n, e, r, o, y), sa[1] = Yn(t, i, a, s, y), p = ah(Bo, sa), p < g && (c = y, g = p);
        g = 1 / 0;
        for (var m = 0; m < 32 && !(f < Uz); m++) d = c - f, A = c + f, sa[0] = Yn(n, e, r, o, d), sa[1] = Yn(t, i, a, s, d), p = ah(sa, Bo), d >= 0 && p < g ? (c = d, g = p) : (hg[0] = Yn(n, e, r, o, A), hg[1] = Yn(t, i, a, s, A), v = ah(hg, Bo), A <= 1 && v < g ? (c = A, g = v) : f *= 0.5);
        return h && (h[0] = Yn(n, e, r, o, c), h[1] = Yn(t, i, a, s, c)), Vl(g);
      }
      function O0t(n, t, e, i, r, a, o, s, l) {
        for (var u = n, h = t, c = 0, f = 1 / l, g = 1; g <= l; g++) {
          var d = g * f, A = Yn(n, e, r, o, d), p = Yn(t, i, a, s, d), v = A - u, y = p - h;
          c += Math.sqrt(v * v + y * y), u = A, h = p;
        }
        return c;
      }
      function si(n, t, e, i) {
        var r = 1 - i;
        return r * (r * n + 2 * i * t) + i * i * e;
      }
      function Lb(n, t, e, i) {
        return 2 * ((1 - i) * (t - n) + i * (e - t));
      }
      function z0t(n, t, e, i, r) {
        var a = n - 2 * t + e, o = 2 * (t - n), s = n - i, l = 0;
        if (jl(a)) {
          if (jz(o)) {
            var u = -s / o;
            u >= 0 && u <= 1 && (r[l++] = u);
          }
        } else {
          var h = o * o - 4 * a * s;
          if (jl(h)) {
            var u = -o / (2 * a);
            u >= 0 && u <= 1 && (r[l++] = u);
          } else if (h > 0) {
            var c = Vl(h), u = (-o + c) / (2 * a), f = (-o - c) / (2 * a);
            u >= 0 && u <= 1 && (r[l++] = u), f >= 0 && f <= 1 && (r[l++] = f);
          }
        }
        return l;
      }
      function Wz(n, t, e) {
        var i = n + e - 2 * t;
        return i === 0 ? 0.5 : (n - t) / i;
      }
      function vp(n, t, e, i, r) {
        var a = (t - n) * i + n, o = (e - t) * i + t, s = (o - a) * i + a;
        r[0] = n, r[1] = a, r[2] = s, r[3] = s, r[4] = o, r[5] = e;
      }
      function Xz(n, t, e, i, r, a, o, s, l) {
        var u, h = 5e-3, c = 1 / 0;
        Bo[0] = o, Bo[1] = s;
        for (var f = 0; f < 1; f += 0.05) {
          sa[0] = si(n, e, r, f), sa[1] = si(t, i, a, f);
          var g = ah(Bo, sa);
          g < c && (u = f, c = g);
        }
        c = 1 / 0;
        for (var d = 0; d < 32 && !(h < Uz); d++) {
          var A = u - h, p = u + h;
          sa[0] = si(n, e, r, A), sa[1] = si(t, i, a, A);
          var g = ah(sa, Bo);
          if (A >= 0 && g < c) u = A, c = g;
          else {
            hg[0] = si(n, e, r, p), hg[1] = si(t, i, a, p);
            var v = ah(hg, Bo);
            p <= 1 && v < c ? (u = p, c = v) : h *= 0.5;
          }
        }
        return l && (l[0] = si(n, e, r, u), l[1] = si(t, i, a, u)), Vl(c);
      }
      function G0t(n, t, e, i, r, a, o) {
        for (var s = n, l = t, u = 0, h = 1 / o, c = 1; c <= o; c++) {
          var f = c * h, g = si(n, e, r, f), d = si(t, i, a, f), A = g - s, p = d - l;
          u += Math.sqrt(A * A + p * p), s = g, l = d;
        }
        return u;
      }
      var U0t = /cubic-bezier\(([0-9,\.e ]+)\)/;
      function Pb(n) {
        var t = n && U0t.exec(n);
        if (t) {
          var e = t[1].split(","), i = +Ga(e[0]), r = +Ga(e[1]), a = +Ga(e[2]), o = +Ga(e[3]);
          if (isNaN(i + r + a + o)) return;
          var s = [];
          return function(l) {
            return l <= 0 ? 0 : l >= 1 ? 1 : E_(0, i, a, 1, l, s) && Yn(0, r, o, 1, s[0]);
          };
        }
      }
      var V0t = function() {
        function n(t) {
          this._inited = false, this._startTime = 0, this._pausedTime = 0, this._paused = false, this._life = t.life || 1e3, this._delay = t.delay || 0, this.loop = t.loop || false, this.onframe = t.onframe || In, this.ondestroy = t.ondestroy || In, this.onrestart = t.onrestart || In, t.easing && this.setEasing(t.easing);
        }
        return n.prototype.step = function(t, e) {
          if (this._inited || (this._startTime = t + this._delay, this._inited = true), this._paused) {
            this._pausedTime += e;
            return;
          }
          var i = this._life, r = t - this._startTime - this._pausedTime, a = r / i;
          a < 0 && (a = 0), a = Math.min(a, 1);
          var o = this.easingFunc, s = o ? o(a) : a;
          if (this.onframe(s), a === 1) if (this.loop) {
            var l = r % i;
            this._startTime = t - l, this._pausedTime = 0, this.onrestart();
          } else return true;
          return false;
        }, n.prototype.pause = function() {
          this._paused = true;
        }, n.prototype.resume = function() {
          this._paused = false;
        }, n.prototype.setEasing = function(t) {
          this.easing = t, this.easingFunc = yt(t) ? t : pp[t] || Pb(t);
        }, n;
      }(), Zz = /* @__PURE__ */ function() {
        function n(t) {
          this.value = t;
        }
        return n;
      }(), j0t = function() {
        function n() {
          this._len = 0;
        }
        return n.prototype.insert = function(t) {
          var e = new Zz(t);
          return this.insertEntry(e), e;
        }, n.prototype.insertEntry = function(t) {
          this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
        }, n.prototype.remove = function(t) {
          var e = t.prev, i = t.next;
          e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len--;
        }, n.prototype.len = function() {
          return this._len;
        }, n.prototype.clear = function() {
          this.head = this.tail = null, this._len = 0;
        }, n;
      }(), yp = function() {
        function n(t) {
          this._list = new j0t(), this._maxSize = 10, this._map = {}, this._maxSize = t;
        }
        return n.prototype.put = function(t, e) {
          var i = this._list, r = this._map, a = null;
          if (r[t] == null) {
            var o = i.len(), s = this._lastRemovedEntry;
            if (o >= this._maxSize && o > 0) {
              var l = i.head;
              i.remove(l), delete r[l.key], a = l.value, this._lastRemovedEntry = l;
            }
            s ? s.value = e : s = new Zz(e), s.key = t, i.insertEntry(s), r[t] = s;
          }
          return a;
        }, n.prototype.get = function(t) {
          var e = this._map[t], i = this._list;
          if (e != null) return e !== i.tail && (i.remove(e), i.insertEntry(e)), e.value;
        }, n.prototype.clear = function() {
          this._list.clear(), this._map = {};
        }, n.prototype.len = function() {
          return this._list.len();
        }, n;
      }(), Kz = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
      function Ua(n) {
        return n = Math.round(n), n < 0 ? 0 : n > 255 ? 255 : n;
      }
      function q0t(n) {
        return n = Math.round(n), n < 0 ? 0 : n > 360 ? 360 : n;
      }
      function mp(n) {
        return n < 0 ? 0 : n > 1 ? 1 : n;
      }
      function Nb(n) {
        var t = n;
        return t.length && t.charAt(t.length - 1) === "%" ? Ua(parseFloat(t) / 100 * 255) : Ua(parseInt(t, 10));
      }
      function ch(n) {
        var t = n;
        return t.length && t.charAt(t.length - 1) === "%" ? mp(parseFloat(t) / 100) : mp(parseFloat(t));
      }
      function kb(n, t, e) {
        return e < 0 ? e += 1 : e > 1 && (e -= 1), e * 6 < 1 ? n + (t - n) * e * 6 : e * 2 < 1 ? t : e * 3 < 2 ? n + (t - n) * (2 / 3 - e) * 6 : n;
      }
      function Hl(n, t, e) {
        return n + (t - n) * e;
      }
      function la(n, t, e, i, r) {
        return n[0] = t, n[1] = e, n[2] = i, n[3] = r, n;
      }
      function Fb(n, t) {
        return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n;
      }
      var $z = new yp(20), x_ = null;
      function cg(n, t) {
        x_ && Fb(x_, t), x_ = $z.put(n, x_ || t.slice());
      }
      function Or(n, t) {
        if (n) {
          t = t || [];
          var e = $z.get(n);
          if (e) return Fb(t, e);
          n = n + "";
          var i = n.replace(/ /g, "").toLowerCase();
          if (i in Kz) return Fb(t, Kz[i]), cg(n, t), t;
          var r = i.length;
          if (i.charAt(0) === "#") {
            if (r === 4 || r === 5) {
              var a = parseInt(i.slice(1, 4), 16);
              if (!(a >= 0 && a <= 4095)) {
                la(t, 0, 0, 0, 1);
                return;
              }
              return la(t, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, r === 5 ? parseInt(i.slice(4), 16) / 15 : 1), cg(n, t), t;
            } else if (r === 7 || r === 9) {
              var a = parseInt(i.slice(1, 7), 16);
              if (!(a >= 0 && a <= 16777215)) {
                la(t, 0, 0, 0, 1);
                return;
              }
              return la(t, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, r === 9 ? parseInt(i.slice(7), 16) / 255 : 1), cg(n, t), t;
            }
            return;
          }
          var o = i.indexOf("("), s = i.indexOf(")");
          if (o !== -1 && s + 1 === r) {
            var l = i.substr(0, o), u = i.substr(o + 1, s - (o + 1)).split(","), h = 1;
            switch (l) {
              case "rgba":
                if (u.length !== 4) return u.length === 3 ? la(t, +u[0], +u[1], +u[2], 1) : la(t, 0, 0, 0, 1);
                h = ch(u.pop());
              case "rgb":
                if (u.length >= 3) return la(t, Nb(u[0]), Nb(u[1]), Nb(u[2]), u.length === 3 ? h : ch(u[3])), cg(n, t), t;
                la(t, 0, 0, 0, 1);
                return;
              case "hsla":
                if (u.length !== 4) {
                  la(t, 0, 0, 0, 1);
                  return;
                }
                return u[3] = ch(u[3]), Qb(u, t), cg(n, t), t;
              case "hsl":
                if (u.length !== 3) {
                  la(t, 0, 0, 0, 1);
                  return;
                }
                return Qb(u, t), cg(n, t), t;
              default:
                return;
            }
          }
          la(t, 0, 0, 0, 1);
        }
      }
      function Qb(n, t) {
        var e = (parseFloat(n[0]) % 360 + 360) % 360 / 360, i = ch(n[1]), r = ch(n[2]), a = r <= 0.5 ? r * (i + 1) : r + i - r * i, o = r * 2 - a;
        return t = t || [], la(t, Ua(kb(o, a, e + 1 / 3) * 255), Ua(kb(o, a, e) * 255), Ua(kb(o, a, e - 1 / 3) * 255), 1), n.length === 4 && (t[3] = n[3]), t;
      }
      function H0t(n) {
        if (n) {
          var t = n[0] / 255, e = n[1] / 255, i = n[2] / 255, r = Math.min(t, e, i), a = Math.max(t, e, i), o = a - r, s = (a + r) / 2, l, u;
          if (o === 0) l = 0, u = 0;
          else {
            s < 0.5 ? u = o / (a + r) : u = o / (2 - a - r);
            var h = ((a - t) / 6 + o / 2) / o, c = ((a - e) / 6 + o / 2) / o, f = ((a - i) / 6 + o / 2) / o;
            t === a ? l = f - c : e === a ? l = 1 / 3 + h - f : i === a && (l = 2 / 3 + c - h), l < 0 && (l += 1), l > 1 && (l -= 1);
          }
          var g = [l * 360, u, s];
          return n[3] != null && g.push(n[3]), g;
        }
      }
      function Ob(n, t) {
        var e = Or(n);
        if (e) {
          for (var i = 0; i < 3; i++) t < 0 ? e[i] = e[i] * (1 - t) | 0 : e[i] = (255 - e[i]) * t + e[i] | 0, e[i] > 255 ? e[i] = 255 : e[i] < 0 && (e[i] = 0);
          return bs(e, e.length === 4 ? "rgba" : "rgb");
        }
      }
      function zb(n, t, e) {
        if (!(!(t && t.length) || !(n >= 0 && n <= 1))) {
          e = e || [];
          var i = n * (t.length - 1), r = Math.floor(i), a = Math.ceil(i), o = t[r], s = t[a], l = i - r;
          return e[0] = Ua(Hl(o[0], s[0], l)), e[1] = Ua(Hl(o[1], s[1], l)), e[2] = Ua(Hl(o[2], s[2], l)), e[3] = mp(Hl(o[3], s[3], l)), e;
        }
      }
      function Y0t(n, t, e) {
        if (!(!(t && t.length) || !(n >= 0 && n <= 1))) {
          var i = n * (t.length - 1), r = Math.floor(i), a = Math.ceil(i), o = Or(t[r]), s = Or(t[a]), l = i - r, u = bs([Ua(Hl(o[0], s[0], l)), Ua(Hl(o[1], s[1], l)), Ua(Hl(o[2], s[2], l)), mp(Hl(o[3], s[3], l))], "rgba");
          return e ? { color: u, leftIndex: r, rightIndex: a, value: i } : u;
        }
      }
      function _p(n, t, e, i) {
        var r = Or(n);
        if (n) return r = H0t(r), t != null && (r[0] = q0t(t)), e != null && (r[1] = ch(e)), i != null && (r[2] = ch(i)), bs(Qb(r), "rgba");
      }
      function w_(n, t) {
        var e = Or(n);
        if (e && t != null) return e[3] = mp(t), bs(e, "rgba");
      }
      function bs(n, t) {
        if (!(!n || !n.length)) {
          var e = n[0] + "," + n[1] + "," + n[2];
          return (t === "rgba" || t === "hsva" || t === "hsla") && (e += "," + n[3]), t + "(" + e + ")";
        }
      }
      function C_(n, t) {
        var e = Or(n);
        return e ? (0.299 * e[0] + 0.587 * e[1] + 0.114 * e[2]) * e[3] / 255 + (1 - e[3]) * t : 0;
      }
      var Jz = new yp(100);
      function Gb(n) {
        if (ht(n)) {
          var t = Jz.get(n);
          return t || (t = Ob(n, -0.1), Jz.put(n, t)), t;
        } else if (s_(n)) {
          var e = Y({}, n);
          return e.colorStops = Z(n.colorStops, function(i) {
            return { offset: i.offset, color: Ob(i.color, -0.1) };
          }), e;
        }
        return n;
      }
      var S_ = Math.round;
      function Ip(n) {
        var t;
        if (!n || n === "transparent") n = "none";
        else if (typeof n == "string" && n.indexOf("rgba") > -1) {
          var e = Or(n);
          e && (n = "rgb(" + e[0] + "," + e[1] + "," + e[2] + ")", t = e[3]);
        }
        return { color: n, opacity: t == null ? 1 : t };
      }
      var tG = 1e-4;
      function Yl(n) {
        return n < tG && n > -tG;
      }
      function b_(n) {
        return S_(n * 1e3) / 1e3;
      }
      function Ub(n) {
        return S_(n * 1e4) / 1e4;
      }
      function W0t(n) {
        return "matrix(" + b_(n[0]) + "," + b_(n[1]) + "," + b_(n[2]) + "," + b_(n[3]) + "," + Ub(n[4]) + "," + Ub(n[5]) + ")";
      }
      var X0t = { left: "start", right: "end", center: "middle", middle: "middle" };
      function Z0t(n, t, e) {
        return e === "top" ? n += t / 2 : e === "bottom" && (n -= t / 2), n;
      }
      function K0t(n) {
        return n && (n.shadowBlur || n.shadowOffsetX || n.shadowOffsetY);
      }
      function $0t(n) {
        var t = n.style, e = n.getGlobalScale();
        return [t.shadowColor, (t.shadowBlur || 0).toFixed(2), (t.shadowOffsetX || 0).toFixed(2), (t.shadowOffsetY || 0).toFixed(2), e[0], e[1]].join(",");
      }
      function eG(n) {
        return n && !!n.image;
      }
      function J0t(n) {
        return n && !!n.svgElement;
      }
      function Vb(n) {
        return eG(n) || J0t(n);
      }
      function nG(n) {
        return n.type === "linear";
      }
      function iG(n) {
        return n.type === "radial";
      }
      function rG(n) {
        return n && (n.type === "linear" || n.type === "radial");
      }
      function B_(n) {
        return "url(#" + n + ")";
      }
      function aG(n) {
        var t = n.getGlobalScale(), e = Math.max(t[0], t[1]);
        return Math.max(Math.ceil(Math.log(e) / Math.log(10)), 1);
      }
      function oG(n) {
        var t = n.x || 0, e = n.y || 0, i = (n.rotation || 0) * c_, r = Pt(n.scaleX, 1), a = Pt(n.scaleY, 1), o = n.skewX || 0, s = n.skewY || 0, l = [];
        return (t || e) && l.push("translate(" + t + "px," + e + "px)"), i && l.push("rotate(" + i + ")"), (r !== 1 || a !== 1) && l.push("scale(" + r + "," + a + ")"), (o || s) && l.push("skew(" + S_(o * c_) + "deg, " + S_(s * c_) + "deg)"), l.join(" ");
      }
      var tmt = function() {
        return ee.hasGlobalWindow && yt(window.btoa) ? function(n) {
          return window.btoa(unescape(encodeURIComponent(n)));
        } : typeof Buffer != "undefined" ? function(n) {
          return Buffer.from(n).toString("base64");
        } : function(n) {
          return za("Base64 isn't natively supported in the current environment."), null;
        };
      }(), jb = Array.prototype.slice;
      function Bs(n, t, e) {
        return (t - n) * e + n;
      }
      function qb(n, t, e, i) {
        for (var r = t.length, a = 0; a < r; a++) n[a] = Bs(t[a], e[a], i);
        return n;
      }
      function emt(n, t, e, i) {
        for (var r = t.length, a = r && t[0].length, o = 0; o < r; o++) {
          n[o] || (n[o] = []);
          for (var s = 0; s < a; s++) n[o][s] = Bs(t[o][s], e[o][s], i);
        }
        return n;
      }
      function T_(n, t, e, i) {
        for (var r = t.length, a = 0; a < r; a++) n[a] = t[a] + e[a] * i;
        return n;
      }
      function sG(n, t, e, i) {
        for (var r = t.length, a = r && t[0].length, o = 0; o < r; o++) {
          n[o] || (n[o] = []);
          for (var s = 0; s < a; s++) n[o][s] = t[o][s] + e[o][s] * i;
        }
        return n;
      }
      function nmt(n, t) {
        for (var e = n.length, i = t.length, r = e > i ? t : n, a = Math.min(e, i), o = r[a - 1] || { color: [0, 0, 0, 0], offset: 0 }, s = a; s < Math.max(e, i); s++) r.push({ offset: o.offset, color: o.color.slice() });
      }
      function imt(n, t, e) {
        var i = n, r = t;
        if (!(!i.push || !r.push)) {
          var a = i.length, o = r.length;
          if (a !== o) {
            var s = a > o;
            if (s) i.length = o;
            else for (var l = a; l < o; l++) i.push(e === 1 ? r[l] : jb.call(r[l]));
          }
          for (var u = i[0] && i[0].length, l = 0; l < i.length; l++) if (e === 1) isNaN(i[l]) && (i[l] = r[l]);
          else for (var h = 0; h < u; h++) isNaN(i[l][h]) && (i[l][h] = r[l][h]);
        }
      }
      function Ep(n) {
        if (Mi(n)) {
          var t = n.length;
          if (Mi(n[0])) {
            for (var e = [], i = 0; i < t; i++) e.push(jb.call(n[i]));
            return e;
          }
          return jb.call(n);
        }
        return n;
      }
      function M_(n) {
        return n[0] = Math.floor(n[0]) || 0, n[1] = Math.floor(n[1]) || 0, n[2] = Math.floor(n[2]) || 0, n[3] = n[3] == null ? 1 : n[3], "rgba(" + n.join(",") + ")";
      }
      function rmt(n) {
        return Mi(n && n[0]) ? 2 : 1;
      }
      var D_ = 0, R_ = 1, lG = 2, xp = 3, Hb = 4, Yb = 5, uG = 6;
      function hG(n) {
        return n === Hb || n === Yb;
      }
      function L_(n) {
        return n === R_ || n === lG;
      }
      var wp = [0, 0, 0, 0], amt = function() {
        function n(t) {
          this.keyframes = [], this.discrete = false, this._invalid = false, this._needsSort = false, this._lastFr = 0, this._lastFrP = 0, this.propName = t;
        }
        return n.prototype.isFinished = function() {
          return this._finished;
        }, n.prototype.setFinished = function() {
          this._finished = true, this._additiveTrack && this._additiveTrack.setFinished();
        }, n.prototype.needsAnimate = function() {
          return this.keyframes.length >= 1;
        }, n.prototype.getAdditiveTrack = function() {
          return this._additiveTrack;
        }, n.prototype.addKeyframe = function(t, e, i) {
          this._needsSort = true;
          var r = this.keyframes, a = r.length, o = false, s = uG, l = e;
          if (Mi(e)) {
            var u = rmt(e);
            s = u, (u === 1 && !pe(e[0]) || u === 2 && !pe(e[0][0])) && (o = true);
          } else if (pe(e) && !nh(e)) s = D_;
          else if (ht(e)) if (!isNaN(+e)) s = D_;
          else {
            var h = Or(e);
            h && (l = h, s = xp);
          }
          else if (s_(e)) {
            var c = Y({}, l);
            c.colorStops = Z(e.colorStops, function(g) {
              return { offset: g.offset, color: Or(g.color) };
            }), nG(e) ? s = Hb : iG(e) && (s = Yb), l = c;
          }
          a === 0 ? this.valType = s : (s !== this.valType || s === uG) && (o = true), this.discrete = this.discrete || o;
          var f = { time: t, value: l, rawValue: e, percent: 0 };
          return i && (f.easing = i, f.easingFunc = yt(i) ? i : pp[i] || Pb(i)), r.push(f), f;
        }, n.prototype.prepare = function(t, e) {
          var i = this.keyframes;
          this._needsSort && i.sort(function(A, p) {
            return A.time - p.time;
          });
          for (var r = this.valType, a = i.length, o = i[a - 1], s = this.discrete, l = L_(r), u = hG(r), h = 0; h < a; h++) {
            var c = i[h], f = c.value, g = o.value;
            c.percent = c.time / t, s || (l && h !== a - 1 ? imt(f, g, r) : u && nmt(f.colorStops, g.colorStops));
          }
          if (!s && r !== Yb && e && this.needsAnimate() && e.needsAnimate() && r === e.valType && !e._finished) {
            this._additiveTrack = e;
            for (var d = i[0].value, h = 0; h < a; h++) r === D_ ? i[h].additiveValue = i[h].value - d : r === xp ? i[h].additiveValue = T_([], i[h].value, d, -1) : L_(r) && (i[h].additiveValue = r === R_ ? T_([], i[h].value, d, -1) : sG([], i[h].value, d, -1));
          }
        }, n.prototype.step = function(t, e) {
          if (!this._finished) {
            this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
            var i = this._additiveTrack != null, r = i ? "additiveValue" : "value", a = this.valType, o = this.keyframes, s = o.length, l = this.propName, u = a === xp, h, c = this._lastFr, f = Math.min, g, d;
            if (s === 1) g = d = o[0];
            else {
              if (e < 0) h = 0;
              else if (e < this._lastFrP) {
                var A = f(c + 1, s - 1);
                for (h = A; h >= 0 && !(o[h].percent <= e); h--) ;
                h = f(h, s - 2);
              } else {
                for (h = c; h < s && !(o[h].percent > e); h++) ;
                h = f(h - 1, s - 2);
              }
              d = o[h + 1], g = o[h];
            }
            if (g && d) {
              this._lastFr = h, this._lastFrP = e;
              var p = d.percent - g.percent, v = p === 0 ? 1 : f((e - g.percent) / p, 1);
              d.easingFunc && (v = d.easingFunc(v));
              var y = i ? this._additiveValue : u ? wp : t[l];
              if ((L_(a) || u) && !y && (y = this._additiveValue = []), this.discrete) t[l] = v < 1 ? g.rawValue : d.rawValue;
              else if (L_(a)) a === R_ ? qb(y, g[r], d[r], v) : emt(y, g[r], d[r], v);
              else if (hG(a)) {
                var m = g[r], _ = d[r], E = a === Hb;
                t[l] = { type: E ? "linear" : "radial", x: Bs(m.x, _.x, v), y: Bs(m.y, _.y, v), colorStops: Z(m.colorStops, function(x, w) {
                  var C = _.colorStops[w];
                  return { offset: Bs(x.offset, C.offset, v), color: M_(qb([], x.color, C.color, v)) };
                }), global: _.global }, E ? (t[l].x2 = Bs(m.x2, _.x2, v), t[l].y2 = Bs(m.y2, _.y2, v)) : t[l].r = Bs(m.r, _.r, v);
              } else if (u) qb(y, g[r], d[r], v), i || (t[l] = M_(y));
              else {
                var I = Bs(g[r], d[r], v);
                i ? this._additiveValue = I : t[l] = I;
              }
              i && this._addToTarget(t);
            }
          }
        }, n.prototype._addToTarget = function(t) {
          var e = this.valType, i = this.propName, r = this._additiveValue;
          e === D_ ? t[i] = t[i] + r : e === xp ? (Or(t[i], wp), T_(wp, wp, r, 1), t[i] = M_(wp)) : e === R_ ? T_(t[i], t[i], r, 1) : e === lG && sG(t[i], t[i], r, 1);
        }, n;
      }(), Wb = function() {
        function n(t, e, i, r) {
          if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = t, this._loop = e, e && r) {
            za("Can' use additive animation on looped animation.");
            return;
          }
          this._additiveAnimators = r, this._allowDiscrete = i;
        }
        return n.prototype.getMaxTime = function() {
          return this._maxTime;
        }, n.prototype.getDelay = function() {
          return this._delay;
        }, n.prototype.getLoop = function() {
          return this._loop;
        }, n.prototype.getTarget = function() {
          return this._target;
        }, n.prototype.changeTarget = function(t) {
          this._target = t;
        }, n.prototype.when = function(t, e, i) {
          return this.whenWithKeys(t, e, re(e), i);
        }, n.prototype.whenWithKeys = function(t, e, i, r) {
          for (var a = this._tracks, o = 0; o < i.length; o++) {
            var s = i[o], l = a[s];
            if (!l) {
              l = a[s] = new amt(s);
              var u = void 0, h = this._getAdditiveTrack(s);
              if (h) {
                var c = h.keyframes, f = c[c.length - 1];
                u = f && f.value, h.valType === xp && u && (u = M_(u));
              } else u = this._target[s];
              if (u == null) continue;
              t > 0 && l.addKeyframe(0, Ep(u), r), this._trackKeys.push(s);
            }
            l.addKeyframe(t, Ep(e[s]), r);
          }
          return this._maxTime = Math.max(this._maxTime, t), this;
        }, n.prototype.pause = function() {
          this._clip.pause(), this._paused = true;
        }, n.prototype.resume = function() {
          this._clip.resume(), this._paused = false;
        }, n.prototype.isPaused = function() {
          return !!this._paused;
        }, n.prototype.duration = function(t) {
          return this._maxTime = t, this._force = true, this;
        }, n.prototype._doneCallback = function() {
          this._setTracksFinished(), this._clip = null;
          var t = this._doneCbs;
          if (t) for (var e = t.length, i = 0; i < e; i++) t[i].call(this);
        }, n.prototype._abortedCallback = function() {
          this._setTracksFinished();
          var t = this.animation, e = this._abortedCbs;
          if (t && t.removeClip(this._clip), this._clip = null, e) for (var i = 0; i < e.length; i++) e[i].call(this);
        }, n.prototype._setTracksFinished = function() {
          for (var t = this._tracks, e = this._trackKeys, i = 0; i < e.length; i++) t[e[i]].setFinished();
        }, n.prototype._getAdditiveTrack = function(t) {
          var e, i = this._additiveAnimators;
          if (i) for (var r = 0; r < i.length; r++) {
            var a = i[r].getTrack(t);
            a && (e = a);
          }
          return e;
        }, n.prototype.start = function(t) {
          if (!(this._started > 0)) {
            this._started = 1;
            for (var e = this, i = [], r = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
              var o = this._trackKeys[a], s = this._tracks[o], l = this._getAdditiveTrack(o), u = s.keyframes, h = u.length;
              if (s.prepare(r, l), s.needsAnimate()) if (!this._allowDiscrete && s.discrete) {
                var c = u[h - 1];
                c && (e._target[s.propName] = c.rawValue), s.setFinished();
              } else i.push(s);
            }
            if (i.length || this._force) {
              var f = new V0t({ life: r, loop: this._loop, delay: this._delay || 0, onframe: function(g) {
                e._started = 2;
                var d = e._additiveAnimators;
                if (d) {
                  for (var A = false, p = 0; p < d.length; p++) if (d[p]._clip) {
                    A = true;
                    break;
                  }
                  A || (e._additiveAnimators = null);
                }
                for (var p = 0; p < i.length; p++) i[p].step(e._target, g);
                var v = e._onframeCbs;
                if (v) for (var p = 0; p < v.length; p++) v[p](e._target, g);
              }, ondestroy: function() {
                e._doneCallback();
              } });
              this._clip = f, this.animation && this.animation.addClip(f), t && f.setEasing(t);
            } else this._doneCallback();
            return this;
          }
        }, n.prototype.stop = function(t) {
          if (this._clip) {
            var e = this._clip;
            t && e.onframe(1), this._abortedCallback();
          }
        }, n.prototype.delay = function(t) {
          return this._delay = t, this;
        }, n.prototype.during = function(t) {
          return t && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(t)), this;
        }, n.prototype.done = function(t) {
          return t && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(t)), this;
        }, n.prototype.aborted = function(t) {
          return t && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(t)), this;
        }, n.prototype.getClip = function() {
          return this._clip;
        }, n.prototype.getTrack = function(t) {
          return this._tracks[t];
        }, n.prototype.getTracks = function() {
          var t = this;
          return Z(this._trackKeys, function(e) {
            return t._tracks[e];
          });
        }, n.prototype.stopTracks = function(t, e) {
          if (!t.length || !this._clip) return true;
          for (var i = this._tracks, r = this._trackKeys, a = 0; a < t.length; a++) {
            var o = i[t[a]];
            o && !o.isFinished() && (e ? o.step(this._target, 1) : this._started === 1 && o.step(this._target, 0), o.setFinished());
          }
          for (var s = true, a = 0; a < r.length; a++) if (!i[r[a]].isFinished()) {
            s = false;
            break;
          }
          return s && this._abortedCallback(), s;
        }, n.prototype.saveTo = function(t, e, i) {
          if (t) {
            e = e || this._trackKeys;
            for (var r = 0; r < e.length; r++) {
              var a = e[r], o = this._tracks[a];
              if (!(!o || o.isFinished())) {
                var s = o.keyframes, l = s[i ? 0 : s.length - 1];
                l && (t[a] = Ep(l.rawValue));
              }
            }
          }
        }, n.prototype.__changeFinalValue = function(t, e) {
          e = e || re(t);
          for (var i = 0; i < e.length; i++) {
            var r = e[i], a = this._tracks[r];
            if (a) {
              var o = a.keyframes;
              if (o.length > 1) {
                var s = o.pop();
                a.addKeyframe(s.time, t[r]), a.prepare(this._maxTime, a.getAdditiveTrack());
              }
            }
          }
        }, n;
      }();
      function fg() {
        return (/* @__PURE__ */ new Date()).getTime();
      }
      var omt = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this) || this;
          return i._running = false, i._time = 0, i._pausedTime = 0, i._pauseStart = 0, i._paused = false, e = e || {}, i.stage = e.stage || {}, i;
        }
        return t.prototype.addClip = function(e) {
          e.animation && this.removeClip(e), this._head ? (this._tail.next = e, e.prev = this._tail, e.next = null, this._tail = e) : this._head = this._tail = e, e.animation = this;
        }, t.prototype.addAnimator = function(e) {
          e.animation = this;
          var i = e.getClip();
          i && this.addClip(i);
        }, t.prototype.removeClip = function(e) {
          if (e.animation) {
            var i = e.prev, r = e.next;
            i ? i.next = r : this._head = r, r ? r.prev = i : this._tail = i, e.next = e.prev = e.animation = null;
          }
        }, t.prototype.removeAnimator = function(e) {
          var i = e.getClip();
          i && this.removeClip(i), e.animation = null;
        }, t.prototype.update = function(e) {
          for (var i = fg() - this._pausedTime, r = i - this._time, a = this._head; a; ) {
            var o = a.next, s = a.step(i, r);
            s && (a.ondestroy(), this.removeClip(a)), a = o;
          }
          this._time = i, e || (this.trigger("frame", r), this.stage.update && this.stage.update());
        }, t.prototype._startLoop = function() {
          var e = this;
          this._running = true;
          function i() {
            e._running && (y_(i), !e._paused && e.update());
          }
          y_(i);
        }, t.prototype.start = function() {
          this._running || (this._time = fg(), this._pausedTime = 0, this._startLoop());
        }, t.prototype.stop = function() {
          this._running = false;
        }, t.prototype.pause = function() {
          this._paused || (this._pauseStart = fg(), this._paused = true);
        }, t.prototype.resume = function() {
          this._paused && (this._pausedTime += fg() - this._pauseStart, this._paused = false);
        }, t.prototype.clear = function() {
          for (var e = this._head; e; ) {
            var i = e.next;
            e.prev = e.next = e.animation = null, e = i;
          }
          this._head = this._tail = null;
        }, t.prototype.isFinished = function() {
          return this._head == null;
        }, t.prototype.animate = function(e, i) {
          i = i || {}, this.start();
          var r = new Wb(e, i.loop);
          return this.addAnimator(r), r;
        }, t;
      }(aa), smt = 300, Xb = ee.domSupported, Zb = function() {
        var n = ["click", "dblclick", "mousewheel", "wheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"], t = ["touchstart", "touchend", "touchmove"], e = { pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1 }, i = Z(n, function(r) {
          var a = r.replace("mouse", "pointer");
          return e.hasOwnProperty(a) ? a : r;
        });
        return { mouse: n, touch: t, pointer: i };
      }(), cG = { mouse: ["mousemove", "mouseup"], pointer: ["pointermove", "pointerup"] }, fG = false;
      function Kb(n) {
        var t = n.pointerType;
        return t === "pen" || t === "touch";
      }
      function lmt(n) {
        n.touching = true, n.touchTimer != null && (clearTimeout(n.touchTimer), n.touchTimer = null), n.touchTimer = setTimeout(function() {
          n.touching = false, n.touchTimer = null;
        }, 700);
      }
      function $b(n) {
        n && (n.zrByTouch = true);
      }
      function umt(n, t) {
        return oa(n.dom, new hmt(n, t), true);
      }
      function gG(n, t) {
        for (var e = t, i = false; e && e.nodeType !== 9 && !(i = e.domBelongToZr || e !== t && e === n.painterRoot); ) e = e.parentNode;
        return i;
      }
      var hmt = /* @__PURE__ */ function() {
        function n(t, e) {
          this.stopPropagation = In, this.stopImmediatePropagation = In, this.preventDefault = In, this.type = e.type, this.target = this.currentTarget = t.dom, this.pointerType = e.pointerType, this.clientX = e.clientX, this.clientY = e.clientY;
        }
        return n;
      }(), Va = { mousedown: function(n) {
        n = oa(this.dom, n), this.__mayPointerCapture = [n.zrX, n.zrY], this.trigger("mousedown", n);
      }, mousemove: function(n) {
        n = oa(this.dom, n);
        var t = this.__mayPointerCapture;
        t && (n.zrX !== t[0] || n.zrY !== t[1]) && this.__togglePointerCapture(true), this.trigger("mousemove", n);
      }, mouseup: function(n) {
        n = oa(this.dom, n), this.__togglePointerCapture(false), this.trigger("mouseup", n);
      }, mouseout: function(n) {
        n = oa(this.dom, n);
        var t = n.toElement || n.relatedTarget;
        gG(this, t) || (this.__pointerCapturing && (n.zrEventControl = "no_globalout"), this.trigger("mouseout", n));
      }, wheel: function(n) {
        fG = true, n = oa(this.dom, n), this.trigger("mousewheel", n);
      }, mousewheel: function(n) {
        fG || (n = oa(this.dom, n), this.trigger("mousewheel", n));
      }, touchstart: function(n) {
        n = oa(this.dom, n), $b(n), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(n, "start"), Va.mousemove.call(this, n), Va.mousedown.call(this, n);
      }, touchmove: function(n) {
        n = oa(this.dom, n), $b(n), this.handler.processGesture(n, "change"), Va.mousemove.call(this, n);
      }, touchend: function(n) {
        n = oa(this.dom, n), $b(n), this.handler.processGesture(n, "end"), Va.mouseup.call(this, n), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < smt && Va.click.call(this, n);
      }, pointerdown: function(n) {
        Va.mousedown.call(this, n);
      }, pointermove: function(n) {
        Kb(n) || Va.mousemove.call(this, n);
      }, pointerup: function(n) {
        Va.mouseup.call(this, n);
      }, pointerout: function(n) {
        Kb(n) || Va.mouseout.call(this, n);
      } };
      M(["click", "dblclick", "contextmenu"], function(n) {
        Va[n] = function(t) {
          t = oa(this.dom, t), this.trigger(n, t);
        };
      });
      var Jb = { pointermove: function(n) {
        Kb(n) || Jb.mousemove.call(this, n);
      }, pointerup: function(n) {
        Jb.mouseup.call(this, n);
      }, mousemove: function(n) {
        this.trigger("mousemove", n);
      }, mouseup: function(n) {
        var t = this.__pointerCapturing;
        this.__togglePointerCapture(false), this.trigger("mouseup", n), t && (n.zrEventControl = "only_globalout", this.trigger("mouseout", n));
      } };
      function cmt(n, t) {
        var e = t.domHandlers;
        ee.pointerEventsSupported ? M(Zb.pointer, function(i) {
          P_(t, i, function(r) {
            e[i].call(n, r);
          });
        }) : (ee.touchEventsSupported && M(Zb.touch, function(i) {
          P_(t, i, function(r) {
            e[i].call(n, r), lmt(t);
          });
        }), M(Zb.mouse, function(i) {
          P_(t, i, function(r) {
            r = wb(r), t.touching || e[i].call(n, r);
          });
        }));
      }
      function fmt(n, t) {
        ee.pointerEventsSupported ? M(cG.pointer, e) : ee.touchEventsSupported || M(cG.mouse, e);
        function e(i) {
          function r(a) {
            a = wb(a), gG(n, a.target) || (a = umt(n, a), t.domHandlers[i].call(n, a));
          }
          P_(t, i, r, { capture: true });
        }
      }
      function P_(n, t, e, i) {
        n.mounted[t] = e, n.listenerOpts[t] = i, Cb(n.domTarget, t, e, i);
      }
      function t2(n) {
        var t = n.mounted;
        for (var e in t) t.hasOwnProperty(e) && S0t(n.domTarget, e, t[e], n.listenerOpts[e]);
        n.mounted = {};
      }
      var dG = /* @__PURE__ */ function() {
        function n(t, e) {
          this.mounted = {}, this.listenerOpts = {}, this.touching = false, this.domTarget = t, this.domHandlers = e;
        }
        return n;
      }(), gmt = function(n) {
        V(t, n);
        function t(e, i) {
          var r = n.call(this) || this;
          return r.__pointerCapturing = false, r.dom = e, r.painterRoot = i, r._localHandlerScope = new dG(e, Va), Xb && (r._globalHandlerScope = new dG(document, Jb)), cmt(r, r._localHandlerScope), r;
        }
        return t.prototype.dispose = function() {
          t2(this._localHandlerScope), Xb && t2(this._globalHandlerScope);
        }, t.prototype.setCursor = function(e) {
          this.dom.style && (this.dom.style.cursor = e || "default");
        }, t.prototype.__togglePointerCapture = function(e) {
          if (this.__mayPointerCapture = null, Xb && +this.__pointerCapturing ^ +e) {
            this.__pointerCapturing = e;
            var i = this._globalHandlerScope;
            e ? fmt(this, i) : t2(i);
          }
        }, t;
      }(aa), AG = 1;
      ee.hasGlobalWindow && (AG = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
      var N_ = AG, e2 = 0.4, n2 = "#333", i2 = "#ccc", dmt = "#eee", pG = d_, vG = 5e-5;
      function fh(n) {
        return n > vG || n < -vG;
      }
      var gh = [], gg = [], r2 = Fr(), a2 = Math.abs, Ts = function() {
        function n() {
        }
        return n.prototype.getLocalTransform = function(t) {
          return n.getLocalTransform(this, t);
        }, n.prototype.setPosition = function(t) {
          this.x = t[0], this.y = t[1];
        }, n.prototype.setScale = function(t) {
          this.scaleX = t[0], this.scaleY = t[1];
        }, n.prototype.setSkew = function(t) {
          this.skewX = t[0], this.skewY = t[1];
        }, n.prototype.setOrigin = function(t) {
          this.originX = t[0], this.originY = t[1];
        }, n.prototype.needLocalTransform = function() {
          return fh(this.rotation) || fh(this.x) || fh(this.y) || fh(this.scaleX - 1) || fh(this.scaleY - 1) || fh(this.skewX) || fh(this.skewY);
        }, n.prototype.updateTransform = function() {
          var t = this.parent && this.parent.transform, e = this.needLocalTransform(), i = this.transform;
          if (!(e || t)) {
            i && (pG(i), this.invTransform = null);
            return;
          }
          i = i || Fr(), e ? this.getLocalTransform(i) : pG(i), t && (e ? Ss(i, t, i) : bb(i, t)), this.transform = i, this._resolveGlobalScaleRatio(i);
        }, n.prototype._resolveGlobalScaleRatio = function(t) {
          var e = this.globalScaleRatio;
          if (e != null && e !== 1) {
            this.getGlobalScale(gh);
            var i = gh[0] < 0 ? -1 : 1, r = gh[1] < 0 ? -1 : 1, a = ((gh[0] - i) * e + i) / gh[0] || 0, o = ((gh[1] - r) * e + r) / gh[1] || 0;
            t[0] *= a, t[1] *= a, t[2] *= o, t[3] *= o;
          }
          this.invTransform = this.invTransform || Fr(), lg(this.invTransform, t);
        }, n.prototype.getComputedTransform = function() {
          for (var t = this, e = []; t; ) e.push(t), t = t.parent;
          for (; t = e.pop(); ) t.updateTransform();
          return this.transform;
        }, n.prototype.setLocalTransform = function(t) {
          if (t) {
            var e = t[0] * t[0] + t[1] * t[1], i = t[2] * t[2] + t[3] * t[3], r = Math.atan2(t[1], t[0]), a = Math.PI / 2 + r - Math.atan2(t[3], t[2]);
            i = Math.sqrt(i) * Math.cos(a), e = Math.sqrt(e), this.skewX = a, this.skewY = 0, this.rotation = -r, this.x = +t[4], this.y = +t[5], this.scaleX = e, this.scaleY = i, this.originX = 0, this.originY = 0;
          }
        }, n.prototype.decomposeTransform = function() {
          if (this.transform) {
            var t = this.parent, e = this.transform;
            t && t.transform && (t.invTransform = t.invTransform || Fr(), Ss(gg, t.invTransform, e), e = gg);
            var i = this.originX, r = this.originY;
            (i || r) && (r2[4] = i, r2[5] = r, Ss(gg, e, r2), gg[4] -= i, gg[5] -= r, e = gg), this.setLocalTransform(e);
          }
        }, n.prototype.getGlobalScale = function(t) {
          var e = this.transform;
          return t = t || [], e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), e[0] < 0 && (t[0] = -t[0]), e[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t);
        }, n.prototype.transformCoordToLocal = function(t, e) {
          var i = [t, e], r = this.invTransform;
          return r && di(i, i, r), i;
        }, n.prototype.transformCoordToGlobal = function(t, e) {
          var i = [t, e], r = this.transform;
          return r && di(i, i, r), i;
        }, n.prototype.getLineScale = function() {
          var t = this.transform;
          return t && a2(t[0] - 1) > 1e-10 && a2(t[3] - 1) > 1e-10 ? Math.sqrt(a2(t[0] * t[3] - t[2] * t[1])) : 1;
        }, n.prototype.copyTransform = function(t) {
          yG(this, t);
        }, n.getLocalTransform = function(t, e) {
          e = e || [];
          var i = t.originX || 0, r = t.originY || 0, a = t.scaleX, o = t.scaleY, s = t.anchorX, l = t.anchorY, u = t.rotation || 0, h = t.x, c = t.y, f = t.skewX ? Math.tan(t.skewX) : 0, g = t.skewY ? Math.tan(-t.skewY) : 0;
          if (i || r || s || l) {
            var d = i + s, A = r + l;
            e[4] = -d * a - f * A * o, e[5] = -A * o - g * d * a;
          } else e[4] = e[5] = 0;
          return e[0] = a, e[3] = o, e[1] = g * a, e[2] = f * o, u && oh(e, e, u), e[4] += i + h, e[5] += r + c, e;
        }, n.initDefaultProps = function() {
          var t = n.prototype;
          t.scaleX = t.scaleY = t.globalScaleRatio = 1, t.x = t.y = t.originX = t.originY = t.skewX = t.skewY = t.rotation = t.anchorX = t.anchorY = 0;
        }(), n;
      }(), To = ["x", "y", "originX", "originY", "anchorX", "anchorY", "rotation", "scaleX", "scaleY", "skewX", "skewY"];
      function yG(n, t) {
        for (var e = 0; e < To.length; e++) {
          var i = To[e];
          n[i] = t[i];
        }
      }
      var mG = {};
      function zr(n, t) {
        t = t || Ql;
        var e = mG[t];
        e || (e = mG[t] = new yp(500));
        var i = e.get(n);
        return i == null && (i = Ol.measureText(n, t).width, e.put(n, i)), i;
      }
      function _G(n, t, e, i) {
        var r = zr(n, t), a = k_(t), o = Sp(0, r, e), s = dg(0, a, i), l = new Ht(o, s, r, a);
        return l;
      }
      function Cp(n, t, e, i) {
        var r = ((n || "") + "").split(`
`), a = r.length;
        if (a === 1) return _G(r[0], t, e, i);
        for (var o = new Ht(0, 0, 0, 0), s = 0; s < r.length; s++) {
          var l = _G(r[s], t, e, i);
          s === 0 ? o.copy(l) : o.union(l);
        }
        return o;
      }
      function Sp(n, t, e) {
        return e === "right" ? n -= t : e === "center" && (n -= t / 2), n;
      }
      function dg(n, t, e) {
        return e === "middle" ? n -= t / 2 : e === "bottom" && (n -= t), n;
      }
      function k_(n) {
        return zr("", n);
      }
      function ja(n, t) {
        return typeof n == "string" ? n.lastIndexOf("%") >= 0 ? parseFloat(n) / 100 * t : parseFloat(n) : n;
      }
      function F_(n, t, e) {
        var i = t.position || "inside", r = t.distance != null ? t.distance : 5, a = e.height, o = e.width, s = a / 2, l = e.x, u = e.y, h = "left", c = "top";
        if (i instanceof Array) l += ja(i[0], e.width), u += ja(i[1], e.height), h = null, c = null;
        else switch (i) {
          case "left":
            l -= r, u += s, h = "right", c = "middle";
            break;
          case "right":
            l += r + o, u += s, c = "middle";
            break;
          case "top":
            l += o / 2, u -= r, h = "center", c = "bottom";
            break;
          case "bottom":
            l += o / 2, u += a + r, h = "center";
            break;
          case "inside":
            l += o / 2, u += s, h = "center", c = "middle";
            break;
          case "insideLeft":
            l += r, u += s, c = "middle";
            break;
          case "insideRight":
            l += o - r, u += s, h = "right", c = "middle";
            break;
          case "insideTop":
            l += o / 2, u += r, h = "center";
            break;
          case "insideBottom":
            l += o / 2, u += a - r, h = "center", c = "bottom";
            break;
          case "insideTopLeft":
            l += r, u += r;
            break;
          case "insideTopRight":
            l += o - r, u += r, h = "right";
            break;
          case "insideBottomLeft":
            l += r, u += a - r, c = "bottom";
            break;
          case "insideBottomRight":
            l += o - r, u += a - r, h = "right", c = "bottom";
            break;
        }
        return n = n || {}, n.x = l, n.y = u, n.align = h, n.verticalAlign = c, n;
      }
      var o2 = "__zr_normal__", s2 = To.concat(["ignore"]), Amt = So(To, function(n, t) {
        return n[t] = true, n;
      }, { ignore: false }), Ag = {}, pmt = new Ht(0, 0, 0, 0), Q_ = function() {
        function n(t) {
          this.id = _z(), this.animators = [], this.currentStates = [], this.states = {}, this._init(t);
        }
        return n.prototype._init = function(t) {
          this.attr(t);
        }, n.prototype.drift = function(t, e, i) {
          switch (this.draggable) {
            case "horizontal":
              e = 0;
              break;
            case "vertical":
              t = 0;
              break;
          }
          var r = this.transform;
          r || (r = this.transform = [1, 0, 0, 1, 0, 0]), r[4] += t, r[5] += e, this.decomposeTransform(), this.markRedraw();
        }, n.prototype.beforeUpdate = function() {
        }, n.prototype.afterUpdate = function() {
        }, n.prototype.update = function() {
          this.updateTransform(), this.__dirty && this.updateInnerText();
        }, n.prototype.updateInnerText = function(t) {
          var e = this._textContent;
          if (e && (!e.ignore || t)) {
            this.textConfig || (this.textConfig = {});
            var i = this.textConfig, r = i.local, a = e.innerTransformable, o = void 0, s = void 0, l = false;
            a.parent = r ? this : null;
            var u = false;
            if (a.copyTransform(e), i.position != null) {
              var h = pmt;
              i.layoutRect ? h.copy(i.layoutRect) : h.copy(this.getBoundingRect()), r || h.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(Ag, i, h) : F_(Ag, i, h), a.x = Ag.x, a.y = Ag.y, o = Ag.align, s = Ag.verticalAlign;
              var c = i.origin;
              if (c && i.rotation != null) {
                var f = void 0, g = void 0;
                c === "center" ? (f = h.width * 0.5, g = h.height * 0.5) : (f = ja(c[0], h.width), g = ja(c[1], h.height)), u = true, a.originX = -a.x + f + (r ? 0 : h.x), a.originY = -a.y + g + (r ? 0 : h.y);
              }
            }
            i.rotation != null && (a.rotation = i.rotation);
            var d = i.offset;
            d && (a.x += d[0], a.y += d[1], u || (a.originX = -d[0], a.originY = -d[1]));
            var A = i.inside == null ? typeof i.position == "string" && i.position.indexOf("inside") >= 0 : i.inside, p = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), v = void 0, y = void 0, m = void 0;
            A && this.canBeInsideText() ? (v = i.insideFill, y = i.insideStroke, (v == null || v === "auto") && (v = this.getInsideTextFill()), (y == null || y === "auto") && (y = this.getInsideTextStroke(v), m = true)) : (v = i.outsideFill, y = i.outsideStroke, (v == null || v === "auto") && (v = this.getOutsideFill()), (y == null || y === "auto") && (y = this.getOutsideStroke(v), m = true)), v = v || "#000", (v !== p.fill || y !== p.stroke || m !== p.autoStroke || o !== p.align || s !== p.verticalAlign) && (l = true, p.fill = v, p.stroke = y, p.autoStroke = m, p.align = o, p.verticalAlign = s, e.setDefaultTextStyle(p)), e.__dirty |= Qr, l && e.dirtyStyle(true);
          }
        }, n.prototype.canBeInsideText = function() {
          return true;
        }, n.prototype.getInsideTextFill = function() {
          return "#fff";
        }, n.prototype.getInsideTextStroke = function(t) {
          return "#000";
        }, n.prototype.getOutsideFill = function() {
          return this.__zr && this.__zr.isDarkMode() ? i2 : n2;
        }, n.prototype.getOutsideStroke = function(t) {
          var e = this.__zr && this.__zr.getBackgroundColor(), i = typeof e == "string" && Or(e);
          i || (i = [255, 255, 255, 1]);
          for (var r = i[3], a = this.__zr.isDarkMode(), o = 0; o < 3; o++) i[o] = i[o] * r + (a ? 0 : 255) * (1 - r);
          return i[3] = 1, bs(i, "rgba");
        }, n.prototype.traverse = function(t, e) {
        }, n.prototype.attrKV = function(t, e) {
          t === "textConfig" ? this.setTextConfig(e) : t === "textContent" ? this.setTextContent(e) : t === "clipPath" ? this.setClipPath(e) : t === "extra" ? (this.extra = this.extra || {}, Y(this.extra, e)) : this[t] = e;
        }, n.prototype.hide = function() {
          this.ignore = true, this.markRedraw();
        }, n.prototype.show = function() {
          this.ignore = false, this.markRedraw();
        }, n.prototype.attr = function(t, e) {
          if (typeof t == "string") this.attrKV(t, e);
          else if (_t(t)) for (var i = t, r = re(i), a = 0; a < r.length; a++) {
            var o = r[a];
            this.attrKV(o, t[o]);
          }
          return this.markRedraw(), this;
        }, n.prototype.saveCurrentToNormalState = function(t) {
          this._innerSaveToNormal(t);
          for (var e = this._normalState, i = 0; i < this.animators.length; i++) {
            var r = this.animators[i], a = r.__fromStateTransition;
            if (!(r.getLoop() || a && a !== o2)) {
              var o = r.targetName, s = o ? e[o] : e;
              r.saveTo(s);
            }
          }
        }, n.prototype._innerSaveToNormal = function(t) {
          var e = this._normalState;
          e || (e = this._normalState = {}), t.textConfig && !e.textConfig && (e.textConfig = this.textConfig), this._savePrimaryToNormal(t, e, s2);
        }, n.prototype._savePrimaryToNormal = function(t, e, i) {
          for (var r = 0; r < i.length; r++) {
            var a = i[r];
            t[a] != null && !(a in e) && (e[a] = this[a]);
          }
        }, n.prototype.hasState = function() {
          return this.currentStates.length > 0;
        }, n.prototype.getState = function(t) {
          return this.states[t];
        }, n.prototype.ensureState = function(t) {
          var e = this.states;
          return e[t] || (e[t] = {}), e[t];
        }, n.prototype.clearStates = function(t) {
          this.useState(o2, false, t);
        }, n.prototype.useState = function(t, e, i, r) {
          var a = t === o2, o = this.hasState();
          if (!(!o && a)) {
            var s = this.currentStates, l = this.stateTransition;
            if (!(Wt(s, t) >= 0 && (e || s.length === 1))) {
              var u;
              if (this.stateProxy && !a && (u = this.stateProxy(t)), u || (u = this.states && this.states[t]), !u && !a) {
                za("State " + t + " not exists.");
                return;
              }
              a || this.saveCurrentToNormalState(u);
              var h = !!(u && u.hoverLayer || r);
              h && this._toggleHoverLayerFlag(true), this._applyStateObj(t, u, this._normalState, e, !i && !this.__inHover && l && l.duration > 0, l);
              var c = this._textContent, f = this._textGuide;
              return c && c.useState(t, e, i, h), f && f.useState(t, e, i, h), a ? (this.currentStates = [], this._normalState = {}) : e ? this.currentStates.push(t) : this.currentStates = [t], this._updateAnimationTargets(), this.markRedraw(), !h && this.__inHover && (this._toggleHoverLayerFlag(false), this.__dirty &= ~Qr), u;
            }
          }
        }, n.prototype.useStates = function(t, e, i) {
          if (!t.length) this.clearStates();
          else {
            var r = [], a = this.currentStates, o = t.length, s = o === a.length;
            if (s) {
              for (var l = 0; l < o; l++) if (t[l] !== a[l]) {
                s = false;
                break;
              }
            }
            if (s) return;
            for (var l = 0; l < o; l++) {
              var u = t[l], h = void 0;
              this.stateProxy && (h = this.stateProxy(u, t)), h || (h = this.states[u]), h && r.push(h);
            }
            var c = r[o - 1], f = !!(c && c.hoverLayer || i);
            f && this._toggleHoverLayerFlag(true);
            var g = this._mergeStates(r), d = this.stateTransition;
            this.saveCurrentToNormalState(g), this._applyStateObj(t.join(","), g, this._normalState, false, !e && !this.__inHover && d && d.duration > 0, d);
            var A = this._textContent, p = this._textGuide;
            A && A.useStates(t, e, f), p && p.useStates(t, e, f), this._updateAnimationTargets(), this.currentStates = t.slice(), this.markRedraw(), !f && this.__inHover && (this._toggleHoverLayerFlag(false), this.__dirty &= ~Qr);
          }
        }, n.prototype.isSilent = function() {
          for (var t = this.silent, e = this.parent; !t && e; ) {
            if (e.silent) {
              t = true;
              break;
            }
            e = e.parent;
          }
          return t;
        }, n.prototype._updateAnimationTargets = function() {
          for (var t = 0; t < this.animators.length; t++) {
            var e = this.animators[t];
            e.targetName && e.changeTarget(this[e.targetName]);
          }
        }, n.prototype.removeState = function(t) {
          var e = Wt(this.currentStates, t);
          if (e >= 0) {
            var i = this.currentStates.slice();
            i.splice(e, 1), this.useStates(i);
          }
        }, n.prototype.replaceState = function(t, e, i) {
          var r = this.currentStates.slice(), a = Wt(r, t), o = Wt(r, e) >= 0;
          a >= 0 ? o ? r.splice(a, 1) : r[a] = e : i && !o && r.push(e), this.useStates(r);
        }, n.prototype.toggleState = function(t, e) {
          e ? this.useState(t, true) : this.removeState(t);
        }, n.prototype._mergeStates = function(t) {
          for (var e = {}, i, r = 0; r < t.length; r++) {
            var a = t[r];
            Y(e, a), a.textConfig && (i = i || {}, Y(i, a.textConfig));
          }
          return i && (e.textConfig = i), e;
        }, n.prototype._applyStateObj = function(t, e, i, r, a, o) {
          var s = !(e && r);
          e && e.textConfig ? (this.textConfig = Y({}, r ? this.textConfig : i.textConfig), Y(this.textConfig, e.textConfig)) : s && i.textConfig && (this.textConfig = i.textConfig);
          for (var l = {}, u = false, h = 0; h < s2.length; h++) {
            var c = s2[h], f = a && Amt[c];
            e && e[c] != null ? f ? (u = true, l[c] = e[c]) : this[c] = e[c] : s && i[c] != null && (f ? (u = true, l[c] = i[c]) : this[c] = i[c]);
          }
          if (!a) for (var h = 0; h < this.animators.length; h++) {
            var g = this.animators[h], d = g.targetName;
            g.getLoop() || g.__changeFinalValue(d ? (e || i)[d] : e || i);
          }
          u && this._transitionState(t, l, o);
        }, n.prototype._attachComponent = function(t) {
          if (t.__zr && !t.__hostTarget) {
            if (true) throw new Error("Text element has been added to zrender.");
            return;
          }
          if (t === this) {
            if (true) throw new Error("Recursive component attachment.");
            return;
          }
          var e = this.__zr;
          e && t.addSelfToZr(e), t.__zr = e, t.__hostTarget = this;
        }, n.prototype._detachComponent = function(t) {
          t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__hostTarget = null;
        }, n.prototype.getClipPath = function() {
          return this._clipPath;
        }, n.prototype.setClipPath = function(t) {
          this._clipPath && this._clipPath !== t && this.removeClipPath(), this._attachComponent(t), this._clipPath = t, this.markRedraw();
        }, n.prototype.removeClipPath = function() {
          var t = this._clipPath;
          t && (this._detachComponent(t), this._clipPath = null, this.markRedraw());
        }, n.prototype.getTextContent = function() {
          return this._textContent;
        }, n.prototype.setTextContent = function(t) {
          var e = this._textContent;
          if (e !== t) {
            if (e && e !== t && this.removeTextContent(), t.__zr && !t.__hostTarget) throw new Error("Text element has been added to zrender.");
            t.innerTransformable = new Ts(), this._attachComponent(t), this._textContent = t, this.markRedraw();
          }
        }, n.prototype.setTextConfig = function(t) {
          this.textConfig || (this.textConfig = {}), Y(this.textConfig, t), this.markRedraw();
        }, n.prototype.removeTextConfig = function() {
          this.textConfig = null, this.markRedraw();
        }, n.prototype.removeTextContent = function() {
          var t = this._textContent;
          t && (t.innerTransformable = null, this._detachComponent(t), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
        }, n.prototype.getTextGuideLine = function() {
          return this._textGuide;
        }, n.prototype.setTextGuideLine = function(t) {
          this._textGuide && this._textGuide !== t && this.removeTextGuideLine(), this._attachComponent(t), this._textGuide = t, this.markRedraw();
        }, n.prototype.removeTextGuideLine = function() {
          var t = this._textGuide;
          t && (this._detachComponent(t), this._textGuide = null, this.markRedraw());
        }, n.prototype.markRedraw = function() {
          this.__dirty |= Qr;
          var t = this.__zr;
          t && (this.__inHover ? t.refreshHover() : t.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
        }, n.prototype.dirty = function() {
          this.markRedraw();
        }, n.prototype._toggleHoverLayerFlag = function(t) {
          this.__inHover = t;
          var e = this._textContent, i = this._textGuide;
          e && (e.__inHover = t), i && (i.__inHover = t);
        }, n.prototype.addSelfToZr = function(t) {
          if (this.__zr !== t) {
            this.__zr = t;
            var e = this.animators;
            if (e) for (var i = 0; i < e.length; i++) t.animation.addAnimator(e[i]);
            this._clipPath && this._clipPath.addSelfToZr(t), this._textContent && this._textContent.addSelfToZr(t), this._textGuide && this._textGuide.addSelfToZr(t);
          }
        }, n.prototype.removeSelfFromZr = function(t) {
          if (this.__zr) {
            this.__zr = null;
            var e = this.animators;
            if (e) for (var i = 0; i < e.length; i++) t.animation.removeAnimator(e[i]);
            this._clipPath && this._clipPath.removeSelfFromZr(t), this._textContent && this._textContent.removeSelfFromZr(t), this._textGuide && this._textGuide.removeSelfFromZr(t);
          }
        }, n.prototype.animate = function(t, e, i) {
          var r = t ? this[t] : this;
          if (!r) {
            za('Property "' + t + '" is not existed in element ' + this.id);
            return;
          }
          var a = new Wb(r, e, i);
          return t && (a.targetName = t), this.addAnimator(a, t), a;
        }, n.prototype.addAnimator = function(t, e) {
          var i = this.__zr, r = this;
          t.during(function() {
            r.updateDuringAnimation(e);
          }).done(function() {
            var a = r.animators, o = Wt(a, t);
            o >= 0 && a.splice(o, 1);
          }), this.animators.push(t), i && i.animation.addAnimator(t), i && i.wakeUp();
        }, n.prototype.updateDuringAnimation = function(t) {
          this.markRedraw();
        }, n.prototype.stopAnimation = function(t, e) {
          for (var i = this.animators, r = i.length, a = [], o = 0; o < r; o++) {
            var s = i[o];
            !t || t === s.scope ? s.stop(e) : a.push(s);
          }
          return this.animators = a, this;
        }, n.prototype.animateTo = function(t, e, i) {
          l2(this, t, e, i);
        }, n.prototype.animateFrom = function(t, e, i) {
          l2(this, t, e, i, true);
        }, n.prototype._transitionState = function(t, e, i, r) {
          for (var a = l2(this, e, i, r), o = 0; o < a.length; o++) a[o].__fromStateTransition = t;
        }, n.prototype.getBoundingRect = function() {
          return null;
        }, n.prototype.getPaintRect = function() {
          return null;
        }, n.initDefaultProps = function() {
          var t = n.prototype;
          t.type = "element", t.name = "", t.ignore = t.silent = t.isGroup = t.draggable = t.dragging = t.ignoreClip = t.__inHover = false, t.__dirty = Qr;
          var e = {};
          function i(a, o, s) {
            e[a + o + s] || (e[a + o + s] = true);
          }
          function r(a, o, s, l) {
            Object.defineProperty(t, a, { get: function() {
              if (i(a, s, l), !this[o]) {
                var h = this[o] = [];
                u(this, h);
              }
              return this[o];
            }, set: function(h) {
              i(a, s, l), this[s] = h[0], this[l] = h[1], this[o] = h, u(this, h);
            } });
            function u(h, c) {
              Object.defineProperty(c, 0, { get: function() {
                return h[s];
              }, set: function(f) {
                h[s] = f;
              } }), Object.defineProperty(c, 1, { get: function() {
                return h[l];
              }, set: function(f) {
                h[l] = f;
              } });
            }
          }
          Object.defineProperty && (r("position", "_legacyPos", "x", "y"), r("scale", "_legacyScale", "scaleX", "scaleY"), r("origin", "_legacyOrigin", "originX", "originY"));
        }(), n;
      }();
      Mn(Q_, aa), Mn(Q_, Ts);
      function l2(n, t, e, i, r) {
        e = e || {};
        var a = [];
        IG(n, "", n, t, e, i, a, r);
        var o = a.length, s = false, l = e.done, u = e.aborted, h = function() {
          s = true, o--, o <= 0 && (s ? l && l() : u && u());
        }, c = function() {
          o--, o <= 0 && (s ? l && l() : u && u());
        };
        o || l && l(), a.length > 0 && e.during && a[0].during(function(d, A) {
          e.during(A);
        });
        for (var f = 0; f < a.length; f++) {
          var g = a[f];
          h && g.done(h), c && g.aborted(c), e.force && g.duration(e.duration), g.start(e.easing);
        }
        return a;
      }
      function u2(n, t, e) {
        for (var i = 0; i < e; i++) n[i] = t[i];
      }
      function vmt(n) {
        return Mi(n[0]);
      }
      function ymt(n, t, e) {
        if (Mi(t[e])) if (Mi(n[e]) || (n[e] = []), Ui(t[e])) {
          var i = t[e].length;
          n[e].length !== i && (n[e] = new t[e].constructor(i), u2(n[e], t[e], i));
        } else {
          var r = t[e], a = n[e], o = r.length;
          if (vmt(r)) for (var s = r[0].length, l = 0; l < o; l++) a[l] ? u2(a[l], r[l], s) : a[l] = Array.prototype.slice.call(r[l]);
          else u2(a, r, o);
          a.length = r.length;
        }
        else n[e] = t[e];
      }
      function mmt(n, t) {
        return n === t || Mi(n) && Mi(t) && _mt(n, t);
      }
      function _mt(n, t) {
        var e = n.length;
        if (e !== t.length) return false;
        for (var i = 0; i < e; i++) if (n[i] !== t[i]) return false;
        return true;
      }
      function IG(n, t, e, i, r, a, o, s) {
        for (var l = re(i), u = r.duration, h = r.delay, c = r.additive, f = r.setToFinal, g = !_t(a), d = n.animators, A = [], p = 0; p < l.length; p++) {
          var v = l[p], y = i[v];
          if (y != null && e[v] != null && (g || a[v])) if (_t(y) && !Mi(y) && !s_(y)) {
            if (t) {
              s || (e[v] = y, n.updateDuringAnimation(t));
              continue;
            }
            IG(n, v, e[v], y, r, a && a[v], o, s);
          } else A.push(v);
          else s || (e[v] = y, n.updateDuringAnimation(t), A.push(v));
        }
        var m = A.length;
        if (!c && m) for (var _ = 0; _ < d.length; _++) {
          var E = d[_];
          if (E.targetName === t) {
            var I = E.stopTracks(A);
            if (I) {
              var x = Wt(d, E);
              d.splice(x, 1);
            }
          }
        }
        if (r.force || (A = Ne(A, function(b) {
          return !mmt(i[b], e[b]);
        }), m = A.length), m > 0 || r.force && !o.length) {
          var w = void 0, C = void 0, S = void 0;
          if (s) {
            C = {}, f && (w = {});
            for (var _ = 0; _ < m; _++) {
              var v = A[_];
              C[v] = e[v], f ? w[v] = i[v] : e[v] = i[v];
            }
          } else if (f) {
            S = {};
            for (var _ = 0; _ < m; _++) {
              var v = A[_];
              S[v] = Ep(e[v]), ymt(e, i, v);
            }
          }
          var E = new Wb(e, false, false, c ? Ne(d, function(B) {
            return B.targetName === t;
          }) : null);
          E.targetName = t, r.scope && (E.scope = r.scope), f && w && E.whenWithKeys(0, w, A), S && E.whenWithKeys(0, S, A), E.whenWithKeys(u == null ? 500 : u, s ? C : i, A).delay(h || 0), n.addAnimator(E, t), o.push(E);
        }
      }
      var Ct = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this) || this;
          return i.isGroup = true, i._children = [], i.attr(e), i;
        }
        return t.prototype.childrenRef = function() {
          return this._children;
        }, t.prototype.children = function() {
          return this._children.slice();
        }, t.prototype.childAt = function(e) {
          return this._children[e];
        }, t.prototype.childOfName = function(e) {
          for (var i = this._children, r = 0; r < i.length; r++) if (i[r].name === e) return i[r];
        }, t.prototype.childCount = function() {
          return this._children.length;
        }, t.prototype.add = function(e) {
          if (e && (e !== this && e.parent !== this && (this._children.push(e), this._doAdd(e)), e.__hostTarget)) throw "This elemenet has been used as an attachment";
          return this;
        }, t.prototype.addBefore = function(e, i) {
          if (e && e !== this && e.parent !== this && i && i.parent === this) {
            var r = this._children, a = r.indexOf(i);
            a >= 0 && (r.splice(a, 0, e), this._doAdd(e));
          }
          return this;
        }, t.prototype.replace = function(e, i) {
          var r = Wt(this._children, e);
          return r >= 0 && this.replaceAt(i, r), this;
        }, t.prototype.replaceAt = function(e, i) {
          var r = this._children, a = r[i];
          if (e && e !== this && e.parent !== this && e !== a) {
            r[i] = e, a.parent = null;
            var o = this.__zr;
            o && a.removeSelfFromZr(o), this._doAdd(e);
          }
          return this;
        }, t.prototype._doAdd = function(e) {
          e.parent && e.parent.remove(e), e.parent = this;
          var i = this.__zr;
          i && i !== e.__zr && e.addSelfToZr(i), i && i.refresh();
        }, t.prototype.remove = function(e) {
          var i = this.__zr, r = this._children, a = Wt(r, e);
          return a < 0 ? this : (r.splice(a, 1), e.parent = null, i && e.removeSelfFromZr(i), i && i.refresh(), this);
        }, t.prototype.removeAll = function() {
          for (var e = this._children, i = this.__zr, r = 0; r < e.length; r++) {
            var a = e[r];
            i && a.removeSelfFromZr(i), a.parent = null;
          }
          return e.length = 0, this;
        }, t.prototype.eachChild = function(e, i) {
          for (var r = this._children, a = 0; a < r.length; a++) {
            var o = r[a];
            e.call(i, o, a);
          }
          return this;
        }, t.prototype.traverse = function(e, i) {
          for (var r = 0; r < this._children.length; r++) {
            var a = this._children[r], o = e.call(i, a);
            a.isGroup && !o && a.traverse(e, i);
          }
          return this;
        }, t.prototype.addSelfToZr = function(e) {
          n.prototype.addSelfToZr.call(this, e);
          for (var i = 0; i < this._children.length; i++) {
            var r = this._children[i];
            r.addSelfToZr(e);
          }
        }, t.prototype.removeSelfFromZr = function(e) {
          n.prototype.removeSelfFromZr.call(this, e);
          for (var i = 0; i < this._children.length; i++) {
            var r = this._children[i];
            r.removeSelfFromZr(e);
          }
        }, t.prototype.getBoundingRect = function(e) {
          for (var i = new Ht(0, 0, 0, 0), r = e || this._children, a = [], o = null, s = 0; s < r.length; s++) {
            var l = r[s];
            if (!(l.ignore || l.invisible)) {
              var u = l.getBoundingRect(), h = l.getLocalTransform(a);
              h ? (Ht.applyTransform(i, u, h), o = o || i.clone(), o.union(i)) : (o = o || u.clone(), o.union(u));
            }
          }
          return o || i;
        }, t;
      }(Q_);
      Ct.prototype.type = "group";
      var bp = {}, EG = {};
      function Imt(n) {
        delete EG[n];
      }
      function Emt(n) {
        if (!n) return false;
        if (typeof n == "string") return C_(n, 1) < e2;
        if (n.colorStops) {
          for (var t = n.colorStops, e = 0, i = t.length, r = 0; r < i; r++) e += C_(t[r].color, 1);
          return e /= i, e < e2;
        }
        return false;
      }
      var xmt = function() {
        function n(t, e, i) {
          var r = this;
          this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = true, this._needsRefreshHover = true, this._darkMode = false, i = i || {}, this.dom = e, this.id = t;
          var a = new Q0t(), o = i.renderer || "canvas";
          if (bp[o] || (o = re(bp)[0]), !bp[o]) throw new Error("Renderer '" + o + "' is not imported. Please import it first.");
          i.useDirtyRect = i.useDirtyRect == null ? false : i.useDirtyRect;
          var s = new bp[o](e, a, i, t), l = i.ssr || s.ssrOnly;
          this.storage = a, this.painter = s;
          var u = !ee.node && !ee.worker && !l ? new gmt(s.getViewportRoot(), s.root) : null, h = i.useCoarsePointer, c = h == null || h === "auto" ? ee.touchEventsSupported : !!h, f = 44, g;
          c && (g = Pt(i.pointerSize, f)), this.handler = new Pz(a, s, u, s.root, g), this.animation = new omt({ stage: { update: l ? null : function() {
            return r._flush(true);
          } } }), l || this.animation.start();
        }
        return n.prototype.add = function(t) {
          this._disposed || !t || (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh());
        }, n.prototype.remove = function(t) {
          this._disposed || !t || (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh());
        }, n.prototype.configLayer = function(t, e) {
          this._disposed || (this.painter.configLayer && this.painter.configLayer(t, e), this.refresh());
        }, n.prototype.setBackgroundColor = function(t) {
          this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this.refresh(), this._backgroundColor = t, this._darkMode = Emt(t));
        }, n.prototype.getBackgroundColor = function() {
          return this._backgroundColor;
        }, n.prototype.setDarkMode = function(t) {
          this._darkMode = t;
        }, n.prototype.isDarkMode = function() {
          return this._darkMode;
        }, n.prototype.refreshImmediately = function(t) {
          this._disposed || (t || this.animation.update(true), this._needsRefresh = false, this.painter.refresh(), this._needsRefresh = false);
        }, n.prototype.refresh = function() {
          this._disposed || (this._needsRefresh = true, this.animation.start());
        }, n.prototype.flush = function() {
          this._disposed || this._flush(false);
        }, n.prototype._flush = function(t) {
          var e, i = fg();
          this._needsRefresh && (e = true, this.refreshImmediately(t)), this._needsRefreshHover && (e = true, this.refreshHoverImmediately());
          var r = fg();
          e ? (this._stillFrameAccum = 0, this.trigger("rendered", { elapsedTime: r - i })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
        }, n.prototype.setSleepAfterStill = function(t) {
          this._sleepAfterStill = t;
        }, n.prototype.wakeUp = function() {
          this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
        }, n.prototype.refreshHover = function() {
          this._needsRefreshHover = true;
        }, n.prototype.refreshHoverImmediately = function() {
          this._disposed || (this._needsRefreshHover = false, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
        }, n.prototype.resize = function(t) {
          this._disposed || (t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize());
        }, n.prototype.clearAnimation = function() {
          this._disposed || this.animation.clear();
        }, n.prototype.getWidth = function() {
          if (!this._disposed) return this.painter.getWidth();
        }, n.prototype.getHeight = function() {
          if (!this._disposed) return this.painter.getHeight();
        }, n.prototype.setCursorStyle = function(t) {
          this._disposed || this.handler.setCursorStyle(t);
        }, n.prototype.findHover = function(t, e) {
          if (!this._disposed) return this.handler.findHover(t, e);
        }, n.prototype.on = function(t, e, i) {
          return this._disposed || this.handler.on(t, e, i), this;
        }, n.prototype.off = function(t, e) {
          this._disposed || this.handler.off(t, e);
        }, n.prototype.trigger = function(t, e) {
          this._disposed || this.handler.trigger(t, e);
        }, n.prototype.clear = function() {
          if (!this._disposed) {
            for (var t = this.storage.getRoots(), e = 0; e < t.length; e++) t[e] instanceof Ct && t[e].removeSelfFromZr(this);
            this.storage.delAllRoots(), this.painter.clear();
          }
        }, n.prototype.dispose = function() {
          this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = true, Imt(this.id));
        }, n;
      }();
      function xG(n, t) {
        var e = new xmt(_z(), n, t);
        return EG[e.id] = e, e;
      }
      function wmt(n, t) {
        bp[n] = t;
      }
      var h2;
      function Cmt(n) {
        if (typeof h2 == "function") return h2(n);
      }
      function Smt(n) {
        h2 = n;
      }
      var wG = 1e-4, CG = 20;
      function bmt(n) {
        return n.replace(/^\s+|\s+$/g, "");
      }
      function Le(n, t, e, i) {
        var r = t[0], a = t[1], o = e[0], s = e[1], l = a - r, u = s - o;
        if (l === 0) return u === 0 ? o : (o + s) / 2;
        if (i) if (l > 0) {
          if (n <= r) return o;
          if (n >= a) return s;
        } else {
          if (n >= r) return o;
          if (n <= a) return s;
        }
        else {
          if (n === r) return o;
          if (n === a) return s;
        }
        return (n - r) / l * u + o;
      }
      function ot(n, t) {
        switch (n) {
          case "center":
          case "middle":
            n = "50%";
            break;
          case "left":
          case "top":
            n = "0%";
            break;
          case "right":
          case "bottom":
            n = "100%";
            break;
        }
        return ht(n) ? bmt(n).match(/%$/) ? parseFloat(n) / 100 * t : parseFloat(n) : n == null ? NaN : +n;
      }
      function vn(n, t, e) {
        return t == null && (t = 10), t = Math.min(Math.max(0, t), CG), n = (+n).toFixed(t), e ? n : +n;
      }
      function ua(n) {
        return n.sort(function(t, e) {
          return t - e;
        }), n;
      }
      function Mo(n) {
        if (n = +n, isNaN(n)) return 0;
        if (n > 1e-14) {
          for (var t = 1, e = 0; e < 15; e++, t *= 10) if (Math.round(n * t) / t === n) return e;
        }
        return c2(n);
      }
      function c2(n) {
        var t = n.toString().toLowerCase(), e = t.indexOf("e"), i = e > 0 ? +t.slice(e + 1) : 0, r = e > 0 ? e : t.length, a = t.indexOf("."), o = a < 0 ? 0 : r - 1 - a;
        return Math.max(0, o - i);
      }
      function SG(n, t) {
        var e = Math.log, i = Math.LN10, r = Math.floor(e(n[1] - n[0]) / i), a = Math.round(e(Math.abs(t[1] - t[0])) / i), o = Math.min(Math.max(-r + a, 0), 20);
        return isFinite(o) ? o : 20;
      }
      function Bmt(n, t) {
        var e = So(n, function(g, d) {
          return g + (isNaN(d) ? 0 : d);
        }, 0);
        if (e === 0) return [];
        for (var i = Math.pow(10, t), r = Z(n, function(g) {
          return (isNaN(g) ? 0 : g) / e * i * 100;
        }), a = i * 100, o = Z(r, function(g) {
          return Math.floor(g);
        }), s = So(o, function(g, d) {
          return g + d;
        }, 0), l = Z(r, function(g, d) {
          return g - o[d];
        }); s < a; ) {
          for (var u = Number.NEGATIVE_INFINITY, h = null, c = 0, f = l.length; c < f; ++c) l[c] > u && (u = l[c], h = c);
          ++o[h], l[h] = 0, ++s;
        }
        return Z(o, function(g) {
          return g / i;
        });
      }
      function Tmt(n, t) {
        var e = Math.max(Mo(n), Mo(t)), i = n + t;
        return e > CG ? i : vn(i, e);
      }
      var bG = 9007199254740991;
      function BG(n) {
        var t = Math.PI * 2;
        return (n % t + t) % t;
      }
      function Bp(n) {
        return n > -wG && n < wG;
      }
      var Mmt = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
      function Do(n) {
        if (n instanceof Date) return n;
        if (ht(n)) {
          var t = Mmt.exec(n);
          if (!t) return /* @__PURE__ */ new Date(NaN);
          if (t[8]) {
            var e = +t[4] || 0;
            return t[8].toUpperCase() !== "Z" && (e -= +t[8].slice(0, 3)), new Date(Date.UTC(+t[1], +(t[2] || 1) - 1, +t[3] || 1, e, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0));
          } else return new Date(+t[1], +(t[2] || 1) - 1, +t[3] || 1, +t[4] || 0, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0);
        } else if (n == null) return /* @__PURE__ */ new Date(NaN);
        return new Date(Math.round(n));
      }
      function Dmt(n) {
        return Math.pow(10, O_(n));
      }
      function O_(n) {
        if (n === 0) return 0;
        var t = Math.floor(Math.log(n) / Math.LN10);
        return n / Math.pow(10, t) >= 10 && t++, t;
      }
      function TG(n, t) {
        var e = O_(n), i = Math.pow(10, e), r = n / i, a;
        return r < 1.5 ? a = 1 : r < 2.5 ? a = 2 : r < 4 ? a = 3 : r < 7 ? a = 5 : a = 10, n = a * i, e >= -20 ? +n.toFixed(e < 0 ? -e : 0) : n;
      }
      function f2(n, t) {
        var e = (n.length - 1) * t + 1, i = Math.floor(e), r = +n[i - 1], a = e - i;
        return a ? r + a * (n[i] - r) : r;
      }
      function MG(n) {
        n.sort(function(l, u) {
          return s(l, u, 0) ? -1 : 1;
        });
        for (var t = -1 / 0, e = 1, i = 0; i < n.length; ) {
          for (var r = n[i].interval, a = n[i].close, o = 0; o < 2; o++) r[o] <= t && (r[o] = t, a[o] = o ? 1 : 1 - e), t = r[o], e = a[o];
          r[0] === r[1] && a[0] * a[1] !== 1 ? n.splice(i, 1) : i++;
        }
        return n;
        function s(l, u, h) {
          return l.interval[h] < u.interval[h] || l.interval[h] === u.interval[h] && (l.close[h] - u.close[h] === (h ? -1 : 1) || !h && s(l, u, 1));
        }
      }
      function Ms(n) {
        var t = parseFloat(n);
        return t == n && (t !== 0 || !ht(n) || n.indexOf("x") <= 0) ? t : NaN;
      }
      function g2(n) {
        return !isNaN(Ms(n));
      }
      function DG() {
        return Math.round(Math.random() * 9);
      }
      function RG(n, t) {
        return t === 0 ? n : RG(t, n % t);
      }
      function LG(n, t) {
        return n == null ? t : t == null ? n : n * t / RG(n, t);
      }
      var mzt = "[ECharts] ", PG = {}, Rmt = typeof console != "undefined" && console.warn && console.log;
      function z_(n, t, e) {
        if (Rmt && e) {
          if (PG[t]) return;
          PG[t] = true;
        }
      }
      function Lmt(n, t) {
        z_("log", n, t);
      }
      function un(n, t) {
        z_("warn", n, t);
      }
      function Ai(n, t) {
        z_("error", n, t);
      }
      function qa(n) {
        z_("warn", "DEPRECATED: " + n, true);
      }
      function Rn(n, t, e) {
        qa((e ? "[" + e + "]" : "") + (n + " is deprecated, use " + t + " instead."));
      }
      function vr() {
        for (var n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];
        var e = "";
        if (true) {
          var i = function(r) {
            return r === void 0 ? "undefined" : r === 1 / 0 ? "Infinity" : r === -1 / 0 ? "-Infinity" : nh(r) ? "NaN" : r instanceof Date ? "Date(" + r.toISOString() + ")" : yt(r) ? "function () { ... }" : Ez(r) ? r + "" : null;
          };
          e = Z(n, function(r) {
            if (ht(r)) return r;
            var a = i(r);
            if (a != null) return a;
            if (typeof JSON != "undefined" && JSON.stringify) try {
              return JSON.stringify(r, function(o, s) {
                var l = i(s);
                return l == null ? s : l;
              });
            } catch (o) {
              return "?";
            }
            else return "?";
          }).join(" ");
        }
        return e;
      }
      function Ce(n) {
        throw new Error(n);
      }
      function NG(n, t, e) {
        return (t - n) * e + n;
      }
      var kG = "series\0", FG = "\0_ec_\0";
      function Qe(n) {
        return n instanceof Array ? n : n == null ? [] : [n];
      }
      function dh(n, t, e) {
        if (n) {
          n[t] = n[t] || {}, n.emphasis = n.emphasis || {}, n.emphasis[t] = n.emphasis[t] || {};
          for (var i = 0, r = e.length; i < r; i++) {
            var a = e[i];
            !n.emphasis[t].hasOwnProperty(a) && n[t].hasOwnProperty(a) && (n.emphasis[t][a] = n[t][a]);
          }
        }
      }
      var QG = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
      function pg(n) {
        return _t(n) && !X(n) && !(n instanceof Date) ? n.value : n;
      }
      function Pmt(n) {
        return _t(n) && !(n instanceof Array);
      }
      function OG(n, t, e) {
        var i = e === "normalMerge", r = e === "replaceMerge", a = e === "replaceAll";
        n = n || [], t = (t || []).slice();
        var o = dt();
        M(t, function(l, u) {
          if (!_t(l)) {
            t[u] = null;
            return;
          }
          l.id != null && !UG(l.id) && GG(l.id), l.name != null && !UG(l.name) && GG(l.name);
        });
        var s = Nmt(n, o, e);
        return (i || r) && kmt(s, n, o, t), i && Fmt(s, t), i || r ? Qmt(s, t, r) : a && Omt(s, t), zmt(s), s;
      }
      function Nmt(n, t, e) {
        var i = [];
        if (e === "replaceAll") return i;
        for (var r = 0; r < n.length; r++) {
          var a = n[r];
          a && a.id != null && t.set(a.id, r), i.push({ existing: e === "replaceMerge" || vg(a) ? null : a, newOption: null, keyInfo: null, brandNew: null });
        }
        return i;
      }
      function kmt(n, t, e, i) {
        M(i, function(r, a) {
          if (!(!r || r.id == null)) {
            var o = Tp(r.id), s = e.get(o);
            if (s != null) {
              var l = n[s];
              It(!l.newOption, 'Duplicated option on id "' + o + '".'), l.newOption = r, l.existing = t[s], i[a] = null;
            }
          }
        });
      }
      function Fmt(n, t) {
        M(t, function(e, i) {
          if (!(!e || e.name == null)) for (var r = 0; r < n.length; r++) {
            var a = n[r].existing;
            if (!n[r].newOption && a && (a.id == null || e.id == null) && !vg(e) && !vg(a) && zG("name", a, e)) {
              n[r].newOption = e, t[i] = null;
              return;
            }
          }
        });
      }
      function Qmt(n, t, e) {
        M(t, function(i) {
          if (i) {
            for (var r, a = 0; (r = n[a]) && (r.newOption || vg(r.existing) || r.existing && i.id != null && !zG("id", i, r.existing)); ) a++;
            r ? (r.newOption = i, r.brandNew = e) : n.push({ newOption: i, brandNew: e, existing: null, keyInfo: null }), a++;
          }
        });
      }
      function Omt(n, t) {
        M(t, function(e) {
          n.push({ newOption: e, brandNew: true, existing: null, keyInfo: null });
        });
      }
      function zmt(n) {
        var t = dt();
        M(n, function(e) {
          var i = e.existing;
          i && t.set(i.id, e);
        }), M(n, function(e) {
          var i = e.newOption;
          It(!i || i.id == null || !t.get(i.id) || t.get(i.id) === e, "id duplicates: " + (i && i.id)), i && i.id != null && t.set(i.id, e), !e.keyInfo && (e.keyInfo = {});
        }), M(n, function(e, i) {
          var r = e.existing, a = e.newOption, o = e.keyInfo;
          if (_t(a)) {
            if (o.name = a.name != null ? Tp(a.name) : r ? r.name : kG + i, r) o.id = Tp(r.id);
            else if (a.id != null) o.id = Tp(a.id);
            else {
              var s = 0;
              do
                o.id = "\0" + o.name + "\0" + s++;
              while (t.get(o.id));
            }
            t.set(o.id, e);
          }
        });
      }
      function zG(n, t, e) {
        var i = zn(t[n], null), r = zn(e[n], null);
        return i != null && r != null && i === r;
      }
      function Tp(n) {
        if (n == null) throw new Error();
        return zn(n, "");
      }
      function zn(n, t) {
        return n == null ? t : ht(n) ? n : pe(n) || o_(n) ? n + "" : t;
      }
      function GG(n) {
        un("`" + n + "` is invalid id or name. Must be a string or number.");
      }
      function UG(n) {
        return o_(n) || g2(n);
      }
      function d2(n) {
        var t = n.name;
        return !!(t && t.indexOf(kG));
      }
      function vg(n) {
        return n && n.id != null && Tp(n.id).indexOf(FG) === 0;
      }
      function Gmt(n) {
        return FG + n;
      }
      function Umt(n, t, e) {
        M(n, function(i) {
          var r = i.newOption;
          _t(r) && (i.keyInfo.mainType = t, i.keyInfo.subType = Vmt(t, r, i.existing, e));
        });
      }
      function Vmt(n, t, e, i) {
        var r = t.type ? t.type : e ? e.subType : i.determineSubType(n, t);
        return r;
      }
      function jmt(n, t) {
        var e = {}, i = {};
        return r(n || [], e), r(t || [], i, e), [a(e), a(i)];
        function r(o, s, l) {
          for (var u = 0, h = o.length; u < h; u++) {
            var c = zn(o[u].seriesId, null);
            if (c == null) return;
            for (var f = Qe(o[u].dataIndex), g = l && l[c], d = 0, A = f.length; d < A; d++) {
              var p = f[d];
              g && g[p] ? g[p] = null : (s[c] || (s[c] = {}))[p] = 1;
            }
          }
        }
        function a(o, s) {
          var l = [];
          for (var u in o) if (o.hasOwnProperty(u) && o[u] != null) if (s) l.push(+u);
          else {
            var h = a(o[u], true);
            h.length && l.push({ seriesId: u, dataIndex: h });
          }
          return l;
        }
      }
      function Ah(n, t) {
        if (t.dataIndexInside != null) return t.dataIndexInside;
        if (t.dataIndex != null) return X(t.dataIndex) ? Z(t.dataIndex, function(e) {
          return n.indexOfRawIndex(e);
        }) : n.indexOfRawIndex(t.dataIndex);
        if (t.name != null) return X(t.name) ? Z(t.name, function(e) {
          return n.indexOfName(e);
        }) : n.indexOfName(t.name);
      }
      function le() {
        var n = "__ec_inner_" + qmt++;
        return function(t) {
          return t[n] || (t[n] = {});
        };
      }
      var qmt = DG();
      function Mp(n, t, e) {
        var i = A2(t, e), r = i.mainTypeSpecified, a = i.queryOptionMap, o = i.others, s = o, l = e ? e.defaultMainType : null;
        return !r && l && a.set(l, {}), a.each(function(u, h) {
          var c = Dp(n, h, u, { useDefault: l === h, enableAll: e && e.enableAll != null ? e.enableAll : true, enableNone: e && e.enableNone != null ? e.enableNone : true });
          s[h + "Models"] = c.models, s[h + "Model"] = c.models[0];
        }), s;
      }
      function A2(n, t) {
        var e;
        if (ht(n)) {
          var i = {};
          i[n + "Index"] = 0, e = i;
        } else e = n;
        var r = dt(), a = {}, o = false;
        return M(e, function(s, l) {
          if (l === "dataIndex" || l === "dataIndexInside") {
            a[l] = s;
            return;
          }
          var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], h = u[1], c = (u[2] || "").toLowerCase();
          if (!(!h || !c || t && t.includeMainTypes && Wt(t.includeMainTypes, h) < 0)) {
            o = o || !!h;
            var f = r.get(h) || r.set(h, {});
            f[c] = s;
          }
        }), { mainTypeSpecified: o, queryOptionMap: r, others: a };
      }
      var Ln = { useDefault: true, enableAll: false, enableNone: false }, Hmt = { useDefault: false, enableAll: true, enableNone: true };
      function Dp(n, t, e, i) {
        i = i || Ln;
        var r = e.index, a = e.id, o = e.name, s = { models: null, specified: r != null || a != null || o != null };
        if (!s.specified) {
          var l = void 0;
          return s.models = i.useDefault && (l = n.getComponent(t)) ? [l] : [], s;
        }
        return r === "none" || r === false ? (It(i.enableNone, '`"none"` or `false` is not a valid value on index option.'), s.models = [], s) : (r === "all" && (It(i.enableAll, '`"all"` is not a valid value on index option.'), r = a = o = null), s.models = n.queryComponents({ mainType: t, index: r, id: a, name: o }), s);
      }
      function VG(n, t, e) {
        n.setAttribute ? n.setAttribute(t, e) : n[t] = e;
      }
      function Ymt(n, t) {
        return n.getAttribute ? n.getAttribute(t) : n[t];
      }
      function Wmt(n) {
        return n === "auto" ? ee.domSupported ? "html" : "richText" : n || "html";
      }
      function p2(n, t) {
        var e = dt(), i = [];
        return M(n, function(r) {
          var a = t(r);
          (e.get(a) || (i.push(a), e.set(a, []))).push(r);
        }), { keys: i, buckets: e };
      }
      function jG(n, t, e, i, r) {
        var a = t == null || t === "auto";
        if (i == null) return i;
        if (pe(i)) {
          var o = NG(e || 0, i, r);
          return vn(o, a ? Math.max(Mo(e || 0), Mo(i)) : t);
        } else {
          if (ht(i)) return r < 1 ? e : i;
          for (var s = [], l = e, u = i, h = Math.max(l ? l.length : 0, u.length), c = 0; c < h; ++c) {
            var f = n.getDimensionInfo(c);
            if (f && f.type === "ordinal") s[c] = (r < 1 && l ? l : u)[c];
            else {
              var g = l && l[c] ? l[c] : 0, d = u[c], o = NG(g, d, r);
              s[c] = vn(o, a ? Math.max(Mo(g), Mo(d)) : t);
            }
          }
          return s;
        }
      }
      var Xmt = ".", ph = "___EC__COMPONENT__CONTAINER___", qG = "___EC__EXTENDED_CLASS___";
      function Ro(n) {
        var t = { main: "", sub: "" };
        if (n) {
          var e = n.split(Xmt);
          t.main = e[0] || "", t.sub = e[1] || "";
        }
        return t;
      }
      function Zmt(n) {
        It(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(n), 'componentType "' + n + '" illegal');
      }
      function Kmt(n) {
        return !!(n && n[qG]);
      }
      function v2(n, t) {
        n.$constructor = n, n.extend = function(e) {
          M(t, function(a) {
            e[a];
          });
          var i = this, r;
          return $mt(i) ? r = function(a) {
            V(o, a);
            function o() {
              return a.apply(this, arguments) || this;
            }
            return o;
          }(i) : (r = function() {
            (e.$constructor || i).apply(this, arguments);
          }, o0t(r, this)), Y(r.prototype, e), r[qG] = true, r.extend = this.extend, r.superCall = e_t, r.superApply = n_t, r.superClass = i, r;
        };
      }
      function $mt(n) {
        return yt(n) && /^class\s/.test(Function.prototype.toString.call(n));
      }
      function HG(n, t) {
        n.extend = t.extend;
      }
      var Jmt = Math.round(Math.random() * 10);
      function t_t(n) {
        var t = ["__\0is_clz", Jmt++].join("_");
        n.prototype[t] = true, It(!n.isInstance, 'The method "is" can not be defined.'), n.isInstance = function(e) {
          return !!(e && e[t]);
        };
      }
      function e_t(n, t) {
        for (var e = [], i = 2; i < arguments.length; i++) e[i - 2] = arguments[i];
        return this.superClass.prototype[t].apply(n, e);
      }
      function n_t(n, t, e) {
        return this.superClass.prototype[t].apply(n, e);
      }
      function G_(n) {
        var t = {};
        n.registerClass = function(i) {
          var r = i.type || i.prototype.type;
          if (r) {
            Zmt(r), i.prototype.type = r;
            var a = Ro(r);
            if (!a.sub) t[a.main], t[a.main] = i;
            else if (a.sub !== ph) {
              var o = e(a);
              o[a.sub] = i;
            }
          }
          return i;
        }, n.getClass = function(i, r, a) {
          var o = t[i];
          if (o && o[ph] && (o = r ? o[r] : null), a && !o) throw new Error(r ? "Component " + i + "." + (r || "") + " is used but not imported." : i + ".type should be specified.");
          return o;
        }, n.getClassesByMainType = function(i) {
          var r = Ro(i), a = [], o = t[r.main];
          return o && o[ph] ? M(o, function(s, l) {
            l !== ph && a.push(s);
          }) : a.push(o), a;
        }, n.hasClass = function(i) {
          var r = Ro(i);
          return !!t[r.main];
        }, n.getAllClassMainTypes = function() {
          var i = [];
          return M(t, function(r, a) {
            i.push(a);
          }), i;
        }, n.hasSubTypes = function(i) {
          var r = Ro(i), a = t[r.main];
          return a && a[ph];
        };
        function e(i) {
          var r = t[i.main];
          return (!r || !r[ph]) && (r = t[i.main] = {}, r[ph] = true), r;
        }
      }
      function vh(n, t) {
        for (var e = 0; e < n.length; e++) n[e][1] || (n[e][1] = n[e][0]);
        return t = t || false, function(i, r, a) {
          for (var o = {}, s = 0; s < n.length; s++) {
            var l = n[s][1];
            if (!(r && Wt(r, l) >= 0 || a && Wt(a, l) < 0)) {
              var u = i.getShallow(l, t);
              u != null && (o[n[s][0]] = u);
            }
          }
          return o;
        };
      }
      var i_t = [["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["opacity"], ["shadowColor"]], r_t = vh(i_t), a_t = function() {
        function n() {
        }
        return n.prototype.getAreaStyle = function(t, e) {
          return r_t(this, t, e);
        }, n;
      }(), y2 = new yp(50);
      function o_t(n) {
        if (typeof n == "string") {
          var t = y2.get(n);
          return t && t.image;
        } else return n;
      }
      function m2(n, t, e, i, r) {
        if (n) if (typeof n == "string") {
          if (t && t.__zrImageSrc === n || !e) return t;
          var a = y2.get(n), o = { hostEl: e, cb: i, cbPayload: r };
          return a ? (t = a.image, !U_(t) && a.pending.push(o)) : (t = Ol.loadImage(n, YG, YG), t.__zrImageSrc = n, y2.put(n, t.__cachedImgObj = { image: t, pending: [o] })), t;
        } else return n;
        else return t;
      }
      function YG() {
        var n = this.__cachedImgObj;
        this.onload = this.onerror = this.__cachedImgObj = null;
        for (var t = 0; t < n.pending.length; t++) {
          var e = n.pending[t], i = e.cb;
          i && i(this, e.cbPayload), e.hostEl.dirty();
        }
        n.pending.length = 0;
      }
      function U_(n) {
        return n && n.width && n.height;
      }
      var _2 = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
      function s_t(n, t, e, i, r) {
        if (!t) return "";
        var a = (n + "").split(`
`);
        r = WG(t, e, i, r);
        for (var o = 0, s = a.length; o < s; o++) a[o] = XG(a[o], r);
        return a.join(`
`);
      }
      function WG(n, t, e, i) {
        i = i || {};
        var r = Y({}, i);
        r.font = t, e = Pt(e, "..."), r.maxIterations = Pt(i.maxIterations, 2);
        var a = r.minChar = Pt(i.minChar, 0);
        r.cnCharWidth = zr("", t);
        var o = r.ascCharWidth = zr("a", t);
        r.placeholder = Pt(i.placeholder, "");
        for (var s = n = Math.max(0, n - 1), l = 0; l < a && s >= o; l++) s -= o;
        var u = zr(e, t);
        return u > s && (e = "", u = 0), s = n - u, r.ellipsis = e, r.ellipsisWidth = u, r.contentWidth = s, r.containerWidth = n, r;
      }
      function XG(n, t) {
        var e = t.containerWidth, i = t.font, r = t.contentWidth;
        if (!e) return "";
        var a = zr(n, i);
        if (a <= e) return n;
        for (var o = 0; ; o++) {
          if (a <= r || o >= t.maxIterations) {
            n += t.ellipsis;
            break;
          }
          var s = o === 0 ? l_t(n, r, t.ascCharWidth, t.cnCharWidth) : a > 0 ? Math.floor(n.length * r / a) : 0;
          n = n.substr(0, s), a = zr(n, i);
        }
        return n === "" && (n = t.placeholder), n;
      }
      function l_t(n, t, e, i) {
        for (var r = 0, a = 0, o = n.length; a < o && r < t; a++) {
          var s = n.charCodeAt(a);
          r += 0 <= s && s <= 127 ? e : i;
        }
        return a;
      }
      function u_t(n, t) {
        n != null && (n += "");
        var e = t.overflow, i = t.padding, r = t.font, a = e === "truncate", o = k_(r), s = Pt(t.lineHeight, o), l = !!t.backgroundColor, u = t.lineOverflow === "truncate", h = t.width, c;
        h != null && (e === "break" || e === "breakAll") ? c = n ? KG(n, t.font, h, e === "breakAll", 0).lines : [] : c = n ? n.split(`
`) : [];
        var f = c.length * s, g = Pt(t.height, f);
        if (f > g && u) {
          var d = Math.floor(g / s);
          c = c.slice(0, d);
        }
        if (n && a && h != null) for (var A = WG(h, r, t.ellipsis, { minChar: t.truncateMinChar, placeholder: t.placeholder }), p = 0; p < c.length; p++) c[p] = XG(c[p], A);
        for (var v = g, y = 0, p = 0; p < c.length; p++) y = Math.max(zr(c[p], r), y);
        h == null && (h = y);
        var m = y;
        return i && (v += i[0] + i[2], m += i[1] + i[3], h += i[1] + i[3]), l && (m = h), { lines: c, height: g, outerWidth: m, outerHeight: v, lineHeight: s, calculatedLineHeight: o, contentWidth: y, contentHeight: f, width: h };
      }
      var h_t = /* @__PURE__ */ function() {
        function n() {
        }
        return n;
      }(), ZG = /* @__PURE__ */ function() {
        function n(t) {
          this.tokens = [], t && (this.tokens = t);
        }
        return n;
      }(), c_t = /* @__PURE__ */ function() {
        function n() {
          this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [];
        }
        return n;
      }();
      function f_t(n, t) {
        var e = new c_t();
        if (n != null && (n += ""), !n) return e;
        for (var i = t.width, r = t.height, a = t.overflow, o = (a === "break" || a === "breakAll") && i != null ? { width: i, accumWidth: 0, breakAll: a === "breakAll" } : null, s = _2.lastIndex = 0, l; (l = _2.exec(n)) != null; ) {
          var u = l.index;
          u > s && I2(e, n.substring(s, u), t, o), I2(e, l[2], t, o, l[1]), s = _2.lastIndex;
        }
        s < n.length && I2(e, n.substring(s, n.length), t, o);
        var h = [], c = 0, f = 0, g = t.padding, d = a === "truncate", A = t.lineOverflow === "truncate";
        function p(P, F, Q) {
          P.width = F, P.lineHeight = Q, c += Q, f = Math.max(f, F);
        }
        t: for (var v = 0; v < e.lines.length; v++) {
          for (var y = e.lines[v], m = 0, _ = 0, E = 0; E < y.tokens.length; E++) {
            var I = y.tokens[E], x = I.styleName && t.rich[I.styleName] || {}, w = I.textPadding = x.padding, C = w ? w[1] + w[3] : 0, S = I.font = x.font || t.font;
            I.contentHeight = k_(S);
            var b = Pt(x.height, I.contentHeight);
            if (I.innerHeight = b, w && (b += w[0] + w[2]), I.height = b, I.lineHeight = ra(x.lineHeight, t.lineHeight, b), I.align = x && x.align || t.align, I.verticalAlign = x && x.verticalAlign || "middle", A && r != null && c + I.lineHeight > r) {
              E > 0 ? (y.tokens = y.tokens.slice(0, E), p(y, _, m), e.lines = e.lines.slice(0, v + 1)) : e.lines = e.lines.slice(0, v);
              break t;
            }
            var B = x.width, T = B == null || B === "auto";
            if (typeof B == "string" && B.charAt(B.length - 1) === "%") I.percentWidth = B, h.push(I), I.contentWidth = zr(I.text, S);
            else {
              if (T) {
                var D = x.backgroundColor, R = D && D.image;
                R && (R = o_t(R), U_(R) && (I.width = Math.max(I.width, R.width * b / R.height)));
              }
              var L = d && i != null ? i - _ : null;
              L != null && L < I.width ? !T || L < C ? (I.text = "", I.width = I.contentWidth = 0) : (I.text = s_t(I.text, L - C, S, t.ellipsis, { minChar: t.truncateMinChar }), I.width = I.contentWidth = zr(I.text, S)) : I.contentWidth = zr(I.text, S);
            }
            I.width += C, _ += I.width, x && (m = Math.max(m, I.lineHeight));
          }
          p(y, _, m);
        }
        e.outerWidth = e.width = Pt(i, f), e.outerHeight = e.height = Pt(r, c), e.contentHeight = c, e.contentWidth = f, g && (e.outerWidth += g[1] + g[3], e.outerHeight += g[0] + g[2]);
        for (var v = 0; v < h.length; v++) {
          var I = h[v], k = I.percentWidth;
          I.width = parseInt(k, 10) / 100 * e.width;
        }
        return e;
      }
      function I2(n, t, e, i, r) {
        var a = t === "", o = r && e.rich[r] || {}, s = n.lines, l = o.font || e.font, u = false, h, c;
        if (i) {
          var f = o.padding, g = f ? f[1] + f[3] : 0;
          if (o.width != null && o.width !== "auto") {
            var d = ja(o.width, i.width) + g;
            s.length > 0 && d + i.accumWidth > i.width && (h = t.split(`
`), u = true), i.accumWidth = d;
          } else {
            var A = KG(t, l, i.width, i.breakAll, i.accumWidth);
            i.accumWidth = A.accumWidth + g, c = A.linesWidths, h = A.lines;
          }
        } else h = t.split(`
`);
        for (var p = 0; p < h.length; p++) {
          var v = h[p], y = new h_t();
          if (y.styleName = r, y.text = v, y.isLineHolder = !v && !a, typeof o.width == "number" ? y.width = o.width : y.width = c ? c[p] : zr(v, l), !p && !u) {
            var m = (s[s.length - 1] || (s[0] = new ZG())).tokens, _ = m.length;
            _ === 1 && m[0].isLineHolder ? m[0] = y : (v || !_ || a) && m.push(y);
          } else s.push(new ZG([y]));
        }
      }
      function g_t(n) {
        var t = n.charCodeAt(0);
        return t >= 32 && t <= 591 || t >= 880 && t <= 4351 || t >= 4608 && t <= 5119 || t >= 7680 && t <= 8303;
      }
      var d_t = So(",&?/;] ".split(""), function(n, t) {
        return n[t] = true, n;
      }, {});
      function A_t(n) {
        return g_t(n) ? !!d_t[n] : true;
      }
      function KG(n, t, e, i, r) {
        for (var a = [], o = [], s = "", l = "", u = 0, h = 0, c = 0; c < n.length; c++) {
          var f = n.charAt(c);
          if (f === `
`) {
            l && (s += l, h += u), a.push(s), o.push(h), s = "", l = "", u = 0, h = 0;
            continue;
          }
          var g = zr(f, t), d = i ? false : !A_t(f);
          if (a.length ? h + g > e : r + h + g > e) {
            h ? (s || l) && (d ? (s || (s = l, l = "", u = 0, h = u), a.push(s), o.push(h - u), l += f, u += g, s = "", h = u) : (l && (s += l, l = "", u = 0), a.push(s), o.push(h), s = f, h = g)) : d ? (a.push(l), o.push(u), l = f, u = g) : (a.push(f), o.push(g));
            continue;
          }
          h += g, d ? (l += f, u += g) : (l && (s += l, l = "", u = 0), s += f);
        }
        return !a.length && !s && (s = n, l = "", u = 0), l && (s += l), s && (a.push(s), o.push(h)), a.length === 1 && (h += r), { accumWidth: h, lines: a, linesWidths: o };
      }
      var E2 = "__zr_style_" + Math.round(Math.random() * 10), yh = { shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, shadowColor: "#000", opacity: 1, blend: "source-over" }, V_ = { style: { shadowBlur: true, shadowOffsetX: true, shadowOffsetY: true, shadowColor: true, opacity: true } };
      yh[E2] = true;
      var $G = ["z", "z2", "invisible"], p_t = ["invisible"], ha = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype._init = function(e) {
          for (var i = re(e), r = 0; r < i.length; r++) {
            var a = i[r];
            a === "style" ? this.useStyle(e[a]) : n.prototype.attrKV.call(this, a, e[a]);
          }
          this.style || this.useStyle({});
        }, t.prototype.beforeBrush = function() {
        }, t.prototype.afterBrush = function() {
        }, t.prototype.innerBeforeBrush = function() {
        }, t.prototype.innerAfterBrush = function() {
        }, t.prototype.shouldBePainted = function(e, i, r, a) {
          var o = this.transform;
          if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && v_t(this, e, i) || o && !o[0] && !o[3]) return false;
          if (r && this.__clipPaths) {
            for (var s = 0; s < this.__clipPaths.length; ++s) if (this.__clipPaths[s].isZeroArea()) return false;
          }
          if (a && this.parent) for (var l = this.parent; l; ) {
            if (l.ignore) return false;
            l = l.parent;
          }
          return true;
        }, t.prototype.contain = function(e, i) {
          return this.rectContain(e, i);
        }, t.prototype.traverse = function(e, i) {
          e.call(i, this);
        }, t.prototype.rectContain = function(e, i) {
          var r = this.transformCoordToLocal(e, i), a = this.getBoundingRect();
          return a.contain(r[0], r[1]);
        }, t.prototype.getPaintRect = function() {
          var e = this._paintRect;
          if (!this._paintRect || this.__dirty) {
            var i = this.transform, r = this.getBoundingRect(), a = this.style, o = a.shadowBlur || 0, s = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
            e = this._paintRect || (this._paintRect = new Ht(0, 0, 0, 0)), i ? Ht.applyTransform(e, r, i) : e.copy(r), (o || s || l) && (e.width += o * 2 + Math.abs(s), e.height += o * 2 + Math.abs(l), e.x = Math.min(e.x, e.x + s - o), e.y = Math.min(e.y, e.y + l - o));
            var u = this.dirtyRectTolerance;
            e.isZero() || (e.x = Math.floor(e.x - u), e.y = Math.floor(e.y - u), e.width = Math.ceil(e.width + 1 + u * 2), e.height = Math.ceil(e.height + 1 + u * 2));
          }
          return e;
        }, t.prototype.setPrevPaintRect = function(e) {
          e ? (this._prevPaintRect = this._prevPaintRect || new Ht(0, 0, 0, 0), this._prevPaintRect.copy(e)) : this._prevPaintRect = null;
        }, t.prototype.getPrevPaintRect = function() {
          return this._prevPaintRect;
        }, t.prototype.animateStyle = function(e) {
          return this.animate("style", e);
        }, t.prototype.updateDuringAnimation = function(e) {
          e === "style" ? this.dirtyStyle() : this.markRedraw();
        }, t.prototype.attrKV = function(e, i) {
          e !== "style" ? n.prototype.attrKV.call(this, e, i) : this.style ? this.setStyle(i) : this.useStyle(i);
        }, t.prototype.setStyle = function(e, i) {
          return typeof e == "string" ? this.style[e] = i : Y(this.style, e), this.dirtyStyle(), this;
        }, t.prototype.dirtyStyle = function(e) {
          e || this.markRedraw(), this.__dirty |= Ap, this._rect && (this._rect = null);
        }, t.prototype.dirty = function() {
          this.dirtyStyle();
        }, t.prototype.styleChanged = function() {
          return !!(this.__dirty & Ap);
        }, t.prototype.styleUpdated = function() {
          this.__dirty &= ~Ap;
        }, t.prototype.createStyle = function(e) {
          return h_(yh, e);
        }, t.prototype.useStyle = function(e) {
          e[E2] || (e = this.createStyle(e)), this.__inHover ? this.__hoverStyle = e : this.style = e, this.dirtyStyle();
        }, t.prototype.isStyleObject = function(e) {
          return e[E2];
        }, t.prototype._innerSaveToNormal = function(e) {
          n.prototype._innerSaveToNormal.call(this, e);
          var i = this._normalState;
          e.style && !i.style && (i.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(e, i, $G);
        }, t.prototype._applyStateObj = function(e, i, r, a, o, s) {
          n.prototype._applyStateObj.call(this, e, i, r, a, o, s);
          var l = !(i && a), u;
          if (i && i.style ? o ? a ? u = i.style : (u = this._mergeStyle(this.createStyle(), r.style), this._mergeStyle(u, i.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : r.style), this._mergeStyle(u, i.style)) : l && (u = r.style), u) if (o) {
            var h = this.style;
            if (this.style = this.createStyle(l ? {} : h), l) for (var c = re(h), f = 0; f < c.length; f++) {
              var g = c[f];
              g in u && (u[g] = u[g], this.style[g] = h[g]);
            }
            for (var d = re(u), f = 0; f < d.length; f++) {
              var g = d[f];
              this.style[g] = this.style[g];
            }
            this._transitionState(e, { style: u }, s, this.getAnimationStyleProps());
          } else this.useStyle(u);
          for (var A = this.__inHover ? p_t : $G, f = 0; f < A.length; f++) {
            var g = A[f];
            i && i[g] != null ? this[g] = i[g] : l && r[g] != null && (this[g] = r[g]);
          }
        }, t.prototype._mergeStates = function(e) {
          for (var i = n.prototype._mergeStates.call(this, e), r, a = 0; a < e.length; a++) {
            var o = e[a];
            o.style && (r = r || {}, this._mergeStyle(r, o.style));
          }
          return r && (i.style = r), i;
        }, t.prototype._mergeStyle = function(e, i) {
          return Y(e, i), e;
        }, t.prototype.getAnimationStyleProps = function() {
          return V_;
        }, t.initDefaultProps = function() {
          var e = t.prototype;
          e.type = "displayable", e.invisible = false, e.z = 0, e.z2 = 0, e.zlevel = 0, e.culling = false, e.cursor = "pointer", e.rectHover = false, e.incremental = false, e._rect = null, e.dirtyRectTolerance = 0, e.__dirty = Qr | Ap;
        }(), t;
      }(Q_), x2 = new Ht(0, 0, 0, 0), w2 = new Ht(0, 0, 0, 0);
      function v_t(n, t, e) {
        return x2.copy(n.getBoundingRect()), n.transform && x2.applyTransform(n.transform), w2.width = t, w2.height = e, !x2.intersect(w2);
      }
      var yr = Math.min, mr = Math.max, C2 = Math.sin, S2 = Math.cos, mh = Math.PI * 2, j_ = ih(), q_ = ih(), H_ = ih();
      function Y_(n, t, e) {
        if (n.length !== 0) {
          for (var i = n[0], r = i[0], a = i[0], o = i[1], s = i[1], l = 1; l < n.length; l++) i = n[l], r = yr(r, i[0]), a = mr(a, i[0]), o = yr(o, i[1]), s = mr(s, i[1]);
          t[0] = r, t[1] = o, e[0] = a, e[1] = s;
        }
      }
      function JG(n, t, e, i, r, a) {
        r[0] = yr(n, e), r[1] = yr(t, i), a[0] = mr(n, e), a[1] = mr(t, i);
      }
      var t5 = [], e5 = [];
      function y_t(n, t, e, i, r, a, o, s, l, u) {
        var h = Hz, c = Yn, f = h(n, e, r, o, t5);
        l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
        for (var g = 0; g < f; g++) {
          var d = c(n, e, r, o, t5[g]);
          l[0] = yr(d, l[0]), u[0] = mr(d, u[0]);
        }
        f = h(t, i, a, s, e5);
        for (var g = 0; g < f; g++) {
          var A = c(t, i, a, s, e5[g]);
          l[1] = yr(A, l[1]), u[1] = mr(A, u[1]);
        }
        l[0] = yr(n, l[0]), u[0] = mr(n, u[0]), l[0] = yr(o, l[0]), u[0] = mr(o, u[0]), l[1] = yr(t, l[1]), u[1] = mr(t, u[1]), l[1] = yr(s, l[1]), u[1] = mr(s, u[1]);
      }
      function m_t(n, t, e, i, r, a, o, s) {
        var l = Wz, u = si, h = mr(yr(l(n, e, r), 1), 0), c = mr(yr(l(t, i, a), 1), 0), f = u(n, e, r, h), g = u(t, i, a, c);
        o[0] = yr(n, r, f), o[1] = yr(t, a, g), s[0] = mr(n, r, f), s[1] = mr(t, a, g);
      }
      function __t(n, t, e, i, r, a, o, s, l) {
        var u = Gl, h = Ul, c = Math.abs(r - a);
        if (c % mh < 1e-4 && c > 1e-4) {
          s[0] = n - e, s[1] = t - i, l[0] = n + e, l[1] = t + i;
          return;
        }
        if (j_[0] = S2(r) * e + n, j_[1] = C2(r) * i + t, q_[0] = S2(a) * e + n, q_[1] = C2(a) * i + t, u(s, j_, q_), h(l, j_, q_), r = r % mh, r < 0 && (r = r + mh), a = a % mh, a < 0 && (a = a + mh), r > a && !o ? a += mh : r < a && o && (r += mh), o) {
          var f = a;
          a = r, r = f;
        }
        for (var g = 0; g < a; g += Math.PI / 2) g > r && (H_[0] = S2(g) * e + n, H_[1] = C2(g) * i + t, u(s, H_, s), h(l, H_, l));
      }
      var Xe = { M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7 }, _h = [], Ih = [], Lo = [], Wl = [], Po = [], No = [], b2 = Math.min, B2 = Math.max, Eh = Math.cos, xh = Math.sin, Ds = Math.abs, T2 = Math.PI, Xl = T2 * 2, M2 = typeof Float32Array != "undefined", Rp = [];
      function D2(n) {
        var t = Math.round(n / T2 * 1e8) / 1e8;
        return t % 2 * T2;
      }
      function R2(n, t) {
        var e = D2(n[0]);
        e < 0 && (e += Xl);
        var i = e - n[0], r = n[1];
        r += i, !t && r - e >= Xl ? r = e + Xl : t && e - r >= Xl ? r = e - Xl : !t && e > r ? r = e + (Xl - D2(e - r)) : t && e < r && (r = e - (Xl - D2(r - e))), n[0] = e, n[1] = r;
      }
      var ko = function() {
        function n(t) {
          this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, t && (this._saveData = false), this._saveData && (this.data = []);
        }
        return n.prototype.increaseVersion = function() {
          this._version++;
        }, n.prototype.getVersion = function() {
          return this._version;
        }, n.prototype.setScale = function(t, e, i) {
          i = i || 0, i > 0 && (this._ux = Ds(i / N_ / t) || 0, this._uy = Ds(i / N_ / e) || 0);
        }, n.prototype.setDPR = function(t) {
          this.dpr = t;
        }, n.prototype.setContext = function(t) {
          this._ctx = t;
        }, n.prototype.getContext = function() {
          return this._ctx;
        }, n.prototype.beginPath = function() {
          return this._ctx && this._ctx.beginPath(), this.reset(), this;
        }, n.prototype.reset = function() {
          this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
        }, n.prototype.moveTo = function(t, e) {
          return this._drawPendingPt(), this.addData(Xe.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this;
        }, n.prototype.lineTo = function(t, e) {
          var i = Ds(t - this._xi), r = Ds(e - this._yi), a = i > this._ux || r > this._uy;
          if (this.addData(Xe.L, t, e), this._ctx && a && this._ctx.lineTo(t, e), a) this._xi = t, this._yi = e, this._pendingPtDist = 0;
          else {
            var o = i * i + r * r;
            o > this._pendingPtDist && (this._pendingPtX = t, this._pendingPtY = e, this._pendingPtDist = o);
          }
          return this;
        }, n.prototype.bezierCurveTo = function(t, e, i, r, a, o) {
          return this._drawPendingPt(), this.addData(Xe.C, t, e, i, r, a, o), this._ctx && this._ctx.bezierCurveTo(t, e, i, r, a, o), this._xi = a, this._yi = o, this;
        }, n.prototype.quadraticCurveTo = function(t, e, i, r) {
          return this._drawPendingPt(), this.addData(Xe.Q, t, e, i, r), this._ctx && this._ctx.quadraticCurveTo(t, e, i, r), this._xi = i, this._yi = r, this;
        }, n.prototype.arc = function(t, e, i, r, a, o) {
          this._drawPendingPt(), Rp[0] = r, Rp[1] = a, R2(Rp, o), r = Rp[0], a = Rp[1];
          var s = a - r;
          return this.addData(Xe.A, t, e, i, i, r, s, 0, o ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, r, a, o), this._xi = Eh(a) * i + t, this._yi = xh(a) * i + e, this;
        }, n.prototype.arcTo = function(t, e, i, r, a) {
          return this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, e, i, r, a), this;
        }, n.prototype.rect = function(t, e, i, r) {
          return this._drawPendingPt(), this._ctx && this._ctx.rect(t, e, i, r), this.addData(Xe.R, t, e, i, r), this;
        }, n.prototype.closePath = function() {
          this._drawPendingPt(), this.addData(Xe.Z);
          var t = this._ctx, e = this._x0, i = this._y0;
          return t && t.closePath(), this._xi = e, this._yi = i, this;
        }, n.prototype.fill = function(t) {
          t && t.fill(), this.toStatic();
        }, n.prototype.stroke = function(t) {
          t && t.stroke(), this.toStatic();
        }, n.prototype.len = function() {
          return this._len;
        }, n.prototype.setData = function(t) {
          var e = t.length;
          !(this.data && this.data.length === e) && M2 && (this.data = new Float32Array(e));
          for (var i = 0; i < e; i++) this.data[i] = t[i];
          this._len = e;
        }, n.prototype.appendPath = function(t) {
          t instanceof Array || (t = [t]);
          for (var e = t.length, i = 0, r = this._len, a = 0; a < e; a++) i += t[a].len();
          M2 && this.data instanceof Float32Array && (this.data = new Float32Array(r + i));
          for (var a = 0; a < e; a++) for (var o = t[a].data, s = 0; s < o.length; s++) this.data[r++] = o[s];
          this._len = r;
        }, n.prototype.addData = function(t, e, i, r, a, o, s, l, u) {
          if (this._saveData) {
            var h = this.data;
            this._len + arguments.length > h.length && (this._expandData(), h = this.data);
            for (var c = 0; c < arguments.length; c++) h[this._len++] = arguments[c];
          }
        }, n.prototype._drawPendingPt = function() {
          this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
        }, n.prototype._expandData = function() {
          if (!(this.data instanceof Array)) {
            for (var t = [], e = 0; e < this._len; e++) t[e] = this.data[e];
            this.data = t;
          }
        }, n.prototype.toStatic = function() {
          if (this._saveData) {
            this._drawPendingPt();
            var t = this.data;
            t instanceof Array && (t.length = this._len, M2 && this._len > 11 && (this.data = new Float32Array(t)));
          }
        }, n.prototype.getBoundingRect = function() {
          Lo[0] = Lo[1] = Po[0] = Po[1] = Number.MAX_VALUE, Wl[0] = Wl[1] = No[0] = No[1] = -Number.MAX_VALUE;
          var t = this.data, e = 0, i = 0, r = 0, a = 0, o;
          for (o = 0; o < this._len; ) {
            var s = t[o++], l = o === 1;
            switch (l && (e = t[o], i = t[o + 1], r = e, a = i), s) {
              case Xe.M:
                e = r = t[o++], i = a = t[o++], Po[0] = r, Po[1] = a, No[0] = r, No[1] = a;
                break;
              case Xe.L:
                JG(e, i, t[o], t[o + 1], Po, No), e = t[o++], i = t[o++];
                break;
              case Xe.C:
                y_t(e, i, t[o++], t[o++], t[o++], t[o++], t[o], t[o + 1], Po, No), e = t[o++], i = t[o++];
                break;
              case Xe.Q:
                m_t(e, i, t[o++], t[o++], t[o], t[o + 1], Po, No), e = t[o++], i = t[o++];
                break;
              case Xe.A:
                var u = t[o++], h = t[o++], c = t[o++], f = t[o++], g = t[o++], d = t[o++] + g;
                o += 1;
                var A = !t[o++];
                l && (r = Eh(g) * c + u, a = xh(g) * f + h), __t(u, h, c, f, g, d, A, Po, No), e = Eh(d) * c + u, i = xh(d) * f + h;
                break;
              case Xe.R:
                r = e = t[o++], a = i = t[o++];
                var p = t[o++], v = t[o++];
                JG(r, a, r + p, a + v, Po, No);
                break;
              case Xe.Z:
                e = r, i = a;
                break;
            }
            Gl(Lo, Lo, Po), Ul(Wl, Wl, No);
          }
          return o === 0 && (Lo[0] = Lo[1] = Wl[0] = Wl[1] = 0), new Ht(Lo[0], Lo[1], Wl[0] - Lo[0], Wl[1] - Lo[1]);
        }, n.prototype._calculateLength = function() {
          var t = this.data, e = this._len, i = this._ux, r = this._uy, a = 0, o = 0, s = 0, l = 0;
          this._pathSegLen || (this._pathSegLen = []);
          for (var u = this._pathSegLen, h = 0, c = 0, f = 0; f < e; ) {
            var g = t[f++], d = f === 1;
            d && (a = t[f], o = t[f + 1], s = a, l = o);
            var A = -1;
            switch (g) {
              case Xe.M:
                a = s = t[f++], o = l = t[f++];
                break;
              case Xe.L: {
                var p = t[f++], v = t[f++], y = p - a, m = v - o;
                (Ds(y) > i || Ds(m) > r || f === e - 1) && (A = Math.sqrt(y * y + m * m), a = p, o = v);
                break;
              }
              case Xe.C: {
                var _ = t[f++], E = t[f++], p = t[f++], v = t[f++], I = t[f++], x = t[f++];
                A = O0t(a, o, _, E, p, v, I, x, 10), a = I, o = x;
                break;
              }
              case Xe.Q: {
                var _ = t[f++], E = t[f++], p = t[f++], v = t[f++];
                A = G0t(a, o, _, E, p, v, 10), a = p, o = v;
                break;
              }
              case Xe.A:
                var w = t[f++], C = t[f++], S = t[f++], b = t[f++], B = t[f++], T = t[f++], D = T + B;
                f += 1, d && (s = Eh(B) * S + w, l = xh(B) * b + C), A = B2(S, b) * b2(Xl, Math.abs(T)), a = Eh(D) * S + w, o = xh(D) * b + C;
                break;
              case Xe.R: {
                s = a = t[f++], l = o = t[f++];
                var R = t[f++], L = t[f++];
                A = R * 2 + L * 2;
                break;
              }
              case Xe.Z: {
                var y = s - a, m = l - o;
                A = Math.sqrt(y * y + m * m), a = s, o = l;
                break;
              }
            }
            A >= 0 && (u[c++] = A, h += A);
          }
          return this._pathLen = h, h;
        }, n.prototype.rebuildPath = function(t, e) {
          var i = this.data, r = this._ux, a = this._uy, o = this._len, s, l, u, h, c, f, g = e < 1, d, A, p = 0, v = 0, y, m = 0, _, E;
          if (!(g && (this._pathSegLen || this._calculateLength(), d = this._pathSegLen, A = this._pathLen, y = e * A, !y))) t: for (var I = 0; I < o; ) {
            var x = i[I++], w = I === 1;
            switch (w && (u = i[I], h = i[I + 1], s = u, l = h), x !== Xe.L && m > 0 && (t.lineTo(_, E), m = 0), x) {
              case Xe.M:
                s = u = i[I++], l = h = i[I++], t.moveTo(u, h);
                break;
              case Xe.L: {
                c = i[I++], f = i[I++];
                var C = Ds(c - u), S = Ds(f - h);
                if (C > r || S > a) {
                  if (g) {
                    var b = d[v++];
                    if (p + b > y) {
                      var B = (y - p) / b;
                      t.lineTo(u * (1 - B) + c * B, h * (1 - B) + f * B);
                      break t;
                    }
                    p += b;
                  }
                  t.lineTo(c, f), u = c, h = f, m = 0;
                } else {
                  var T = C * C + S * S;
                  T > m && (_ = c, E = f, m = T);
                }
                break;
              }
              case Xe.C: {
                var D = i[I++], R = i[I++], L = i[I++], k = i[I++], P = i[I++], F = i[I++];
                if (g) {
                  var b = d[v++];
                  if (p + b > y) {
                    var B = (y - p) / b;
                    ql(u, D, L, P, B, _h), ql(h, R, k, F, B, Ih), t.bezierCurveTo(_h[1], Ih[1], _h[2], Ih[2], _h[3], Ih[3]);
                    break t;
                  }
                  p += b;
                }
                t.bezierCurveTo(D, R, L, k, P, F), u = P, h = F;
                break;
              }
              case Xe.Q: {
                var D = i[I++], R = i[I++], L = i[I++], k = i[I++];
                if (g) {
                  var b = d[v++];
                  if (p + b > y) {
                    var B = (y - p) / b;
                    vp(u, D, L, B, _h), vp(h, R, k, B, Ih), t.quadraticCurveTo(_h[1], Ih[1], _h[2], Ih[2]);
                    break t;
                  }
                  p += b;
                }
                t.quadraticCurveTo(D, R, L, k), u = L, h = k;
                break;
              }
              case Xe.A:
                var Q = i[I++], z = i[I++], j = i[I++], $ = i[I++], G = i[I++], tt = i[I++], J = i[I++], et = !i[I++], nt = j > $ ? j : $, gt = Ds(j - $) > 1e-3, H = G + tt, W = false;
                if (g) {
                  var b = d[v++];
                  p + b > y && (H = G + tt * (y - p) / b, W = true), p += b;
                }
                if (gt && t.ellipse ? t.ellipse(Q, z, j, $, J, G, H, et) : t.arc(Q, z, nt, G, H, et), W) break t;
                w && (s = Eh(G) * j + Q, l = xh(G) * $ + z), u = Eh(H) * j + Q, h = xh(H) * $ + z;
                break;
              case Xe.R:
                s = u = i[I], l = h = i[I + 1], c = i[I++], f = i[I++];
                var it = i[I++], kt = i[I++];
                if (g) {
                  var b = d[v++];
                  if (p + b > y) {
                    var vt = y - p;
                    t.moveTo(c, f), t.lineTo(c + b2(vt, it), f), vt -= it, vt > 0 && t.lineTo(c + it, f + b2(vt, kt)), vt -= kt, vt > 0 && t.lineTo(c + B2(it - vt, 0), f + kt), vt -= it, vt > 0 && t.lineTo(c, f + B2(kt - vt, 0));
                    break t;
                  }
                  p += b;
                }
                t.rect(c, f, it, kt);
                break;
              case Xe.Z:
                if (g) {
                  var b = d[v++];
                  if (p + b > y) {
                    var B = (y - p) / b;
                    t.lineTo(u * (1 - B) + s * B, h * (1 - B) + l * B);
                    break t;
                  }
                  p += b;
                }
                t.closePath(), u = s, h = l;
            }
          }
        }, n.prototype.clone = function() {
          var t = new n(), e = this.data;
          return t.data = e.slice ? e.slice() : Array.prototype.slice.call(e), t._len = this._len, t;
        }, n.CMD = Xe, n.initDefaultProps = function() {
          var t = n.prototype;
          t._saveData = true, t._ux = 0, t._uy = 0, t._pendingPtDist = 0, t._version = 0;
        }(), n;
      }();
      function Zl(n, t, e, i, r, a, o) {
        if (r === 0) return false;
        var s = r, l = 0, u = n;
        if (o > t + s && o > i + s || o < t - s && o < i - s || a > n + s && a > e + s || a < n - s && a < e - s) return false;
        if (n !== e) l = (t - i) / (n - e), u = (n * i - e * t) / (n - e);
        else return Math.abs(a - n) <= s / 2;
        var h = l * a - o + u, c = h * h / (l * l + 1);
        return c <= s / 2 * s / 2;
      }
      function I_t(n, t, e, i, r, a, o, s, l, u, h) {
        if (l === 0) return false;
        var c = l;
        if (h > t + c && h > i + c && h > a + c && h > s + c || h < t - c && h < i - c && h < a - c && h < s - c || u > n + c && u > e + c && u > r + c && u > o + c || u < n - c && u < e - c && u < r - c && u < o - c) return false;
        var f = Yz(n, t, e, i, r, a, o, s, u, h, null);
        return f <= c / 2;
      }
      function n5(n, t, e, i, r, a, o, s, l) {
        if (o === 0) return false;
        var u = o;
        if (l > t + u && l > i + u && l > a + u || l < t - u && l < i - u && l < a - u || s > n + u && s > e + u && s > r + u || s < n - u && s < e - u && s < r - u) return false;
        var h = Xz(n, t, e, i, r, a, s, l, null);
        return h <= u / 2;
      }
      var i5 = Math.PI * 2;
      function Gr(n) {
        return n %= i5, n < 0 && (n += i5), n;
      }
      var Lp = Math.PI * 2;
      function E_t(n, t, e, i, r, a, o, s, l) {
        if (o === 0) return false;
        var u = o;
        s -= n, l -= t;
        var h = Math.sqrt(s * s + l * l);
        if (h - u > e || h + u < e) return false;
        if (Math.abs(i - r) % Lp < 1e-4) return true;
        if (a) {
          var c = i;
          i = Gr(r), r = Gr(c);
        } else i = Gr(i), r = Gr(r);
        i > r && (r += Lp);
        var f = Math.atan2(l, s);
        return f < 0 && (f += Lp), f >= i && f <= r || f + Lp >= i && f + Lp <= r;
      }
      function Rs(n, t, e, i, r, a) {
        if (a > t && a > i || a < t && a < i || i === t) return 0;
        var o = (a - t) / (i - t), s = i < t ? 1 : -1;
        (o === 1 || o === 0) && (s = i < t ? 0.5 : -0.5);
        var l = o * (e - n) + n;
        return l === r ? 1 / 0 : l > r ? s : 0;
      }
      var Kl = ko.CMD, wh = Math.PI * 2, x_t = 1e-4;
      function w_t(n, t) {
        return Math.abs(n - t) < x_t;
      }
      var ji = [-1, -1, -1], ca = [-1, -1];
      function C_t() {
        var n = ca[0];
        ca[0] = ca[1], ca[1] = n;
      }
      function S_t(n, t, e, i, r, a, o, s, l, u) {
        if (u > t && u > i && u > a && u > s || u < t && u < i && u < a && u < s) return 0;
        var h = E_(t, i, a, s, u, ji);
        if (h === 0) return 0;
        for (var c = 0, f = -1, g = void 0, d = void 0, A = 0; A < h; A++) {
          var p = ji[A], v = p === 0 || p === 1 ? 0.5 : 1, y = Yn(n, e, r, o, p);
          y < l || (f < 0 && (f = Hz(t, i, a, s, ca), ca[1] < ca[0] && f > 1 && C_t(), g = Yn(t, i, a, s, ca[0]), f > 1 && (d = Yn(t, i, a, s, ca[1]))), f === 2 ? p < ca[0] ? c += g < t ? v : -v : p < ca[1] ? c += d < g ? v : -v : c += s < d ? v : -v : p < ca[0] ? c += g < t ? v : -v : c += s < g ? v : -v);
        }
        return c;
      }
      function b_t(n, t, e, i, r, a, o, s) {
        if (s > t && s > i && s > a || s < t && s < i && s < a) return 0;
        var l = z0t(t, i, a, s, ji);
        if (l === 0) return 0;
        var u = Wz(t, i, a);
        if (u >= 0 && u <= 1) {
          for (var h = 0, c = si(t, i, a, u), f = 0; f < l; f++) {
            var g = ji[f] === 0 || ji[f] === 1 ? 0.5 : 1, d = si(n, e, r, ji[f]);
            d < o || (ji[f] < u ? h += c < t ? g : -g : h += a < c ? g : -g);
          }
          return h;
        } else {
          var g = ji[0] === 0 || ji[0] === 1 ? 0.5 : 1, d = si(n, e, r, ji[0]);
          return d < o ? 0 : a < t ? g : -g;
        }
      }
      function B_t(n, t, e, i, r, a, o, s) {
        if (s -= t, s > e || s < -e) return 0;
        var l = Math.sqrt(e * e - s * s);
        ji[0] = -l, ji[1] = l;
        var u = Math.abs(i - r);
        if (u < 1e-4) return 0;
        if (u >= wh - 1e-4) {
          i = 0, r = wh;
          var h = a ? 1 : -1;
          return o >= ji[0] + n && o <= ji[1] + n ? h : 0;
        }
        if (i > r) {
          var c = i;
          i = r, r = c;
        }
        i < 0 && (i += wh, r += wh);
        for (var f = 0, g = 0; g < 2; g++) {
          var d = ji[g];
          if (d + n > o) {
            var A = Math.atan2(s, d), h = a ? 1 : -1;
            A < 0 && (A = wh + A), (A >= i && A <= r || A + wh >= i && A + wh <= r) && (A > Math.PI / 2 && A < Math.PI * 1.5 && (h = -h), f += h);
          }
        }
        return f;
      }
      function r5(n, t, e, i, r) {
        for (var a = n.data, o = n.len(), s = 0, l = 0, u = 0, h = 0, c = 0, f, g, d = 0; d < o; ) {
          var A = a[d++], p = d === 1;
          switch (A === Kl.M && d > 1 && (e || (s += Rs(l, u, h, c, i, r))), p && (l = a[d], u = a[d + 1], h = l, c = u), A) {
            case Kl.M:
              h = a[d++], c = a[d++], l = h, u = c;
              break;
            case Kl.L:
              if (e) {
                if (Zl(l, u, a[d], a[d + 1], t, i, r)) return true;
              } else s += Rs(l, u, a[d], a[d + 1], i, r) || 0;
              l = a[d++], u = a[d++];
              break;
            case Kl.C:
              if (e) {
                if (I_t(l, u, a[d++], a[d++], a[d++], a[d++], a[d], a[d + 1], t, i, r)) return true;
              } else s += S_t(l, u, a[d++], a[d++], a[d++], a[d++], a[d], a[d + 1], i, r) || 0;
              l = a[d++], u = a[d++];
              break;
            case Kl.Q:
              if (e) {
                if (n5(l, u, a[d++], a[d++], a[d], a[d + 1], t, i, r)) return true;
              } else s += b_t(l, u, a[d++], a[d++], a[d], a[d + 1], i, r) || 0;
              l = a[d++], u = a[d++];
              break;
            case Kl.A:
              var v = a[d++], y = a[d++], m = a[d++], _ = a[d++], E = a[d++], I = a[d++];
              d += 1;
              var x = !!(1 - a[d++]);
              f = Math.cos(E) * m + v, g = Math.sin(E) * _ + y, p ? (h = f, c = g) : s += Rs(l, u, f, g, i, r);
              var w = (i - v) * _ / m + v;
              if (e) {
                if (E_t(v, y, _, E, E + I, x, t, w, r)) return true;
              } else s += B_t(v, y, _, E, E + I, x, w, r);
              l = Math.cos(E + I) * m + v, u = Math.sin(E + I) * _ + y;
              break;
            case Kl.R:
              h = l = a[d++], c = u = a[d++];
              var C = a[d++], S = a[d++];
              if (f = h + C, g = c + S, e) {
                if (Zl(h, c, f, c, t, i, r) || Zl(f, c, f, g, t, i, r) || Zl(f, g, h, g, t, i, r) || Zl(h, g, h, c, t, i, r)) return true;
              } else s += Rs(f, c, f, g, i, r), s += Rs(h, g, h, c, i, r);
              break;
            case Kl.Z:
              if (e) {
                if (Zl(l, u, h, c, t, i, r)) return true;
              } else s += Rs(l, u, h, c, i, r);
              l = h, u = c;
              break;
          }
        }
        return !e && !w_t(u, c) && (s += Rs(l, u, h, c, i, r) || 0), s !== 0;
      }
      function T_t(n, t, e) {
        return r5(n, 0, false, t, e);
      }
      function M_t(n, t, e, i) {
        return r5(n, t, true, e, i);
      }
      var W_ = Et({ fill: "#000", stroke: null, strokePercent: 1, fillOpacity: 1, strokeOpacity: 1, lineDashOffset: 0, lineWidth: 1, lineCap: "butt", miterLimit: 10, strokeNoScale: false, strokeFirst: false }, yh), D_t = { style: Et({ fill: true, stroke: true, strokePercent: true, fillOpacity: true, strokeOpacity: true, lineDashOffset: true, lineWidth: true, miterLimit: true }, V_.style) }, L2 = To.concat(["invisible", "culling", "z", "z2", "zlevel", "parent"]), Jt = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.update = function() {
          var e = this;
          n.prototype.update.call(this);
          var i = this.style;
          if (i.decal) {
            var r = this._decalEl = this._decalEl || new t();
            r.buildPath === t.prototype.buildPath && (r.buildPath = function(l) {
              e.buildPath(l, e.shape);
            }), r.silent = true;
            var a = r.style;
            for (var o in i) a[o] !== i[o] && (a[o] = i[o]);
            a.fill = i.fill ? i.decal : null, a.decal = null, a.shadowColor = null, i.strokeFirst && (a.stroke = null);
            for (var s = 0; s < L2.length; ++s) r[L2[s]] = this[L2[s]];
            r.__dirty |= Qr;
          } else this._decalEl && (this._decalEl = null);
        }, t.prototype.getDecalElement = function() {
          return this._decalEl;
        }, t.prototype._init = function(e) {
          var i = re(e);
          this.shape = this.getDefaultShape();
          var r = this.getDefaultStyle();
          r && this.useStyle(r);
          for (var a = 0; a < i.length; a++) {
            var o = i[a], s = e[o];
            o === "style" ? this.style ? Y(this.style, s) : this.useStyle(s) : o === "shape" ? Y(this.shape, s) : n.prototype.attrKV.call(this, o, s);
          }
          this.style || this.useStyle({});
        }, t.prototype.getDefaultStyle = function() {
          return null;
        }, t.prototype.getDefaultShape = function() {
          return {};
        }, t.prototype.canBeInsideText = function() {
          return this.hasFill();
        }, t.prototype.getInsideTextFill = function() {
          var e = this.style.fill;
          if (e !== "none") {
            if (ht(e)) {
              var i = C_(e, 0);
              return i > 0.5 ? n2 : i > 0.2 ? dmt : i2;
            } else if (e) return i2;
          }
          return n2;
        }, t.prototype.getInsideTextStroke = function(e) {
          var i = this.style.fill;
          if (ht(i)) {
            var r = this.__zr, a = !!(r && r.isDarkMode()), o = C_(e, 0) < e2;
            if (a === o) return i;
          }
        }, t.prototype.buildPath = function(e, i, r) {
        }, t.prototype.pathUpdated = function() {
          this.__dirty &= ~ug;
        }, t.prototype.getUpdatedPathProxy = function(e) {
          return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, e), this.path;
        }, t.prototype.createPathProxy = function() {
          this.path = new ko(false);
        }, t.prototype.hasStroke = function() {
          var e = this.style, i = e.stroke;
          return !(i == null || i === "none" || !(e.lineWidth > 0));
        }, t.prototype.hasFill = function() {
          var e = this.style, i = e.fill;
          return i != null && i !== "none";
        }, t.prototype.getBoundingRect = function() {
          var e = this._rect, i = this.style, r = !e;
          if (r) {
            var a = false;
            this.path || (a = true, this.createPathProxy());
            var o = this.path;
            (a || this.__dirty & ug) && (o.beginPath(), this.buildPath(o, this.shape, false), this.pathUpdated()), e = o.getBoundingRect();
          }
          if (this._rect = e, this.hasStroke() && this.path && this.path.len() > 0) {
            var s = this._rectStroke || (this._rectStroke = e.clone());
            if (this.__dirty || r) {
              s.copy(e);
              var l = i.strokeNoScale ? this.getLineScale() : 1, u = i.lineWidth;
              if (!this.hasFill()) {
                var h = this.strokeContainThreshold;
                u = Math.max(u, h == null ? 4 : h);
              }
              l > 1e-10 && (s.width += u / l, s.height += u / l, s.x -= u / l / 2, s.y -= u / l / 2);
            }
            return s;
          }
          return e;
        }, t.prototype.contain = function(e, i) {
          var r = this.transformCoordToLocal(e, i), a = this.getBoundingRect(), o = this.style;
          if (e = r[0], i = r[1], a.contain(e, i)) {
            var s = this.path;
            if (this.hasStroke()) {
              var l = o.lineWidth, u = o.strokeNoScale ? this.getLineScale() : 1;
              if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), M_t(s, l / u, e, i))) return true;
            }
            if (this.hasFill()) return T_t(s, e, i);
          }
          return false;
        }, t.prototype.dirtyShape = function() {
          this.__dirty |= ug, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
        }, t.prototype.dirty = function() {
          this.dirtyStyle(), this.dirtyShape();
        }, t.prototype.animateShape = function(e) {
          return this.animate("shape", e);
        }, t.prototype.updateDuringAnimation = function(e) {
          e === "style" ? this.dirtyStyle() : e === "shape" ? this.dirtyShape() : this.markRedraw();
        }, t.prototype.attrKV = function(e, i) {
          e === "shape" ? this.setShape(i) : n.prototype.attrKV.call(this, e, i);
        }, t.prototype.setShape = function(e, i) {
          var r = this.shape;
          return r || (r = this.shape = {}), typeof e == "string" ? r[e] = i : Y(r, e), this.dirtyShape(), this;
        }, t.prototype.shapeChanged = function() {
          return !!(this.__dirty & ug);
        }, t.prototype.createStyle = function(e) {
          return h_(W_, e);
        }, t.prototype._innerSaveToNormal = function(e) {
          n.prototype._innerSaveToNormal.call(this, e);
          var i = this._normalState;
          e.shape && !i.shape && (i.shape = Y({}, this.shape));
        }, t.prototype._applyStateObj = function(e, i, r, a, o, s) {
          n.prototype._applyStateObj.call(this, e, i, r, a, o, s);
          var l = !(i && a), u;
          if (i && i.shape ? o ? a ? u = i.shape : (u = Y({}, r.shape), Y(u, i.shape)) : (u = Y({}, a ? this.shape : r.shape), Y(u, i.shape)) : l && (u = r.shape), u) if (o) {
            this.shape = Y({}, this.shape);
            for (var h = {}, c = re(u), f = 0; f < c.length; f++) {
              var g = c[f];
              typeof u[g] == "object" ? this.shape[g] = u[g] : h[g] = u[g];
            }
            this._transitionState(e, { shape: h }, s);
          } else this.shape = u, this.dirtyShape();
        }, t.prototype._mergeStates = function(e) {
          for (var i = n.prototype._mergeStates.call(this, e), r, a = 0; a < e.length; a++) {
            var o = e[a];
            o.shape && (r = r || {}, this._mergeStyle(r, o.shape));
          }
          return r && (i.shape = r), i;
        }, t.prototype.getAnimationStyleProps = function() {
          return D_t;
        }, t.prototype.isZeroArea = function() {
          return false;
        }, t.extend = function(e) {
          var i = function(a) {
            V(o, a);
            function o(s) {
              var l = a.call(this, s) || this;
              return e.init && e.init.call(l, s), l;
            }
            return o.prototype.getDefaultStyle = function() {
              return xt(e.style);
            }, o.prototype.getDefaultShape = function() {
              return xt(e.shape);
            }, o;
          }(t);
          for (var r in e) typeof e[r] == "function" && (i.prototype[r] = e[r]);
          return i;
        }, t.initDefaultProps = function() {
          var e = t.prototype;
          e.type = "path", e.strokeContainThreshold = 5, e.segmentIgnoreThreshold = 0, e.subPixelOptimize = false, e.autoBatch = false, e.__dirty = Qr | Ap | ug;
        }(), t;
      }(ha), R_t = Et({ strokeFirst: true, font: Ql, x: 0, y: 0, textAlign: "left", textBaseline: "top", miterLimit: 2 }, W_), yg = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.hasStroke = function() {
          var e = this.style, i = e.stroke;
          return i != null && i !== "none" && e.lineWidth > 0;
        }, t.prototype.hasFill = function() {
          var e = this.style, i = e.fill;
          return i != null && i !== "none";
        }, t.prototype.createStyle = function(e) {
          return h_(R_t, e);
        }, t.prototype.setBoundingRect = function(e) {
          this._rect = e;
        }, t.prototype.getBoundingRect = function() {
          var e = this.style;
          if (!this._rect) {
            var i = e.text;
            i != null ? i += "" : i = "";
            var r = Cp(i, e.font, e.textAlign, e.textBaseline);
            if (r.x += e.x || 0, r.y += e.y || 0, this.hasStroke()) {
              var a = e.lineWidth;
              r.x -= a / 2, r.y -= a / 2, r.width += a, r.height += a;
            }
            this._rect = r;
          }
          return this._rect;
        }, t.initDefaultProps = function() {
          var e = t.prototype;
          e.dirtyRectTolerance = 10;
        }(), t;
      }(ha);
      yg.prototype.type = "tspan";
      var L_t = Et({ x: 0, y: 0 }, yh), P_t = { style: Et({ x: true, y: true, width: true, height: true, sx: true, sy: true, sWidth: true, sHeight: true }, V_.style) };
      function N_t(n) {
        return !!(n && typeof n != "string" && n.width && n.height);
      }
      var li = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.createStyle = function(e) {
          return h_(L_t, e);
        }, t.prototype._getSize = function(e) {
          var i = this.style, r = i[e];
          if (r != null) return r;
          var a = N_t(i.image) ? i.image : this.__image;
          if (!a) return 0;
          var o = e === "width" ? "height" : "width", s = i[o];
          return s == null ? a[e] : a[e] / a[o] * s;
        }, t.prototype.getWidth = function() {
          return this._getSize("width");
        }, t.prototype.getHeight = function() {
          return this._getSize("height");
        }, t.prototype.getAnimationStyleProps = function() {
          return P_t;
        }, t.prototype.getBoundingRect = function() {
          var e = this.style;
          return this._rect || (this._rect = new Ht(e.x || 0, e.y || 0, this.getWidth(), this.getHeight())), this._rect;
        }, t;
      }(ha);
      li.prototype.type = "image";
      function k_t(n, t) {
        var e = t.x, i = t.y, r = t.width, a = t.height, o = t.r, s, l, u, h;
        r < 0 && (e = e + r, r = -r), a < 0 && (i = i + a, a = -a), typeof o == "number" ? s = l = u = h = o : o instanceof Array ? o.length === 1 ? s = l = u = h = o[0] : o.length === 2 ? (s = u = o[0], l = h = o[1]) : o.length === 3 ? (s = o[0], l = h = o[1], u = o[2]) : (s = o[0], l = o[1], u = o[2], h = o[3]) : s = l = u = h = 0;
        var c;
        s + l > r && (c = s + l, s *= r / c, l *= r / c), u + h > r && (c = u + h, u *= r / c, h *= r / c), l + u > a && (c = l + u, l *= a / c, u *= a / c), s + h > a && (c = s + h, s *= a / c, h *= a / c), n.moveTo(e + s, i), n.lineTo(e + r - l, i), l !== 0 && n.arc(e + r - l, i + l, l, -Math.PI / 2, 0), n.lineTo(e + r, i + a - u), u !== 0 && n.arc(e + r - u, i + a - u, u, 0, Math.PI / 2), n.lineTo(e + h, i + a), h !== 0 && n.arc(e + h, i + a - h, h, Math.PI / 2, Math.PI), n.lineTo(e, i + s), s !== 0 && n.arc(e + s, i + s, s, Math.PI, Math.PI * 1.5);
      }
      var mg = Math.round;
      function a5(n, t, e) {
        if (t) {
          var i = t.x1, r = t.x2, a = t.y1, o = t.y2;
          n.x1 = i, n.x2 = r, n.y1 = a, n.y2 = o;
          var s = e && e.lineWidth;
          return s && (mg(i * 2) === mg(r * 2) && (n.x1 = n.x2 = Ch(i, s, true)), mg(a * 2) === mg(o * 2) && (n.y1 = n.y2 = Ch(a, s, true))), n;
        }
      }
      function o5(n, t, e) {
        if (t) {
          var i = t.x, r = t.y, a = t.width, o = t.height;
          n.x = i, n.y = r, n.width = a, n.height = o;
          var s = e && e.lineWidth;
          return s && (n.x = Ch(i, s, true), n.y = Ch(r, s, true), n.width = Math.max(Ch(i + a, s, false) - n.x, a === 0 ? 0 : 1), n.height = Math.max(Ch(r + o, s, false) - n.y, o === 0 ? 0 : 1)), n;
        }
      }
      function Ch(n, t, e) {
        if (!t) return n;
        var i = mg(n * 2);
        return (i + mg(t)) % 2 === 0 ? i / 2 : (i + (e ? 1 : -1)) / 2;
      }
      var F_t = /* @__PURE__ */ function() {
        function n() {
          this.x = 0, this.y = 0, this.width = 0, this.height = 0;
        }
        return n;
      }(), Q_t = {}, ue = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultShape = function() {
          return new F_t();
        }, t.prototype.buildPath = function(e, i) {
          var r, a, o, s;
          if (this.subPixelOptimize) {
            var l = o5(Q_t, i, this.style);
            r = l.x, a = l.y, o = l.width, s = l.height, l.r = i.r, i = l;
          } else r = i.x, a = i.y, o = i.width, s = i.height;
          i.r ? k_t(e, i) : e.rect(r, a, o, s);
        }, t.prototype.isZeroArea = function() {
          return !this.shape.width || !this.shape.height;
        }, t;
      }(Jt);
      ue.prototype.type = "rect";
      var s5 = { fill: "#000" }, l5 = 2, O_t = { style: Et({ fill: true, stroke: true, fillOpacity: true, strokeOpacity: true, lineWidth: true, fontSize: true, lineHeight: true, width: true, height: true, textShadowColor: true, textShadowBlur: true, textShadowOffsetX: true, textShadowOffsetY: true, backgroundColor: true, padding: true, borderColor: true, borderWidth: true, borderRadius: true }, V_.style) }, ge = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this) || this;
          return i.type = "text", i._children = [], i._defaultStyle = s5, i.attr(e), i;
        }
        return t.prototype.childrenRef = function() {
          return this._children;
        }, t.prototype.update = function() {
          n.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
          for (var e = 0; e < this._children.length; e++) {
            var i = this._children[e];
            i.zlevel = this.zlevel, i.z = this.z, i.z2 = this.z2, i.culling = this.culling, i.cursor = this.cursor, i.invisible = this.invisible;
          }
        }, t.prototype.updateTransform = function() {
          var e = this.innerTransformable;
          e ? (e.updateTransform(), e.transform && (this.transform = e.transform)) : n.prototype.updateTransform.call(this);
        }, t.prototype.getLocalTransform = function(e) {
          var i = this.innerTransformable;
          return i ? i.getLocalTransform(e) : n.prototype.getLocalTransform.call(this, e);
        }, t.prototype.getComputedTransform = function() {
          return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(true)), n.prototype.getComputedTransform.call(this);
        }, t.prototype._updateSubTexts = function() {
          this._childCursor = 0, U_t(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
        }, t.prototype.addSelfToZr = function(e) {
          n.prototype.addSelfToZr.call(this, e);
          for (var i = 0; i < this._children.length; i++) this._children[i].__zr = e;
        }, t.prototype.removeSelfFromZr = function(e) {
          n.prototype.removeSelfFromZr.call(this, e);
          for (var i = 0; i < this._children.length; i++) this._children[i].__zr = null;
        }, t.prototype.getBoundingRect = function() {
          if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
            for (var e = new Ht(0, 0, 0, 0), i = this._children, r = [], a = null, o = 0; o < i.length; o++) {
              var s = i[o], l = s.getBoundingRect(), u = s.getLocalTransform(r);
              u ? (e.copy(l), e.applyTransform(u), a = a || e.clone(), a.union(e)) : (a = a || l.clone(), a.union(l));
            }
            this._rect = a || e;
          }
          return this._rect;
        }, t.prototype.setDefaultTextStyle = function(e) {
          this._defaultStyle = e || s5;
        }, t.prototype.setTextContent = function(e) {
          if (true) throw new Error("Can't attach text on another text");
        }, t.prototype._mergeStyle = function(e, i) {
          if (!i) return e;
          var r = i.rich, a = e.rich || r && {};
          return Y(e, i), r && a ? (this._mergeRich(a, r), e.rich = a) : a && (e.rich = a), e;
        }, t.prototype._mergeRich = function(e, i) {
          for (var r = re(i), a = 0; a < r.length; a++) {
            var o = r[a];
            e[o] = e[o] || {}, Y(e[o], i[o]);
          }
        }, t.prototype.getAnimationStyleProps = function() {
          return O_t;
        }, t.prototype._getOrCreateChild = function(e) {
          var i = this._children[this._childCursor];
          return (!i || !(i instanceof e)) && (i = new e()), this._children[this._childCursor++] = i, i.__zr = this.__zr, i.parent = this, i;
        }, t.prototype._updatePlainTexts = function() {
          var e = this.style, i = e.font || Ql, r = e.padding, a = v5(e), o = u_t(a, e), s = P2(e), l = !!e.backgroundColor, u = o.outerHeight, h = o.outerWidth, c = o.contentWidth, f = o.lines, g = o.lineHeight, d = this._defaultStyle, A = e.x || 0, p = e.y || 0, v = e.align || d.align || "left", y = e.verticalAlign || d.verticalAlign || "top", m = A, _ = dg(p, o.contentHeight, y);
          if (s || r) {
            var E = Sp(A, h, v), I = dg(p, u, y);
            s && this._renderBackground(e, e, E, I, h, u);
          }
          _ += g / 2, r && (m = p5(A, v, r), y === "top" ? _ += r[0] : y === "bottom" && (_ -= r[2]));
          for (var x = 0, w = false, C = A5("fill" in e ? e.fill : (w = true, d.fill)), S = d5("stroke" in e ? e.stroke : !l && (!d.autoStroke || w) ? (x = l5, d.stroke) : null), b = e.textShadowBlur > 0, B = e.width != null && (e.overflow === "truncate" || e.overflow === "break" || e.overflow === "breakAll"), T = o.calculatedLineHeight, D = 0; D < f.length; D++) {
            var R = this._getOrCreateChild(yg), L = R.createStyle();
            R.useStyle(L), L.text = f[D], L.x = m, L.y = _, v && (L.textAlign = v), L.textBaseline = "middle", L.opacity = e.opacity, L.strokeFirst = true, b && (L.shadowBlur = e.textShadowBlur || 0, L.shadowColor = e.textShadowColor || "transparent", L.shadowOffsetX = e.textShadowOffsetX || 0, L.shadowOffsetY = e.textShadowOffsetY || 0), L.stroke = S, L.fill = C, S && (L.lineWidth = e.lineWidth || x, L.lineDash = e.lineDash, L.lineDashOffset = e.lineDashOffset || 0), L.font = i, c5(L, e), _ += g, B && R.setBoundingRect(new Ht(Sp(L.x, e.width, L.textAlign), dg(L.y, T, L.textBaseline), c, T));
          }
        }, t.prototype._updateRichTexts = function() {
          var e = this.style, i = v5(e), r = f_t(i, e), a = r.width, o = r.outerWidth, s = r.outerHeight, l = e.padding, u = e.x || 0, h = e.y || 0, c = this._defaultStyle, f = e.align || c.align, g = e.verticalAlign || c.verticalAlign, d = Sp(u, o, f), A = dg(h, s, g), p = d, v = A;
          l && (p += l[3], v += l[0]);
          var y = p + a;
          P2(e) && this._renderBackground(e, e, d, A, o, s);
          for (var m = !!e.backgroundColor, _ = 0; _ < r.lines.length; _++) {
            for (var E = r.lines[_], I = E.tokens, x = I.length, w = E.lineHeight, C = E.width, S = 0, b = p, B = y, T = x - 1, D = void 0; S < x && (D = I[S], !D.align || D.align === "left"); ) this._placeToken(D, e, w, v, b, "left", m), C -= D.width, b += D.width, S++;
            for (; T >= 0 && (D = I[T], D.align === "right"); ) this._placeToken(D, e, w, v, B, "right", m), C -= D.width, B -= D.width, T--;
            for (b += (a - (b - p) - (y - B) - C) / 2; S <= T; ) D = I[S], this._placeToken(D, e, w, v, b + D.width / 2, "center", m), b += D.width, S++;
            v += w;
          }
        }, t.prototype._placeToken = function(e, i, r, a, o, s, l) {
          var u = i.rich[e.styleName] || {};
          u.text = e.text;
          var h = e.verticalAlign, c = a + r / 2;
          h === "top" ? c = a + e.height / 2 : h === "bottom" && (c = a + r - e.height / 2);
          var f = !e.isLineHolder && P2(u);
          f && this._renderBackground(u, i, s === "right" ? o - e.width : s === "center" ? o - e.width / 2 : o, c - e.height / 2, e.width, e.height);
          var g = !!u.backgroundColor, d = e.textPadding;
          d && (o = p5(o, s, d), c -= e.height / 2 - d[0] - e.innerHeight / 2);
          var A = this._getOrCreateChild(yg), p = A.createStyle();
          A.useStyle(p);
          var v = this._defaultStyle, y = false, m = 0, _ = A5("fill" in u ? u.fill : "fill" in i ? i.fill : (y = true, v.fill)), E = d5("stroke" in u ? u.stroke : "stroke" in i ? i.stroke : !g && !l && (!v.autoStroke || y) ? (m = l5, v.stroke) : null), I = u.textShadowBlur > 0 || i.textShadowBlur > 0;
          p.text = e.text, p.x = o, p.y = c, I && (p.shadowBlur = u.textShadowBlur || i.textShadowBlur || 0, p.shadowColor = u.textShadowColor || i.textShadowColor || "transparent", p.shadowOffsetX = u.textShadowOffsetX || i.textShadowOffsetX || 0, p.shadowOffsetY = u.textShadowOffsetY || i.textShadowOffsetY || 0), p.textAlign = s, p.textBaseline = "middle", p.font = e.font || Ql, p.opacity = ra(u.opacity, i.opacity, 1), c5(p, u), E && (p.lineWidth = ra(u.lineWidth, i.lineWidth, m), p.lineDash = Pt(u.lineDash, i.lineDash), p.lineDashOffset = i.lineDashOffset || 0, p.stroke = E), _ && (p.fill = _);
          var x = e.contentWidth, w = e.contentHeight;
          A.setBoundingRect(new Ht(Sp(p.x, x, p.textAlign), dg(p.y, w, p.textBaseline), x, w));
        }, t.prototype._renderBackground = function(e, i, r, a, o, s) {
          var l = e.backgroundColor, u = e.borderWidth, h = e.borderColor, c = l && l.image, f = l && !c, g = e.borderRadius, d = this, A, p;
          if (f || e.lineHeight || u && h) {
            A = this._getOrCreateChild(ue), A.useStyle(A.createStyle()), A.style.fill = null;
            var v = A.shape;
            v.x = r, v.y = a, v.width = o, v.height = s, v.r = g, A.dirtyShape();
          }
          if (f) {
            var y = A.style;
            y.fill = l || null, y.fillOpacity = Pt(e.fillOpacity, 1);
          } else if (c) {
            p = this._getOrCreateChild(li), p.onload = function() {
              d.dirtyStyle();
            };
            var m = p.style;
            m.image = l.image, m.x = r, m.y = a, m.width = o, m.height = s;
          }
          if (u && h) {
            var y = A.style;
            y.lineWidth = u, y.stroke = h, y.strokeOpacity = Pt(e.strokeOpacity, 1), y.lineDash = e.borderDash, y.lineDashOffset = e.borderDashOffset || 0, A.strokeContainThreshold = 0, A.hasFill() && A.hasStroke() && (y.strokeFirst = true, y.lineWidth *= 2);
          }
          var _ = (A || p).style;
          _.shadowBlur = e.shadowBlur || 0, _.shadowColor = e.shadowColor || "transparent", _.shadowOffsetX = e.shadowOffsetX || 0, _.shadowOffsetY = e.shadowOffsetY || 0, _.opacity = ra(e.opacity, i.opacity, 1);
        }, t.makeFont = function(e) {
          var i = "";
          return f5(e) && (i = [e.fontStyle, e.fontWeight, h5(e.fontSize), e.fontFamily || "sans-serif"].join(" ")), i && Ga(i) || e.textFont || e.font;
        }, t;
      }(ha), z_t = { left: true, right: 1, center: 1 }, G_t = { top: 1, bottom: 1, middle: 1 }, u5 = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
      function h5(n) {
        return typeof n == "string" && (n.indexOf("px") !== -1 || n.indexOf("rem") !== -1 || n.indexOf("em") !== -1) ? n : isNaN(+n) ? hb + "px" : n + "px";
      }
      function c5(n, t) {
        for (var e = 0; e < u5.length; e++) {
          var i = u5[e], r = t[i];
          r != null && (n[i] = r);
        }
      }
      function f5(n) {
        return n.fontSize != null || n.fontFamily || n.fontWeight;
      }
      function U_t(n) {
        return g5(n), M(n.rich, g5), n;
      }
      function g5(n) {
        if (n) {
          n.font = ge.makeFont(n);
          var t = n.align;
          t === "middle" && (t = "center"), n.align = t == null || z_t[t] ? t : "left";
          var e = n.verticalAlign;
          e === "center" && (e = "middle"), n.verticalAlign = e == null || G_t[e] ? e : "top";
          var i = n.padding;
          i && (n.padding = Ab(n.padding));
        }
      }
      function d5(n, t) {
        return n == null || t <= 0 || n === "transparent" || n === "none" ? null : n.image || n.colorStops ? "#000" : n;
      }
      function A5(n) {
        return n == null || n === "none" ? null : n.image || n.colorStops ? "#000" : n;
      }
      function p5(n, t, e) {
        return t === "right" ? n - e[1] : t === "center" ? n + e[3] / 2 - e[1] / 2 : n + e[3];
      }
      function v5(n) {
        var t = n.text;
        return t != null && (t += ""), t;
      }
      function P2(n) {
        return !!(n.backgroundColor || n.lineHeight || n.borderWidth && n.borderColor);
      }
      var Dt = le(), N2 = function(n, t, e, i) {
        if (i) {
          var r = Dt(i);
          r.dataIndex = e, r.dataType = t, r.seriesIndex = n, r.ssrType = "chart", i.type === "group" && i.traverse(function(a) {
            var o = Dt(a);
            o.seriesIndex = n, o.dataIndex = e, o.dataType = t, o.ssrType = "chart";
          });
        }
      }, y5 = 1, m5 = {}, _5 = le(), k2 = le(), F2 = 0, Pp = 1, X_ = 2, qi = ["emphasis", "blur", "select"], Np = ["normal", "emphasis", "blur", "select"], _g = 10, V_t = 9, Sh = "highlight", Z_ = "downplay", kp = "select", K_ = "unselect", Fp = "toggleSelect";
      function Ig(n) {
        return n != null && n !== "none";
      }
      function $_(n, t, e) {
        n.onHoverStateChange && (n.hoverState || 0) !== e && n.onHoverStateChange(t), n.hoverState = e;
      }
      function I5(n) {
        $_(n, "emphasis", X_);
      }
      function E5(n) {
        n.hoverState === X_ && $_(n, "normal", F2);
      }
      function Q2(n) {
        $_(n, "blur", Pp);
      }
      function x5(n) {
        n.hoverState === Pp && $_(n, "normal", F2);
      }
      function j_t(n) {
        n.selected = true;
      }
      function q_t(n) {
        n.selected = false;
      }
      function w5(n, t, e) {
        t(n, e);
      }
      function Ls(n, t, e) {
        w5(n, t, e), n.isGroup && n.traverse(function(i) {
          w5(i, t, e);
        });
      }
      function J_(n, t) {
        switch (t) {
          case "emphasis":
            n.hoverState = X_;
            break;
          case "normal":
            n.hoverState = F2;
            break;
          case "blur":
            n.hoverState = Pp;
            break;
          case "select":
            n.selected = true;
        }
      }
      function H_t(n, t, e, i) {
        for (var r = n.style, a = {}, o = 0; o < t.length; o++) {
          var s = t[o], l = r[s];
          a[s] = l == null ? i && i[s] : l;
        }
        for (var o = 0; o < n.animators.length; o++) {
          var u = n.animators[o];
          u.__fromStateTransition && u.__fromStateTransition.indexOf(e) < 0 && u.targetName === "style" && u.saveTo(a, t);
        }
        return a;
      }
      function Y_t(n, t, e, i) {
        var r = e && Wt(e, "select") >= 0, a = false;
        if (n instanceof Jt) {
          var o = _5(n), s = r && o.selectFill || o.normalFill, l = r && o.selectStroke || o.normalStroke;
          if (Ig(s) || Ig(l)) {
            i = i || {};
            var u = i.style || {};
            u.fill === "inherit" ? (a = true, i = Y({}, i), u = Y({}, u), u.fill = s) : !Ig(u.fill) && Ig(s) ? (a = true, i = Y({}, i), u = Y({}, u), u.fill = Gb(s)) : !Ig(u.stroke) && Ig(l) && (a || (i = Y({}, i), u = Y({}, u)), u.stroke = Gb(l)), i.style = u;
          }
        }
        if (i && i.z2 == null) {
          a || (i = Y({}, i));
          var h = n.z2EmphasisLift;
          i.z2 = n.z2 + (h != null ? h : _g);
        }
        return i;
      }
      function W_t(n, t, e) {
        if (e && e.z2 == null) {
          e = Y({}, e);
          var i = n.z2SelectLift;
          e.z2 = n.z2 + (i != null ? i : V_t);
        }
        return e;
      }
      function X_t(n, t, e) {
        var i = Wt(n.currentStates, t) >= 0, r = n.style.opacity, a = i ? null : H_t(n, ["opacity"], t, { opacity: 1 });
        e = e || {};
        var o = e.style || {};
        return o.opacity == null && (e = Y({}, e), o = Y({ opacity: i ? r : a.opacity * 0.1 }, o), e.style = o), e;
      }
      function O2(n, t) {
        var e = this.states[n];
        if (this.style) {
          if (n === "emphasis") return Y_t(this, n, t, e);
          if (n === "blur") return X_t(this, n, e);
          if (n === "select") return W_t(this, n, e);
        }
        return e;
      }
      function bh(n) {
        n.stateProxy = O2;
        var t = n.getTextContent(), e = n.getTextGuideLine();
        t && (t.stateProxy = O2), e && (e.stateProxy = O2);
      }
      function C5(n, t) {
        !M5(n, t) && !n.__highByOuter && Ls(n, I5);
      }
      function S5(n, t) {
        !M5(n, t) && !n.__highByOuter && Ls(n, E5);
      }
      function Ps(n, t) {
        n.__highByOuter |= 1 << (t || 0), Ls(n, I5);
      }
      function Ns(n, t) {
        !(n.__highByOuter &= ~(1 << (t || 0))) && Ls(n, E5);
      }
      function b5(n) {
        Ls(n, Q2);
      }
      function z2(n) {
        Ls(n, x5);
      }
      function B5(n) {
        Ls(n, j_t);
      }
      function T5(n) {
        Ls(n, q_t);
      }
      function M5(n, t) {
        return n.__highDownSilentOnTouch && t.zrByTouch;
      }
      function D5(n) {
        var t = n.getModel(), e = [], i = [];
        t.eachComponent(function(r, a) {
          var o = k2(a), s = r === "series", l = s ? n.getViewOfSeriesModel(a) : n.getViewOfComponentModel(a);
          !s && i.push(l), o.isBlured && (l.group.traverse(function(u) {
            x5(u);
          }), s && e.push(a)), o.isBlured = false;
        }), M(i, function(r) {
          r && r.toggleBlurSeries && r.toggleBlurSeries(e, false, t);
        });
      }
      function G2(n, t, e, i) {
        var r = i.getModel();
        e = e || "coordinateSystem";
        function a(u, h) {
          for (var c = 0; c < h.length; c++) {
            var f = u.getItemGraphicEl(h[c]);
            f && z2(f);
          }
        }
        if (n != null && !(!t || t === "none")) {
          var o = r.getSeriesByIndex(n), s = o.coordinateSystem;
          s && s.master && (s = s.master);
          var l = [];
          r.eachSeries(function(u) {
            var h = o === u, c = u.coordinateSystem;
            c && c.master && (c = c.master);
            var f = c && s ? c === s : h;
            if (!(e === "series" && !h || e === "coordinateSystem" && !f || t === "series" && h)) {
              var g = i.getViewOfSeriesModel(u);
              if (g.group.traverse(function(p) {
                p.__highByOuter && h && t === "self" || Q2(p);
              }), Mi(t)) a(u.getData(), t);
              else if (_t(t)) for (var d = re(t), A = 0; A < d.length; A++) a(u.getData(d[A]), t[d[A]]);
              l.push(u), k2(u).isBlured = true;
            }
          }), r.eachComponent(function(u, h) {
            if (u !== "series") {
              var c = i.getViewOfComponentModel(h);
              c && c.toggleBlurSeries && c.toggleBlurSeries(l, true, r);
            }
          });
        }
      }
      function U2(n, t, e) {
        if (!(n == null || t == null)) {
          var i = e.getModel().getComponent(n, t);
          if (i) {
            k2(i).isBlured = true;
            var r = e.getViewOfComponentModel(i);
            !r || !r.focusBlurEnabled || r.group.traverse(function(a) {
              Q2(a);
            });
          }
        }
      }
      function Z_t(n, t, e) {
        var i = n.seriesIndex, r = n.getData(t.dataType);
        if (!r) {
          Ai("Unknown dataType " + t.dataType);
          return;
        }
        var a = Ah(r, t);
        a = (X(a) ? a[0] : a) || 0;
        var o = r.getItemGraphicEl(a);
        if (!o) for (var s = r.count(), l = 0; !o && l < s; ) o = r.getItemGraphicEl(l++);
        if (o) {
          var u = Dt(o);
          G2(i, u.focus, u.blurScope, e);
        } else {
          var h = n.get(["emphasis", "focus"]), c = n.get(["emphasis", "blurScope"]);
          h != null && G2(i, h, c, e);
        }
      }
      function V2(n, t, e, i) {
        var r = { focusSelf: false, dispatchers: null };
        if (n == null || n === "series" || t == null || e == null) return r;
        var a = i.getModel().getComponent(n, t);
        if (!a) return r;
        var o = i.getViewOfComponentModel(a);
        if (!o || !o.findHighDownDispatchers) return r;
        for (var s = o.findHighDownDispatchers(e), l, u = 0; u < s.length; u++) if (!$l(s[u]) && Ai("param should be highDownDispatcher"), Dt(s[u]).focus === "self") {
          l = true;
          break;
        }
        return { focusSelf: l, dispatchers: s };
      }
      function K_t(n, t, e) {
        !$l(n) && Ai("param should be highDownDispatcher");
        var i = Dt(n), r = V2(i.componentMainType, i.componentIndex, i.componentHighDownName, e), a = r.dispatchers, o = r.focusSelf;
        a ? (o && U2(i.componentMainType, i.componentIndex, e), M(a, function(s) {
          return C5(s, t);
        })) : (G2(i.seriesIndex, i.focus, i.blurScope, e), i.focus === "self" && U2(i.componentMainType, i.componentIndex, e), C5(n, t));
      }
      function $_t(n, t, e) {
        !$l(n) && Ai("param should be highDownDispatcher"), D5(e);
        var i = Dt(n), r = V2(i.componentMainType, i.componentIndex, i.componentHighDownName, e).dispatchers;
        r ? M(r, function(a) {
          return S5(a, t);
        }) : S5(n, t);
      }
      function J_t(n, t, e) {
        if (q2(t)) {
          var i = t.dataType, r = n.getData(i), a = Ah(r, t);
          X(a) || (a = [a]), n[t.type === Fp ? "toggleSelect" : t.type === kp ? "select" : "unselect"](a, i);
        }
      }
      function R5(n) {
        var t = n.getAllData();
        M(t, function(e) {
          var i = e.data, r = e.type;
          i.eachItemGraphicEl(function(a, o) {
            n.isSelected(o, r) ? B5(a) : T5(a);
          });
        });
      }
      function t1t(n) {
        var t = [];
        return n.eachSeries(function(e) {
          var i = e.getAllData();
          M(i, function(r) {
            r.data;
            var a = r.type, o = e.getSelectedDataIndices();
            if (o.length > 0) {
              var s = { dataIndex: o, seriesIndex: e.seriesIndex };
              a != null && (s.dataType = a), t.push(s);
            }
          });
        }), t;
      }
      function Bh(n, t, e) {
        Th(n, true), Ls(n, bh), j2(n, t, e);
      }
      function e1t(n) {
        Th(n, false);
      }
      function hn(n, t, e, i) {
        i ? e1t(n) : Bh(n, t, e);
      }
      function j2(n, t, e) {
        var i = Dt(n);
        t != null ? (i.focus = t, i.blurScope = e) : i.focus && (i.focus = null);
      }
      var L5 = ["emphasis", "blur", "select"], n1t = { itemStyle: "getItemStyle", lineStyle: "getLineStyle", areaStyle: "getAreaStyle" };
      function pi(n, t, e, i) {
        e = e || "itemStyle";
        for (var r = 0; r < L5.length; r++) {
          var a = L5[r], o = t.getModel([a, e]), s = n.ensureState(a);
          s.style = i ? i(o) : o[n1t[e]]();
        }
      }
      function Th(n, t) {
        var e = t === false, i = n;
        n.highDownSilentOnTouch && (i.__highDownSilentOnTouch = n.highDownSilentOnTouch), (!e || i.__highDownDispatcher) && (i.__highByOuter = i.__highByOuter || 0, i.__highDownDispatcher = !e);
      }
      function $l(n) {
        return !!(n && n.__highDownDispatcher);
      }
      function i1t(n, t, e) {
        var i = Dt(n);
        i.componentMainType = t.mainType, i.componentIndex = t.componentIndex, i.componentHighDownName = e;
      }
      function r1t(n) {
        var t = m5[n];
        return t == null && y5 <= 32 && (t = m5[n] = y5++), t;
      }
      function q2(n) {
        var t = n.type;
        return t === kp || t === K_ || t === Fp;
      }
      function P5(n) {
        var t = n.type;
        return t === Sh || t === Z_;
      }
      function a1t(n) {
        var t = _5(n);
        t.normalFill = n.style.fill, t.normalStroke = n.style.stroke;
        var e = n.states.select || {};
        t.selectFill = e.style && e.style.fill || null, t.selectStroke = e.style && e.style.stroke || null;
      }
      var Eg = ko.CMD, o1t = [[], [], []], N5 = Math.sqrt, s1t = Math.atan2;
      function k5(n, t) {
        if (t) {
          var e = n.data, i = n.len(), r, a, o, s, l, u, h = Eg.M, c = Eg.C, f = Eg.L, g = Eg.R, d = Eg.A, A = Eg.Q;
          for (o = 0, s = 0; o < i; ) {
            switch (r = e[o++], s = o, a = 0, r) {
              case h:
                a = 1;
                break;
              case f:
                a = 1;
                break;
              case c:
                a = 3;
                break;
              case A:
                a = 2;
                break;
              case d:
                var p = t[4], v = t[5], y = N5(t[0] * t[0] + t[1] * t[1]), m = N5(t[2] * t[2] + t[3] * t[3]), _ = s1t(-t[1] / m, t[0] / y);
                e[o] *= y, e[o++] += p, e[o] *= m, e[o++] += v, e[o++] *= y, e[o++] *= m, e[o++] += _, e[o++] += _, o += 2, s = o;
                break;
              case g:
                u[0] = e[o++], u[1] = e[o++], di(u, u, t), e[s++] = u[0], e[s++] = u[1], u[0] += e[o++], u[1] += e[o++], di(u, u, t), e[s++] = u[0], e[s++] = u[1];
            }
            for (l = 0; l < a; l++) {
              var E = o1t[l];
              E[0] = e[o++], E[1] = e[o++], di(E, E, t), e[s++] = E[0], e[s++] = E[1];
            }
          }
          n.increaseVersion();
        }
      }
      var H2 = Math.sqrt, t1 = Math.sin, e1 = Math.cos, Qp = Math.PI;
      function F5(n) {
        return Math.sqrt(n[0] * n[0] + n[1] * n[1]);
      }
      function Y2(n, t) {
        return (n[0] * t[0] + n[1] * t[1]) / (F5(n) * F5(t));
      }
      function Q5(n, t) {
        return (n[0] * t[1] < n[1] * t[0] ? -1 : 1) * Math.acos(Y2(n, t));
      }
      function O5(n, t, e, i, r, a, o, s, l, u, h) {
        var c = l * (Qp / 180), f = e1(c) * (n - e) / 2 + t1(c) * (t - i) / 2, g = -1 * t1(c) * (n - e) / 2 + e1(c) * (t - i) / 2, d = f * f / (o * o) + g * g / (s * s);
        d > 1 && (o *= H2(d), s *= H2(d));
        var A = (r === a ? -1 : 1) * H2((o * o * (s * s) - o * o * (g * g) - s * s * (f * f)) / (o * o * (g * g) + s * s * (f * f))) || 0, p = A * o * g / s, v = A * -s * f / o, y = (n + e) / 2 + e1(c) * p - t1(c) * v, m = (t + i) / 2 + t1(c) * p + e1(c) * v, _ = Q5([1, 0], [(f - p) / o, (g - v) / s]), E = [(f - p) / o, (g - v) / s], I = [(-1 * f - p) / o, (-1 * g - v) / s], x = Q5(E, I);
        if (Y2(E, I) <= -1 && (x = Qp), Y2(E, I) >= 1 && (x = 0), x < 0) {
          var w = Math.round(x / Qp * 1e6) / 1e6;
          x = Qp * 2 + w % 2 * Qp;
        }
        h.addData(u, y, m, o, s, _, x, c, a);
      }
      var l1t = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, u1t = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
      function h1t(n) {
        var t = new ko();
        if (!n) return t;
        var e = 0, i = 0, r = e, a = i, o, s = ko.CMD, l = n.match(l1t);
        if (!l) return t;
        for (var u = 0; u < l.length; u++) {
          for (var h = l[u], c = h.charAt(0), f = void 0, g = h.match(u1t) || [], d = g.length, A = 0; A < d; A++) g[A] = parseFloat(g[A]);
          for (var p = 0; p < d; ) {
            var v = void 0, y = void 0, m = void 0, _ = void 0, E = void 0, I = void 0, x = void 0, w = e, C = i, S = void 0, b = void 0;
            switch (c) {
              case "l":
                e += g[p++], i += g[p++], f = s.L, t.addData(f, e, i);
                break;
              case "L":
                e = g[p++], i = g[p++], f = s.L, t.addData(f, e, i);
                break;
              case "m":
                e += g[p++], i += g[p++], f = s.M, t.addData(f, e, i), r = e, a = i, c = "l";
                break;
              case "M":
                e = g[p++], i = g[p++], f = s.M, t.addData(f, e, i), r = e, a = i, c = "L";
                break;
              case "h":
                e += g[p++], f = s.L, t.addData(f, e, i);
                break;
              case "H":
                e = g[p++], f = s.L, t.addData(f, e, i);
                break;
              case "v":
                i += g[p++], f = s.L, t.addData(f, e, i);
                break;
              case "V":
                i = g[p++], f = s.L, t.addData(f, e, i);
                break;
              case "C":
                f = s.C, t.addData(f, g[p++], g[p++], g[p++], g[p++], g[p++], g[p++]), e = g[p - 2], i = g[p - 1];
                break;
              case "c":
                f = s.C, t.addData(f, g[p++] + e, g[p++] + i, g[p++] + e, g[p++] + i, g[p++] + e, g[p++] + i), e += g[p - 2], i += g[p - 1];
                break;
              case "S":
                v = e, y = i, S = t.len(), b = t.data, o === s.C && (v += e - b[S - 4], y += i - b[S - 3]), f = s.C, w = g[p++], C = g[p++], e = g[p++], i = g[p++], t.addData(f, v, y, w, C, e, i);
                break;
              case "s":
                v = e, y = i, S = t.len(), b = t.data, o === s.C && (v += e - b[S - 4], y += i - b[S - 3]), f = s.C, w = e + g[p++], C = i + g[p++], e += g[p++], i += g[p++], t.addData(f, v, y, w, C, e, i);
                break;
              case "Q":
                w = g[p++], C = g[p++], e = g[p++], i = g[p++], f = s.Q, t.addData(f, w, C, e, i);
                break;
              case "q":
                w = g[p++] + e, C = g[p++] + i, e += g[p++], i += g[p++], f = s.Q, t.addData(f, w, C, e, i);
                break;
              case "T":
                v = e, y = i, S = t.len(), b = t.data, o === s.Q && (v += e - b[S - 4], y += i - b[S - 3]), e = g[p++], i = g[p++], f = s.Q, t.addData(f, v, y, e, i);
                break;
              case "t":
                v = e, y = i, S = t.len(), b = t.data, o === s.Q && (v += e - b[S - 4], y += i - b[S - 3]), e += g[p++], i += g[p++], f = s.Q, t.addData(f, v, y, e, i);
                break;
              case "A":
                m = g[p++], _ = g[p++], E = g[p++], I = g[p++], x = g[p++], w = e, C = i, e = g[p++], i = g[p++], f = s.A, O5(w, C, e, i, I, x, m, _, E, f, t);
                break;
              case "a":
                m = g[p++], _ = g[p++], E = g[p++], I = g[p++], x = g[p++], w = e, C = i, e += g[p++], i += g[p++], f = s.A, O5(w, C, e, i, I, x, m, _, E, f, t);
                break;
            }
          }
          (c === "z" || c === "Z") && (f = s.Z, t.addData(f), e = r, i = a), o = f;
        }
        return t.toStatic(), t;
      }
      var z5 = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.applyTransform = function(e) {
        }, t;
      }(Jt);
      function G5(n) {
        return n.setData != null;
      }
      function U5(n, t) {
        var e = h1t(n), i = Y({}, t);
        return i.buildPath = function(r) {
          if (G5(r)) {
            r.setData(e.data);
            var a = r.getContext();
            a && r.rebuildPath(a, 1);
          } else {
            var a = r;
            e.rebuildPath(a, 1);
          }
        }, i.applyTransform = function(r) {
          k5(e, r), this.dirtyShape();
        }, i;
      }
      function V5(n, t) {
        return new z5(U5(n, t));
      }
      function c1t(n, t) {
        var e = U5(n, t), i = function(r) {
          V(a, r);
          function a(o) {
            var s = r.call(this, o) || this;
            return s.applyTransform = e.applyTransform, s.buildPath = e.buildPath, s;
          }
          return a;
        }(z5);
        return i;
      }
      function f1t(n, t) {
        for (var e = [], i = n.length, r = 0; r < i; r++) {
          var a = n[r];
          e.push(a.getUpdatedPathProxy(true));
        }
        var o = new Jt(t);
        return o.createPathProxy(), o.buildPath = function(s) {
          if (G5(s)) {
            s.appendPath(e);
            var l = s.getContext();
            l && s.rebuildPath(l, 1);
          }
        }, o;
      }
      function W2(n, t) {
        t = t || {};
        var e = new Jt();
        return n.shape && e.setShape(n.shape), e.setStyle(n.style), t.bakeTransform ? k5(e.path, n.getComputedTransform()) : t.toLocal ? e.setLocalTransform(n.getComputedTransform()) : e.copyTransform(n), e.buildPath = n.buildPath, e.applyTransform = e.applyTransform, e.z = n.z, e.z2 = n.z2, e.zlevel = n.zlevel, e;
      }
      var g1t = /* @__PURE__ */ function() {
        function n() {
          this.cx = 0, this.cy = 0, this.r = 0;
        }
        return n;
      }(), ks = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultShape = function() {
          return new g1t();
        }, t.prototype.buildPath = function(e, i) {
          e.moveTo(i.cx + i.r, i.cy), e.arc(i.cx, i.cy, i.r, 0, Math.PI * 2);
        }, t;
      }(Jt);
      ks.prototype.type = "circle";
      var d1t = /* @__PURE__ */ function() {
        function n() {
          this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
        }
        return n;
      }(), n1 = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultShape = function() {
          return new d1t();
        }, t.prototype.buildPath = function(e, i) {
          var r = 0.5522848, a = i.cx, o = i.cy, s = i.rx, l = i.ry, u = s * r, h = l * r;
          e.moveTo(a - s, o), e.bezierCurveTo(a - s, o - h, a - u, o - l, a, o - l), e.bezierCurveTo(a + u, o - l, a + s, o - h, a + s, o), e.bezierCurveTo(a + s, o + h, a + u, o + l, a, o + l), e.bezierCurveTo(a - u, o + l, a - s, o + h, a - s, o), e.closePath();
        }, t;
      }(Jt);
      n1.prototype.type = "ellipse";
      var j5 = Math.PI, X2 = j5 * 2, Mh = Math.sin, xg = Math.cos, A1t = Math.acos, Di = Math.atan2, q5 = Math.abs, Op = Math.sqrt, zp = Math.max, Fo = Math.min, Ha = 1e-4;
      function p1t(n, t, e, i, r, a, o, s) {
        var l = e - n, u = i - t, h = o - r, c = s - a, f = c * l - h * u;
        if (!(f * f < Ha)) return f = (h * (t - a) - c * (n - r)) / f, [n + f * l, t + f * u];
      }
      function i1(n, t, e, i, r, a, o) {
        var s = n - e, l = t - i, u = (o ? a : -a) / Op(s * s + l * l), h = u * l, c = -u * s, f = n + h, g = t + c, d = e + h, A = i + c, p = (f + d) / 2, v = (g + A) / 2, y = d - f, m = A - g, _ = y * y + m * m, E = r - a, I = f * A - d * g, x = (m < 0 ? -1 : 1) * Op(zp(0, E * E * _ - I * I)), w = (I * m - y * x) / _, C = (-I * y - m * x) / _, S = (I * m + y * x) / _, b = (-I * y + m * x) / _, B = w - p, T = C - v, D = S - p, R = b - v;
        return B * B + T * T > D * D + R * R && (w = S, C = b), { cx: w, cy: C, x0: -h, y0: -c, x1: w * (r / E - 1), y1: C * (r / E - 1) };
      }
      function v1t(n) {
        var t;
        if (X(n)) {
          var e = n.length;
          if (!e) return n;
          e === 1 ? t = [n[0], n[0], 0, 0] : e === 2 ? t = [n[0], n[0], n[1], n[1]] : e === 3 ? t = n.concat(n[2]) : t = n;
        } else t = [n, n, n, n];
        return t;
      }
      function y1t(n, t) {
        var e, i = zp(t.r, 0), r = zp(t.r0 || 0, 0), a = i > 0, o = r > 0;
        if (!(!a && !o)) {
          if (a || (i = r, r = 0), r > i) {
            var s = i;
            i = r, r = s;
          }
          var l = t.startAngle, u = t.endAngle;
          if (!(isNaN(l) || isNaN(u))) {
            var h = t.cx, c = t.cy, f = !!t.clockwise, g = q5(u - l), d = g > X2 && g % X2;
            if (d > Ha && (g = d), !(i > Ha)) n.moveTo(h, c);
            else if (g > X2 - Ha) n.moveTo(h + i * xg(l), c + i * Mh(l)), n.arc(h, c, i, l, u, !f), r > Ha && (n.moveTo(h + r * xg(u), c + r * Mh(u)), n.arc(h, c, r, u, l, f));
            else {
              var A = void 0, p = void 0, v = void 0, y = void 0, m = void 0, _ = void 0, E = void 0, I = void 0, x = void 0, w = void 0, C = void 0, S = void 0, b = void 0, B = void 0, T = void 0, D = void 0, R = i * xg(l), L = i * Mh(l), k = r * xg(u), P = r * Mh(u), F = g > Ha;
              if (F) {
                var Q = t.cornerRadius;
                Q && (e = v1t(Q), A = e[0], p = e[1], v = e[2], y = e[3]);
                var z = q5(i - r) / 2;
                if (m = Fo(z, v), _ = Fo(z, y), E = Fo(z, A), I = Fo(z, p), C = x = zp(m, _), S = w = zp(E, I), (x > Ha || w > Ha) && (b = i * xg(u), B = i * Mh(u), T = r * xg(l), D = r * Mh(l), g < j5)) {
                  var j = p1t(R, L, T, D, b, B, k, P);
                  if (j) {
                    var $ = R - j[0], G = L - j[1], tt = b - j[0], J = B - j[1], et = 1 / Mh(A1t(($ * tt + G * J) / (Op($ * $ + G * G) * Op(tt * tt + J * J))) / 2), nt = Op(j[0] * j[0] + j[1] * j[1]);
                    C = Fo(x, (i - nt) / (et + 1)), S = Fo(w, (r - nt) / (et - 1));
                  }
                }
              }
              if (!F) n.moveTo(h + R, c + L);
              else if (C > Ha) {
                var gt = Fo(v, C), H = Fo(y, C), W = i1(T, D, R, L, i, gt, f), it = i1(b, B, k, P, i, H, f);
                n.moveTo(h + W.cx + W.x0, c + W.cy + W.y0), C < x && gt === H ? n.arc(h + W.cx, c + W.cy, C, Di(W.y0, W.x0), Di(it.y0, it.x0), !f) : (gt > 0 && n.arc(h + W.cx, c + W.cy, gt, Di(W.y0, W.x0), Di(W.y1, W.x1), !f), n.arc(h, c, i, Di(W.cy + W.y1, W.cx + W.x1), Di(it.cy + it.y1, it.cx + it.x1), !f), H > 0 && n.arc(h + it.cx, c + it.cy, H, Di(it.y1, it.x1), Di(it.y0, it.x0), !f));
              } else n.moveTo(h + R, c + L), n.arc(h, c, i, l, u, !f);
              if (!(r > Ha) || !F) n.lineTo(h + k, c + P);
              else if (S > Ha) {
                var gt = Fo(A, S), H = Fo(p, S), W = i1(k, P, b, B, r, -H, f), it = i1(R, L, T, D, r, -gt, f);
                n.lineTo(h + W.cx + W.x0, c + W.cy + W.y0), S < w && gt === H ? n.arc(h + W.cx, c + W.cy, S, Di(W.y0, W.x0), Di(it.y0, it.x0), !f) : (H > 0 && n.arc(h + W.cx, c + W.cy, H, Di(W.y0, W.x0), Di(W.y1, W.x1), !f), n.arc(h, c, r, Di(W.cy + W.y1, W.cx + W.x1), Di(it.cy + it.y1, it.cx + it.x1), f), gt > 0 && n.arc(h + it.cx, c + it.cy, gt, Di(it.y1, it.x1), Di(it.y0, it.x0), !f));
              } else n.lineTo(h + k, c + P), n.arc(h, c, r, u, l, f);
            }
            n.closePath();
          }
        }
      }
      var m1t = /* @__PURE__ */ function() {
        function n() {
          this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true, this.cornerRadius = 0;
        }
        return n;
      }(), Hi = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultShape = function() {
          return new m1t();
        }, t.prototype.buildPath = function(e, i) {
          y1t(e, i);
        }, t.prototype.isZeroArea = function() {
          return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
        }, t;
      }(Jt);
      Hi.prototype.type = "sector";
      var _1t = /* @__PURE__ */ function() {
        function n() {
          this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
        }
        return n;
      }(), Gp = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultShape = function() {
          return new _1t();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.cx, a = i.cy, o = Math.PI * 2;
          e.moveTo(r + i.r, a), e.arc(r, a, i.r, 0, o, false), e.moveTo(r + i.r0, a), e.arc(r, a, i.r0, 0, o, true);
        }, t;
      }(Jt);
      Gp.prototype.type = "ring";
      function I1t(n, t, e, i) {
        var r = [], a = [], o = [], s = [], l, u, h, c;
        if (i) {
          h = [1 / 0, 1 / 0], c = [-1 / 0, -1 / 0];
          for (var f = 0, g = n.length; f < g; f++) Gl(h, h, n[f]), Ul(c, c, n[f]);
          Gl(h, h, i[0]), Ul(c, c, i[1]);
        }
        for (var f = 0, g = n.length; f < g; f++) {
          var d = n[f];
          if (e) l = n[f ? f - 1 : g - 1], u = n[(f + 1) % g];
          else if (f === 0 || f === g - 1) {
            r.push(ws(n[f]));
            continue;
          } else l = n[f - 1], u = n[f + 1];
          rh(a, u, l), f_(a, a, t);
          var A = yb(d, l), p = yb(d, u), v = A + p;
          v !== 0 && (A /= v, p /= v), f_(o, a, -A), f_(s, a, p);
          var y = Sz([], d, o), m = Sz([], d, s);
          i && (Ul(y, y, h), Gl(y, y, c), Ul(m, m, h), Gl(m, m, c)), r.push(y), r.push(m);
        }
        return e && r.push(r.shift()), r;
      }
      function H5(n, t, e) {
        var i = t.smooth, r = t.points;
        if (r && r.length >= 2) {
          if (i) {
            var a = I1t(r, i, e, t.smoothConstraint);
            n.moveTo(r[0][0], r[0][1]);
            for (var o = r.length, s = 0; s < (e ? o : o - 1); s++) {
              var l = a[s * 2], u = a[s * 2 + 1], h = r[(s + 1) % o];
              n.bezierCurveTo(l[0], l[1], u[0], u[1], h[0], h[1]);
            }
          } else {
            n.moveTo(r[0][0], r[0][1]);
            for (var s = 1, c = r.length; s < c; s++) n.lineTo(r[s][0], r[s][1]);
          }
          e && n.closePath();
        }
      }
      var E1t = /* @__PURE__ */ function() {
        function n() {
          this.points = null, this.smooth = 0, this.smoothConstraint = null;
        }
        return n;
      }(), Yi = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultShape = function() {
          return new E1t();
        }, t.prototype.buildPath = function(e, i) {
          H5(e, i, true);
        }, t;
      }(Jt);
      Yi.prototype.type = "polygon";
      var x1t = /* @__PURE__ */ function() {
        function n() {
          this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
        }
        return n;
      }(), Wi = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new x1t();
        }, t.prototype.buildPath = function(e, i) {
          H5(e, i, false);
        }, t;
      }(Jt);
      Wi.prototype.type = "polyline";
      var w1t = {}, C1t = /* @__PURE__ */ function() {
        function n() {
          this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
        }
        return n;
      }(), Wn = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new C1t();
        }, t.prototype.buildPath = function(e, i) {
          var r, a, o, s;
          if (this.subPixelOptimize) {
            var l = a5(w1t, i, this.style);
            r = l.x1, a = l.y1, o = l.x2, s = l.y2;
          } else r = i.x1, a = i.y1, o = i.x2, s = i.y2;
          var u = i.percent;
          u !== 0 && (e.moveTo(r, a), u < 1 && (o = r * (1 - u) + o * u, s = a * (1 - u) + s * u), e.lineTo(o, s));
        }, t.prototype.pointAt = function(e) {
          var i = this.shape;
          return [i.x1 * (1 - e) + i.x2 * e, i.y1 * (1 - e) + i.y2 * e];
        }, t;
      }(Jt);
      Wn.prototype.type = "line";
      var _r = [], S1t = /* @__PURE__ */ function() {
        function n() {
          this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
        }
        return n;
      }();
      function Y5(n, t, e) {
        var i = n.cpx2, r = n.cpy2;
        return i != null || r != null ? [(e ? qz : Yn)(n.x1, n.cpx1, n.cpx2, n.x2, t), (e ? qz : Yn)(n.y1, n.cpy1, n.cpy2, n.y2, t)] : [(e ? Lb : si)(n.x1, n.cpx1, n.x2, t), (e ? Lb : si)(n.y1, n.cpy1, n.y2, t)];
      }
      var Up = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new S1t();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.x1, a = i.y1, o = i.x2, s = i.y2, l = i.cpx1, u = i.cpy1, h = i.cpx2, c = i.cpy2, f = i.percent;
          f !== 0 && (e.moveTo(r, a), h == null || c == null ? (f < 1 && (vp(r, l, o, f, _r), l = _r[1], o = _r[2], vp(a, u, s, f, _r), u = _r[1], s = _r[2]), e.quadraticCurveTo(l, u, o, s)) : (f < 1 && (ql(r, l, h, o, f, _r), l = _r[1], h = _r[2], o = _r[3], ql(a, u, c, s, f, _r), u = _r[1], c = _r[2], s = _r[3]), e.bezierCurveTo(l, u, h, c, o, s)));
        }, t.prototype.pointAt = function(e) {
          return Y5(this.shape, e, false);
        }, t.prototype.tangentAt = function(e) {
          var i = Y5(this.shape, e, true);
          return og(i, i);
        }, t;
      }(Jt);
      Up.prototype.type = "bezier-curve";
      var b1t = /* @__PURE__ */ function() {
        function n() {
          this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true;
        }
        return n;
      }(), r1 = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new b1t();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.cx, a = i.cy, o = Math.max(i.r, 0), s = i.startAngle, l = i.endAngle, u = i.clockwise, h = Math.cos(s), c = Math.sin(s);
          e.moveTo(h * o + r, c * o + a), e.arc(r, a, o, s, l, !u);
        }, t;
      }(Jt);
      r1.prototype.type = "arc";
      var Z2 = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "compound", e;
        }
        return t.prototype._updatePathDirty = function() {
          for (var e = this.shape.paths, i = this.shapeChanged(), r = 0; r < e.length; r++) i = i || e[r].shapeChanged();
          i && this.dirtyShape();
        }, t.prototype.beforeBrush = function() {
          this._updatePathDirty();
          for (var e = this.shape.paths || [], i = this.getGlobalScale(), r = 0; r < e.length; r++) e[r].path || e[r].createPathProxy(), e[r].path.setScale(i[0], i[1], e[r].segmentIgnoreThreshold);
        }, t.prototype.buildPath = function(e, i) {
          for (var r = i.paths || [], a = 0; a < r.length; a++) r[a].buildPath(e, r[a].shape, true);
        }, t.prototype.afterBrush = function() {
          for (var e = this.shape.paths || [], i = 0; i < e.length; i++) e[i].pathUpdated();
        }, t.prototype.getBoundingRect = function() {
          return this._updatePathDirty.call(this), Jt.prototype.getBoundingRect.call(this);
        }, t;
      }(Jt), W5 = function() {
        function n(t) {
          this.colorStops = t || [];
        }
        return n.prototype.addColorStop = function(t, e) {
          this.colorStops.push({ offset: t, color: e });
        }, n;
      }(), Vp = function(n) {
        V(t, n);
        function t(e, i, r, a, o, s) {
          var l = n.call(this, o) || this;
          return l.x = e == null ? 0 : e, l.y = i == null ? 0 : i, l.x2 = r == null ? 1 : r, l.y2 = a == null ? 0 : a, l.type = "linear", l.global = s || false, l;
        }
        return t;
      }(W5), X5 = function(n) {
        V(t, n);
        function t(e, i, r, a, o) {
          var s = n.call(this, a) || this;
          return s.x = e == null ? 0.5 : e, s.y = i == null ? 0.5 : i, s.r = r == null ? 0.5 : r, s.type = "radial", s.global = o || false, s;
        }
        return t;
      }(W5), Dh = [0, 0], Rh = [0, 0], a1 = new Ut(), o1 = new Ut(), s1 = function() {
        function n(t, e) {
          this._corners = [], this._axes = [], this._origin = [0, 0];
          for (var i = 0; i < 4; i++) this._corners[i] = new Ut();
          for (var i = 0; i < 2; i++) this._axes[i] = new Ut();
          t && this.fromBoundingRect(t, e);
        }
        return n.prototype.fromBoundingRect = function(t, e) {
          var i = this._corners, r = this._axes, a = t.x, o = t.y, s = a + t.width, l = o + t.height;
          if (i[0].set(a, o), i[1].set(s, o), i[2].set(s, l), i[3].set(a, l), e) for (var u = 0; u < 4; u++) i[u].transform(e);
          Ut.sub(r[0], i[1], i[0]), Ut.sub(r[1], i[3], i[0]), r[0].normalize(), r[1].normalize();
          for (var u = 0; u < 2; u++) this._origin[u] = r[u].dot(i[0]);
        }, n.prototype.intersect = function(t, e) {
          var i = true, r = !e;
          return a1.set(1 / 0, 1 / 0), o1.set(0, 0), !this._intersectCheckOneSide(this, t, a1, o1, r, 1) && (i = false, r) || !this._intersectCheckOneSide(t, this, a1, o1, r, -1) && (i = false, r) || r || Ut.copy(e, i ? a1 : o1), i;
        }, n.prototype._intersectCheckOneSide = function(t, e, i, r, a, o) {
          for (var s = true, l = 0; l < 2; l++) {
            var u = this._axes[l];
            if (this._getProjMinMaxOnAxis(l, t._corners, Dh), this._getProjMinMaxOnAxis(l, e._corners, Rh), Dh[1] < Rh[0] || Dh[0] > Rh[1]) {
              if (s = false, a) return s;
              var h = Math.abs(Rh[0] - Dh[1]), c = Math.abs(Dh[0] - Rh[1]);
              Math.min(h, c) > r.len() && (h < c ? Ut.scale(r, u, -h * o) : Ut.scale(r, u, c * o));
            } else if (i) {
              var h = Math.abs(Rh[0] - Dh[1]), c = Math.abs(Dh[0] - Rh[1]);
              Math.min(h, c) < i.len() && (h < c ? Ut.scale(i, u, h * o) : Ut.scale(i, u, -c * o));
            }
          }
          return s;
        }, n.prototype._getProjMinMaxOnAxis = function(t, e, i) {
          for (var r = this._axes[t], a = this._origin, o = e[0].dot(r) + a[t], s = o, l = o, u = 1; u < e.length; u++) {
            var h = e[u].dot(r) + a[t];
            s = Math.min(h, s), l = Math.max(h, l);
          }
          i[0] = s, i[1] = l;
        }, n;
      }(), B1t = [], T1t = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.notClear = true, e.incremental = true, e._displayables = [], e._temporaryDisplayables = [], e._cursor = 0, e;
        }
        return t.prototype.traverse = function(e, i) {
          e.call(i, this);
        }, t.prototype.useStyle = function() {
          this.style = {};
        }, t.prototype.getCursor = function() {
          return this._cursor;
        }, t.prototype.innerAfterBrush = function() {
          this._cursor = this._displayables.length;
        }, t.prototype.clearDisplaybles = function() {
          this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = false;
        }, t.prototype.clearTemporalDisplayables = function() {
          this._temporaryDisplayables = [];
        }, t.prototype.addDisplayable = function(e, i) {
          i ? this._temporaryDisplayables.push(e) : this._displayables.push(e), this.markRedraw();
        }, t.prototype.addDisplayables = function(e, i) {
          i = i || false;
          for (var r = 0; r < e.length; r++) this.addDisplayable(e[r], i);
        }, t.prototype.getDisplayables = function() {
          return this._displayables;
        }, t.prototype.getTemporalDisplayables = function() {
          return this._temporaryDisplayables;
        }, t.prototype.eachPendingDisplayable = function(e) {
          for (var i = this._cursor; i < this._displayables.length; i++) e && e(this._displayables[i]);
          for (var i = 0; i < this._temporaryDisplayables.length; i++) e && e(this._temporaryDisplayables[i]);
        }, t.prototype.update = function() {
          this.updateTransform();
          for (var e = this._cursor; e < this._displayables.length; e++) {
            var i = this._displayables[e];
            i.parent = this, i.update(), i.parent = null;
          }
          for (var e = 0; e < this._temporaryDisplayables.length; e++) {
            var i = this._temporaryDisplayables[e];
            i.parent = this, i.update(), i.parent = null;
          }
        }, t.prototype.getBoundingRect = function() {
          if (!this._rect) {
            for (var e = new Ht(1 / 0, 1 / 0, -1 / 0, -1 / 0), i = 0; i < this._displayables.length; i++) {
              var r = this._displayables[i], a = r.getBoundingRect().clone();
              r.needLocalTransform() && a.applyTransform(r.getLocalTransform(B1t)), e.union(a);
            }
            this._rect = e;
          }
          return this._rect;
        }, t.prototype.contain = function(e, i) {
          var r = this.transformCoordToLocal(e, i), a = this.getBoundingRect();
          if (a.contain(r[0], r[1])) for (var o = 0; o < this._displayables.length; o++) {
            var s = this._displayables[o];
            if (s.contain(e, i)) return true;
          }
          return false;
        }, t;
      }(ha), Z5 = le();
      function wg(n, t, e, i, r) {
        var a;
        if (t && t.ecModel) {
          var o = t.ecModel.getUpdatePayload();
          a = o && o.animation;
        }
        var s = t && t.isAnimationEnabled(), l = n === "update";
        if (s) {
          var u = void 0, h = void 0, c = void 0;
          i ? (u = Pt(i.duration, 200), h = Pt(i.easing, "cubicOut"), c = 0) : (u = t.getShallow(l ? "animationDurationUpdate" : "animationDuration"), h = t.getShallow(l ? "animationEasingUpdate" : "animationEasing"), c = t.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (h = a.easing), a.delay != null && (c = a.delay)), yt(c) && (c = c(e, r)), yt(u) && (u = u(e));
          var f = { duration: u || 0, delay: c, easing: h };
          return f;
        } else return null;
      }
      function K2(n, t, e, i, r, a, o) {
        var s = false, l;
        yt(r) ? (o = a, a = r, r = null) : _t(r) && (a = r.cb, o = r.during, s = r.isFrom, l = r.removeOpt, r = r.dataIndex);
        var u = n === "leave";
        u || t.stopAnimation("leave");
        var h = wg(n, i, r, u ? l || {} : null, i && i.getAnimationDelayParams ? i.getAnimationDelayParams(t, r) : null);
        if (h && h.duration > 0) {
          var c = h.duration, f = h.delay, g = h.easing, d = { duration: c, delay: f || 0, easing: g, done: a, force: !!a || !!o, setToFinal: !u, scope: n, during: o };
          s ? t.animateFrom(e, d) : t.animateTo(e, d);
        } else t.stopAnimation(), !s && t.attr(e), o && o(1), a && a();
      }
      function _e(n, t, e, i, r, a) {
        K2("update", n, t, e, i, r, a);
      }
      function nn(n, t, e, i, r, a) {
        K2("enter", n, t, e, i, r, a);
      }
      function Cg(n) {
        if (!n.__zr) return true;
        for (var t = 0; t < n.animators.length; t++) {
          var e = n.animators[t];
          if (e.scope === "leave") return true;
        }
        return false;
      }
      function Jl(n, t, e, i, r, a) {
        Cg(n) || K2("leave", n, t, e, i, r, a);
      }
      function K5(n, t, e, i) {
        n.removeTextContent(), n.removeTextGuideLine(), Jl(n, { style: { opacity: 0 } }, t, e, i);
      }
      function jp(n, t, e) {
        function i() {
          n.parent && n.parent.remove(n);
        }
        n.isGroup ? n.traverse(function(r) {
          r.isGroup || K5(r, t, e, i);
        }) : K5(n, t, e, i);
      }
      function Ya(n) {
        Z5(n).oldStyle = n.style;
      }
      function M1t(n) {
        return Z5(n).oldStyle;
      }
      var l1 = Math.max, u1 = Math.min, $2 = {};
      function D1t(n) {
        return Jt.extend(n);
      }
      var R1t = c1t;
      function L1t(n, t) {
        return R1t(n, t);
      }
      function Wa(n, t) {
        $2[n] = t;
      }
      function J2(n) {
        if ($2.hasOwnProperty(n)) return $2[n];
      }
      function h1(n, t, e, i) {
        var r = V5(n, t);
        return e && (i === "center" && (e = J5(e, r.getBoundingRect())), t4(r, e)), r;
      }
      function $5(n, t, e) {
        var i = new li({ style: { image: n, x: t.x, y: t.y, width: t.width, height: t.height }, onload: function(r) {
          if (e === "center") {
            var a = { width: r.width, height: r.height };
            i.setStyle(J5(t, a));
          }
        } });
        return i;
      }
      function J5(n, t) {
        var e = t.width / t.height, i = n.height * e, r;
        i <= n.width ? r = n.height : (i = n.width, r = i / e);
        var a = n.x + n.width / 2, o = n.y + n.height / 2;
        return { x: a - i / 2, y: o - r / 2, width: i, height: r };
      }
      var fa = f1t;
      function t4(n, t) {
        if (n.applyTransform) {
          var e = n.getBoundingRect(), i = e.calculateTransform(t);
          n.applyTransform(i);
        }
      }
      function Sg(n, t) {
        return a5(n, n, { lineWidth: t }), n;
      }
      function P1t(n) {
        return o5(n.shape, n.shape, n.style), n;
      }
      var c1 = Ch;
      function Lh(n, t) {
        for (var e = d_([]); n && n !== t; ) Ss(e, n.getLocalTransform(), e), n = n.parent;
        return e;
      }
      function Xa(n, t, e) {
        return t && !Mi(t) && (t = Ts.getLocalTransform(t)), e && (t = lg([], t)), di([], n, t);
      }
      function f1(n, t, e) {
        var i = t[4] === 0 || t[5] === 0 || t[0] === 0 ? 1 : Math.abs(2 * t[4] / t[0]), r = t[4] === 0 || t[5] === 0 || t[2] === 0 ? 1 : Math.abs(2 * t[4] / t[2]), a = [n === "left" ? -i : n === "right" ? i : 0, n === "top" ? -r : n === "bottom" ? r : 0];
        return a = Xa(a, t, e), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
      }
      function e4(n) {
        return !n.isGroup;
      }
      function N1t(n) {
        return n.shape != null;
      }
      function qp(n, t, e) {
        if (!n || !t) return;
        function i(o) {
          var s = {};
          return o.traverse(function(l) {
            e4(l) && l.anid && (s[l.anid] = l);
          }), s;
        }
        function r(o) {
          var s = { x: o.x, y: o.y, rotation: o.rotation };
          return N1t(o) && (s.shape = Y({}, o.shape)), s;
        }
        var a = i(n);
        t.traverse(function(o) {
          if (e4(o) && o.anid) {
            var s = a[o.anid];
            if (s) {
              var l = r(o);
              o.attr(r(s)), _e(o, l, e, Dt(o).dataIndex);
            }
          }
        });
      }
      function n4(n, t) {
        return Z(n, function(e) {
          var i = e[0];
          i = l1(i, t.x), i = u1(i, t.x + t.width);
          var r = e[1];
          return r = l1(r, t.y), r = u1(r, t.y + t.height), [i, r];
        });
      }
      function k1t(n, t) {
        var e = l1(n.x, t.x), i = u1(n.x + n.width, t.x + t.width), r = l1(n.y, t.y), a = u1(n.y + n.height, t.y + t.height);
        if (i >= e && a >= r) return { x: e, y: r, width: i - e, height: a - r };
      }
      function Hp(n, t, e) {
        var i = Y({ rectHover: true }, t), r = i.style = { strokeNoScale: true };
        if (e = e || { x: -1, y: -1, width: 2, height: 2 }, n) return n.indexOf("image://") === 0 ? (r.image = n.slice(8), Et(r, e), new li(i)) : h1(n.replace("path://", ""), i, e, "center");
      }
      function Yp(n, t, e, i, r) {
        for (var a = 0, o = r[r.length - 1]; a < r.length; a++) {
          var s = r[a];
          if (i4(n, t, e, i, s[0], s[1], o[0], o[1])) return true;
          o = s;
        }
      }
      function i4(n, t, e, i, r, a, o, s) {
        var l = e - n, u = i - t, h = o - r, c = s - a, f = tB(h, c, l, u);
        if (F1t(f)) return false;
        var g = n - r, d = t - a, A = tB(g, d, l, u) / f;
        if (A < 0 || A > 1) return false;
        var p = tB(g, d, h, c) / f;
        return !(p < 0 || p > 1);
      }
      function tB(n, t, e, i) {
        return n * i - e * t;
      }
      function F1t(n) {
        return n <= 1e-6 && n >= -1e-6;
      }
      function bg(n) {
        var t = n.itemTooltipOption, e = n.componentModel, i = n.itemName, r = ht(t) ? { formatter: t } : t, a = e.mainType, o = e.componentIndex, s = { componentType: a, name: i, $vars: ["name"] };
        s[a + "Index"] = o;
        var l = n.formatterParamsExtra;
        l && M(re(l), function(h) {
          ft(s, h) || (s[h] = l[h], s.$vars.push(h));
        });
        var u = Dt(n.el);
        u.componentMainType = a, u.componentIndex = o, u.tooltipConfig = { name: i, option: Et({ content: i, encodeHTMLContent: true, formatterParams: s }, r) };
      }
      function r4(n, t) {
        var e;
        n.isGroup && (e = t(n)), e || n.traverse(t);
      }
      function tu(n, t) {
        if (n) if (X(n)) for (var e = 0; e < n.length; e++) r4(n[e], t);
        else r4(n, t);
      }
      Wa("circle", ks), Wa("ellipse", n1), Wa("sector", Hi), Wa("ring", Gp), Wa("polygon", Yi), Wa("polyline", Wi), Wa("rect", ue), Wa("line", Wn), Wa("bezierCurve", Up), Wa("arc", r1);
      const Ph = Object.freeze(Object.defineProperty({ __proto__: null, Arc: r1, BezierCurve: Up, BoundingRect: Ht, Circle: ks, CompoundPath: Z2, Ellipse: n1, Group: Ct, Image: li, IncrementalDisplayable: T1t, Line: Wn, LinearGradient: Vp, OrientedBoundingRect: s1, Path: Jt, Point: Ut, Polygon: Yi, Polyline: Wi, RadialGradient: X5, Rect: ue, Ring: Gp, Sector: Hi, Text: ge, applyTransform: Xa, clipPointsByRect: n4, clipRectByRect: k1t, createIcon: Hp, extendPath: L1t, extendShape: D1t, getShapeClass: J2, getTransform: Lh, groupTransition: qp, initProps: nn, isElementRemoved: Cg, lineLineIntersect: i4, linePolygonIntersect: Yp, makeImage: $5, makePath: h1, mergePath: fa, registerShape: Wa, removeElement: Jl, removeElementWithFadeOut: jp, resizePath: t4, setTooltipConfig: bg, subPixelOptimize: c1, subPixelOptimizeLine: Sg, subPixelOptimizeRect: P1t, transformDirection: f1, traverseElements: tu, updateProps: _e }, Symbol.toStringTag, { value: "Module" }));
      var g1 = {};
      function a4(n, t) {
        for (var e = 0; e < qi.length; e++) {
          var i = qi[e], r = t[i], a = n.ensureState(i);
          a.style = a.style || {}, a.style.text = r;
        }
        var o = n.currentStates.slice();
        n.clearStates(true), n.setStyle({ text: t.normal }), n.useStates(o, true);
      }
      function eB(n, t, e) {
        var i = n.labelFetcher, r = n.labelDataIndex, a = n.labelDimIndex, o = t.normal, s;
        i && (s = i.getFormattedLabel(r, "normal", null, a, o && o.get("formatter"), e != null ? { interpolatedValue: e } : null)), s == null && (s = yt(n.defaultText) ? n.defaultText(r, n, e) : n.defaultText);
        for (var l = { normal: s }, u = 0; u < qi.length; u++) {
          var h = qi[u], c = t[h];
          l[h] = Pt(i ? i.getFormattedLabel(r, h, null, a, c && c.get("formatter")) : null, s);
        }
        return l;
      }
      function vi(n, t, e, i) {
        e = e || g1;
        for (var r = n instanceof ge, a = false, o = 0; o < Np.length; o++) {
          var s = t[Np[o]];
          if (s && s.getShallow("show")) {
            a = true;
            break;
          }
        }
        var l = r ? n : n.getTextContent();
        if (a) {
          r || (l || (l = new ge(), n.setTextContent(l)), n.stateProxy && (l.stateProxy = n.stateProxy));
          var u = eB(e, t), h = t.normal, c = !!h.getShallow("show"), f = Ke(h, i && i.normal, e, false, !r);
          f.text = u.normal, r || n.setTextConfig(d1(h, e, false));
          for (var o = 0; o < qi.length; o++) {
            var g = qi[o], s = t[g];
            if (s) {
              var d = l.ensureState(g), A = !!Pt(s.getShallow("show"), c);
              if (A !== c && (d.ignore = !A), d.style = Ke(s, i && i[g], e, true, !r), d.style.text = u[g], !r) {
                var p = n.ensureState(g);
                p.textConfig = d1(s, e, true);
              }
            }
          }
          l.silent = !!h.getShallow("silent"), l.style.x != null && (f.x = l.style.x), l.style.y != null && (f.y = l.style.y), l.ignore = !c, l.useStyle(f), l.dirty(), e.enableTextSetter && (Bg(l).setLabelText = function(v) {
            var y = eB(e, t, v);
            a4(l, y);
          });
        } else l && (l.ignore = true);
        n.dirty();
      }
      function Xn(n, t) {
        t = t || "label";
        for (var e = { normal: n.getModel(t) }, i = 0; i < qi.length; i++) {
          var r = qi[i];
          e[r] = n.getModel([r, t]);
        }
        return e;
      }
      function Ke(n, t, e, i, r) {
        var a = {};
        return Q1t(a, n, e, i, r), t && Y(a, t), a;
      }
      function d1(n, t, e) {
        t = t || {};
        var i = {}, r, a = n.getShallow("rotate"), o = Pt(n.getShallow("distance"), e ? null : 5), s = n.getShallow("offset");
        return r = n.getShallow("position") || (e ? null : "inside"), r === "outside" && (r = t.defaultOutsidePosition || "top"), r != null && (i.position = r), s != null && (i.offset = s), a != null && (a *= Math.PI / 180, i.rotation = a), o != null && (i.distance = o), i.outsideFill = n.get("color") === "inherit" ? t.inheritColor || null : "auto", i;
      }
      function Q1t(n, t, e, i, r) {
        e = e || g1;
        var a = t.ecModel, o = a && a.option.textStyle, s = O1t(t), l;
        if (s) {
          l = {};
          for (var u in s) if (s.hasOwnProperty(u)) {
            var h = t.getModel(["rich", u]);
            u4(l[u] = {}, h, o, e, i, r, false, true);
          }
        }
        l && (n.rich = l);
        var c = t.get("overflow");
        c && (n.overflow = c);
        var f = t.get("minMargin");
        f != null && (n.margin = f), u4(n, t, o, e, i, r, true, false);
      }
      function O1t(n) {
        for (var t; n && n !== n.ecModel; ) {
          var e = (n.option || g1).rich;
          if (e) {
            t = t || {};
            for (var i = re(e), r = 0; r < i.length; r++) {
              var a = i[r];
              t[a] = 1;
            }
          }
          n = n.parentModel;
        }
        return t;
      }
      var o4 = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], s4 = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], l4 = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
      function u4(n, t, e, i, r, a, o, s) {
        e = !r && e || g1;
        var l = i && i.inheritColor, u = t.getShallow("color"), h = t.getShallow("textBorderColor"), c = Pt(t.getShallow("opacity"), e.opacity);
        (u === "inherit" || u === "auto") && (u === "auto" && Rn("color: 'auto'", "color: 'inherit'"), l ? u = l : u = null), (h === "inherit" || h === "auto") && (h === "auto" && Rn("color: 'auto'", "color: 'inherit'"), l ? h = l : h = null), a || (u = u || e.color, h = h || e.textBorderColor), u != null && (n.fill = u), h != null && (n.stroke = h);
        var f = Pt(t.getShallow("textBorderWidth"), e.textBorderWidth);
        f != null && (n.lineWidth = f);
        var g = Pt(t.getShallow("textBorderType"), e.textBorderType);
        g != null && (n.lineDash = g);
        var d = Pt(t.getShallow("textBorderDashOffset"), e.textBorderDashOffset);
        d != null && (n.lineDashOffset = d), !r && c == null && !s && (c = i && i.defaultOpacity), c != null && (n.opacity = c), !r && !a && n.fill == null && i.inheritColor && (n.fill = i.inheritColor);
        for (var A = 0; A < o4.length; A++) {
          var p = o4[A], v = Pt(t.getShallow(p), e[p]);
          v != null && (n[p] = v);
        }
        for (var A = 0; A < s4.length; A++) {
          var p = s4[A], v = t.getShallow(p);
          v != null && (n[p] = v);
        }
        if (n.verticalAlign == null) {
          var y = t.getShallow("baseline");
          y != null && (n.verticalAlign = y);
        }
        if (!o || !i.disableBox) {
          for (var A = 0; A < l4.length; A++) {
            var p = l4[A], v = t.getShallow(p);
            v != null && (n[p] = v);
          }
          var m = t.getShallow("borderType");
          m != null && (n.borderDash = m), (n.backgroundColor === "auto" || n.backgroundColor === "inherit") && l && (n.backgroundColor === "auto" && Rn("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), n.backgroundColor = l), (n.borderColor === "auto" || n.borderColor === "inherit") && l && (n.borderColor === "auto" && Rn("borderColor: 'auto'", "borderColor: 'inherit'"), n.borderColor = l);
        }
      }
      function nB(n, t) {
        var e = t && t.getModel("textStyle");
        return Ga([n.fontStyle || e && e.getShallow("fontStyle") || "", n.fontWeight || e && e.getShallow("fontWeight") || "", (n.fontSize || e && e.getShallow("fontSize") || 12) + "px", n.fontFamily || e && e.getShallow("fontFamily") || "sans-serif"].join(" "));
      }
      var Bg = le();
      function h4(n, t, e, i) {
        if (n) {
          var r = Bg(n);
          r.prevValue = r.value, r.value = e;
          var a = t.normal;
          r.valueAnimation = a.get("valueAnimation"), r.valueAnimation && (r.precision = a.get("precision"), r.defaultInterpolatedText = i, r.statesModels = t);
        }
      }
      function c4(n, t, e, i, r) {
        var a = Bg(n);
        if (!a.valueAnimation || a.prevValue === a.value) return;
        var o = a.defaultInterpolatedText, s = Pt(a.interpolatedValue, a.prevValue), l = a.value;
        function u(h) {
          var c = jG(e, a.precision, s, l, h);
          a.interpolatedValue = h === 1 ? null : c;
          var f = eB({ labelDataIndex: t, labelFetcher: r, defaultText: o ? o(c) : c + "" }, a.statesModels, c);
          a4(n, f);
        }
        n.percent = 0, (a.prevValue == null ? nn : _e)(n, { percent: 1 }, i, t, null, u);
      }
      var z1t = ["textStyle", "color"], iB = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], rB = new ge(), G1t = function() {
        function n() {
        }
        return n.prototype.getTextColor = function(t) {
          var e = this.ecModel;
          return this.getShallow("color") || (!t && e ? e.get(z1t) : null);
        }, n.prototype.getFont = function() {
          return nB({ fontStyle: this.getShallow("fontStyle"), fontWeight: this.getShallow("fontWeight"), fontSize: this.getShallow("fontSize"), fontFamily: this.getShallow("fontFamily") }, this.ecModel);
        }, n.prototype.getTextRect = function(t) {
          for (var e = { text: t, verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline") }, i = 0; i < iB.length; i++) e[iB[i]] = this.getShallow(iB[i]);
          return rB.useStyle(e), rB.update(), rB.getBoundingRect();
        }, n;
      }(), f4 = [["lineWidth", "width"], ["stroke", "color"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["lineDash", "type"], ["lineDashOffset", "dashOffset"], ["lineCap", "cap"], ["lineJoin", "join"], ["miterLimit"]], U1t = vh(f4), V1t = function() {
        function n() {
        }
        return n.prototype.getLineStyle = function(t) {
          return U1t(this, t);
        }, n;
      }(), g4 = [["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["lineDash", "borderType"], ["lineDashOffset", "borderDashOffset"], ["lineCap", "borderCap"], ["lineJoin", "borderJoin"], ["miterLimit", "borderMiterLimit"]], j1t = vh(g4), q1t = function() {
        function n() {
        }
        return n.prototype.getItemStyle = function(t, e) {
          return j1t(this, t, e);
        }, n;
      }(), Te = function() {
        function n(t, e, i) {
          this.parentModel = e, this.ecModel = i, this.option = t;
        }
        return n.prototype.init = function(t, e, i) {
        }, n.prototype.mergeOption = function(t, e) {
          qt(this.option, t, true);
        }, n.prototype.get = function(t, e) {
          return t == null ? this.option : this._doGet(this.parsePath(t), !e && this.parentModel);
        }, n.prototype.getShallow = function(t, e) {
          var i = this.option, r = i == null ? i : i[t];
          if (r == null && !e) {
            var a = this.parentModel;
            a && (r = a.getShallow(t));
          }
          return r;
        }, n.prototype.getModel = function(t, e) {
          var i = t != null, r = i ? this.parsePath(t) : null, a = i ? this._doGet(r) : this.option;
          return e = e || this.parentModel && this.parentModel.getModel(this.resolveParentPath(r)), new n(a, e, this.ecModel);
        }, n.prototype.isEmpty = function() {
          return this.option == null;
        }, n.prototype.restoreData = function() {
        }, n.prototype.clone = function() {
          var t = this.constructor;
          return new t(xt(this.option));
        }, n.prototype.parsePath = function(t) {
          return typeof t == "string" ? t.split(".") : t;
        }, n.prototype.resolveParentPath = function(t) {
          return t;
        }, n.prototype.isAnimationEnabled = function() {
          if (!ee.node && this.option) {
            if (this.option.animation != null) return !!this.option.animation;
            if (this.parentModel) return this.parentModel.isAnimationEnabled();
          }
        }, n.prototype._doGet = function(t, e) {
          var i = this.option;
          if (!t) return i;
          for (var r = 0; r < t.length && !(t[r] && (i = i && typeof i == "object" ? i[t[r]] : null, i == null)); r++) ;
          return i == null && e && (i = e._doGet(this.resolveParentPath(t), e.parentModel)), i;
        }, n;
      }();
      v2(Te), t_t(Te), Mn(Te, V1t), Mn(Te, q1t), Mn(Te, a_t), Mn(Te, G1t);
      var H1t = Math.round(Math.random() * 10);
      function Tg(n) {
        return [n || "", H1t++].join("_");
      }
      function Y1t(n) {
        var t = {};
        n.registerSubTypeDefaulter = function(e, i) {
          var r = Ro(e);
          t[r.main] = i;
        }, n.determineSubType = function(e, i) {
          var r = i.type;
          if (!r) {
            var a = Ro(e).main;
            n.hasSubTypes(e) && t[a] && (r = t[a](i));
          }
          return r;
        };
      }
      function W1t(n, t) {
        n.topologicalTravel = function(a, o, s, l) {
          if (!a.length) return;
          var u = e(o), h = u.graph, c = u.noEntryList, f = {};
          for (M(a, function(y) {
            f[y] = true;
          }); c.length; ) {
            var g = c.pop(), d = h[g], A = !!f[g];
            A && (s.call(l, g, d.originalDeps.slice()), delete f[g]), M(d.successor, A ? v : p);
          }
          M(f, function() {
            var y = "";
            throw y = vr("Circular dependency may exists: ", f, a, o), new Error(y);
          });
          function p(y) {
            h[y].entryCount--, h[y].entryCount === 0 && c.push(y);
          }
          function v(y) {
            f[y] = true, p(y);
          }
        };
        function e(a) {
          var o = {}, s = [];
          return M(a, function(l) {
            var u = i(o, l), h = u.originalDeps = t(l), c = r(h, a);
            u.entryCount = c.length, u.entryCount === 0 && s.push(l), M(c, function(f) {
              Wt(u.predecessor, f) < 0 && u.predecessor.push(f);
              var g = i(o, f);
              Wt(g.successor, f) < 0 && g.successor.push(l);
            });
          }), { graph: o, noEntryList: s };
        }
        function i(a, o) {
          return a[o] || (a[o] = { predecessor: [], successor: [] }), a[o];
        }
        function r(a, o) {
          var s = [];
          return M(a, function(l) {
            Wt(o, l) >= 0 && s.push(l);
          }), s;
        }
      }
      function eu(n, t) {
        return qt(qt({}, n, true), t, true);
      }
      const X1t = { time: { month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] }, legend: { selector: { all: "All", inverse: "Inv" } }, toolbox: { brush: { title: { rect: "Box Select", polygon: "Lasso Select", lineX: "Horizontally Select", lineY: "Vertically Select", keep: "Keep Selections", clear: "Clear Selections" } }, dataView: { title: "Data View", lang: ["Data View", "Close", "Refresh"] }, dataZoom: { title: { zoom: "Zoom", back: "Zoom Reset" } }, magicType: { title: { line: "Switch to Line Chart", bar: "Switch to Bar Chart", stack: "Stack", tiled: "Tile" } }, restore: { title: "Restore" }, saveAsImage: { title: "Save as Image", lang: ["Right Click to Save Image"] } }, series: { typeNames: { pie: "Pie chart", bar: "Bar chart", line: "Line chart", scatter: "Scatter plot", effectScatter: "Ripple scatter plot", radar: "Radar chart", tree: "Tree", treemap: "Treemap", boxplot: "Boxplot", candlestick: "Candlestick", k: "K line chart", heatmap: "Heat map", map: "Map", parallel: "Parallel coordinate map", lines: "Line graph", graph: "Relationship graph", sankey: "Sankey diagram", funnel: "Funnel chart", gauge: "Gauge", pictorialBar: "Pictorial bar", themeRiver: "Theme River Map", sunburst: "Sunburst", custom: "Custom chart", chart: "Chart" } }, aria: { general: { withTitle: 'This is a chart about "{title}"', withoutTitle: "This is a chart" }, series: { single: { prefix: "", withName: " with type {seriesType} named {seriesName}.", withoutName: " with type {seriesType}." }, multiple: { prefix: ". It consists of {seriesCount} series count.", withName: " The {seriesId} series is a {seriesType} representing {seriesName}.", withoutName: " The {seriesId} series is a {seriesType}.", separator: { middle: "", end: "" } } }, data: { allData: "The data is as follows: ", partialData: "The first {displayCnt} items are: ", withName: "the data for {name} is {value}", withoutName: "{value}", separator: { middle: ", ", end: ". " } } } }, Z1t = { time: { month: ["", "", "", "", "", "", "", "", "", "", "", ""], monthAbbr: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], dayOfWeek: ["", "", "", "", "", "", ""], dayOfWeekAbbr: ["", "", "", "", "", "", ""] }, legend: { selector: { all: "", inverse: "" } }, toolbox: { brush: { title: { rect: "", polygon: "", lineX: "", lineY: "", keep: "", clear: "" } }, dataView: { title: "", lang: ["", "", ""] }, dataZoom: { title: { zoom: "", back: "" } }, magicType: { title: { line: "", bar: "", stack: "", tiled: "" } }, restore: { title: "" }, saveAsImage: { title: "", lang: [""] } }, series: { typeNames: { pie: "", bar: "", line: "", scatter: "", effectScatter: "", radar: "", tree: "", treemap: "", boxplot: "", candlestick: "K", k: "K", heatmap: "", map: "", parallel: "", lines: "", graph: "", sankey: "", funnel: "", gauge: "", pictorialBar: "", themeRiver: "", sunburst: "", custom: "", chart: "" } }, aria: { general: { withTitle: "{title}", withoutTitle: "" }, series: { single: { prefix: "", withName: "{seriesType}{seriesName}", withoutName: "{seriesType}" }, multiple: { prefix: "{seriesCount}", withName: "{seriesId}{seriesName}{seriesType}", withoutName: "{seriesId}{seriesType}", separator: { middle: "", end: "" } } }, data: { allData: "", partialData: "{displayCnt}", withName: "{name}{value}", withoutName: "{value}", separator: { middle: "", end: "" } } } };
      var A1 = "ZH", aB = "EN", Mg = aB, p1 = {}, oB = {}, d4 = ee.domSupported ? function() {
        var n = (document.documentElement.lang || navigator.language || navigator.browserLanguage || Mg).toUpperCase();
        return n.indexOf(A1) > -1 ? A1 : Mg;
      }() : Mg;
      function A4(n, t) {
        n = n.toUpperCase(), oB[n] = new Te(t), p1[n] = t;
      }
      function K1t(n) {
        if (ht(n)) {
          var t = p1[n.toUpperCase()] || {};
          return n === A1 || n === aB ? xt(t) : qt(xt(t), xt(p1[Mg]), false);
        } else return qt(xt(n), xt(p1[Mg]), false);
      }
      function sB(n) {
        return oB[n];
      }
      function $1t() {
        return oB[Mg];
      }
      A4(aB, X1t), A4(A1, Z1t);
      var lB = 1e3, uB = lB * 60, Wp = uB * 60, ga = Wp * 24, p4 = ga * 365, Xp = { year: "{yyyy}", month: "{MMM}", day: "{d}", hour: "{HH}:{mm}", minute: "{HH}:{mm}", second: "{HH}:{mm}:{ss}", millisecond: "{HH}:{mm}:{ss} {SSS}", none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}" }, v1 = "{yyyy}-{MM}-{dd}", v4 = { year: "{yyyy}", month: "{yyyy}-{MM}", day: v1, hour: v1 + " " + Xp.hour, minute: v1 + " " + Xp.minute, second: v1 + " " + Xp.second, millisecond: Xp.none }, hB = ["year", "month", "day", "hour", "minute", "second", "millisecond"], y4 = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
      function nu(n, t) {
        return n += "", "0000".substr(0, t - n.length) + n;
      }
      function Dg(n) {
        switch (n) {
          case "half-year":
          case "quarter":
            return "month";
          case "week":
          case "half-week":
            return "day";
          case "half-day":
          case "quarter-day":
            return "hour";
          default:
            return n;
        }
      }
      function J1t(n) {
        return n === Dg(n);
      }
      function tIt(n) {
        switch (n) {
          case "year":
          case "month":
            return "day";
          case "millisecond":
            return "millisecond";
          default:
            return "second";
        }
      }
      function y1(n, t, e, i) {
        var r = Do(n), a = r[cB(e)](), o = r[Rg(e)]() + 1, s = Math.floor((o - 1) / 3) + 1, l = r[m1(e)](), u = r["get" + (e ? "UTC" : "") + "Day"](), h = r[Zp(e)](), c = (h - 1) % 12 + 1, f = r[_1(e)](), g = r[I1(e)](), d = r[E1(e)](), A = h >= 12 ? "pm" : "am", p = A.toUpperCase(), v = i instanceof Te ? i : sB(i || d4) || $1t(), y = v.getModel("time"), m = y.get("month"), _ = y.get("monthAbbr"), E = y.get("dayOfWeek"), I = y.get("dayOfWeekAbbr");
        return (t || "").replace(/{a}/g, A + "").replace(/{A}/g, p + "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, nu(a % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, m[o - 1]).replace(/{MMM}/g, _[o - 1]).replace(/{MM}/g, nu(o, 2)).replace(/{M}/g, o + "").replace(/{dd}/g, nu(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, E[u]).replace(/{ee}/g, I[u]).replace(/{e}/g, u + "").replace(/{HH}/g, nu(h, 2)).replace(/{H}/g, h + "").replace(/{hh}/g, nu(c + "", 2)).replace(/{h}/g, c + "").replace(/{mm}/g, nu(f, 2)).replace(/{m}/g, f + "").replace(/{ss}/g, nu(g, 2)).replace(/{s}/g, g + "").replace(/{SSS}/g, nu(d, 3)).replace(/{S}/g, d + "");
      }
      function eIt(n, t, e, i, r) {
        var a = null;
        if (ht(e)) a = e;
        else if (yt(e)) a = e(n.value, t, { level: n.level });
        else {
          var o = Y({}, Xp);
          if (n.level > 0) for (var s = 0; s < hB.length; ++s) o[hB[s]] = "{primary|" + o[hB[s]] + "}";
          var l = e ? e.inherit === false ? e : Et(e, o) : o, u = m4(n.value, r);
          if (l[u]) a = l[u];
          else if (l.inherit) {
            for (var h = y4.indexOf(u), s = h - 1; s >= 0; --s) if (l[u]) {
              a = l[u];
              break;
            }
            a = a || o.none;
          }
          if (X(a)) {
            var c = n.level == null ? 0 : n.level >= 0 ? n.level : a.length + n.level;
            c = Math.min(c, a.length - 1), a = a[c];
          }
        }
        return y1(new Date(n.value), a, r, i);
      }
      function m4(n, t) {
        var e = Do(n), i = e[Rg(t)]() + 1, r = e[m1(t)](), a = e[Zp(t)](), o = e[_1(t)](), s = e[I1(t)](), l = e[E1(t)](), u = l === 0, h = u && s === 0, c = h && o === 0, f = c && a === 0, g = f && r === 1, d = g && i === 1;
        return d ? "year" : g ? "month" : f ? "day" : c ? "hour" : h ? "minute" : u ? "second" : "millisecond";
      }
      function _4(n, t, e) {
        var i = pe(n) ? Do(n) : n;
        switch (t = t || m4(n, e), t) {
          case "year":
            return i[cB(e)]();
          case "half-year":
            return i[Rg(e)]() >= 6 ? 1 : 0;
          case "quarter":
            return Math.floor((i[Rg(e)]() + 1) / 4);
          case "month":
            return i[Rg(e)]();
          case "day":
            return i[m1(e)]();
          case "half-day":
            return i[Zp(e)]() / 24;
          case "hour":
            return i[Zp(e)]();
          case "minute":
            return i[_1(e)]();
          case "second":
            return i[I1(e)]();
          case "millisecond":
            return i[E1(e)]();
        }
      }
      function cB(n) {
        return n ? "getUTCFullYear" : "getFullYear";
      }
      function Rg(n) {
        return n ? "getUTCMonth" : "getMonth";
      }
      function m1(n) {
        return n ? "getUTCDate" : "getDate";
      }
      function Zp(n) {
        return n ? "getUTCHours" : "getHours";
      }
      function _1(n) {
        return n ? "getUTCMinutes" : "getMinutes";
      }
      function I1(n) {
        return n ? "getUTCSeconds" : "getSeconds";
      }
      function E1(n) {
        return n ? "getUTCMilliseconds" : "getMilliseconds";
      }
      function nIt(n) {
        return n ? "setUTCFullYear" : "setFullYear";
      }
      function I4(n) {
        return n ? "setUTCMonth" : "setMonth";
      }
      function E4(n) {
        return n ? "setUTCDate" : "setDate";
      }
      function x4(n) {
        return n ? "setUTCHours" : "setHours";
      }
      function w4(n) {
        return n ? "setUTCMinutes" : "setMinutes";
      }
      function C4(n) {
        return n ? "setUTCSeconds" : "setSeconds";
      }
      function S4(n) {
        return n ? "setUTCMilliseconds" : "setMilliseconds";
      }
      function b4(n) {
        if (!g2(n)) return ht(n) ? n : "-";
        var t = (n + "").split(".");
        return t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : "");
      }
      function B4(n, t) {
        return n = (n || "").toLowerCase().replace(/-(.)/g, function(e, i) {
          return i.toUpperCase();
        }), t && n && (n = n.charAt(0).toUpperCase() + n.slice(1)), n;
      }
      var Lg = Ab;
      function fB(n, t, e) {
        var i = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
        function r(h) {
          return h && Ga(h) ? h : "-";
        }
        function a(h) {
          return !!(h != null && !isNaN(h) && isFinite(h));
        }
        var o = t === "time", s = n instanceof Date;
        if (o || s) {
          var l = o ? Do(n) : n;
          if (isNaN(+l)) {
            if (s) return "-";
          } else return y1(l, i, e);
        }
        if (t === "ordinal") return o_(n) ? r(n) : pe(n) && a(n) ? n + "" : "-";
        var u = Ms(n);
        return a(u) ? b4(u) : o_(n) ? r(n) : typeof n == "boolean" ? n + "" : "-";
      }
      var T4 = ["a", "b", "c", "d", "e", "f", "g"], gB = function(n, t) {
        return "{" + n + (t == null ? "" : t) + "}";
      };
      function M4(n, t, e) {
        X(t) || (t = [t]);
        var i = t.length;
        if (!i) return "";
        for (var r = t[0].$vars || [], a = 0; a < r.length; a++) {
          var o = T4[a];
          n = n.replace(gB(o), gB(o, 0));
        }
        for (var s = 0; s < i; s++) for (var l = 0; l < r.length; l++) {
          var u = t[s][r[l]];
          n = n.replace(gB(T4[l], s), e ? pr(u) : u);
        }
        return n;
      }
      function iIt(n, t, e) {
        return M(t, function(i, r) {
          n = n.replace("{" + r + "}", i);
        }), n;
      }
      function rIt(n, t) {
        var e = ht(n) ? { color: n, extraCssText: t } : n || {}, i = e.color, r = e.type;
        t = e.extraCssText;
        var a = e.renderMode || "html";
        if (!i) return "";
        if (a === "html") return r === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + pr(i) + ";" + (t || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + pr(i) + ";" + (t || "") + '"></span>';
        var o = e.markerId || "markerX";
        return { renderMode: a, content: "{" + o + "|}  ", style: r === "subItem" ? { width: 4, height: 4, borderRadius: 2, backgroundColor: i } : { width: 10, height: 10, borderRadius: 5, backgroundColor: i } };
      }
      function Nh(n, t) {
        return t = t || "transparent", ht(n) ? n : _t(n) && n.colorStops && (n.colorStops[0] || {}).color || t;
      }
      function x1(n, t) {
        if (t === "_blank" || t === "blank") {
          var e = window.open();
          e.opener = null, e.location.href = n;
        } else window.open(n, t);
      }
      var w1 = M, D4 = ["left", "right", "top", "bottom", "width", "height"], kh = [["width", "left", "right"], ["height", "top", "bottom"]];
      function dB(n, t, e, i, r) {
        var a = 0, o = 0;
        i == null && (i = 1 / 0), r == null && (r = 1 / 0);
        var s = 0;
        t.eachChild(function(l, u) {
          var h = l.getBoundingRect(), c = t.childAt(u + 1), f = c && c.getBoundingRect(), g, d;
          if (n === "horizontal") {
            var A = h.width + (f ? -f.x + h.x : 0);
            g = a + A, g > i || l.newline ? (a = 0, g = A, o += s + e, s = h.height) : s = Math.max(s, h.height);
          } else {
            var p = h.height + (f ? -f.y + h.y : 0);
            d = o + p, d > r || l.newline ? (a += s + e, o = 0, d = p, s = h.width) : s = Math.max(s, h.width);
          }
          l.newline || (l.x = a, l.y = o, l.markRedraw(), n === "horizontal" ? a = g + e : o = d + e);
        });
      }
      var Fh = dB;
      Ot(dB, "vertical"), Ot(dB, "horizontal");
      function aIt(n, t, e) {
        var i = t.width, r = t.height, a = ot(n.left, i), o = ot(n.top, r), s = ot(n.right, i), l = ot(n.bottom, r);
        return (isNaN(a) || isNaN(parseFloat(n.left))) && (a = 0), (isNaN(s) || isNaN(parseFloat(n.right))) && (s = i), (isNaN(o) || isNaN(parseFloat(n.top))) && (o = 0), (isNaN(l) || isNaN(parseFloat(n.bottom))) && (l = r), e = Lg(e || 0), { width: Math.max(s - a - e[1] - e[3], 0), height: Math.max(l - o - e[0] - e[2], 0) };
      }
      function Gn(n, t, e) {
        e = Lg(e || 0);
        var i = t.width, r = t.height, a = ot(n.left, i), o = ot(n.top, r), s = ot(n.right, i), l = ot(n.bottom, r), u = ot(n.width, i), h = ot(n.height, r), c = e[2] + e[0], f = e[1] + e[3], g = n.aspect;
        switch (isNaN(u) && (u = i - s - f - a), isNaN(h) && (h = r - l - c - o), g != null && (isNaN(u) && isNaN(h) && (g > i / r ? u = i * 0.8 : h = r * 0.8), isNaN(u) && (u = g * h), isNaN(h) && (h = u / g)), isNaN(a) && (a = i - s - u - f), isNaN(o) && (o = r - l - h - c), n.left || n.right) {
          case "center":
            a = i / 2 - u / 2 - e[3];
            break;
          case "right":
            a = i - u - f;
            break;
        }
        switch (n.top || n.bottom) {
          case "middle":
          case "center":
            o = r / 2 - h / 2 - e[0];
            break;
          case "bottom":
            o = r - h - c;
            break;
        }
        a = a || 0, o = o || 0, isNaN(u) && (u = i - f - a - (s || 0)), isNaN(h) && (h = r - c - o - (l || 0));
        var d = new Ht(a + e[3], o + e[0], u, h);
        return d.margin = e, d;
      }
      function C1(n, t, e, i, r, a) {
        var o = !r || !r.hv || r.hv[0], s = !r || !r.hv || r.hv[1], l = r && r.boundingMode || "all";
        if (a = a || n, a.x = n.x, a.y = n.y, !o && !s) return false;
        var u;
        if (l === "raw") u = n.type === "group" ? new Ht(0, 0, +t.width || 0, +t.height || 0) : n.getBoundingRect();
        else if (u = n.getBoundingRect(), n.needLocalTransform()) {
          var h = n.getLocalTransform();
          u = u.clone(), u.applyTransform(h);
        }
        var c = Gn(Et({ width: u.width, height: u.height }, t), e, i), f = o ? c.x - u.x : 0, g = s ? c.y - u.y : 0;
        return l === "raw" ? (a.x = f, a.y = g) : (a.x += f, a.y += g), a === n && n.markRedraw(), true;
      }
      function oIt(n, t) {
        return n[kh[t][0]] != null || n[kh[t][1]] != null && n[kh[t][2]] != null;
      }
      function Kp(n) {
        var t = n.layoutMode || n.constructor.layoutMode;
        return _t(t) ? t : t ? { type: t } : null;
      }
      function iu(n, t, e) {
        var i = e && e.ignoreSize;
        !X(i) && (i = [i, i]);
        var r = o(kh[0], 0), a = o(kh[1], 1);
        u(kh[0], n, r), u(kh[1], n, a);
        function o(h, c) {
          var f = {}, g = 0, d = {}, A = 0, p = 2;
          if (w1(h, function(m) {
            d[m] = n[m];
          }), w1(h, function(m) {
            s(t, m) && (f[m] = d[m] = t[m]), l(f, m) && g++, l(d, m) && A++;
          }), i[c]) return l(t, h[1]) ? d[h[2]] = null : l(t, h[2]) && (d[h[1]] = null), d;
          if (A === p || !g) return d;
          if (g >= p) return f;
          for (var v = 0; v < h.length; v++) {
            var y = h[v];
            if (!s(f, y) && s(n, y)) {
              f[y] = n[y];
              break;
            }
          }
          return f;
        }
        function s(h, c) {
          return h.hasOwnProperty(c);
        }
        function l(h, c) {
          return h[c] != null && h[c] !== "auto";
        }
        function u(h, c, f) {
          w1(h, function(g) {
            c[g] = f[g];
          });
        }
      }
      function Pg(n) {
        return R4({}, n);
      }
      function R4(n, t) {
        return t && n && w1(D4, function(e) {
          t.hasOwnProperty(e) && (n[e] = t[e]);
        }), n;
      }
      var sIt = le(), ne = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this, e, i, r) || this;
          return a.uid = Tg("ec_cpt_model"), a;
        }
        return t.prototype.init = function(e, i, r) {
          this.mergeDefaultAndTheme(e, r);
        }, t.prototype.mergeDefaultAndTheme = function(e, i) {
          var r = Kp(this), a = r ? Pg(e) : {}, o = i.getTheme();
          qt(e, o.get(this.mainType)), qt(e, this.getDefaultOption()), r && iu(e, a, r);
        }, t.prototype.mergeOption = function(e, i) {
          qt(this.option, e, true);
          var r = Kp(this);
          r && iu(this.option, e, r);
        }, t.prototype.optionUpdated = function(e, i) {
        }, t.prototype.getDefaultOption = function() {
          var e = this.constructor;
          if (!Kmt(e)) return e.defaultOption;
          var i = sIt(this);
          if (!i.defaultOption) {
            for (var r = [], a = e; a; ) {
              var o = a.prototype.defaultOption;
              o && r.push(o), a = a.superClass;
            }
            for (var s = {}, l = r.length - 1; l >= 0; l--) s = qt(s, r[l], true);
            i.defaultOption = s;
          }
          return i.defaultOption;
        }, t.prototype.getReferringComponents = function(e, i) {
          var r = e + "Index", a = e + "Id";
          return Dp(this.ecModel, e, { index: this.get(r, true), id: this.get(a, true) }, i);
        }, t.prototype.getBoxLayoutParams = function() {
          var e = this;
          return { left: e.get("left"), top: e.get("top"), right: e.get("right"), bottom: e.get("bottom"), width: e.get("width"), height: e.get("height") };
        }, t.prototype.getZLevelKey = function() {
          return "";
        }, t.prototype.setZLevel = function(e) {
          this.option.zlevel = e;
        }, t.protoInitialize = function() {
          var e = t.prototype;
          e.type = "component", e.id = "", e.name = "", e.mainType = "", e.subType = "", e.componentIndex = 0;
        }(), t;
      }(Te);
      HG(ne, Te), G_(ne), Y1t(ne), W1t(ne, lIt);
      function lIt(n) {
        var t = [];
        return M(ne.getClassesByMainType(n), function(e) {
          t = t.concat(e.dependencies || e.prototype.dependencies || []);
        }), t = Z(t, function(e) {
          return Ro(e).main;
        }), n !== "dataset" && Wt(t, "dataset") <= 0 && t.unshift("dataset"), t;
      }
      var L4 = "";
      typeof navigator != "undefined" && (L4 = navigator.platform || "");
      var Ng = "rgba(0, 0, 0, 0.2)";
      const uIt = { darkMode: "auto", colorBy: "series", color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"], gradientColor: ["#f6efa6", "#d88273", "#bf444c"], aria: { decal: { decals: [{ color: Ng, dashArrayX: [1, 0], dashArrayY: [2, 5], symbolSize: 1, rotation: Math.PI / 6 }, { color: Ng, symbol: "circle", dashArrayX: [[8, 8], [0, 8, 8, 0]], dashArrayY: [6, 0], symbolSize: 0.8 }, { color: Ng, dashArrayX: [1, 0], dashArrayY: [4, 3], rotation: -Math.PI / 4 }, { color: Ng, dashArrayX: [[6, 6], [0, 6, 6, 0]], dashArrayY: [6, 0] }, { color: Ng, dashArrayX: [[1, 0], [1, 6]], dashArrayY: [1, 0, 6, 0], rotation: Math.PI / 4 }, { color: Ng, symbol: "triangle", dashArrayX: [[9, 9], [0, 9, 9, 0]], dashArrayY: [7, 2], symbolSize: 0.75 }] } }, textStyle: { fontFamily: L4.match(/^Win/) ? "Microsoft YaHei" : "sans-serif", fontSize: 12, fontStyle: "normal", fontWeight: "normal" }, blendMode: null, stateAnimation: { duration: 300, easing: "cubicOut" }, animation: "auto", animationDuration: 1e3, animationDurationUpdate: 500, animationEasing: "cubicInOut", animationEasingUpdate: "cubicInOut", animationThreshold: 2e3, progressiveThreshold: 3e3, progressive: 400, hoverLayerThreshold: 3e3, useUTC: false };
      var AB = dt(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), da = "original", Ri = "arrayRows", Aa = "objectRows", Qo = "keyedColumns", Fs = "typedArray", P4 = "unknown", Oo = "column", kg = "row", yi = { Must: 1, Might: 2, Not: 3 }, N4 = le();
      function hIt(n) {
        N4(n).datasetMap = dt();
      }
      function k4(n, t, e) {
        var i = {}, r = vB(t);
        if (!r || !n) return i;
        var a = [], o = [], s = t.ecModel, l = N4(s).datasetMap, u = r.uid + "_" + e.seriesLayoutBy, h, c;
        n = n.slice(), M(n, function(A, p) {
          var v = _t(A) ? A : n[p] = { name: A };
          v.type === "ordinal" && h == null && (h = p, c = d(v)), i[v.name] = [];
        });
        var f = l.get(u) || l.set(u, { categoryWayDim: c, valueWayDim: 0 });
        M(n, function(A, p) {
          var v = A.name, y = d(A);
          if (h == null) {
            var m = f.valueWayDim;
            g(i[v], m, y), g(o, m, y), f.valueWayDim += y;
          } else if (h === p) g(i[v], 0, y), g(a, 0, y);
          else {
            var m = f.categoryWayDim;
            g(i[v], m, y), g(o, m, y), f.categoryWayDim += y;
          }
        });
        function g(A, p, v) {
          for (var y = 0; y < v; y++) A.push(p + y);
        }
        function d(A) {
          var p = A.dimsDef;
          return p ? p.length : 1;
        }
        return a.length && (i.itemName = a), o.length && (i.seriesName = o), i;
      }
      function pB(n, t, e) {
        var i = {}, r = vB(n);
        if (!r) return i;
        var a = t.sourceFormat, o = t.dimensionsDefine, s;
        (a === Aa || a === Qo) && M(o, function(h, c) {
          (_t(h) ? h.name : h) === "name" && (s = c);
        });
        var l = function() {
          for (var h = {}, c = {}, f = [], g = 0, d = Math.min(5, e); g < d; g++) {
            var A = Q4(t.data, a, t.seriesLayoutBy, o, t.startIndex, g);
            f.push(A);
            var p = A === yi.Not;
            if (p && h.v == null && g !== s && (h.v = g), (h.n == null || h.n === h.v || !p && f[h.n] === yi.Not) && (h.n = g), v(h) && f[h.n] !== yi.Not) return h;
            p || (A === yi.Might && c.v == null && g !== s && (c.v = g), (c.n == null || c.n === c.v) && (c.n = g));
          }
          function v(y) {
            return y.v != null && y.n != null;
          }
          return v(h) ? h : v(c) ? c : null;
        }();
        if (l) {
          i.value = [l.v];
          var u = s != null ? s : l.n;
          i.itemName = [u], i.seriesName = [u];
        }
        return i;
      }
      function vB(n) {
        var t = n.get("data", true);
        if (!t) return Dp(n.ecModel, "dataset", { index: n.get("datasetIndex", true), id: n.get("datasetId", true) }, Ln).models[0];
      }
      function cIt(n) {
        return !n.get("transform", true) && !n.get("fromTransformResult", true) ? [] : Dp(n.ecModel, "dataset", { index: n.get("fromDatasetIndex", true), id: n.get("fromDatasetId", true) }, Ln).models;
      }
      function F4(n, t) {
        return Q4(n.data, n.sourceFormat, n.seriesLayoutBy, n.dimensionsDefine, n.startIndex, t);
      }
      function Q4(n, t, e, i, r, a) {
        var o, s = 5;
        if (Ui(n)) return yi.Not;
        var l, u;
        if (i) {
          var h = i[a];
          _t(h) ? (l = h.name, u = h.type) : ht(h) && (l = h);
        }
        if (u != null) return u === "ordinal" ? yi.Must : yi.Not;
        if (t === Ri) {
          var c = n;
          if (e === kg) {
            for (var f = c[a], g = 0; g < (f || []).length && g < s; g++) if ((o = _(f[r + g])) != null) return o;
          } else for (var g = 0; g < c.length && g < s; g++) {
            var d = c[r + g];
            if (d && (o = _(d[a])) != null) return o;
          }
        } else if (t === Aa) {
          var A = n;
          if (!l) return yi.Not;
          for (var g = 0; g < A.length && g < s; g++) {
            var p = A[g];
            if (p && (o = _(p[l])) != null) return o;
          }
        } else if (t === Qo) {
          var v = n;
          if (!l) return yi.Not;
          var f = v[l];
          if (!f || Ui(f)) return yi.Not;
          for (var g = 0; g < f.length && g < s; g++) if ((o = _(f[g])) != null) return o;
        } else if (t === da) for (var y = n, g = 0; g < y.length && g < s; g++) {
          var p = y[g], m = pg(p);
          if (!X(m)) return yi.Not;
          if ((o = _(m[a])) != null) return o;
        }
        function _(E) {
          var I = ht(E);
          if (E != null && Number.isFinite(Number(E)) && E !== "") return I ? yi.Might : yi.Not;
          if (I && E !== "-") return yi.Must;
        }
        return yi.Not;
      }
      var yB = dt();
      function fIt(n, t) {
        It(yB.get(n) == null && t), yB.set(n, t);
      }
      function gIt(n, t, e) {
        var i = yB.get(t);
        if (!i) return e;
        var r = i(n);
        if (!r) return e;
        if (true) for (var a = 0; a < r.length; a++) It(vg(r[a]));
        return e.concat(r);
      }
      var O4 = le(), dIt = le(), mB = function() {
        function n() {
        }
        return n.prototype.getColorFromPalette = function(t, e, i) {
          var r = Qe(this.get("color", true)), a = this.get("colorLayer", true);
          return z4(this, O4, r, a, t, e, i);
        }, n.prototype.clearColorPalette = function() {
          pIt(this, O4);
        }, n;
      }();
      function _B(n, t, e, i) {
        var r = Qe(n.get(["aria", "decal", "decals"]));
        return z4(n, dIt, r, null, t, e, i);
      }
      function AIt(n, t) {
        for (var e = n.length, i = 0; i < e; i++) if (n[i].length > t) return n[i];
        return n[e - 1];
      }
      function z4(n, t, e, i, r, a, o) {
        a = a || n;
        var s = t(a), l = s.paletteIdx || 0, u = s.paletteNameMap = s.paletteNameMap || {};
        if (u.hasOwnProperty(r)) return u[r];
        var h = o == null || !i ? e : AIt(i, o);
        if (h = h || e, !(!h || !h.length)) {
          var c = h[l];
          return r && (u[r] = c), s.paletteIdx = (l + 1) % h.length, c;
        }
      }
      function pIt(n, t) {
        t(n).paletteIdx = 0, t(n).paletteNameMap = {};
      }
      var S1, $p, G4, IB = "\0_ec_inner", U4 = 1, vIt = { grid: "GridComponent", polar: "PolarComponent", geo: "GeoComponent", singleAxis: "SingleAxisComponent", parallel: "ParallelComponent", calendar: "CalendarComponent", graphic: "GraphicComponent", toolbox: "ToolboxComponent", tooltip: "TooltipComponent", axisPointer: "AxisPointerComponent", brush: "BrushComponent", title: "TitleComponent", timeline: "TimelineComponent", markPoint: "MarkPointComponent", markLine: "MarkLineComponent", markArea: "MarkAreaComponent", legend: "LegendComponent", dataZoom: "DataZoomComponent", visualMap: "VisualMapComponent", xAxis: "GridComponent", yAxis: "GridComponent", angleAxis: "PolarComponent", radiusAxis: "PolarComponent" }, yIt = { line: "LineChart", bar: "BarChart", pie: "PieChart", scatter: "ScatterChart", radar: "RadarChart", map: "MapChart", tree: "TreeChart", treemap: "TreemapChart", graph: "GraphChart", gauge: "GaugeChart", funnel: "FunnelChart", parallel: "ParallelChart", sankey: "SankeyChart", boxplot: "BoxplotChart", candlestick: "CandlestickChart", effectScatter: "EffectScatterChart", lines: "LinesChart", heatmap: "HeatmapChart", pictorialBar: "PictorialBarChart", themeRiver: "ThemeRiverChart", sunburst: "SunburstChart", custom: "CustomChart" }, b1 = {};
      function mIt(n) {
        M(n, function(t, e) {
          if (!ne.hasClass(e)) {
            var i = vIt[e];
            i && !b1[i] && (Ai("Component " + e + ` is used but not imported.
import { ` + i + ` } from 'echarts/components';
echarts.use([` + i + "]);"), b1[i] = true);
          }
        });
      }
      var EB = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.init = function(e, i, r, a, o, s) {
          a = a || {}, this.option = null, this._theme = new Te(a), this._locale = new Te(o), this._optionManager = s;
        }, t.prototype.setOption = function(e, i, r) {
          It(e != null, "option is null/undefined"), It(e[IB] !== U4, "please use chart.getOption()");
          var a = q4(i);
          this._optionManager.setOption(e, r, a), this._resetOption(null, a);
        }, t.prototype.resetOption = function(e, i) {
          return this._resetOption(e, q4(i));
        }, t.prototype._resetOption = function(e, i) {
          var r = false, a = this._optionManager;
          if (!e || e === "recreate") {
            var o = a.mountOption(e === "recreate");
            mIt(o), !this.option || e === "recreate" ? G4(this, o) : (this.restoreData(), this._mergeOption(o, i)), r = true;
          }
          if ((e === "timeline" || e === "media") && this.restoreData(), !e || e === "recreate" || e === "timeline") {
            var s = a.getTimelineOption(this);
            s && (r = true, this._mergeOption(s, i));
          }
          if (!e || e === "recreate" || e === "media") {
            var l = a.getMediaOption(this);
            l.length && M(l, function(u) {
              r = true, this._mergeOption(u, i);
            }, this);
          }
          return r;
        }, t.prototype.mergeOption = function(e) {
          this._mergeOption(e, null);
        }, t.prototype._mergeOption = function(e, i) {
          var r = this.option, a = this._componentsMap, o = this._componentsCount, s = [], l = dt(), u = i && i.replaceMergeMainTypeMap;
          hIt(this), M(e, function(c, f) {
            c != null && (ne.hasClass(f) ? f && (s.push(f), l.set(f, true)) : r[f] = r[f] == null ? xt(c) : qt(r[f], c, true));
          }), u && u.each(function(c, f) {
            ne.hasClass(f) && !l.get(f) && (s.push(f), l.set(f, true));
          }), ne.topologicalTravel(s, ne.getAllClassMainTypes(), h, this);
          function h(c) {
            var f = gIt(this, c, Qe(e[c])), g = a.get(c), d = g ? u && u.get(c) ? "replaceMerge" : "normalMerge" : "replaceAll", A = OG(g, f, d);
            Umt(A, c, ne), r[c] = null, a.set(c, null), o.set(c, 0);
            var p = [], v = [], y = 0, m, _;
            M(A, function(E, I) {
              var x = E.existing, w = E.newOption;
              if (!w) x && (x.mergeOption({}, this), x.optionUpdated({}, false));
              else {
                var C = c === "series", S = ne.getClass(c, E.keyInfo.subType, !C);
                if (!S) {
                  if (true) {
                    var b = E.keyInfo.subType, B = yIt[b];
                    b1[b] || (b1[b] = true, Ai(B ? "Series " + b + ` is used but not imported.
import { ` + B + ` } from 'echarts/charts';
echarts.use([` + B + "]);" : "Unknown series " + b));
                  }
                  return;
                }
                if (c === "tooltip") {
                  if (m) {
                    _ || (un("Currently only one tooltip component is allowed."), _ = true);
                    return;
                  }
                  m = true;
                }
                if (x && x.constructor === S) x.name = E.keyInfo.name, x.mergeOption(w, this), x.optionUpdated(w, false);
                else {
                  var T = Y({ componentIndex: I }, E.keyInfo);
                  x = new S(w, this, this, T), Y(x, T), E.brandNew && (x.__requireNewView = true), x.init(w, this, this), x.optionUpdated(null, true);
                }
              }
              x ? (p.push(x.option), v.push(x), y++) : (p.push(void 0), v.push(void 0));
            }, this), r[c] = p, a.set(c, v), o.set(c, y), c === "series" && S1(this);
          }
          this._seriesIndices || S1(this);
        }, t.prototype.getOption = function() {
          var e = xt(this.option);
          return M(e, function(i, r) {
            if (ne.hasClass(r)) {
              for (var a = Qe(i), o = a.length, s = false, l = o - 1; l >= 0; l--) a[l] && !vg(a[l]) ? s = true : (a[l] = null, !s && o--);
              a.length = o, e[r] = a;
            }
          }), delete e[IB], e;
        }, t.prototype.getTheme = function() {
          return this._theme;
        }, t.prototype.getLocaleModel = function() {
          return this._locale;
        }, t.prototype.setUpdatePayload = function(e) {
          this._payload = e;
        }, t.prototype.getUpdatePayload = function() {
          return this._payload;
        }, t.prototype.getComponent = function(e, i) {
          var r = this._componentsMap.get(e);
          if (r) {
            var a = r[i || 0];
            if (a) return a;
            if (i == null) {
              for (var o = 0; o < r.length; o++) if (r[o]) return r[o];
            }
          }
        }, t.prototype.queryComponents = function(e) {
          var i = e.mainType;
          if (!i) return [];
          var r = e.index, a = e.id, o = e.name, s = this._componentsMap.get(i);
          if (!s || !s.length) return [];
          var l;
          return r != null ? (l = [], M(Qe(r), function(u) {
            s[u] && l.push(s[u]);
          })) : a != null ? l = V4("id", a, s) : o != null ? l = V4("name", o, s) : l = Ne(s, function(u) {
            return !!u;
          }), j4(l, e);
        }, t.prototype.findComponents = function(e) {
          var i = e.query, r = e.mainType, a = s(i), o = a ? this.queryComponents(a) : Ne(this._componentsMap.get(r), function(u) {
            return !!u;
          });
          return l(j4(o, e));
          function s(u) {
            var h = r + "Index", c = r + "Id", f = r + "Name";
            return u && (u[h] != null || u[c] != null || u[f] != null) ? { mainType: r, index: u[h], id: u[c], name: u[f] } : null;
          }
          function l(u) {
            return e.filter ? Ne(u, e.filter) : u;
          }
        }, t.prototype.eachComponent = function(e, i, r) {
          var a = this._componentsMap;
          if (yt(e)) {
            var o = i, s = e;
            a.each(function(c, f) {
              for (var g = 0; c && g < c.length; g++) {
                var d = c[g];
                d && s.call(o, f, d, d.componentIndex);
              }
            });
          } else for (var l = ht(e) ? a.get(e) : _t(e) ? this.findComponents(e) : null, u = 0; l && u < l.length; u++) {
            var h = l[u];
            h && i.call(r, h, h.componentIndex);
          }
        }, t.prototype.getSeriesByName = function(e) {
          var i = zn(e, null);
          return Ne(this._componentsMap.get("series"), function(r) {
            return !!r && i != null && r.name === i;
          });
        }, t.prototype.getSeriesByIndex = function(e) {
          return this._componentsMap.get("series")[e];
        }, t.prototype.getSeriesByType = function(e) {
          return Ne(this._componentsMap.get("series"), function(i) {
            return !!i && i.subType === e;
          });
        }, t.prototype.getSeries = function() {
          return Ne(this._componentsMap.get("series"), function(e) {
            return !!e;
          });
        }, t.prototype.getSeriesCount = function() {
          return this._componentsCount.get("series");
        }, t.prototype.eachSeries = function(e, i) {
          $p(this), M(this._seriesIndices, function(r) {
            var a = this._componentsMap.get("series")[r];
            e.call(i, a, r);
          }, this);
        }, t.prototype.eachRawSeries = function(e, i) {
          M(this._componentsMap.get("series"), function(r) {
            r && e.call(i, r, r.componentIndex);
          });
        }, t.prototype.eachSeriesByType = function(e, i, r) {
          $p(this), M(this._seriesIndices, function(a) {
            var o = this._componentsMap.get("series")[a];
            o.subType === e && i.call(r, o, a);
          }, this);
        }, t.prototype.eachRawSeriesByType = function(e, i, r) {
          return M(this.getSeriesByType(e), i, r);
        }, t.prototype.isSeriesFiltered = function(e) {
          return $p(this), this._seriesIndicesMap.get(e.componentIndex) == null;
        }, t.prototype.getCurrentSeriesIndices = function() {
          return (this._seriesIndices || []).slice();
        }, t.prototype.filterSeries = function(e, i) {
          $p(this);
          var r = [];
          M(this._seriesIndices, function(a) {
            var o = this._componentsMap.get("series")[a];
            e.call(i, o, a) && r.push(a);
          }, this), this._seriesIndices = r, this._seriesIndicesMap = dt(r);
        }, t.prototype.restoreData = function(e) {
          S1(this);
          var i = this._componentsMap, r = [];
          i.each(function(a, o) {
            ne.hasClass(o) && r.push(o);
          }), ne.topologicalTravel(r, ne.getAllClassMainTypes(), function(a) {
            M(i.get(a), function(o) {
              o && (a !== "series" || !_It(o, e)) && o.restoreData();
            });
          });
        }, t.internalField = function() {
          S1 = function(e) {
            var i = e._seriesIndices = [];
            M(e._componentsMap.get("series"), function(r) {
              r && i.push(r.componentIndex);
            }), e._seriesIndicesMap = dt(i);
          }, $p = function(e) {
            if (!e._seriesIndices) throw new Error("Option should contains series.");
          }, G4 = function(e, i) {
            e.option = {}, e.option[IB] = U4, e._componentsMap = dt({ series: [] }), e._componentsCount = dt();
            var r = i.aria;
            _t(r) && r.enabled == null && (r.enabled = true), IIt(i, e._theme.option), qt(i, uIt, false), e._mergeOption(i, null);
          };
        }(), t;
      }(Te);
      function _It(n, t) {
        if (t) {
          var e = t.seriesIndex, i = t.seriesId, r = t.seriesName;
          return e != null && n.componentIndex !== e || i != null && n.id !== i || r != null && n.name !== r;
        }
      }
      function IIt(n, t) {
        var e = n.color && !n.colorLayer;
        M(t, function(i, r) {
          r === "colorLayer" && e || ne.hasClass(r) || (typeof i == "object" ? n[r] = n[r] ? qt(n[r], i, false) : xt(i) : n[r] == null && (n[r] = i));
        });
      }
      function V4(n, t, e) {
        if (X(t)) {
          var i = dt();
          return M(t, function(a) {
            if (a != null) {
              var o = zn(a, null);
              o != null && i.set(a, true);
            }
          }), Ne(e, function(a) {
            return a && i.get(a[n]);
          });
        } else {
          var r = zn(t, null);
          return Ne(e, function(a) {
            return a && r != null && a[n] === r;
          });
        }
      }
      function j4(n, t) {
        return t.hasOwnProperty("subType") ? Ne(n, function(e) {
          return e && e.subType === t.subType;
        }) : n;
      }
      function q4(n) {
        var t = dt();
        return n && M(Qe(n.replaceMerge), function(e) {
          It(ne.hasClass(e), '"' + e + '" is not valid component main type in "replaceMerge"'), t.set(e, true);
        }), { replaceMergeMainTypeMap: t };
      }
      Mn(EB, mB);
      var EIt = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isSSR", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getOption", "getId", "updateLabelLayout"], H4 = /* @__PURE__ */ function() {
        function n(t) {
          M(EIt, function(e) {
            this[e] = ct(t[e], t);
          }, this);
        }
        return n;
      }(), xB = {}, Fg = function() {
        function n() {
          this._coordinateSystems = [];
        }
        return n.prototype.create = function(t, e) {
          var i = [];
          M(xB, function(r, a) {
            var o = r.create(t, e);
            i = i.concat(o || []);
          }), this._coordinateSystems = i;
        }, n.prototype.update = function(t, e) {
          M(this._coordinateSystems, function(i) {
            i.update && i.update(t, e);
          });
        }, n.prototype.getCoordinateSystems = function() {
          return this._coordinateSystems.slice();
        }, n.register = function(t, e) {
          xB[t] = e;
        }, n.get = function(t) {
          return xB[t];
        }, n;
      }(), xIt = /^(min|max)?(.+)$/, wIt = function() {
        function n(t) {
          this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = t;
        }
        return n.prototype.setOption = function(t, e, i) {
          t && (M(Qe(t.series), function(o) {
            o && o.data && Ui(o.data) && l_(o.data);
          }), M(Qe(t.dataset), function(o) {
            o && o.source && Ui(o.source) && l_(o.source);
          })), t = xt(t);
          var r = this._optionBackup, a = CIt(t, e, !r);
          this._newBaseOption = a.baseOption, r ? (a.timelineOptions.length && (r.timelineOptions = a.timelineOptions), a.mediaList.length && (r.mediaList = a.mediaList), a.mediaDefault && (r.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
        }, n.prototype.mountOption = function(t) {
          var e = this._optionBackup;
          return this._timelineOptions = e.timelineOptions, this._mediaList = e.mediaList, this._mediaDefault = e.mediaDefault, this._currentMediaIndices = [], xt(t ? e.baseOption : this._newBaseOption);
        }, n.prototype.getTimelineOption = function(t) {
          var e, i = this._timelineOptions;
          if (i.length) {
            var r = t.getComponent("timeline");
            r && (e = xt(i[r.getCurrentIndex()]));
          }
          return e;
        }, n.prototype.getMediaOption = function(t) {
          var e = this._api.getWidth(), i = this._api.getHeight(), r = this._mediaList, a = this._mediaDefault, o = [], s = [];
          if (!r.length && !a) return s;
          for (var l = 0, u = r.length; l < u; l++) SIt(r[l].query, e, i) && o.push(l);
          return !o.length && a && (o = [-1]), o.length && !BIt(o, this._currentMediaIndices) && (s = Z(o, function(h) {
            return xt(h === -1 ? a.option : r[h].option);
          })), this._currentMediaIndices = o, s;
        }, n;
      }();
      function CIt(n, t, e) {
        var i = [], r, a, o = n.baseOption, s = n.timeline, l = n.options, u = n.media, h = !!n.media, c = !!(l || s || o && o.timeline);
        o ? (a = o, a.timeline || (a.timeline = s)) : ((c || h) && (n.options = n.media = null), a = n), h && (X(u) ? M(u, function(g) {
          g && !g.option && _t(g.query) && _t(g.query.option) && Ai("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), g && g.option && (g.query ? i.push(g) : r || (r = g));
        }) : Ai("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), f(a), M(l, function(g) {
          return f(g);
        }), M(i, function(g) {
          return f(g.option);
        });
        function f(g) {
          M(t, function(d) {
            d(g, e);
          });
        }
        return { baseOption: a, timelineOptions: l || [], mediaDefault: r, mediaList: i };
      }
      function SIt(n, t, e) {
        var i = { width: t, height: e, aspectratio: t / e }, r = true;
        return M(n, function(a, o) {
          var s = o.match(xIt);
          if (!(!s || !s[1] || !s[2])) {
            var l = s[1], u = s[2].toLowerCase();
            bIt(i[u], a, l) || (r = false);
          }
        }), r;
      }
      function bIt(n, t, e) {
        return e === "min" ? n >= t : e === "max" ? n <= t : n === t;
      }
      function BIt(n, t) {
        return n.join(",") === t.join(",");
      }
      var pa = M, Jp = _t, Y4 = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
      function wB(n) {
        var t = n && n.itemStyle;
        if (t) for (var e = 0, i = Y4.length; e < i; e++) {
          var r = Y4[e], a = t.normal, o = t.emphasis;
          a && a[r] && (Rn("itemStyle.normal." + r, r), n[r] = n[r] || {}, n[r].normal ? qt(n[r].normal, a[r]) : n[r].normal = a[r], a[r] = null), o && o[r] && (Rn("itemStyle.emphasis." + r, "emphasis." + r), n[r] = n[r] || {}, n[r].emphasis ? qt(n[r].emphasis, o[r]) : n[r].emphasis = o[r], o[r] = null);
        }
      }
      function Li(n, t, e) {
        if (n && n[t] && (n[t].normal || n[t].emphasis)) {
          var i = n[t].normal, r = n[t].emphasis;
          i && (qa("'normal' hierarchy in " + t + " has been removed since 4.0. All style properties are configured in " + t + " directly now."), e ? (n[t].normal = n[t].emphasis = null, Et(n[t], i)) : n[t] = i), r && (qa(t + ".emphasis has been changed to emphasis." + t + " since 4.0"), n.emphasis = n.emphasis || {}, n.emphasis[t] = r, r.focus && (n.emphasis.focus = r.focus), r.blurScope && (n.emphasis.blurScope = r.blurScope));
        }
      }
      function tv(n) {
        Li(n, "itemStyle"), Li(n, "lineStyle"), Li(n, "areaStyle"), Li(n, "label"), Li(n, "labelLine"), Li(n, "upperLabel"), Li(n, "edgeLabel");
      }
      function Pn(n, t) {
        var e = Jp(n) && n[t], i = Jp(e) && e.textStyle;
        if (i) {
          qa("textStyle hierarchy in " + t + " has been removed since 4.0. All textStyle properties are configured in " + t + " directly now.");
          for (var r = 0, a = QG.length; r < a; r++) {
            var o = QG[r];
            i.hasOwnProperty(o) && (e[o] = i[o]);
          }
        }
      }
      function va(n) {
        n && (tv(n), Pn(n, "label"), n.emphasis && Pn(n.emphasis, "label"));
      }
      function TIt(n) {
        if (Jp(n)) {
          wB(n), tv(n), Pn(n, "label"), Pn(n, "upperLabel"), Pn(n, "edgeLabel"), n.emphasis && (Pn(n.emphasis, "label"), Pn(n.emphasis, "upperLabel"), Pn(n.emphasis, "edgeLabel"));
          var t = n.markPoint;
          t && (wB(t), va(t));
          var e = n.markLine;
          e && (wB(e), va(e));
          var i = n.markArea;
          i && va(i);
          var r = n.data;
          if (n.type === "graph") {
            r = r || n.nodes;
            var a = n.links || n.edges;
            if (a && !Ui(a)) for (var o = 0; o < a.length; o++) va(a[o]);
            M(n.categories, function(u) {
              tv(u);
            });
          }
          if (r && !Ui(r)) for (var o = 0; o < r.length; o++) va(r[o]);
          if (t = n.markPoint, t && t.data) for (var s = t.data, o = 0; o < s.length; o++) va(s[o]);
          if (e = n.markLine, e && e.data) for (var l = e.data, o = 0; o < l.length; o++) X(l[o]) ? (va(l[o][0]), va(l[o][1])) : va(l[o]);
          n.type === "gauge" ? (Pn(n, "axisLabel"), Pn(n, "title"), Pn(n, "detail")) : n.type === "treemap" ? (Li(n.breadcrumb, "itemStyle"), M(n.levels, function(u) {
            tv(u);
          })) : n.type === "tree" && tv(n.leaves);
        }
      }
      function Qs(n) {
        return X(n) ? n : n ? [n] : [];
      }
      function W4(n) {
        return (X(n) ? n[0] : n) || {};
      }
      function MIt(n, t) {
        pa(Qs(n.series), function(i) {
          Jp(i) && TIt(i);
        });
        var e = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
        t && e.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), pa(e, function(i) {
          pa(Qs(n[i]), function(r) {
            r && (Pn(r, "axisLabel"), Pn(r.axisPointer, "label"));
          });
        }), pa(Qs(n.parallel), function(i) {
          var r = i && i.parallelAxisDefault;
          Pn(r, "axisLabel"), Pn(r && r.axisPointer, "label");
        }), pa(Qs(n.calendar), function(i) {
          Li(i, "itemStyle"), Pn(i, "dayLabel"), Pn(i, "monthLabel"), Pn(i, "yearLabel");
        }), pa(Qs(n.radar), function(i) {
          Pn(i, "name"), i.name && i.axisName == null && (i.axisName = i.name, delete i.name, qa("name property in radar component has been changed to axisName")), i.nameGap != null && i.axisNameGap == null && (i.axisNameGap = i.nameGap, delete i.nameGap, qa("nameGap property in radar component has been changed to axisNameGap")), pa(i.indicator, function(r) {
            r.text && Rn("text", "name", "radar.indicator");
          });
        }), pa(Qs(n.geo), function(i) {
          Jp(i) && (va(i), pa(Qs(i.regions), function(r) {
            va(r);
          }));
        }), pa(Qs(n.timeline), function(i) {
          va(i), Li(i, "label"), Li(i, "itemStyle"), Li(i, "controlStyle", true);
          var r = i.data;
          X(r) && M(r, function(a) {
            _t(a) && (Li(a, "label"), Li(a, "itemStyle"));
          });
        }), pa(Qs(n.toolbox), function(i) {
          Li(i, "iconStyle"), pa(i.feature, function(r) {
            Li(r, "iconStyle");
          });
        }), Pn(W4(n.axisPointer), "label"), Pn(W4(n.tooltip).axisPointer, "label");
      }
      function DIt(n, t) {
        for (var e = t.split(","), i = n, r = 0; r < e.length && (i = i && i[e[r]], i != null); r++) ;
        return i;
      }
      function RIt(n, t, e, i) {
        for (var r = t.split(","), a = n, o, s = 0; s < r.length - 1; s++) o = r[s], a[o] == null && (a[o] = {}), a = a[o];
        a[r[s]] == null && (a[r[s]] = e);
      }
      function X4(n) {
        n && M(LIt, function(t) {
          t[0] in n && !(t[1] in n) && (n[t[1]] = n[t[0]]);
        });
      }
      var LIt = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], PIt = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], CB = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
      function ev(n) {
        var t = n && n.itemStyle;
        if (t) for (var e = 0; e < CB.length; e++) {
          var i = CB[e][1], r = CB[e][0];
          t[i] != null && (t[r] = t[i], Rn(i, r));
        }
      }
      function Z4(n) {
        n && n.alignTo === "edge" && n.margin != null && n.edgeDistance == null && (Rn("label.margin", "label.edgeDistance", "pie"), n.edgeDistance = n.margin);
      }
      function K4(n) {
        n && n.downplay && !n.blur && (n.blur = n.downplay, Rn("downplay", "blur", "sunburst"));
      }
      function NIt(n) {
        n && n.focusNodeAdjacency != null && (n.emphasis = n.emphasis || {}, n.emphasis.focus == null && (Rn("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), n.emphasis.focus = "adjacency"));
      }
      function $4(n, t) {
        if (n) for (var e = 0; e < n.length; e++) t(n[e]), n[e] && $4(n[e].children, t);
      }
      function J4(n, t) {
        MIt(n, t), n.series = Qe(n.series), M(n.series, function(e) {
          if (_t(e)) {
            var i = e.type;
            if (i === "line") e.clipOverflow != null && (e.clip = e.clipOverflow, Rn("clipOverflow", "clip", "line"));
            else if (i === "pie" || i === "gauge") {
              e.clockWise != null && (e.clockwise = e.clockWise, Rn("clockWise", "clockwise")), Z4(e.label);
              var r = e.data;
              if (r && !Ui(r)) for (var a = 0; a < r.length; a++) Z4(r[a]);
              e.hoverOffset != null && (e.emphasis = e.emphasis || {}, (e.emphasis.scaleSize = null) && (Rn("hoverOffset", "emphasis.scaleSize"), e.emphasis.scaleSize = e.hoverOffset));
            } else if (i === "gauge") {
              var o = DIt(e, "pointer.color");
              o != null && RIt(e, "itemStyle.color", o);
            } else if (i === "bar") {
              ev(e), ev(e.backgroundStyle), ev(e.emphasis);
              var r = e.data;
              if (r && !Ui(r)) for (var a = 0; a < r.length; a++) typeof r[a] == "object" && (ev(r[a]), ev(r[a] && r[a].emphasis));
            } else if (i === "sunburst") {
              var s = e.highlightPolicy;
              s && (e.emphasis = e.emphasis || {}, e.emphasis.focus || (e.emphasis.focus = s, Rn("highlightPolicy", "emphasis.focus", "sunburst"))), K4(e), $4(e.data, K4);
            } else i === "graph" || i === "sankey" ? NIt(e) : i === "map" && (e.mapType && !e.map && (Rn("mapType", "map", "map"), e.map = e.mapType), e.mapLocation && (qa("`mapLocation` is not used anymore."), Et(e, e.mapLocation)));
            e.hoverAnimation != null && (e.emphasis = e.emphasis || {}, e.emphasis && e.emphasis.scale == null && (Rn("hoverAnimation", "emphasis.scale"), e.emphasis.scale = e.hoverAnimation)), X4(e);
          }
        }), n.dataRange && (n.visualMap = n.dataRange), M(PIt, function(e) {
          var i = n[e];
          i && (X(i) || (i = [i]), M(i, function(r) {
            X4(r);
          }));
        });
      }
      function kIt(n) {
        var t = dt();
        n.eachSeries(function(e) {
          var i = e.get("stack");
          if (i) {
            var r = t.get(i) || t.set(i, []), a = e.getData(), o = { stackResultDimension: a.getCalculationInfo("stackResultDimension"), stackedOverDimension: a.getCalculationInfo("stackedOverDimension"), stackedDimension: a.getCalculationInfo("stackedDimension"), stackedByDimension: a.getCalculationInfo("stackedByDimension"), isStackedByIndex: a.getCalculationInfo("isStackedByIndex"), data: a, seriesModel: e };
            if (!o.stackedDimension || !(o.isStackedByIndex || o.stackedByDimension)) return;
            r.length && a.setCalculationInfo("stackedOnSeries", r[r.length - 1].seriesModel), r.push(o);
          }
        }), t.each(FIt);
      }
      function FIt(n) {
        M(n, function(t, e) {
          var i = [], r = [NaN, NaN], a = [t.stackResultDimension, t.stackedOverDimension], o = t.data, s = t.isStackedByIndex, l = t.seriesModel.get("stackStrategy") || "samesign";
          o.modify(a, function(u, h, c) {
            var f = o.get(t.stackedDimension, c);
            if (isNaN(f)) return r;
            var g, d;
            s ? d = o.getRawIndex(c) : g = o.get(t.stackedByDimension, c);
            for (var A = NaN, p = e - 1; p >= 0; p--) {
              var v = n[p];
              if (s || (d = v.data.rawIndexOf(v.stackedByDimension, g)), d >= 0) {
                var y = v.data.getByRawIndex(v.stackResultDimension, d);
                if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && f >= 0 && y > 0 || l === "samesign" && f <= 0 && y < 0) {
                  f = Tmt(f, y), A = y;
                  break;
                }
              }
            }
            return i[0] = f, i[1] = A, i;
          });
        });
      }
      var B1 = /* @__PURE__ */ function() {
        function n(t) {
          this.data = t.data || (t.sourceFormat === Qo ? {} : []), this.sourceFormat = t.sourceFormat || P4, this.seriesLayoutBy = t.seriesLayoutBy || Oo, this.startIndex = t.startIndex || 0, this.dimensionsDetectedCount = t.dimensionsDetectedCount, this.metaRawOption = t.metaRawOption;
          var e = this.dimensionsDefine = t.dimensionsDefine;
          if (e) for (var i = 0; i < e.length; i++) {
            var r = e[i];
            r.type == null && F4(this, i) === yi.Must && (r.type = "ordinal");
          }
        }
        return n;
      }();
      function SB(n) {
        return n instanceof B1;
      }
      function bB(n, t, e) {
        e = e || t8(n);
        var i = t.seriesLayoutBy, r = OIt(n, e, i, t.sourceHeader, t.dimensions), a = new B1({ data: n, sourceFormat: e, seriesLayoutBy: i, dimensionsDefine: r.dimensionsDefine, startIndex: r.startIndex, dimensionsDetectedCount: r.dimensionsDetectedCount, metaRawOption: xt(t) });
        return a;
      }
      function BB(n) {
        return new B1({ data: n, sourceFormat: Ui(n) ? Fs : da });
      }
      function QIt(n) {
        return new B1({ data: n.data, sourceFormat: n.sourceFormat, seriesLayoutBy: n.seriesLayoutBy, dimensionsDefine: xt(n.dimensionsDefine), startIndex: n.startIndex, dimensionsDetectedCount: n.dimensionsDetectedCount });
      }
      function t8(n) {
        var t = P4;
        if (Ui(n)) t = Fs;
        else if (X(n)) {
          n.length === 0 && (t = Ri);
          for (var e = 0, i = n.length; e < i; e++) {
            var r = n[e];
            if (r != null) {
              if (X(r) || Ui(r)) {
                t = Ri;
                break;
              } else if (_t(r)) {
                t = Aa;
                break;
              }
            }
          }
        } else if (_t(n)) {
          for (var a in n) if (ft(n, a) && Mi(n[a])) {
            t = Qo;
            break;
          }
        }
        return t;
      }
      function OIt(n, t, e, i, r) {
        var a, o;
        if (!n) return { dimensionsDefine: e8(r), startIndex: o, dimensionsDetectedCount: a };
        if (t === Ri) {
          var s = n;
          i === "auto" || i == null ? n8(function(u) {
            u != null && u !== "-" && (ht(u) ? o == null && (o = 1) : o = 0);
          }, e, s, 10) : o = pe(i) ? i : i ? 1 : 0, !r && o === 1 && (r = [], n8(function(u, h) {
            r[h] = u != null ? u + "" : "";
          }, e, s, 1 / 0)), a = r ? r.length : e === kg ? s.length : s[0] ? s[0].length : null;
        } else if (t === Aa) r || (r = zIt(n));
        else if (t === Qo) r || (r = [], M(n, function(u, h) {
          r.push(h);
        }));
        else if (t === da) {
          var l = pg(n[0]);
          a = X(l) && l.length || 1;
        } else t === Fs && true && It(!!r, "dimensions must be given if data is TypedArray.");
        return { startIndex: o, dimensionsDefine: e8(r), dimensionsDetectedCount: a };
      }
      function zIt(n) {
        for (var t = 0, e; t < n.length && !(e = n[t++]); ) ;
        if (e) return re(e);
      }
      function e8(n) {
        if (n) {
          var t = dt();
          return Z(n, function(e, i) {
            e = _t(e) ? e : { name: e };
            var r = { name: e.name, displayName: e.displayName, type: e.type };
            if (r.name == null) return r;
            r.name += "", r.displayName == null && (r.displayName = r.name);
            var a = t.get(r.name);
            return a ? r.name += "-" + a.count++ : t.set(r.name, { count: 1 }), r;
          });
        }
      }
      function n8(n, t, e, i) {
        if (t === kg) for (var r = 0; r < e.length && r < i; r++) n(e[r] ? e[r][0] : null, r);
        else for (var a = e[0] || [], r = 0; r < a.length && r < i; r++) n(a[r], r);
      }
      function i8(n) {
        var t = n.sourceFormat;
        return t === Aa || t === Qo;
      }
      var Qh, Oh, zh, r8, a8, o8 = function() {
        function n(t, e) {
          var i = SB(t) ? t : BB(t);
          this._source = i;
          var r = this._data = i.data;
          if (i.sourceFormat === Fs) {
            if (e == null) throw new Error("Typed array data must specify dimension size");
            this._offset = 0, this._dimSize = e, this._data = r;
          }
          a8(this, r, i);
        }
        return n.prototype.getSource = function() {
          return this._source;
        }, n.prototype.count = function() {
          return 0;
        }, n.prototype.getItem = function(t, e) {
        }, n.prototype.appendData = function(t) {
        }, n.prototype.clean = function() {
        }, n.protoInitialize = function() {
          var t = n.prototype;
          t.pure = false, t.persistent = true;
        }(), n.internalField = function() {
          var t;
          a8 = function(o, s, l) {
            var u = l.sourceFormat, h = l.seriesLayoutBy, c = l.startIndex, f = l.dimensionsDefine, g = r8[MB(u, h)];
            if (It(g, "Invalide sourceFormat: " + u), Y(o, g), u === Fs) o.getItem = e, o.count = r, o.fillStorage = i;
            else {
              var d = l8(u, h);
              o.getItem = ct(d, null, s, c, f);
              var A = h8(u, h);
              o.count = ct(A, null, s, c, f);
            }
          };
          var e = function(o, s) {
            o = o - this._offset, s = s || [];
            for (var l = this._data, u = this._dimSize, h = u * o, c = 0; c < u; c++) s[c] = l[h + c];
            return s;
          }, i = function(o, s, l, u) {
            for (var h = this._data, c = this._dimSize, f = 0; f < c; f++) {
              for (var g = u[f], d = g[0] == null ? 1 / 0 : g[0], A = g[1] == null ? -1 / 0 : g[1], p = s - o, v = l[f], y = 0; y < p; y++) {
                var m = h[y * c + f];
                v[o + y] = m, m < d && (d = m), m > A && (A = m);
              }
              g[0] = d, g[1] = A;
            }
          }, r = function() {
            return this._data ? this._data.length / this._dimSize : 0;
          };
          r8 = (t = {}, t[Ri + "_" + Oo] = { pure: true, appendData: a }, t[Ri + "_" + kg] = { pure: true, appendData: function() {
            throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
          } }, t[Aa] = { pure: true, appendData: a }, t[Qo] = { pure: true, appendData: function(o) {
            var s = this._data;
            M(o, function(l, u) {
              for (var h = s[u] || (s[u] = []), c = 0; c < (l || []).length; c++) h.push(l[c]);
            });
          } }, t[da] = { appendData: a }, t[Fs] = { persistent: false, pure: true, appendData: function(o) {
            It(Ui(o), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = o;
          }, clean: function() {
            this._offset += this.count(), this._data = null;
          } }, t);
          function a(o) {
            for (var s = 0; s < o.length; s++) this._data.push(o[s]);
          }
        }(), n;
      }(), s8 = function(n, t, e, i) {
        return n[i];
      }, GIt = (Qh = {}, Qh[Ri + "_" + Oo] = function(n, t, e, i) {
        return n[i + t];
      }, Qh[Ri + "_" + kg] = function(n, t, e, i, r) {
        i += t;
        for (var a = r || [], o = n, s = 0; s < o.length; s++) {
          var l = o[s];
          a[s] = l ? l[i] : null;
        }
        return a;
      }, Qh[Aa] = s8, Qh[Qo] = function(n, t, e, i, r) {
        for (var a = r || [], o = 0; o < e.length; o++) {
          var s = e[o].name;
          if (s == null) throw new Error();
          var l = n[s];
          a[o] = l ? l[i] : null;
        }
        return a;
      }, Qh[da] = s8, Qh);
      function l8(n, t) {
        var e = GIt[MB(n, t)];
        return It(e, 'Do not support get item on "' + n + '", "' + t + '".'), e;
      }
      var u8 = function(n, t, e) {
        return n.length;
      }, UIt = (Oh = {}, Oh[Ri + "_" + Oo] = function(n, t, e) {
        return Math.max(0, n.length - t);
      }, Oh[Ri + "_" + kg] = function(n, t, e) {
        var i = n[0];
        return i ? Math.max(0, i.length - t) : 0;
      }, Oh[Aa] = u8, Oh[Qo] = function(n, t, e) {
        var i = e[0].name;
        if (i == null) throw new Error();
        var r = n[i];
        return r ? r.length : 0;
      }, Oh[da] = u8, Oh);
      function h8(n, t) {
        var e = UIt[MB(n, t)];
        return It(e, 'Do not support count on "' + n + '", "' + t + '".'), e;
      }
      var TB = function(n, t, e) {
        return n[t];
      }, VIt = (zh = {}, zh[Ri] = TB, zh[Aa] = function(n, t, e) {
        return n[e];
      }, zh[Qo] = TB, zh[da] = function(n, t, e) {
        var i = pg(n);
        return i instanceof Array ? i[t] : i;
      }, zh[Fs] = TB, zh);
      function c8(n) {
        var t = VIt[n];
        return It(t, 'Do not support get value on "' + n + '".'), t;
      }
      function MB(n, t) {
        return n === Ri ? n + "_" + t : n;
      }
      function Qg(n, t, e) {
        if (n) {
          var i = n.getRawDataItem(t);
          if (i != null) {
            var r = n.getStore(), a = r.getSource().sourceFormat;
            if (e != null) {
              var o = n.getDimensionIndex(e), s = r.getDimensionProperty(o);
              return c8(a)(i, o, s);
            } else {
              var l = i;
              return a === da && (l = pg(i)), l;
            }
          }
        }
      }
      var jIt = /\{@(.+?)\}/g, T1 = function() {
        function n() {
        }
        return n.prototype.getDataParams = function(t, e) {
          var i = this.getData(e), r = this.getRawValue(t, e), a = i.getRawIndex(t), o = i.getName(t), s = i.getRawDataItem(t), l = i.getItemVisual(t, "style"), u = l && l[i.getItemVisual(t, "drawType") || "fill"], h = l && l.stroke, c = this.mainType, f = c === "series", g = i.userOutput && i.userOutput.get();
          return { componentType: c, componentSubType: this.subType, componentIndex: this.componentIndex, seriesType: f ? this.subType : null, seriesIndex: this.seriesIndex, seriesId: f ? this.id : null, seriesName: f ? this.name : null, name: o, dataIndex: a, data: s, dataType: e, value: r, color: u, borderColor: h, dimensionNames: g ? g.fullDimensions : null, encode: g ? g.encode : null, $vars: ["seriesName", "name", "value"] };
        }, n.prototype.getFormattedLabel = function(t, e, i, r, a, o) {
          e = e || "normal";
          var s = this.getData(i), l = this.getDataParams(t, i);
          if (o && (l.value = o.interpolatedValue), r != null && X(l.value) && (l.value = l.value[r]), !a) {
            var u = s.getItemModel(t);
            a = u.get(e === "normal" ? ["label", "formatter"] : [e, "label", "formatter"]);
          }
          if (yt(a)) return l.status = e, l.dimensionIndex = r, a(l);
          if (ht(a)) {
            var h = M4(a, l);
            return h.replace(jIt, function(c, f) {
              var g = f.length, d = f;
              d.charAt(0) === "[" && d.charAt(g - 1) === "]" && (d = +d.slice(1, g - 1), isNaN(d) && Ai("Invalide label formatter: @" + f + ", only support @[0], @[1], @[2], ..."));
              var A = Qg(s, t, d);
              if (o && X(o.interpolatedValue)) {
                var p = s.getDimensionIndex(d);
                p >= 0 && (A = o.interpolatedValue[p]);
              }
              return A != null ? A + "" : "";
            });
          }
        }, n.prototype.getRawValue = function(t, e) {
          return Qg(this.getData(e), t);
        }, n.prototype.formatTooltip = function(t, e, i) {
        }, n;
      }();
      function f8(n) {
        var t, e;
        return _t(n) ? n.type ? e = n : "development" : t = n, { text: t, frag: e };
      }
      function nv(n) {
        return new qIt(n);
      }
      var qIt = function() {
        function n(t) {
          t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = true;
        }
        return n.prototype.perform = function(t) {
          var e = this._upstream, i = t && t.skip;
          if (this._dirty && e) {
            var r = this.context;
            r.data = r.outputData = e.context.outputData;
          }
          this.__pipeline && (this.__pipeline.currentTask = this);
          var a;
          this._plan && !i && (a = this._plan(this.context));
          var o = h(this._modBy), s = this._modDataCount || 0, l = h(t && t.modBy), u = t && t.modDataCount || 0;
          (o !== l || s !== u) && (a = "reset");
          function h(y) {
            return !(y >= 1) && (y = 1), y;
          }
          var c;
          (this._dirty || a === "reset") && (this._dirty = false, c = this._doReset(i)), this._modBy = l, this._modDataCount = u;
          var f = t && t.step;
          if (e ? (It(e._outputDueEnd != null), this._dueEnd = e._outputDueEnd) : (It(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
            var g = this._dueIndex, d = Math.min(f != null ? this._dueIndex + f : 1 / 0, this._dueEnd);
            if (!i && (c || g < d)) {
              var A = this._progress;
              if (X(A)) for (var p = 0; p < A.length; p++) this._doProgress(A[p], g, d, l, u);
              else this._doProgress(A, g, d, l, u);
            }
            this._dueIndex = d;
            var v = this._settedOutputEnd != null ? this._settedOutputEnd : d;
            It(v >= this._outputDueEnd), this._outputDueEnd = v;
          } else this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
          return this.unfinished();
        }, n.prototype.dirty = function() {
          this._dirty = true, this._onDirty && this._onDirty(this.context);
        }, n.prototype._doProgress = function(t, e, i, r, a) {
          g8.reset(e, i, r, a), this._callingProgress = t, this._callingProgress({ start: e, end: i, count: i - e, next: g8.next }, this.context);
        }, n.prototype._doReset = function(t) {
          this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
          var e, i;
          !t && this._reset && (e = this._reset(this.context), e && e.progress && (i = e.forceFirstProgress, e = e.progress), X(e) && !e.length && (e = null)), this._progress = e, this._modBy = this._modDataCount = null;
          var r = this._downstream;
          return r && r.dirty(), i;
        }, n.prototype.unfinished = function() {
          return this._progress && this._dueIndex < this._dueEnd;
        }, n.prototype.pipe = function(t) {
          It(t && !t._disposed && t !== this), (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty());
        }, n.prototype.dispose = function() {
          this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = false, this._disposed = true);
        }, n.prototype.getUpstream = function() {
          return this._upstream;
        }, n.prototype.getDownstream = function() {
          return this._downstream;
        }, n.prototype.setOutputEnd = function(t) {
          this._outputDueEnd = this._settedOutputEnd = t;
        }, n;
      }(), g8 = /* @__PURE__ */ function() {
        var n, t, e, i, r, a = { reset: function(l, u, h, c) {
          t = l, n = u, e = h, i = c, r = Math.ceil(i / e), a.next = e > 1 && i > 0 ? s : o;
        } };
        return a;
        function o() {
          return t < n ? t++ : null;
        }
        function s() {
          var l = t % r * e + Math.ceil(t / r), u = t >= n ? null : l < i ? l : t;
          return t++, u;
        }
      }();
      function ru(n, t) {
        var e = t && t.type;
        return e === "ordinal" ? n : (e === "time" && !pe(n) && n != null && n !== "-" && (n = +Do(n)), n == null || n === "" ? NaN : Number(n));
      }
      var HIt = dt({ number: function(n) {
        return parseFloat(n);
      }, time: function(n) {
        return +Do(n);
      }, trim: function(n) {
        return ht(n) ? Ga(n) : n;
      } });
      function d8(n) {
        return HIt.get(n);
      }
      var A8 = { lt: function(n, t) {
        return n < t;
      }, lte: function(n, t) {
        return n <= t;
      }, gt: function(n, t) {
        return n > t;
      }, gte: function(n, t) {
        return n >= t;
      } }, YIt = function() {
        function n(t, e) {
          if (!pe(e)) {
            var i = "";
            i = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.', Ce(i);
          }
          this._opFn = A8[t], this._rvalFloat = Ms(e);
        }
        return n.prototype.evaluate = function(t) {
          return pe(t) ? this._opFn(t, this._rvalFloat) : this._opFn(Ms(t), this._rvalFloat);
        }, n;
      }(), p8 = function() {
        function n(t, e) {
          var i = t === "desc";
          this._resultLT = i ? 1 : -1, e == null && (e = i ? "min" : "max"), this._incomparable = e === "min" ? -1 / 0 : 1 / 0;
        }
        return n.prototype.evaluate = function(t, e) {
          var i = pe(t) ? t : Ms(t), r = pe(e) ? e : Ms(e), a = isNaN(i), o = isNaN(r);
          if (a && (i = this._incomparable), o && (r = this._incomparable), a && o) {
            var s = ht(t), l = ht(e);
            s && (i = l ? t : 0), l && (r = s ? e : 0);
          }
          return i < r ? this._resultLT : i > r ? -this._resultLT : 0;
        }, n;
      }(), WIt = function() {
        function n(t, e) {
          this._rval = e, this._isEQ = t, this._rvalTypeof = typeof e, this._rvalFloat = Ms(e);
        }
        return n.prototype.evaluate = function(t) {
          var e = t === this._rval;
          if (!e) {
            var i = typeof t;
            i !== this._rvalTypeof && (i === "number" || this._rvalTypeof === "number") && (e = Ms(t) === this._rvalFloat);
          }
          return this._isEQ ? e : !e;
        }, n;
      }();
      function XIt(n, t) {
        return n === "eq" || n === "ne" ? new WIt(n === "eq", t) : ft(A8, n) ? new YIt(n, t) : null;
      }
      var ZIt = function() {
        function n() {
        }
        return n.prototype.getRawData = function() {
          throw new Error("not supported");
        }, n.prototype.getRawDataItem = function(t) {
          throw new Error("not supported");
        }, n.prototype.cloneRawData = function() {
        }, n.prototype.getDimensionInfo = function(t) {
        }, n.prototype.cloneAllDimensionInfo = function() {
        }, n.prototype.count = function() {
        }, n.prototype.retrieveValue = function(t, e) {
        }, n.prototype.retrieveValueFromItem = function(t, e) {
        }, n.prototype.convertValue = function(t, e) {
          return ru(t, e);
        }, n;
      }();
      function KIt(n, t) {
        var e = new ZIt(), i = n.data, r = e.sourceFormat = n.sourceFormat, a = n.startIndex, o = "";
        n.seriesLayoutBy !== Oo && (o = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.', Ce(o));
        var s = [], l = {}, u = n.dimensionsDefine;
        if (u) M(u, function(A, p) {
          var v = A.name, y = { index: p, name: v, displayName: A.displayName };
          if (s.push(y), v != null) {
            var m = "";
            ft(l, v) && (m = 'dimension name "' + v + '" duplicated.', Ce(m)), l[v] = y;
          }
        });
        else for (var h = 0; h < n.dimensionsDetectedCount; h++) s.push({ index: h });
        var c = l8(r, Oo);
        t.__isBuiltIn && (e.getRawDataItem = function(A) {
          return c(i, a, s, A);
        }, e.getRawData = ct($It, null, n)), e.cloneRawData = ct(JIt, null, n);
        var f = h8(r, Oo);
        e.count = ct(f, null, i, a, s);
        var g = c8(r);
        e.retrieveValue = function(A, p) {
          var v = c(i, a, s, A);
          return d(v, p);
        };
        var d = e.retrieveValueFromItem = function(A, p) {
          if (A != null) {
            var v = s[p];
            if (v) return g(A, p, v.name);
          }
        };
        return e.getDimensionInfo = ct(tEt, null, s, l), e.cloneAllDimensionInfo = ct(eEt, null, s), e;
      }
      function $It(n) {
        var t = n.sourceFormat;
        if (!DB(t)) {
          var e = "";
          e = "`getRawData` is not supported in source format " + t, Ce(e);
        }
        return n.data;
      }
      function JIt(n) {
        var t = n.sourceFormat, e = n.data;
        if (!DB(t)) {
          var i = "";
          i = "`cloneRawData` is not supported in source format " + t, Ce(i);
        }
        if (t === Ri) {
          for (var r = [], a = 0, o = e.length; a < o; a++) r.push(e[a].slice());
          return r;
        } else if (t === Aa) {
          for (var r = [], a = 0, o = e.length; a < o; a++) r.push(Y({}, e[a]));
          return r;
        }
      }
      function tEt(n, t, e) {
        if (e != null) {
          if (pe(e) || !isNaN(e) && !ft(t, e)) return n[e];
          if (ft(t, e)) return t[e];
        }
      }
      function eEt(n) {
        return xt(n);
      }
      var v8 = dt();
      function nEt(n) {
        n = xt(n);
        var t = n.type, e = "";
        t || (e = "Must have a `type` when `registerTransform`.", Ce(e));
        var i = t.split(":");
        i.length !== 2 && (e = 'Name must include namespace like "ns:regression".', Ce(e));
        var r = false;
        i[0] === "echarts" && (t = i[1], r = true), n.__isBuiltIn = r, v8.set(t, n);
      }
      function iEt(n, t, e) {
        var i = Qe(n), r = i.length, a = "";
        r || (a = "If `transform` declared, it should at least contain one transform.", Ce(a));
        for (var o = 0, s = r; o < s; o++) {
          var l = i[o];
          t = rEt(l, t, e, r === 1 ? null : o), o !== s - 1 && (t.length = Math.max(t.length, 1));
        }
        return t;
      }
      function rEt(n, t, e, i) {
        var r = "";
        t.length || (r = "Must have at least one upstream dataset.", Ce(r)), _t(n) || (r = "transform declaration must be an object rather than " + typeof n + ".", Ce(r));
        var a = n.type, o = v8.get(a);
        o || (r = 'Can not find transform on type "' + a + '".', Ce(r));
        var s = Z(t, function(h) {
          return KIt(h, o);
        }), l = Qe(o.transform({ upstream: s[0], upstreamList: s, config: xt(n.config) }));
        if (n.print) {
          var u = Z(l, function(h) {
            var c = i != null ? " === pipe index: " + i : "";
            return ["=== dataset index: " + e.datasetIndex + c + " ===", "- transform result data:", vr(h.data), "- transform result dimensions:", vr(h.dimensions)].join(`
`);
          }).join(`
`);
          Lmt(u);
        }
        return Z(l, function(h, c) {
          var f = "";
          _t(h) || (f = "A transform should not return some empty results.", Ce(f)), h.data || (f = "Transform result data should be not be null or undefined", Ce(f));
          var g = t8(h.data);
          DB(g) || (f = "Transform result data should be array rows or object rows.", Ce(f));
          var d, A = t[0];
          if (A && c === 0 && !h.dimensions) {
            var p = A.startIndex;
            p && (h.data = A.data.slice(0, p).concat(h.data)), d = { seriesLayoutBy: Oo, sourceHeader: p, dimensions: A.metaRawOption.dimensions };
          } else d = { seriesLayoutBy: Oo, sourceHeader: 0, dimensions: h.dimensions };
          return bB(h.data, d, null);
        });
      }
      function DB(n) {
        return n === Ri || n === Aa;
      }
      var M1 = "undefined", aEt = typeof Uint32Array === M1 ? Array : Uint32Array, oEt = typeof Uint16Array === M1 ? Array : Uint16Array, y8 = typeof Int32Array === M1 ? Array : Int32Array, m8 = typeof Float64Array === M1 ? Array : Float64Array, _8 = { float: m8, int: y8, ordinal: Array, number: Array, time: m8 }, RB;
      function iv(n) {
        return n > 65535 ? aEt : oEt;
      }
      function Og() {
        return [1 / 0, -1 / 0];
      }
      function sEt(n) {
        var t = n.constructor;
        return t === Array ? n.slice() : new t(n);
      }
      function I8(n, t, e, i, r) {
        var a = _8[e || "float"];
        if (r) {
          var o = n[t], s = o && o.length;
          if (s !== i) {
            for (var l = new a(i), u = 0; u < s; u++) l[u] = o[u];
            n[t] = l;
          }
        } else n[t] = new a(i);
      }
      var LB = function() {
        function n() {
          this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = dt();
        }
        return n.prototype.initData = function(t, e, i) {
          It(yt(t.getItem) && yt(t.count), "Invalid data provider."), this._provider = t, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
          var r = t.getSource(), a = this.defaultDimValueGetter = RB[r.sourceFormat];
          this._dimValueGetter = i || a, this._rawExtent = [];
          var o = i8(r);
          this._dimensions = Z(e, function(s) {
            return o && It(s.property != null), { type: s.type, property: s.property };
          }), this._initDataFromProvider(0, t.count());
        }, n.prototype.getProvider = function() {
          return this._provider;
        }, n.prototype.getSource = function() {
          return this._provider.getSource();
        }, n.prototype.ensureCalculationDimension = function(t, e) {
          var i = this._calcDimNameToIdx, r = this._dimensions, a = i.get(t);
          if (a != null) {
            if (r[a].type === e) return a;
          } else a = r.length;
          return r[a] = { type: e }, i.set(t, a), this._chunks[a] = new _8[e || "float"](this._rawCount), this._rawExtent[a] = Og(), a;
        }, n.prototype.collectOrdinalMeta = function(t, e) {
          var i = this._chunks[t], r = this._dimensions[t], a = this._rawExtent, o = r.ordinalOffset || 0, s = i.length;
          o === 0 && (a[t] = Og());
          for (var l = a[t], u = o; u < s; u++) {
            var h = i[u] = e.parseAndCollect(i[u]);
            isNaN(h) || (l[0] = Math.min(h, l[0]), l[1] = Math.max(h, l[1]));
          }
          r.ordinalMeta = e, r.ordinalOffset = s, r.type = "ordinal";
        }, n.prototype.getOrdinalMeta = function(t) {
          var e = this._dimensions[t], i = e.ordinalMeta;
          return i;
        }, n.prototype.getDimensionProperty = function(t) {
          var e = this._dimensions[t];
          return e && e.property;
        }, n.prototype.appendData = function(t) {
          It(!this._indices, "appendData can only be called on raw data.");
          var e = this._provider, i = this.count();
          e.appendData(t);
          var r = e.count();
          return e.persistent || (r += i), i < r && this._initDataFromProvider(i, r, true), [i, r];
        }, n.prototype.appendValues = function(t, e) {
          for (var i = this._chunks, r = this._dimensions, a = r.length, o = this._rawExtent, s = this.count(), l = s + Math.max(t.length, e || 0), u = 0; u < a; u++) {
            var h = r[u];
            I8(i, u, h.type, l, true);
          }
          for (var c = [], f = s; f < l; f++) for (var g = f - s, d = 0; d < a; d++) {
            var h = r[d], A = RB.arrayRows.call(this, t[g] || c, h.property, g, d);
            i[d][f] = A;
            var p = o[d];
            A < p[0] && (p[0] = A), A > p[1] && (p[1] = A);
          }
          return this._rawCount = this._count = l, { start: s, end: l };
        }, n.prototype._initDataFromProvider = function(t, e, i) {
          for (var r = this._provider, a = this._chunks, o = this._dimensions, s = o.length, l = this._rawExtent, u = Z(o, function(y) {
            return y.property;
          }), h = 0; h < s; h++) {
            var c = o[h];
            l[h] || (l[h] = Og()), I8(a, h, c.type, e, i);
          }
          if (r.fillStorage) r.fillStorage(t, e, a, l);
          else for (var f = [], g = t; g < e; g++) {
            f = r.getItem(g, f);
            for (var d = 0; d < s; d++) {
              var A = a[d], p = this._dimValueGetter(f, u[d], g, d);
              A[g] = p;
              var v = l[d];
              p < v[0] && (v[0] = p), p > v[1] && (v[1] = p);
            }
          }
          !r.persistent && r.clean && r.clean(), this._rawCount = this._count = e, this._extent = [];
        }, n.prototype.count = function() {
          return this._count;
        }, n.prototype.get = function(t, e) {
          if (!(e >= 0 && e < this._count)) return NaN;
          var i = this._chunks[t];
          return i ? i[this.getRawIndex(e)] : NaN;
        }, n.prototype.getValues = function(t, e) {
          var i = [], r = [];
          if (e == null) {
            e = t, t = [];
            for (var a = 0; a < this._dimensions.length; a++) r.push(a);
          } else r = t;
          for (var a = 0, o = r.length; a < o; a++) i.push(this.get(r[a], e));
          return i;
        }, n.prototype.getByRawIndex = function(t, e) {
          if (!(e >= 0 && e < this._rawCount)) return NaN;
          var i = this._chunks[t];
          return i ? i[e] : NaN;
        }, n.prototype.getSum = function(t) {
          var e = this._chunks[t], i = 0;
          if (e) for (var r = 0, a = this.count(); r < a; r++) {
            var o = this.get(t, r);
            isNaN(o) || (i += o);
          }
          return i;
        }, n.prototype.getMedian = function(t) {
          var e = [];
          this.each([t], function(a) {
            isNaN(a) || e.push(a);
          });
          var i = e.sort(function(a, o) {
            return a - o;
          }), r = this.count();
          return r === 0 ? 0 : r % 2 === 1 ? i[(r - 1) / 2] : (i[r / 2] + i[r / 2 - 1]) / 2;
        }, n.prototype.indexOfRawIndex = function(t) {
          if (t >= this._rawCount || t < 0) return -1;
          if (!this._indices) return t;
          var e = this._indices, i = e[t];
          if (i != null && i < this._count && i === t) return t;
          for (var r = 0, a = this._count - 1; r <= a; ) {
            var o = (r + a) / 2 | 0;
            if (e[o] < t) r = o + 1;
            else if (e[o] > t) a = o - 1;
            else return o;
          }
          return -1;
        }, n.prototype.indicesOfNearest = function(t, e, i) {
          var r = this._chunks, a = r[t], o = [];
          if (!a) return o;
          i == null && (i = 1 / 0);
          for (var s = 1 / 0, l = -1, u = 0, h = 0, c = this.count(); h < c; h++) {
            var f = this.getRawIndex(h), g = e - a[f], d = Math.abs(g);
            d <= i && ((d < s || d === s && g >= 0 && l < 0) && (s = d, l = g, u = 0), g === l && (o[u++] = h));
          }
          return o.length = u, o;
        }, n.prototype.getIndices = function() {
          var t, e = this._indices;
          if (e) {
            var i = e.constructor, r = this._count;
            if (i === Array) {
              t = new i(r);
              for (var a = 0; a < r; a++) t[a] = e[a];
            } else t = new i(e.buffer, 0, r);
          } else {
            var i = iv(this._rawCount);
            t = new i(this.count());
            for (var a = 0; a < t.length; a++) t[a] = a;
          }
          return t;
        }, n.prototype.filter = function(t, e) {
          if (!this._count) return this;
          for (var i = this.clone(), r = i.count(), a = iv(i._rawCount), o = new a(r), s = [], l = t.length, u = 0, h = t[0], c = i._chunks, f = 0; f < r; f++) {
            var g = void 0, d = i.getRawIndex(f);
            if (l === 0) g = e(f);
            else if (l === 1) {
              var A = c[h][d];
              g = e(A, f);
            } else {
              for (var p = 0; p < l; p++) s[p] = c[t[p]][d];
              s[p] = f, g = e.apply(null, s);
            }
            g && (o[u++] = d);
          }
          return u < r && (i._indices = o), i._count = u, i._extent = [], i._updateGetRawIdx(), i;
        }, n.prototype.selectRange = function(t) {
          var e = this.clone(), i = e._count;
          if (!i) return this;
          var r = re(t), a = r.length;
          if (!a) return this;
          var o = e.count(), s = iv(e._rawCount), l = new s(o), u = 0, h = r[0], c = t[h][0], f = t[h][1], g = e._chunks, d = false;
          if (!e._indices) {
            var A = 0;
            if (a === 1) {
              for (var p = g[r[0]], v = 0; v < i; v++) {
                var y = p[v];
                (y >= c && y <= f || isNaN(y)) && (l[u++] = A), A++;
              }
              d = true;
            } else if (a === 2) {
              for (var p = g[r[0]], m = g[r[1]], _ = t[r[1]][0], E = t[r[1]][1], v = 0; v < i; v++) {
                var y = p[v], I = m[v];
                (y >= c && y <= f || isNaN(y)) && (I >= _ && I <= E || isNaN(I)) && (l[u++] = A), A++;
              }
              d = true;
            }
          }
          if (!d) if (a === 1) for (var v = 0; v < o; v++) {
            var x = e.getRawIndex(v), y = g[r[0]][x];
            (y >= c && y <= f || isNaN(y)) && (l[u++] = x);
          }
          else for (var v = 0; v < o; v++) {
            for (var w = true, x = e.getRawIndex(v), C = 0; C < a; C++) {
              var S = r[C], y = g[S][x];
              (y < t[S][0] || y > t[S][1]) && (w = false);
            }
            w && (l[u++] = e.getRawIndex(v));
          }
          return u < o && (e._indices = l), e._count = u, e._extent = [], e._updateGetRawIdx(), e;
        }, n.prototype.map = function(t, e) {
          var i = this.clone(t);
          return this._updateDims(i, t, e), i;
        }, n.prototype.modify = function(t, e) {
          this._updateDims(this, t, e);
        }, n.prototype._updateDims = function(t, e, i) {
          for (var r = t._chunks, a = [], o = e.length, s = t.count(), l = [], u = t._rawExtent, h = 0; h < e.length; h++) u[e[h]] = Og();
          for (var c = 0; c < s; c++) {
            for (var f = t.getRawIndex(c), g = 0; g < o; g++) l[g] = r[e[g]][f];
            l[o] = c;
            var d = i && i.apply(null, l);
            if (d != null) {
              typeof d != "object" && (a[0] = d, d = a);
              for (var h = 0; h < d.length; h++) {
                var A = e[h], p = d[h], v = u[A], y = r[A];
                y && (y[f] = p), p < v[0] && (v[0] = p), p > v[1] && (v[1] = p);
              }
            }
          }
        }, n.prototype.lttbDownSample = function(t, e) {
          var i = this.clone([t], true), r = i._chunks, a = r[t], o = this.count(), s = 0, l = Math.floor(1 / e), u = this.getRawIndex(0), h, c, f, g = new (iv(this._rawCount))(Math.min((Math.ceil(o / l) + 2) * 2, o));
          g[s++] = u;
          for (var d = 1; d < o - 1; d += l) {
            for (var A = Math.min(d + l, o - 1), p = Math.min(d + l * 2, o), v = (p + A) / 2, y = 0, m = A; m < p; m++) {
              var _ = this.getRawIndex(m), E = a[_];
              isNaN(E) || (y += E);
            }
            y /= p - A;
            var I = d, x = Math.min(d + l, o), w = d - 1, C = a[u];
            h = -1, f = I;
            for (var S = -1, b = 0, m = I; m < x; m++) {
              var _ = this.getRawIndex(m), E = a[_];
              if (isNaN(E)) {
                b++, S < 0 && (S = _);
                continue;
              }
              c = Math.abs((w - v) * (E - C) - (w - m) * (y - C)), c > h && (h = c, f = _);
            }
            b > 0 && b < x - I && (g[s++] = Math.min(S, f), f = Math.max(S, f)), g[s++] = f, u = f;
          }
          return g[s++] = this.getRawIndex(o - 1), i._count = s, i._indices = g, i.getRawIndex = this._getRawIdx, i;
        }, n.prototype.downSample = function(t, e, i, r) {
          for (var a = this.clone([t], true), o = a._chunks, s = [], l = Math.floor(1 / e), u = o[t], h = this.count(), c = a._rawExtent[t] = Og(), f = new (iv(this._rawCount))(Math.ceil(h / l)), g = 0, d = 0; d < h; d += l) {
            l > h - d && (l = h - d, s.length = l);
            for (var A = 0; A < l; A++) {
              var p = this.getRawIndex(d + A);
              s[A] = u[p];
            }
            var v = i(s), y = this.getRawIndex(Math.min(d + r(s, v) || 0, h - 1));
            u[y] = v, v < c[0] && (c[0] = v), v > c[1] && (c[1] = v), f[g++] = y;
          }
          return a._count = g, a._indices = f, a._updateGetRawIdx(), a;
        }, n.prototype.each = function(t, e) {
          if (this._count) for (var i = t.length, r = this._chunks, a = 0, o = this.count(); a < o; a++) {
            var s = this.getRawIndex(a);
            switch (i) {
              case 0:
                e(a);
                break;
              case 1:
                e(r[t[0]][s], a);
                break;
              case 2:
                e(r[t[0]][s], r[t[1]][s], a);
                break;
              default:
                for (var l = 0, u = []; l < i; l++) u[l] = r[t[l]][s];
                u[l] = a, e.apply(null, u);
            }
          }
        }, n.prototype.getDataExtent = function(t) {
          var e = this._chunks[t], i = Og();
          if (!e) return i;
          var r = this.count(), a = !this._indices, o;
          if (a) return this._rawExtent[t].slice();
          if (o = this._extent[t], o) return o.slice();
          o = i;
          for (var s = o[0], l = o[1], u = 0; u < r; u++) {
            var h = this.getRawIndex(u), c = e[h];
            c < s && (s = c), c > l && (l = c);
          }
          return o = [s, l], this._extent[t] = o, o;
        }, n.prototype.getRawDataItem = function(t) {
          var e = this.getRawIndex(t);
          if (this._provider.persistent) return this._provider.getItem(e);
          for (var i = [], r = this._chunks, a = 0; a < r.length; a++) i.push(r[a][e]);
          return i;
        }, n.prototype.clone = function(t, e) {
          var i = new n(), r = this._chunks, a = t && So(t, function(s, l) {
            return s[l] = true, s;
          }, {});
          if (a) for (var o = 0; o < r.length; o++) i._chunks[o] = a[o] ? sEt(r[o]) : r[o];
          else i._chunks = r;
          return this._copyCommonProps(i), e || (i._indices = this._cloneIndices()), i._updateGetRawIdx(), i;
        }, n.prototype._copyCommonProps = function(t) {
          t._count = this._count, t._rawCount = this._rawCount, t._provider = this._provider, t._dimensions = this._dimensions, t._extent = xt(this._extent), t._rawExtent = xt(this._rawExtent);
        }, n.prototype._cloneIndices = function() {
          if (this._indices) {
            var t = this._indices.constructor, e = void 0;
            if (t === Array) {
              var i = this._indices.length;
              e = new t(i);
              for (var r = 0; r < i; r++) e[r] = this._indices[r];
            } else e = new t(this._indices);
            return e;
          }
          return null;
        }, n.prototype._getRawIdxIdentity = function(t) {
          return t;
        }, n.prototype._getRawIdx = function(t) {
          return t < this._count && t >= 0 ? this._indices[t] : -1;
        }, n.prototype._updateGetRawIdx = function() {
          this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
        }, n.internalField = function() {
          function t(e, i, r, a) {
            return ru(e[a], this._dimensions[a]);
          }
          RB = { arrayRows: t, objectRows: function(e, i, r, a) {
            return ru(e[i], this._dimensions[a]);
          }, keyedColumns: t, original: function(e, i, r, a) {
            var o = e && (e.value == null ? e : e.value);
            return ru(o instanceof Array ? o[a] : o, this._dimensions[a]);
          }, typedArray: function(e, i, r, a) {
            return e[a];
          } };
        }(), n;
      }(), E8 = function() {
        function n(t) {
          this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = true, this._sourceHost = t;
        }
        return n.prototype.dirty = function() {
          this._setLocalSource([], []), this._storeList = [], this._dirty = true;
        }, n.prototype._setLocalSource = function(t, e) {
          this._sourceList = t, this._upstreamSignList = e, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
        }, n.prototype._getVersionSign = function() {
          return this._sourceHost.uid + "_" + this._versionSignBase;
        }, n.prototype.prepareSource = function() {
          this._isDirty() && (this._createSource(), this._dirty = false);
        }, n.prototype._createSource = function() {
          this._setLocalSource([], []);
          var t = this._sourceHost, e = this._getUpstreamSourceManagers(), i = !!e.length, r, a;
          if (rv(t)) {
            var o = t, s = void 0, l = void 0, u = void 0;
            if (i) {
              var h = e[0];
              h.prepareSource(), u = h.getSource(), s = u.data, l = u.sourceFormat, a = [h._getVersionSign()];
            } else s = o.get("data", true), l = Ui(s) ? Fs : da, a = [];
            var c = this._getSourceMetaRawOption() || {}, f = u && u.metaRawOption || {}, g = Pt(c.seriesLayoutBy, f.seriesLayoutBy) || null, d = Pt(c.sourceHeader, f.sourceHeader), A = Pt(c.dimensions, f.dimensions), p = g !== f.seriesLayoutBy || !!d != !!f.sourceHeader || A;
            r = p ? [bB(s, { seriesLayoutBy: g, sourceHeader: d, dimensions: A }, l)] : [];
          } else {
            var v = t;
            if (i) {
              var y = this._applyTransform(e);
              r = y.sourceList, a = y.upstreamSignList;
            } else {
              var m = v.get("source", true);
              r = [bB(m, this._getSourceMetaRawOption(), null)], a = [];
            }
          }
          It(r && a), this._setLocalSource(r, a);
        }, n.prototype._applyTransform = function(t) {
          var e = this._sourceHost, i = e.get("transform", true), r = e.get("fromTransformResult", true);
          if (It(r != null || i != null), r != null) {
            var a = "";
            t.length !== 1 && (a = "When using `fromTransformResult`, there should be only one upstream dataset", w8(a));
          }
          var o, s = [], l = [];
          return M(t, function(u) {
            u.prepareSource();
            var h = u.getSource(r || 0), c = "";
            r != null && !h && (c = "Can not retrieve result by `fromTransformResult`: " + r, w8(c)), s.push(h), l.push(u._getVersionSign());
          }), i ? o = iEt(i, s, { datasetIndex: e.componentIndex }) : r != null && (o = [QIt(s[0])]), { sourceList: o, upstreamSignList: l };
        }, n.prototype._isDirty = function() {
          if (this._dirty) return true;
          for (var t = this._getUpstreamSourceManagers(), e = 0; e < t.length; e++) {
            var i = t[e];
            if (i._isDirty() || this._upstreamSignList[e] !== i._getVersionSign()) return true;
          }
        }, n.prototype.getSource = function(t) {
          t = t || 0;
          var e = this._sourceList[t];
          if (!e) {
            var i = this._getUpstreamSourceManagers();
            return i[0] && i[0].getSource(t);
          }
          return e;
        }, n.prototype.getSharedDataStore = function(t) {
          It(rv(this._sourceHost), "Can only call getDataStore on series source manager.");
          var e = t.makeStoreSchema();
          return this._innerGetDataStore(e.dimensions, t.source, e.hash);
        }, n.prototype._innerGetDataStore = function(t, e, i) {
          var r = 0, a = this._storeList, o = a[r];
          o || (o = a[r] = {});
          var s = o[i];
          if (!s) {
            var l = this._getUpstreamSourceManagers()[0];
            rv(this._sourceHost) && l ? s = l._innerGetDataStore(t, e, i) : (s = new LB(), s.initData(new o8(e, t.length), t)), o[i] = s;
          }
          return s;
        }, n.prototype._getUpstreamSourceManagers = function() {
          var t = this._sourceHost;
          if (rv(t)) {
            var e = vB(t);
            return e ? [e.getSourceManager()] : [];
          } else return Z(cIt(t), function(i) {
            return i.getSourceManager();
          });
        }, n.prototype._getSourceMetaRawOption = function() {
          var t = this._sourceHost, e, i, r;
          if (rv(t)) e = t.get("seriesLayoutBy", true), i = t.get("sourceHeader", true), r = t.get("dimensions", true);
          else if (!this._getUpstreamSourceManagers().length) {
            var a = t;
            e = a.get("seriesLayoutBy", true), i = a.get("sourceHeader", true), r = a.get("dimensions", true);
          }
          return { seriesLayoutBy: e, sourceHeader: i, dimensions: r };
        }, n;
      }();
      function x8(n) {
        var t = n.option.transform;
        t && l_(n.option.transform);
      }
      function rv(n) {
        return n.mainType === "series";
      }
      function w8(n) {
        throw new Error(n);
      }
      var C8 = "line-height:1";
      function S8(n, t) {
        var e = n.color || "#6e7079", i = n.fontSize || 12, r = n.fontWeight || "400", a = n.color || "#464646", o = n.fontSize || 14, s = n.fontWeight || "900";
        return t === "html" ? { nameStyle: "font-size:" + pr(i + "") + "px;color:" + pr(e) + ";font-weight:" + pr(r + ""), valueStyle: "font-size:" + pr(o + "") + "px;color:" + pr(a) + ";font-weight:" + pr(s + "") } : { nameStyle: { fontSize: i, fill: e, fontWeight: r }, valueStyle: { fontSize: o, fill: a, fontWeight: s } };
      }
      var lEt = [0, 10, 20, 30], uEt = ["", `
`, `

`, `


`];
      function Zn(n, t) {
        return t.type = n, t;
      }
      function PB(n) {
        return n.type === "section";
      }
      function b8(n) {
        return PB(n) ? hEt : cEt;
      }
      function B8(n) {
        if (PB(n)) {
          var t = 0, e = n.blocks.length, i = e > 1 || e > 0 && !n.noHeader;
          return M(n.blocks, function(r) {
            var a = B8(r);
            a >= t && (t = a + +(i && (!a || PB(r) && !r.noHeader)));
          }), t;
        }
        return 0;
      }
      function hEt(n, t, e, i) {
        var r = t.noHeader, a = fEt(B8(t)), o = [], s = t.blocks || [];
        It(!s || X(s)), s = s || [];
        var l = n.orderMode;
        if (t.sortBlocks && l) {
          s = s.slice();
          var u = { valueAsc: "asc", valueDesc: "desc" };
          if (ft(u, l)) {
            var h = new p8(u[l], null);
            s.sort(function(d, A) {
              return h.evaluate(d.sortParam, A.sortParam);
            });
          } else l === "seriesDesc" && s.reverse();
        }
        M(s, function(d, A) {
          var p = t.valueFormatter, v = b8(d)(p ? Y(Y({}, n), { valueFormatter: p }) : n, d, A > 0 ? a.html : 0, i);
          v != null && o.push(v);
        });
        var c = n.renderMode === "richText" ? o.join(a.richText) : NB(o.join(""), r ? e : a.html);
        if (r) return c;
        var f = fB(t.header, "ordinal", n.useUTC), g = S8(i, n.renderMode).nameStyle;
        return n.renderMode === "richText" ? M8(n, f, g) + a.richText + c : NB('<div style="' + g + ";" + C8 + ';">' + pr(f) + "</div>" + c, e);
      }
      function cEt(n, t, e, i) {
        var r = n.renderMode, a = t.noName, o = t.noValue, s = !t.markerType, l = t.name, u = n.useUTC, h = t.valueFormatter || n.valueFormatter || function(_) {
          return _ = X(_) ? _ : [_], Z(_, function(E, I) {
            return fB(E, X(g) ? g[I] : g, u);
          });
        };
        if (!(a && o)) {
          var c = s ? "" : n.markupStyleCreator.makeTooltipMarker(t.markerType, t.markerColor || "#333", r), f = a ? "" : fB(l, "ordinal", u), g = t.valueType, d = o ? [] : h(t.value, t.dataIndex), A = !s || !a, p = !s && a, v = S8(i, r), y = v.nameStyle, m = v.valueStyle;
          return r === "richText" ? (s ? "" : c) + (a ? "" : M8(n, f, y)) + (o ? "" : AEt(n, d, A, p, m)) : NB((s ? "" : c) + (a ? "" : gEt(f, !s, y)) + (o ? "" : dEt(d, A, p, m)), e);
        }
      }
      function T8(n, t, e, i, r, a) {
        if (n) {
          var o = b8(n), s = { useUTC: r, renderMode: e, orderMode: i, markupStyleCreator: t, valueFormatter: n.valueFormatter };
          return o(s, n, 0, a);
        }
      }
      function fEt(n) {
        return { html: lEt[n], richText: uEt[n] };
      }
      function NB(n, t) {
        var e = '<div style="clear:both"></div>', i = "margin: " + t + "px 0 0";
        return '<div style="' + i + ";" + C8 + ';">' + n + e + "</div>";
      }
      function gEt(n, t, e) {
        var i = t ? "margin-left:2px" : "";
        return '<span style="' + e + ";" + i + '">' + pr(n) + "</span>";
      }
      function dEt(n, t, e, i) {
        var r = e ? "10px" : "20px", a = t ? "float:right;margin-left:" + r : "";
        return n = X(n) ? n : [n], '<span style="' + a + ";" + i + '">' + Z(n, function(o) {
          return pr(o);
        }).join("&nbsp;&nbsp;") + "</span>";
      }
      function M8(n, t, e) {
        return n.markupStyleCreator.wrapRichTextStyle(t, e);
      }
      function AEt(n, t, e, i, r) {
        var a = [r], o = i ? 10 : 20;
        return e && a.push({ padding: [0, 0, 0, o], align: "right" }), n.markupStyleCreator.wrapRichTextStyle(X(t) ? t.join("  ") : t, a);
      }
      function D8(n, t) {
        var e = n.getData().getItemVisual(t, "style"), i = e[n.visualDrawType];
        return Nh(i);
      }
      function R8(n, t) {
        var e = n.get("padding");
        return e != null ? e : t === "richText" ? [8, 10] : 10;
      }
      var kB = function() {
        function n() {
          this.richTextStyles = {}, this._nextStyleNameId = DG();
        }
        return n.prototype._generateStyleName = function() {
          return "__EC_aUTo_" + this._nextStyleNameId++;
        }, n.prototype.makeTooltipMarker = function(t, e, i) {
          var r = i === "richText" ? this._generateStyleName() : null, a = rIt({ color: e, type: t, renderMode: i, markerId: r });
          return ht(a) ? a : (It(r), this.richTextStyles[r] = a.style, a.content);
        }, n.prototype.wrapRichTextStyle = function(t, e) {
          var i = {};
          X(e) ? M(e, function(a) {
            return Y(i, a);
          }) : Y(i, e);
          var r = this._generateStyleName();
          return this.richTextStyles[r] = i, "{" + r + "|" + t + "}";
        }, n;
      }();
      function L8(n) {
        var t = n.series, e = n.dataIndex, i = n.multipleSeries, r = t.getData(), a = r.mapDimensionsAll("defaultedTooltip"), o = a.length, s = t.getRawValue(e), l = X(s), u = D8(t, e), h, c, f, g;
        if (o > 1 || l && !o) {
          var d = pEt(s, t, e, a, u);
          h = d.inlineValues, c = d.inlineValueTypes, f = d.blocks, g = d.inlineValues[0];
        } else if (o) {
          var A = r.getDimensionInfo(a[0]);
          g = h = Qg(r, e, a[0]), c = A.type;
        } else g = h = l ? s[0] : s;
        var p = d2(t), v = p && t.name || "", y = r.getName(e), m = i ? v : y;
        return Zn("section", { header: v, noHeader: i || !p, sortParam: g, blocks: [Zn("nameValue", { markerType: "item", markerColor: u, name: m, noName: !Ga(m), value: h, valueType: c, dataIndex: e })].concat(f || []) });
      }
      function pEt(n, t, e, i, r) {
        var a = t.getData(), o = So(n, function(c, f, g) {
          var d = a.getDimensionInfo(g);
          return c = c || d && d.tooltip !== false && d.displayName != null;
        }, false), s = [], l = [], u = [];
        i.length ? M(i, function(c) {
          h(Qg(a, e, c), c);
        }) : M(n, h);
        function h(c, f) {
          var g = a.getDimensionInfo(f);
          !g || g.otherDims.tooltip === false || (o ? u.push(Zn("nameValue", { markerType: "subItem", markerColor: r, name: g.displayName, value: c, valueType: g.type })) : (s.push(c), l.push(g.type)));
        }
        return { inlineValues: s, inlineValueTypes: l, blocks: u };
      }
      var au = le();
      function D1(n, t) {
        return n.getName(t) || n.getId(t);
      }
      var R1 = "__universalTransitionEnabled", $e = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e._selectedDataIndicesMap = {}, e;
        }
        return t.prototype.init = function(e, i, r) {
          this.seriesIndex = this.componentIndex, this.dataTask = nv({ count: yEt, reset: mEt }), this.dataTask.context = { model: this }, this.mergeDefaultAndTheme(e, r);
          var a = au(this).sourceManager = new E8(this);
          a.prepareSource();
          var o = this.getInitialData(e, r);
          N8(o, this), this.dataTask.context.data = o, It(o, "getInitialData returned invalid data."), au(this).dataBeforeProcessed = o, P8(this), this._initSelectedMapFromData(o);
        }, t.prototype.mergeDefaultAndTheme = function(e, i) {
          var r = Kp(this), a = r ? Pg(e) : {}, o = this.subType;
          ne.hasClass(o) && (o += "Series"), qt(e, i.getTheme().get(this.subType)), qt(e, this.getDefaultOption()), dh(e, "label", ["show"]), this.fillDataTextStyle(e.data), r && iu(e, a, r);
        }, t.prototype.mergeOption = function(e, i) {
          e = qt(this.option, e, true), this.fillDataTextStyle(e.data);
          var r = Kp(this);
          r && iu(this.option, e, r);
          var a = au(this).sourceManager;
          a.dirty(), a.prepareSource();
          var o = this.getInitialData(e, i);
          N8(o, this), this.dataTask.dirty(), this.dataTask.context.data = o, au(this).dataBeforeProcessed = o, P8(this), this._initSelectedMapFromData(o);
        }, t.prototype.fillDataTextStyle = function(e) {
          if (e && !Ui(e)) for (var i = ["show"], r = 0; r < e.length; r++) e[r] && e[r].label && dh(e[r], "label", i);
        }, t.prototype.getInitialData = function(e, i) {
        }, t.prototype.appendData = function(e) {
          var i = this.getRawData();
          i.appendData(e.data);
        }, t.prototype.getData = function(e) {
          var i = FB(this);
          if (i) {
            var r = i.context.data;
            return e == null || !r.getLinkedData ? r : r.getLinkedData(e);
          } else return au(this).data;
        }, t.prototype.getAllData = function() {
          var e = this.getData();
          return e && e.getLinkedDataAll ? e.getLinkedDataAll() : [{ data: e }];
        }, t.prototype.setData = function(e) {
          var i = FB(this);
          if (i) {
            var r = i.context;
            r.outputData = e, i !== this.dataTask && (r.data = e);
          }
          au(this).data = e;
        }, t.prototype.getEncode = function() {
          var e = this.get("encode", true);
          if (e) return dt(e);
        }, t.prototype.getSourceManager = function() {
          return au(this).sourceManager;
        }, t.prototype.getSource = function() {
          return this.getSourceManager().getSource();
        }, t.prototype.getRawData = function() {
          return au(this).dataBeforeProcessed;
        }, t.prototype.getColorBy = function() {
          var e = this.get("colorBy");
          return e || "series";
        }, t.prototype.isColorBySeries = function() {
          return this.getColorBy() === "series";
        }, t.prototype.getBaseAxis = function() {
          var e = this.coordinateSystem;
          return e && e.getBaseAxis && e.getBaseAxis();
        }, t.prototype.formatTooltip = function(e, i, r) {
          return L8({ series: this, dataIndex: e, multipleSeries: i });
        }, t.prototype.isAnimationEnabled = function() {
          var e = this.ecModel;
          if (ee.node && !(e && e.ssr)) return false;
          var i = this.getShallow("animation");
          return i && this.getData().count() > this.getShallow("animationThreshold") && (i = false), !!i;
        }, t.prototype.restoreData = function() {
          this.dataTask.dirty();
        }, t.prototype.getColorFromPalette = function(e, i, r) {
          var a = this.ecModel, o = mB.prototype.getColorFromPalette.call(this, e, i, r);
          return o || (o = a.getColorFromPalette(e, i, r)), o;
        }, t.prototype.coordDimToDataDim = function(e) {
          return this.getRawData().mapDimensionsAll(e);
        }, t.prototype.getProgressive = function() {
          return this.get("progressive");
        }, t.prototype.getProgressiveThreshold = function() {
          return this.get("progressiveThreshold");
        }, t.prototype.select = function(e, i) {
          this._innerSelect(this.getData(i), e);
        }, t.prototype.unselect = function(e, i) {
          var r = this.option.selectedMap;
          if (r) {
            var a = this.option.selectedMode, o = this.getData(i);
            if (a === "series" || r === "all") {
              this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
              return;
            }
            for (var s = 0; s < e.length; s++) {
              var l = e[s], u = D1(o, l);
              r[u] = false, this._selectedDataIndicesMap[u] = -1;
            }
          }
        }, t.prototype.toggleSelect = function(e, i) {
          for (var r = [], a = 0; a < e.length; a++) r[0] = e[a], this.isSelected(e[a], i) ? this.unselect(r, i) : this.select(r, i);
        }, t.prototype.getSelectedDataIndices = function() {
          if (this.option.selectedMap === "all") return [].slice.call(this.getData().getIndices());
          for (var e = this._selectedDataIndicesMap, i = re(e), r = [], a = 0; a < i.length; a++) {
            var o = e[i[a]];
            o >= 0 && r.push(o);
          }
          return r;
        }, t.prototype.isSelected = function(e, i) {
          var r = this.option.selectedMap;
          if (!r) return false;
          var a = this.getData(i);
          return (r === "all" || r[D1(a, e)]) && !a.getItemModel(e).get(["select", "disabled"]);
        }, t.prototype.isUniversalTransitionEnabled = function() {
          if (this[R1]) return true;
          var e = this.option.universalTransition;
          return e ? e === true ? true : e && e.enabled : false;
        }, t.prototype._innerSelect = function(e, i) {
          var r, a, o = this.option, s = o.selectedMode, l = i.length;
          if (!(!s || !l)) {
            if (s === "series") o.selectedMap = "all";
            else if (s === "multiple") {
              _t(o.selectedMap) || (o.selectedMap = {});
              for (var u = o.selectedMap, h = 0; h < l; h++) {
                var c = i[h], f = D1(e, c);
                u[f] = true, this._selectedDataIndicesMap[f] = e.getRawIndex(c);
              }
            } else if (s === "single" || s === true) {
              var g = i[l - 1], f = D1(e, g);
              o.selectedMap = (r = {}, r[f] = true, r), this._selectedDataIndicesMap = (a = {}, a[f] = e.getRawIndex(g), a);
            }
          }
        }, t.prototype._initSelectedMapFromData = function(e) {
          if (!this.option.selectedMap) {
            var i = [];
            e.hasItemOption && e.each(function(r) {
              var a = e.getRawDataItem(r);
              a && a.selected && i.push(r);
            }), i.length > 0 && this._innerSelect(e, i);
          }
        }, t.registerClass = function(e) {
          return ne.registerClass(e);
        }, t.protoInitialize = function() {
          var e = t.prototype;
          e.type = "series.__base__", e.seriesIndex = 0, e.ignoreStyleOnData = false, e.hasSymbolVisual = false, e.defaultSymbol = "circle", e.visualStyleAccessPath = "itemStyle", e.visualDrawType = "fill";
        }(), t;
      }(ne);
      Mn($e, T1), Mn($e, mB), HG($e, ne);
      function P8(n) {
        var t = n.name;
        d2(n) || (n.name = vEt(n) || t);
      }
      function vEt(n) {
        var t = n.getRawData(), e = t.mapDimensionsAll("seriesName"), i = [];
        return M(e, function(r) {
          var a = t.getDimensionInfo(r);
          a.displayName && i.push(a.displayName);
        }), i.join(" ");
      }
      function yEt(n) {
        return n.model.getRawData().count();
      }
      function mEt(n) {
        var t = n.model;
        return t.setData(t.getRawData().cloneShallow()), _Et;
      }
      function _Et(n, t) {
        t.outputData && n.end > t.outputData.count() && t.model.getRawData().cloneShallow(t.outputData);
      }
      function N8(n, t) {
        M(u_(n.CHANGABLE_METHODS, n.DOWNSAMPLE_METHODS), function(e) {
          n.wrapMethod(e, Ot(IEt, t));
        });
      }
      function IEt(n, t) {
        var e = FB(n);
        return e && e.setOutputEnd((t || this).count()), t;
      }
      function FB(n) {
        var t = (n.ecModel || {}).scheduler, e = t && t.getPipeline(n.uid);
        if (e) {
          var i = e.currentTask;
          if (i) {
            var r = i.agentStubMap;
            r && (i = r.get(n.uid));
          }
          return i;
        }
      }
      var on = function() {
        function n() {
          this.group = new Ct(), this.uid = Tg("viewComponent");
        }
        return n.prototype.init = function(t, e) {
        }, n.prototype.render = function(t, e, i, r) {
        }, n.prototype.dispose = function(t, e) {
        }, n.prototype.updateView = function(t, e, i, r) {
        }, n.prototype.updateLayout = function(t, e, i, r) {
        }, n.prototype.updateVisual = function(t, e, i, r) {
        }, n.prototype.toggleBlurSeries = function(t, e, i) {
        }, n.prototype.eachRendered = function(t) {
          var e = this.group;
          e && e.traverse(t);
        }, n;
      }();
      v2(on), G_(on);
      function zg() {
        var n = le();
        return function(t) {
          var e = n(t), i = t.pipelineContext, r = !!e.large, a = !!e.progressiveRender, o = e.large = !!(i && i.large), s = e.progressiveRender = !!(i && i.progressiveRender);
          return (r !== o || a !== s) && "reset";
        };
      }
      var k8 = le(), EEt = zg(), Ve = function() {
        function n() {
          this.group = new Ct(), this.uid = Tg("viewChart"), this.renderTask = nv({ plan: xEt, reset: wEt }), this.renderTask.context = { view: this };
        }
        return n.prototype.init = function(t, e) {
        }, n.prototype.render = function(t, e, i, r) {
          if (true) throw new Error("render method must been implemented");
        }, n.prototype.highlight = function(t, e, i, r) {
          var a = t.getData(r && r.dataType);
          if (!a) {
            Ai("Unknown dataType " + r.dataType);
            return;
          }
          Q8(a, r, "emphasis");
        }, n.prototype.downplay = function(t, e, i, r) {
          var a = t.getData(r && r.dataType);
          if (!a) {
            Ai("Unknown dataType " + r.dataType);
            return;
          }
          Q8(a, r, "normal");
        }, n.prototype.remove = function(t, e) {
          this.group.removeAll();
        }, n.prototype.dispose = function(t, e) {
        }, n.prototype.updateView = function(t, e, i, r) {
          this.render(t, e, i, r);
        }, n.prototype.updateLayout = function(t, e, i, r) {
          this.render(t, e, i, r);
        }, n.prototype.updateVisual = function(t, e, i, r) {
          this.render(t, e, i, r);
        }, n.prototype.eachRendered = function(t) {
          tu(this.group, t);
        }, n.markUpdateMethod = function(t, e) {
          k8(t).updateMethod = e;
        }, n.protoInitialize = function() {
          var t = n.prototype;
          t.type = "chart";
        }(), n;
      }();
      function F8(n, t, e) {
        n && $l(n) && (t === "emphasis" ? Ps : Ns)(n, e);
      }
      function Q8(n, t, e) {
        var i = Ah(n, t), r = t && t.highlightKey != null ? r1t(t.highlightKey) : null;
        i != null ? M(Qe(i), function(a) {
          F8(n.getItemGraphicEl(a), e, r);
        }) : n.eachItemGraphicEl(function(a) {
          F8(a, e, r);
        });
      }
      v2(Ve, ["dispose"]), G_(Ve);
      function xEt(n) {
        return EEt(n.model);
      }
      function wEt(n) {
        var t = n.model, e = n.ecModel, i = n.api, r = n.payload, a = t.pipelineContext.progressiveRender, o = n.view, s = r && k8(r).updateMethod, l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render";
        return l !== "render" && o[l](t, e, i, r), CEt[l];
      }
      var CEt = { incrementalPrepareRender: { progress: function(n, t) {
        t.view.incrementalRender(n, t.model, t.ecModel, t.api, t.payload);
      } }, render: { forceFirstProgress: true, progress: function(n, t) {
        t.view.render(t.model, t.ecModel, t.api, t.payload);
      } } }, L1 = "\0__throttleOriginMethod", O8 = "\0__throttleRate", z8 = "\0__throttleType";
      function QB(n, t, e) {
        var i, r = 0, a = 0, o = null, s, l, u, h;
        t = t || 0;
        function c() {
          a = (/* @__PURE__ */ new Date()).getTime(), o = null, n.apply(l, u || []);
        }
        var f = function() {
          for (var g = [], d = 0; d < arguments.length; d++) g[d] = arguments[d];
          i = (/* @__PURE__ */ new Date()).getTime(), l = this, u = g;
          var A = h || t, p = h || e;
          h = null, s = i - (p ? r : a) - A, clearTimeout(o), p ? o = setTimeout(c, A) : s >= 0 ? c() : o = setTimeout(c, -s), r = i;
        };
        return f.clear = function() {
          o && (clearTimeout(o), o = null);
        }, f.debounceNextCall = function(g) {
          h = g;
        }, f;
      }
      function Gg(n, t, e, i) {
        var r = n[t];
        if (r) {
          var a = r[L1] || r, o = r[z8], s = r[O8];
          if (s !== e || o !== i) {
            if (e == null || !i) return n[t] = a;
            r = n[t] = QB(a, e, i === "debounce"), r[L1] = a, r[z8] = i, r[O8] = e;
          }
          return r;
        }
      }
      function av(n, t) {
        var e = n[t];
        e && e[L1] && (e.clear && e.clear(), n[t] = e[L1]);
      }
      var G8 = le(), U8 = { itemStyle: vh(g4, true), lineStyle: vh(f4, true) }, SEt = { lineStyle: "stroke", itemStyle: "fill" };
      function V8(n, t) {
        var e = n.visualStyleMapper || U8[t];
        return e || U8.itemStyle;
      }
      function j8(n, t) {
        var e = n.visualDrawType || SEt[t];
        return e || "fill";
      }
      var bEt = { createOnAllSeries: true, performRawSeries: true, reset: function(n, t) {
        var e = n.getData(), i = n.visualStyleAccessPath || "itemStyle", r = n.getModel(i), a = V8(n, i), o = a(r), s = r.getShallow("decal");
        s && (e.setVisual("decal", s), s.dirty = true);
        var l = j8(n, i), u = o[l], h = yt(u) ? u : null, c = o.fill === "auto" || o.stroke === "auto";
        if (!o[l] || h || c) {
          var f = n.getColorFromPalette(n.name, null, t.getSeriesCount());
          o[l] || (o[l] = f, e.setVisual("colorFromPalette", true)), o.fill = o.fill === "auto" || yt(o.fill) ? f : o.fill, o.stroke = o.stroke === "auto" || yt(o.stroke) ? f : o.stroke;
        }
        if (e.setVisual("style", o), e.setVisual("drawType", l), !t.isSeriesFiltered(n) && h) return e.setVisual("colorFromPalette", false), { dataEach: function(g, d) {
          var A = n.getDataParams(d), p = Y({}, o);
          p[l] = h(A), g.setItemVisual(d, "style", p);
        } };
      } }, ov = new Te(), BEt = { createOnAllSeries: true, performRawSeries: true, reset: function(n, t) {
        if (!(n.ignoreStyleOnData || t.isSeriesFiltered(n))) {
          var e = n.getData(), i = n.visualStyleAccessPath || "itemStyle", r = V8(n, i), a = e.getVisual("drawType");
          return { dataEach: e.hasItemOption ? function(o, s) {
            var l = o.getRawDataItem(s);
            if (l && l[i]) {
              ov.option = l[i];
              var u = r(ov), h = o.ensureUniqueItemVisual(s, "style");
              Y(h, u), ov.option.decal && (o.setItemVisual(s, "decal", ov.option.decal), ov.option.decal.dirty = true), a in u && o.setItemVisual(s, "colorFromPalette", false);
            }
          } : null };
        }
      } }, TEt = { performRawSeries: true, overallReset: function(n) {
        var t = dt();
        n.eachSeries(function(e) {
          var i = e.getColorBy();
          if (!e.isColorBySeries()) {
            var r = e.type + "-" + i, a = t.get(r);
            a || (a = {}, t.set(r, a)), G8(e).scope = a;
          }
        }), n.eachSeries(function(e) {
          if (!(e.isColorBySeries() || n.isSeriesFiltered(e))) {
            var i = e.getRawData(), r = {}, a = e.getData(), o = G8(e).scope, s = e.visualStyleAccessPath || "itemStyle", l = j8(e, s);
            a.each(function(u) {
              var h = a.getRawIndex(u);
              r[h] = u;
            }), i.each(function(u) {
              var h = r[u], c = a.getItemVisual(h, "colorFromPalette");
              if (c) {
                var f = a.ensureUniqueItemVisual(h, "style"), g = i.getName(u) || u + "", d = i.count();
                f[l] = e.getColorFromPalette(g, o, d);
              }
            });
          }
        });
      } }, P1 = Math.PI;
      function MEt(n, t) {
        t = t || {}, Et(t, { text: "loading", textColor: "#000", fontSize: 12, fontWeight: "normal", fontStyle: "normal", fontFamily: "sans-serif", maskColor: "rgba(255, 255, 255, 0.8)", showSpinner: true, color: "#5470c6", spinnerRadius: 10, lineWidth: 5, zlevel: 0 });
        var e = new Ct(), i = new ue({ style: { fill: t.maskColor }, zlevel: t.zlevel, z: 1e4 });
        e.add(i);
        var r = new ge({ style: { text: t.text, fill: t.textColor, fontSize: t.fontSize, fontWeight: t.fontWeight, fontStyle: t.fontStyle, fontFamily: t.fontFamily }, zlevel: t.zlevel, z: 10001 }), a = new ue({ style: { fill: "none" }, textContent: r, textConfig: { position: "right", distance: 10 }, zlevel: t.zlevel, z: 10001 });
        e.add(a);
        var o;
        return t.showSpinner && (o = new r1({ shape: { startAngle: -P1 / 2, endAngle: -P1 / 2 + 0.1, r: t.spinnerRadius }, style: { stroke: t.color, lineCap: "round", lineWidth: t.lineWidth }, zlevel: t.zlevel, z: 10001 }), o.animateShape(true).when(1e3, { endAngle: P1 * 3 / 2 }).start("circularInOut"), o.animateShape(true).when(1e3, { startAngle: P1 * 3 / 2 }).delay(300).start("circularInOut"), e.add(o)), e.resize = function() {
          var s = r.getBoundingRect().width, l = t.showSpinner ? t.spinnerRadius : 0, u = (n.getWidth() - l * 2 - (t.showSpinner && s ? 10 : 0) - s) / 2 - (t.showSpinner && s ? 0 : 5 + s / 2) + (t.showSpinner ? 0 : s / 2) + (s ? 0 : l), h = n.getHeight() / 2;
          t.showSpinner && o.setShape({ cx: u, cy: h }), a.setShape({ x: u - l, y: h - l, width: l * 2, height: l * 2 }), i.setShape({ x: 0, y: 0, width: n.getWidth(), height: n.getHeight() });
        }, e.resize(), e;
      }
      var q8 = function() {
        function n(t, e, i, r) {
          this._stageTaskMap = dt(), this.ecInstance = t, this.api = e, i = this._dataProcessorHandlers = i.slice(), r = this._visualHandlers = r.slice(), this._allHandlers = i.concat(r);
        }
        return n.prototype.restoreData = function(t, e) {
          t.restoreData(e), this._stageTaskMap.each(function(i) {
            var r = i.overallTask;
            r && r.dirty();
          });
        }, n.prototype.getPerformArgs = function(t, e) {
          if (t.__pipeline) {
            var i = this._pipelineMap.get(t.__pipeline.id), r = i.context, a = !e && i.progressiveEnabled && (!r || r.progressiveRender) && t.__idxInPipeline > i.blockIndex, o = a ? i.step : null, s = r && r.modDataCount, l = s != null ? Math.ceil(s / o) : null;
            return { step: o, modBy: l, modDataCount: s };
          }
        }, n.prototype.getPipeline = function(t) {
          return this._pipelineMap.get(t);
        }, n.prototype.updateStreamModes = function(t, e) {
          var i = this._pipelineMap.get(t.uid), r = t.getData(), a = r.count(), o = i.progressiveEnabled && e.incrementalPrepareRender && a >= i.threshold, s = t.get("large") && a >= t.get("largeThreshold"), l = t.get("progressiveChunkMode") === "mod" ? a : null;
          t.pipelineContext = i.context = { progressiveRender: o, modDataCount: l, large: s };
        }, n.prototype.restorePipelines = function(t) {
          var e = this, i = e._pipelineMap = dt();
          t.eachSeries(function(r) {
            var a = r.getProgressive(), o = r.uid;
            i.set(o, { id: o, head: null, tail: null, threshold: r.getProgressiveThreshold(), progressiveEnabled: a && !(r.preventIncremental && r.preventIncremental()), blockIndex: -1, step: Math.round(a || 700), count: 0 }), e._pipe(r, r.dataTask);
          });
        }, n.prototype.prepareStageTasks = function() {
          var t = this._stageTaskMap, e = this.api.getModel(), i = this.api;
          M(this._allHandlers, function(r) {
            var a = t.get(r.uid) || t.set(r.uid, {}), o = "";
            o = '"reset" and "overallReset" must not be both specified.', It(!(r.reset && r.overallReset), o), r.reset && this._createSeriesStageTask(r, a, e, i), r.overallReset && this._createOverallStageTask(r, a, e, i);
          }, this);
        }, n.prototype.prepareView = function(t, e, i, r) {
          var a = t.renderTask, o = a.context;
          o.model = e, o.ecModel = i, o.api = r, a.__block = !t.incrementalPrepareRender, this._pipe(e, a);
        }, n.prototype.performDataProcessorTasks = function(t, e) {
          this._performStageTasks(this._dataProcessorHandlers, t, e, { block: true });
        }, n.prototype.performVisualTasks = function(t, e, i) {
          this._performStageTasks(this._visualHandlers, t, e, i);
        }, n.prototype._performStageTasks = function(t, e, i, r) {
          r = r || {};
          var a = false, o = this;
          M(t, function(l, u) {
            if (!(r.visualType && r.visualType !== l.visualType)) {
              var h = o._stageTaskMap.get(l.uid), c = h.seriesTaskMap, f = h.overallTask;
              if (f) {
                var g, d = f.agentStubMap;
                d.each(function(p) {
                  s(r, p) && (p.dirty(), g = true);
                }), g && f.dirty(), o.updatePayload(f, i);
                var A = o.getPerformArgs(f, r.block);
                d.each(function(p) {
                  p.perform(A);
                }), f.perform(A) && (a = true);
              } else c && c.each(function(p, v) {
                s(r, p) && p.dirty();
                var y = o.getPerformArgs(p, r.block);
                y.skip = !l.performRawSeries && e.isSeriesFiltered(p.context.model), o.updatePayload(p, i), p.perform(y) && (a = true);
              });
            }
          });
          function s(l, u) {
            return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
          }
          this.unfinished = a || this.unfinished;
        }, n.prototype.performSeriesTasks = function(t) {
          var e;
          t.eachSeries(function(i) {
            e = i.dataTask.perform() || e;
          }), this.unfinished = e || this.unfinished;
        }, n.prototype.plan = function() {
          this._pipelineMap.each(function(t) {
            var e = t.tail;
            do {
              if (e.__block) {
                t.blockIndex = e.__idxInPipeline;
                break;
              }
              e = e.getUpstream();
            } while (e);
          });
        }, n.prototype.updatePayload = function(t, e) {
          e !== "remain" && (t.context.payload = e);
        }, n.prototype._createSeriesStageTask = function(t, e, i, r) {
          var a = this, o = e.seriesTaskMap, s = e.seriesTaskMap = dt(), l = t.seriesType, u = t.getTargetSeries;
          t.createOnAllSeries ? i.eachRawSeries(h) : l ? i.eachRawSeriesByType(l, h) : u && u(i, r).each(h);
          function h(c) {
            var f = c.uid, g = s.set(f, o && o.get(f) || nv({ plan: NEt, reset: kEt, count: QEt }));
            g.context = { model: c, ecModel: i, api: r, useClearVisual: t.isVisual && !t.isLayout, plan: t.plan, reset: t.reset, scheduler: a }, a._pipe(c, g);
          }
        }, n.prototype._createOverallStageTask = function(t, e, i, r) {
          var a = this, o = e.overallTask = e.overallTask || nv({ reset: DEt });
          o.context = { ecModel: i, api: r, overallReset: t.overallReset, scheduler: a };
          var s = o.agentStubMap, l = o.agentStubMap = dt(), u = t.seriesType, h = t.getTargetSeries, c = true, f = false, g = "";
          g = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.', It(!t.createOnAllSeries, g), u ? i.eachRawSeriesByType(u, d) : h ? h(i, r).each(d) : (c = false, M(i.getSeries(), d));
          function d(A) {
            var p = A.uid, v = l.set(p, s && s.get(p) || (f = true, nv({ reset: REt, onDirty: PEt })));
            v.context = { model: A, overallProgress: c }, v.agent = o, v.__block = c, a._pipe(A, v);
          }
          f && o.dirty();
        }, n.prototype._pipe = function(t, e) {
          var i = t.uid, r = this._pipelineMap.get(i);
          !r.head && (r.head = e), r.tail && r.tail.pipe(e), r.tail = e, e.__idxInPipeline = r.count++, e.__pipeline = r;
        }, n.wrapStageHandler = function(t, e) {
          return yt(t) && (t = { overallReset: t, seriesType: OEt(t) }), t.uid = Tg("stageHandler"), e && (t.visualType = e), t;
        }, n;
      }();
      function DEt(n) {
        n.overallReset(n.ecModel, n.api, n.payload);
      }
      function REt(n) {
        return n.overallProgress && LEt;
      }
      function LEt() {
        this.agent.dirty(), this.getDownstream().dirty();
      }
      function PEt() {
        this.agent && this.agent.dirty();
      }
      function NEt(n) {
        return n.plan ? n.plan(n.model, n.ecModel, n.api, n.payload) : null;
      }
      function kEt(n) {
        n.useClearVisual && n.data.clearAllVisual();
        var t = n.resetDefines = Qe(n.reset(n.model, n.ecModel, n.api, n.payload));
        return t.length > 1 ? Z(t, function(e, i) {
          return H8(i);
        }) : FEt;
      }
      var FEt = H8(0);
      function H8(n) {
        return function(t, e) {
          var i = e.data, r = e.resetDefines[n];
          if (r && r.dataEach) for (var a = t.start; a < t.end; a++) r.dataEach(i, a);
          else r && r.progress && r.progress(t, i);
        };
      }
      function QEt(n) {
        return n.data.count();
      }
      function OEt(n) {
        N1 = null;
        try {
          n(sv, Y8);
        } catch (t) {
        }
        return N1;
      }
      var sv = {}, Y8 = {}, N1;
      W8(sv, EB), W8(Y8, H4), sv.eachSeriesByType = sv.eachRawSeriesByType = function(n) {
        N1 = n;
      }, sv.eachComponent = function(n) {
        n.mainType === "series" && n.subType && (N1 = n.subType);
      };
      function W8(n, t) {
        for (var e in t.prototype) n[e] = In;
      }
      var X8 = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
      const zEt = { color: X8, colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], X8] };
      var Xi = "#B9B8CE", Z8 = "#100C2A", k1 = function() {
        return { axisLine: { lineStyle: { color: Xi } }, splitLine: { lineStyle: { color: "#484753" } }, splitArea: { areaStyle: { color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"] } }, minorSplitLine: { lineStyle: { color: "#20203B" } } };
      }, K8 = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"], $8 = { darkMode: true, color: K8, backgroundColor: Z8, axisPointer: { lineStyle: { color: "#817f91" }, crossStyle: { color: "#817f91" }, label: { color: "#fff" } }, legend: { textStyle: { color: Xi } }, textStyle: { color: Xi }, title: { textStyle: { color: "#EEF1FA" }, subtextStyle: { color: "#B9B8CE" } }, toolbox: { iconStyle: { borderColor: Xi } }, dataZoom: { borderColor: "#71708A", textStyle: { color: Xi }, brushStyle: { color: "rgba(135,163,206,0.3)" }, handleStyle: { color: "#353450", borderColor: "#C5CBE3" }, moveHandleStyle: { color: "#B0B6C3", opacity: 0.3 }, fillerColor: "rgba(135,163,206,0.2)", emphasis: { handleStyle: { borderColor: "#91B7F2", color: "#4D587D" }, moveHandleStyle: { color: "#636D9A", opacity: 0.7 } }, dataBackground: { lineStyle: { color: "#71708A", width: 1 }, areaStyle: { color: "#71708A" } }, selectedDataBackground: { lineStyle: { color: "#87A3CE" }, areaStyle: { color: "#87A3CE" } } }, visualMap: { textStyle: { color: Xi } }, timeline: { lineStyle: { color: Xi }, label: { color: Xi }, controlStyle: { color: Xi, borderColor: Xi } }, calendar: { itemStyle: { color: Z8 }, dayLabel: { color: Xi }, monthLabel: { color: Xi }, yearLabel: { color: Xi } }, timeAxis: k1(), logAxis: k1(), valueAxis: k1(), categoryAxis: k1(), line: { symbol: "circle" }, graph: { color: K8 }, gauge: { title: { color: Xi }, axisLine: { lineStyle: { color: [[1, "rgba(207,212,219,0.2)"]] } }, axisLabel: { color: Xi }, detail: { color: "#EEF1FA" } }, candlestick: { itemStyle: { color: "#f64e56", color0: "#54ea92", borderColor: "#f64e56", borderColor0: "#54ea92" } } };
      $8.categoryAxis.splitLine.show = false;
      var GEt = function() {
        function n() {
        }
        return n.prototype.normalizeQuery = function(t) {
          var e = {}, i = {}, r = {};
          if (ht(t)) {
            var a = Ro(t);
            e.mainType = a.main || null, e.subType = a.sub || null;
          } else {
            var o = ["Index", "Name", "Id"], s = { name: 1, dataIndex: 1, dataType: 1 };
            M(t, function(l, u) {
              for (var h = false, c = 0; c < o.length; c++) {
                var f = o[c], g = u.lastIndexOf(f);
                if (g > 0 && g === u.length - f.length) {
                  var d = u.slice(0, g);
                  d !== "data" && (e.mainType = d, e[f.toLowerCase()] = l, h = true);
                }
              }
              s.hasOwnProperty(u) && (i[u] = l, h = true), h || (r[u] = l);
            });
          }
          return { cptQuery: e, dataQuery: i, otherQuery: r };
        }, n.prototype.filter = function(t, e) {
          var i = this.eventInfo;
          if (!i) return true;
          var r = i.targetEl, a = i.packedEvent, o = i.model, s = i.view;
          if (!o || !s) return true;
          var l = e.cptQuery, u = e.dataQuery;
          return h(l, o, "mainType") && h(l, o, "subType") && h(l, o, "index", "componentIndex") && h(l, o, "name") && h(l, o, "id") && h(u, a, "name") && h(u, a, "dataIndex") && h(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(t, e.otherQuery, r, a));
          function h(c, f, g, d) {
            return c[g] == null || f[d || g] === c[g];
          }
        }, n.prototype.afterTrigger = function() {
          this.eventInfo = null;
        }, n;
      }(), OB = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], J8 = OB.concat(["symbolKeepAspect"]), UEt = { createOnAllSeries: true, performRawSeries: true, reset: function(n, t) {
        var e = n.getData();
        if (n.legendIcon && e.setVisual("legendIcon", n.legendIcon), !n.hasSymbolVisual) return;
        for (var i = {}, r = {}, a = false, o = 0; o < OB.length; o++) {
          var s = OB[o], l = n.get(s);
          yt(l) ? (a = true, r[s] = l) : i[s] = l;
        }
        if (i.symbol = i.symbol || n.defaultSymbol, e.setVisual(Y({ legendIcon: n.legendIcon || i.symbol, symbolKeepAspect: n.get("symbolKeepAspect") }, i)), t.isSeriesFiltered(n)) return;
        var u = re(r);
        function h(c, f) {
          for (var g = n.getRawValue(f), d = n.getDataParams(f), A = 0; A < u.length; A++) {
            var p = u[A];
            c.setItemVisual(f, p, r[p](g, d));
          }
        }
        return { dataEach: a ? h : null };
      } }, VEt = { createOnAllSeries: true, performRawSeries: true, reset: function(n, t) {
        if (!n.hasSymbolVisual || t.isSeriesFiltered(n)) return;
        var e = n.getData();
        function i(r, a) {
          for (var o = r.getItemModel(a), s = 0; s < J8.length; s++) {
            var l = J8[s], u = o.getShallow(l, true);
            u != null && r.setItemVisual(a, l, u);
          }
        }
        return { dataEach: e.hasItemOption ? i : null };
      } };
      function zB(n, t, e) {
        switch (e) {
          case "color":
            var i = n.getItemVisual(t, "style");
            return i[n.getVisual("drawType")];
          case "opacity":
            return n.getItemVisual(t, "style").opacity;
          case "symbol":
          case "symbolSize":
          case "liftZ":
            return n.getItemVisual(t, e);
          default:
        }
      }
      function lv(n, t) {
        switch (t) {
          case "color":
            var e = n.getVisual("style");
            return e[n.getVisual("drawType")];
          case "opacity":
            return n.getVisual("style").opacity;
          case "symbol":
          case "symbolSize":
          case "liftZ":
            return n.getVisual(t);
          default:
        }
      }
      function t6(n, t, e, i) {
        switch (e) {
          case "color":
            var r = n.ensureUniqueItemVisual(t, "style");
            r[n.getVisual("drawType")] = i, n.setItemVisual(t, "colorFromPalette", false);
            break;
          case "opacity":
            n.ensureUniqueItemVisual(t, "style").opacity = i;
            break;
          case "symbol":
          case "symbolSize":
          case "liftZ":
            n.setItemVisual(t, e, i);
            break;
          default:
        }
      }
      function e6(n, t) {
        function e(i, r) {
          var a = [];
          return i.eachComponent({ mainType: "series", subType: n, query: r }, function(o) {
            a.push(o.seriesIndex);
          }), a;
        }
        M([[n + "ToggleSelect", "toggleSelect"], [n + "Select", "select"], [n + "UnSelect", "unselect"]], function(i) {
          t(i[0], function(r, a, o) {
            r = Y({}, r), Rn(r.type, i[1]), o.dispatchAction(Y(r, { type: i[1], seriesIndex: e(a, r) }));
          });
        });
      }
      function Ug(n, t, e, i, r) {
        var a = n + t;
        e.isSilent(a) || (qa("event " + a + " is deprecated."), i.eachComponent({ mainType: "series", subType: "pie" }, function(o) {
          for (var s = o.seriesIndex, l = o.option.selectedMap, u = r.selected, h = 0; h < u.length; h++) if (u[h].seriesIndex === s) {
            var c = o.getData(), f = Ah(c, r.fromActionPayload);
            e.trigger(a, { type: a, seriesId: o.id, name: X(f) ? c.getName(f[0]) : c.getName(f), selected: ht(l) ? l : Y({}, l) });
          }
        }));
      }
      function jEt(n, t, e) {
        n.on("selectchanged", function(i) {
          var r = e.getModel();
          i.isFromClick ? (Ug("map", "selectchanged", t, r, i), Ug("pie", "selectchanged", t, r, i)) : i.fromAction === "select" ? (Ug("map", "selected", t, r, i), Ug("pie", "selected", t, r, i)) : i.fromAction === "unselect" && (Ug("map", "unselected", t, r, i), Ug("pie", "unselected", t, r, i));
        });
      }
      function Gh(n, t, e) {
        for (var i; n && !(t(n) && (i = n, e)); ) n = n.__hostTarget || n.parent;
        return i;
      }
      var qEt = Math.round(Math.random() * 9), HEt = typeof Object.defineProperty == "function", YEt = function() {
        function n() {
          this._id = "__ec_inner_" + qEt++;
        }
        return n.prototype.get = function(t) {
          return this._guard(t)[this._id];
        }, n.prototype.set = function(t, e) {
          var i = this._guard(t);
          return HEt ? Object.defineProperty(i, this._id, { value: e, enumerable: false, configurable: true }) : i[this._id] = e, this;
        }, n.prototype.delete = function(t) {
          return this.has(t) ? (delete this._guard(t)[this._id], true) : false;
        }, n.prototype.has = function(t) {
          return !!this._guard(t)[this._id];
        }, n.prototype._guard = function(t) {
          if (t !== Object(t)) throw TypeError("Value of WeakMap is not a non-null object.");
          return t;
        }, n;
      }(), WEt = Jt.extend({ type: "triangle", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function(n, t) {
        var e = t.cx, i = t.cy, r = t.width / 2, a = t.height / 2;
        n.moveTo(e, i - a), n.lineTo(e + r, i + a), n.lineTo(e - r, i + a), n.closePath();
      } }), XEt = Jt.extend({ type: "diamond", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function(n, t) {
        var e = t.cx, i = t.cy, r = t.width / 2, a = t.height / 2;
        n.moveTo(e, i - a), n.lineTo(e + r, i), n.lineTo(e, i + a), n.lineTo(e - r, i), n.closePath();
      } }), ZEt = Jt.extend({ type: "pin", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function(n, t) {
        var e = t.x, i = t.y, r = t.width / 5 * 3, a = Math.max(r, t.height), o = r / 2, s = o * o / (a - o), l = i - a + o + s, u = Math.asin(s / o), h = Math.cos(u) * o, c = Math.sin(u), f = Math.cos(u), g = o * 0.6, d = o * 0.7;
        n.moveTo(e - h, l + s), n.arc(e, l, o, Math.PI - u, Math.PI * 2 + u), n.bezierCurveTo(e + h - c * g, l + s + f * g, e, i - d, e, i), n.bezierCurveTo(e, i - d, e - h + c * g, l + s + f * g, e - h, l + s), n.closePath();
      } }), KEt = Jt.extend({ type: "arrow", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function(n, t) {
        var e = t.height, i = t.width, r = t.x, a = t.y, o = i / 3 * 2;
        n.moveTo(r, a), n.lineTo(r + o, a + e), n.lineTo(r, a + e / 4 * 3), n.lineTo(r - o, a + e), n.lineTo(r, a), n.closePath();
      } }), $Et = { line: Wn, rect: ue, roundRect: ue, square: ue, circle: ks, diamond: XEt, pin: ZEt, arrow: KEt, triangle: WEt }, JEt = { line: function(n, t, e, i, r) {
        r.x1 = n, r.y1 = t + i / 2, r.x2 = n + e, r.y2 = t + i / 2;
      }, rect: function(n, t, e, i, r) {
        r.x = n, r.y = t, r.width = e, r.height = i;
      }, roundRect: function(n, t, e, i, r) {
        r.x = n, r.y = t, r.width = e, r.height = i, r.r = Math.min(e, i) / 4;
      }, square: function(n, t, e, i, r) {
        var a = Math.min(e, i);
        r.x = n, r.y = t, r.width = a, r.height = a;
      }, circle: function(n, t, e, i, r) {
        r.cx = n + e / 2, r.cy = t + i / 2, r.r = Math.min(e, i) / 2;
      }, diamond: function(n, t, e, i, r) {
        r.cx = n + e / 2, r.cy = t + i / 2, r.width = e, r.height = i;
      }, pin: function(n, t, e, i, r) {
        r.x = n + e / 2, r.y = t + i / 2, r.width = e, r.height = i;
      }, arrow: function(n, t, e, i, r) {
        r.x = n + e / 2, r.y = t + i / 2, r.width = e, r.height = i;
      }, triangle: function(n, t, e, i, r) {
        r.cx = n + e / 2, r.cy = t + i / 2, r.width = e, r.height = i;
      } }, F1 = {};
      M($Et, function(n, t) {
        F1[t] = new n();
      });
      var txt = Jt.extend({ type: "symbol", shape: { symbolType: "", x: 0, y: 0, width: 0, height: 0 }, calculateTextPosition: function(n, t, e) {
        var i = F_(n, t, e), r = this.shape;
        return r && r.symbolType === "pin" && t.position === "inside" && (i.y = e.y + e.height * 0.4), i;
      }, buildPath: function(n, t, e) {
        var i = t.symbolType;
        if (i !== "none") {
          var r = F1[i];
          r || (i = "rect", r = F1[i]), JEt[i](t.x, t.y, t.width, t.height, r.shape), r.buildPath(n, r.shape, e);
        }
      } });
      function ext(n, t) {
        if (this.type !== "image") {
          var e = this.style;
          this.__isEmptyBrush ? (e.stroke = n, e.fill = t || "#fff", e.lineWidth = 2) : this.shape.symbolType === "line" ? e.stroke = n : e.fill = n, this.markRedraw();
        }
      }
      function Nn(n, t, e, i, r, a, o) {
        var s = n.indexOf("empty") === 0;
        s && (n = n.substr(5, 1).toLowerCase() + n.substr(6));
        var l;
        return n.indexOf("image://") === 0 ? l = $5(n.slice(8), new Ht(t, e, i, r), o ? "center" : "cover") : n.indexOf("path://") === 0 ? l = h1(n.slice(7), {}, new Ht(t, e, i, r), o ? "center" : "cover") : l = new txt({ shape: { symbolType: n, x: t, y: e, width: i, height: r } }), l.__isEmptyBrush = s, l.setColor = ext, a && l.setColor(a), l;
      }
      function Vg(n) {
        return X(n) || (n = [+n, +n]), [n[0] || 0, n[1] || 0];
      }
      function Uh(n, t) {
        if (n != null) return X(n) || (n = [n, n]), [ot(n[0], t[0]) || 0, ot(Pt(n[1], n[0]), t[1]) || 0];
      }
      function Vh(n) {
        return isFinite(n);
      }
      function nxt(n, t, e) {
        var i = t.x == null ? 0 : t.x, r = t.x2 == null ? 1 : t.x2, a = t.y == null ? 0 : t.y, o = t.y2 == null ? 0 : t.y2;
        t.global || (i = i * e.width + e.x, r = r * e.width + e.x, a = a * e.height + e.y, o = o * e.height + e.y), i = Vh(i) ? i : 0, r = Vh(r) ? r : 1, a = Vh(a) ? a : 0, o = Vh(o) ? o : 0;
        var s = n.createLinearGradient(i, a, r, o);
        return s;
      }
      function ixt(n, t, e) {
        var i = e.width, r = e.height, a = Math.min(i, r), o = t.x == null ? 0.5 : t.x, s = t.y == null ? 0.5 : t.y, l = t.r == null ? 0.5 : t.r;
        t.global || (o = o * i + e.x, s = s * r + e.y, l = l * a), o = Vh(o) ? o : 0.5, s = Vh(s) ? s : 0.5, l = l >= 0 && Vh(l) ? l : 0.5;
        var u = n.createRadialGradient(o, s, 0, o, s, l);
        return u;
      }
      function GB(n, t, e) {
        for (var i = t.type === "radial" ? ixt(n, t, e) : nxt(n, t, e), r = t.colorStops, a = 0; a < r.length; a++) i.addColorStop(r[a].offset, r[a].color);
        return i;
      }
      function rxt(n, t) {
        if (n === t || !n && !t) return false;
        if (!n || !t || n.length !== t.length) return true;
        for (var e = 0; e < n.length; e++) if (n[e] !== t[e]) return true;
        return false;
      }
      function Q1(n) {
        return parseInt(n, 10);
      }
      function jg(n, t, e) {
        var i = ["width", "height"][t], r = ["clientWidth", "clientHeight"][t], a = ["paddingLeft", "paddingTop"][t], o = ["paddingRight", "paddingBottom"][t];
        if (e[i] != null && e[i] !== "auto") return parseFloat(e[i]);
        var s = document.defaultView.getComputedStyle(n);
        return (n[r] || Q1(s[i]) || Q1(n.style[i])) - (Q1(s[a]) || 0) - (Q1(s[o]) || 0) | 0;
      }
      function axt(n, t) {
        return !n || n === "solid" || !(t > 0) ? null : n === "dashed" ? [4 * t, 2 * t] : n === "dotted" ? [t] : pe(n) ? [n] : X(n) ? n : null;
      }
      function UB(n) {
        var t = n.style, e = t.lineDash && t.lineWidth > 0 && axt(t.lineDash, t.lineWidth), i = t.lineDashOffset;
        if (e) {
          var r = t.strokeNoScale && n.getLineScale ? n.getLineScale() : 1;
          r && r !== 1 && (e = Z(e, function(a) {
            return a / r;
          }), i /= r);
        }
        return [e, i];
      }
      var oxt = new ko(true);
      function O1(n) {
        var t = n.stroke;
        return !(t == null || t === "none" || !(n.lineWidth > 0));
      }
      function n6(n) {
        return typeof n == "string" && n !== "none";
      }
      function z1(n) {
        var t = n.fill;
        return t != null && t !== "none";
      }
      function i6(n, t) {
        if (t.fillOpacity != null && t.fillOpacity !== 1) {
          var e = n.globalAlpha;
          n.globalAlpha = t.fillOpacity * t.opacity, n.fill(), n.globalAlpha = e;
        } else n.fill();
      }
      function r6(n, t) {
        if (t.strokeOpacity != null && t.strokeOpacity !== 1) {
          var e = n.globalAlpha;
          n.globalAlpha = t.strokeOpacity * t.opacity, n.stroke(), n.globalAlpha = e;
        } else n.stroke();
      }
      function VB(n, t, e) {
        var i = m2(t.image, t.__image, e);
        if (U_(i)) {
          var r = n.createPattern(i, t.repeat || "repeat");
          if (typeof DOMMatrix == "function" && r && r.setTransform) {
            var a = new DOMMatrix();
            a.translateSelf(t.x || 0, t.y || 0), a.rotateSelf(0, 0, (t.rotation || 0) * c_), a.scaleSelf(t.scaleX || 1, t.scaleY || 1), r.setTransform(a);
          }
          return r;
        }
      }
      function sxt(n, t, e, i) {
        var r, a = O1(e), o = z1(e), s = e.strokePercent, l = s < 1, u = !t.path;
        (!t.silent || l) && u && t.createPathProxy();
        var h = t.path || oxt, c = t.__dirty;
        if (!i) {
          var f = e.fill, g = e.stroke, d = o && !!f.colorStops, A = a && !!g.colorStops, p = o && !!f.image, v = a && !!g.image, y = void 0, m = void 0, _ = void 0, E = void 0, I = void 0;
          (d || A) && (I = t.getBoundingRect()), d && (y = c ? GB(n, f, I) : t.__canvasFillGradient, t.__canvasFillGradient = y), A && (m = c ? GB(n, g, I) : t.__canvasStrokeGradient, t.__canvasStrokeGradient = m), p && (_ = c || !t.__canvasFillPattern ? VB(n, f, t) : t.__canvasFillPattern, t.__canvasFillPattern = _), v && (E = c || !t.__canvasStrokePattern ? VB(n, g, t) : t.__canvasStrokePattern, t.__canvasStrokePattern = _), d ? n.fillStyle = y : p && (_ ? n.fillStyle = _ : o = false), A ? n.strokeStyle = m : v && (E ? n.strokeStyle = E : a = false);
        }
        var x = t.getGlobalScale();
        h.setScale(x[0], x[1], t.segmentIgnoreThreshold);
        var w, C;
        n.setLineDash && e.lineDash && (r = UB(t), w = r[0], C = r[1]);
        var S = true;
        (u || c & ug) && (h.setDPR(n.dpr), l ? h.setContext(null) : (h.setContext(n), S = false), h.reset(), t.buildPath(h, t.shape, i), h.toStatic(), t.pathUpdated()), S && h.rebuildPath(n, l ? s : 1), w && (n.setLineDash(w), n.lineDashOffset = C), i || (e.strokeFirst ? (a && r6(n, e), o && i6(n, e)) : (o && i6(n, e), a && r6(n, e))), w && n.setLineDash([]);
      }
      function lxt(n, t, e) {
        var i = t.__image = m2(e.image, t.__image, t, t.onload);
        if (!(!i || !U_(i))) {
          var r = e.x || 0, a = e.y || 0, o = t.getWidth(), s = t.getHeight(), l = i.width / i.height;
          if (o == null && s != null ? o = s * l : s == null && o != null ? s = o / l : o == null && s == null && (o = i.width, s = i.height), e.sWidth && e.sHeight) {
            var u = e.sx || 0, h = e.sy || 0;
            n.drawImage(i, u, h, e.sWidth, e.sHeight, r, a, o, s);
          } else if (e.sx && e.sy) {
            var u = e.sx, h = e.sy, c = o - u, f = s - h;
            n.drawImage(i, u, h, c, f, r, a, o, s);
          } else n.drawImage(i, r, a, o, s);
        }
      }
      function uxt(n, t, e) {
        var i, r = e.text;
        if (r != null && (r += ""), r) {
          n.font = e.font || Ql, n.textAlign = e.textAlign, n.textBaseline = e.textBaseline;
          var a = void 0, o = void 0;
          n.setLineDash && e.lineDash && (i = UB(t), a = i[0], o = i[1]), a && (n.setLineDash(a), n.lineDashOffset = o), e.strokeFirst ? (O1(e) && n.strokeText(r, e.x, e.y), z1(e) && n.fillText(r, e.x, e.y)) : (z1(e) && n.fillText(r, e.x, e.y), O1(e) && n.strokeText(r, e.x, e.y)), a && n.setLineDash([]);
        }
      }
      var a6 = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], o6 = [["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]];
      function s6(n, t, e, i, r) {
        var a = false;
        if (!i && (e = e || {}, t === e)) return false;
        if (i || t.opacity !== e.opacity) {
          Ir(n, r), a = true;
          var o = Math.max(Math.min(t.opacity, 1), 0);
          n.globalAlpha = isNaN(o) ? yh.opacity : o;
        }
        (i || t.blend !== e.blend) && (a || (Ir(n, r), a = true), n.globalCompositeOperation = t.blend || yh.blend);
        for (var s = 0; s < a6.length; s++) {
          var l = a6[s];
          (i || t[l] !== e[l]) && (a || (Ir(n, r), a = true), n[l] = n.dpr * (t[l] || 0));
        }
        return (i || t.shadowColor !== e.shadowColor) && (a || (Ir(n, r), a = true), n.shadowColor = t.shadowColor || yh.shadowColor), a;
      }
      function l6(n, t, e, i, r) {
        var a = uv(t, r.inHover), o = i ? null : e && uv(e, r.inHover) || {};
        if (a === o) return false;
        var s = s6(n, a, o, i, r);
        if ((i || a.fill !== o.fill) && (s || (Ir(n, r), s = true), n6(a.fill) && (n.fillStyle = a.fill)), (i || a.stroke !== o.stroke) && (s || (Ir(n, r), s = true), n6(a.stroke) && (n.strokeStyle = a.stroke)), (i || a.opacity !== o.opacity) && (s || (Ir(n, r), s = true), n.globalAlpha = a.opacity == null ? 1 : a.opacity), t.hasStroke()) {
          var l = a.lineWidth, u = l / (a.strokeNoScale && t.getLineScale ? t.getLineScale() : 1);
          n.lineWidth !== u && (s || (Ir(n, r), s = true), n.lineWidth = u);
        }
        for (var h = 0; h < o6.length; h++) {
          var c = o6[h], f = c[0];
          (i || a[f] !== o[f]) && (s || (Ir(n, r), s = true), n[f] = a[f] || c[1]);
        }
        return s;
      }
      function hxt(n, t, e, i, r) {
        return s6(n, uv(t, r.inHover), e && uv(e, r.inHover), i, r);
      }
      function u6(n, t) {
        var e = t.transform, i = n.dpr || 1;
        e ? n.setTransform(i * e[0], i * e[1], i * e[2], i * e[3], i * e[4], i * e[5]) : n.setTransform(i, 0, 0, i, 0, 0);
      }
      function cxt(n, t, e) {
        for (var i = false, r = 0; r < n.length; r++) {
          var a = n[r];
          i = i || a.isZeroArea(), u6(t, a), t.beginPath(), a.buildPath(t, a.shape), t.clip();
        }
        e.allClipped = i;
      }
      function fxt(n, t) {
        return n && t ? n[0] !== t[0] || n[1] !== t[1] || n[2] !== t[2] || n[3] !== t[3] || n[4] !== t[4] || n[5] !== t[5] : !(!n && !t);
      }
      var h6 = 1, c6 = 2, f6 = 3, g6 = 4;
      function gxt(n) {
        var t = z1(n), e = O1(n);
        return !(n.lineDash || !(+t ^ +e) || t && typeof n.fill != "string" || e && typeof n.stroke != "string" || n.strokePercent < 1 || n.strokeOpacity < 1 || n.fillOpacity < 1);
      }
      function Ir(n, t) {
        t.batchFill && n.fill(), t.batchStroke && n.stroke(), t.batchFill = "", t.batchStroke = "";
      }
      function uv(n, t) {
        return t && n.__hoverStyle || n.style;
      }
      function d6(n, t) {
        jh(n, t, { inHover: false, viewWidth: 0, viewHeight: 0 }, true);
      }
      function jh(n, t, e, i) {
        var r = t.transform;
        if (!t.shouldBePainted(e.viewWidth, e.viewHeight, false, false)) {
          t.__dirty &= ~Qr, t.__isRendered = false;
          return;
        }
        var a = t.__clipPaths, o = e.prevElClipPaths, s = false, l = false;
        if ((!o || rxt(a, o)) && (o && o.length && (Ir(n, e), n.restore(), l = s = true, e.prevElClipPaths = null, e.allClipped = false, e.prevEl = null), a && a.length && (Ir(n, e), n.save(), cxt(a, n, e), s = true), e.prevElClipPaths = a), e.allClipped) {
          t.__isRendered = false;
          return;
        }
        t.beforeBrush && t.beforeBrush(), t.innerBeforeBrush();
        var u = e.prevEl;
        u || (l = s = true);
        var h = t instanceof Jt && t.autoBatch && gxt(t.style);
        s || fxt(r, u.transform) ? (Ir(n, e), u6(n, t)) : h || Ir(n, e);
        var c = uv(t, e.inHover);
        t instanceof Jt ? (e.lastDrawType !== h6 && (l = true, e.lastDrawType = h6), l6(n, t, u, l, e), (!h || !e.batchFill && !e.batchStroke) && n.beginPath(), sxt(n, t, c, h), h && (e.batchFill = c.fill || "", e.batchStroke = c.stroke || "")) : t instanceof yg ? (e.lastDrawType !== f6 && (l = true, e.lastDrawType = f6), l6(n, t, u, l, e), uxt(n, t, c)) : t instanceof li ? (e.lastDrawType !== c6 && (l = true, e.lastDrawType = c6), hxt(n, t, u, l, e), lxt(n, t, c)) : t.getTemporalDisplayables && (e.lastDrawType !== g6 && (l = true, e.lastDrawType = g6), dxt(n, t, e)), h && i && Ir(n, e), t.innerAfterBrush(), t.afterBrush && t.afterBrush(), e.prevEl = t, t.__dirty = 0, t.__isRendered = true;
      }
      function dxt(n, t, e) {
        var i = t.getDisplayables(), r = t.getTemporalDisplayables();
        n.save();
        var a = { prevElClipPaths: null, prevEl: null, allClipped: false, viewWidth: e.viewWidth, viewHeight: e.viewHeight, inHover: e.inHover }, o, s;
        for (o = t.getCursor(), s = i.length; o < s; o++) {
          var l = i[o];
          l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), jh(n, l, a, o === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
        }
        for (var u = 0, h = r.length; u < h; u++) {
          var l = r[u];
          l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), jh(n, l, a, u === h - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
        }
        t.clearTemporalDisplayables(), t.notClear = true, n.restore();
      }
      var jB = new YEt(), A6 = new yp(100), p6 = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
      function qg(n, t) {
        if (n === "none") return null;
        var e = t.getDevicePixelRatio(), i = t.getZr(), r = i.painter.type === "svg";
        n.dirty && jB.delete(n);
        var a = jB.get(n);
        if (a) return a;
        var o = Et(n, { symbol: "rect", symbolSize: 1, symbolKeepAspect: true, color: "rgba(0, 0, 0, 0.2)", backgroundColor: null, dashArrayX: 5, dashArrayY: 5, rotation: 0, maxTileWidth: 512, maxTileHeight: 512 });
        o.backgroundColor === "none" && (o.backgroundColor = null);
        var s = { repeat: "repeat" };
        return l(s), s.rotation = o.rotation, s.scaleX = s.scaleY = r ? 1 : 1 / e, jB.set(n, s), n.dirty = false, s;
        function l(u) {
          for (var h = [e], c = true, f = 0; f < p6.length; ++f) {
            var g = o[p6[f]];
            if (g != null && !X(g) && !ht(g) && !pe(g) && typeof g != "boolean") {
              c = false;
              break;
            }
            h.push(g);
          }
          var d;
          if (c) {
            d = h.join(",") + (r ? "-svg" : "");
            var A = A6.get(d);
            A && (r ? u.svgElement = A : u.image = A);
          }
          var p = y6(o.dashArrayX), v = Axt(o.dashArrayY), y = v6(o.symbol), m = pxt(p), _ = m6(v), E = !r && Ol.createCanvas(), I = r && { tag: "g", attrs: {}, key: "dcl", children: [] }, x = C(), w;
          E && (E.width = x.width * e, E.height = x.height * e, w = E.getContext("2d")), S(), c && A6.put(d, E || I), u.image = E, u.svgElement = I, u.svgWidth = x.width, u.svgHeight = x.height;
          function C() {
            for (var b = 1, B = 0, T = m.length; B < T; ++B) b = LG(b, m[B]);
            for (var D = 1, B = 0, T = y.length; B < T; ++B) D = LG(D, y[B].length);
            b *= D;
            var R = _ * m.length * y.length;
            if (true) {
              var L = function(k) {
              };
              b > o.maxTileWidth && L("maxTileWidth"), R > o.maxTileHeight && L("maxTileHeight");
            }
            return { width: Math.max(1, Math.min(b, o.maxTileWidth)), height: Math.max(1, Math.min(R, o.maxTileHeight)) };
          }
          function S() {
            w && (w.clearRect(0, 0, E.width, E.height), o.backgroundColor && (w.fillStyle = o.backgroundColor, w.fillRect(0, 0, E.width, E.height)));
            for (var b = 0, B = 0; B < v.length; ++B) b += v[B];
            if (b <= 0) return;
            for (var T = -_, D = 0, R = 0, L = 0; T < x.height; ) {
              if (D % 2 === 0) {
                for (var k = R / 2 % y.length, P = 0, F = 0, Q = 0; P < x.width * 2; ) {
                  for (var z = 0, B = 0; B < p[L].length; ++B) z += p[L][B];
                  if (z <= 0) break;
                  if (F % 2 === 0) {
                    var j = (1 - o.symbolSize) * 0.5, $ = P + p[L][F] * j, G = T + v[D] * j, tt = p[L][F] * o.symbolSize, J = v[D] * o.symbolSize, et = Q / 2 % y[k].length;
                    nt($, G, tt, J, y[k][et]);
                  }
                  P += p[L][F], ++Q, ++F, F === p[L].length && (F = 0);
                }
                ++L, L === p.length && (L = 0);
              }
              T += v[D], ++R, ++D, D === v.length && (D = 0);
            }
            function nt(gt, H, W, it, kt) {
              var vt = r ? 1 : e, St = Nn(kt, gt * vt, H * vt, W * vt, it * vt, o.color, o.symbolKeepAspect);
              if (r) {
                var bt = i.painter.renderOneToVNode(St);
                bt && I.children.push(bt);
              } else d6(w, St);
            }
          }
        }
      }
      function v6(n) {
        if (!n || n.length === 0) return [["rect"]];
        if (ht(n)) return [[n]];
        for (var t = true, e = 0; e < n.length; ++e) if (!ht(n[e])) {
          t = false;
          break;
        }
        if (t) return v6([n]);
        for (var i = [], e = 0; e < n.length; ++e) ht(n[e]) ? i.push([n[e]]) : i.push(n[e]);
        return i;
      }
      function y6(n) {
        if (!n || n.length === 0) return [[0, 0]];
        if (pe(n)) {
          var t = Math.ceil(n);
          return [[t, t]];
        }
        for (var e = true, i = 0; i < n.length; ++i) if (!pe(n[i])) {
          e = false;
          break;
        }
        if (e) return y6([n]);
        for (var r = [], i = 0; i < n.length; ++i) if (pe(n[i])) {
          var t = Math.ceil(n[i]);
          r.push([t, t]);
        } else {
          var t = Z(n[i], function(s) {
            return Math.ceil(s);
          });
          t.length % 2 === 1 ? r.push(t.concat(t)) : r.push(t);
        }
        return r;
      }
      function Axt(n) {
        if (!n || typeof n == "object" && n.length === 0) return [0, 0];
        if (pe(n)) {
          var t = Math.ceil(n);
          return [t, t];
        }
        var e = Z(n, function(i) {
          return Math.ceil(i);
        });
        return n.length % 2 ? e.concat(e) : e;
      }
      function pxt(n) {
        return Z(n, function(t) {
          return m6(t);
        });
      }
      function m6(n) {
        for (var t = 0, e = 0; e < n.length; ++e) t += n[e];
        return n.length % 2 === 1 ? t * 2 : t;
      }
      function vxt(n, t) {
        n.eachRawSeries(function(e) {
          if (!n.isSeriesFiltered(e)) {
            var i = e.getData();
            i.hasItemVisual() && i.each(function(o) {
              var s = i.getItemVisual(o, "decal");
              if (s) {
                var l = i.ensureUniqueItemVisual(o, "style");
                l.decal = qg(s, t);
              }
            });
            var r = i.getVisual("decal");
            if (r) {
              var a = i.getVisual("style");
              a.decal = qg(r, t);
            }
          }
        });
      }
      var Za = new aa(), G1 = {};
      function yxt(n, t) {
        G1[n] && Ai("Already has an implementation of " + n + "."), G1[n] = t;
      }
      function mxt(n) {
        return G1[n] || Ai("Implementation of " + n + " doesn't exists."), G1[n];
      }
      var _xt = 1, Ixt = 800, Ext = 900, xxt = 1e3, wxt = 2e3, Cxt = 5e3, _6 = 1e3, Sxt = 1100, qB = 2e3, I6 = 3e3, bxt = 4e3, U1 = 4500, Bxt = 4600, Txt = 5e3, Mxt = 6e3, E6 = 7e3, Dxt = { PROCESSOR: { FILTER: xxt, SERIES_FILTER: Ixt, STATISTIC: Cxt }, VISUAL: { LAYOUT: _6, PROGRESSIVE_LAYOUT: Sxt, GLOBAL: qB, CHART: I6, POST_CHART_LAYOUT: Bxt, COMPONENT: bxt, BRUSH: Txt, CHART_ITEM: U1, ARIA: Mxt, DECAL: E6 } }, Pi = "__flagInMainProcess", Er = "__pendingUpdate", HB = "__needsUpdateStatus", x6 = /^[a-zA-Z0-9_]+$/, YB = "__connectUpdateStatus", w6 = 0, Rxt = 1, Lxt = 2;
      function C6(n) {
        return function() {
          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
          if (this.isDisposed()) {
            Ur(this.id);
            return;
          }
          return b6(this, n, t);
        };
      }
      function S6(n) {
        return function() {
          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
          return b6(this, n, t);
        };
      }
      function b6(n, t, e) {
        return e[0] = e[0] && e[0].toLowerCase(), aa.prototype[t].apply(n, e);
      }
      var B6 = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t;
      }(aa), T6 = B6.prototype;
      T6.on = S6("on"), T6.off = S6("off");
      var Hg, WB, V1, ou, XB, ZB, KB, hv, cv, M6, D6, $B, R6, j1, L6, P6, ya, N6, k6 = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this, new GEt()) || this;
          a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], r = r || {}, ht(i) && (i = F6[i]), a._dom = e;
          var o = "canvas", s = "auto", l = false;
          if (true) {
            var u = ee.hasGlobalWindow ? window : global;
            u && (o = Pt(u.__ECHARTS__DEFAULT__RENDERER__, o), s = Pt(u.__ECHARTS__DEFAULT__COARSE_POINTER, s), l = Pt(u.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, l));
          }
          r.ssr && Smt(function(g) {
            var d = Dt(g), A = d.dataIndex;
            if (A != null) {
              var p = dt();
              return p.set("series_index", d.seriesIndex), p.set("data_index", A), d.ssrType && p.set("ssr_type", d.ssrType), p;
            }
          });
          var h = a._zr = xG(e, { renderer: r.renderer || o, devicePixelRatio: r.devicePixelRatio, width: r.width, height: r.height, ssr: r.ssr, useDirtyRect: Pt(r.useDirtyRect, l), useCoarsePointer: Pt(r.useCoarsePointer, s), pointerSize: r.pointerSize });
          a._ssr = r.ssr, a._throttledZrFlush = QB(ct(h.flush, h), 17), i = xt(i), i && J4(i, true), a._theme = i, a._locale = K1t(r.locale || d4), a._coordSysMgr = new Fg();
          var c = a._api = L6(a);
          function f(g, d) {
            return g.__prio - d.__prio;
          }
          return v_(H1, f), v_(tT, f), a._scheduler = new q8(a, c, tT, H1), a._messageCenter = new B6(), a._initEvents(), a.resize = ct(a.resize, a), h.animation.on("frame", a._onframe, a), M6(h, a), D6(h, a), l_(a), a;
        }
        return t.prototype._onframe = function() {
          if (!this._disposed) {
            N6(this);
            var e = this._scheduler;
            if (this[Er]) {
              var i = this[Er].silent;
              this[Pi] = true;
              try {
                Hg(this), ou.update.call(this, null, this[Er].updateParams);
              } catch (l) {
                throw this[Pi] = false, this[Er] = null, l;
              }
              this._zr.flush(), this[Pi] = false, this[Er] = null, hv.call(this, i), cv.call(this, i);
            } else if (e.unfinished) {
              var r = _xt, a = this._model, o = this._api;
              e.unfinished = false;
              do {
                var s = +/* @__PURE__ */ new Date();
                e.performSeriesTasks(a), e.performDataProcessorTasks(a), ZB(this, a), e.performVisualTasks(a), j1(this, this._model, o, "remain", {}), r -= +/* @__PURE__ */ new Date() - s;
              } while (r > 0 && e.unfinished);
              e.unfinished || this._zr.flush();
            }
          }
        }, t.prototype.getDom = function() {
          return this._dom;
        }, t.prototype.getId = function() {
          return this.id;
        }, t.prototype.getZr = function() {
          return this._zr;
        }, t.prototype.isSSR = function() {
          return this._ssr;
        }, t.prototype.setOption = function(e, i, r) {
          if (this[Pi]) {
            Ai("`setOption` should not be called during main process.");
            return;
          }
          if (this._disposed) {
            Ur(this.id);
            return;
          }
          var a, o, s;
          if (_t(i) && (r = i.lazyUpdate, a = i.silent, o = i.replaceMerge, s = i.transition, i = i.notMerge), this[Pi] = true, !this._model || i) {
            var l = new wIt(this._api), u = this._theme, h = this._model = new EB();
            h.scheduler = this._scheduler, h.ssr = this._ssr, h.init(null, null, null, u, this._locale, l);
          }
          this._model.setOption(e, { replaceMerge: o }, eT);
          var c = { seriesTransition: s, optionChanged: true };
          if (r) this[Er] = { silent: a, updateParams: c }, this[Pi] = false, this.getZr().wakeUp();
          else {
            try {
              Hg(this), ou.update.call(this, null, c);
            } catch (f) {
              throw this[Er] = null, this[Pi] = false, f;
            }
            this._ssr || this._zr.flush(), this[Er] = null, this[Pi] = false, hv.call(this, a), cv.call(this, a);
          }
        }, t.prototype.setTheme = function() {
          qa("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
        }, t.prototype.getModel = function() {
          return this._model;
        }, t.prototype.getOption = function() {
          return this._model && this._model.getOption();
        }, t.prototype.getWidth = function() {
          return this._zr.getWidth();
        }, t.prototype.getHeight = function() {
          return this._zr.getHeight();
        }, t.prototype.getDevicePixelRatio = function() {
          return this._zr.painter.dpr || ee.hasGlobalWindow && window.devicePixelRatio || 1;
        }, t.prototype.getRenderedCanvas = function(e) {
          return Rn("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(e);
        }, t.prototype.renderToCanvas = function(e) {
          e = e || {};
          var i = this._zr.painter;
          if (i.type !== "canvas") throw new Error("renderToCanvas can only be used in the canvas renderer.");
          return i.getRenderedCanvas({ backgroundColor: e.backgroundColor || this._model.get("backgroundColor"), pixelRatio: e.pixelRatio || this.getDevicePixelRatio() });
        }, t.prototype.renderToSVGString = function(e) {
          e = e || {};
          var i = this._zr.painter;
          if (i.type !== "svg") throw new Error("renderToSVGString can only be used in the svg renderer.");
          return i.renderToString({ useViewBox: e.useViewBox });
        }, t.prototype.getSvgDataURL = function() {
          if (ee.svgSupported) {
            var e = this._zr, i = e.storage.getDisplayList();
            return M(i, function(r) {
              r.stopAnimation(null, true);
            }), e.painter.toDataURL();
          }
        }, t.prototype.getDataURL = function(e) {
          if (this._disposed) {
            Ur(this.id);
            return;
          }
          e = e || {};
          var i = e.excludeComponents, r = this._model, a = [], o = this;
          M(i, function(l) {
            r.eachComponent({ mainType: l }, function(u) {
              var h = o._componentsMap[u.__viewId];
              h.group.ignore || (a.push(h), h.group.ignore = true);
            });
          });
          var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(e).toDataURL("image/" + (e && e.type || "png"));
          return M(a, function(l) {
            l.group.ignore = false;
          }), s;
        }, t.prototype.getConnectedDataURL = function(e) {
          if (this._disposed) {
            Ur(this.id);
            return;
          }
          var i = e.type === "svg", r = this.group, a = Math.min, o = Math.max, s = 1 / 0;
          if (Q6[r]) {
            var l = s, u = s, h = -s, c = -s, f = [], g = e && e.pixelRatio || this.getDevicePixelRatio();
            M(gv, function(m, _) {
              if (m.group === r) {
                var E = i ? m.getZr().painter.getSvgDom().innerHTML : m.renderToCanvas(xt(e)), I = m.getDom().getBoundingClientRect();
                l = a(I.left, l), u = a(I.top, u), h = o(I.right, h), c = o(I.bottom, c), f.push({ dom: E, left: I.left, top: I.top });
              }
            }), l *= g, u *= g, h *= g, c *= g;
            var d = h - l, A = c - u, p = Ol.createCanvas(), v = xG(p, { renderer: i ? "svg" : "canvas" });
            if (v.resize({ width: d, height: A }), i) {
              var y = "";
              return M(f, function(m) {
                var _ = m.left - l, E = m.top - u;
                y += '<g transform="translate(' + _ + "," + E + ')">' + m.dom + "</g>";
              }), v.painter.getSvgRoot().innerHTML = y, e.connectedBackgroundColor && v.painter.setBackgroundColor(e.connectedBackgroundColor), v.refreshImmediately(), v.painter.toDataURL();
            } else return e.connectedBackgroundColor && v.add(new ue({ shape: { x: 0, y: 0, width: d, height: A }, style: { fill: e.connectedBackgroundColor } })), M(f, function(m) {
              var _ = new li({ style: { x: m.left * g - l, y: m.top * g - u, image: m.dom } });
              v.add(_);
            }), v.refreshImmediately(), p.toDataURL("image/" + (e && e.type || "png"));
          } else return this.getDataURL(e);
        }, t.prototype.convertToPixel = function(e, i) {
          return XB(this, "convertToPixel", e, i);
        }, t.prototype.convertFromPixel = function(e, i) {
          return XB(this, "convertFromPixel", e, i);
        }, t.prototype.containPixel = function(e, i) {
          if (this._disposed) {
            Ur(this.id);
            return;
          }
          var r = this._model, a, o = Mp(r, e);
          return M(o, function(s, l) {
            l.indexOf("Models") >= 0 && M(s, function(u) {
              var h = u.coordinateSystem;
              if (h && h.containPoint) a = a || !!h.containPoint(i);
              else if (l === "seriesModels") {
                var c = this._chartsMap[u.__viewId];
                c && c.containPoint ? a = a || c.containPoint(i, u) : un(l + ": " + (c ? "The found component do not support containPoint." : "No view mapping to the found component."));
              } else un(l + ": containPoint is not supported");
            }, this);
          }, this), !!a;
        }, t.prototype.getVisual = function(e, i) {
          var r = this._model, a = Mp(r, e, { defaultMainType: "series" }), o = a.seriesModel;
          o || un("There is no specified series model");
          var s = o.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(a.dataIndex) : null;
          return l != null ? zB(s, l, i) : lv(s, i);
        }, t.prototype.getViewOfComponentModel = function(e) {
          return this._componentsMap[e.__viewId];
        }, t.prototype.getViewOfSeriesModel = function(e) {
          return this._chartsMap[e.__viewId];
        }, t.prototype._initEvents = function() {
          var e = this;
          M(Pxt, function(i) {
            var r = function(a) {
              var o = e.getModel(), s = a.target, l, u = i === "globalout";
              if (u ? l = {} : s && Gh(s, function(d) {
                var A = Dt(d);
                if (A && A.dataIndex != null) {
                  var p = A.dataModel || o.getSeriesByIndex(A.seriesIndex);
                  return l = p && p.getDataParams(A.dataIndex, A.dataType, s) || {}, true;
                } else if (A.eventData) return l = Y({}, A.eventData), true;
              }, true), l) {
                var h = l.componentType, c = l.componentIndex;
                (h === "markLine" || h === "markPoint" || h === "markArea") && (h = "series", c = l.seriesIndex);
                var f = h && c != null && o.getComponent(h, c), g = f && e[f.mainType === "series" ? "_chartsMap" : "_componentsMap"][f.__viewId];
                !u && !(f && g) && un("model or view can not be found by params"), l.event = a, l.type = i, e._$eventProcessor.eventInfo = { targetEl: s, packedEvent: l, model: f, view: g }, e.trigger(i, l);
              }
            };
            r.zrEventfulCallAtLast = true, e._zr.on(i, r, e);
          }), M(fv, function(i, r) {
            e._messageCenter.on(r, function(a) {
              this.trigger(r, a);
            }, e);
          }), M(["selectchanged"], function(i) {
            e._messageCenter.on(i, function(r) {
              this.trigger(i, r);
            }, e);
          }), jEt(this._messageCenter, this, this._api);
        }, t.prototype.isDisposed = function() {
          return this._disposed;
        }, t.prototype.clear = function() {
          if (this._disposed) {
            Ur(this.id);
            return;
          }
          this.setOption({ series: [] }, true);
        }, t.prototype.dispose = function() {
          if (this._disposed) {
            Ur(this.id);
            return;
          }
          this._disposed = true;
          var e = this.getDom();
          e && VG(this.getDom(), iT, "");
          var i = this, r = i._api, a = i._model;
          M(i._componentsViews, function(o) {
            o.dispose(a, r);
          }), M(i._chartsViews, function(o) {
            o.dispose(a, r);
          }), i._zr.dispose(), i._dom = i._model = i._chartsMap = i._componentsMap = i._chartsViews = i._componentsViews = i._scheduler = i._api = i._zr = i._throttledZrFlush = i._theme = i._coordSysMgr = i._messageCenter = null, delete gv[i.id];
        }, t.prototype.resize = function(e) {
          if (this[Pi]) {
            Ai("`resize` should not be called during main process.");
            return;
          }
          if (this._disposed) {
            Ur(this.id);
            return;
          }
          this._zr.resize(e);
          var i = this._model;
          if (this._loadingFX && this._loadingFX.resize(), !!i) {
            var r = i.resetOption("media"), a = e && e.silent;
            this[Er] && (a == null && (a = this[Er].silent), r = true, this[Er] = null), this[Pi] = true;
            try {
              r && Hg(this), ou.update.call(this, { type: "resize", animation: Y({ duration: 0 }, e && e.animation) });
            } catch (o) {
              throw this[Pi] = false, o;
            }
            this[Pi] = false, hv.call(this, a), cv.call(this, a);
          }
        }, t.prototype.showLoading = function(e, i) {
          if (this._disposed) {
            Ur(this.id);
            return;
          }
          if (_t(e) && (i = e, e = ""), e = e || "default", this.hideLoading(), !nT[e]) {
            un("Loading effects " + e + " not exists.");
            return;
          }
          var r = nT[e](this._api, i), a = this._zr;
          this._loadingFX = r, a.add(r);
        }, t.prototype.hideLoading = function() {
          if (this._disposed) {
            Ur(this.id);
            return;
          }
          this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
        }, t.prototype.makeActionFromEvent = function(e) {
          var i = Y({}, e);
          return i.type = fv[e.type], i;
        }, t.prototype.dispatchAction = function(e, i) {
          if (this._disposed) {
            Ur(this.id);
            return;
          }
          if (_t(i) || (i = { silent: !!i }), !!q1[e.type] && this._model) {
            if (this[Pi]) {
              this._pendingActions.push(e);
              return;
            }
            var r = i.silent;
            KB.call(this, e, r);
            var a = i.flush;
            a ? this._zr.flush() : a !== false && ee.browser.weChat && this._throttledZrFlush(), hv.call(this, r), cv.call(this, r);
          }
        }, t.prototype.updateLabelLayout = function() {
          Za.trigger("series:layoutlabels", this._model, this._api, { updatedSeries: [] });
        }, t.prototype.appendData = function(e) {
          if (this._disposed) {
            Ur(this.id);
            return;
          }
          var i = e.seriesIndex, r = this.getModel(), a = r.getSeriesByIndex(i);
          It(e.data && a), a.appendData(e), this._scheduler.unfinished = true, this.getZr().wakeUp();
        }, t.internalField = function() {
          Hg = function(c) {
            var f = c._scheduler;
            f.restorePipelines(c._model), f.prepareStageTasks(), WB(c, true), WB(c, false), f.plan();
          }, WB = function(c, f) {
            for (var g = c._model, d = c._scheduler, A = f ? c._componentsViews : c._chartsViews, p = f ? c._componentsMap : c._chartsMap, v = c._zr, y = c._api, m = 0; m < A.length; m++) A[m].__alive = false;
            f ? g.eachComponent(function(I, x) {
              I !== "series" && _(x);
            }) : g.eachSeries(_);
            function _(I) {
              var x = I.__requireNewView;
              I.__requireNewView = false;
              var w = "_ec_" + I.id + "_" + I.type, C = !x && p[w];
              if (!C) {
                var S = Ro(I.type), b = f ? on.getClass(S.main, S.sub) : Ve.getClass(S.sub);
                It(b, S.sub + " does not exist."), C = new b(), C.init(g, y), p[w] = C, A.push(C), v.add(C.group);
              }
              I.__viewId = C.__id = w, C.__alive = true, C.__model = I, C.group.__ecComponentInfo = { mainType: I.mainType, index: I.componentIndex }, !f && d.prepareView(C, I, g, y);
            }
            for (var m = 0; m < A.length; ) {
              var E = A[m];
              E.__alive ? m++ : (!f && E.renderTask.dispose(), v.remove(E.group), E.dispose(g, y), A.splice(m, 1), p[E.__id] === E && delete p[E.__id], E.__id = E.group.__ecComponentInfo = null);
            }
          }, V1 = function(c, f, g, d, A) {
            var p = c._model;
            if (p.setUpdatePayload(g), !d) {
              M([].concat(c._componentsViews).concat(c._chartsViews), E);
              return;
            }
            var v = {};
            v[d + "Id"] = g[d + "Id"], v[d + "Index"] = g[d + "Index"], v[d + "Name"] = g[d + "Name"];
            var y = { mainType: d, query: v };
            A && (y.subType = A);
            var m = g.excludeSeriesId, _;
            m != null && (_ = dt(), M(Qe(m), function(I) {
              var x = zn(I, null);
              x != null && _.set(x, true);
            })), p && p.eachComponent(y, function(I) {
              var x = _ && _.get(I.id) != null;
              if (!x) if (P5(g)) if (I instanceof $e) g.type === Sh && !g.notBlur && !I.get(["emphasis", "disabled"]) && Z_t(I, g, c._api);
              else {
                var w = V2(I.mainType, I.componentIndex, g.name, c._api), C = w.focusSelf, S = w.dispatchers;
                g.type === Sh && C && !g.notBlur && U2(I.mainType, I.componentIndex, c._api), S && M(S, function(b) {
                  g.type === Sh ? Ps(b) : Ns(b);
                });
              }
              else q2(g) && I instanceof $e && (J_t(I, g, c._api), R5(I), ya(c));
            }, c), p && p.eachComponent(y, function(I) {
              var x = _ && _.get(I.id) != null;
              x || E(c[d === "series" ? "_chartsMap" : "_componentsMap"][I.__viewId]);
            }, c);
            function E(I) {
              I && I.__alive && I[f] && I[f](I.__model, p, c._api, g);
            }
          }, ou = { prepareAndUpdate: function(c) {
            Hg(this), ou.update.call(this, c, { optionChanged: c.newOption != null });
          }, update: function(c, f) {
            var g = this._model, d = this._api, A = this._zr, p = this._coordSysMgr, v = this._scheduler;
            if (g) {
              g.setUpdatePayload(c), v.restoreData(g, c), v.performSeriesTasks(g), p.create(g, d), v.performDataProcessorTasks(g, c), ZB(this, g), p.update(g, d), e(g), v.performVisualTasks(g, c), $B(this, g, d, c, f);
              var y = g.get("backgroundColor") || "transparent", m = g.get("darkMode");
              A.setBackgroundColor(y), m != null && m !== "auto" && A.setDarkMode(m), Za.trigger("afterupdate", g, d);
            }
          }, updateTransform: function(c) {
            var f = this, g = this._model, d = this._api;
            if (g) {
              g.setUpdatePayload(c);
              var A = [];
              g.eachComponent(function(v, y) {
                if (v !== "series") {
                  var m = f.getViewOfComponentModel(y);
                  if (m && m.__alive) if (m.updateTransform) {
                    var _ = m.updateTransform(y, g, d, c);
                    _ && _.update && A.push(m);
                  } else A.push(m);
                }
              });
              var p = dt();
              g.eachSeries(function(v) {
                var y = f._chartsMap[v.__viewId];
                if (y.updateTransform) {
                  var m = y.updateTransform(v, g, d, c);
                  m && m.update && p.set(v.uid, 1);
                } else p.set(v.uid, 1);
              }), e(g), this._scheduler.performVisualTasks(g, c, { setDirty: true, dirtyMap: p }), j1(this, g, d, c, {}, p), Za.trigger("afterupdate", g, d);
            }
          }, updateView: function(c) {
            var f = this._model;
            f && (f.setUpdatePayload(c), Ve.markUpdateMethod(c, "updateView"), e(f), this._scheduler.performVisualTasks(f, c, { setDirty: true }), $B(this, f, this._api, c, {}), Za.trigger("afterupdate", f, this._api));
          }, updateVisual: function(c) {
            var f = this, g = this._model;
            g && (g.setUpdatePayload(c), g.eachSeries(function(d) {
              d.getData().clearAllVisual();
            }), Ve.markUpdateMethod(c, "updateVisual"), e(g), this._scheduler.performVisualTasks(g, c, { visualType: "visual", setDirty: true }), g.eachComponent(function(d, A) {
              if (d !== "series") {
                var p = f.getViewOfComponentModel(A);
                p && p.__alive && p.updateVisual(A, g, f._api, c);
              }
            }), g.eachSeries(function(d) {
              var A = f._chartsMap[d.__viewId];
              A.updateVisual(d, g, f._api, c);
            }), Za.trigger("afterupdate", g, this._api));
          }, updateLayout: function(c) {
            ou.update.call(this, c);
          } }, XB = function(c, f, g, d) {
            if (c._disposed) {
              Ur(c.id);
              return;
            }
            for (var A = c._model, p = c._coordSysMgr.getCoordinateSystems(), v, y = Mp(A, g), m = 0; m < p.length; m++) {
              var _ = p[m];
              if (_[f] && (v = _[f](A, y, d)) != null) return v;
            }
            un("No coordinate system that supports " + f + " found by the given finder.");
          }, ZB = function(c, f) {
            var g = c._chartsMap, d = c._scheduler;
            f.eachSeries(function(A) {
              d.updateStreamModes(A, g[A.__viewId]);
            });
          }, KB = function(c, f) {
            var g = this, d = this.getModel(), A = c.type, p = c.escapeConnect, v = q1[A], y = v.actionInfo, m = (y.update || "update").split(":"), _ = m.pop(), E = m[0] != null && Ro(m[0]);
            this[Pi] = true;
            var I = [c], x = false;
            c.batch && (x = true, I = Z(c.batch, function(D) {
              return D = Et(Y({}, D), c), D.batch = null, D;
            }));
            var w = [], C, S = q2(c), b = P5(c);
            if (b && D5(this._api), M(I, function(D) {
              if (C = v.action(D, g._model, g._api), C = C || Y({}, D), C.type = y.event || C.type, w.push(C), b) {
                var R = A2(c), L = R.queryOptionMap, k = R.mainTypeSpecified, P = k ? L.keys()[0] : "series";
                V1(g, _, D, P), ya(g);
              } else S ? (V1(g, _, D, "series"), ya(g)) : E && V1(g, _, D, E.main, E.sub);
            }), _ !== "none" && !b && !S && !E) try {
              this[Er] ? (Hg(this), ou.update.call(this, c), this[Er] = null) : ou[_].call(this, c);
            } catch (D) {
              throw this[Pi] = false, D;
            }
            if (x ? C = { type: y.event || A, escapeConnect: p, batch: w } : C = w[0], this[Pi] = false, !f) {
              var B = this._messageCenter;
              if (B.trigger(C.type, C), S) {
                var T = { type: "selectchanged", escapeConnect: p, selected: t1t(d), isFromClick: c.isFromClick || false, fromAction: c.type, fromActionPayload: c };
                B.trigger(T.type, T);
              }
            }
          }, hv = function(c) {
            for (var f = this._pendingActions; f.length; ) {
              var g = f.shift();
              KB.call(this, g, c);
            }
          }, cv = function(c) {
            !c && this.trigger("updated");
          }, M6 = function(c, f) {
            c.on("rendered", function(g) {
              f.trigger("rendered", g), c.animation.isFinished() && !f[Er] && !f._scheduler.unfinished && !f._pendingActions.length && f.trigger("finished");
            });
          }, D6 = function(c, f) {
            c.on("mouseover", function(g) {
              var d = g.target, A = Gh(d, $l);
              A && (K_t(A, g, f._api), ya(f));
            }).on("mouseout", function(g) {
              var d = g.target, A = Gh(d, $l);
              A && ($_t(A, g, f._api), ya(f));
            }).on("click", function(g) {
              var d = g.target, A = Gh(d, function(y) {
                return Dt(y).dataIndex != null;
              }, true);
              if (A) {
                var p = A.selected ? "unselect" : "select", v = Dt(A);
                f._api.dispatchAction({ type: p, dataType: v.dataType, dataIndexInside: v.dataIndex, seriesIndex: v.seriesIndex, isFromClick: true });
              }
            });
          };
          function e(c) {
            c.clearColorPalette(), c.eachSeries(function(f) {
              f.clearColorPalette();
            });
          }
          function i(c) {
            var f = [], g = [], d = false;
            if (c.eachComponent(function(y, m) {
              var _ = m.get("zlevel") || 0, E = m.get("z") || 0, I = m.getZLevelKey();
              d = d || !!I, (y === "series" ? g : f).push({ zlevel: _, z: E, idx: m.componentIndex, type: y, key: I });
            }), d) {
              var A = f.concat(g), p, v;
              v_(A, function(y, m) {
                return y.zlevel === m.zlevel ? y.z - m.z : y.zlevel - m.zlevel;
              }), M(A, function(y) {
                var m = c.getComponent(y.type, y.idx), _ = y.zlevel, E = y.key;
                p != null && (_ = Math.max(p, _)), E ? (_ === p && E !== v && _++, v = E) : v && (_ === p && _++, v = ""), p = _, m.setZLevel(_);
              });
            }
          }
          $B = function(c, f, g, d, A) {
            i(f), R6(c, f, g, d, A), M(c._chartsViews, function(p) {
              p.__alive = false;
            }), j1(c, f, g, d, A), M(c._chartsViews, function(p) {
              p.__alive || p.remove(f, g);
            });
          }, R6 = function(c, f, g, d, A, p) {
            M(p || c._componentsViews, function(v) {
              var y = v.__model;
              u(y, v), v.render(y, f, g, d), s(y, v), h(y, v);
            });
          }, j1 = function(c, f, g, d, A, p) {
            var v = c._scheduler;
            A = Y(A || {}, { updatedSeries: f.getSeries() }), Za.trigger("series:beforeupdate", f, g, A);
            var y = false;
            f.eachSeries(function(m) {
              var _ = c._chartsMap[m.__viewId];
              _.__alive = true;
              var E = _.renderTask;
              v.updatePayload(E, d), u(m, _), p && p.get(m.uid) && E.dirty(), E.perform(v.getPerformArgs(E)) && (y = true), _.group.silent = !!m.get("silent"), o(m, _), R5(m);
            }), v.unfinished = y || v.unfinished, Za.trigger("series:layoutlabels", f, g, A), Za.trigger("series:transition", f, g, A), f.eachSeries(function(m) {
              var _ = c._chartsMap[m.__viewId];
              s(m, _), h(m, _);
            }), a(c, f), Za.trigger("series:afterupdate", f, g, A);
          }, ya = function(c) {
            c[HB] = true, c.getZr().wakeUp();
          }, N6 = function(c) {
            c[HB] && (c.getZr().storage.traverse(function(f) {
              Cg(f) || r(f);
            }), c[HB] = false);
          };
          function r(c) {
            for (var f = [], g = c.currentStates, d = 0; d < g.length; d++) {
              var A = g[d];
              A === "emphasis" || A === "blur" || A === "select" || f.push(A);
            }
            c.selected && c.states.select && f.push("select"), c.hoverState === X_ && c.states.emphasis ? f.push("emphasis") : c.hoverState === Pp && c.states.blur && f.push("blur"), c.useStates(f);
          }
          function a(c, f) {
            var g = c._zr, d = g.storage, A = 0;
            d.traverse(function(p) {
              p.isGroup || A++;
            }), A > f.get("hoverLayerThreshold") && !ee.node && !ee.worker && f.eachSeries(function(p) {
              if (!p.preventUsingHoverLayer) {
                var v = c._chartsMap[p.__viewId];
                v.__alive && v.eachRendered(function(y) {
                  y.states.emphasis && (y.states.emphasis.hoverLayer = true);
                });
              }
            });
          }
          function o(c, f) {
            var g = c.get("blendMode") || null;
            f.eachRendered(function(d) {
              d.isGroup || (d.style.blend = g);
            });
          }
          function s(c, f) {
            if (!c.preventAutoZ) {
              var g = c.get("z") || 0, d = c.get("zlevel") || 0;
              f.eachRendered(function(A) {
                return l(A, g, d, -1 / 0), true;
              });
            }
          }
          function l(c, f, g, d) {
            var A = c.getTextContent(), p = c.getTextGuideLine(), v = c.isGroup;
            if (v) for (var y = c.childrenRef(), m = 0; m < y.length; m++) d = Math.max(l(y[m], f, g, d), d);
            else c.z = f, c.zlevel = g, d = Math.max(c.z2, d);
            if (A && (A.z = f, A.zlevel = g, isFinite(d) && (A.z2 = d + 2)), p) {
              var _ = c.textGuideLineConfig;
              p.z = f, p.zlevel = g, isFinite(d) && (p.z2 = d + (_ && _.showAbove ? 1 : -1));
            }
            return d;
          }
          function u(c, f) {
            f.eachRendered(function(g) {
              if (!Cg(g)) {
                var d = g.getTextContent(), A = g.getTextGuideLine();
                g.stateTransition && (g.stateTransition = null), d && d.stateTransition && (d.stateTransition = null), A && A.stateTransition && (A.stateTransition = null), g.hasState() ? (g.prevStates = g.currentStates, g.clearStates()) : g.prevStates && (g.prevStates = null);
              }
            });
          }
          function h(c, f) {
            var g = c.getModel("stateAnimation"), d = c.isAnimationEnabled(), A = g.get("duration"), p = A > 0 ? { duration: A, delay: g.get("delay"), easing: g.get("easing") } : null;
            f.eachRendered(function(v) {
              if (v.states && v.states.emphasis) {
                if (Cg(v)) return;
                if (v instanceof Jt && a1t(v), v.__dirty) {
                  var y = v.prevStates;
                  y && v.useStates(y);
                }
                if (d) {
                  v.stateTransition = p;
                  var m = v.getTextContent(), _ = v.getTextGuideLine();
                  m && (m.stateTransition = p), _ && (_.stateTransition = p);
                }
                v.__dirty && r(v);
              }
            });
          }
          L6 = function(c) {
            return new (function(f) {
              V(g, f);
              function g() {
                return f !== null && f.apply(this, arguments) || this;
              }
              return g.prototype.getCoordinateSystems = function() {
                return c._coordSysMgr.getCoordinateSystems();
              }, g.prototype.getComponentByElement = function(d) {
                for (; d; ) {
                  var A = d.__ecComponentInfo;
                  if (A != null) return c._model.getComponent(A.mainType, A.index);
                  d = d.parent;
                }
              }, g.prototype.enterEmphasis = function(d, A) {
                Ps(d, A), ya(c);
              }, g.prototype.leaveEmphasis = function(d, A) {
                Ns(d, A), ya(c);
              }, g.prototype.enterBlur = function(d) {
                b5(d), ya(c);
              }, g.prototype.leaveBlur = function(d) {
                z2(d), ya(c);
              }, g.prototype.enterSelect = function(d) {
                B5(d), ya(c);
              }, g.prototype.leaveSelect = function(d) {
                T5(d), ya(c);
              }, g.prototype.getModel = function() {
                return c.getModel();
              }, g.prototype.getViewOfComponentModel = function(d) {
                return c.getViewOfComponentModel(d);
              }, g.prototype.getViewOfSeriesModel = function(d) {
                return c.getViewOfSeriesModel(d);
              }, g;
            }(H4))(c);
          }, P6 = function(c) {
            function f(g, d) {
              for (var A = 0; A < g.length; A++) {
                var p = g[A];
                p[YB] = d;
              }
            }
            M(fv, function(g, d) {
              c._messageCenter.on(d, function(A) {
                if (Q6[c.group] && c[YB] !== w6) {
                  if (A && A.escapeConnect) return;
                  var p = c.makeActionFromEvent(A), v = [];
                  M(gv, function(y) {
                    y !== c && y.group === c.group && v.push(y);
                  }), f(v, w6), M(v, function(y) {
                    y[YB] !== Rxt && y.dispatchAction(p);
                  }), f(v, Lxt);
                }
              });
            });
          };
        }(), t;
      }(aa), JB = k6.prototype;
      JB.on = C6("on"), JB.off = C6("off"), JB.one = function(n, t, e) {
        var i = this;
        qa("ECharts#one is deprecated.");
        function r() {
          for (var a = [], o = 0; o < arguments.length; o++) a[o] = arguments[o];
          t && t.apply && t.apply(this, a), i.off(n, r);
        }
        this.on.call(this, n, r, e);
      };
      var Pxt = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
      function Ur(n) {
        un("Instance " + n + " has been disposed");
      }
      var q1 = {}, fv = {}, tT = [], eT = [], H1 = [], F6 = {}, nT = {}, gv = {}, Q6 = {}, Nxt = +/* @__PURE__ */ new Date() - 0, iT = "_echarts_instance_";
      function kxt(n, t, e) {
        {
          if (!n) throw new Error("Initialize failed: invalid dom.");
          var i = Fxt(n);
          if (i) return un("There is a chart instance already initialized on the dom."), i;
          eh(n) && n.nodeName.toUpperCase() !== "CANVAS" && (!n.clientWidth && !e || !n.clientHeight && !e) && un("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
        }
        var r = new k6(n, t, e);
        return r.id = "ec_" + Nxt++, gv[r.id] = r, VG(n, iT, r.id), P6(r), Za.trigger("afterinit", r), r;
      }
      function Fxt(n) {
        return gv[Ymt(n, iT)];
      }
      function O6(n, t) {
        F6[n] = t;
      }
      function z6(n) {
        Wt(eT, n) < 0 && eT.push(n);
      }
      function G6(n, t) {
        aT(tT, n, t, wxt);
      }
      function Qxt(n) {
        rT("afterinit", n);
      }
      function Oxt(n) {
        rT("afterupdate", n);
      }
      function rT(n, t) {
        Za.on(n, t);
      }
      function zo(n, t, e) {
        yt(t) && (e = t, t = "");
        var i = _t(n) ? n.type : [n, n = { event: t }][0];
        n.event = (n.event || i).toLowerCase(), t = n.event, !fv[t] && (It(x6.test(i) && x6.test(t)), q1[i] || (q1[i] = { action: e, actionInfo: n }), fv[t] = i);
      }
      function U6(n, t) {
        Fg.register(n, t);
      }
      function zxt(n, t) {
        aT(H1, n, t, _6, "layout");
      }
      function qh(n, t) {
        aT(H1, n, t, I6, "visual");
      }
      var V6 = [];
      function aT(n, t, e, i, r) {
        if ((yt(t) || _t(t)) && (e = t, t = i), true) {
          if (isNaN(t) || t == null) throw new Error("Illegal priority");
          M(n, function(o) {
            It(o.__raw !== e);
          });
        }
        if (!(Wt(V6, e) >= 0)) {
          V6.push(e);
          var a = q8.wrapStageHandler(e, r);
          a.__prio = t, a.__raw = e, n.push(a);
        }
      }
      function j6(n, t) {
        nT[n] = t;
      }
      function Gxt(n, t, e) {
        var i = mxt("registerMap");
        i && i(n, t, e);
      }
      var Uxt = nEt;
      qh(qB, bEt), qh(U1, BEt), qh(U1, TEt), qh(qB, UEt), qh(U1, VEt), qh(E6, vxt), z6(J4), G6(Ext, kIt), j6("default", MEt), zo({ type: Sh, event: Sh, update: Sh }, In), zo({ type: Z_, event: Z_, update: Z_ }, In), zo({ type: kp, event: kp, update: kp }, In), zo({ type: K_, event: K_, update: K_ }, In), zo({ type: Fp, event: Fp, update: Fp }, In), O6("light", zEt), O6("dark", $8);
      var q6 = [], Vxt = { registerPreprocessor: z6, registerProcessor: G6, registerPostInit: Qxt, registerPostUpdate: Oxt, registerUpdateLifecycle: rT, registerAction: zo, registerCoordinateSystem: U6, registerLayout: zxt, registerVisual: qh, registerTransform: Uxt, registerLoading: j6, registerMap: Gxt, registerImpl: yxt, PRIORITY: Dxt, ComponentModel: ne, ComponentView: on, SeriesModel: $e, ChartView: Ve, registerComponentModel: function(n) {
        ne.registerClass(n);
      }, registerComponentView: function(n) {
        on.registerClass(n);
      }, registerSeriesModel: function(n) {
        $e.registerClass(n);
      }, registerChartView: function(n) {
        Ve.registerClass(n);
      }, registerSubTypeDefaulter: function(n, t) {
        ne.registerSubTypeDefaulter(n, t);
      }, registerPainter: function(n, t) {
        wmt(n, t);
      } };
      function Zt(n) {
        if (X(n)) {
          M(n, function(t) {
            Zt(t);
          });
          return;
        }
        Wt(q6, n) >= 0 || (q6.push(n), yt(n) && (n = { install: n }), n.install(Vxt));
      }
      function dv(n) {
        return n == null ? 0 : n.length || 1;
      }
      function H6(n) {
        return n;
      }
      var Os = function() {
        function n(t, e, i, r, a, o) {
          this._old = t, this._new = e, this._oldKeyGetter = i || H6, this._newKeyGetter = r || H6, this.context = a, this._diffModeMultiple = o === "multiple";
        }
        return n.prototype.add = function(t) {
          return this._add = t, this;
        }, n.prototype.update = function(t) {
          return this._update = t, this;
        }, n.prototype.updateManyToOne = function(t) {
          return this._updateManyToOne = t, this;
        }, n.prototype.updateOneToMany = function(t) {
          return this._updateOneToMany = t, this;
        }, n.prototype.updateManyToMany = function(t) {
          return this._updateManyToMany = t, this;
        }, n.prototype.remove = function(t) {
          return this._remove = t, this;
        }, n.prototype.execute = function() {
          this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
        }, n.prototype._executeOneToOne = function() {
          var t = this._old, e = this._new, i = {}, r = new Array(t.length), a = new Array(e.length);
          this._initIndexMap(t, null, r, "_oldKeyGetter"), this._initIndexMap(e, i, a, "_newKeyGetter");
          for (var o = 0; o < t.length; o++) {
            var s = r[o], l = i[s], u = dv(l);
            if (u > 1) {
              var h = l.shift();
              l.length === 1 && (i[s] = l[0]), this._update && this._update(h, o);
            } else u === 1 ? (i[s] = null, this._update && this._update(l, o)) : this._remove && this._remove(o);
          }
          this._performRestAdd(a, i);
        }, n.prototype._executeMultiple = function() {
          var t = this._old, e = this._new, i = {}, r = {}, a = [], o = [];
          this._initIndexMap(t, i, a, "_oldKeyGetter"), this._initIndexMap(e, r, o, "_newKeyGetter");
          for (var s = 0; s < a.length; s++) {
            var l = a[s], u = i[l], h = r[l], c = dv(u), f = dv(h);
            if (c > 1 && f === 1) this._updateManyToOne && this._updateManyToOne(h, u), r[l] = null;
            else if (c === 1 && f > 1) this._updateOneToMany && this._updateOneToMany(h, u), r[l] = null;
            else if (c === 1 && f === 1) this._update && this._update(h, u), r[l] = null;
            else if (c > 1 && f > 1) this._updateManyToMany && this._updateManyToMany(h, u), r[l] = null;
            else if (c > 1) for (var g = 0; g < c; g++) this._remove && this._remove(u[g]);
            else this._remove && this._remove(u);
          }
          this._performRestAdd(o, r);
        }, n.prototype._performRestAdd = function(t, e) {
          for (var i = 0; i < t.length; i++) {
            var r = t[i], a = e[r], o = dv(a);
            if (o > 1) for (var s = 0; s < o; s++) this._add && this._add(a[s]);
            else o === 1 && this._add && this._add(a);
            e[r] = null;
          }
        }, n.prototype._initIndexMap = function(t, e, i, r) {
          for (var a = this._diffModeMultiple, o = 0; o < t.length; o++) {
            var s = "_ec_" + this[r](t[o], o);
            if (a || (i[o] = s), !!e) {
              var l = e[s], u = dv(l);
              u === 0 ? (e[s] = o, a && i.push(s)) : u === 1 ? e[s] = [l, o] : l.push(o);
            }
          }
        }, n;
      }(), jxt = function() {
        function n(t, e) {
          this._encode = t, this._schema = e;
        }
        return n.prototype.get = function() {
          return { fullDimensions: this._getFullDimensionNames(), encode: this._encode };
        }, n.prototype._getFullDimensionNames = function() {
          return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
        }, n;
      }();
      function qxt(n, t) {
        var e = {}, i = e.encode = {}, r = dt(), a = [], o = [], s = {};
        M(n.dimensions, function(f) {
          var g = n.getDimensionInfo(f), d = g.coordDim;
          if (d) {
            It(AB.get(d) == null);
            var A = g.coordDimIndex;
            oT(i, d)[A] = f, g.isExtraCoord || (r.set(d, 1), Hxt(g.type) && (a[0] = f), oT(s, d)[A] = n.getDimensionIndex(g.name)), g.defaultTooltip && o.push(f);
          }
          AB.each(function(p, v) {
            var y = oT(i, v), m = g.otherDims[v];
            m != null && m !== false && (y[m] = g.name);
          });
        });
        var l = [], u = {};
        r.each(function(f, g) {
          var d = i[g];
          u[g] = d[0], l = l.concat(d);
        }), e.dataDimsOnCoord = l, e.dataDimIndicesOnCoord = Z(l, function(f) {
          return n.getDimensionInfo(f).storeDimIndex;
        }), e.encodeFirstDimNotExtra = u;
        var h = i.label;
        h && h.length && (a = h.slice());
        var c = i.tooltip;
        return c && c.length ? o = c.slice() : o.length || (o = a.slice()), i.defaultedLabel = a, i.defaultedTooltip = o, e.userOutput = new jxt(s, t), e;
      }
      function oT(n, t) {
        return n.hasOwnProperty(t) || (n[t] = []), n[t];
      }
      function Y1(n) {
        return n === "category" ? "ordinal" : n === "time" ? "time" : "float";
      }
      function Hxt(n) {
        return !(n === "ordinal" || n === "time");
      }
      var W1 = /* @__PURE__ */ function() {
        function n(t) {
          this.otherDims = {}, t != null && Y(this, t);
        }
        return n;
      }(), Yxt = le(), Wxt = { float: "f", int: "i", ordinal: "o", number: "n", time: "t" }, Y6 = function() {
        function n(t) {
          this.dimensions = t.dimensions, this._dimOmitted = t.dimensionOmitted, this.source = t.source, this._fullDimCount = t.fullDimensionCount, this._updateDimOmitted(t.dimensionOmitted);
        }
        return n.prototype.isDimensionOmitted = function() {
          return this._dimOmitted;
        }, n.prototype._updateDimOmitted = function(t) {
          this._dimOmitted = t, t && (this._dimNameMap || (this._dimNameMap = Z6(this.source)));
        }, n.prototype.getSourceDimensionIndex = function(t) {
          return Pt(this._dimNameMap.get(t), -1);
        }, n.prototype.getSourceDimension = function(t) {
          var e = this.source.dimensionsDefine;
          if (e) return e[t];
        }, n.prototype.makeStoreSchema = function() {
          for (var t = this._fullDimCount, e = i8(this.source), i = !K6(t), r = "", a = [], o = 0, s = 0; o < t; o++) {
            var l = void 0, u = void 0, h = void 0, c = this.dimensions[s];
            if (c && c.storeDimIndex === o) l = e ? c.name : null, u = c.type, h = c.ordinalMeta, s++;
            else {
              var f = this.getSourceDimension(o);
              f && (l = e ? f.name : null, u = f.type);
            }
            a.push({ property: l, type: u, ordinalMeta: h }), e && l != null && (!c || !c.isCalculationCoord) && (r += i ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), r += "$", r += Wxt[u] || "f", h && (r += h.uid), r += "$";
          }
          var g = this.source, d = [g.seriesLayoutBy, g.startIndex, r].join("$$");
          return { dimensions: a, hash: d };
        }, n.prototype.makeOutputDimensionNames = function() {
          for (var t = [], e = 0, i = 0; e < this._fullDimCount; e++) {
            var r = void 0, a = this.dimensions[i];
            if (a && a.storeDimIndex === e) a.isCalculationCoord || (r = a.name), i++;
            else {
              var o = this.getSourceDimension(e);
              o && (r = o.name);
            }
            t.push(r);
          }
          return t;
        }, n.prototype.appendCalculationDimension = function(t) {
          this.dimensions.push(t), t.isCalculationCoord = true, this._fullDimCount++, this._updateDimOmitted(true);
        }, n;
      }();
      function W6(n) {
        return n instanceof Y6;
      }
      function X6(n) {
        for (var t = dt(), e = 0; e < (n || []).length; e++) {
          var i = n[e], r = _t(i) ? i.name : i;
          r != null && t.get(r) == null && t.set(r, e);
        }
        return t;
      }
      function Z6(n) {
        var t = Yxt(n);
        return t.dimNameMap || (t.dimNameMap = X6(n.dimensionsDefine));
      }
      function K6(n) {
        return n > 30;
      }
      var Av = _t, su = Z, Xxt = typeof Int32Array == "undefined" ? Array : Int32Array, Zxt = "e\0\0", $6 = -1, Kxt = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], $xt = ["_approximateExtent"], J6, X1, pv, Yg, sT, Z1, lT, Zi = function() {
        function n(t, e) {
          this.type = "list", this._dimOmitted = false, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = false, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"];
          var i, r = false;
          W6(t) ? (i = t.dimensions, this._dimOmitted = t.isDimensionOmitted(), this._schema = t) : (r = true, i = t), i = i || ["x", "y"];
          for (var a = {}, o = [], s = {}, l = false, u = {}, h = 0; h < i.length; h++) {
            var c = i[h], f = ht(c) ? new W1({ name: c }) : c instanceof W1 ? c : new W1(c), g = f.name;
            f.type = f.type || "float", f.coordDim || (f.coordDim = g, f.coordDimIndex = 0);
            var d = f.otherDims = f.otherDims || {};
            o.push(g), a[g] = f, u[g] != null && (l = true), f.createInvertedIndices && (s[g] = []), d.itemName === 0 && (this._nameDimIdx = h), d.itemId === 0 && (this._idDimIdx = h), It(r || f.storeDimIndex >= 0), r && (f.storeDimIndex = h);
          }
          if (this.dimensions = o, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = e, this._invertedIndicesMap = s, this._dimOmitted) {
            var A = this._dimIdxToName = dt();
            M(o, function(p) {
              A.set(a[p].storeDimIndex, p);
            });
          }
        }
        return n.prototype.getDimension = function(t) {
          var e = this._recognizeDimIndex(t);
          if (e == null) return t;
          if (e = t, !this._dimOmitted) return this.dimensions[e];
          var i = this._dimIdxToName.get(e);
          if (i != null) return i;
          var r = this._schema.getSourceDimension(e);
          if (r) return r.name;
        }, n.prototype.getDimensionIndex = function(t) {
          var e = this._recognizeDimIndex(t);
          if (e != null) return e;
          if (t == null) return -1;
          var i = this._getDimInfo(t);
          return i ? i.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(t) : -1;
        }, n.prototype._recognizeDimIndex = function(t) {
          if (pe(t) || t != null && !isNaN(t) && !this._getDimInfo(t) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(t) < 0)) return +t;
        }, n.prototype._getStoreDimIndex = function(t) {
          var e = this.getDimensionIndex(t);
          if (e == null) throw new Error("Unknown dimension " + t);
          return e;
        }, n.prototype.getDimensionInfo = function(t) {
          return this._getDimInfo(this.getDimension(t));
        }, n.prototype._initGetDimensionInfo = function(t) {
          var e = this._dimInfos;
          this._getDimInfo = t ? function(i) {
            return e.hasOwnProperty(i) ? e[i] : void 0;
          } : function(i) {
            return e[i];
          };
        }, n.prototype.getDimensionsOnCoord = function() {
          return this._dimSummary.dataDimsOnCoord.slice();
        }, n.prototype.mapDimension = function(t, e) {
          var i = this._dimSummary;
          if (e == null) return i.encodeFirstDimNotExtra[t];
          var r = i.encode[t];
          return r ? r[e] : null;
        }, n.prototype.mapDimensionsAll = function(t) {
          var e = this._dimSummary, i = e.encode[t];
          return (i || []).slice();
        }, n.prototype.getStore = function() {
          return this._store;
        }, n.prototype.initData = function(t, e, i) {
          var r = this, a;
          if (t instanceof LB && (a = t), !a) {
            var o = this.dimensions, s = SB(t) || Mi(t) ? new o8(t, o.length) : t;
            a = new LB();
            var l = su(o, function(u) {
              return { type: r._dimInfos[u].type, property: u };
            });
            a.initData(s, l, i);
          }
          this._store = a, this._nameList = (e || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = qxt(this, this._schema), this.userOutput = this._dimSummary.userOutput;
        }, n.prototype.appendData = function(t) {
          var e = this._store.appendData(t);
          this._doInit(e[0], e[1]);
        }, n.prototype.appendValues = function(t, e) {
          var i = this._store.appendValues(t, e.length), r = i.start, a = i.end, o = this._shouldMakeIdFromName();
          if (this._updateOrdinalMeta(), e) for (var s = r; s < a; s++) {
            var l = s - r;
            this._nameList[s] = e[l], o && lT(this, s);
          }
        }, n.prototype._updateOrdinalMeta = function() {
          for (var t = this._store, e = this.dimensions, i = 0; i < e.length; i++) {
            var r = this._dimInfos[e[i]];
            r.ordinalMeta && t.collectOrdinalMeta(r.storeDimIndex, r.ordinalMeta);
          }
        }, n.prototype._shouldMakeIdFromName = function() {
          var t = this._store.getProvider();
          return this._idDimIdx == null && t.getSource().sourceFormat !== Fs && !t.fillStorage;
        }, n.prototype._doInit = function(t, e) {
          if (!(t >= e)) {
            var i = this._store, r = i.getProvider();
            this._updateOrdinalMeta();
            var a = this._nameList, o = this._idList, s = r.getSource().sourceFormat, l = s === da;
            if (l && !r.pure) for (var u = [], h = t; h < e; h++) {
              var c = r.getItem(h, u);
              if (!this.hasItemOption && Pmt(c) && (this.hasItemOption = true), c) {
                var f = c.name;
                a[h] == null && f != null && (a[h] = zn(f, null));
                var g = c.id;
                o[h] == null && g != null && (o[h] = zn(g, null));
              }
            }
            if (this._shouldMakeIdFromName()) for (var h = t; h < e; h++) lT(this, h);
            J6(this);
          }
        }, n.prototype.getApproximateExtent = function(t) {
          return this._approximateExtent[t] || this._store.getDataExtent(this._getStoreDimIndex(t));
        }, n.prototype.setApproximateExtent = function(t, e) {
          e = this.getDimension(e), this._approximateExtent[e] = t.slice();
        }, n.prototype.getCalculationInfo = function(t) {
          return this._calculationInfo[t];
        }, n.prototype.setCalculationInfo = function(t, e) {
          Av(t) ? Y(this._calculationInfo, t) : this._calculationInfo[t] = e;
        }, n.prototype.getName = function(t) {
          var e = this.getRawIndex(t), i = this._nameList[e];
          return i == null && this._nameDimIdx != null && (i = pv(this, this._nameDimIdx, e)), i == null && (i = ""), i;
        }, n.prototype._getCategory = function(t, e) {
          var i = this._store.get(t, e), r = this._store.getOrdinalMeta(t);
          return r ? r.categories[i] : i;
        }, n.prototype.getId = function(t) {
          return X1(this, this.getRawIndex(t));
        }, n.prototype.count = function() {
          return this._store.count();
        }, n.prototype.get = function(t, e) {
          var i = this._store, r = this._dimInfos[t];
          if (r) return i.get(r.storeDimIndex, e);
        }, n.prototype.getByRawIndex = function(t, e) {
          var i = this._store, r = this._dimInfos[t];
          if (r) return i.getByRawIndex(r.storeDimIndex, e);
        }, n.prototype.getIndices = function() {
          return this._store.getIndices();
        }, n.prototype.getDataExtent = function(t) {
          return this._store.getDataExtent(this._getStoreDimIndex(t));
        }, n.prototype.getSum = function(t) {
          return this._store.getSum(this._getStoreDimIndex(t));
        }, n.prototype.getMedian = function(t) {
          return this._store.getMedian(this._getStoreDimIndex(t));
        }, n.prototype.getValues = function(t, e) {
          var i = this, r = this._store;
          return X(t) ? r.getValues(su(t, function(a) {
            return i._getStoreDimIndex(a);
          }), e) : r.getValues(t);
        }, n.prototype.hasValue = function(t) {
          for (var e = this._dimSummary.dataDimIndicesOnCoord, i = 0, r = e.length; i < r; i++) if (isNaN(this._store.get(e[i], t))) return false;
          return true;
        }, n.prototype.indexOfName = function(t) {
          for (var e = 0, i = this._store.count(); e < i; e++) if (this.getName(e) === t) return e;
          return -1;
        }, n.prototype.getRawIndex = function(t) {
          return this._store.getRawIndex(t);
        }, n.prototype.indexOfRawIndex = function(t) {
          return this._store.indexOfRawIndex(t);
        }, n.prototype.rawIndexOf = function(t, e) {
          var i = t && this._invertedIndicesMap[t];
          if (!i) throw new Error("Do not supported yet");
          var r = i[e];
          return r == null || isNaN(r) ? $6 : r;
        }, n.prototype.indicesOfNearest = function(t, e, i) {
          return this._store.indicesOfNearest(this._getStoreDimIndex(t), e, i);
        }, n.prototype.each = function(t, e, i) {
          yt(t) && (i = e, e = t, t = []);
          var r = i || this, a = su(Yg(t), this._getStoreDimIndex, this);
          this._store.each(a, r ? ct(e, r) : e);
        }, n.prototype.filterSelf = function(t, e, i) {
          yt(t) && (i = e, e = t, t = []);
          var r = i || this, a = su(Yg(t), this._getStoreDimIndex, this);
          return this._store = this._store.filter(a, r ? ct(e, r) : e), this;
        }, n.prototype.selectRange = function(t) {
          var e = this, i = {}, r = re(t);
          return M(r, function(a) {
            var o = e._getStoreDimIndex(a);
            i[o] = t[a];
          }), this._store = this._store.selectRange(i), this;
        }, n.prototype.mapArray = function(t, e, i) {
          yt(t) && (i = e, e = t, t = []), i = i || this;
          var r = [];
          return this.each(t, function() {
            r.push(e && e.apply(this, arguments));
          }, i), r;
        }, n.prototype.map = function(t, e, i, r) {
          var a = i || r || this, o = su(Yg(t), this._getStoreDimIndex, this), s = Z1(this);
          return s._store = this._store.map(o, a ? ct(e, a) : e), s;
        }, n.prototype.modify = function(t, e, i, r) {
          var a = this, o = i || r || this;
          M(Yg(t), function(l) {
            var u = a.getDimensionInfo(l);
            u.isCalculationCoord;
          });
          var s = su(Yg(t), this._getStoreDimIndex, this);
          this._store.modify(s, o ? ct(e, o) : e);
        }, n.prototype.downSample = function(t, e, i, r) {
          var a = Z1(this);
          return a._store = this._store.downSample(this._getStoreDimIndex(t), e, i, r), a;
        }, n.prototype.lttbDownSample = function(t, e) {
          var i = Z1(this);
          return i._store = this._store.lttbDownSample(this._getStoreDimIndex(t), e), i;
        }, n.prototype.getRawDataItem = function(t) {
          return this._store.getRawDataItem(t);
        }, n.prototype.getItemModel = function(t) {
          var e = this.hostModel, i = this.getRawDataItem(t);
          return new Te(i, e, e && e.ecModel);
        }, n.prototype.diff = function(t) {
          var e = this;
          return new Os(t ? t.getStore().getIndices() : [], this.getStore().getIndices(), function(i) {
            return X1(t, i);
          }, function(i) {
            return X1(e, i);
          });
        }, n.prototype.getVisual = function(t) {
          var e = this._visual;
          return e && e[t];
        }, n.prototype.setVisual = function(t, e) {
          this._visual = this._visual || {}, Av(t) ? Y(this._visual, t) : this._visual[t] = e;
        }, n.prototype.getItemVisual = function(t, e) {
          var i = this._itemVisuals[t], r = i && i[e];
          return r == null ? this.getVisual(e) : r;
        }, n.prototype.hasItemVisual = function() {
          return this._itemVisuals.length > 0;
        }, n.prototype.ensureUniqueItemVisual = function(t, e) {
          var i = this._itemVisuals, r = i[t];
          r || (r = i[t] = {});
          var a = r[e];
          return a == null && (a = this.getVisual(e), X(a) ? a = a.slice() : Av(a) && (a = Y({}, a)), r[e] = a), a;
        }, n.prototype.setItemVisual = function(t, e, i) {
          var r = this._itemVisuals[t] || {};
          this._itemVisuals[t] = r, Av(e) ? Y(r, e) : r[e] = i;
        }, n.prototype.clearAllVisual = function() {
          this._visual = {}, this._itemVisuals = [];
        }, n.prototype.setLayout = function(t, e) {
          Av(t) ? Y(this._layout, t) : this._layout[t] = e;
        }, n.prototype.getLayout = function(t) {
          return this._layout[t];
        }, n.prototype.getItemLayout = function(t) {
          return this._itemLayouts[t];
        }, n.prototype.setItemLayout = function(t, e, i) {
          this._itemLayouts[t] = i ? Y(this._itemLayouts[t] || {}, e) : e;
        }, n.prototype.clearItemLayouts = function() {
          this._itemLayouts.length = 0;
        }, n.prototype.setItemGraphicEl = function(t, e) {
          var i = this.hostModel && this.hostModel.seriesIndex;
          N2(i, this.dataType, t, e), this._graphicEls[t] = e;
        }, n.prototype.getItemGraphicEl = function(t) {
          return this._graphicEls[t];
        }, n.prototype.eachItemGraphicEl = function(t, e) {
          M(this._graphicEls, function(i, r) {
            i && t && t.call(e, i, r);
          });
        }, n.prototype.cloneShallow = function(t) {
          return t || (t = new n(this._schema ? this._schema : su(this.dimensions, this._getDimInfo, this), this.hostModel)), sT(t, this), t._store = this._store, t;
        }, n.prototype.wrapMethod = function(t, e) {
          var i = this[t];
          yt(i) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
            var r = i.apply(this, arguments);
            return e.apply(this, [r].concat(db(arguments)));
          });
        }, n.internalField = function() {
          J6 = function(t) {
            var e = t._invertedIndicesMap;
            M(e, function(i, r) {
              var a = t._dimInfos[r], o = a.ordinalMeta, s = t._store;
              if (o) {
                i = e[r] = new Xxt(o.categories.length);
                for (var l = 0; l < i.length; l++) i[l] = $6;
                for (var l = 0; l < s.count(); l++) i[s.get(a.storeDimIndex, l)] = l;
              }
            });
          }, pv = function(t, e, i) {
            return zn(t._getCategory(e, i), null);
          }, X1 = function(t, e) {
            var i = t._idList[e];
            return i == null && t._idDimIdx != null && (i = pv(t, t._idDimIdx, e)), i == null && (i = Zxt + e), i;
          }, Yg = function(t) {
            return X(t) || (t = t != null ? [t] : []), t;
          }, Z1 = function(t) {
            var e = new n(t._schema ? t._schema : su(t.dimensions, t._getDimInfo, t), t.hostModel);
            return sT(e, t), e;
          }, sT = function(t, e) {
            M(Kxt.concat(e.__wrappedMethods || []), function(i) {
              e.hasOwnProperty(i) && (t[i] = e[i]);
            }), t.__wrappedMethods = e.__wrappedMethods, M($xt, function(i) {
              t[i] = xt(e[i]);
            }), t._calculationInfo = Y({}, e._calculationInfo);
          }, lT = function(t, e) {
            var i = t._nameList, r = t._idList, a = t._nameDimIdx, o = t._idDimIdx, s = i[e], l = r[e];
            if (s == null && a != null && (i[e] = s = pv(t, a, e)), l == null && o != null && (r[e] = l = pv(t, o, e)), l == null && s != null) {
              var u = t._nameRepeatCount, h = u[s] = (u[s] || 0) + 1;
              l = s, h > 1 && (l += "__ec__" + h), r[e] = l;
            }
          };
        }(), n;
      }();
      function vv(n, t) {
        SB(n) || (n = BB(n)), t = t || {};
        var e = t.coordDimensions || [], i = t.dimensionsDefine || n.dimensionsDefine || [], r = dt(), a = [], o = twt(n, e, i, t.dimensionsCount), s = t.canOmitUnusedDimensions && K6(o), l = i === n.dimensionsDefine, u = l ? Z6(n) : X6(i), h = t.encodeDefine;
        !h && t.encodeDefaulter && (h = t.encodeDefaulter(n, o));
        for (var c = dt(h), f = new y8(o), g = 0; g < f.length; g++) f[g] = -1;
        function d(C) {
          var S = f[C];
          if (S < 0) {
            var b = i[C], B = _t(b) ? b : { name: b }, T = new W1(), D = B.name;
            D != null && u.get(D) != null && (T.name = T.displayName = D), B.type != null && (T.type = B.type), B.displayName != null && (T.displayName = B.displayName);
            var R = a.length;
            return f[C] = R, T.storeDimIndex = C, a.push(T), T;
          }
          return a[S];
        }
        if (!s) for (var g = 0; g < o; g++) d(g);
        c.each(function(C, S) {
          var b = Qe(C).slice();
          if (b.length === 1 && !ht(b[0]) && b[0] < 0) {
            c.set(S, false);
            return;
          }
          var B = c.set(S, []);
          M(b, function(T, D) {
            var R = ht(T) ? u.get(T) : T;
            R != null && R < o && (B[D] = R, p(d(R), S, D));
          });
        });
        var A = 0;
        M(e, function(C) {
          var S, b, B, T;
          if (ht(C)) S = C, T = {};
          else {
            T = C, S = T.name;
            var D = T.ordinalMeta;
            T.ordinalMeta = null, T = Y({}, T), T.ordinalMeta = D, b = T.dimsDef, B = T.otherDims, T.name = T.coordDim = T.coordDimIndex = T.dimsDef = T.otherDims = null;
          }
          var R = c.get(S);
          if (R !== false) {
            if (R = Qe(R), !R.length) for (var L = 0; L < (b && b.length || 1); L++) {
              for (; A < o && d(A).coordDim != null; ) A++;
              A < o && R.push(A++);
            }
            M(R, function(k, P) {
              var F = d(k);
              if (l && T.type != null && (F.type = T.type), p(Et(F, T), S, P), F.name == null && b) {
                var Q = b[P];
                !_t(Q) && (Q = { name: Q }), F.name = F.displayName = Q.name, F.defaultTooltip = Q.defaultTooltip;
              }
              B && Et(F.otherDims, B);
            });
          }
        });
        function p(C, S, b) {
          AB.get(S) != null ? C.otherDims[S] = b : (C.coordDim = S, C.coordDimIndex = b, r.set(S, true));
        }
        var v = t.generateCoord, y = t.generateCoordCount, m = y != null;
        y = v ? y || 1 : 0;
        var _ = v || "value";
        function E(C) {
          C.name == null && (C.name = C.coordDim);
        }
        if (s) M(a, function(C) {
          E(C);
        }), a.sort(function(C, S) {
          return C.storeDimIndex - S.storeDimIndex;
        });
        else for (var I = 0; I < o; I++) {
          var x = d(I), w = x.coordDim;
          w == null && (x.coordDim = ewt(_, r, m), x.coordDimIndex = 0, (!v || y <= 0) && (x.isExtraCoord = true), y--), E(x), x.type == null && (F4(n, I) === yi.Must || x.isExtraCoord && (x.otherDims.itemName != null || x.otherDims.seriesName != null)) && (x.type = "ordinal");
        }
        return Jxt(a), new Y6({ source: n, dimensions: a, fullDimensionCount: o, dimensionOmitted: s });
      }
      function Jxt(n) {
        for (var t = dt(), e = 0; e < n.length; e++) {
          var i = n[e], r = i.name, a = t.get(r) || 0;
          a > 0 && (i.name = r + (a - 1)), a++, t.set(r, a);
        }
      }
      function twt(n, t, e, i) {
        var r = Math.max(n.dimensionsDetectedCount || 1, t.length, e.length, i || 0);
        return M(t, function(a) {
          var o;
          _t(a) && (o = a.dimsDef) && (r = Math.max(r, o.length));
        }), r;
      }
      function ewt(n, t, e) {
        if (e || t.hasKey(n)) {
          for (var i = 0; t.hasKey(n + i); ) i++;
          n += i;
        }
        return t.set(n, true), n;
      }
      var nwt = /* @__PURE__ */ function() {
        function n(t) {
          this.coordSysDims = [], this.axisMap = dt(), this.categoryAxisMap = dt(), this.coordSysName = t;
        }
        return n;
      }();
      function iwt(n) {
        var t = n.get("coordinateSystem"), e = new nwt(t), i = rwt[t];
        if (i) return i(n, e, e.axisMap, e.categoryAxisMap), e;
      }
      var rwt = { cartesian2d: function(n, t, e, i) {
        var r = n.getReferringComponents("xAxis", Ln).models[0], a = n.getReferringComponents("yAxis", Ln).models[0];
        if (true) {
          if (!r) throw new Error('xAxis "' + Dn(n.get("xAxisIndex"), n.get("xAxisId"), 0) + '" not found');
          if (!a) throw new Error('yAxis "' + Dn(n.get("xAxisIndex"), n.get("yAxisId"), 0) + '" not found');
        }
        t.coordSysDims = ["x", "y"], e.set("x", r), e.set("y", a), Wg(r) && (i.set("x", r), t.firstCategoryDimIndex = 0), Wg(a) && (i.set("y", a), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
      }, singleAxis: function(n, t, e, i) {
        var r = n.getReferringComponents("singleAxis", Ln).models[0];
        if (!r) throw new Error("singleAxis should be specified.");
        t.coordSysDims = ["single"], e.set("single", r), Wg(r) && (i.set("single", r), t.firstCategoryDimIndex = 0);
      }, polar: function(n, t, e, i) {
        var r = n.getReferringComponents("polar", Ln).models[0], a = r.findAxisModel("radiusAxis"), o = r.findAxisModel("angleAxis");
        if (true) {
          if (!o) throw new Error("angleAxis option not found");
          if (!a) throw new Error("radiusAxis option not found");
        }
        t.coordSysDims = ["radius", "angle"], e.set("radius", a), e.set("angle", o), Wg(a) && (i.set("radius", a), t.firstCategoryDimIndex = 0), Wg(o) && (i.set("angle", o), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
      }, geo: function(n, t, e, i) {
        t.coordSysDims = ["lng", "lat"];
      }, parallel: function(n, t, e, i) {
        var r = n.ecModel, a = r.getComponent("parallel", n.get("parallelIndex")), o = t.coordSysDims = a.dimensions.slice();
        M(a.parallelAxisIndex, function(s, l) {
          var u = r.getComponent("parallelAxis", s), h = o[l];
          e.set(h, u), Wg(u) && (i.set(h, u), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = l));
        });
      } };
      function Wg(n) {
        return n.get("type") === "category";
      }
      function awt(n, t, e) {
        e = e || {};
        var i = e.byIndex, r = e.stackedCoordDimension, a, o, s;
        owt(t) ? a = t : (o = t.schema, a = o.dimensions, s = t.store);
        var l = !!(n && n.get("stack")), u, h, c, f;
        if (M(a, function(y, m) {
          ht(y) && (a[m] = y = { name: y }), l && !y.isExtraCoord && (!i && !u && y.ordinalMeta && (u = y), !h && y.type !== "ordinal" && y.type !== "time" && (!r || r === y.coordDim) && (h = y));
        }), h && !i && !u && (i = true), h) {
          c = "__\0ecstackresult_" + n.id, f = "__\0ecstackedover_" + n.id, u && (u.createInvertedIndices = true);
          var g = h.coordDim, d = h.type, A = 0;
          M(a, function(y) {
            y.coordDim === g && A++;
          });
          var p = { name: c, coordDim: g, coordDimIndex: A, type: d, isExtraCoord: true, isCalculationCoord: true, storeDimIndex: a.length }, v = { name: f, coordDim: f, coordDimIndex: A + 1, type: d, isExtraCoord: true, isCalculationCoord: true, storeDimIndex: a.length + 1 };
          o ? (s && (p.storeDimIndex = s.ensureCalculationDimension(f, d), v.storeDimIndex = s.ensureCalculationDimension(c, d)), o.appendCalculationDimension(p), o.appendCalculationDimension(v)) : (a.push(p), a.push(v));
        }
        return { stackedDimension: h && h.name, stackedByDimension: u && u.name, isStackedByIndex: i, stackedOverDimension: f, stackResultDimension: c };
      }
      function owt(n) {
        return !W6(n.schema);
      }
      function lu(n, t) {
        return !!t && t === n.getCalculationInfo("stackedDimension");
      }
      function tU(n, t) {
        return lu(n, t) ? n.getCalculationInfo("stackResultDimension") : t;
      }
      function swt(n, t) {
        var e = n.get("coordinateSystem"), i = Fg.get(e), r;
        return t && t.coordSysDims && (r = Z(t.coordSysDims, function(a) {
          var o = { name: a }, s = t.axisMap.get(a);
          if (s) {
            var l = s.get("type");
            o.type = Y1(l);
          }
          return o;
        })), r || (r = i && (i.getDimensionsInfo ? i.getDimensionsInfo() : i.dimensions.slice()) || ["x", "y"]), r;
      }
      function lwt(n, t, e) {
        var i, r;
        return e && M(n, function(a, o) {
          var s = a.coordDim, l = e.categoryAxisMap.get(s);
          l && (i == null && (i = o), a.ordinalMeta = l.getOrdinalMeta(), t && (a.createInvertedIndices = true)), a.otherDims.itemName != null && (r = true);
        }), !r && i != null && (n[i].otherDims.itemName = 0), i;
      }
      function zs(n, t, e) {
        e = e || {};
        var i = t.getSourceManager(), r, a = false;
        n ? (a = true, r = BB(n)) : (r = i.getSource(), a = r.sourceFormat === da);
        var o = iwt(t), s = swt(t, o), l = e.useEncodeDefaulter, u = yt(l) ? l : l ? Ot(k4, s, t) : null, h = { coordDimensions: s, generateCoord: e.generateCoord, encodeDefine: t.getEncode(), encodeDefaulter: u, canOmitUnusedDimensions: !a }, c = vv(r, h), f = lwt(c.dimensions, e.createInvertedIndices, o), g = a ? null : i.getSharedDataStore(c), d = awt(t, { schema: c, store: g }), A = new Zi(c, t);
        A.setCalculationInfo(d);
        var p = f != null && uwt(r) ? function(v, y, m, _) {
          return _ === f ? m : this.defaultDimValueGetter(v, y, m, _);
        } : null;
        return A.hasItemOption = false, A.initData(a ? r : g, null, p), A;
      }
      function uwt(n) {
        if (n.sourceFormat === da) {
          var t = hwt(n.data || []);
          return !X(pg(t));
        }
      }
      function hwt(n) {
        for (var t = 0; t < n.length && n[t] == null; ) t++;
        return n[t];
      }
      var Go = function() {
        function n(t) {
          this._setting = t || {}, this._extent = [1 / 0, -1 / 0];
        }
        return n.prototype.getSetting = function(t) {
          return this._setting[t];
        }, n.prototype.unionExtent = function(t) {
          var e = this._extent;
          t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]);
        }, n.prototype.unionExtentFromData = function(t, e) {
          this.unionExtent(t.getApproximateExtent(e));
        }, n.prototype.getExtent = function() {
          return this._extent.slice();
        }, n.prototype.setExtent = function(t, e) {
          var i = this._extent;
          isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e);
        }, n.prototype.isInExtentRange = function(t) {
          return this._extent[0] <= t && this._extent[1] >= t;
        }, n.prototype.isBlank = function() {
          return this._isBlank;
        }, n.prototype.setBlank = function(t) {
          this._isBlank = t;
        }, n;
      }();
      G_(Go);
      var cwt = 0, uT = function() {
        function n(t) {
          this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, this.uid = ++cwt;
        }
        return n.createByAxisModel = function(t) {
          var e = t.option, i = e.data, r = i && Z(i, fwt);
          return new n({ categories: r, needCollect: !r, deduplication: e.dedplication !== false });
        }, n.prototype.getOrdinal = function(t) {
          return this._getOrCreateMap().get(t);
        }, n.prototype.parseAndCollect = function(t) {
          var e, i = this._needCollect;
          if (!ht(t) && !i) return t;
          if (i && !this._deduplication) return e = this.categories.length, this.categories[e] = t, e;
          var r = this._getOrCreateMap();
          return e = r.get(t), e == null && (i ? (e = this.categories.length, this.categories[e] = t, r.set(t, e)) : e = NaN), e;
        }, n.prototype._getOrCreateMap = function() {
          return this._map || (this._map = dt(this.categories));
        }, n;
      }();
      function fwt(n) {
        return _t(n) && n.value != null ? n.value : n + "";
      }
      function gwt(n) {
        var t = Math.pow(10, O_(Math.abs(n))), e = Math.abs(n / t);
        return e === 0 || e === 1 || e === 2 || e === 3 || e === 5;
      }
      function hT(n) {
        return n.type === "interval" || n.type === "log";
      }
      function dwt(n, t, e, i) {
        var r = {}, a = n[1] - n[0], o = r.interval = TG(a / t);
        e != null && o < e && (o = r.interval = e), i != null && o > i && (o = r.interval = i);
        var s = r.intervalPrecision = eU(o), l = r.niceTickExtent = [vn(Math.ceil(n[0] / o) * o, s), vn(Math.floor(n[1] / o) * o, s)];
        return Awt(l, n), r;
      }
      function cT(n) {
        var t = Math.pow(10, O_(n)), e = n / t;
        return e ? e === 2 ? e = 3 : e === 3 ? e = 5 : e *= 2 : e = 1, vn(e * t);
      }
      function eU(n) {
        return Mo(n) + 2;
      }
      function nU(n, t, e) {
        n[t] = Math.max(Math.min(n[t], e[1]), e[0]);
      }
      function Awt(n, t) {
        !isFinite(n[0]) && (n[0] = t[0]), !isFinite(n[1]) && (n[1] = t[1]), nU(n, 0, t), nU(n, 1, t), n[0] > n[1] && (n[0] = n[1]);
      }
      function K1(n, t) {
        return n >= t[0] && n <= t[1];
      }
      function $1(n, t) {
        return t[1] === t[0] ? 0.5 : (n - t[0]) / (t[1] - t[0]);
      }
      function J1(n, t) {
        return n * (t[1] - t[0]) + t[0];
      }
      var tI = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          i.type = "ordinal";
          var r = i.getSetting("ordinalMeta");
          return r || (r = new uT({})), X(r) && (r = new uT({ categories: Z(r, function(a) {
            return _t(a) ? a.value : a;
          }) })), i._ordinalMeta = r, i._extent = i.getSetting("extent") || [0, r.categories.length - 1], i;
        }
        return t.prototype.parse = function(e) {
          return e == null ? NaN : ht(e) ? this._ordinalMeta.getOrdinal(e) : Math.round(e);
        }, t.prototype.contain = function(e) {
          return e = this.parse(e), K1(e, this._extent) && this._ordinalMeta.categories[e] != null;
        }, t.prototype.normalize = function(e) {
          return e = this._getTickNumber(this.parse(e)), $1(e, this._extent);
        }, t.prototype.scale = function(e) {
          return e = Math.round(J1(e, this._extent)), this.getRawOrdinalNumber(e);
        }, t.prototype.getTicks = function() {
          for (var e = [], i = this._extent, r = i[0]; r <= i[1]; ) e.push({ value: r }), r++;
          return e;
        }, t.prototype.getMinorTicks = function(e) {
        }, t.prototype.setSortInfo = function(e) {
          if (e == null) {
            this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
            return;
          }
          for (var i = e.ordinalNumbers, r = this._ordinalNumbersByTick = [], a = this._ticksByOrdinalNumber = [], o = 0, s = this._ordinalMeta.categories.length, l = Math.min(s, i.length); o < l; ++o) {
            var u = i[o];
            r[o] = u, a[u] = o;
          }
          for (var h = 0; o < s; ++o) {
            for (; a[h] != null; ) h++;
            r.push(h), a[h] = o;
          }
        }, t.prototype._getTickNumber = function(e) {
          var i = this._ticksByOrdinalNumber;
          return i && e >= 0 && e < i.length ? i[e] : e;
        }, t.prototype.getRawOrdinalNumber = function(e) {
          var i = this._ordinalNumbersByTick;
          return i && e >= 0 && e < i.length ? i[e] : e;
        }, t.prototype.getLabel = function(e) {
          if (!this.isBlank()) {
            var i = this.getRawOrdinalNumber(e.value), r = this._ordinalMeta.categories[i];
            return r == null ? "" : r + "";
          }
        }, t.prototype.count = function() {
          return this._extent[1] - this._extent[0] + 1;
        }, t.prototype.unionExtentFromData = function(e, i) {
          this.unionExtent(e.getApproximateExtent(i));
        }, t.prototype.isInExtentRange = function(e) {
          return e = this._getTickNumber(e), this._extent[0] <= e && this._extent[1] >= e;
        }, t.prototype.getOrdinalMeta = function() {
          return this._ordinalMeta;
        }, t.prototype.calcNiceTicks = function() {
        }, t.prototype.calcNiceExtent = function() {
        }, t.type = "ordinal", t;
      }(Go);
      Go.registerClass(tI);
      var Hh = vn, Gs = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "interval", e._interval = 0, e._intervalPrecision = 2, e;
        }
        return t.prototype.parse = function(e) {
          return e;
        }, t.prototype.contain = function(e) {
          return K1(e, this._extent);
        }, t.prototype.normalize = function(e) {
          return $1(e, this._extent);
        }, t.prototype.scale = function(e) {
          return J1(e, this._extent);
        }, t.prototype.setExtent = function(e, i) {
          var r = this._extent;
          isNaN(e) || (r[0] = parseFloat(e)), isNaN(i) || (r[1] = parseFloat(i));
        }, t.prototype.unionExtent = function(e) {
          var i = this._extent;
          e[0] < i[0] && (i[0] = e[0]), e[1] > i[1] && (i[1] = e[1]), this.setExtent(i[0], i[1]);
        }, t.prototype.getInterval = function() {
          return this._interval;
        }, t.prototype.setInterval = function(e) {
          this._interval = e, this._niceExtent = this._extent.slice(), this._intervalPrecision = eU(e);
        }, t.prototype.getTicks = function(e) {
          var i = this._interval, r = this._extent, a = this._niceExtent, o = this._intervalPrecision, s = [];
          if (!i) return s;
          var l = 1e4;
          r[0] < a[0] && (e ? s.push({ value: Hh(a[0] - i, o) }) : s.push({ value: r[0] }));
          for (var u = a[0]; u <= a[1] && (s.push({ value: u }), u = Hh(u + i, o), u !== s[s.length - 1].value); ) if (s.length > l) return [];
          var h = s.length ? s[s.length - 1].value : a[1];
          return r[1] > h && (e ? s.push({ value: Hh(h + i, o) }) : s.push({ value: r[1] })), s;
        }, t.prototype.getMinorTicks = function(e) {
          for (var i = this.getTicks(true), r = [], a = this.getExtent(), o = 1; o < i.length; o++) {
            for (var s = i[o], l = i[o - 1], u = 0, h = [], c = s.value - l.value, f = c / e; u < e - 1; ) {
              var g = Hh(l.value + (u + 1) * f);
              g > a[0] && g < a[1] && h.push(g), u++;
            }
            r.push(h);
          }
          return r;
        }, t.prototype.getLabel = function(e, i) {
          if (e == null) return "";
          var r = i && i.precision;
          r == null ? r = Mo(e.value) || 0 : r === "auto" && (r = this._intervalPrecision);
          var a = Hh(e.value, r, true);
          return b4(a);
        }, t.prototype.calcNiceTicks = function(e, i, r) {
          e = e || 5;
          var a = this._extent, o = a[1] - a[0];
          if (isFinite(o)) {
            o < 0 && (o = -o, a.reverse());
            var s = dwt(a, e, i, r);
            this._intervalPrecision = s.intervalPrecision, this._interval = s.interval, this._niceExtent = s.niceTickExtent;
          }
        }, t.prototype.calcNiceExtent = function(e) {
          var i = this._extent;
          if (i[0] === i[1]) if (i[0] !== 0) {
            var r = Math.abs(i[0]);
            e.fixMax || (i[1] += r / 2), i[0] -= r / 2;
          } else i[1] = 1;
          var a = i[1] - i[0];
          isFinite(a) || (i[0] = 0, i[1] = 1), this.calcNiceTicks(e.splitNumber, e.minInterval, e.maxInterval);
          var o = this._interval;
          e.fixMin || (i[0] = Hh(Math.floor(i[0] / o) * o)), e.fixMax || (i[1] = Hh(Math.ceil(i[1] / o) * o));
        }, t.prototype.setNiceExtent = function(e, i) {
          this._niceExtent = [e, i];
        }, t.type = "interval", t;
      }(Go);
      Go.registerClass(Gs);
      var iU = typeof Float32Array != "undefined", pwt = iU ? Float32Array : Array;
      function Uo(n) {
        return X(n) ? iU ? new Float32Array(n) : n : new pwt(n);
      }
      var fT = "__ec_stack_";
      function gT(n) {
        return n.get("stack") || fT + n.seriesIndex;
      }
      function dT(n) {
        return n.dim + n.index;
      }
      function vwt(n) {
        var t = [], e = n.axis, i = "axis0";
        if (e.type === "category") {
          for (var r = e.getBandWidth(), a = 0; a < n.count; a++) t.push(Et({ bandWidth: r, axisKey: i, stackId: fT + a }, n));
          for (var o = oU(t), s = [], a = 0; a < n.count; a++) {
            var l = o[i][fT + a];
            l.offsetCenter = l.offset + l.width / 2, s.push(l);
          }
          return s;
        }
      }
      function rU(n, t) {
        var e = [];
        return t.eachSeriesByType(n, function(i) {
          uU(i) && e.push(i);
        }), e;
      }
      function ywt(n) {
        var t = {};
        M(n, function(l) {
          var u = l.coordinateSystem, h = u.getBaseAxis();
          if (!(h.type !== "time" && h.type !== "value")) for (var c = l.getData(), f = h.dim + "_" + h.index, g = c.getDimensionIndex(c.mapDimension(h.dim)), d = c.getStore(), A = 0, p = d.count(); A < p; ++A) {
            var v = d.get(g, A);
            t[f] ? t[f].push(v) : t[f] = [v];
          }
        });
        var e = {};
        for (var i in t) if (t.hasOwnProperty(i)) {
          var r = t[i];
          if (r) {
            r.sort(function(l, u) {
              return l - u;
            });
            for (var a = null, o = 1; o < r.length; ++o) {
              var s = r[o] - r[o - 1];
              s > 0 && (a = a === null ? s : Math.min(a, s));
            }
            e[i] = a;
          }
        }
        return e;
      }
      function aU(n) {
        var t = ywt(n), e = [];
        return M(n, function(i) {
          var r = i.coordinateSystem, a = r.getBaseAxis(), o = a.getExtent(), s;
          if (a.type === "category") s = a.getBandWidth();
          else if (a.type === "value" || a.type === "time") {
            var l = a.dim + "_" + a.index, u = t[l], h = Math.abs(o[1] - o[0]), c = a.scale.getExtent(), f = Math.abs(c[1] - c[0]);
            s = u ? h / f * u : h;
          } else {
            var g = i.getData();
            s = Math.abs(o[1] - o[0]) / g.count();
          }
          var d = ot(i.get("barWidth"), s), A = ot(i.get("barMaxWidth"), s), p = ot(i.get("barMinWidth") || (hU(i) ? 0.5 : 1), s), v = i.get("barGap"), y = i.get("barCategoryGap");
          e.push({ bandWidth: s, barWidth: d, barMaxWidth: A, barMinWidth: p, barGap: v, barCategoryGap: y, axisKey: dT(a), stackId: gT(i) });
        }), oU(e);
      }
      function oU(n) {
        var t = {};
        M(n, function(i, r) {
          var a = i.axisKey, o = i.bandWidth, s = t[a] || { bandWidth: o, remainedWidth: o, autoWidthCount: 0, categoryGap: null, gap: "20%", stacks: {} }, l = s.stacks;
          t[a] = s;
          var u = i.stackId;
          l[u] || s.autoWidthCount++, l[u] = l[u] || { width: 0, maxWidth: 0 };
          var h = i.barWidth;
          h && !l[u].width && (l[u].width = h, h = Math.min(s.remainedWidth, h), s.remainedWidth -= h);
          var c = i.barMaxWidth;
          c && (l[u].maxWidth = c);
          var f = i.barMinWidth;
          f && (l[u].minWidth = f);
          var g = i.barGap;
          g != null && (s.gap = g);
          var d = i.barCategoryGap;
          d != null && (s.categoryGap = d);
        });
        var e = {};
        return M(t, function(i, r) {
          e[r] = {};
          var a = i.stacks, o = i.bandWidth, s = i.categoryGap;
          if (s == null) {
            var l = re(a).length;
            s = Math.max(35 - l * 4, 15) + "%";
          }
          var u = ot(s, o), h = ot(i.gap, 1), c = i.remainedWidth, f = i.autoWidthCount, g = (c - u) / (f + (f - 1) * h);
          g = Math.max(g, 0), M(a, function(v) {
            var y = v.maxWidth, m = v.minWidth;
            if (v.width) {
              var _ = v.width;
              y && (_ = Math.min(_, y)), m && (_ = Math.max(_, m)), v.width = _, c -= _ + h * _, f--;
            } else {
              var _ = g;
              y && y < _ && (_ = Math.min(y, c)), m && m > _ && (_ = m), _ !== g && (v.width = _, c -= _ + h * _, f--);
            }
          }), g = (c - u) / (f + (f - 1) * h), g = Math.max(g, 0);
          var d = 0, A;
          M(a, function(v, y) {
            v.width || (v.width = g), A = v, d += v.width * (1 + h);
          }), A && (d -= A.width * h);
          var p = -d / 2;
          M(a, function(v, y) {
            e[r][y] = e[r][y] || { bandWidth: o, offset: p, width: v.width }, p += v.width * (1 + h);
          });
        }), e;
      }
      function mwt(n, t, e) {
        if (n && t) {
          var i = n[dT(t)];
          return i != null && e != null ? i[gT(e)] : i;
        }
      }
      function sU(n, t) {
        var e = rU(n, t), i = aU(e);
        M(e, function(r) {
          var a = r.getData(), o = r.coordinateSystem, s = o.getBaseAxis(), l = gT(r), u = i[dT(s)][l], h = u.offset, c = u.width;
          a.setLayout({ bandWidth: u.bandWidth, offset: h, size: c });
        });
      }
      function lU(n) {
        return { seriesType: n, plan: zg(), reset: function(t) {
          if (uU(t)) {
            var e = t.getData(), i = t.coordinateSystem, r = i.getBaseAxis(), a = i.getOtherAxis(r), o = e.getDimensionIndex(e.mapDimension(a.dim)), s = e.getDimensionIndex(e.mapDimension(r.dim)), l = t.get("showBackground", true), u = e.mapDimension(a.dim), h = e.getCalculationInfo("stackResultDimension"), c = lu(e, u) && !!e.getCalculationInfo("stackedOnSeries"), f = a.isHorizontal(), g = _wt(r, a), d = hU(t), A = t.get("barMinHeight") || 0, p = h && e.getDimensionIndex(h), v = e.getLayout("size"), y = e.getLayout("offset");
            return { progress: function(m, _) {
              for (var E = m.count, I = d && Uo(E * 3), x = d && l && Uo(E * 3), w = d && Uo(E), C = i.master.getRect(), S = f ? C.width : C.height, b, B = _.getStore(), T = 0; (b = m.next()) != null; ) {
                var D = B.get(c ? p : o, b), R = B.get(s, b), L = g, k = void 0;
                c && (k = +D - B.get(o, b));
                var P = void 0, F = void 0, Q = void 0, z = void 0;
                if (f) {
                  var j = i.dataToPoint([D, R]);
                  if (c) {
                    var $ = i.dataToPoint([k, R]);
                    L = $[0];
                  }
                  P = L, F = j[1] + y, Q = j[0] - L, z = v, Math.abs(Q) < A && (Q = (Q < 0 ? -1 : 1) * A);
                } else {
                  var j = i.dataToPoint([R, D]);
                  if (c) {
                    var $ = i.dataToPoint([R, k]);
                    L = $[1];
                  }
                  P = j[0] + y, F = L, Q = v, z = j[1] - L, Math.abs(z) < A && (z = (z <= 0 ? -1 : 1) * A);
                }
                d ? (I[T] = P, I[T + 1] = F, I[T + 2] = f ? Q : z, x && (x[T] = f ? C.x : P, x[T + 1] = f ? F : C.y, x[T + 2] = S), w[b] = b) : _.setItemLayout(b, { x: P, y: F, width: Q, height: z }), T += 3;
              }
              d && _.setLayout({ largePoints: I, largeDataIndices: w, largeBackgroundPoints: x, valueAxisHorizontal: f });
            } };
          }
        } };
      }
      function uU(n) {
        return n.coordinateSystem && n.coordinateSystem.type === "cartesian2d";
      }
      function hU(n) {
        return n.pipelineContext && n.pipelineContext.large;
      }
      function _wt(n, t) {
        var e = t.model.get("startValue");
        return e || (e = 0), t.toGlobalCoord(t.dataToCoord(t.type === "log" ? e > 0 ? e : 1 : e));
      }
      var Iwt = function(n, t, e, i) {
        for (; e < i; ) {
          var r = e + i >>> 1;
          n[r][1] < t ? e = r + 1 : i = r;
        }
        return e;
      }, AT = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "time", i;
        }
        return t.prototype.getLabel = function(e) {
          var i = this.getSetting("useUTC");
          return y1(e.value, v4[tIt(Dg(this._minLevelUnit))] || v4.second, i, this.getSetting("locale"));
        }, t.prototype.getFormattedLabel = function(e, i, r) {
          var a = this.getSetting("useUTC"), o = this.getSetting("locale");
          return eIt(e, i, r, o, a);
        }, t.prototype.getTicks = function() {
          var e = this._interval, i = this._extent, r = [];
          if (!e) return r;
          r.push({ value: i[0], level: 0 });
          var a = this.getSetting("useUTC"), o = Bwt(this._minLevelUnit, this._approxInterval, a, i);
          return r = r.concat(o), r.push({ value: i[1], level: 0 }), r;
        }, t.prototype.calcNiceExtent = function(e) {
          var i = this._extent;
          if (i[0] === i[1] && (i[0] -= ga, i[1] += ga), i[1] === -1 / 0 && i[0] === 1 / 0) {
            var r = /* @__PURE__ */ new Date();
            i[1] = +new Date(r.getFullYear(), r.getMonth(), r.getDate()), i[0] = i[1] - ga;
          }
          this.calcNiceTicks(e.splitNumber, e.minInterval, e.maxInterval);
        }, t.prototype.calcNiceTicks = function(e, i, r) {
          e = e || 10;
          var a = this._extent, o = a[1] - a[0];
          this._approxInterval = o / e, i != null && this._approxInterval < i && (this._approxInterval = i), r != null && this._approxInterval > r && (this._approxInterval = r);
          var s = eI.length, l = Math.min(Iwt(eI, this._approxInterval, 0, s), s - 1);
          this._interval = eI[l][1], this._minLevelUnit = eI[Math.max(l - 1, 0)][0];
        }, t.prototype.parse = function(e) {
          return pe(e) ? e : +Do(e);
        }, t.prototype.contain = function(e) {
          return K1(this.parse(e), this._extent);
        }, t.prototype.normalize = function(e) {
          return $1(this.parse(e), this._extent);
        }, t.prototype.scale = function(e) {
          return J1(e, this._extent);
        }, t.type = "time", t;
      }(Gs), eI = [["second", lB], ["minute", uB], ["hour", Wp], ["quarter-day", Wp * 6], ["half-day", Wp * 12], ["day", ga * 1.2], ["half-week", ga * 3.5], ["week", ga * 7], ["month", ga * 31], ["quarter", ga * 95], ["half-year", p4 / 2], ["year", p4]];
      function Ewt(n, t, e, i) {
        var r = Do(t), a = Do(e), o = function(d) {
          return _4(r, d, i) === _4(a, d, i);
        }, s = function() {
          return o("year");
        }, l = function() {
          return s() && o("month");
        }, u = function() {
          return l() && o("day");
        }, h = function() {
          return u() && o("hour");
        }, c = function() {
          return h() && o("minute");
        }, f = function() {
          return c() && o("second");
        }, g = function() {
          return f() && o("millisecond");
        };
        switch (n) {
          case "year":
            return s();
          case "month":
            return l();
          case "day":
            return u();
          case "hour":
            return h();
          case "minute":
            return c();
          case "second":
            return f();
          case "millisecond":
            return g();
        }
      }
      function xwt(n, t) {
        return n /= ga, n > 16 ? 16 : n > 7.5 ? 7 : n > 3.5 ? 4 : n > 1.5 ? 2 : 1;
      }
      function wwt(n) {
        var t = 30 * ga;
        return n /= t, n > 6 ? 6 : n > 3 ? 3 : n > 2 ? 2 : 1;
      }
      function Cwt(n) {
        return n /= Wp, n > 12 ? 12 : n > 6 ? 6 : n > 3.5 ? 4 : n > 2 ? 2 : 1;
      }
      function cU(n, t) {
        return n /= t ? uB : lB, n > 30 ? 30 : n > 20 ? 20 : n > 15 ? 15 : n > 10 ? 10 : n > 5 ? 5 : n > 2 ? 2 : 1;
      }
      function Swt(n) {
        return TG(n);
      }
      function bwt(n, t, e) {
        var i = new Date(n);
        switch (Dg(t)) {
          case "year":
          case "month":
            i[I4(e)](0);
          case "day":
            i[E4(e)](1);
          case "hour":
            i[x4(e)](0);
          case "minute":
            i[w4(e)](0);
          case "second":
            i[C4(e)](0), i[S4(e)](0);
        }
        return i.getTime();
      }
      function Bwt(n, t, e, i) {
        var r = 1e4, a = y4, o = 0;
        function s(S, b, B, T, D, R, L) {
          for (var k = new Date(b), P = b, F = k[T](); P < B && P <= i[1]; ) L.push({ value: P }), F += S, k[D](F), P = k.getTime();
          L.push({ value: P, notAdd: true });
        }
        function l(S, b, B) {
          var T = [], D = !b.length;
          if (!Ewt(Dg(S), i[0], i[1], e)) {
            D && (b = [{ value: bwt(new Date(i[0]), S, e) }, { value: i[1] }]);
            for (var R = 0; R < b.length - 1; R++) {
              var L = b[R].value, k = b[R + 1].value;
              if (L !== k) {
                var P = void 0, F = void 0, Q = void 0, z = false;
                switch (S) {
                  case "year":
                    P = Math.max(1, Math.round(t / ga / 365)), F = cB(e), Q = nIt(e);
                    break;
                  case "half-year":
                  case "quarter":
                  case "month":
                    P = wwt(t), F = Rg(e), Q = I4(e);
                    break;
                  case "week":
                  case "half-week":
                  case "day":
                    P = xwt(t), F = m1(e), Q = E4(e), z = true;
                    break;
                  case "half-day":
                  case "quarter-day":
                  case "hour":
                    P = Cwt(t), F = Zp(e), Q = x4(e);
                    break;
                  case "minute":
                    P = cU(t, true), F = _1(e), Q = w4(e);
                    break;
                  case "second":
                    P = cU(t, false), F = I1(e), Q = C4(e);
                    break;
                  case "millisecond":
                    P = Swt(t), F = E1(e), Q = S4(e);
                    break;
                }
                s(P, L, k, F, Q, z, T), S === "year" && B.length > 1 && R === 0 && B.unshift({ value: B[0].value - P });
              }
            }
            for (var R = 0; R < T.length; R++) B.push(T[R]);
            return T;
          }
        }
        for (var u = [], h = [], c = 0, f = 0, g = 0; g < a.length && o++ < r; ++g) {
          var d = Dg(a[g]);
          if (J1t(a[g])) {
            l(a[g], u[u.length - 1] || [], h);
            var A = a[g + 1] ? Dg(a[g + 1]) : null;
            if (d !== A) {
              if (h.length) {
                f = c, h.sort(function(S, b) {
                  return S.value - b.value;
                });
                for (var p = [], v = 0; v < h.length; ++v) {
                  var y = h[v].value;
                  (v === 0 || h[v - 1].value !== y) && (p.push(h[v]), y >= i[0] && y <= i[1] && c++);
                }
                var m = (i[1] - i[0]) / t;
                if (c > m * 1.5 && f > m / 1.5 || (u.push(p), c > m || n === a[g])) break;
              }
              h = [];
            }
          }
        }
        o >= r && un("Exceed safe limit.");
        for (var _ = Ne(Z(u, function(S) {
          return Ne(S, function(b) {
            return b.value >= i[0] && b.value <= i[1] && !b.notAdd;
          });
        }), function(S) {
          return S.length > 0;
        }), E = [], I = _.length - 1, g = 0; g < _.length; ++g) for (var x = _[g], w = 0; w < x.length; ++w) E.push({ value: x[w].value, level: I - g });
        E.sort(function(S, b) {
          return S.value - b.value;
        });
        for (var C = [], g = 0; g < E.length; ++g) (g === 0 || E[g].value !== E[g - 1].value) && C.push(E[g]);
        return C;
      }
      Go.registerClass(AT);
      var fU = Go.prototype, yv = Gs.prototype, Twt = vn, Mwt = Math.floor, Dwt = Math.ceil, nI = Math.pow, Ka = Math.log, pT = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "log", e.base = 10, e._originalScale = new Gs(), e._interval = 0, e;
        }
        return t.prototype.getTicks = function(e) {
          var i = this._originalScale, r = this._extent, a = i.getExtent(), o = yv.getTicks.call(this, e);
          return Z(o, function(s) {
            var l = s.value, u = vn(nI(this.base, l));
            return u = l === r[0] && this._fixMin ? iI(u, a[0]) : u, u = l === r[1] && this._fixMax ? iI(u, a[1]) : u, { value: u };
          }, this);
        }, t.prototype.setExtent = function(e, i) {
          var r = Ka(this.base);
          e = Ka(Math.max(0, e)) / r, i = Ka(Math.max(0, i)) / r, yv.setExtent.call(this, e, i);
        }, t.prototype.getExtent = function() {
          var e = this.base, i = fU.getExtent.call(this);
          i[0] = nI(e, i[0]), i[1] = nI(e, i[1]);
          var r = this._originalScale, a = r.getExtent();
          return this._fixMin && (i[0] = iI(i[0], a[0])), this._fixMax && (i[1] = iI(i[1], a[1])), i;
        }, t.prototype.unionExtent = function(e) {
          this._originalScale.unionExtent(e);
          var i = this.base;
          e[0] = Ka(e[0]) / Ka(i), e[1] = Ka(e[1]) / Ka(i), fU.unionExtent.call(this, e);
        }, t.prototype.unionExtentFromData = function(e, i) {
          this.unionExtent(e.getApproximateExtent(i));
        }, t.prototype.calcNiceTicks = function(e) {
          e = e || 10;
          var i = this._extent, r = i[1] - i[0];
          if (!(r === 1 / 0 || r <= 0)) {
            var a = Dmt(r), o = e / r * a;
            for (o <= 0.5 && (a *= 10); !isNaN(a) && Math.abs(a) < 1 && Math.abs(a) > 0; ) a *= 10;
            var s = [vn(Dwt(i[0] / a) * a), vn(Mwt(i[1] / a) * a)];
            this._interval = a, this._niceExtent = s;
          }
        }, t.prototype.calcNiceExtent = function(e) {
          yv.calcNiceExtent.call(this, e), this._fixMin = e.fixMin, this._fixMax = e.fixMax;
        }, t.prototype.parse = function(e) {
          return e;
        }, t.prototype.contain = function(e) {
          return e = Ka(e) / Ka(this.base), K1(e, this._extent);
        }, t.prototype.normalize = function(e) {
          return e = Ka(e) / Ka(this.base), $1(e, this._extent);
        }, t.prototype.scale = function(e) {
          return e = J1(e, this._extent), nI(this.base, e);
        }, t.type = "log", t;
      }(Go), gU = pT.prototype;
      gU.getMinorTicks = yv.getMinorTicks, gU.getLabel = yv.getLabel;
      function iI(n, t) {
        return Twt(n, Mo(t));
      }
      Go.registerClass(pT);
      var Rwt = function() {
        function n(t, e, i) {
          this._prepareParams(t, e, i);
        }
        return n.prototype._prepareParams = function(t, e, i) {
          i[1] < i[0] && (i = [NaN, NaN]), this._dataMin = i[0], this._dataMax = i[1];
          var r = this._isOrdinal = t.type === "ordinal";
          this._needCrossZero = t.type === "interval" && e.getNeedCrossZero && e.getNeedCrossZero();
          var a = e.get("min", true);
          a == null && (a = e.get("startValue", true));
          var o = this._modelMinRaw = a;
          yt(o) ? this._modelMinNum = rI(t, o({ min: i[0], max: i[1] })) : o !== "dataMin" && (this._modelMinNum = rI(t, o));
          var s = this._modelMaxRaw = e.get("max", true);
          if (yt(s) ? this._modelMaxNum = rI(t, s({ min: i[0], max: i[1] })) : s !== "dataMax" && (this._modelMaxNum = rI(t, s)), r) this._axisDataLen = e.getCategories().length;
          else {
            var l = e.get("boundaryGap"), u = X(l) ? l : [l || 0, l || 0];
            typeof u[0] == "boolean" || typeof u[1] == "boolean" ? ("development", this._boundaryGapInner = [0, 0]) : this._boundaryGapInner = [ja(u[0], 1), ja(u[1], 1)];
          }
        }, n.prototype.calculate = function() {
          var t = this._isOrdinal, e = this._dataMin, i = this._dataMax, r = this._axisDataLen, a = this._boundaryGapInner, o = t ? null : i - e || Math.abs(e), s = this._modelMinRaw === "dataMin" ? e : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? i : this._modelMaxNum, u = s != null, h = l != null;
          s == null && (s = t ? r ? 0 : NaN : e - a[0] * o), l == null && (l = t ? r ? r - 1 : NaN : i + a[1] * o), (s == null || !isFinite(s)) && (s = NaN), (l == null || !isFinite(l)) && (l = NaN);
          var c = nh(s) || nh(l) || t && !r;
          this._needCrossZero && (s > 0 && l > 0 && !u && (s = 0), s < 0 && l < 0 && !h && (l = 0));
          var f = this._determinedMin, g = this._determinedMax;
          return f != null && (s = f, u = true), g != null && (l = g, h = true), { min: s, max: l, minFixed: u, maxFixed: h, isBlank: c };
        }, n.prototype.modifyDataMinMax = function(t, e) {
          It(!this.frozen), this[Pwt[t]] = e;
        }, n.prototype.setDeterminedMinMax = function(t, e) {
          var i = Lwt[t];
          It(!this.frozen && this[i] == null), this[i] = e;
        }, n.prototype.freeze = function() {
          this.frozen = true;
        }, n;
      }(), Lwt = { min: "_determinedMin", max: "_determinedMax" }, Pwt = { min: "_dataMin", max: "_dataMax" };
      function dU(n, t, e) {
        var i = n.rawExtentInfo;
        return i || (i = new Rwt(n, t, e), n.rawExtentInfo = i, i);
      }
      function rI(n, t) {
        return t == null ? null : nh(t) ? NaN : n.parse(t);
      }
      function AU(n, t) {
        var e = n.type, i = dU(n, t, n.getExtent()).calculate();
        n.setBlank(i.isBlank);
        var r = i.min, a = i.max, o = t.ecModel;
        if (o && e === "time") {
          var s = rU("bar", o), l = false;
          if (M(s, function(c) {
            l = l || c.getBaseAxis() === t.axis;
          }), l) {
            var u = aU(s), h = Nwt(r, a, t, u);
            r = h.min, a = h.max;
          }
        }
        return { extent: [r, a], fixMin: i.minFixed, fixMax: i.maxFixed };
      }
      function Nwt(n, t, e, i) {
        var r = e.axis.getExtent(), a = r[1] - r[0], o = mwt(i, e.axis);
        if (o === void 0) return { min: n, max: t };
        var s = 1 / 0;
        M(o, function(g) {
          s = Math.min(g.offset, s);
        });
        var l = -1 / 0;
        M(o, function(g) {
          l = Math.max(g.offset + g.width, l);
        }), s = Math.abs(s), l = Math.abs(l);
        var u = s + l, h = t - n, c = 1 - (s + l) / a, f = h / c - h;
        return t += f * (l / u), n -= f * (s / u), { min: n, max: t };
      }
      function Xg(n, t) {
        var e = t, i = AU(n, e), r = i.extent, a = e.get("splitNumber");
        n instanceof pT && (n.base = e.get("logBase"));
        var o = n.type, s = e.get("interval"), l = o === "interval" || o === "time";
        n.setExtent(r[0], r[1]), n.calcNiceExtent({ splitNumber: a, fixMin: i.fixMin, fixMax: i.fixMax, minInterval: l ? e.get("minInterval") : null, maxInterval: l ? e.get("maxInterval") : null }), s != null && n.setInterval && n.setInterval(s);
      }
      function aI(n, t) {
        if (t = t || n.get("type"), t) switch (t) {
          case "category":
            return new tI({ ordinalMeta: n.getOrdinalMeta ? n.getOrdinalMeta() : n.getCategories(), extent: [1 / 0, -1 / 0] });
          case "time":
            return new AT({ locale: n.ecModel.getLocaleModel(), useUTC: n.ecModel.get("useUTC") });
          default:
            return new (Go.getClass(t) || Gs)();
        }
      }
      function kwt(n) {
        var t = n.scale.getExtent(), e = t[0], i = t[1];
        return !(e > 0 && i > 0 || e < 0 && i < 0);
      }
      function Zg(n) {
        var t = n.getLabelModel().get("formatter"), e = n.type === "category" ? n.scale.getExtent()[0] : null;
        return n.scale.type === "time" ? /* @__PURE__ */ function(i) {
          return function(r, a) {
            return n.scale.getFormattedLabel(r, a, i);
          };
        }(t) : ht(t) ? /* @__PURE__ */ function(i) {
          return function(r) {
            var a = n.scale.getLabel(r), o = i.replace("{value}", a != null ? a : "");
            return o;
          };
        }(t) : yt(t) ? /* @__PURE__ */ function(i) {
          return function(r, a) {
            return e != null && (a = r.value - e), i(vT(n, r), a, r.level != null ? { level: r.level } : null);
          };
        }(t) : function(i) {
          return n.scale.getLabel(i);
        };
      }
      function vT(n, t) {
        return n.type === "category" ? n.scale.getLabel(t) : t.value;
      }
      function Fwt(n) {
        var t = n.model, e = n.scale;
        if (!(!t.get(["axisLabel", "show"]) || e.isBlank())) {
          var i, r, a = e.getExtent();
          e instanceof tI ? r = e.count() : (i = e.getTicks(), r = i.length);
          var o = n.getLabelModel(), s = Zg(n), l, u = 1;
          r > 40 && (u = Math.ceil(r / 40));
          for (var h = 0; h < r; h += u) {
            var c = i ? i[h] : { value: a[0] + h }, f = s(c, h), g = o.getTextRect(f), d = Qwt(g, o.get("rotate") || 0);
            l ? l.union(d) : l = d;
          }
          return l;
        }
      }
      function Qwt(n, t) {
        var e = t * Math.PI / 180, i = n.width, r = n.height, a = i * Math.abs(Math.cos(e)) + Math.abs(r * Math.sin(e)), o = i * Math.abs(Math.sin(e)) + Math.abs(r * Math.cos(e)), s = new Ht(n.x, n.y, a, o);
        return s;
      }
      function yT(n) {
        var t = n.get("interval");
        return t == null ? "auto" : t;
      }
      function pU(n) {
        return n.type === "category" && yT(n.getLabelModel()) === 0;
      }
      function oI(n, t) {
        var e = {};
        return M(n.mapDimensionsAll(t), function(i) {
          e[tU(n, i)] = true;
        }), re(e);
      }
      function Owt(n, t, e) {
        t && M(oI(t, e), function(i) {
          var r = t.getApproximateExtent(i);
          r[0] < n[0] && (n[0] = r[0]), r[1] > n[1] && (n[1] = r[1]);
        });
      }
      var mv = function() {
        function n() {
        }
        return n.prototype.getNeedCrossZero = function() {
          var t = this.option;
          return !t.scale;
        }, n.prototype.getCoordSysModel = function() {
        }, n;
      }(), zwt = 1e-8;
      function vU(n, t) {
        return Math.abs(n - t) < zwt;
      }
      function Yh(n, t, e) {
        var i = 0, r = n[0];
        if (!r) return false;
        for (var a = 1; a < n.length; a++) {
          var o = n[a];
          i += Rs(r[0], r[1], o[0], o[1], t, e), r = o;
        }
        var s = n[0];
        return (!vU(r[0], s[0]) || !vU(r[1], s[1])) && (i += Rs(r[0], r[1], s[0], s[1], t, e)), i !== 0;
      }
      var Gwt = [];
      function mT(n, t) {
        for (var e = 0; e < n.length; e++) di(n[e], n[e], t);
      }
      function yU(n, t, e, i) {
        for (var r = 0; r < n.length; r++) {
          var a = n[r];
          i && (a = i.project(a)), a && isFinite(a[0]) && isFinite(a[1]) && (Gl(t, t, a), Ul(e, e, a));
        }
      }
      function Uwt(n) {
        for (var t = 0, e = 0, i = 0, r = n.length, a = n[r - 1][0], o = n[r - 1][1], s = 0; s < r; s++) {
          var l = n[s][0], u = n[s][1], h = a * u - l * o;
          t += h, e += (a + l) * h, i += (o + u) * h, a = l, o = u;
        }
        return t ? [e / t / 3, i / t / 3, t] : [n[0][0] || 0, n[0][1] || 0];
      }
      var mU = function() {
        function n(t) {
          this.name = t;
        }
        return n.prototype.setCenter = function(t) {
          this._center = t;
        }, n.prototype.getCenter = function() {
          var t = this._center;
          return t || (t = this._center = this.calcCenter()), t;
        }, n;
      }(), _U = /* @__PURE__ */ function() {
        function n(t, e) {
          this.type = "polygon", this.exterior = t, this.interiors = e;
        }
        return n;
      }(), IU = /* @__PURE__ */ function() {
        function n(t) {
          this.type = "linestring", this.points = t;
        }
        return n;
      }(), EU = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this, e) || this;
          return a.type = "geoJSON", a.geometries = i, a._center = r && [r[0], r[1]], a;
        }
        return t.prototype.calcCenter = function() {
          for (var e = this.geometries, i, r = 0, a = 0; a < e.length; a++) {
            var o = e[a], s = o.exterior, l = s && s.length;
            l > r && (i = o, r = l);
          }
          if (i) return Uwt(i.exterior);
          var u = this.getBoundingRect();
          return [u.x + u.width / 2, u.y + u.height / 2];
        }, t.prototype.getBoundingRect = function(e) {
          var i = this._rect;
          if (i && !e) return i;
          var r = [1 / 0, 1 / 0], a = [-1 / 0, -1 / 0], o = this.geometries;
          return M(o, function(s) {
            s.type === "polygon" ? yU(s.exterior, r, a, e) : M(s.points, function(l) {
              yU(l, r, a, e);
            });
          }), isFinite(r[0]) && isFinite(r[1]) && isFinite(a[0]) && isFinite(a[1]) || (r[0] = r[1] = a[0] = a[1] = 0), i = new Ht(r[0], r[1], a[0] - r[0], a[1] - r[1]), e || (this._rect = i), i;
        }, t.prototype.contain = function(e) {
          var i = this.getBoundingRect(), r = this.geometries;
          if (!i.contain(e[0], e[1])) return false;
          t: for (var a = 0, o = r.length; a < o; a++) {
            var s = r[a];
            if (s.type === "polygon") {
              var l = s.exterior, u = s.interiors;
              if (Yh(l, e[0], e[1])) {
                for (var h = 0; h < (u ? u.length : 0); h++) if (Yh(u[h], e[0], e[1])) continue t;
                return true;
              }
            }
          }
          return false;
        }, t.prototype.transformTo = function(e, i, r, a) {
          var o = this.getBoundingRect(), s = o.width / o.height;
          r ? a || (a = r / s) : r = s * a;
          for (var l = new Ht(e, i, r, a), u = o.calculateTransform(l), h = this.geometries, c = 0; c < h.length; c++) {
            var f = h[c];
            f.type === "polygon" ? (mT(f.exterior, u), M(f.interiors, function(g) {
              mT(g, u);
            })) : M(f.points, function(g) {
              mT(g, u);
            });
          }
          o = this._rect, o.copy(l), this._center = [o.x + o.width / 2, o.y + o.height / 2];
        }, t.prototype.cloneShallow = function(e) {
          e == null && (e = this.name);
          var i = new t(e, this.geometries, this._center);
          return i._rect = this._rect, i.transformTo = null, i;
        }, t;
      }(mU), Vwt = function(n) {
        V(t, n);
        function t(e, i) {
          var r = n.call(this, e) || this;
          return r.type = "geoSVG", r._elOnlyForCalculate = i, r;
        }
        return t.prototype.calcCenter = function() {
          for (var e = this._elOnlyForCalculate, i = e.getBoundingRect(), r = [i.x + i.width / 2, i.y + i.height / 2], a = d_(Gwt), o = e; o && !o.isGeoSVGGraphicRoot; ) Ss(a, o.getLocalTransform(), a), o = o.parent;
          return lg(a, a), di(r, r, a), r;
        }, t;
      }(mU);
      function jwt(n) {
        if (!n.UTF8Encoding) return n;
        var t = n, e = t.UTF8Scale;
        e == null && (e = 1024);
        var i = t.features;
        return M(i, function(r) {
          var a = r.geometry, o = a.encodeOffsets, s = a.coordinates;
          if (o) switch (a.type) {
            case "LineString":
              a.coordinates = xU(s, o, e);
              break;
            case "Polygon":
              _T(s, o, e);
              break;
            case "MultiLineString":
              _T(s, o, e);
              break;
            case "MultiPolygon":
              M(s, function(l, u) {
                return _T(l, o[u], e);
              });
          }
        }), t.UTF8Encoding = false, t;
      }
      function _T(n, t, e) {
        for (var i = 0; i < n.length; i++) n[i] = xU(n[i], t[i], e);
      }
      function xU(n, t, e) {
        for (var i = [], r = t[0], a = t[1], o = 0; o < n.length; o += 2) {
          var s = n.charCodeAt(o) - 64, l = n.charCodeAt(o + 1) - 64;
          s = s >> 1 ^ -(s & 1), l = l >> 1 ^ -(l & 1), s += r, l += a, r = s, a = l, i.push([s / e, l / e]);
        }
        return i;
      }
      function qwt(n, t) {
        return n = jwt(n), Z(Ne(n.features, function(e) {
          return e.geometry && e.properties && e.geometry.coordinates.length > 0;
        }), function(e) {
          var i = e.properties, r = e.geometry, a = [];
          switch (r.type) {
            case "Polygon":
              var o = r.coordinates;
              a.push(new _U(o[0], o.slice(1)));
              break;
            case "MultiPolygon":
              M(r.coordinates, function(l) {
                l[0] && a.push(new _U(l[0], l.slice(1)));
              });
              break;
            case "LineString":
              a.push(new IU([r.coordinates]));
              break;
            case "MultiLineString":
              a.push(new IU(r.coordinates));
          }
          var s = new EU(i[t || "name"], a, i.cp);
          return s.properties = i, s;
        });
      }
      var _v = le();
      function wU(n, t) {
        var e = Z(t, function(i) {
          return n.scale.parse(i);
        });
        return n.type === "time" && e.length > 0 && (e.sort(), e.unshift(e[0]), e.push(e[e.length - 1])), e;
      }
      function Hwt(n) {
        var t = n.getLabelModel().get("customValues");
        if (t) {
          var e = Zg(n);
          return { labels: wU(n, t).map(function(i) {
            var r = { value: i };
            return { formattedLabel: e(r), rawLabel: n.scale.getLabel(r), tickValue: i };
          }) };
        }
        return n.type === "category" ? Wwt(n) : Zwt(n);
      }
      function Ywt(n, t) {
        var e = n.getTickModel().get("customValues");
        return e ? { ticks: wU(n, e) } : n.type === "category" ? Xwt(n, t) : { ticks: Z(n.scale.getTicks(), function(i) {
          return i.value;
        }) };
      }
      function Wwt(n) {
        var t = n.getLabelModel(), e = CU(n, t);
        return !t.get("show") || n.scale.isBlank() ? { labels: [], labelCategoryInterval: e.labelCategoryInterval } : e;
      }
      function CU(n, t) {
        var e = SU(n, "labels"), i = yT(t), r = bU(e, i);
        if (r) return r;
        var a, o;
        return yt(i) ? a = MU(n, i) : (o = i === "auto" ? Kwt(n) : i, a = TU(n, o)), BU(e, i, { labels: a, labelCategoryInterval: o });
      }
      function Xwt(n, t) {
        var e = SU(n, "ticks"), i = yT(t), r = bU(e, i);
        if (r) return r;
        var a, o;
        if ((!t.get("show") || n.scale.isBlank()) && (a = []), yt(i)) a = MU(n, i, true);
        else if (i === "auto") {
          var s = CU(n, n.getLabelModel());
          o = s.labelCategoryInterval, a = Z(s.labels, function(l) {
            return l.tickValue;
          });
        } else o = i, a = TU(n, o, true);
        return BU(e, i, { ticks: a, tickCategoryInterval: o });
      }
      function Zwt(n) {
        var t = n.scale.getTicks(), e = Zg(n);
        return { labels: Z(t, function(i, r) {
          return { level: i.level, formattedLabel: e(i, r), rawLabel: n.scale.getLabel(i), tickValue: i.value };
        }) };
      }
      function SU(n, t) {
        return _v(n)[t] || (_v(n)[t] = []);
      }
      function bU(n, t) {
        for (var e = 0; e < n.length; e++) if (n[e].key === t) return n[e].value;
      }
      function BU(n, t, e) {
        return n.push({ key: t, value: e }), e;
      }
      function Kwt(n) {
        var t = _v(n).autoInterval;
        return t != null ? t : _v(n).autoInterval = n.calculateCategoryInterval();
      }
      function $wt(n) {
        var t = Jwt(n), e = Zg(n), i = (t.axisRotate - t.labelRotate) / 180 * Math.PI, r = n.scale, a = r.getExtent(), o = r.count();
        if (a[1] - a[0] < 1) return 0;
        var s = 1;
        o > 40 && (s = Math.max(1, Math.floor(o / 40)));
        for (var l = a[0], u = n.dataToCoord(l + 1) - n.dataToCoord(l), h = Math.abs(u * Math.cos(i)), c = Math.abs(u * Math.sin(i)), f = 0, g = 0; l <= a[1]; l += s) {
          var d = 0, A = 0, p = Cp(e({ value: l }), t.font, "center", "top");
          d = p.width * 1.3, A = p.height * 1.3, f = Math.max(f, d, 7), g = Math.max(g, A, 7);
        }
        var v = f / h, y = g / c;
        isNaN(v) && (v = 1 / 0), isNaN(y) && (y = 1 / 0);
        var m = Math.max(0, Math.floor(Math.min(v, y))), _ = _v(n.model), E = n.getExtent(), I = _.lastAutoInterval, x = _.lastTickCount;
        return I != null && x != null && Math.abs(I - m) <= 1 && Math.abs(x - o) <= 1 && I > m && _.axisExtent0 === E[0] && _.axisExtent1 === E[1] ? m = I : (_.lastTickCount = o, _.lastAutoInterval = m, _.axisExtent0 = E[0], _.axisExtent1 = E[1]), m;
      }
      function Jwt(n) {
        var t = n.getLabelModel();
        return { axisRotate: n.getRotate ? n.getRotate() : n.isHorizontal && !n.isHorizontal() ? 90 : 0, labelRotate: t.get("rotate") || 0, font: t.getFont() };
      }
      function TU(n, t, e) {
        var i = Zg(n), r = n.scale, a = r.getExtent(), o = n.getLabelModel(), s = [], l = Math.max((t || 0) + 1, 1), u = a[0], h = r.count();
        u !== 0 && l > 1 && h / l > 2 && (u = Math.round(Math.ceil(u / l) * l));
        var c = pU(n), f = o.get("showMinLabel") || c, g = o.get("showMaxLabel") || c;
        f && u !== a[0] && A(a[0]);
        for (var d = u; d <= a[1]; d += l) A(d);
        g && d - l !== a[1] && A(a[1]);
        function A(p) {
          var v = { value: p };
          s.push(e ? p : { formattedLabel: i(v), rawLabel: r.getLabel(v), tickValue: p });
        }
        return s;
      }
      function MU(n, t, e) {
        var i = n.scale, r = Zg(n), a = [];
        return M(i.getTicks(), function(o) {
          var s = i.getLabel(o), l = o.value;
          t(o.value, s) && a.push(e ? l : { formattedLabel: r(o), rawLabel: s, tickValue: l });
        }), a;
      }
      var DU = [0, 1], $a = function() {
        function n(t, e, i) {
          this.onBand = false, this.inverse = false, this.dim = t, this.scale = e, this._extent = i || [0, 0];
        }
        return n.prototype.contain = function(t) {
          var e = this._extent, i = Math.min(e[0], e[1]), r = Math.max(e[0], e[1]);
          return t >= i && t <= r;
        }, n.prototype.containData = function(t) {
          return this.scale.contain(t);
        }, n.prototype.getExtent = function() {
          return this._extent.slice();
        }, n.prototype.getPixelPrecision = function(t) {
          return SG(t || this.scale.getExtent(), this._extent);
        }, n.prototype.setExtent = function(t, e) {
          var i = this._extent;
          i[0] = t, i[1] = e;
        }, n.prototype.dataToCoord = function(t, e) {
          var i = this._extent, r = this.scale;
          return t = r.normalize(t), this.onBand && r.type === "ordinal" && (i = i.slice(), RU(i, r.count())), Le(t, DU, i, e);
        }, n.prototype.coordToData = function(t, e) {
          var i = this._extent, r = this.scale;
          this.onBand && r.type === "ordinal" && (i = i.slice(), RU(i, r.count()));
          var a = Le(t, i, DU, e);
          return this.scale.scale(a);
        }, n.prototype.pointToData = function(t, e) {
        }, n.prototype.getTicksCoords = function(t) {
          t = t || {};
          var e = t.tickModel || this.getTickModel(), i = Ywt(this, e), r = i.ticks, a = Z(r, function(s) {
            return { coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(s) : s), tickValue: s };
          }, this), o = e.get("alignWithLabel");
          return tCt(this, a, o, t.clamp), a;
        }, n.prototype.getMinorTicksCoords = function() {
          if (this.scale.type === "ordinal") return [];
          var t = this.model.getModel("minorTick"), e = t.get("splitNumber");
          e > 0 && e < 100 || (e = 5);
          var i = this.scale.getMinorTicks(e), r = Z(i, function(a) {
            return Z(a, function(o) {
              return { coord: this.dataToCoord(o), tickValue: o };
            }, this);
          }, this);
          return r;
        }, n.prototype.getViewLabels = function() {
          return Hwt(this).labels;
        }, n.prototype.getLabelModel = function() {
          return this.model.getModel("axisLabel");
        }, n.prototype.getTickModel = function() {
          return this.model.getModel("axisTick");
        }, n.prototype.getBandWidth = function() {
          var t = this._extent, e = this.scale.getExtent(), i = e[1] - e[0] + (this.onBand ? 1 : 0);
          i === 0 && (i = 1);
          var r = Math.abs(t[1] - t[0]);
          return Math.abs(r) / i;
        }, n.prototype.calculateCategoryInterval = function() {
          return $wt(this);
        }, n;
      }();
      function RU(n, t) {
        var e = n[1] - n[0], i = t, r = e / i / 2;
        n[0] += r, n[1] -= r;
      }
      function tCt(n, t, e, i) {
        var r = t.length;
        if (!n.onBand || e || !r) return;
        var a = n.getExtent(), o, s;
        if (r === 1) t[0].coord = a[0], o = t[1] = { coord: a[1] };
        else {
          var l = t[r - 1].tickValue - t[0].tickValue, u = (t[r - 1].coord - t[0].coord) / l;
          M(t, function(g) {
            g.coord -= u / 2;
          });
          var h = n.scale.getExtent();
          s = 1 + h[1] - t[r - 1].tickValue, o = { coord: t[r - 1].coord + u * s }, t.push(o);
        }
        var c = a[0] > a[1];
        f(t[0].coord, a[0]) && (i ? t[0].coord = a[0] : t.shift()), i && f(a[0], t[0].coord) && t.unshift({ coord: a[0] }), f(a[1], o.coord) && (i ? o.coord = a[1] : t.pop()), i && f(o.coord, a[1]) && t.push({ coord: a[1] });
        function f(g, d) {
          return g = vn(g), d = vn(d), c ? g > d : g < d;
        }
      }
      var Iv = Math.PI * 2, Wh = ko.CMD, eCt = ["top", "right", "bottom", "left"];
      function nCt(n, t, e, i, r) {
        var a = e.width, o = e.height;
        switch (n) {
          case "top":
            i.set(e.x + a / 2, e.y - t), r.set(0, -1);
            break;
          case "bottom":
            i.set(e.x + a / 2, e.y + o + t), r.set(0, 1);
            break;
          case "left":
            i.set(e.x - t, e.y + o / 2), r.set(-1, 0);
            break;
          case "right":
            i.set(e.x + a + t, e.y + o / 2), r.set(1, 0);
            break;
        }
      }
      function iCt(n, t, e, i, r, a, o, s, l) {
        o -= n, s -= t;
        var u = Math.sqrt(o * o + s * s);
        o /= u, s /= u;
        var h = o * e + n, c = s * e + t;
        if (Math.abs(i - r) % Iv < 1e-4) return l[0] = h, l[1] = c, u - e;
        if (a) {
          var f = i;
          i = Gr(r), r = Gr(f);
        } else i = Gr(i), r = Gr(r);
        i > r && (r += Iv);
        var g = Math.atan2(s, o);
        if (g < 0 && (g += Iv), g >= i && g <= r || g + Iv >= i && g + Iv <= r) return l[0] = h, l[1] = c, u - e;
        var d = e * Math.cos(i) + n, A = e * Math.sin(i) + t, p = e * Math.cos(r) + n, v = e * Math.sin(r) + t, y = (d - o) * (d - o) + (A - s) * (A - s), m = (p - o) * (p - o) + (v - s) * (v - s);
        return y < m ? (l[0] = d, l[1] = A, Math.sqrt(y)) : (l[0] = p, l[1] = v, Math.sqrt(m));
      }
      function sI(n, t, e, i, r, a, o, s) {
        var l = r - n, u = a - t, h = e - n, c = i - t, f = Math.sqrt(h * h + c * c);
        h /= f, c /= f;
        var g = l * h + u * c, d = g / f;
        s && (d = Math.min(Math.max(d, 0), 1)), d *= f;
        var A = o[0] = n + d * h, p = o[1] = t + d * c;
        return Math.sqrt((A - r) * (A - r) + (p - a) * (p - a));
      }
      function LU(n, t, e, i, r, a, o) {
        e < 0 && (n = n + e, e = -e), i < 0 && (t = t + i, i = -i);
        var s = n + e, l = t + i, u = o[0] = Math.min(Math.max(r, n), s), h = o[1] = Math.min(Math.max(a, t), l);
        return Math.sqrt((u - r) * (u - r) + (h - a) * (h - a));
      }
      var Ja = [];
      function rCt(n, t, e) {
        var i = LU(t.x, t.y, t.width, t.height, n.x, n.y, Ja);
        return e.set(Ja[0], Ja[1]), i;
      }
      function aCt(n, t, e) {
        for (var i = 0, r = 0, a = 0, o = 0, s, l, u = 1 / 0, h = t.data, c = n.x, f = n.y, g = 0; g < h.length; ) {
          var d = h[g++];
          g === 1 && (i = h[g], r = h[g + 1], a = i, o = r);
          var A = u;
          switch (d) {
            case Wh.M:
              a = h[g++], o = h[g++], i = a, r = o;
              break;
            case Wh.L:
              A = sI(i, r, h[g], h[g + 1], c, f, Ja, true), i = h[g++], r = h[g++];
              break;
            case Wh.C:
              A = Yz(i, r, h[g++], h[g++], h[g++], h[g++], h[g], h[g + 1], c, f, Ja), i = h[g++], r = h[g++];
              break;
            case Wh.Q:
              A = Xz(i, r, h[g++], h[g++], h[g], h[g + 1], c, f, Ja), i = h[g++], r = h[g++];
              break;
            case Wh.A:
              var p = h[g++], v = h[g++], y = h[g++], m = h[g++], _ = h[g++], E = h[g++];
              g += 1;
              var I = !!(1 - h[g++]);
              s = Math.cos(_) * y + p, l = Math.sin(_) * m + v, g <= 1 && (a = s, o = l);
              var x = (c - p) * m / y + p;
              A = iCt(p, v, m, _, _ + E, I, x, f, Ja), i = Math.cos(_ + E) * y + p, r = Math.sin(_ + E) * m + v;
              break;
            case Wh.R:
              a = i = h[g++], o = r = h[g++];
              var w = h[g++], C = h[g++];
              A = LU(a, o, w, C, c, f, Ja);
              break;
            case Wh.Z:
              A = sI(i, r, a, o, c, f, Ja, true), i = a, r = o;
              break;
          }
          A < u && (u = A, e.set(Ja[0], Ja[1]));
        }
        return u;
      }
      var to = new Ut(), Je = new Ut(), En = new Ut(), Vo = new Ut(), jo = new Ut();
      function PU(n, t) {
        if (n) {
          var e = n.getTextGuideLine(), i = n.getTextContent();
          if (i && e) {
            var r = n.textGuideLineConfig || {}, a = [[0, 0], [0, 0], [0, 0]], o = r.candidates || eCt, s = i.getBoundingRect().clone();
            s.applyTransform(i.getComputedTransform());
            var l = 1 / 0, u = r.anchor, h = n.getComputedTransform(), c = h && lg([], h), f = t.get("length2") || 0;
            u && En.copy(u);
            for (var g = 0; g < o.length; g++) {
              var d = o[g];
              nCt(d, 0, s, to, Vo), Ut.scaleAndAdd(Je, to, Vo, f), Je.transform(c);
              var A = n.getBoundingRect(), p = u ? u.distance(Je) : n instanceof Jt ? aCt(Je, n.path, En) : rCt(Je, A, En);
              p < l && (l = p, Je.transform(h), En.transform(h), En.toArray(a[0]), Je.toArray(a[1]), to.toArray(a[2]));
            }
            NU(a, t.get("minTurnAngle")), e.setShape({ points: a });
          }
        }
      }
      var lI = [], Ki = new Ut();
      function NU(n, t) {
        if (t <= 180 && t > 0) {
          t = t / 180 * Math.PI, to.fromArray(n[0]), Je.fromArray(n[1]), En.fromArray(n[2]), Ut.sub(Vo, to, Je), Ut.sub(jo, En, Je);
          var e = Vo.len(), i = jo.len();
          if (!(e < 1e-3 || i < 1e-3)) {
            Vo.scale(1 / e), jo.scale(1 / i);
            var r = Vo.dot(jo), a = Math.cos(t);
            if (a < r) {
              var o = sI(Je.x, Je.y, En.x, En.y, to.x, to.y, lI, false);
              Ki.fromArray(lI), Ki.scaleAndAdd(jo, o / Math.tan(Math.PI - t));
              var s = En.x !== Je.x ? (Ki.x - Je.x) / (En.x - Je.x) : (Ki.y - Je.y) / (En.y - Je.y);
              if (isNaN(s)) return;
              s < 0 ? Ut.copy(Ki, Je) : s > 1 && Ut.copy(Ki, En), Ki.toArray(n[1]);
            }
          }
        }
      }
      function oCt(n, t, e) {
        if (e <= 180 && e > 0) {
          e = e / 180 * Math.PI, to.fromArray(n[0]), Je.fromArray(n[1]), En.fromArray(n[2]), Ut.sub(Vo, Je, to), Ut.sub(jo, En, Je);
          var i = Vo.len(), r = jo.len();
          if (!(i < 1e-3 || r < 1e-3)) {
            Vo.scale(1 / i), jo.scale(1 / r);
            var a = Vo.dot(t), o = Math.cos(e);
            if (a < o) {
              var s = sI(Je.x, Je.y, En.x, En.y, to.x, to.y, lI, false);
              Ki.fromArray(lI);
              var l = Math.PI / 2, u = Math.acos(jo.dot(t)), h = l + u - e;
              if (h >= l) Ut.copy(Ki, En);
              else {
                Ki.scaleAndAdd(jo, s / Math.tan(Math.PI / 2 - h));
                var c = En.x !== Je.x ? (Ki.x - Je.x) / (En.x - Je.x) : (Ki.y - Je.y) / (En.y - Je.y);
                if (isNaN(c)) return;
                c < 0 ? Ut.copy(Ki, Je) : c > 1 && Ut.copy(Ki, En);
              }
              Ki.toArray(n[1]);
            }
          }
        }
      }
      function IT(n, t, e, i) {
        var r = e === "normal", a = r ? n : n.ensureState(e);
        a.ignore = t;
        var o = i.get("smooth");
        o && o === true && (o = 0.3), a.shape = a.shape || {}, o > 0 && (a.shape.smooth = o);
        var s = i.getModel("lineStyle").getLineStyle();
        r ? n.useStyle(s) : a.style = s;
      }
      function sCt(n, t) {
        var e = t.smooth, i = t.points;
        if (i) if (n.moveTo(i[0][0], i[0][1]), e > 0 && i.length >= 3) {
          var r = zl(i[0], i[1]), a = zl(i[1], i[2]);
          if (!r || !a) {
            n.lineTo(i[1][0], i[1][1]), n.lineTo(i[2][0], i[2][1]);
            return;
          }
          var o = Math.min(r, a) * e, s = g_([], i[1], i[0], o / r), l = g_([], i[1], i[2], o / a), u = g_([], s, l, 0.5);
          n.bezierCurveTo(s[0], s[1], s[0], s[1], u[0], u[1]), n.bezierCurveTo(l[0], l[1], l[0], l[1], i[2][0], i[2][1]);
        } else for (var h = 1; h < i.length; h++) n.lineTo(i[h][0], i[h][1]);
      }
      function ET(n, t, e) {
        var i = n.getTextGuideLine(), r = n.getTextContent();
        if (!r) {
          i && n.removeTextGuideLine();
          return;
        }
        for (var a = t.normal, o = a.get("show"), s = r.ignore, l = 0; l < Np.length; l++) {
          var u = Np[l], h = t[u], c = u === "normal";
          if (h) {
            var f = h.get("show"), g = c ? s : Pt(r.states[u] && r.states[u].ignore, s);
            if (g || !Pt(f, o)) {
              var d = c ? i : i && i.states[u];
              d && (d.ignore = true), i && IT(i, true, u, h);
              continue;
            }
            i || (i = new Wi(), n.setTextGuideLine(i), !c && (s || !o) && IT(i, true, "normal", t.normal), n.stateProxy && (i.stateProxy = n.stateProxy)), IT(i, false, u, h);
          }
        }
        if (i) {
          Et(i.style, e), i.style.fill = null;
          var A = a.get("showAbove"), p = n.textGuideLineConfig = n.textGuideLineConfig || {};
          p.showAbove = A || false, i.buildPath = sCt;
        }
      }
      function xT(n, t) {
        t = t || "labelLine";
        for (var e = { normal: n.getModel(t) }, i = 0; i < qi.length; i++) {
          var r = qi[i];
          e[r] = n.getModel([r, t]);
        }
        return e;
      }
      function kU(n) {
        for (var t = [], e = 0; e < n.length; e++) {
          var i = n[e];
          if (!i.defaultAttr.ignore) {
            var r = i.label, a = r.getComputedTransform(), o = r.getBoundingRect(), s = !a || a[1] < 1e-5 && a[2] < 1e-5, l = r.style.margin || 0, u = o.clone();
            u.applyTransform(a), u.x -= l / 2, u.y -= l / 2, u.width += l, u.height += l;
            var h = s ? new s1(o, a) : null;
            t.push({ label: r, labelLine: i.labelLine, rect: u, localRect: o, obb: h, priority: i.priority, defaultAttr: i.defaultAttr, layoutOption: i.computedLayoutOption, axisAligned: s, transform: a });
          }
        }
        return t;
      }
      function FU(n, t, e, i, r, a) {
        var o = n.length;
        if (o < 2) return;
        n.sort(function(w, C) {
          return w.rect[t] - C.rect[t];
        });
        for (var s = 0, l, u = false, h = 0, c = 0; c < o; c++) {
          var f = n[c], g = f.rect;
          l = g[t] - s, l < 0 && (g[t] -= l, f.label[t] -= l, u = true);
          var d = Math.max(-l, 0);
          h += d, s = g[t] + g[e];
        }
        h > 0 && a && E(-h / o, 0, o);
        var A = n[0], p = n[o - 1], v, y;
        m(), v < 0 && I(-v, 0.8), y < 0 && I(y, 0.8), m(), _(v, y, 1), _(y, v, -1), m(), v < 0 && x(-v), y < 0 && x(y);
        function m() {
          v = A.rect[t] - i, y = r - p.rect[t] - p.rect[e];
        }
        function _(w, C, S) {
          if (w < 0) {
            var b = Math.min(C, -w);
            if (b > 0) {
              E(b * S, 0, o);
              var B = b + w;
              B < 0 && I(-B * S, 1);
            } else I(-w * S, 1);
          }
        }
        function E(w, C, S) {
          w !== 0 && (u = true);
          for (var b = C; b < S; b++) {
            var B = n[b], T = B.rect;
            T[t] += w, B.label[t] += w;
          }
        }
        function I(w, C) {
          for (var S = [], b = 0, B = 1; B < o; B++) {
            var T = n[B - 1].rect, D = Math.max(n[B].rect[t] - T[t] - T[e], 0);
            S.push(D), b += D;
          }
          if (b) {
            var R = Math.min(Math.abs(w) / b, C);
            if (w > 0) for (var B = 0; B < o - 1; B++) {
              var L = S[B] * R;
              E(L, 0, B + 1);
            }
            else for (var B = o - 1; B > 0; B--) {
              var L = S[B - 1] * R;
              E(-L, B, o);
            }
          }
        }
        function x(w) {
          var C = w < 0 ? -1 : 1;
          w = Math.abs(w);
          for (var S = Math.ceil(w / (o - 1)), b = 0; b < o - 1; b++) if (C > 0 ? E(S, 0, b + 1) : E(-S, o - b - 1, o), w -= S, w <= 0) return;
        }
        return u;
      }
      function lCt(n, t, e, i) {
        return FU(n, "x", "width", t, e, i);
      }
      function QU(n, t, e, i) {
        return FU(n, "y", "height", t, e, i);
      }
      function OU(n) {
        var t = [];
        n.sort(function(A, p) {
          return p.priority - A.priority;
        });
        var e = new Ht(0, 0, 0, 0);
        function i(A) {
          if (!A.ignore) {
            var p = A.ensureState("emphasis");
            p.ignore == null && (p.ignore = false);
          }
          A.ignore = true;
        }
        for (var r = 0; r < n.length; r++) {
          var a = n[r], o = a.axisAligned, s = a.localRect, l = a.transform, u = a.label, h = a.labelLine;
          e.copy(a.rect), e.width -= 0.1, e.height -= 0.1, e.x += 0.05, e.y += 0.05;
          for (var c = a.obb, f = false, g = 0; g < t.length; g++) {
            var d = t[g];
            if (e.intersect(d.rect)) {
              if (o && d.axisAligned) {
                f = true;
                break;
              }
              if (d.obb || (d.obb = new s1(d.localRect, d.transform)), c || (c = new s1(s, l)), c.intersect(d.obb)) {
                f = true;
                break;
              }
            }
          }
          f ? (i(u), h && i(h)) : (u.attr("ignore", a.defaultAttr.ignore), h && h.attr("ignore", a.defaultAttr.labelGuideIgnore), t.push(a));
        }
      }
      function uCt(n) {
        if (n) {
          for (var t = [], e = 0; e < n.length; e++) t.push(n[e].slice());
          return t;
        }
      }
      function hCt(n, t) {
        var e = n.label, i = t && t.getTextGuideLine();
        return { dataIndex: n.dataIndex, dataType: n.dataType, seriesIndex: n.seriesModel.seriesIndex, text: n.label.style.text, rect: n.hostRect, labelRect: n.rect, align: e.style.align, verticalAlign: e.style.verticalAlign, labelLinePoints: uCt(i && i.shape.points) };
      }
      var zU = ["align", "verticalAlign", "width", "height", "fontSize"], $i = new Ts(), wT = le(), cCt = le();
      function uI(n, t, e) {
        for (var i = 0; i < e.length; i++) {
          var r = e[i];
          t[r] != null && (n[r] = t[r]);
        }
      }
      var hI = ["x", "y", "rotation"], fCt = function() {
        function n() {
          this._labelList = [], this._chartViewList = [];
        }
        return n.prototype.clearLabels = function() {
          this._labelList = [], this._chartViewList = [];
        }, n.prototype._addLabel = function(t, e, i, r, a) {
          var o = r.style, s = r.__hostTarget, l = s.textConfig || {}, u = r.getComputedTransform(), h = r.getBoundingRect().plain();
          Ht.applyTransform(h, h, u), u ? $i.setLocalTransform(u) : ($i.x = $i.y = $i.rotation = $i.originX = $i.originY = 0, $i.scaleX = $i.scaleY = 1), $i.rotation = Gr($i.rotation);
          var c = r.__hostTarget, f;
          if (c) {
            f = c.getBoundingRect().plain();
            var g = c.getComputedTransform();
            Ht.applyTransform(f, f, g);
          }
          var d = f && c.getTextGuideLine();
          this._labelList.push({ label: r, labelLine: d, seriesModel: i, dataIndex: t, dataType: e, layoutOption: a, computedLayoutOption: null, rect: h, hostRect: f, priority: f ? f.width * f.height : 0, defaultAttr: { ignore: r.ignore, labelGuideIgnore: d && d.ignore, x: $i.x, y: $i.y, scaleX: $i.scaleX, scaleY: $i.scaleY, rotation: $i.rotation, style: { x: o.x, y: o.y, align: o.align, verticalAlign: o.verticalAlign, width: o.width, height: o.height, fontSize: o.fontSize }, cursor: r.cursor, attachedPos: l.position, attachedRot: l.rotation } });
        }, n.prototype.addLabelsOfSeries = function(t) {
          var e = this;
          this._chartViewList.push(t);
          var i = t.__model, r = i.get("labelLayout");
          (yt(r) || re(r).length) && t.group.traverse(function(a) {
            if (a.ignore) return true;
            var o = a.getTextContent(), s = Dt(a);
            o && !o.disableLabelLayout && e._addLabel(s.dataIndex, s.dataType, i, o, r);
          });
        }, n.prototype.updateLayoutConfig = function(t) {
          var e = t.getWidth(), i = t.getHeight();
          function r(m, _) {
            return function() {
              PU(m, _);
            };
          }
          for (var a = 0; a < this._labelList.length; a++) {
            var o = this._labelList[a], s = o.label, l = s.__hostTarget, u = o.defaultAttr, h = void 0;
            yt(o.layoutOption) ? h = o.layoutOption(hCt(o, l)) : h = o.layoutOption, h = h || {}, o.computedLayoutOption = h;
            var c = Math.PI / 180;
            l && l.setTextConfig({ local: false, position: h.x != null || h.y != null ? null : u.attachedPos, rotation: h.rotate != null ? h.rotate * c : u.attachedRot, offset: [h.dx || 0, h.dy || 0] });
            var f = false;
            if (h.x != null ? (s.x = ot(h.x, e), s.setStyle("x", 0), f = true) : (s.x = u.x, s.setStyle("x", u.style.x)), h.y != null ? (s.y = ot(h.y, i), s.setStyle("y", 0), f = true) : (s.y = u.y, s.setStyle("y", u.style.y)), h.labelLinePoints) {
              var g = l.getTextGuideLine();
              g && (g.setShape({ points: h.labelLinePoints }), f = false);
            }
            var d = wT(s);
            d.needsUpdateLabelLine = f, s.rotation = h.rotate != null ? h.rotate * c : u.rotation, s.scaleX = u.scaleX, s.scaleY = u.scaleY;
            for (var A = 0; A < zU.length; A++) {
              var p = zU[A];
              s.setStyle(p, h[p] != null ? h[p] : u.style[p]);
            }
            if (h.draggable) {
              if (s.draggable = true, s.cursor = "move", l) {
                var v = o.seriesModel;
                if (o.dataIndex != null) {
                  var y = o.seriesModel.getData(o.dataType);
                  v = y.getItemModel(o.dataIndex);
                }
                s.on("drag", r(l, v.getModel("labelLine")));
              }
            } else s.off("drag"), s.cursor = u.cursor;
          }
        }, n.prototype.layout = function(t) {
          var e = t.getWidth(), i = t.getHeight(), r = kU(this._labelList), a = Ne(r, function(l) {
            return l.layoutOption.moveOverlap === "shiftX";
          }), o = Ne(r, function(l) {
            return l.layoutOption.moveOverlap === "shiftY";
          });
          lCt(a, 0, e), QU(o, 0, i);
          var s = Ne(r, function(l) {
            return l.layoutOption.hideOverlap;
          });
          OU(s);
        }, n.prototype.processLabelsOverall = function() {
          var t = this;
          M(this._chartViewList, function(e) {
            var i = e.__model, r = e.ignoreLabelLineUpdate, a = i.isAnimationEnabled();
            e.group.traverse(function(o) {
              if (o.ignore && !o.forceLabelAnimation) return true;
              var s = !r, l = o.getTextContent();
              !s && l && (s = wT(l).needsUpdateLabelLine), s && t._updateLabelLine(o, i), a && t._animateLabels(o, i);
            });
          });
        }, n.prototype._updateLabelLine = function(t, e) {
          var i = t.getTextContent(), r = Dt(t), a = r.dataIndex;
          if (i && a != null) {
            var o = e.getData(r.dataType), s = o.getItemModel(a), l = {}, u = o.getItemVisual(a, "style");
            if (u) {
              var h = o.getVisual("drawType");
              l.stroke = u[h];
            }
            var c = s.getModel("labelLine");
            ET(t, xT(s), l), PU(t, c);
          }
        }, n.prototype._animateLabels = function(t, e) {
          var i = t.getTextContent(), r = t.getTextGuideLine();
          if (i && (t.forceLabelAnimation || !i.ignore && !i.invisible && !t.disableLabelAnimation && !Cg(t))) {
            var a = wT(i), o = a.oldLayout, s = Dt(t), l = s.dataIndex, u = { x: i.x, y: i.y, rotation: i.rotation }, h = e.getData(s.dataType);
            if (o) {
              i.attr(o);
              var f = t.prevStates;
              f && (Wt(f, "select") >= 0 && i.attr(a.oldLayoutSelect), Wt(f, "emphasis") >= 0 && i.attr(a.oldLayoutEmphasis)), _e(i, u, e, l);
            } else if (i.attr(u), !Bg(i).valueAnimation) {
              var c = Pt(i.style.opacity, 1);
              i.style.opacity = 0, nn(i, { style: { opacity: c } }, e, l);
            }
            if (a.oldLayout = u, i.states.select) {
              var g = a.oldLayoutSelect = {};
              uI(g, u, hI), uI(g, i.states.select, hI);
            }
            if (i.states.emphasis) {
              var d = a.oldLayoutEmphasis = {};
              uI(d, u, hI), uI(d, i.states.emphasis, hI);
            }
            c4(i, l, h, e, e);
          }
          if (r && !r.ignore && !r.invisible) {
            var a = cCt(r), o = a.oldLayout, A = { points: r.shape.points };
            o ? (r.attr({ shape: o }), _e(r, { shape: A }, e)) : (r.setShape(A), r.style.strokePercent = 0, nn(r, { style: { strokePercent: 1 } }, e)), a.oldLayout = A;
          }
        }, n;
      }(), CT = le();
      function gCt(n) {
        n.registerUpdateLifecycle("series:beforeupdate", function(t, e, i) {
          var r = CT(e).labelManager;
          r || (r = CT(e).labelManager = new fCt()), r.clearLabels();
        }), n.registerUpdateLifecycle("series:layoutlabels", function(t, e, i) {
          var r = CT(e).labelManager;
          i.updatedSeries.forEach(function(a) {
            r.addLabelsOfSeries(e.getViewOfSeriesModel(a));
          }), r.updateLayoutConfig(e), r.layout(e), r.processLabelsOverall();
        });
      }
      var ST = Math.sin, bT = Math.cos, GU = Math.PI, Xh = Math.PI * 2, dCt = 180 / GU, UU = function() {
        function n() {
        }
        return n.prototype.reset = function(t) {
          this._start = true, this._d = [], this._str = "", this._p = Math.pow(10, t || 4);
        }, n.prototype.moveTo = function(t, e) {
          this._add("M", t, e);
        }, n.prototype.lineTo = function(t, e) {
          this._add("L", t, e);
        }, n.prototype.bezierCurveTo = function(t, e, i, r, a, o) {
          this._add("C", t, e, i, r, a, o);
        }, n.prototype.quadraticCurveTo = function(t, e, i, r) {
          this._add("Q", t, e, i, r);
        }, n.prototype.arc = function(t, e, i, r, a, o) {
          this.ellipse(t, e, i, i, 0, r, a, o);
        }, n.prototype.ellipse = function(t, e, i, r, a, o, s, l) {
          var u = s - o, h = !l, c = Math.abs(u), f = Yl(c - Xh) || (h ? u >= Xh : -u >= Xh), g = u > 0 ? u % Xh : u % Xh + Xh, d = false;
          f ? d = true : Yl(c) ? d = false : d = g >= GU == !!h;
          var A = t + i * bT(o), p = e + r * ST(o);
          this._start && this._add("M", A, p);
          var v = Math.round(a * dCt);
          if (f) {
            var y = 1 / this._p, m = (h ? 1 : -1) * (Xh - y);
            this._add("A", i, r, v, 1, +h, t + i * bT(o + m), e + r * ST(o + m)), y > 0.01 && this._add("A", i, r, v, 0, +h, A, p);
          } else {
            var _ = t + i * bT(s), E = e + r * ST(s);
            this._add("A", i, r, v, +d, +h, _, E);
          }
        }, n.prototype.rect = function(t, e, i, r) {
          this._add("M", t, e), this._add("l", i, 0), this._add("l", 0, r), this._add("l", -i, 0), this._add("Z");
        }, n.prototype.closePath = function() {
          this._d.length > 0 && this._add("Z");
        }, n.prototype._add = function(t, e, i, r, a, o, s, l, u) {
          for (var h = [], c = this._p, f = 1; f < arguments.length; f++) {
            var g = arguments[f];
            if (isNaN(g)) {
              this._invalid = true;
              return;
            }
            h.push(Math.round(g * c) / c);
          }
          this._d.push(t + h.join(" ")), this._start = t === "Z";
        }, n.prototype.generateStr = function() {
          this._str = this._invalid ? "" : this._d.join(""), this._d = [];
        }, n.prototype.getStr = function() {
          return this._str;
        }, n;
      }(), BT = "none", ACt = Math.round;
      function pCt(n) {
        var t = n.fill;
        return t != null && t !== BT;
      }
      function vCt(n) {
        var t = n.stroke;
        return t != null && t !== BT;
      }
      var TT = ["lineCap", "miterLimit", "lineJoin"], yCt = Z(TT, function(n) {
        return "stroke-" + n.toLowerCase();
      });
      function mCt(n, t, e, i) {
        var r = t.opacity == null ? 1 : t.opacity;
        if (e instanceof li) {
          n("opacity", r);
          return;
        }
        if (pCt(t)) {
          var a = Ip(t.fill);
          n("fill", a.color);
          var o = t.fillOpacity != null ? t.fillOpacity * a.opacity * r : a.opacity * r;
          o < 1 && n("fill-opacity", o);
        } else n("fill", BT);
        if (vCt(t)) {
          var s = Ip(t.stroke);
          n("stroke", s.color);
          var l = t.strokeNoScale ? e.getLineScale() : 1, u = l ? (t.lineWidth || 0) / l : 0, h = t.strokeOpacity != null ? t.strokeOpacity * s.opacity * r : s.opacity * r, c = t.strokeFirst;
          if (u !== 1 && n("stroke-width", u), c && n("paint-order", c ? "stroke" : "fill"), h < 1 && n("stroke-opacity", h), t.lineDash) {
            var f = UB(e), g = f[0], d = f[1];
            g && (d = ACt(d || 0), n("stroke-dasharray", g.join(",")), (d || i) && n("stroke-dashoffset", d));
          }
          for (var A = 0; A < TT.length; A++) {
            var p = TT[A];
            if (t[p] !== W_[p]) {
              var v = t[p] || W_[p];
              v && n(yCt[A], v);
            }
          }
        }
      }
      var VU = "http://www.w3.org/2000/svg", jU = "http://www.w3.org/1999/xlink", _Ct = "http://www.w3.org/2000/xmlns/", ICt = "http://www.w3.org/XML/1998/namespace", qU = "ecmeta_";
      function HU(n) {
        return document.createElementNS(VU, n);
      }
      function Kn(n, t, e, i, r) {
        return { tag: n, attrs: e || {}, children: i, text: r, key: t };
      }
      function ECt(n, t) {
        var e = [];
        if (t) for (var i in t) {
          var r = t[i], a = i;
          r !== false && (r !== true && r != null && (a += '="' + r + '"'), e.push(a));
        }
        return "<" + n + " " + e.join(" ") + ">";
      }
      function xCt(n) {
        return "</" + n + ">";
      }
      function MT(n, t) {
        t = t || {};
        var e = t.newline ? `
` : "";
        function i(r) {
          var a = r.children, o = r.tag, s = r.attrs, l = r.text;
          return ECt(o, s) + (o !== "style" ? pr(l) : l || "") + (a ? "" + e + Z(a, function(u) {
            return i(u);
          }).join(e) + e : "") + xCt(o);
        }
        return i(n);
      }
      function wCt(n, t, e) {
        e = e || {};
        var i = e.newline ? `
` : "", r = " {" + i, a = i + "}", o = Z(re(n), function(l) {
          return l + r + Z(re(n[l]), function(u) {
            return u + ":" + n[l][u] + ";";
          }).join(i) + a;
        }).join(i), s = Z(re(t), function(l) {
          return "@keyframes " + l + r + Z(re(t[l]), function(u) {
            return u + r + Z(re(t[l][u]), function(h) {
              var c = t[l][u][h];
              return h === "d" && (c = 'path("' + c + '")'), h + ":" + c + ";";
            }).join(i) + a;
          }).join(i) + a;
        }).join(i);
        return !o && !s ? "" : ["<![CDATA[", o, s, "]]>"].join(i);
      }
      function DT(n) {
        return { zrId: n, shadowCache: {}, patternCache: {}, gradientCache: {}, clipPathCache: {}, defs: {}, cssNodes: {}, cssAnims: {}, cssStyleCache: {}, cssAnimIdx: 0, shadowIdx: 0, gradientIdx: 0, patternIdx: 0, clipPathIdx: 0 };
      }
      function YU(n, t, e, i) {
        return Kn("svg", "root", { width: n, height: t, xmlns: VU, "xmlns:xlink": jU, version: "1.1", baseProfile: "full", viewBox: i ? "0 0 " + n + " " + t : false }, e);
      }
      var CCt = 0;
      function WU() {
        return CCt++;
      }
      var XU = { cubicIn: "0.32,0,0.67,0", cubicOut: "0.33,1,0.68,1", cubicInOut: "0.65,0,0.35,1", quadraticIn: "0.11,0,0.5,0", quadraticOut: "0.5,1,0.89,1", quadraticInOut: "0.45,0,0.55,1", quarticIn: "0.5,0,0.75,0", quarticOut: "0.25,1,0.5,1", quarticInOut: "0.76,0,0.24,1", quinticIn: "0.64,0,0.78,0", quinticOut: "0.22,1,0.36,1", quinticInOut: "0.83,0,0.17,1", sinusoidalIn: "0.12,0,0.39,0", sinusoidalOut: "0.61,1,0.88,1", sinusoidalInOut: "0.37,0,0.63,1", exponentialIn: "0.7,0,0.84,0", exponentialOut: "0.16,1,0.3,1", exponentialInOut: "0.87,0,0.13,1", circularIn: "0.55,0,1,0.45", circularOut: "0,0.55,0.45,1", circularInOut: "0.85,0,0.15,1" }, Zh = "transform-origin";
      function SCt(n, t, e) {
        var i = Y({}, n.shape);
        Y(i, t), n.buildPath(e, i);
        var r = new UU();
        return r.reset(aG(n)), e.rebuildPath(r, 1), r.generateStr(), r.getStr();
      }
      function bCt(n, t) {
        var e = t.originX, i = t.originY;
        (e || i) && (n[Zh] = e + "px " + i + "px");
      }
      var BCt = { fill: "fill", opacity: "opacity", lineWidth: "stroke-width", lineDashOffset: "stroke-dashoffset" };
      function ZU(n, t) {
        var e = t.zrId + "-ani-" + t.cssAnimIdx++;
        return t.cssAnims[e] = n, e;
      }
      function TCt(n, t, e) {
        var i = n.shape.paths, r = {}, a, o;
        if (M(i, function(l) {
          var u = DT(e.zrId);
          u.animation = true, cI(l, {}, u, true);
          var h = u.cssAnims, c = u.cssNodes, f = re(h), g = f.length;
          if (g) {
            o = f[g - 1];
            var d = h[o];
            for (var A in d) {
              var p = d[A];
              r[A] = r[A] || { d: "" }, r[A].d += p.d || "";
            }
            for (var v in c) {
              var y = c[v].animation;
              y.indexOf(o) >= 0 && (a = y);
            }
          }
        }), !!a) {
          t.d = false;
          var s = ZU(r, e);
          return a.replace(o, s);
        }
      }
      function KU(n) {
        return ht(n) ? XU[n] ? "cubic-bezier(" + XU[n] + ")" : Pb(n) ? n : "" : "";
      }
      function cI(n, t, e, i) {
        var r = n.animators, a = r.length, o = [];
        if (n instanceof Z2) {
          var s = TCt(n, t, e);
          if (s) o.push(s);
          else if (!a) return;
        } else if (!a) return;
        for (var l = {}, u = 0; u < a; u++) {
          var h = r[u], c = [h.getMaxTime() / 1e3 + "s"], f = KU(h.getClip().easing), g = h.getDelay();
          f ? c.push(f) : c.push("linear"), g && c.push(g / 1e3 + "s"), h.getLoop() && c.push("infinite");
          var d = c.join(" ");
          l[d] = l[d] || [d, []], l[d][1].push(h);
        }
        function A(y) {
          var m = y[1], _ = m.length, E = {}, I = {}, x = {}, w = "animation-timing-function";
          function C(nt, gt, H) {
            for (var W = nt.getTracks(), it = nt.getMaxTime(), kt = 0; kt < W.length; kt++) {
              var vt = W[kt];
              if (vt.needsAnimate()) {
                var St = vt.keyframes, bt = vt.propName;
                if (H && (bt = H(bt)), bt) for (var Ee = 0; Ee < St.length; Ee++) {
                  var rn = St[Ee], Ie = Math.round(rn.time / it * 100) + "%", fn = KU(rn.easing), an = rn.rawValue;
                  (ht(an) || pe(an)) && (gt[Ie] = gt[Ie] || {}, gt[Ie][bt] = rn.rawValue, fn && (gt[Ie][w] = fn));
                }
              }
            }
          }
          for (var S = 0; S < _; S++) {
            var b = m[S], B = b.targetName;
            B ? B === "shape" && C(b, I) : !i && C(b, E);
          }
          for (var T in E) {
            var D = {};
            yG(D, n), Y(D, E[T]);
            var R = oG(D), L = E[T][w];
            x[T] = R ? { transform: R } : {}, bCt(x[T], D), L && (x[T][w] = L);
          }
          var k, P = true;
          for (var T in I) {
            x[T] = x[T] || {};
            var F = !k, L = I[T][w];
            F && (k = new ko());
            var Q = k.len();
            k.reset(), x[T].d = SCt(n, I[T], k);
            var z = k.len();
            if (!F && Q !== z) {
              P = false;
              break;
            }
            L && (x[T][w] = L);
          }
          if (!P) for (var T in x) delete x[T].d;
          if (!i) for (var S = 0; S < _; S++) {
            var b = m[S], B = b.targetName;
            B === "style" && C(b, x, function(W) {
              return BCt[W];
            });
          }
          for (var j = re(x), $ = true, G, S = 1; S < j.length; S++) {
            var tt = j[S - 1], J = j[S];
            if (x[tt][Zh] !== x[J][Zh]) {
              $ = false;
              break;
            }
            G = x[tt][Zh];
          }
          if ($ && G) {
            for (var T in x) x[T][Zh] && delete x[T][Zh];
            t[Zh] = G;
          }
          if (Ne(j, function(nt) {
            return re(x[nt]).length > 0;
          }).length) {
            var et = ZU(x, e);
            return et + " " + y[0] + " both";
          }
        }
        for (var p in l) {
          var s = A(l[p]);
          s && o.push(s);
        }
        if (o.length) {
          var v = e.zrId + "-cls-" + WU();
          e.cssNodes["." + v] = { animation: o.join(",") }, t.class = v;
        }
      }
      function MCt(n, t, e) {
        if (!n.ignore) if (n.isSilent()) {
          var i = { "pointer-events": "none" };
          $U(i, t, e);
        } else {
          var r = n.states.emphasis && n.states.emphasis.style ? n.states.emphasis.style : {}, a = r.fill;
          if (!a) {
            var o = n.style && n.style.fill, s = n.states.select && n.states.select.style && n.states.select.style.fill, l = n.currentStates.indexOf("select") >= 0 && s || o;
            l && (a = Gb(l));
          }
          var u = r.lineWidth;
          if (u) {
            var h = !r.strokeNoScale && n.transform ? n.transform[0] : 1;
            u = u / h;
          }
          var i = { cursor: "pointer" };
          a && (i.fill = a), r.stroke && (i.stroke = r.stroke), u && (i["stroke-width"] = u), $U(i, t, e);
        }
      }
      function $U(n, t, e, i) {
        var r = JSON.stringify(n), a = e.cssStyleCache[r];
        a || (a = e.zrId + "-cls-" + WU(), e.cssStyleCache[r] = a, e.cssNodes["." + a + ":hover"] = n), t.class = t.class ? t.class + " " + a : a;
      }
      var Ev = Math.round;
      function JU(n) {
        return n && ht(n.src);
      }
      function tV(n) {
        return n && yt(n.toDataURL);
      }
      function RT(n, t, e, i) {
        mCt(function(r, a) {
          var o = r === "fill" || r === "stroke";
          o && rG(a) ? oV(t, n, r, i) : o && Vb(a) ? sV(e, n, r, i) : o && a === "none" ? n[r] = "transparent" : n[r] = a;
        }, t, e, false), FCt(e, n, i);
      }
      function LT(n, t) {
        var e = Cmt(t);
        e && (e.each(function(i, r) {
          i != null && (n[(qU + r).toLowerCase()] = i + "");
        }), t.isSilent() && (n[qU + "silent"] = "true"));
      }
      function eV(n) {
        return Yl(n[0] - 1) && Yl(n[1]) && Yl(n[2]) && Yl(n[3] - 1);
      }
      function DCt(n) {
        return Yl(n[4]) && Yl(n[5]);
      }
      function PT(n, t, e) {
        if (t && !(DCt(t) && eV(t))) {
          var i = 1e4;
          n.transform = eV(t) ? "translate(" + Ev(t[4] * i) / i + " " + Ev(t[5] * i) / i + ")" : W0t(t);
        }
      }
      function nV(n, t, e) {
        for (var i = n.points, r = [], a = 0; a < i.length; a++) r.push(Ev(i[a][0] * e) / e), r.push(Ev(i[a][1] * e) / e);
        t.points = r.join(" ");
      }
      function iV(n) {
        return !n.smooth;
      }
      function RCt(n) {
        var t = Z(n, function(e) {
          return typeof e == "string" ? [e, e] : e;
        });
        return function(e, i, r) {
          for (var a = 0; a < t.length; a++) {
            var o = t[a], s = e[o[0]];
            s != null && (i[o[1]] = Ev(s * r) / r);
          }
        };
      }
      var LCt = { circle: [RCt(["cx", "cy", "r"])], polyline: [nV, iV], polygon: [nV, iV] };
      function PCt(n) {
        for (var t = n.animators, e = 0; e < t.length; e++) if (t[e].targetName === "shape") return true;
        return false;
      }
      function rV(n, t) {
        var e = n.style, i = n.shape, r = LCt[n.type], a = {}, o = t.animation, s = "path", l = n.style.strokePercent, u = t.compress && aG(n) || 4;
        if (r && !t.willUpdate && !(r[1] && !r[1](i)) && !(o && PCt(n)) && !(l < 1)) {
          s = n.type;
          var h = Math.pow(10, u);
          r[0](i, a, h);
        } else {
          var c = !n.path || n.shapeChanged();
          n.path || n.createPathProxy();
          var f = n.path;
          c && (f.beginPath(), n.buildPath(f, n.shape), n.pathUpdated());
          var g = f.getVersion(), d = n, A = d.__svgPathBuilder;
          (d.__svgPathVersion !== g || !A || l !== d.__svgPathStrokePercent) && (A || (A = d.__svgPathBuilder = new UU()), A.reset(u), f.rebuildPath(A, l), A.generateStr(), d.__svgPathVersion = g, d.__svgPathStrokePercent = l), a.d = A.getStr();
        }
        return PT(a, n.transform), RT(a, e, n, t), LT(a, n), t.animation && cI(n, a, t), t.emphasis && MCt(n, a, t), Kn(s, n.id + "", a);
      }
      function NCt(n, t) {
        var e = n.style, i = e.image;
        if (i && !ht(i) && (JU(i) ? i = i.src : tV(i) && (i = i.toDataURL())), !!i) {
          var r = e.x || 0, a = e.y || 0, o = e.width, s = e.height, l = { href: i, width: o, height: s };
          return r && (l.x = r), a && (l.y = a), PT(l, n.transform), RT(l, e, n, t), LT(l, n), t.animation && cI(n, l, t), Kn("image", n.id + "", l);
        }
      }
      function kCt(n, t) {
        var e = n.style, i = e.text;
        if (i != null && (i += ""), !(!i || isNaN(e.x) || isNaN(e.y))) {
          var r = e.font || Ql, a = e.x || 0, o = Z0t(e.y || 0, k_(r), e.textBaseline), s = X0t[e.textAlign] || e.textAlign, l = { "dominant-baseline": "central", "text-anchor": s };
          if (f5(e)) {
            var u = "", h = e.fontStyle, c = h5(e.fontSize);
            if (!parseFloat(c)) return;
            var f = e.fontFamily || pz, g = e.fontWeight;
            u += "font-size:" + c + ";font-family:" + f + ";", h && h !== "normal" && (u += "font-style:" + h + ";"), g && g !== "normal" && (u += "font-weight:" + g + ";"), l.style = u;
          } else l.style = "font: " + r;
          return i.match(/\s/) && (l["xml:space"] = "preserve"), a && (l.x = a), o && (l.y = o), PT(l, n.transform), RT(l, e, n, t), LT(l, n), t.animation && cI(n, l, t), Kn("text", n.id + "", l, void 0, i);
        }
      }
      function aV(n, t) {
        if (n instanceof Jt) return rV(n, t);
        if (n instanceof li) return NCt(n, t);
        if (n instanceof yg) return kCt(n, t);
      }
      function FCt(n, t, e) {
        var i = n.style;
        if (K0t(i)) {
          var r = $0t(n), a = e.shadowCache, o = a[r];
          if (!o) {
            var s = n.getGlobalScale(), l = s[0], u = s[1];
            if (!l || !u) return;
            var h = i.shadowOffsetX || 0, c = i.shadowOffsetY || 0, f = i.shadowBlur, g = Ip(i.shadowColor), d = g.opacity, A = g.color, p = f / 2 / l, v = f / 2 / u, y = p + " " + v;
            o = e.zrId + "-s" + e.shadowIdx++, e.defs[o] = Kn("filter", o, { id: o, x: "-100%", y: "-100%", width: "300%", height: "300%" }, [Kn("feDropShadow", "", { dx: h / l, dy: c / u, stdDeviation: y, "flood-color": A, "flood-opacity": d })]), a[r] = o;
          }
          t.filter = B_(o);
        }
      }
      function oV(n, t, e, i) {
        var r = n[e], a, o = { gradientUnits: r.global ? "userSpaceOnUse" : "objectBoundingBox" };
        if (nG(r)) a = "linearGradient", o.x1 = r.x, o.y1 = r.y, o.x2 = r.x2, o.y2 = r.y2;
        else if (iG(r)) a = "radialGradient", o.cx = Pt(r.x, 0.5), o.cy = Pt(r.y, 0.5), o.r = Pt(r.r, 0.5);
        else {
          za("Illegal gradient type.");
          return;
        }
        for (var s = r.colorStops, l = [], u = 0, h = s.length; u < h; ++u) {
          var c = Ub(s[u].offset) * 100 + "%", f = s[u].color, g = Ip(f), d = g.color, A = g.opacity, p = { offset: c };
          p["stop-color"] = d, A < 1 && (p["stop-opacity"] = A), l.push(Kn("stop", u + "", p));
        }
        var v = Kn(a, "", o, l), y = MT(v), m = i.gradientCache, _ = m[y];
        _ || (_ = i.zrId + "-g" + i.gradientIdx++, m[y] = _, o.id = _, i.defs[_] = Kn(a, _, o, l)), t[e] = B_(_);
      }
      function sV(n, t, e, i) {
        var r = n.style[e], a = n.getBoundingRect(), o = {}, s = r.repeat, l = s === "no-repeat", u = s === "repeat-x", h = s === "repeat-y", c;
        if (eG(r)) {
          var f = r.imageWidth, g = r.imageHeight, d = void 0, A = r.image;
          if (ht(A) ? d = A : JU(A) ? d = A.src : tV(A) && (d = A.toDataURL()), typeof Image == "undefined") {
            var p = "Image width/height must been given explictly in svg-ssr renderer.";
            It(f, p), It(g, p);
          } else if (f == null || g == null) {
            var v = function(S, b) {
              if (S) {
                var B = S.elm, T = f || b.width, D = g || b.height;
                S.tag === "pattern" && (u ? (D = 1, T /= a.width) : h && (T = 1, D /= a.height)), S.attrs.width = T, S.attrs.height = D, B && (B.setAttribute("width", T), B.setAttribute("height", D));
              }
            }, y = m2(d, null, n, function(S) {
              l || v(I, S), v(c, S);
            });
            y && y.width && y.height && (f = f || y.width, g = g || y.height);
          }
          c = Kn("image", "img", { href: d, width: f, height: g }), o.width = f, o.height = g;
        } else r.svgElement && (c = xt(r.svgElement), o.width = r.svgWidth, o.height = r.svgHeight);
        if (c) {
          var m, _;
          l ? m = _ = 1 : u ? (_ = 1, m = o.width / a.width) : h ? (m = 1, _ = o.height / a.height) : o.patternUnits = "userSpaceOnUse", m != null && !isNaN(m) && (o.width = m), _ != null && !isNaN(_) && (o.height = _);
          var E = oG(r);
          E && (o.patternTransform = E);
          var I = Kn("pattern", "", o, [c]), x = MT(I), w = i.patternCache, C = w[x];
          C || (C = i.zrId + "-p" + i.patternIdx++, w[x] = C, o.id = C, I = i.defs[C] = Kn("pattern", C, o, [c])), t[e] = B_(C);
        }
      }
      function QCt(n, t, e) {
        var i = e.clipPathCache, r = e.defs, a = i[n.id];
        if (!a) {
          a = e.zrId + "-c" + e.clipPathIdx++;
          var o = { id: a };
          i[n.id] = a, r[a] = Kn("clipPath", a, o, [rV(n, e)]);
        }
        t["clip-path"] = B_(a);
      }
      function lV(n) {
        return document.createTextNode(n);
      }
      function Kh(n, t, e) {
        n.insertBefore(t, e);
      }
      function uV(n, t) {
        n.removeChild(t);
      }
      function hV(n, t) {
        n.appendChild(t);
      }
      function cV(n) {
        return n.parentNode;
      }
      function fV(n) {
        return n.nextSibling;
      }
      function NT(n, t) {
        n.textContent = t;
      }
      var gV = 58, OCt = 120, zCt = Kn("", "");
      function kT(n) {
        return n === void 0;
      }
      function qo(n) {
        return n !== void 0;
      }
      function GCt(n, t, e) {
        for (var i = {}, r = t; r <= e; ++r) {
          var a = n[r].key;
          a !== void 0 && (i[a] != null, i[a] = r);
        }
        return i;
      }
      function xv(n, t) {
        var e = n.key === t.key, i = n.tag === t.tag;
        return i && e;
      }
      function wv(n) {
        var t, e = n.children, i = n.tag;
        if (qo(i)) {
          var r = n.elm = HU(i);
          if (FT(zCt, n), X(e)) for (t = 0; t < e.length; ++t) {
            var a = e[t];
            a != null && hV(r, wv(a));
          }
          else qo(n.text) && !_t(n.text) && hV(r, lV(n.text));
        } else n.elm = lV(n.text);
        return n.elm;
      }
      function dV(n, t, e, i, r) {
        for (; i <= r; ++i) {
          var a = e[i];
          a != null && Kh(n, wv(a), t);
        }
      }
      function fI(n, t, e, i) {
        for (; e <= i; ++e) {
          var r = t[e];
          if (r != null) if (qo(r.tag)) {
            var a = cV(r.elm);
            uV(a, r.elm);
          } else uV(n, r.elm);
        }
      }
      function FT(n, t) {
        var e, i = t.elm, r = n && n.attrs || {}, a = t.attrs || {};
        if (r !== a) {
          for (e in a) {
            var o = a[e], s = r[e];
            s !== o && (o === true ? i.setAttribute(e, "") : o === false ? i.removeAttribute(e) : e === "style" ? i.style.cssText = o : e.charCodeAt(0) !== OCt ? i.setAttribute(e, o) : e === "xmlns:xlink" || e === "xmlns" ? i.setAttributeNS(_Ct, e, o) : e.charCodeAt(3) === gV ? i.setAttributeNS(ICt, e, o) : e.charCodeAt(5) === gV ? i.setAttributeNS(jU, e, o) : i.setAttribute(e, o));
          }
          for (e in r) e in a || i.removeAttribute(e);
        }
      }
      function UCt(n, t, e) {
        for (var i = 0, r = 0, a = t.length - 1, o = t[0], s = t[a], l = e.length - 1, u = e[0], h = e[l], c, f, g, d; i <= a && r <= l; ) o == null ? o = t[++i] : s == null ? s = t[--a] : u == null ? u = e[++r] : h == null ? h = e[--l] : xv(o, u) ? (Kg(o, u), o = t[++i], u = e[++r]) : xv(s, h) ? (Kg(s, h), s = t[--a], h = e[--l]) : xv(o, h) ? (Kg(o, h), Kh(n, o.elm, fV(s.elm)), o = t[++i], h = e[--l]) : xv(s, u) ? (Kg(s, u), Kh(n, s.elm, o.elm), s = t[--a], u = e[++r]) : (kT(c) && (c = GCt(t, i, a)), f = c[u.key], kT(f) ? Kh(n, wv(u), o.elm) : (g = t[f], g.tag !== u.tag ? Kh(n, wv(u), o.elm) : (Kg(g, u), t[f] = void 0, Kh(n, g.elm, o.elm))), u = e[++r]);
        (i <= a || r <= l) && (i > a ? (d = e[l + 1] == null ? null : e[l + 1].elm, dV(n, d, e, r, l)) : fI(n, t, i, a));
      }
      function Kg(n, t) {
        var e = t.elm = n.elm, i = n.children, r = t.children;
        n !== t && (FT(n, t), kT(t.text) ? qo(i) && qo(r) ? i !== r && UCt(e, i, r) : qo(r) ? (qo(n.text) && NT(e, ""), dV(e, null, r, 0, r.length - 1)) : qo(i) ? fI(e, i, 0, i.length - 1) : qo(n.text) && NT(e, "") : n.text !== t.text && (qo(i) && fI(e, i, 0, i.length - 1), NT(e, t.text)));
      }
      function VCt(n, t) {
        if (xv(n, t)) Kg(n, t);
        else {
          var e = n.elm, i = cV(e);
          wv(t), i !== null && (Kh(i, t.elm, fV(e)), fI(i, [n], 0, 0));
        }
        return t;
      }
      var jCt = 0, qCt = function() {
        function n(t, e, i) {
          if (this.type = "svg", this.refreshHover = AV("refreshHover"), this.configLayer = AV("configLayer"), this.storage = e, this._opts = i = Y({}, i), this.root = t, this._id = "zr" + jCt++, this._oldVNode = YU(i.width, i.height), t && !i.ssr) {
            var r = this._viewport = document.createElement("div");
            r.style.cssText = "position:relative;overflow:hidden";
            var a = this._svgDom = this._oldVNode.elm = HU("svg");
            FT(null, this._oldVNode), r.appendChild(a), t.appendChild(r);
          }
          this.resize(i.width, i.height);
        }
        return n.prototype.getType = function() {
          return this.type;
        }, n.prototype.getViewportRoot = function() {
          return this._viewport;
        }, n.prototype.getViewportRootOffset = function() {
          var t = this.getViewportRoot();
          if (t) return { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 };
        }, n.prototype.getSvgDom = function() {
          return this._svgDom;
        }, n.prototype.refresh = function() {
          if (this.root) {
            var t = this.renderToVNode({ willUpdate: true });
            t.attrs.style = "position:absolute;left:0;top:0;user-select:none", VCt(this._oldVNode, t), this._oldVNode = t;
          }
        }, n.prototype.renderOneToVNode = function(t) {
          return aV(t, DT(this._id));
        }, n.prototype.renderToVNode = function(t) {
          t = t || {};
          var e = this.storage.getDisplayList(true), i = this._width, r = this._height, a = DT(this._id);
          a.animation = t.animation, a.willUpdate = t.willUpdate, a.compress = t.compress, a.emphasis = t.emphasis;
          var o = [], s = this._bgVNode = HCt(i, r, this._backgroundColor, a);
          s && o.push(s);
          var l = t.compress ? null : this._mainVNode = Kn("g", "main", {}, []);
          this._paintList(e, a, l ? l.children : o), l && o.push(l);
          var u = Z(re(a.defs), function(f) {
            return a.defs[f];
          });
          if (u.length && o.push(Kn("defs", "defs", {}, u)), t.animation) {
            var h = wCt(a.cssNodes, a.cssAnims, { newline: true });
            if (h) {
              var c = Kn("style", "stl", {}, [], h);
              o.push(c);
            }
          }
          return YU(i, r, o, t.useViewBox);
        }, n.prototype.renderToString = function(t) {
          return t = t || {}, MT(this.renderToVNode({ animation: Pt(t.cssAnimation, true), emphasis: Pt(t.cssEmphasis, true), willUpdate: false, compress: true, useViewBox: Pt(t.useViewBox, true) }), { newline: true });
        }, n.prototype.setBackgroundColor = function(t) {
          this._backgroundColor = t;
        }, n.prototype.getSvgRoot = function() {
          return this._mainVNode && this._mainVNode.elm;
        }, n.prototype._paintList = function(t, e, i) {
          for (var r = t.length, a = [], o = 0, s, l, u = 0, h = 0; h < r; h++) {
            var c = t[h];
            if (!c.invisible) {
              var f = c.__clipPaths, g = f && f.length || 0, d = l && l.length || 0, A = void 0;
              for (A = Math.max(g - 1, d - 1); A >= 0 && !(f && l && f[A] === l[A]); A--) ;
              for (var p = d - 1; p > A; p--) o--, s = a[o - 1];
              for (var v = A + 1; v < g; v++) {
                var y = {};
                QCt(f[v], y, e);
                var m = Kn("g", "clip-g-" + u++, y, []);
                (s ? s.children : i).push(m), a[o++] = m, s = m;
              }
              l = f;
              var _ = aV(c, e);
              _ && (s ? s.children : i).push(_);
            }
          }
        }, n.prototype.resize = function(t, e) {
          var i = this._opts, r = this.root, a = this._viewport;
          if (t != null && (i.width = t), e != null && (i.height = e), r && a && (a.style.display = "none", t = jg(r, 0, i), e = jg(r, 1, i), a.style.display = ""), this._width !== t || this._height !== e) {
            if (this._width = t, this._height = e, a) {
              var o = a.style;
              o.width = t + "px", o.height = e + "px";
            }
            if (Vb(this._backgroundColor)) this.refresh();
            else {
              var s = this._svgDom;
              s && (s.setAttribute("width", t), s.setAttribute("height", e));
              var l = this._bgVNode && this._bgVNode.elm;
              l && (l.setAttribute("width", t), l.setAttribute("height", e));
            }
          }
        }, n.prototype.getWidth = function() {
          return this._width;
        }, n.prototype.getHeight = function() {
          return this._height;
        }, n.prototype.dispose = function() {
          this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
        }, n.prototype.clear = function() {
          this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
        }, n.prototype.toDataURL = function(t) {
          var e = this.renderToString(), i = "data:image/svg+xml;";
          return t ? (e = tmt(e), e && i + "base64," + e) : i + "charset=UTF-8," + encodeURIComponent(e);
        }, n;
      }();
      function AV(n) {
        return function() {
          za('In SVG mode painter not support method "' + n + '"');
        };
      }
      function HCt(n, t, e, i) {
        var r;
        if (e && e !== "none") if (r = Kn("rect", "bg", { width: n, height: t, x: "0", y: "0" }), rG(e)) oV({ fill: e }, r.attrs, "fill", i);
        else if (Vb(e)) sV({ style: { fill: e }, dirty: In, getBoundingRect: function() {
          return { width: n, height: t };
        } }, r.attrs, "fill", i);
        else {
          var a = Ip(e), o = a.color, s = a.opacity;
          r.attrs.fill = o, s < 1 && (r.attrs["fill-opacity"] = s);
        }
        return r;
      }
      function YCt(n) {
        n.registerPainter("svg", qCt);
      }
      function pV(n, t, e) {
        var i = Ol.createCanvas(), r = t.getWidth(), a = t.getHeight(), o = i.style;
        return o && (o.position = "absolute", o.left = "0", o.top = "0", o.width = r + "px", o.height = a + "px", i.setAttribute("data-zr-dom-id", n)), i.width = r * e, i.height = a * e, i;
      }
      var QT = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this) || this;
          a.motionBlur = false, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = false, a.config = {}, a.incremental = false, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = true, a.__firstTimePaint = true, a.__used = false, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
          var o;
          r = r || N_, typeof e == "string" ? o = pV(e, i, r) : _t(e) && (o = e, e = o.id), a.id = e, a.dom = o;
          var s = o.style;
          return s && (Cz(o), o.onselectstart = function() {
            return false;
          }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), a.painter = i, a.dpr = r, a;
        }
        return t.prototype.getElementCount = function() {
          return this.__endIndex - this.__startIndex;
        }, t.prototype.afterBrush = function() {
          this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
        }, t.prototype.initContext = function() {
          this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
        }, t.prototype.setUnpainted = function() {
          this.__firstTimePaint = true;
        }, t.prototype.createBackBuffer = function() {
          var e = this.dpr;
          this.domBack = pV("back-" + this.id, this.painter, e), this.ctxBack = this.domBack.getContext("2d"), e !== 1 && this.ctxBack.scale(e, e);
        }, t.prototype.createRepaintRects = function(e, i, r, a) {
          if (this.__firstTimePaint) return this.__firstTimePaint = false, null;
          var o = [], s = this.maxRepaintRectCount, l = false, u = new Ht(0, 0, 0, 0);
          function h(y) {
            if (!(!y.isFinite() || y.isZero())) if (o.length === 0) {
              var m = new Ht(0, 0, 0, 0);
              m.copy(y), o.push(m);
            } else {
              for (var _ = false, E = 1 / 0, I = 0, x = 0; x < o.length; ++x) {
                var w = o[x];
                if (w.intersect(y)) {
                  var C = new Ht(0, 0, 0, 0);
                  C.copy(w), C.union(y), o[x] = C, _ = true;
                  break;
                } else if (l) {
                  u.copy(y), u.union(w);
                  var S = y.width * y.height, b = w.width * w.height, B = u.width * u.height, T = B - S - b;
                  T < E && (E = T, I = x);
                }
              }
              if (l && (o[I].union(y), _ = true), !_) {
                var m = new Ht(0, 0, 0, 0);
                m.copy(y), o.push(m);
              }
              l || (l = o.length >= s);
            }
          }
          for (var c = this.__startIndex; c < this.__endIndex; ++c) {
            var f = e[c];
            if (f) {
              var g = f.shouldBePainted(r, a, true, true), d = f.__isRendered && (f.__dirty & Qr || !g) ? f.getPrevPaintRect() : null;
              d && h(d);
              var A = g && (f.__dirty & Qr || !f.__isRendered) ? f.getPaintRect() : null;
              A && h(A);
            }
          }
          for (var c = this.__prevStartIndex; c < this.__prevEndIndex; ++c) {
            var f = i[c], g = f && f.shouldBePainted(r, a, true, true);
            if (f && (!g || !f.__zr) && f.__isRendered) {
              var d = f.getPrevPaintRect();
              d && h(d);
            }
          }
          var p;
          do {
            p = false;
            for (var c = 0; c < o.length; ) {
              if (o[c].isZero()) {
                o.splice(c, 1);
                continue;
              }
              for (var v = c + 1; v < o.length; ) o[c].intersect(o[v]) ? (p = true, o[c].union(o[v]), o.splice(v, 1)) : v++;
              c++;
            }
          } while (p);
          return this._paintRects = o, o;
        }, t.prototype.debugGetPaintRects = function() {
          return (this._paintRects || []).slice();
        }, t.prototype.resize = function(e, i) {
          var r = this.dpr, a = this.dom, o = a.style, s = this.domBack;
          o && (o.width = e + "px", o.height = i + "px"), a.width = e * r, a.height = i * r, s && (s.width = e * r, s.height = i * r, r !== 1 && this.ctxBack.scale(r, r));
        }, t.prototype.clear = function(e, i, r) {
          var a = this.dom, o = this.ctx, s = a.width, l = a.height;
          i = i || this.clearColor;
          var u = this.motionBlur && !e, h = this.lastFrameAlpha, c = this.dpr, f = this;
          u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, s / c, l / c));
          var g = this.domBack;
          function d(A, p, v, y) {
            if (o.clearRect(A, p, v, y), i && i !== "transparent") {
              var m = void 0;
              if (s_(i)) {
                var _ = i.global || i.__width === v && i.__height === y;
                m = _ && i.__canvasGradient || GB(o, i, { x: 0, y: 0, width: v, height: y }), i.__canvasGradient = m, i.__width = v, i.__height = y;
              } else u0t(i) && (i.scaleX = i.scaleX || c, i.scaleY = i.scaleY || c, m = VB(o, i, { dirty: function() {
                f.setUnpainted(), f.painter.refresh();
              } }));
              o.save(), o.fillStyle = m || i, o.fillRect(A, p, v, y), o.restore();
            }
            u && (o.save(), o.globalAlpha = h, o.drawImage(g, A, p, v, y), o.restore());
          }
          !r || u ? d(0, 0, s, l) : r.length && M(r, function(A) {
            d(A.x * c, A.y * c, A.width * c, A.height * c);
          });
        }, t;
      }(aa), vV = 1e5, $h = 314159, gI = 0.01, WCt = 1e-3;
      function XCt(n) {
        return n ? n.__builtin__ ? true : !(typeof n.resize != "function" || typeof n.refresh != "function") : false;
      }
      function ZCt(n, t) {
        var e = document.createElement("div");
        return e.style.cssText = ["position:relative", "width:" + n + "px", "height:" + t + "px", "padding:0", "margin:0", "border-width:0"].join(";") + ";", e;
      }
      var KCt = function() {
        function n(t, e, i, r) {
          this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = false, this.type = "canvas";
          var a = !t.nodeName || t.nodeName.toUpperCase() === "CANVAS";
          this._opts = i = Y({}, i || {}), this.dpr = i.devicePixelRatio || N_, this._singleCanvas = a, this.root = t;
          var o = t.style;
          o && (Cz(t), t.innerHTML = ""), this.storage = e;
          var s = this._zlevelList;
          this._prevDisplayList = [];
          var l = this._layers;
          if (a) {
            var h = t, c = h.width, f = h.height;
            i.width != null && (c = i.width), i.height != null && (f = i.height), this.dpr = i.devicePixelRatio || 1, h.width = c * this.dpr, h.height = f * this.dpr, this._width = c, this._height = f;
            var g = new QT(h, this, this.dpr);
            g.__builtin__ = true, g.initContext(), l[$h] = g, g.zlevel = $h, s.push($h), this._domRoot = t;
          } else {
            this._width = jg(t, 0, i), this._height = jg(t, 1, i);
            var u = this._domRoot = ZCt(this._width, this._height);
            t.appendChild(u);
          }
        }
        return n.prototype.getType = function() {
          return "canvas";
        }, n.prototype.isSingleCanvas = function() {
          return this._singleCanvas;
        }, n.prototype.getViewportRoot = function() {
          return this._domRoot;
        }, n.prototype.getViewportRootOffset = function() {
          var t = this.getViewportRoot();
          if (t) return { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 };
        }, n.prototype.refresh = function(t) {
          var e = this.storage.getDisplayList(true), i = this._prevDisplayList, r = this._zlevelList;
          this._redrawId = Math.random(), this._paintList(e, i, t, this._redrawId);
          for (var a = 0; a < r.length; a++) {
            var o = r[a], s = this._layers[o];
            if (!s.__builtin__ && s.refresh) {
              var l = a === 0 ? this._backgroundColor : null;
              s.refresh(l);
            }
          }
          return this._opts.useDirtyRect && (this._prevDisplayList = e.slice()), this;
        }, n.prototype.refreshHover = function() {
          this._paintHoverList(this.storage.getDisplayList(false));
        }, n.prototype._paintHoverList = function(t) {
          var e = t.length, i = this._hoverlayer;
          if (i && i.clear(), !!e) {
            for (var r = { inHover: true, viewWidth: this._width, viewHeight: this._height }, a, o = 0; o < e; o++) {
              var s = t[o];
              s.__inHover && (i || (i = this._hoverlayer = this.getLayer(vV)), a || (a = i.ctx, a.save()), jh(a, s, r, o === e - 1));
            }
            a && a.restore();
          }
        }, n.prototype.getHoverLayer = function() {
          return this.getLayer(vV);
        }, n.prototype.paintOne = function(t, e) {
          d6(t, e);
        }, n.prototype._paintList = function(t, e, i, r) {
          if (this._redrawId === r) {
            i = i || false, this._updateLayerStatus(t);
            var a = this._doPaintList(t, e, i), o = a.finished, s = a.needsRefreshHover;
            if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(t), o) this.eachLayer(function(u) {
              u.afterBrush && u.afterBrush();
            });
            else {
              var l = this;
              y_(function() {
                l._paintList(t, e, i, r);
              });
            }
          }
        }, n.prototype._compositeManually = function() {
          var t = this.getLayer($h).ctx, e = this._domRoot.width, i = this._domRoot.height;
          t.clearRect(0, 0, e, i), this.eachBuiltinLayer(function(r) {
            r.virtual && t.drawImage(r.dom, 0, 0, e, i);
          });
        }, n.prototype._doPaintList = function(t, e, i) {
          for (var r = this, a = [], o = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
            var l = this._zlevelList[s], u = this._layers[l];
            u.__builtin__ && u !== this._hoverlayer && (u.__dirty || i) && a.push(u);
          }
          for (var h = true, c = false, f = function(A) {
            var p = a[A], v = p.ctx, y = o && p.createRepaintRects(t, e, g._width, g._height), m = i ? p.__startIndex : p.__drawIndex, _ = !i && p.incremental && Date.now, E = _ && Date.now(), I = p.zlevel === g._zlevelList[0] ? g._backgroundColor : null;
            if (p.__startIndex === p.__endIndex) p.clear(false, I, y);
            else if (m === p.__startIndex) {
              var x = t[m];
              (!x.incremental || !x.notClear || i) && p.clear(false, I, y);
            }
            m === -1 && (m = p.__startIndex);
            var w, C = function(T) {
              var D = { inHover: false, allClipped: false, prevEl: null, viewWidth: r._width, viewHeight: r._height };
              for (w = m; w < p.__endIndex; w++) {
                var R = t[w];
                if (R.__inHover && (c = true), r._doPaintEl(R, p, o, T, D, w === p.__endIndex - 1), _) {
                  var L = Date.now() - E;
                  if (L > 15) break;
                }
              }
              D.prevElClipPaths && v.restore();
            };
            if (y) if (y.length === 0) w = p.__endIndex;
            else for (var S = g.dpr, b = 0; b < y.length; ++b) {
              var B = y[b];
              v.save(), v.beginPath(), v.rect(B.x * S, B.y * S, B.width * S, B.height * S), v.clip(), C(B), v.restore();
            }
            else v.save(), C(), v.restore();
            p.__drawIndex = w, p.__drawIndex < p.__endIndex && (h = false);
          }, g = this, d = 0; d < a.length; d++) f(d);
          return ee.wxa && M(this._layers, function(A) {
            A && A.ctx && A.ctx.draw && A.ctx.draw();
          }), { finished: h, needsRefreshHover: c };
        }, n.prototype._doPaintEl = function(t, e, i, r, a, o) {
          var s = e.ctx;
          if (i) {
            var l = t.getPaintRect();
            (!r || l && l.intersect(r)) && (jh(s, t, a, o), t.setPrevPaintRect(l));
          } else jh(s, t, a, o);
        }, n.prototype.getLayer = function(t, e) {
          this._singleCanvas && !this._needsManuallyCompositing && (t = $h);
          var i = this._layers[t];
          return i || (i = new QT("zr_" + t, this, this.dpr), i.zlevel = t, i.__builtin__ = true, this._layerConfig[t] ? qt(i, this._layerConfig[t], true) : this._layerConfig[t - gI] && qt(i, this._layerConfig[t - gI], true), e && (i.virtual = e), this.insertLayer(t, i), i.initContext()), i;
        }, n.prototype.insertLayer = function(t, e) {
          var i = this._layers, r = this._zlevelList, a = r.length, o = this._domRoot, s = null, l = -1;
          if (i[t]) {
            za("ZLevel " + t + " has been used already");
            return;
          }
          if (!XCt(e)) {
            za("Layer of zlevel " + t + " is not valid");
            return;
          }
          if (a > 0 && t > r[0]) {
            for (l = 0; l < a - 1 && !(r[l] < t && r[l + 1] > t); l++) ;
            s = i[r[l]];
          }
          if (r.splice(l + 1, 0, t), i[t] = e, !e.virtual) if (s) {
            var u = s.dom;
            u.nextSibling ? o.insertBefore(e.dom, u.nextSibling) : o.appendChild(e.dom);
          } else o.firstChild ? o.insertBefore(e.dom, o.firstChild) : o.appendChild(e.dom);
          e.painter || (e.painter = this);
        }, n.prototype.eachLayer = function(t, e) {
          for (var i = this._zlevelList, r = 0; r < i.length; r++) {
            var a = i[r];
            t.call(e, this._layers[a], a);
          }
        }, n.prototype.eachBuiltinLayer = function(t, e) {
          for (var i = this._zlevelList, r = 0; r < i.length; r++) {
            var a = i[r], o = this._layers[a];
            o.__builtin__ && t.call(e, o, a);
          }
        }, n.prototype.eachOtherLayer = function(t, e) {
          for (var i = this._zlevelList, r = 0; r < i.length; r++) {
            var a = i[r], o = this._layers[a];
            o.__builtin__ || t.call(e, o, a);
          }
        }, n.prototype.getLayers = function() {
          return this._layers;
        }, n.prototype._updateLayerStatus = function(t) {
          this.eachBuiltinLayer(function(c, f) {
            c.__dirty = c.__used = false;
          });
          function e(c) {
            a && (a.__endIndex !== c && (a.__dirty = true), a.__endIndex = c);
          }
          if (this._singleCanvas) for (var i = 1; i < t.length; i++) {
            var r = t[i];
            if (r.zlevel !== t[i - 1].zlevel || r.incremental) {
              this._needsManuallyCompositing = true;
              break;
            }
          }
          var a = null, o = 0, s, l;
          for (l = 0; l < t.length; l++) {
            var r = t[l], u = r.zlevel, h = void 0;
            s !== u && (s = u, o = 0), r.incremental ? (h = this.getLayer(u + WCt, this._needsManuallyCompositing), h.incremental = true, o = 1) : h = this.getLayer(u + (o > 0 ? gI : 0), this._needsManuallyCompositing), h.__builtin__ || za("ZLevel " + u + " has been used by unkown layer " + h.id), h !== a && (h.__used = true, h.__startIndex !== l && (h.__dirty = true), h.__startIndex = l, h.incremental ? h.__drawIndex = -1 : h.__drawIndex = l, e(l), a = h), r.__dirty & Qr && !r.__inHover && (h.__dirty = true, h.incremental && h.__drawIndex < 0 && (h.__drawIndex = l));
          }
          e(l), this.eachBuiltinLayer(function(c, f) {
            !c.__used && c.getElementCount() > 0 && (c.__dirty = true, c.__startIndex = c.__endIndex = c.__drawIndex = 0), c.__dirty && c.__drawIndex < 0 && (c.__drawIndex = c.__startIndex);
          });
        }, n.prototype.clear = function() {
          return this.eachBuiltinLayer(this._clearLayer), this;
        }, n.prototype._clearLayer = function(t) {
          t.clear();
        }, n.prototype.setBackgroundColor = function(t) {
          this._backgroundColor = t, M(this._layers, function(e) {
            e.setUnpainted();
          });
        }, n.prototype.configLayer = function(t, e) {
          if (e) {
            var i = this._layerConfig;
            i[t] ? qt(i[t], e, true) : i[t] = e;
            for (var r = 0; r < this._zlevelList.length; r++) {
              var a = this._zlevelList[r];
              if (a === t || a === t + gI) {
                var o = this._layers[a];
                qt(o, i[t], true);
              }
            }
          }
        }, n.prototype.delLayer = function(t) {
          var e = this._layers, i = this._zlevelList, r = e[t];
          r && (r.dom.parentNode.removeChild(r.dom), delete e[t], i.splice(Wt(i, t), 1));
        }, n.prototype.resize = function(t, e) {
          if (this._domRoot.style) {
            var i = this._domRoot;
            i.style.display = "none";
            var r = this._opts, a = this.root;
            if (t != null && (r.width = t), e != null && (r.height = e), t = jg(a, 0, r), e = jg(a, 1, r), i.style.display = "", this._width !== t || e !== this._height) {
              i.style.width = t + "px", i.style.height = e + "px";
              for (var o in this._layers) this._layers.hasOwnProperty(o) && this._layers[o].resize(t, e);
              this.refresh(true);
            }
            this._width = t, this._height = e;
          } else {
            if (t == null || e == null) return;
            this._width = t, this._height = e, this.getLayer($h).resize(t, e);
          }
          return this;
        }, n.prototype.clearLayer = function(t) {
          var e = this._layers[t];
          e && e.clear();
        }, n.prototype.dispose = function() {
          this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
        }, n.prototype.getRenderedCanvas = function(t) {
          if (t = t || {}, this._singleCanvas && !this._compositeManually) return this._layers[$h].dom;
          var e = new QT("image", this, t.pixelRatio || this.dpr);
          e.initContext(), e.clear(false, t.backgroundColor || this._backgroundColor);
          var i = e.ctx;
          if (t.pixelRatio <= this.dpr) {
            this.refresh();
            var r = e.dom.width, a = e.dom.height;
            this.eachLayer(function(c) {
              c.__builtin__ ? i.drawImage(c.dom, 0, 0, r, a) : c.renderToCanvas && (i.save(), c.renderToCanvas(i), i.restore());
            });
          } else for (var o = { inHover: false, viewWidth: this._width, viewHeight: this._height }, s = this.storage.getDisplayList(true), l = 0, u = s.length; l < u; l++) {
            var h = s[l];
            jh(i, h, o, l === u - 1);
          }
          return e.dom;
        }, n.prototype.getWidth = function() {
          return this._width;
        }, n.prototype.getHeight = function() {
          return this._height;
        }, n;
      }();
      function $Ct(n) {
        n.registerPainter("canvas", KCt);
      }
      var JCt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.hasSymbolVisual = true, e;
        }
        return t.prototype.getInitialData = function(e) {
          if (true) {
            var i = e.coordinateSystem;
            if (i !== "polar" && i !== "cartesian2d") throw new Error("Line not support coordinateSystem besides cartesian and polar");
          }
          return zs(null, this, { useEncodeDefaulter: true });
        }, t.prototype.getLegendIcon = function(e) {
          var i = new Ct(), r = Nn("line", 0, e.itemHeight / 2, e.itemWidth, 0, e.lineStyle.stroke, false);
          i.add(r), r.setStyle(e.lineStyle);
          var a = this.getData().getVisual("symbol"), o = this.getData().getVisual("symbolRotate"), s = a === "none" ? "circle" : a, l = e.itemHeight * 0.8, u = Nn(s, (e.itemWidth - l) / 2, (e.itemHeight - l) / 2, l, l, e.itemStyle.fill);
          i.add(u), u.setStyle(e.itemStyle);
          var h = e.iconRotate === "inherit" ? o : e.iconRotate || 0;
          return u.rotation = h * Math.PI / 180, u.setOrigin([e.itemWidth / 2, e.itemHeight / 2]), s.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = "#fff", u.style.lineWidth = 2), i;
        }, t.type = "series.line", t.dependencies = ["grid", "polar"], t.defaultOption = { z: 3, coordinateSystem: "cartesian2d", legendHoverLink: true, clip: true, label: { position: "top" }, endLabel: { show: false, valueAnimation: true, distance: 8 }, lineStyle: { width: 2, type: "solid" }, emphasis: { scale: true }, step: false, smooth: false, smoothMonotone: null, symbol: "emptyCircle", symbolSize: 4, symbolRotate: null, showSymbol: true, showAllSymbol: "auto", connectNulls: false, sampling: "none", animationEasing: "linear", progressive: 0, hoverLayerThreshold: 1 / 0, universalTransition: { divideShape: "clone" }, triggerLineEvent: false }, t;
      }($e);
      function $g(n, t) {
        var e = n.mapDimensionsAll("defaultedLabel"), i = e.length;
        if (i === 1) {
          var r = Qg(n, t, e[0]);
          return r != null ? r + "" : null;
        } else if (i) {
          for (var a = [], o = 0; o < e.length; o++) a.push(Qg(n, t, e[o]));
          return a.join(" ");
        }
      }
      function yV(n, t) {
        var e = n.mapDimensionsAll("defaultedLabel");
        if (!X(t)) return t + "";
        for (var i = [], r = 0; r < e.length; r++) {
          var a = n.getDimensionIndex(e[r]);
          a >= 0 && i.push(t[a]);
        }
        return i.join(" ");
      }
      var Cv = function(n) {
        V(t, n);
        function t(e, i, r, a) {
          var o = n.call(this) || this;
          return o.updateData(e, i, r, a), o;
        }
        return t.prototype._createSymbol = function(e, i, r, a, o) {
          this.removeAll();
          var s = Nn(e, -1, -1, 2, 2, null, o);
          s.attr({ z2: 100, culling: true, scaleX: a[0] / 2, scaleY: a[1] / 2 }), s.drift = tSt, this._symbolType = e, this.add(s);
        }, t.prototype.stopSymbolAnimation = function(e) {
          this.childAt(0).stopAnimation(null, e);
        }, t.prototype.getSymbolType = function() {
          return this._symbolType;
        }, t.prototype.getSymbolPath = function() {
          return this.childAt(0);
        }, t.prototype.highlight = function() {
          Ps(this.childAt(0));
        }, t.prototype.downplay = function() {
          Ns(this.childAt(0));
        }, t.prototype.setZ = function(e, i) {
          var r = this.childAt(0);
          r.zlevel = e, r.z = i;
        }, t.prototype.setDraggable = function(e, i) {
          var r = this.childAt(0);
          r.draggable = e, r.cursor = !i && e ? "move" : r.cursor;
        }, t.prototype.updateData = function(e, i, r, a) {
          this.silent = false;
          var o = e.getItemVisual(i, "symbol") || "circle", s = e.hostModel, l = t.getSymbolSize(e, i), u = o !== this._symbolType, h = a && a.disableAnimation;
          if (u) {
            var c = e.getItemVisual(i, "symbolKeepAspect");
            this._createSymbol(o, e, i, l, c);
          } else {
            var f = this.childAt(0);
            f.silent = false;
            var g = { scaleX: l[0] / 2, scaleY: l[1] / 2 };
            h ? f.attr(g) : _e(f, g, s, i), Ya(f);
          }
          if (this._updateCommon(e, i, l, r, a), u) {
            var f = this.childAt(0);
            if (!h) {
              var g = { scaleX: this._sizeX, scaleY: this._sizeY, style: { opacity: f.style.opacity } };
              f.scaleX = f.scaleY = 0, f.style.opacity = 0, nn(f, g, s, i);
            }
          }
          h && this.childAt(0).stopAnimation("leave");
        }, t.prototype._updateCommon = function(e, i, r, a, o) {
          var s = this.childAt(0), l = e.hostModel, u, h, c, f, g, d, A, p, v;
          if (a && (u = a.emphasisItemStyle, h = a.blurItemStyle, c = a.selectItemStyle, f = a.focus, g = a.blurScope, A = a.labelStatesModels, p = a.hoverScale, v = a.cursorStyle, d = a.emphasisDisabled), !a || e.hasItemOption) {
            var y = a && a.itemModel ? a.itemModel : e.getItemModel(i), m = y.getModel("emphasis");
            u = m.getModel("itemStyle").getItemStyle(), c = y.getModel(["select", "itemStyle"]).getItemStyle(), h = y.getModel(["blur", "itemStyle"]).getItemStyle(), f = m.get("focus"), g = m.get("blurScope"), d = m.get("disabled"), A = Xn(y), p = m.getShallow("scale"), v = y.getShallow("cursor");
          }
          var _ = e.getItemVisual(i, "symbolRotate");
          s.attr("rotation", (_ || 0) * Math.PI / 180 || 0);
          var E = Uh(e.getItemVisual(i, "symbolOffset"), r);
          E && (s.x = E[0], s.y = E[1]), v && s.attr("cursor", v);
          var I = e.getItemVisual(i, "style"), x = I.fill;
          if (s instanceof li) {
            var w = s.style;
            s.useStyle(Y({ image: w.image, x: w.x, y: w.y, width: w.width, height: w.height }, I));
          } else s.__isEmptyBrush ? s.useStyle(Y({}, I)) : s.useStyle(I), s.style.decal = null, s.setColor(x, o && o.symbolInnerColor), s.style.strokeNoScale = true;
          var C = e.getItemVisual(i, "liftZ"), S = this._z2;
          C != null ? S == null && (this._z2 = s.z2, s.z2 += C) : S != null && (s.z2 = S, this._z2 = null);
          var b = o && o.useNameLabel;
          vi(s, A, { labelFetcher: l, labelDataIndex: i, defaultText: B, inheritColor: x, defaultOpacity: I.opacity });
          function B(R) {
            return b ? e.getName(R) : $g(e, R);
          }
          this._sizeX = r[0] / 2, this._sizeY = r[1] / 2;
          var T = s.ensureState("emphasis");
          T.style = u, s.ensureState("select").style = c, s.ensureState("blur").style = h;
          var D = p == null || p === true ? Math.max(1.1, 3 / this._sizeY) : isFinite(p) && p > 0 ? +p : 1;
          T.scaleX = this._sizeX * D, T.scaleY = this._sizeY * D, this.setSymbolScale(1), hn(this, f, g, d);
        }, t.prototype.setSymbolScale = function(e) {
          this.scaleX = this.scaleY = e;
        }, t.prototype.fadeOut = function(e, i, r) {
          var a = this.childAt(0), o = Dt(this).dataIndex, s = r && r.animation;
          if (this.silent = a.silent = true, r && r.fadeLabel) {
            var l = a.getTextContent();
            l && Jl(l, { style: { opacity: 0 } }, i, { dataIndex: o, removeOpt: s, cb: function() {
              a.removeTextContent();
            } });
          } else a.removeTextContent();
          Jl(a, { style: { opacity: 0 }, scaleX: 0, scaleY: 0 }, i, { dataIndex: o, cb: e, removeOpt: s });
        }, t.getSymbolSize = function(e, i) {
          return Vg(e.getItemVisual(i, "symbolSize"));
        }, t;
      }(Ct);
      function tSt(n, t) {
        this.parent.drift(n, t);
      }
      function OT(n, t, e, i) {
        return t && !isNaN(t[0]) && !isNaN(t[1]) && !(i.isIgnore && i.isIgnore(e)) && !(i.clipShape && !i.clipShape.contain(t[0], t[1])) && n.getItemVisual(e, "symbol") !== "none";
      }
      function mV(n) {
        return n != null && !_t(n) && (n = { isIgnore: n }), n || {};
      }
      function _V(n) {
        var t = n.hostModel, e = t.getModel("emphasis");
        return { emphasisItemStyle: e.getModel("itemStyle").getItemStyle(), blurItemStyle: t.getModel(["blur", "itemStyle"]).getItemStyle(), selectItemStyle: t.getModel(["select", "itemStyle"]).getItemStyle(), focus: e.get("focus"), blurScope: e.get("blurScope"), emphasisDisabled: e.get("disabled"), hoverScale: e.get("scale"), labelStatesModels: Xn(t), cursorStyle: t.get("cursor") };
      }
      var Sv = function() {
        function n(t) {
          this.group = new Ct(), this._SymbolCtor = t || Cv;
        }
        return n.prototype.updateData = function(t, e) {
          this._progressiveEls = null, e = mV(e);
          var i = this.group, r = t.hostModel, a = this._data, o = this._SymbolCtor, s = e.disableAnimation, l = _V(t), u = { disableAnimation: s }, h = e.getSymbolPoint || function(c) {
            return t.getItemLayout(c);
          };
          a || i.removeAll(), t.diff(a).add(function(c) {
            var f = h(c);
            if (OT(t, f, c, e)) {
              var g = new o(t, c, l, u);
              g.setPosition(f), t.setItemGraphicEl(c, g), i.add(g);
            }
          }).update(function(c, f) {
            var g = a.getItemGraphicEl(f), d = h(c);
            if (!OT(t, d, c, e)) {
              i.remove(g);
              return;
            }
            var A = t.getItemVisual(c, "symbol") || "circle", p = g && g.getSymbolType && g.getSymbolType();
            if (!g || p && p !== A) i.remove(g), g = new o(t, c, l, u), g.setPosition(d);
            else {
              g.updateData(t, c, l, u);
              var v = { x: d[0], y: d[1] };
              s ? g.attr(v) : _e(g, v, r);
            }
            i.add(g), t.setItemGraphicEl(c, g);
          }).remove(function(c) {
            var f = a.getItemGraphicEl(c);
            f && f.fadeOut(function() {
              i.remove(f);
            }, r);
          }).execute(), this._getSymbolPoint = h, this._data = t;
        }, n.prototype.updateLayout = function() {
          var t = this, e = this._data;
          e && e.eachItemGraphicEl(function(i, r) {
            var a = t._getSymbolPoint(r);
            i.setPosition(a), i.markRedraw();
          });
        }, n.prototype.incrementalPrepareUpdate = function(t) {
          this._seriesScope = _V(t), this._data = null, this.group.removeAll();
        }, n.prototype.incrementalUpdate = function(t, e, i) {
          this._progressiveEls = [], i = mV(i);
          function r(l) {
            l.isGroup || (l.incremental = true, l.ensureState("emphasis").hoverLayer = true);
          }
          for (var a = t.start; a < t.end; a++) {
            var o = e.getItemLayout(a);
            if (OT(e, o, a, i)) {
              var s = new this._SymbolCtor(e, a, this._seriesScope);
              s.traverse(r), s.setPosition(o), this.group.add(s), e.setItemGraphicEl(a, s), this._progressiveEls.push(s);
            }
          }
        }, n.prototype.eachRendered = function(t) {
          tu(this._progressiveEls || this.group, t);
        }, n.prototype.remove = function(t) {
          var e = this.group, i = this._data;
          i && t ? i.eachItemGraphicEl(function(r) {
            r.fadeOut(function() {
              e.remove(r);
            }, i.hostModel);
          }) : e.removeAll();
        }, n;
      }();
      function IV(n, t, e) {
        var i = n.getBaseAxis(), r = n.getOtherAxis(i), a = eSt(r, e), o = i.dim, s = r.dim, l = t.mapDimension(s), u = t.mapDimension(o), h = s === "x" || s === "radius" ? 1 : 0, c = Z(n.dimensions, function(d) {
          return t.mapDimension(d);
        }), f = false, g = t.getCalculationInfo("stackResultDimension");
        return lu(t, c[0]) && (f = true, c[0] = g), lu(t, c[1]) && (f = true, c[1] = g), { dataDimsForPoint: c, valueStart: a, valueAxisDim: s, baseAxisDim: o, stacked: !!f, valueDim: l, baseDim: u, baseDataOffset: h, stackedOverDimension: t.getCalculationInfo("stackedOverDimension") };
      }
      function eSt(n, t) {
        var e = 0, i = n.scale.getExtent();
        return t === "start" ? e = i[0] : t === "end" ? e = i[1] : pe(t) && !isNaN(t) ? e = t : i[0] > 0 ? e = i[0] : i[1] < 0 && (e = i[1]), e;
      }
      function EV(n, t, e, i) {
        var r = NaN;
        n.stacked && (r = e.get(e.getCalculationInfo("stackedOverDimension"), i)), isNaN(r) && (r = n.valueStart);
        var a = n.baseDataOffset, o = [];
        return o[a] = e.get(n.baseDim, i), o[1 - a] = r, t.dataToPoint(o);
      }
      function nSt(n, t) {
        var e = [];
        return t.diff(n).add(function(i) {
          e.push({ cmd: "+", idx: i });
        }).update(function(i, r) {
          e.push({ cmd: "=", idx: r, idx1: i });
        }).remove(function(i) {
          e.push({ cmd: "-", idx: i });
        }).execute(), e;
      }
      function iSt(n, t, e, i, r, a, o, s) {
        for (var l = nSt(n, t), u = [], h = [], c = [], f = [], g = [], d = [], A = [], p = IV(r, t, o), v = n.getLayout("points") || [], y = t.getLayout("points") || [], m = 0; m < l.length; m++) {
          var _ = l[m], E = true, I = void 0, x = void 0;
          switch (_.cmd) {
            case "=":
              I = _.idx * 2, x = _.idx1 * 2;
              var w = v[I], C = v[I + 1], S = y[x], b = y[x + 1];
              (isNaN(w) || isNaN(C)) && (w = S, C = b), u.push(w, C), h.push(S, b), c.push(e[I], e[I + 1]), f.push(i[x], i[x + 1]), A.push(t.getRawIndex(_.idx1));
              break;
            case "+":
              var B = _.idx, T = p.dataDimsForPoint, D = r.dataToPoint([t.get(T[0], B), t.get(T[1], B)]);
              x = B * 2, u.push(D[0], D[1]), h.push(y[x], y[x + 1]);
              var R = EV(p, r, t, B);
              c.push(R[0], R[1]), f.push(i[x], i[x + 1]), A.push(t.getRawIndex(B));
              break;
            case "-":
              E = false;
          }
          E && (g.push(_), d.push(d.length));
        }
        d.sort(function(tt, J) {
          return A[tt] - A[J];
        });
        for (var L = u.length, k = Uo(L), P = Uo(L), F = Uo(L), Q = Uo(L), z = [], m = 0; m < d.length; m++) {
          var j = d[m], $ = m * 2, G = j * 2;
          k[$] = u[G], k[$ + 1] = u[G + 1], P[$] = h[G], P[$ + 1] = h[G + 1], F[$] = c[G], F[$ + 1] = c[G + 1], Q[$] = f[G], Q[$ + 1] = f[G + 1], z[m] = g[j];
        }
        return { current: k, next: P, stackedOnCurrent: F, stackedOnNext: Q, status: z };
      }
      var uu = Math.min, hu = Math.max;
      function Jh(n, t) {
        return isNaN(n) || isNaN(t);
      }
      function zT(n, t, e, i, r, a, o, s, l) {
        for (var u, h, c, f, g, d, A = e, p = 0; p < i; p++) {
          var v = t[A * 2], y = t[A * 2 + 1];
          if (A >= r || A < 0) break;
          if (Jh(v, y)) {
            if (l) {
              A += a;
              continue;
            }
            break;
          }
          if (A === e) n[a > 0 ? "moveTo" : "lineTo"](v, y), c = v, f = y;
          else {
            var m = v - u, _ = y - h;
            if (m * m + _ * _ < 0.5) {
              A += a;
              continue;
            }
            if (o > 0) {
              for (var E = A + a, I = t[E * 2], x = t[E * 2 + 1]; I === v && x === y && p < i; ) p++, E += a, A += a, I = t[E * 2], x = t[E * 2 + 1], v = t[A * 2], y = t[A * 2 + 1], m = v - u, _ = y - h;
              var w = p + 1;
              if (l) for (; Jh(I, x) && w < i; ) w++, E += a, I = t[E * 2], x = t[E * 2 + 1];
              var C = 0.5, S = 0, b = 0, B = void 0, T = void 0;
              if (w >= i || Jh(I, x)) g = v, d = y;
              else {
                S = I - u, b = x - h;
                var D = v - u, R = I - v, L = y - h, k = x - y, P = void 0, F = void 0;
                if (s === "x") {
                  P = Math.abs(D), F = Math.abs(R);
                  var Q = S > 0 ? 1 : -1;
                  g = v - Q * P * o, d = y, B = v + Q * F * o, T = y;
                } else if (s === "y") {
                  P = Math.abs(L), F = Math.abs(k);
                  var z = b > 0 ? 1 : -1;
                  g = v, d = y - z * P * o, B = v, T = y + z * F * o;
                } else P = Math.sqrt(D * D + L * L), F = Math.sqrt(R * R + k * k), C = F / (F + P), g = v - S * o * (1 - C), d = y - b * o * (1 - C), B = v + S * o * C, T = y + b * o * C, B = uu(B, hu(I, v)), T = uu(T, hu(x, y)), B = hu(B, uu(I, v)), T = hu(T, uu(x, y)), S = B - v, b = T - y, g = v - S * P / F, d = y - b * P / F, g = uu(g, hu(u, v)), d = uu(d, hu(h, y)), g = hu(g, uu(u, v)), d = hu(d, uu(h, y)), S = v - g, b = y - d, B = v + S * F / P, T = y + b * F / P;
              }
              n.bezierCurveTo(c, f, g, d, v, y), c = B, f = T;
            } else n.lineTo(v, y);
          }
          u = v, h = y, A += a;
        }
        return p;
      }
      var xV = /* @__PURE__ */ function() {
        function n() {
          this.smooth = 0, this.smoothConstraint = true;
        }
        return n;
      }(), rSt = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "ec-polyline", i;
        }
        return t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new xV();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.points, a = 0, o = r.length / 2;
          if (i.connectNulls) {
            for (; o > 0 && Jh(r[o * 2 - 2], r[o * 2 - 1]); o--) ;
            for (; a < o && Jh(r[a * 2], r[a * 2 + 1]); a++) ;
          }
          for (; a < o; ) a += zT(e, r, a, o, o, 1, i.smooth, i.smoothMonotone, i.connectNulls) + 1;
        }, t.prototype.getPointOn = function(e, i) {
          this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
          for (var r = this.path, a = r.data, o = ko.CMD, s, l, u = i === "x", h = [], c = 0; c < a.length; ) {
            var f = a[c++], g = void 0, d = void 0, A = void 0, p = void 0, v = void 0, y = void 0, m = void 0;
            switch (f) {
              case o.M:
                s = a[c++], l = a[c++];
                break;
              case o.L:
                if (g = a[c++], d = a[c++], m = u ? (e - s) / (g - s) : (e - l) / (d - l), m <= 1 && m >= 0) {
                  var _ = u ? (d - l) * m + l : (g - s) * m + s;
                  return u ? [e, _] : [_, e];
                }
                s = g, l = d;
                break;
              case o.C:
                g = a[c++], d = a[c++], A = a[c++], p = a[c++], v = a[c++], y = a[c++];
                var E = u ? E_(s, g, A, v, e, h) : E_(l, d, p, y, e, h);
                if (E > 0) for (var I = 0; I < E; I++) {
                  var x = h[I];
                  if (x <= 1 && x >= 0) {
                    var _ = u ? Yn(l, d, p, y, x) : Yn(s, g, A, v, x);
                    return u ? [e, _] : [_, e];
                  }
                }
                s = v, l = y;
                break;
            }
          }
        }, t;
      }(Jt), aSt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t;
      }(xV), wV = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "ec-polygon", i;
        }
        return t.prototype.getDefaultShape = function() {
          return new aSt();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.points, a = i.stackedOnPoints, o = 0, s = r.length / 2, l = i.smoothMonotone;
          if (i.connectNulls) {
            for (; s > 0 && Jh(r[s * 2 - 2], r[s * 2 - 1]); s--) ;
            for (; o < s && Jh(r[o * 2], r[o * 2 + 1]); o++) ;
          }
          for (; o < s; ) {
            var u = zT(e, r, o, s, s, 1, i.smooth, l, i.connectNulls);
            zT(e, a, o + u - 1, u, s, -1, i.stackedOnSmooth, l, i.connectNulls), o += u + 1, e.closePath();
          }
        }, t;
      }(Jt);
      function CV(n, t, e, i, r) {
        var a = n.getArea(), o = a.x, s = a.y, l = a.width, u = a.height, h = e.get(["lineStyle", "width"]) || 2;
        o -= h / 2, s -= h / 2, l += h, u += h, l = Math.ceil(l), o !== Math.floor(o) && (o = Math.floor(o), l++);
        var c = new ue({ shape: { x: o, y: s, width: l, height: u } });
        if (t) {
          var f = n.getBaseAxis(), g = f.isHorizontal(), d = f.inverse;
          g ? (d && (c.shape.x += l), c.shape.width = 0) : (d || (c.shape.y += u), c.shape.height = 0);
          var A = yt(r) ? function(p) {
            r(p, c);
          } : null;
          nn(c, { shape: { width: l, height: u, x: o, y: s } }, e, null, i, A);
        }
        return c;
      }
      function SV(n, t, e) {
        var i = n.getArea(), r = vn(i.r0, 1), a = vn(i.r, 1), o = new Hi({ shape: { cx: vn(n.cx, 1), cy: vn(n.cy, 1), r0: r, r: a, startAngle: i.startAngle, endAngle: i.endAngle, clockwise: i.clockwise } });
        if (t) {
          var s = n.getBaseAxis().dim === "angle";
          s ? o.shape.endAngle = i.startAngle : o.shape.r = r, nn(o, { shape: { endAngle: i.endAngle, r: a } }, e);
        }
        return o;
      }
      function bv(n, t, e, i, r) {
        if (n) {
          if (n.type === "polar") return SV(n, t, e);
          if (n.type === "cartesian2d") return CV(n, t, e, i, r);
        } else return null;
        return null;
      }
      function tc(n, t) {
        return n.type === t;
      }
      function bV(n, t) {
        if (n.length === t.length) {
          for (var e = 0; e < n.length; e++) if (n[e] !== t[e]) return;
          return true;
        }
      }
      function BV(n) {
        for (var t = 1 / 0, e = 1 / 0, i = -1 / 0, r = -1 / 0, a = 0; a < n.length; ) {
          var o = n[a++], s = n[a++];
          isNaN(o) || (t = Math.min(o, t), i = Math.max(o, i)), isNaN(s) || (e = Math.min(s, e), r = Math.max(s, r));
        }
        return [[t, e], [i, r]];
      }
      function TV(n, t) {
        var e = BV(n), i = e[0], r = e[1], a = BV(t), o = a[0], s = a[1];
        return Math.max(Math.abs(i[0] - o[0]), Math.abs(i[1] - o[1]), Math.abs(r[0] - s[0]), Math.abs(r[1] - s[1]));
      }
      function MV(n) {
        return pe(n) ? n : n ? 0.5 : 0;
      }
      function oSt(n, t, e) {
        if (!e.valueDim) return [];
        for (var i = t.count(), r = Uo(i * 2), a = 0; a < i; a++) {
          var o = EV(e, n, t, a);
          r[a * 2] = o[0], r[a * 2 + 1] = o[1];
        }
        return r;
      }
      function cu(n, t, e, i) {
        var r = t.getBaseAxis(), a = r.dim === "x" || r.dim === "radius" ? 0 : 1, o = [], s = 0, l = [], u = [], h = [], c = [];
        if (i) {
          for (s = 0; s < n.length; s += 2) !isNaN(n[s]) && !isNaN(n[s + 1]) && c.push(n[s], n[s + 1]);
          n = c;
        }
        for (s = 0; s < n.length - 2; s += 2) switch (h[0] = n[s + 2], h[1] = n[s + 3], u[0] = n[s], u[1] = n[s + 1], o.push(u[0], u[1]), e) {
          case "end":
            l[a] = h[a], l[1 - a] = u[1 - a], o.push(l[0], l[1]);
            break;
          case "middle":
            var f = (u[a] + h[a]) / 2, g = [];
            l[a] = g[a] = f, l[1 - a] = u[1 - a], g[1 - a] = h[1 - a], o.push(l[0], l[1]), o.push(g[0], g[1]);
            break;
          default:
            l[a] = u[a], l[1 - a] = h[1 - a], o.push(l[0], l[1]);
        }
        return o.push(n[s++], n[s++]), o;
      }
      function sSt(n, t) {
        var e = [], i = n.length, r, a;
        function o(h, c, f) {
          var g = h.coord, d = (f - g) / (c.coord - g), A = Y0t(d, [h.color, c.color]);
          return { coord: f, color: A };
        }
        for (var s = 0; s < i; s++) {
          var l = n[s], u = l.coord;
          if (u < 0) r = l;
          else if (u > t) {
            a ? e.push(o(a, l, t)) : r && e.push(o(r, l, 0), o(r, l, t));
            break;
          } else r && (e.push(o(r, l, 0)), r = null), e.push(l), a = l;
        }
        return e;
      }
      function lSt(n, t, e) {
        var i = n.getVisual("visualMeta");
        if (!(!i || !i.length || !n.count())) {
          if (t.type !== "cartesian2d") {
            return;
          }
          for (var r, a, o = i.length - 1; o >= 0; o--) {
            var s = n.getDimensionInfo(i[o].dimension);
            if (r = s && s.coordDim, r === "x" || r === "y") {
              a = i[o];
              break;
            }
          }
          if (!a) {
            return;
          }
          var l = t.getAxis(r), u = Z(a.stops, function(m) {
            return { coord: l.toGlobalCoord(l.dataToCoord(m.value)), color: m.color };
          }), h = u.length, c = a.outerColors.slice();
          h && u[0].coord > u[h - 1].coord && (u.reverse(), c.reverse());
          var f = sSt(u, r === "x" ? e.getWidth() : e.getHeight()), g = f.length;
          if (!g && h) return u[0].coord < 0 ? c[1] ? c[1] : u[h - 1].color : c[0] ? c[0] : u[0].color;
          var d = 10, A = f[0].coord - d, p = f[g - 1].coord + d, v = p - A;
          if (v < 1e-3) return "transparent";
          M(f, function(m) {
            m.offset = (m.coord - A) / v;
          }), f.push({ offset: g ? f[g - 1].offset : 0.5, color: c[1] || "transparent" }), f.unshift({ offset: g ? f[0].offset : 0.5, color: c[0] || "transparent" });
          var y = new Vp(0, 0, 0, 0, f, true);
          return y[r] = A, y[r + "2"] = p, y;
        }
      }
      function uSt(n, t, e) {
        var i = n.get("showAllSymbol"), r = i === "auto";
        if (!(i && !r)) {
          var a = e.getAxesByScale("ordinal")[0];
          if (a && !(r && hSt(a, t))) {
            var o = t.mapDimension(a.dim), s = {};
            return M(a.getViewLabels(), function(l) {
              var u = a.scale.getRawOrdinalNumber(l.tickValue);
              s[u] = 1;
            }), function(l) {
              return !s.hasOwnProperty(t.get(o, l));
            };
          }
        }
      }
      function hSt(n, t) {
        var e = n.getExtent(), i = Math.abs(e[1] - e[0]) / n.scale.count();
        isNaN(i) && (i = 0);
        for (var r = t.count(), a = Math.max(1, Math.round(r / 5)), o = 0; o < r; o += a) if (Cv.getSymbolSize(t, o)[n.isHorizontal() ? 1 : 0] * 1.5 > i) return false;
        return true;
      }
      function cSt(n, t) {
        return isNaN(n) || isNaN(t);
      }
      function fSt(n) {
        for (var t = n.length / 2; t > 0 && cSt(n[t * 2 - 2], n[t * 2 - 1]); t--) ;
        return t - 1;
      }
      function DV(n, t) {
        return [n[t * 2], n[t * 2 + 1]];
      }
      function gSt(n, t, e) {
        for (var i = n.length / 2, r = e === "x" ? 0 : 1, a, o, s = 0, l = -1, u = 0; u < i; u++) if (o = n[u * 2 + r], !(isNaN(o) || isNaN(n[u * 2 + 1 - r]))) {
          if (u === 0) {
            a = o;
            continue;
          }
          if (a <= t && o >= t || a >= t && o <= t) {
            l = u;
            break;
          }
          s = u, a = o;
        }
        return { range: [s, l], t: (t - a) / (o - a) };
      }
      function RV(n) {
        if (n.get(["endLabel", "show"])) return true;
        for (var t = 0; t < qi.length; t++) if (n.get([qi[t], "endLabel", "show"])) return true;
        return false;
      }
      function GT(n, t, e, i) {
        if (tc(t, "cartesian2d")) {
          var r = i.getModel("endLabel"), a = r.get("valueAnimation"), o = i.getData(), s = { lastFrameIndex: 0 }, l = RV(i) ? function(g, d) {
            n._endLabelOnDuring(g, d, o, s, a, r, t);
          } : null, u = t.getBaseAxis().isHorizontal(), h = CV(t, e, i, function() {
            var g = n._endLabel;
            g && e && s.originalX != null && g.attr({ x: s.originalX, y: s.originalY });
          }, l);
          if (!i.get("clip", true)) {
            var c = h.shape, f = Math.max(c.width, c.height);
            u ? (c.y -= f, c.height += f * 2) : (c.x -= f, c.width += f * 2);
          }
          return l && l(1, h), h;
        } else return i.get(["endLabel", "show"]), SV(t, e, i);
      }
      function dSt(n, t) {
        var e = t.getBaseAxis(), i = e.isHorizontal(), r = e.inverse, a = i ? r ? "right" : "left" : "center", o = i ? "middle" : r ? "top" : "bottom";
        return { normal: { align: n.get("align") || a, verticalAlign: n.get("verticalAlign") || o } };
      }
      var ASt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.init = function() {
          var e = new Ct(), i = new Sv();
          this.group.add(i.group), this._symbolDraw = i, this._lineGroup = e;
        }, t.prototype.render = function(e, i, r) {
          var a = this, o = e.coordinateSystem, s = this.group, l = e.getData(), u = e.getModel("lineStyle"), h = e.getModel("areaStyle"), c = l.getLayout("points") || [], f = o.type === "polar", g = this._coordSys, d = this._symbolDraw, A = this._polyline, p = this._polygon, v = this._lineGroup, y = !i.ssr && e.get("animation"), m = !h.isEmpty(), _ = h.get("origin"), E = IV(o, l, _), I = m && oSt(o, l, E), x = e.get("showSymbol"), w = e.get("connectNulls"), C = x && !f && uSt(e, l, o), S = this._data;
          S && S.eachItemGraphicEl(function(J, et) {
            J.__temp && (s.remove(J), S.setItemGraphicEl(et, null));
          }), x || d.remove(), s.add(v);
          var b = f ? false : e.get("step"), B;
          o && o.getArea && e.get("clip", true) && (B = o.getArea(), B.width != null ? (B.x -= 0.1, B.y -= 0.1, B.width += 0.2, B.height += 0.2) : B.r0 && (B.r0 -= 0.5, B.r += 0.5)), this._clipShapeForSymbol = B;
          var T = lSt(l, o, r) || l.getVisual("style")[l.getVisual("drawType")];
          if (!(A && g.type === o.type && b === this._step)) x && d.updateData(l, { isIgnore: C, clipShape: B, disableAnimation: true, getSymbolPoint: function(J) {
            return [c[J * 2], c[J * 2 + 1]];
          } }), y && this._initSymbolLabelAnimation(l, o, B), b && (c = cu(c, o, b, w), I && (I = cu(I, o, b, w))), A = this._newPolyline(c), m ? p = this._newPolygon(c, I) : p && (v.remove(p), p = this._polygon = null), f || this._initOrUpdateEndLabel(e, o, Nh(T)), v.setClipPath(GT(this, o, true, e));
          else {
            m && !p ? p = this._newPolygon(c, I) : p && !m && (v.remove(p), p = this._polygon = null), f || this._initOrUpdateEndLabel(e, o, Nh(T));
            var D = v.getClipPath();
            if (D) {
              var R = GT(this, o, false, e);
              nn(D, { shape: R.shape }, e);
            } else v.setClipPath(GT(this, o, true, e));
            x && d.updateData(l, { isIgnore: C, clipShape: B, disableAnimation: true, getSymbolPoint: function(J) {
              return [c[J * 2], c[J * 2 + 1]];
            } }), (!bV(this._stackedOnPoints, I) || !bV(this._points, c)) && (y ? this._doUpdateAnimation(l, I, o, r, b, _, w) : (b && (c = cu(c, o, b, w), I && (I = cu(I, o, b, w))), A.setShape({ points: c }), p && p.setShape({ points: c, stackedOnPoints: I })));
          }
          var L = e.getModel("emphasis"), k = L.get("focus"), P = L.get("blurScope"), F = L.get("disabled");
          if (A.useStyle(Et(u.getLineStyle(), { fill: "none", stroke: T, lineJoin: "bevel" })), pi(A, e, "lineStyle"), A.style.lineWidth > 0 && e.get(["emphasis", "lineStyle", "width"]) === "bolder") {
            var Q = A.getState("emphasis").style;
            Q.lineWidth = +A.style.lineWidth + 1;
          }
          Dt(A).seriesIndex = e.seriesIndex, hn(A, k, P, F);
          var z = MV(e.get("smooth")), j = e.get("smoothMonotone");
          if (A.setShape({ smooth: z, smoothMonotone: j, connectNulls: w }), p) {
            var $ = l.getCalculationInfo("stackedOnSeries"), G = 0;
            p.useStyle(Et(h.getAreaStyle(), { fill: T, opacity: 0.7, lineJoin: "bevel", decal: l.getVisual("style").decal })), $ && (G = MV($.get("smooth"))), p.setShape({ smooth: z, stackedOnSmooth: G, smoothMonotone: j, connectNulls: w }), pi(p, e, "areaStyle"), Dt(p).seriesIndex = e.seriesIndex, hn(p, k, P, F);
          }
          var tt = function(J) {
            a._changePolyState(J);
          };
          l.eachItemGraphicEl(function(J) {
            J && (J.onHoverStateChange = tt);
          }), this._polyline.onHoverStateChange = tt, this._data = l, this._coordSys = o, this._stackedOnPoints = I, this._points = c, this._step = b, this._valueOrigin = _, e.get("triggerLineEvent") && (this.packEventData(e, A), p && this.packEventData(e, p));
        }, t.prototype.packEventData = function(e, i) {
          Dt(i).eventData = { componentType: "series", componentSubType: "line", componentIndex: e.componentIndex, seriesIndex: e.seriesIndex, seriesName: e.name, seriesType: "line" };
        }, t.prototype.highlight = function(e, i, r, a) {
          var o = e.getData(), s = Ah(o, a);
          if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) {
            var l = o.getLayout("points"), u = o.getItemGraphicEl(s);
            if (!u) {
              var h = l[s * 2], c = l[s * 2 + 1];
              if (isNaN(h) || isNaN(c) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(h, c)) return;
              var f = e.get("zlevel") || 0, g = e.get("z") || 0;
              u = new Cv(o, s), u.x = h, u.y = c, u.setZ(f, g);
              var d = u.getSymbolPath().getTextContent();
              d && (d.zlevel = f, d.z = g, d.z2 = this._polyline.z2 + 1), u.__temp = true, o.setItemGraphicEl(s, u), u.stopSymbolAnimation(true), this.group.add(u);
            }
            u.highlight();
          } else Ve.prototype.highlight.call(this, e, i, r, a);
        }, t.prototype.downplay = function(e, i, r, a) {
          var o = e.getData(), s = Ah(o, a);
          if (this._changePolyState("normal"), s != null && s >= 0) {
            var l = o.getItemGraphicEl(s);
            l && (l.__temp ? (o.setItemGraphicEl(s, null), this.group.remove(l)) : l.downplay());
          } else Ve.prototype.downplay.call(this, e, i, r, a);
        }, t.prototype._changePolyState = function(e) {
          var i = this._polygon;
          J_(this._polyline, e), i && J_(i, e);
        }, t.prototype._newPolyline = function(e) {
          var i = this._polyline;
          return i && this._lineGroup.remove(i), i = new rSt({ shape: { points: e }, segmentIgnoreThreshold: 2, z2: 10 }), this._lineGroup.add(i), this._polyline = i, i;
        }, t.prototype._newPolygon = function(e, i) {
          var r = this._polygon;
          return r && this._lineGroup.remove(r), r = new wV({ shape: { points: e, stackedOnPoints: i }, segmentIgnoreThreshold: 2 }), this._lineGroup.add(r), this._polygon = r, r;
        }, t.prototype._initSymbolLabelAnimation = function(e, i, r) {
          var a, o, s = i.getBaseAxis(), l = s.inverse;
          i.type === "cartesian2d" ? (a = s.isHorizontal(), o = false) : i.type === "polar" && (a = s.dim === "angle", o = true);
          var u = e.hostModel, h = u.get("animationDuration");
          yt(h) && (h = h(null));
          var c = u.get("animationDelay") || 0, f = yt(c) ? c(null) : c;
          e.eachItemGraphicEl(function(g, d) {
            var A = g;
            if (A) {
              var p = [g.x, g.y], v = void 0, y = void 0, m = void 0;
              if (r) if (o) {
                var _ = r, E = i.pointToCoord(p);
                a ? (v = _.startAngle, y = _.endAngle, m = -E[1] / 180 * Math.PI) : (v = _.r0, y = _.r, m = E[0]);
              } else {
                var I = r;
                a ? (v = I.x, y = I.x + I.width, m = g.x) : (v = I.y + I.height, y = I.y, m = g.y);
              }
              var x = y === v ? 0 : (m - v) / (y - v);
              l && (x = 1 - x);
              var w = yt(c) ? c(d) : h * x + f, C = A.getSymbolPath(), S = C.getTextContent();
              A.attr({ scaleX: 0, scaleY: 0 }), A.animateTo({ scaleX: 1, scaleY: 1 }, { duration: 200, setToFinal: true, delay: w }), S && S.animateFrom({ style: { opacity: 0 } }, { duration: 300, delay: w }), C.disableLabelAnimation = true;
            }
          });
        }, t.prototype._initOrUpdateEndLabel = function(e, i, r) {
          var a = e.getModel("endLabel");
          if (RV(e)) {
            var o = e.getData(), s = this._polyline, l = o.getLayout("points");
            if (!l) {
              s.removeTextContent(), this._endLabel = null;
              return;
            }
            var u = this._endLabel;
            u || (u = this._endLabel = new ge({ z2: 200 }), u.ignoreClip = true, s.setTextContent(this._endLabel), s.disableLabelAnimation = true);
            var h = fSt(l);
            h >= 0 && (vi(s, Xn(e, "endLabel"), { inheritColor: r, labelFetcher: e, labelDataIndex: h, defaultText: function(c, f, g) {
              return g != null ? yV(o, g) : $g(o, c);
            }, enableTextSetter: true }, dSt(a, i)), s.textConfig.position = null);
          } else this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
        }, t.prototype._endLabelOnDuring = function(e, i, r, a, o, s, l) {
          var u = this._endLabel, h = this._polyline;
          if (u) {
            e < 1 && a.originalX == null && (a.originalX = u.x, a.originalY = u.y);
            var c = r.getLayout("points"), f = r.hostModel, g = f.get("connectNulls"), d = s.get("precision"), A = s.get("distance") || 0, p = l.getBaseAxis(), v = p.isHorizontal(), y = p.inverse, m = i.shape, _ = y ? v ? m.x : m.y + m.height : v ? m.x + m.width : m.y, E = (v ? A : 0) * (y ? -1 : 1), I = (v ? 0 : -A) * (y ? -1 : 1), x = v ? "x" : "y", w = gSt(c, _, x), C = w.range, S = C[1] - C[0], b = void 0;
            if (S >= 1) {
              if (S > 1 && !g) {
                var B = DV(c, C[0]);
                u.attr({ x: B[0] + E, y: B[1] + I }), o && (b = f.getRawValue(C[0]));
              } else {
                var B = h.getPointOn(_, x);
                B && u.attr({ x: B[0] + E, y: B[1] + I });
                var T = f.getRawValue(C[0]), D = f.getRawValue(C[1]);
                o && (b = jG(r, d, T, D, w.t));
              }
              a.lastFrameIndex = C[0];
            } else {
              var R = e === 1 || a.lastFrameIndex > 0 ? C[0] : 0, B = DV(c, R);
              o && (b = f.getRawValue(R)), u.attr({ x: B[0] + E, y: B[1] + I });
            }
            if (o) {
              var L = Bg(u);
              typeof L.setLabelText == "function" && L.setLabelText(b);
            }
          }
        }, t.prototype._doUpdateAnimation = function(e, i, r, a, o, s, l) {
          var u = this._polyline, h = this._polygon, c = e.hostModel, f = iSt(this._data, e, this._stackedOnPoints, i, this._coordSys, r, this._valueOrigin), g = f.current, d = f.stackedOnCurrent, A = f.next, p = f.stackedOnNext;
          if (o && (g = cu(f.current, r, o, l), d = cu(f.stackedOnCurrent, r, o, l), A = cu(f.next, r, o, l), p = cu(f.stackedOnNext, r, o, l)), TV(g, A) > 3e3 || h && TV(d, p) > 3e3) {
            u.stopAnimation(), u.setShape({ points: A }), h && (h.stopAnimation(), h.setShape({ points: A, stackedOnPoints: p }));
            return;
          }
          u.shape.__points = f.current, u.shape.points = g;
          var v = { shape: { points: A } };
          f.current !== g && (v.shape.__points = f.next), u.stopAnimation(), _e(u, v, c), h && (h.setShape({ points: g, stackedOnPoints: d }), h.stopAnimation(), _e(h, { shape: { stackedOnPoints: p } }, c), u.shape.points !== h.shape.points && (h.shape.points = u.shape.points));
          for (var y = [], m = f.status, _ = 0; _ < m.length; _++) {
            var E = m[_].cmd;
            if (E === "=") {
              var I = e.getItemGraphicEl(m[_].idx1);
              I && y.push({ el: I, ptIdx: _ });
            }
          }
          u.animators && u.animators.length && u.animators[0].during(function() {
            h && h.dirtyShape();
            for (var x = u.shape.__points, w = 0; w < y.length; w++) {
              var C = y[w].el, S = y[w].ptIdx * 2;
              C.x = x[S], C.y = x[S + 1], C.markRedraw();
            }
          });
        }, t.prototype.remove = function(e) {
          var i = this.group, r = this._data;
          this._lineGroup.removeAll(), this._symbolDraw.remove(true), r && r.eachItemGraphicEl(function(a, o) {
            a.__temp && (i.remove(a), r.setItemGraphicEl(o, null));
          }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
        }, t.type = "line", t;
      }(Ve);
      function Bv(n, t) {
        return { seriesType: n, plan: zg(), reset: function(e) {
          var i = e.getData(), r = e.coordinateSystem, a = e.pipelineContext, o = t || a.large;
          if (r) {
            var s = Z(r.dimensions, function(g) {
              return i.mapDimension(g);
            }).slice(0, 2), l = s.length, u = i.getCalculationInfo("stackResultDimension");
            lu(i, s[0]) && (s[0] = u), lu(i, s[1]) && (s[1] = u);
            var h = i.getStore(), c = i.getDimensionIndex(s[0]), f = i.getDimensionIndex(s[1]);
            return l && { progress: function(g, d) {
              for (var A = g.end - g.start, p = o && Uo(A * l), v = [], y = [], m = g.start, _ = 0; m < g.end; m++) {
                var E = void 0;
                if (l === 1) {
                  var I = h.get(c, m);
                  E = r.dataToPoint(I, null, y);
                } else v[0] = h.get(c, m), v[1] = h.get(f, m), E = r.dataToPoint(v, null, y);
                o ? (p[_++] = E[0], p[_++] = E[1]) : d.setItemLayout(m, E.slice());
              }
              o && d.setLayout("points", p);
            } };
          }
        } };
      }
      var pSt = { average: function(n) {
        for (var t = 0, e = 0, i = 0; i < n.length; i++) isNaN(n[i]) || (t += n[i], e++);
        return e === 0 ? NaN : t / e;
      }, sum: function(n) {
        for (var t = 0, e = 0; e < n.length; e++) t += n[e] || 0;
        return t;
      }, max: function(n) {
        for (var t = -1 / 0, e = 0; e < n.length; e++) n[e] > t && (t = n[e]);
        return isFinite(t) ? t : NaN;
      }, min: function(n) {
        for (var t = 1 / 0, e = 0; e < n.length; e++) n[e] < t && (t = n[e]);
        return isFinite(t) ? t : NaN;
      }, minmax: function(n) {
        for (var t = -1 / 0, e = -1 / 0, i = 0; i < n.length; i++) {
          var r = n[i], a = Math.abs(r);
          a > t && (t = a, e = r);
        }
        return isFinite(e) ? e : NaN;
      }, nearest: function(n) {
        return n[0];
      } }, vSt = function(n) {
        return Math.round(n.length / 2);
      };
      function LV(n) {
        return { seriesType: n, reset: function(t, e, i) {
          var r = t.getData(), a = t.get("sampling"), o = t.coordinateSystem, s = r.count();
          if (s > 10 && o.type === "cartesian2d" && a) {
            var l = o.getBaseAxis(), u = o.getOtherAxis(l), h = l.getExtent(), c = i.getDevicePixelRatio(), f = Math.abs(h[1] - h[0]) * (c || 1), g = Math.round(s / f);
            if (isFinite(g) && g > 1) {
              a === "lttb" && t.setData(r.lttbDownSample(r.mapDimension(u.dim), 1 / g));
              var d = void 0;
              ht(a) ? d = pSt[a] : yt(a) && (d = a), d && t.setData(r.downSample(r.mapDimension(u.dim), 1 / g, d, vSt));
            }
          }
        } };
      }
      function ySt(n) {
        n.registerChartView(ASt), n.registerSeriesModel(JCt), n.registerLayout(Bv("line", true)), n.registerVisual({ seriesType: "line", reset: function(t) {
          var e = t.getData(), i = t.getModel("lineStyle").getLineStyle();
          i && !i.stroke && (i.stroke = e.getVisual("style").fill), e.setVisual("legendLineStyle", i);
        } }), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, LV("line"));
      }
      var Tv = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.getInitialData = function(e, i) {
          return zs(null, this, { useEncodeDefaulter: true });
        }, t.prototype.getMarkerPosition = function(e, i, r) {
          var a = this.coordinateSystem;
          if (a && a.clampData) {
            var o = a.clampData(e), s = a.dataToPoint(o);
            if (r) M(a.getAxes(), function(f, g) {
              if (f.type === "category" && i != null) {
                var d = f.getTicksCoords(), A = f.getTickModel().get("alignWithLabel"), p = o[g], v = i[g] === "x1" || i[g] === "y1";
                if (v && !A && (p += 1), d.length < 2) return;
                if (d.length === 2) {
                  s[g] = f.toGlobalCoord(f.getExtent()[v ? 1 : 0]);
                  return;
                }
                for (var y = void 0, m = void 0, _ = 1, E = 0; E < d.length; E++) {
                  var I = d[E].coord, x = E === d.length - 1 ? d[E - 1].tickValue + _ : d[E].tickValue;
                  if (x === p) {
                    m = I;
                    break;
                  } else if (x < p) y = I;
                  else if (y != null && x > p) {
                    m = (I + y) / 2;
                    break;
                  }
                  E === 1 && (_ = x - d[0].tickValue);
                }
                m == null && (y ? y && (m = d[d.length - 1].coord) : m = d[0].coord), s[g] = f.toGlobalCoord(m);
              }
            });
            else {
              var l = this.getData(), u = l.getLayout("offset"), h = l.getLayout("size"), c = a.getBaseAxis().isHorizontal() ? 0 : 1;
              s[c] += u + h / 2;
            }
            return s;
          }
          return [NaN, NaN];
        }, t.type = "series.__base_bar__", t.defaultOption = { z: 2, coordinateSystem: "cartesian2d", legendHoverLink: true, barMinHeight: 0, barMinAngle: 0, large: false, largeThreshold: 400, progressive: 3e3, progressiveChunkMode: "mod" }, t;
      }($e);
      $e.registerClass(Tv);
      var mSt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.getInitialData = function() {
          return zs(null, this, { useEncodeDefaulter: true, createInvertedIndices: !!this.get("realtimeSort", true) || null });
        }, t.prototype.getProgressive = function() {
          return this.get("large") ? this.get("progressive") : false;
        }, t.prototype.getProgressiveThreshold = function() {
          var e = this.get("progressiveThreshold"), i = this.get("largeThreshold");
          return i > e && (e = i), e;
        }, t.prototype.brushSelector = function(e, i, r) {
          return r.rect(i.getItemLayout(e));
        }, t.type = "series.bar", t.dependencies = ["grid", "polar"], t.defaultOption = eu(Tv.defaultOption, { clip: true, roundCap: false, showBackground: false, backgroundStyle: { color: "rgba(180, 180, 180, 0.2)", borderColor: null, borderWidth: 0, borderType: "solid", borderRadius: 0, shadowBlur: 0, shadowColor: null, shadowOffsetX: 0, shadowOffsetY: 0, opacity: 1 }, select: { itemStyle: { borderColor: "#212121" } }, realtimeSort: false }), t;
      }(Tv), _St = /* @__PURE__ */ function() {
        function n() {
          this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true;
        }
        return n;
      }(), dI = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "sausage", i;
        }
        return t.prototype.getDefaultShape = function() {
          return new _St();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.cx, a = i.cy, o = Math.max(i.r0 || 0, 0), s = Math.max(i.r, 0), l = (s - o) * 0.5, u = o + l, h = i.startAngle, c = i.endAngle, f = i.clockwise, g = Math.PI * 2, d = f ? c - h < g : h - c < g;
          d || (h = c - (f ? g : -g));
          var A = Math.cos(h), p = Math.sin(h), v = Math.cos(c), y = Math.sin(c);
          d ? (e.moveTo(A * o + r, p * o + a), e.arc(A * u + r, p * u + a, l, -Math.PI + h, h, !f)) : e.moveTo(A * s + r, p * s + a), e.arc(r, a, s, h, c, !f), e.arc(v * u + r, y * u + a, l, c - Math.PI * 2, c - Math.PI, !f), o !== 0 && e.arc(r, a, o, c, h, f);
        }, t;
      }(Jt);
      function ISt(n, t) {
        t = t || {};
        var e = t.isRoundCap;
        return function(i, r, a) {
          var o = r.position;
          if (!o || o instanceof Array) return F_(i, r, a);
          var s = n(o), l = r.distance != null ? r.distance : 5, u = this.shape, h = u.cx, c = u.cy, f = u.r, g = u.r0, d = (f + g) / 2, A = u.startAngle, p = u.endAngle, v = (A + p) / 2, y = e ? Math.abs(f - g) / 2 : 0, m = Math.cos, _ = Math.sin, E = h + f * m(A), I = c + f * _(A), x = "left", w = "top";
          switch (s) {
            case "startArc":
              E = h + (g - l) * m(v), I = c + (g - l) * _(v), x = "center", w = "top";
              break;
            case "insideStartArc":
              E = h + (g + l) * m(v), I = c + (g + l) * _(v), x = "center", w = "bottom";
              break;
            case "startAngle":
              E = h + d * m(A) + AI(A, l + y, false), I = c + d * _(A) + pI(A, l + y, false), x = "right", w = "middle";
              break;
            case "insideStartAngle":
              E = h + d * m(A) + AI(A, -l + y, false), I = c + d * _(A) + pI(A, -l + y, false), x = "left", w = "middle";
              break;
            case "middle":
              E = h + d * m(v), I = c + d * _(v), x = "center", w = "middle";
              break;
            case "endArc":
              E = h + (f + l) * m(v), I = c + (f + l) * _(v), x = "center", w = "bottom";
              break;
            case "insideEndArc":
              E = h + (f - l) * m(v), I = c + (f - l) * _(v), x = "center", w = "top";
              break;
            case "endAngle":
              E = h + d * m(p) + AI(p, l + y, true), I = c + d * _(p) + pI(p, l + y, true), x = "left", w = "middle";
              break;
            case "insideEndAngle":
              E = h + d * m(p) + AI(p, -l + y, true), I = c + d * _(p) + pI(p, -l + y, true), x = "right", w = "middle";
              break;
            default:
              return F_(i, r, a);
          }
          return i = i || {}, i.x = E, i.y = I, i.align = x, i.verticalAlign = w, i;
        };
      }
      function ESt(n, t, e, i) {
        if (pe(i)) {
          n.setTextConfig({ rotation: i });
          return;
        } else if (X(t)) {
          n.setTextConfig({ rotation: 0 });
          return;
        }
        var r = n.shape, a = r.clockwise ? r.startAngle : r.endAngle, o = r.clockwise ? r.endAngle : r.startAngle, s = (a + o) / 2, l, u = e(t);
        switch (u) {
          case "startArc":
          case "insideStartArc":
          case "middle":
          case "insideEndArc":
          case "endArc":
            l = s;
            break;
          case "startAngle":
          case "insideStartAngle":
            l = a;
            break;
          case "endAngle":
          case "insideEndAngle":
            l = o;
            break;
          default:
            n.setTextConfig({ rotation: 0 });
            return;
        }
        var h = Math.PI * 1.5 - l;
        u === "middle" && h > Math.PI / 2 && h < Math.PI * 1.5 && (h -= Math.PI), n.setTextConfig({ rotation: h });
      }
      function AI(n, t, e) {
        return t * Math.sin(n) * (e ? -1 : 1);
      }
      function pI(n, t, e) {
        return t * Math.cos(n) * (e ? 1 : -1);
      }
      function ec(n, t, e) {
        var i = n.get("borderRadius");
        if (i == null) return e ? { cornerRadius: 0 } : null;
        X(i) || (i = [i, i, i, i]);
        var r = Math.abs(t.r || 0 - t.r0 || 0);
        return { cornerRadius: Z(i, function(a) {
          return ja(a, r);
        }) };
      }
      var UT = Math.max, VT = Math.min;
      function xSt(n, t) {
        var e = n.getArea && n.getArea();
        if (tc(n, "cartesian2d")) {
          var i = n.getBaseAxis();
          if (i.type !== "category" || !i.onBand) {
            var r = t.getLayout("bandWidth");
            i.isHorizontal() ? (e.x -= r, e.width += r * 2) : (e.y -= r, e.height += r * 2);
          }
        }
        return e;
      }
      var wSt = function(n) {
        V(t, n);
        function t() {
          var e = n.call(this) || this;
          return e.type = t.type, e._isFirstFrame = true, e;
        }
        return t.prototype.render = function(e, i, r, a) {
          this._model = e, this._removeOnRenderedListener(r), this._updateDrawMode(e);
          var o = e.get("coordinateSystem");
          o === "cartesian2d" || o === "polar" ? (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(e, i, r) : this._renderNormal(e, i, r, a)) : un("Only cartesian2d and polar supported for bar.");
        }, t.prototype.incrementalPrepareRender = function(e) {
          this._clear(), this._updateDrawMode(e), this._updateLargeClip(e);
        }, t.prototype.incrementalRender = function(e, i) {
          this._progressiveEls = [], this._incrementalRenderLarge(e, i);
        }, t.prototype.eachRendered = function(e) {
          tu(this._progressiveEls || this.group, e);
        }, t.prototype._updateDrawMode = function(e) {
          var i = e.pipelineContext.large;
          (this._isLargeDraw == null || i !== this._isLargeDraw) && (this._isLargeDraw = i, this._clear());
        }, t.prototype._renderNormal = function(e, i, r, a) {
          var o = this.group, s = e.getData(), l = this._data, u = e.coordinateSystem, h = u.getBaseAxis(), c;
          u.type === "cartesian2d" ? c = h.isHorizontal() : u.type === "polar" && (c = h.dim === "angle");
          var f = e.isAnimationEnabled() ? e : null, g = CSt(e, u);
          g && this._enableRealtimeSort(g, s, r);
          var d = e.get("clip", true) || g, A = xSt(u, s);
          o.removeClipPath();
          var p = e.get("roundCap", true), v = e.get("showBackground", true), y = e.getModel("backgroundStyle"), m = y.get("borderRadius") || 0, _ = [], E = this._backgroundEls, I = a && a.isInitSort, x = a && a.type === "changeAxisOrder";
          function w(b) {
            var B = vI[u.type](s, b), T = RSt(u, c, B);
            return T.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? T.setShape("r", m) : T.setShape("cornerRadius", m), _[b] = T, T;
          }
          s.diff(l).add(function(b) {
            var B = s.getItemModel(b), T = vI[u.type](s, b, B);
            if (v && w(b), !(!s.hasValue(b) || !QV[u.type](T))) {
              var D = false;
              d && (D = PV[u.type](A, T));
              var R = NV[u.type](e, s, b, T, c, f, h.model, false, p);
              g && (R.forceLabelAnimation = true), zV(R, s, b, B, T, e, c, u.type === "polar"), I ? R.attr({ shape: T }) : g ? kV(g, f, R, T, b, c, false, false) : nn(R, { shape: T }, e, b), s.setItemGraphicEl(b, R), o.add(R), R.ignore = D;
            }
          }).update(function(b, B) {
            var T = s.getItemModel(b), D = vI[u.type](s, b, T);
            if (v) {
              var R = void 0;
              E.length === 0 ? R = w(B) : (R = E[B], R.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? R.setShape("r", m) : R.setShape("cornerRadius", m), _[b] = R);
              var L = vI[u.type](s, b), k = jV(c, L, u);
              _e(R, { shape: k }, f, b);
            }
            var P = l.getItemGraphicEl(B);
            if (!s.hasValue(b) || !QV[u.type](D)) {
              o.remove(P);
              return;
            }
            var F = false;
            if (d && (F = PV[u.type](A, D), F && o.remove(P)), P ? Ya(P) : P = NV[u.type](e, s, b, D, c, f, h.model, !!P, p), g && (P.forceLabelAnimation = true), x) {
              var Q = P.getTextContent();
              if (Q) {
                var z = Bg(Q);
                z.prevValue != null && (z.prevValue = z.value);
              }
            } else zV(P, s, b, T, D, e, c, u.type === "polar");
            I ? P.attr({ shape: D }) : g ? kV(g, f, P, D, b, c, true, x) : _e(P, { shape: D }, e, b, null), s.setItemGraphicEl(b, P), P.ignore = F, o.add(P);
          }).remove(function(b) {
            var B = l.getItemGraphicEl(b);
            B && jp(B, e, b);
          }).execute();
          var C = this._backgroundGroup || (this._backgroundGroup = new Ct());
          C.removeAll();
          for (var S = 0; S < _.length; ++S) C.add(_[S]);
          o.add(C), this._backgroundEls = _, this._data = s;
        }, t.prototype._renderLarge = function(e, i, r) {
          this._clear(), UV(e, this.group), this._updateLargeClip(e);
        }, t.prototype._incrementalRenderLarge = function(e, i) {
          this._removeBackground(), UV(i, this.group, this._progressiveEls, true);
        }, t.prototype._updateLargeClip = function(e) {
          var i = e.get("clip", true) && bv(e.coordinateSystem, false, e), r = this.group;
          i ? r.setClipPath(i) : r.removeClipPath();
        }, t.prototype._enableRealtimeSort = function(e, i, r) {
          var a = this;
          if (i.count()) {
            var o = e.baseAxis;
            if (this._isFirstFrame) this._dispatchInitSort(i, e, r), this._isFirstFrame = false;
            else {
              var s = function(l) {
                var u = i.getItemGraphicEl(l), h = u && u.shape;
                return h && Math.abs(o.isHorizontal() ? h.height : h.width) || 0;
              };
              this._onRendered = function() {
                a._updateSortWithinSameData(i, s, o, r);
              }, r.getZr().on("rendered", this._onRendered);
            }
          }
        }, t.prototype._dataSort = function(e, i, r) {
          var a = [];
          return e.each(e.mapDimension(i.dim), function(o, s) {
            var l = r(s);
            l = l == null ? NaN : l, a.push({ dataIndex: s, mappedValue: l, ordinalNumber: o });
          }), a.sort(function(o, s) {
            return s.mappedValue - o.mappedValue;
          }), { ordinalNumbers: Z(a, function(o) {
            return o.ordinalNumber;
          }) };
        }, t.prototype._isOrderChangedWithinSameData = function(e, i, r) {
          for (var a = r.scale, o = e.mapDimension(r.dim), s = Number.MAX_VALUE, l = 0, u = a.getOrdinalMeta().categories.length; l < u; ++l) {
            var h = e.rawIndexOf(o, a.getRawOrdinalNumber(l)), c = h < 0 ? Number.MIN_VALUE : i(e.indexOfRawIndex(h));
            if (c > s) return true;
            s = c;
          }
          return false;
        }, t.prototype._isOrderDifferentInView = function(e, i) {
          for (var r = i.scale, a = r.getExtent(), o = Math.max(0, a[0]), s = Math.min(a[1], r.getOrdinalMeta().categories.length - 1); o <= s; ++o) if (e.ordinalNumbers[o] !== r.getRawOrdinalNumber(o)) return true;
        }, t.prototype._updateSortWithinSameData = function(e, i, r, a) {
          if (this._isOrderChangedWithinSameData(e, i, r)) {
            var o = this._dataSort(e, r, i);
            this._isOrderDifferentInView(o, r) && (this._removeOnRenderedListener(a), a.dispatchAction({ type: "changeAxisOrder", componentType: r.dim + "Axis", axisId: r.index, sortInfo: o }));
          }
        }, t.prototype._dispatchInitSort = function(e, i, r) {
          var a = i.baseAxis, o = this._dataSort(e, a, function(s) {
            return e.get(e.mapDimension(i.otherAxis.dim), s);
          });
          r.dispatchAction({ type: "changeAxisOrder", componentType: a.dim + "Axis", isInitSort: true, axisId: a.index, sortInfo: o });
        }, t.prototype.remove = function(e, i) {
          this._clear(this._model), this._removeOnRenderedListener(i);
        }, t.prototype.dispose = function(e, i) {
          this._removeOnRenderedListener(i);
        }, t.prototype._removeOnRenderedListener = function(e) {
          this._onRendered && (e.getZr().off("rendered", this._onRendered), this._onRendered = null);
        }, t.prototype._clear = function(e) {
          var i = this.group, r = this._data;
          e && e.isAnimationEnabled() && r && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], r.eachItemGraphicEl(function(a) {
            jp(a, e, Dt(a).dataIndex);
          })) : i.removeAll(), this._data = null, this._isFirstFrame = true;
        }, t.prototype._removeBackground = function() {
          this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
        }, t.type = "bar", t;
      }(Ve), PV = { cartesian2d: function(n, t) {
        var e = t.width < 0 ? -1 : 1, i = t.height < 0 ? -1 : 1;
        e < 0 && (t.x += t.width, t.width = -t.width), i < 0 && (t.y += t.height, t.height = -t.height);
        var r = n.x + n.width, a = n.y + n.height, o = UT(t.x, n.x), s = VT(t.x + t.width, r), l = UT(t.y, n.y), u = VT(t.y + t.height, a), h = s < o, c = u < l;
        return t.x = h && o > r ? s : o, t.y = c && l > a ? u : l, t.width = h ? 0 : s - o, t.height = c ? 0 : u - l, e < 0 && (t.x += t.width, t.width = -t.width), i < 0 && (t.y += t.height, t.height = -t.height), h || c;
      }, polar: function(n, t) {
        var e = t.r0 <= t.r ? 1 : -1;
        if (e < 0) {
          var i = t.r;
          t.r = t.r0, t.r0 = i;
        }
        var r = VT(t.r, n.r), a = UT(t.r0, n.r0);
        t.r = r, t.r0 = a;
        var o = r - a < 0;
        if (e < 0) {
          var i = t.r;
          t.r = t.r0, t.r0 = i;
        }
        return o;
      } }, NV = { cartesian2d: function(n, t, e, i, r, a, o, s, l) {
        var u = new ue({ shape: Y({}, i), z2: 1 });
        if (u.__dataIndex = e, u.name = "item", a) {
          var h = u.shape, c = r ? "height" : "width";
          h[c] = 0;
        }
        return u;
      }, polar: function(n, t, e, i, r, a, o, s, l) {
        var u = !r && l ? dI : Hi, h = new u({ shape: i, z2: 1 });
        h.name = "item";
        var c = OV(r);
        if (h.calculateTextPosition = ISt(c, { isRoundCap: u === dI }), a) {
          var f = h.shape, g = r ? "r" : "endAngle", d = {};
          f[g] = r ? i.r0 : i.startAngle, d[g] = i[g], (s ? _e : nn)(h, { shape: d }, a);
        }
        return h;
      } };
      function CSt(n, t) {
        var e = n.get("realtimeSort", true), i = t.getBaseAxis();
        if (e && (i.type !== "category" && un("`realtimeSort` will not work because this bar series is not based on a category axis."), t.type !== "cartesian2d" && un("`realtimeSort` will not work because this bar series is not on cartesian2d.")), e && i.type === "category" && t.type === "cartesian2d") return { baseAxis: i, otherAxis: t.getOtherAxis(i) };
      }
      function kV(n, t, e, i, r, a, o, s) {
        var l, u;
        a ? (u = { x: i.x, width: i.width }, l = { y: i.y, height: i.height }) : (u = { y: i.y, height: i.height }, l = { x: i.x, width: i.width }), s || (o ? _e : nn)(e, { shape: l }, t, r, null);
        var h = t ? n.baseAxis.model : null;
        (o ? _e : nn)(e, { shape: u }, h, r);
      }
      function FV(n, t) {
        for (var e = 0; e < t.length; e++) if (!isFinite(n[t[e]])) return true;
        return false;
      }
      var SSt = ["x", "y", "width", "height"], bSt = ["cx", "cy", "r", "startAngle", "endAngle"], QV = { cartesian2d: function(n) {
        return !FV(n, SSt);
      }, polar: function(n) {
        return !FV(n, bSt);
      } }, vI = { cartesian2d: function(n, t, e) {
        var i = n.getItemLayout(t), r = e ? TSt(e, i) : 0, a = i.width > 0 ? 1 : -1, o = i.height > 0 ? 1 : -1;
        return { x: i.x + a * r / 2, y: i.y + o * r / 2, width: i.width - a * r, height: i.height - o * r };
      }, polar: function(n, t, e) {
        var i = n.getItemLayout(t);
        return { cx: i.cx, cy: i.cy, r0: i.r0, r: i.r, startAngle: i.startAngle, endAngle: i.endAngle, clockwise: i.clockwise };
      } };
      function BSt(n) {
        return n.startAngle != null && n.endAngle != null && n.startAngle === n.endAngle;
      }
      function OV(n) {
        return /* @__PURE__ */ function(t) {
          var e = t ? "Arc" : "Angle";
          return function(i) {
            switch (i) {
              case "start":
              case "insideStart":
              case "end":
              case "insideEnd":
                return i + e;
              default:
                return i;
            }
          };
        }(n);
      }
      function zV(n, t, e, i, r, a, o, s) {
        var l = t.getItemVisual(e, "style");
        if (s) {
          if (!a.get("roundCap")) {
            var h = n.shape, c = ec(i.getModel("itemStyle"), h, true);
            Y(h, c), n.setShape(h);
          }
        } else {
          var u = i.get(["itemStyle", "borderRadius"]) || 0;
          n.setShape("r", u);
        }
        n.useStyle(l);
        var f = i.getShallow("cursor");
        f && n.attr("cursor", f);
        var g = s ? o ? r.r >= r.r0 ? "endArc" : "startArc" : r.endAngle >= r.startAngle ? "endAngle" : "startAngle" : o ? r.height >= 0 ? "bottom" : "top" : r.width >= 0 ? "right" : "left", d = Xn(i);
        vi(n, d, { labelFetcher: a, labelDataIndex: e, defaultText: $g(a.getData(), e), inheritColor: l.fill, defaultOpacity: l.opacity, defaultOutsidePosition: g });
        var A = n.getTextContent();
        if (s && A) {
          var p = i.get(["label", "position"]);
          n.textConfig.inside = p === "middle" ? true : null, ESt(n, p === "outside" ? g : p, OV(o), i.get(["label", "rotate"]));
        }
        h4(A, d, a.getRawValue(e), function(y) {
          return yV(t, y);
        });
        var v = i.getModel(["emphasis"]);
        hn(n, v.get("focus"), v.get("blurScope"), v.get("disabled")), pi(n, i), BSt(r) && (n.style.fill = "none", n.style.stroke = "none", M(n.states, function(y) {
          y.style && (y.style.fill = y.style.stroke = "none");
        }));
      }
      function TSt(n, t) {
        var e = n.get(["itemStyle", "borderColor"]);
        if (!e || e === "none") return 0;
        var i = n.get(["itemStyle", "borderWidth"]) || 0, r = isNaN(t.width) ? Number.MAX_VALUE : Math.abs(t.width), a = isNaN(t.height) ? Number.MAX_VALUE : Math.abs(t.height);
        return Math.min(i, r, a);
      }
      var MSt = /* @__PURE__ */ function() {
        function n() {
        }
        return n;
      }(), GV = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "largeBar", i;
        }
        return t.prototype.getDefaultShape = function() {
          return new MSt();
        }, t.prototype.buildPath = function(e, i) {
          for (var r = i.points, a = this.baseDimIdx, o = 1 - this.baseDimIdx, s = [], l = [], u = this.barWidth, h = 0; h < r.length; h += 3) l[a] = u, l[o] = r[h + 2], s[a] = r[h + a], s[o] = r[h + o], e.rect(s[0], s[1], l[0], l[1]);
        }, t;
      }(Jt);
      function UV(n, t, e, i) {
        var r = n.getData(), a = r.getLayout("valueAxisHorizontal") ? 1 : 0, o = r.getLayout("largeDataIndices"), s = r.getLayout("size"), l = n.getModel("backgroundStyle"), u = r.getLayout("largeBackgroundPoints");
        if (u) {
          var h = new GV({ shape: { points: u }, incremental: !!i, silent: true, z2: 0 });
          h.baseDimIdx = a, h.largeDataIndices = o, h.barWidth = s, h.useStyle(l.getItemStyle()), t.add(h), e && e.push(h);
        }
        var c = new GV({ shape: { points: r.getLayout("largePoints") }, incremental: !!i, ignoreCoarsePointer: true, z2: 1 });
        c.baseDimIdx = a, c.largeDataIndices = o, c.barWidth = s, t.add(c), c.useStyle(r.getVisual("style")), Dt(c).seriesIndex = n.seriesIndex, n.get("silent") || (c.on("mousedown", VV), c.on("mousemove", VV)), e && e.push(c);
      }
      var VV = QB(function(n) {
        var t = this, e = DSt(t, n.offsetX, n.offsetY);
        Dt(t).dataIndex = e >= 0 ? e : null;
      }, 30, false);
      function DSt(n, t, e) {
        for (var i = n.baseDimIdx, r = 1 - i, a = n.shape.points, o = n.largeDataIndices, s = [], l = [], u = n.barWidth, h = 0, c = a.length / 3; h < c; h++) {
          var f = h * 3;
          if (l[i] = u, l[r] = a[f + 2], s[i] = a[f + i], s[r] = a[f + r], l[r] < 0 && (s[r] += l[r], l[r] = -l[r]), t >= s[0] && t <= s[0] + l[0] && e >= s[1] && e <= s[1] + l[1]) return o[h];
        }
        return -1;
      }
      function jV(n, t, e) {
        if (tc(e, "cartesian2d")) {
          var i = t, r = e.getArea();
          return { x: n ? i.x : r.x, y: n ? r.y : i.y, width: n ? i.width : r.width, height: n ? r.height : i.height };
        } else {
          var r = e.getArea(), a = t;
          return { cx: r.cx, cy: r.cy, r0: n ? r.r0 : a.r0, r: n ? r.r : a.r, startAngle: n ? a.startAngle : 0, endAngle: n ? a.endAngle : Math.PI * 2 };
        }
      }
      function RSt(n, t, e) {
        var i = n.type === "polar" ? Hi : ue;
        return new i({ shape: jV(t, e, n), silent: true, z2: 0 });
      }
      function LSt(n) {
        n.registerChartView(wSt), n.registerSeriesModel(mSt), n.registerLayout(n.PRIORITY.VISUAL.LAYOUT, Ot(sU, "bar")), n.registerLayout(n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, lU("bar")), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, LV("bar")), n.registerAction({ type: "changeAxisOrder", event: "changeAxisOrder", update: "update" }, function(t, e) {
          var i = t.componentType || "series";
          e.eachComponent({ mainType: i, query: t }, function(r) {
            t.sortInfo && r.axis.setCategorySortInfo(t.sortInfo);
          });
        });
      }
      var qV = Math.PI * 2, yI = Math.PI / 180;
      function HV(n, t) {
        return Gn(n.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() });
      }
      function YV(n, t) {
        var e = HV(n, t), i = n.get("center"), r = n.get("radius");
        X(r) || (r = [0, r]);
        var a = ot(e.width, t.getWidth()), o = ot(e.height, t.getHeight()), s = Math.min(a, o), l = ot(r[0], s / 2), u = ot(r[1], s / 2), h, c, f = n.coordinateSystem;
        if (f) {
          var g = f.dataToPoint(i);
          h = g[0] || 0, c = g[1] || 0;
        } else X(i) || (i = [i, i]), h = ot(i[0], a) + e.x, c = ot(i[1], o) + e.y;
        return { cx: h, cy: c, r0: l, r: u };
      }
      function PSt(n, t, e) {
        t.eachSeriesByType(n, function(i) {
          var r = i.getData(), a = r.mapDimension("value"), o = HV(i, e), s = YV(i, e), l = s.cx, u = s.cy, h = s.r, c = s.r0, f = -i.get("startAngle") * yI, g = i.get("endAngle"), d = i.get("padAngle") * yI;
          g = g === "auto" ? f - qV : -g * yI;
          var A = i.get("minAngle") * yI, p = A + d, v = 0;
          r.each(a, function(k) {
            !isNaN(k) && v++;
          });
          var y = r.getSum(a), m = Math.PI / (y || v) * 2, _ = i.get("clockwise"), E = i.get("roseType"), I = i.get("stillShowZeroSum"), x = r.getDataExtent(a);
          x[0] = 0;
          var w = _ ? 1 : -1, C = [f, g], S = w * d / 2;
          R2(C, !_), f = C[0], g = C[1];
          var b = WV(i);
          b.startAngle = f, b.endAngle = g, b.clockwise = _;
          var B = Math.abs(g - f), T = B, D = 0, R = f;
          if (r.setLayout({ viewRect: o, r: h }), r.each(a, function(k, P) {
            var F;
            if (isNaN(k)) {
              r.setItemLayout(P, { angle: NaN, startAngle: NaN, endAngle: NaN, clockwise: _, cx: l, cy: u, r0: c, r: E ? NaN : h });
              return;
            }
            E !== "area" ? F = y === 0 && I ? m : k * m : F = B / v, F < p ? (F = p, T -= p) : D += k;
            var Q = R + w * F, z = 0, j = 0;
            d > F ? (z = R + w * F / 2, j = z) : (z = R + S, j = Q - S), r.setItemLayout(P, { angle: F, startAngle: z, endAngle: j, clockwise: _, cx: l, cy: u, r0: c, r: E ? Le(k, x, [c, h]) : h }), R = Q;
          }), T < qV && v) if (T <= 1e-3) {
            var L = B / v;
            r.each(a, function(k, P) {
              if (!isNaN(k)) {
                var F = r.getItemLayout(P);
                F.angle = L;
                var Q = 0, z = 0;
                L < d ? (Q = f + w * (P + 1 / 2) * L, z = Q) : (Q = f + w * P * L + S, z = f + w * (P + 1) * L - S), F.startAngle = Q, F.endAngle = z;
              }
            });
          } else m = T / D, R = f, r.each(a, function(k, P) {
            if (!isNaN(k)) {
              var F = r.getItemLayout(P), Q = F.angle === p ? p : k * m, z = 0, j = 0;
              Q < d ? (z = R + w * Q / 2, j = z) : (z = R + S, j = R + w * Q - S), F.startAngle = z, F.endAngle = j, R += w * Q;
            }
          });
        });
      }
      var WV = le();
      function Mv(n) {
        return { seriesType: n, reset: function(t, e) {
          var i = e.findComponents({ mainType: "legend" });
          if (!(!i || !i.length)) {
            var r = t.getData();
            r.filterSelf(function(a) {
              for (var o = r.getName(a), s = 0; s < i.length; s++) if (!i[s].isSelected(o)) return false;
              return true;
            });
          }
        } };
      }
      var NSt = Math.PI / 180;
      function XV(n, t, e, i, r, a, o, s, l, u) {
        if (n.length < 2) return;
        function h(A) {
          for (var p = A.rB, v = p * p, y = 0; y < A.list.length; y++) {
            var m = A.list[y], _ = Math.abs(m.label.y - e), E = i + m.len, I = E * E, x = Math.sqrt((1 - Math.abs(_ * _ / v)) * I), w = t + (x + m.len2) * r, C = w - m.label.x, S = m.targetTextWidth - C * r;
            ZV(m, S, true), m.label.x = w;
          }
        }
        function c(A) {
          for (var p = { list: [], maxY: 0 }, v = { list: [], maxY: 0 }, y = 0; y < A.length; y++) if (A[y].labelAlignTo === "none") {
            var m = A[y], _ = m.label.y > e ? v : p, E = Math.abs(m.label.y - e);
            if (E >= _.maxY) {
              var I = m.label.x - t - m.len2 * r, x = i + m.len, w = Math.abs(I) < x ? Math.sqrt(E * E / (1 - I * I / x / x)) : x;
              _.rB = w, _.maxY = E;
            }
            _.list.push(m);
          }
          h(p), h(v);
        }
        for (var f = n.length, g = 0; g < f; g++) if (n[g].position === "outer" && n[g].labelAlignTo === "labelLine") {
          var d = n[g].label.x - u;
          n[g].linePoints[1][0] += d, n[g].label.x = u;
        }
        QU(n, l, l + o) && c(n);
      }
      function kSt(n, t, e, i, r, a, o, s) {
        for (var l = [], u = [], h = Number.MAX_VALUE, c = -Number.MAX_VALUE, f = 0; f < n.length; f++) {
          var g = n[f].label;
          jT(n[f]) || (g.x < t ? (h = Math.min(h, g.x), l.push(n[f])) : (c = Math.max(c, g.x), u.push(n[f])));
        }
        for (var f = 0; f < n.length; f++) {
          var d = n[f];
          if (!jT(d) && d.linePoints) {
            if (d.labelStyleWidth != null) continue;
            var g = d.label, A = d.linePoints, p = void 0;
            d.labelAlignTo === "edge" ? g.x < t ? p = A[2][0] - d.labelDistance - o - d.edgeDistance : p = o + r - d.edgeDistance - A[2][0] - d.labelDistance : d.labelAlignTo === "labelLine" ? g.x < t ? p = h - o - d.bleedMargin : p = o + r - c - d.bleedMargin : g.x < t ? p = g.x - o - d.bleedMargin : p = o + r - g.x - d.bleedMargin, d.targetTextWidth = p, ZV(d, p);
          }
        }
        XV(u, t, e, i, 1, r, a, o, s, c), XV(l, t, e, i, -1, r, a, o, s, h);
        for (var f = 0; f < n.length; f++) {
          var d = n[f];
          if (!jT(d) && d.linePoints) {
            var g = d.label, A = d.linePoints, v = d.labelAlignTo === "edge", y = g.style.padding, m = y ? y[1] + y[3] : 0, _ = g.style.backgroundColor ? 0 : m, E = d.rect.width + _, I = A[1][0] - A[2][0];
            v ? g.x < t ? A[2][0] = o + d.edgeDistance + E + d.labelDistance : A[2][0] = o + r - d.edgeDistance - E - d.labelDistance : (g.x < t ? A[2][0] = g.x + d.labelDistance : A[2][0] = g.x - d.labelDistance, A[1][0] = A[2][0] + I), A[1][1] = A[2][1] = g.y;
          }
        }
      }
      function ZV(n, t, e) {
        if (e === void 0 && (e = false), n.labelStyleWidth == null) {
          var i = n.label, r = i.style, a = n.rect, o = r.backgroundColor, s = r.padding, l = s ? s[1] + s[3] : 0, u = r.overflow, h = a.width + (o ? 0 : l);
          if (t < h || e) {
            var c = a.height;
            if (u && u.match("break")) {
              i.setStyle("backgroundColor", null), i.setStyle("width", t - l);
              var f = i.getBoundingRect();
              i.setStyle("width", Math.ceil(f.width)), i.setStyle("backgroundColor", o);
            } else {
              var g = t - l, d = t < h ? g : e ? g > n.unconstrainedWidth ? null : g : null;
              i.setStyle("width", d);
            }
            var A = i.getBoundingRect();
            a.width = A.width;
            var p = (i.style.margin || 0) + 2.1;
            a.height = A.height + p, a.y -= (a.height - c) / 2;
          }
        }
      }
      function jT(n) {
        return n.position === "center";
      }
      function FSt(n) {
        var t = n.getData(), e = [], i, r, a = false, o = (n.get("minShowLabelAngle") || 0) * NSt, s = t.getLayout("viewRect"), l = t.getLayout("r"), u = s.width, h = s.x, c = s.y, f = s.height;
        function g(I) {
          I.ignore = true;
        }
        function d(I) {
          if (!I.ignore) return true;
          for (var x in I.states) if (I.states[x].ignore === false) return true;
          return false;
        }
        t.each(function(I) {
          var x = t.getItemGraphicEl(I), w = x.shape, C = x.getTextContent(), S = x.getTextGuideLine(), b = t.getItemModel(I), B = b.getModel("label"), T = B.get("position") || b.get(["emphasis", "label", "position"]), D = B.get("distanceToLabelLine"), R = B.get("alignTo"), L = ot(B.get("edgeDistance"), u), k = B.get("bleedMargin"), P = b.getModel("labelLine"), F = P.get("length");
          F = ot(F, u);
          var Q = P.get("length2");
          if (Q = ot(Q, u), Math.abs(w.endAngle - w.startAngle) < o) {
            M(C.states, g), C.ignore = true, S && (M(S.states, g), S.ignore = true);
            return;
          }
          if (d(C)) {
            var z = (w.startAngle + w.endAngle) / 2, j = Math.cos(z), $ = Math.sin(z), G, tt, J, et;
            i = w.cx, r = w.cy;
            var nt = T === "inside" || T === "inner";
            if (T === "center") G = w.cx, tt = w.cy, et = "center";
            else {
              var gt = (nt ? (w.r + w.r0) / 2 * j : w.r * j) + i, H = (nt ? (w.r + w.r0) / 2 * $ : w.r * $) + r;
              if (G = gt + j * 3, tt = H + $ * 3, !nt) {
                var W = gt + j * (F + l - w.r), it = H + $ * (F + l - w.r), kt = W + (j < 0 ? -1 : 1) * Q, vt = it;
                R === "edge" ? G = j < 0 ? h + L : h + u - L : G = kt + (j < 0 ? -D : D), tt = vt, J = [[gt, H], [W, it], [kt, vt]];
              }
              et = nt ? "center" : R === "edge" ? j > 0 ? "right" : "left" : j > 0 ? "left" : "right";
            }
            var St = Math.PI, bt = 0, Ee = B.get("rotate");
            if (pe(Ee)) bt = Ee * (St / 180);
            else if (T === "center") bt = 0;
            else if (Ee === "radial" || Ee === true) {
              var rn = j < 0 ? -z + St : -z;
              bt = rn;
            } else if (Ee === "tangential" && T !== "outside" && T !== "outer") {
              var Ie = Math.atan2(j, $);
              Ie < 0 && (Ie = St * 2 + Ie);
              var fn = $ > 0;
              fn && (Ie = St + Ie), bt = Ie - St;
            }
            if (a = !!bt, C.x = G, C.y = tt, C.rotation = bt, C.setStyle({ verticalAlign: "middle" }), nt) {
              C.setStyle({ align: et });
              var Cr = C.states.select;
              Cr && (Cr.x += C.x, Cr.y += C.y);
            } else {
              var an = C.getBoundingRect().clone();
              an.applyTransform(C.getComputedTransform());
              var wr = (C.style.margin || 0) + 2.1;
              an.y -= wr / 2, an.height += wr, e.push({ label: C, labelLine: S, position: T, len: F, len2: Q, minTurnAngle: P.get("minTurnAngle"), maxSurfaceAngle: P.get("maxSurfaceAngle"), surfaceNormal: new Ut(j, $), linePoints: J, textAlign: et, labelDistance: D, labelAlignTo: R, edgeDistance: L, bleedMargin: k, rect: an, unconstrainedWidth: an.width, labelStyleWidth: C.style.width });
            }
            x.setTextConfig({ inside: nt });
          }
        }), !a && n.get("avoidLabelOverlap") && kSt(e, i, r, l, u, f, h, c);
        for (var A = 0; A < e.length; A++) {
          var p = e[A], v = p.label, y = p.labelLine, m = isNaN(v.x) || isNaN(v.y);
          if (v) {
            v.setStyle({ align: p.textAlign }), m && (M(v.states, g), v.ignore = true);
            var _ = v.states.select;
            _ && (_.x += v.x, _.y += v.y);
          }
          if (y) {
            var E = p.linePoints;
            m || !E ? (M(y.states, g), y.ignore = true) : (NU(E, p.minTurnAngle), oCt(E, p.surfaceNormal, p.maxSurfaceAngle), y.setShape({ points: E }), v.__hostTarget.textGuideLineConfig = { anchor: new Ut(E[0][0], E[0][1]) });
          }
        }
      }
      var QSt = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this) || this;
          a.z2 = 2;
          var o = new ge();
          return a.setTextContent(o), a.updateData(e, i, r, true), a;
        }
        return t.prototype.updateData = function(e, i, r, a) {
          var o = this, s = e.hostModel, l = e.getItemModel(i), u = l.getModel("emphasis"), h = e.getItemLayout(i), c = Y(ec(l.getModel("itemStyle"), h, true), h);
          if (isNaN(c.startAngle)) {
            o.setShape(c);
            return;
          }
          if (a) {
            o.setShape(c);
            var f = s.getShallow("animationType");
            s.ecModel.ssr ? (nn(o, { scaleX: 0, scaleY: 0 }, s, { dataIndex: i, isFrom: true }), o.originX = c.cx, o.originY = c.cy) : f === "scale" ? (o.shape.r = h.r0, nn(o, { shape: { r: h.r } }, s, i)) : r != null ? (o.setShape({ startAngle: r, endAngle: r }), nn(o, { shape: { startAngle: h.startAngle, endAngle: h.endAngle } }, s, i)) : (o.shape.endAngle = h.startAngle, _e(o, { shape: { endAngle: h.endAngle } }, s, i));
          } else Ya(o), _e(o, { shape: c }, s, i);
          o.useStyle(e.getItemVisual(i, "style")), pi(o, l);
          var g = (h.startAngle + h.endAngle) / 2, d = s.get("selectedOffset"), A = Math.cos(g) * d, p = Math.sin(g) * d, v = l.getShallow("cursor");
          v && o.attr("cursor", v), this._updateLabel(s, e, i), o.ensureState("emphasis").shape = Y({ r: h.r + (u.get("scale") && u.get("scaleSize") || 0) }, ec(u.getModel("itemStyle"), h)), Y(o.ensureState("select"), { x: A, y: p, shape: ec(l.getModel(["select", "itemStyle"]), h) }), Y(o.ensureState("blur"), { shape: ec(l.getModel(["blur", "itemStyle"]), h) });
          var y = o.getTextGuideLine(), m = o.getTextContent();
          y && Y(y.ensureState("select"), { x: A, y: p }), Y(m.ensureState("select"), { x: A, y: p }), hn(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
        }, t.prototype._updateLabel = function(e, i, r) {
          var a = this, o = i.getItemModel(r), s = o.getModel("labelLine"), l = i.getItemVisual(r, "style"), u = l && l.fill, h = l && l.opacity;
          vi(a, Xn(o), { labelFetcher: i.hostModel, labelDataIndex: r, inheritColor: u, defaultOpacity: h, defaultText: e.getFormattedLabel(r, "normal") || i.getName(r) });
          var c = a.getTextContent();
          a.setTextConfig({ position: null, rotation: null }), c.attr({ z2: 10 });
          var f = e.get(["label", "position"]);
          if (f !== "outside" && f !== "outer") a.removeTextGuideLine();
          else {
            var g = this.getTextGuideLine();
            g || (g = new Wi(), this.setTextGuideLine(g)), ET(this, xT(o), { stroke: u, opacity: ra(s.get(["lineStyle", "opacity"]), h, 1) });
          }
        }, t;
      }(Hi), OSt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.ignoreLabelLineUpdate = true, e;
        }
        return t.prototype.render = function(e, i, r, a) {
          var o = e.getData(), s = this._data, l = this.group, u;
          if (!s && o.count() > 0) {
            for (var h = o.getItemLayout(0), c = 1; isNaN(h && h.startAngle) && c < o.count(); ++c) h = o.getItemLayout(c);
            h && (u = h.startAngle);
          }
          if (this._emptyCircleSector && l.remove(this._emptyCircleSector), o.count() === 0 && e.get("showEmptyCircle")) {
            var f = WV(e), g = new Hi({ shape: Y(YV(e, r), f) });
            g.useStyle(e.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = g, l.add(g);
          }
          o.diff(s).add(function(d) {
            var A = new QSt(o, d, u);
            o.setItemGraphicEl(d, A), l.add(A);
          }).update(function(d, A) {
            var p = s.getItemGraphicEl(A);
            p.updateData(o, d, u), p.off("click"), l.add(p), o.setItemGraphicEl(d, p);
          }).remove(function(d) {
            var A = s.getItemGraphicEl(d);
            jp(A, e, d);
          }).execute(), FSt(e), e.get("animationTypeUpdate") !== "expansion" && (this._data = o);
        }, t.prototype.dispose = function() {
        }, t.prototype.containPoint = function(e, i) {
          var r = i.getData(), a = r.getItemLayout(0);
          if (a) {
            var o = e[0] - a.cx, s = e[1] - a.cy, l = Math.sqrt(o * o + s * s);
            return l <= a.r && l >= a.r0;
          }
        }, t.type = "pie", t;
      }(Ve);
      function Jg(n, t, e) {
        t = X(t) && { coordDimensions: t } || Y({ encodeDefine: n.getEncode() }, t);
        var i = n.getSource(), r = vv(i, t).dimensions, a = new Zi(r, n);
        return a.initData(i, e), a;
      }
      var Dv = function() {
        function n(t, e) {
          this._getDataWithEncodedVisual = t, this._getRawData = e;
        }
        return n.prototype.getAllNames = function() {
          var t = this._getRawData();
          return t.mapArray(t.getName);
        }, n.prototype.containName = function(t) {
          var e = this._getRawData();
          return e.indexOfName(t) >= 0;
        }, n.prototype.indexOfName = function(t) {
          var e = this._getDataWithEncodedVisual();
          return e.indexOfName(t);
        }, n.prototype.getItemVisual = function(t, e) {
          var i = this._getDataWithEncodedVisual();
          return i.getItemVisual(t, e);
        }, n;
      }(), zSt = le(), GSt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.init = function(e) {
          n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Dv(ct(this.getData, this), ct(this.getRawData, this)), this._defaultLabelLine(e);
        }, t.prototype.mergeOption = function() {
          n.prototype.mergeOption.apply(this, arguments);
        }, t.prototype.getInitialData = function() {
          return Jg(this, { coordDimensions: ["value"], encodeDefaulter: Ot(pB, this) });
        }, t.prototype.getDataParams = function(e) {
          var i = this.getData(), r = zSt(i), a = r.seats;
          if (!a) {
            var o = [];
            i.each(i.mapDimension("value"), function(l) {
              o.push(l);
            }), a = r.seats = Bmt(o, i.hostModel.get("percentPrecision"));
          }
          var s = n.prototype.getDataParams.call(this, e);
          return s.percent = a[e] || 0, s.$vars.push("percent"), s;
        }, t.prototype._defaultLabelLine = function(e) {
          dh(e, "labelLine", ["show"]);
          var i = e.labelLine, r = e.emphasis.labelLine;
          i.show = i.show && e.label.show, r.show = r.show && e.emphasis.label.show;
        }, t.type = "series.pie", t.defaultOption = { z: 2, legendHoverLink: true, colorBy: "data", center: ["50%", "50%"], radius: [0, "75%"], clockwise: true, startAngle: 90, endAngle: "auto", padAngle: 0, minAngle: 0, minShowLabelAngle: 0, selectedOffset: 10, percentPrecision: 2, stillShowZeroSum: true, left: 0, top: 0, right: 0, bottom: 0, width: null, height: null, label: { rotate: 0, show: true, overflow: "truncate", position: "outer", alignTo: "none", edgeDistance: "25%", bleedMargin: 10, distanceToLabelLine: 5 }, labelLine: { show: true, length: 15, length2: 15, smooth: false, minTurnAngle: 90, maxSurfaceAngle: 90, lineStyle: { width: 1, type: "solid" } }, itemStyle: { borderWidth: 1, borderJoin: "round" }, showEmptyCircle: true, emptyCircleStyle: { color: "lightgray", opacity: 1 }, labelLayout: { hideOverlap: true }, emphasis: { scale: true, scaleSize: 5 }, avoidLabelOverlap: true, animationType: "expansion", animationDuration: 1e3, animationTypeUpdate: "transition", animationEasingUpdate: "cubicInOut", animationDurationUpdate: 500, animationEasing: "cubicInOut" }, t;
      }($e);
      function USt(n) {
        return { seriesType: n, reset: function(t, e) {
          var i = t.getData();
          i.filterSelf(function(r) {
            var a = i.mapDimension("value"), o = i.get(a, r);
            return !(pe(o) && !isNaN(o) && o < 0);
          });
        } };
      }
      function VSt(n) {
        n.registerChartView(OSt), n.registerSeriesModel(GSt), e6("pie", n.registerAction), n.registerLayout(Ot(PSt, "pie")), n.registerProcessor(Mv("pie")), n.registerProcessor(USt("pie"));
      }
      var jSt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.hasSymbolVisual = true, e;
        }
        return t.prototype.getInitialData = function(e, i) {
          return zs(null, this, { useEncodeDefaulter: true });
        }, t.prototype.getProgressive = function() {
          var e = this.option.progressive;
          return e == null ? this.option.large ? 5e3 : this.get("progressive") : e;
        }, t.prototype.getProgressiveThreshold = function() {
          var e = this.option.progressiveThreshold;
          return e == null ? this.option.large ? 1e4 : this.get("progressiveThreshold") : e;
        }, t.prototype.brushSelector = function(e, i, r) {
          return r.point(i.getItemLayout(e));
        }, t.prototype.getZLevelKey = function() {
          return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
        }, t.type = "series.scatter", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], t.defaultOption = { coordinateSystem: "cartesian2d", z: 2, legendHoverLink: true, symbolSize: 10, large: false, largeThreshold: 2e3, itemStyle: { opacity: 0.8 }, emphasis: { scale: true }, clip: true, select: { itemStyle: { borderColor: "#212121" } }, universalTransition: { divideShape: "clone" } }, t;
      }($e), KV = 4, qSt = /* @__PURE__ */ function() {
        function n() {
        }
        return n;
      }(), HSt = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i._off = 0, i.hoverDataIdx = -1, i;
        }
        return t.prototype.getDefaultShape = function() {
          return new qSt();
        }, t.prototype.reset = function() {
          this.notClear = false, this._off = 0;
        }, t.prototype.buildPath = function(e, i) {
          var r = i.points, a = i.size, o = this.symbolProxy, s = o.shape, l = e.getContext ? e.getContext() : e, u = l && a[0] < KV, h = this.softClipShape, c;
          if (u) {
            this._ctx = l;
            return;
          }
          for (this._ctx = null, c = this._off; c < r.length; ) {
            var f = r[c++], g = r[c++];
            isNaN(f) || isNaN(g) || h && !h.contain(f, g) || (s.x = f - a[0] / 2, s.y = g - a[1] / 2, s.width = a[0], s.height = a[1], o.buildPath(e, s, true));
          }
          this.incremental && (this._off = c, this.notClear = true);
        }, t.prototype.afterBrush = function() {
          var e = this.shape, i = e.points, r = e.size, a = this._ctx, o = this.softClipShape, s;
          if (a) {
            for (s = this._off; s < i.length; ) {
              var l = i[s++], u = i[s++];
              isNaN(l) || isNaN(u) || o && !o.contain(l, u) || a.fillRect(l - r[0] / 2, u - r[1] / 2, r[0], r[1]);
            }
            this.incremental && (this._off = s, this.notClear = true);
          }
        }, t.prototype.findDataIndex = function(e, i) {
          for (var r = this.shape, a = r.points, o = r.size, s = Math.max(o[0], 4), l = Math.max(o[1], 4), u = a.length / 2 - 1; u >= 0; u--) {
            var h = u * 2, c = a[h] - s / 2, f = a[h + 1] - l / 2;
            if (e >= c && i >= f && e <= c + s && i <= f + l) return u;
          }
          return -1;
        }, t.prototype.contain = function(e, i) {
          var r = this.transformCoordToLocal(e, i), a = this.getBoundingRect();
          if (e = r[0], i = r[1], a.contain(e, i)) {
            var o = this.hoverDataIdx = this.findDataIndex(e, i);
            return o >= 0;
          }
          return this.hoverDataIdx = -1, false;
        }, t.prototype.getBoundingRect = function() {
          var e = this._rect;
          if (!e) {
            for (var i = this.shape, r = i.points, a = i.size, o = a[0], s = a[1], l = 1 / 0, u = 1 / 0, h = -1 / 0, c = -1 / 0, f = 0; f < r.length; ) {
              var g = r[f++], d = r[f++];
              l = Math.min(g, l), h = Math.max(g, h), u = Math.min(d, u), c = Math.max(d, c);
            }
            e = this._rect = new Ht(l - o / 2, u - s / 2, h - l + o, c - u + s);
          }
          return e;
        }, t;
      }(Jt), YSt = function() {
        function n() {
          this.group = new Ct();
        }
        return n.prototype.updateData = function(t, e) {
          this._clear();
          var i = this._create();
          i.setShape({ points: t.getLayout("points") }), this._setCommon(i, t, e);
        }, n.prototype.updateLayout = function(t) {
          var e = t.getLayout("points");
          this.group.eachChild(function(i) {
            if (i.startIndex != null) {
              var r = (i.endIndex - i.startIndex) * 2, a = i.startIndex * 4 * 2;
              e = new Float32Array(e.buffer, a, r);
            }
            i.setShape("points", e), i.reset();
          });
        }, n.prototype.incrementalPrepareUpdate = function(t) {
          this._clear();
        }, n.prototype.incrementalUpdate = function(t, e, i) {
          var r = this._newAdded[0], a = e.getLayout("points"), o = r && r.shape.points;
          if (o && o.length < 2e4) {
            var s = o.length, l = new Float32Array(s + a.length);
            l.set(o), l.set(a, s), r.endIndex = t.end, r.setShape({ points: l });
          } else {
            this._newAdded = [];
            var u = this._create();
            u.startIndex = t.start, u.endIndex = t.end, u.incremental = true, u.setShape({ points: a }), this._setCommon(u, e, i);
          }
        }, n.prototype.eachRendered = function(t) {
          this._newAdded[0] && t(this._newAdded[0]);
        }, n.prototype._create = function() {
          var t = new HSt({ cursor: "default" });
          return t.ignoreCoarsePointer = true, this.group.add(t), this._newAdded.push(t), t;
        }, n.prototype._setCommon = function(t, e, i) {
          var r = e.hostModel;
          i = i || {};
          var a = e.getVisual("symbolSize");
          t.setShape("size", a instanceof Array ? a : [a, a]), t.softClipShape = i.clipShape || null, t.symbolProxy = Nn(e.getVisual("symbol"), 0, 0, 0, 0), t.setColor = t.symbolProxy.setColor;
          var o = t.shape.size[0] < KV;
          t.useStyle(r.getModel("itemStyle").getItemStyle(o ? ["color", "shadowBlur", "shadowColor"] : ["color"]));
          var s = e.getVisual("style"), l = s && s.fill;
          l && t.setColor(l);
          var u = Dt(t);
          u.seriesIndex = r.seriesIndex, t.on("mousemove", function(h) {
            u.dataIndex = null;
            var c = t.hoverDataIdx;
            c >= 0 && (u.dataIndex = c + (t.startIndex || 0));
          });
        }, n.prototype.remove = function() {
          this._clear();
        }, n.prototype._clear = function() {
          this._newAdded = [], this.group.removeAll();
        }, n;
      }(), WSt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = e.getData(), o = this._updateSymbolDraw(a, e);
          o.updateData(a, { clipShape: this._getClipShape(e) }), this._finished = true;
        }, t.prototype.incrementalPrepareRender = function(e, i, r) {
          var a = e.getData(), o = this._updateSymbolDraw(a, e);
          o.incrementalPrepareUpdate(a), this._finished = false;
        }, t.prototype.incrementalRender = function(e, i, r) {
          this._symbolDraw.incrementalUpdate(e, i.getData(), { clipShape: this._getClipShape(i) }), this._finished = e.end === i.getData().count();
        }, t.prototype.updateTransform = function(e, i, r) {
          var a = e.getData();
          if (this.group.dirty(), !this._finished || a.count() > 1e4) return { update: true };
          var o = Bv("").reset(e, i, r);
          o.progress && o.progress({ start: 0, end: a.count(), count: a.count() }, a), this._symbolDraw.updateLayout(a);
        }, t.prototype.eachRendered = function(e) {
          this._symbolDraw && this._symbolDraw.eachRendered(e);
        }, t.prototype._getClipShape = function(e) {
          if (e.get("clip", true)) {
            var i = e.coordinateSystem;
            return i && i.getArea && i.getArea(0.1);
          }
        }, t.prototype._updateSymbolDraw = function(e, i) {
          var r = this._symbolDraw, a = i.pipelineContext, o = a.large;
          return (!r || o !== this._isLargeDraw) && (r && r.remove(), r = this._symbolDraw = o ? new YSt() : new Sv(), this._isLargeDraw = o, this.group.removeAll()), this.group.add(r.group), r;
        }, t.prototype.remove = function(e, i) {
          this._symbolDraw && this._symbolDraw.remove(true), this._symbolDraw = null;
        }, t.prototype.dispose = function() {
        }, t.type = "scatter", t;
      }(Ve), XSt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.type = "grid", t.dependencies = ["xAxis", "yAxis"], t.layoutMode = "box", t.defaultOption = { show: false, z: 0, left: "10%", top: 60, right: "10%", bottom: 70, containLabel: false, backgroundColor: "rgba(0,0,0,0)", borderWidth: 1, borderColor: "#ccc" }, t;
      }(ne), qT = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.getCoordSysModel = function() {
          return this.getReferringComponents("grid", Ln).models[0];
        }, t.type = "cartesian2dAxis", t;
      }(ne);
      Mn(qT, mv);
      var $V = { show: true, z: 0, inverse: false, name: "", nameLocation: "end", nameRotate: null, nameTruncate: { maxWidth: null, ellipsis: "...", placeholder: "." }, nameTextStyle: {}, nameGap: 15, silent: false, triggerEvent: false, tooltip: { show: false }, axisPointer: {}, axisLine: { show: true, onZero: true, onZeroAxisIndex: null, lineStyle: { color: "#6E7079", width: 1, type: "solid" }, symbol: ["none", "none"], symbolSize: [10, 15] }, axisTick: { show: true, inside: false, length: 5, lineStyle: { width: 1 } }, axisLabel: { show: true, inside: false, rotate: 0, showMinLabel: null, showMaxLabel: null, margin: 8, fontSize: 12 }, splitLine: { show: true, lineStyle: { color: ["#E0E6F1"], width: 1, type: "solid" } }, splitArea: { show: false, areaStyle: { color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"] } } }, ZSt = qt({ boundaryGap: true, deduplication: null, splitLine: { show: false }, axisTick: { alignWithLabel: false, interval: "auto" }, axisLabel: { interval: "auto" } }, $V), HT = qt({ boundaryGap: [0, 0], axisLine: { show: "auto" }, axisTick: { show: "auto" }, splitNumber: 5, minorTick: { show: false, splitNumber: 5, length: 3, lineStyle: {} }, minorSplitLine: { show: false, lineStyle: { color: "#F4F7FD", width: 1 } } }, $V), KSt = qt({ splitNumber: 6, axisLabel: { showMinLabel: false, showMaxLabel: false, rich: { primary: { fontWeight: "bold" } } }, splitLine: { show: false } }, HT), $St = Et({ logBase: 10 }, HT);
      const JV = { category: ZSt, value: HT, time: KSt, log: $St };
      var JSt = { value: 1, category: 1, time: 1, log: 1 };
      function td(n, t, e, i) {
        M(JSt, function(r, a) {
          var o = qt(qt({}, JV[a], true), i, true), s = function(l) {
            V(u, l);
            function u() {
              var h = l !== null && l.apply(this, arguments) || this;
              return h.type = t + "Axis." + a, h;
            }
            return u.prototype.mergeDefaultAndTheme = function(h, c) {
              var f = Kp(this), g = f ? Pg(h) : {}, d = c.getTheme();
              qt(h, d.get(a + "Axis")), qt(h, this.getDefaultOption()), h.type = tj(h), f && iu(h, g, f);
            }, u.prototype.optionUpdated = function() {
              var h = this.option;
              h.type === "category" && (this.__ordinalMeta = uT.createByAxisModel(this));
            }, u.prototype.getCategories = function(h) {
              var c = this.option;
              if (c.type === "category") return h ? c.data : this.__ordinalMeta.categories;
            }, u.prototype.getOrdinalMeta = function() {
              return this.__ordinalMeta;
            }, u.type = t + "Axis." + a, u.defaultOption = o, u;
          }(e);
          n.registerComponentModel(s);
        }), n.registerSubTypeDefaulter(t + "Axis", tj);
      }
      function tj(n) {
        return n.type || (n.data ? "category" : "value");
      }
      var tbt = function() {
        function n(t) {
          this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = t || "";
        }
        return n.prototype.getAxis = function(t) {
          return this._axes[t];
        }, n.prototype.getAxes = function() {
          return Z(this._dimList, function(t) {
            return this._axes[t];
          }, this);
        }, n.prototype.getAxesByScale = function(t) {
          return t = t.toLowerCase(), Ne(this.getAxes(), function(e) {
            return e.scale.type === t;
          });
        }, n.prototype.addAxis = function(t) {
          var e = t.dim;
          this._axes[e] = t, this._dimList.push(e);
        }, n;
      }(), YT = ["x", "y"];
      function ej(n) {
        return n.type === "interval" || n.type === "time";
      }
      var ebt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "cartesian2d", e.dimensions = YT, e;
        }
        return t.prototype.calcAffineTransform = function() {
          this._transform = this._invTransform = null;
          var e = this.getAxis("x").scale, i = this.getAxis("y").scale;
          if (!(!ej(e) || !ej(i))) {
            var r = e.getExtent(), a = i.getExtent(), o = this.dataToPoint([r[0], a[0]]), s = this.dataToPoint([r[1], a[1]]), l = r[1] - r[0], u = a[1] - a[0];
            if (!(!l || !u)) {
              var h = (s[0] - o[0]) / l, c = (s[1] - o[1]) / u, f = o[0] - r[0] * h, g = o[1] - a[0] * c, d = this._transform = [h, 0, 0, c, f, g];
              this._invTransform = lg([], d);
            }
          }
        }, t.prototype.getBaseAxis = function() {
          return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
        }, t.prototype.containPoint = function(e) {
          var i = this.getAxis("x"), r = this.getAxis("y");
          return i.contain(i.toLocalCoord(e[0])) && r.contain(r.toLocalCoord(e[1]));
        }, t.prototype.containData = function(e) {
          return this.getAxis("x").containData(e[0]) && this.getAxis("y").containData(e[1]);
        }, t.prototype.containZone = function(e, i) {
          var r = this.dataToPoint(e), a = this.dataToPoint(i), o = this.getArea(), s = new Ht(r[0], r[1], a[0] - r[0], a[1] - r[1]);
          return o.intersect(s);
        }, t.prototype.dataToPoint = function(e, i, r) {
          r = r || [];
          var a = e[0], o = e[1];
          if (this._transform && a != null && isFinite(a) && o != null && isFinite(o)) return di(r, e, this._transform);
          var s = this.getAxis("x"), l = this.getAxis("y");
          return r[0] = s.toGlobalCoord(s.dataToCoord(a, i)), r[1] = l.toGlobalCoord(l.dataToCoord(o, i)), r;
        }, t.prototype.clampData = function(e, i) {
          var r = this.getAxis("x").scale, a = this.getAxis("y").scale, o = r.getExtent(), s = a.getExtent(), l = r.parse(e[0]), u = a.parse(e[1]);
          return i = i || [], i[0] = Math.min(Math.max(Math.min(o[0], o[1]), l), Math.max(o[0], o[1])), i[1] = Math.min(Math.max(Math.min(s[0], s[1]), u), Math.max(s[0], s[1])), i;
        }, t.prototype.pointToData = function(e, i) {
          var r = [];
          if (this._invTransform) return di(r, e, this._invTransform);
          var a = this.getAxis("x"), o = this.getAxis("y");
          return r[0] = a.coordToData(a.toLocalCoord(e[0]), i), r[1] = o.coordToData(o.toLocalCoord(e[1]), i), r;
        }, t.prototype.getOtherAxis = function(e) {
          return this.getAxis(e.dim === "x" ? "y" : "x");
        }, t.prototype.getArea = function(e) {
          e = e || 0;
          var i = this.getAxis("x").getGlobalExtent(), r = this.getAxis("y").getGlobalExtent(), a = Math.min(i[0], i[1]) - e, o = Math.min(r[0], r[1]) - e, s = Math.max(i[0], i[1]) - a + e, l = Math.max(r[0], r[1]) - o + e;
          return new Ht(a, o, s, l);
        }, t;
      }(tbt), nbt = function(n) {
        V(t, n);
        function t(e, i, r, a, o) {
          var s = n.call(this, e, i, r) || this;
          return s.index = 0, s.type = a || "value", s.position = o || "bottom", s;
        }
        return t.prototype.isHorizontal = function() {
          var e = this.position;
          return e === "top" || e === "bottom";
        }, t.prototype.getGlobalExtent = function(e) {
          var i = this.getExtent();
          return i[0] = this.toGlobalCoord(i[0]), i[1] = this.toGlobalCoord(i[1]), e && i[0] > i[1] && i.reverse(), i;
        }, t.prototype.pointToData = function(e, i) {
          return this.coordToData(this.toLocalCoord(e[this.dim === "x" ? 0 : 1]), i);
        }, t.prototype.setCategorySortInfo = function(e) {
          if (this.type !== "category") return false;
          this.model.option.categorySortInfo = e, this.scale.setSortInfo(e);
        }, t;
      }($a);
      function WT(n, t, e) {
        e = e || {};
        var i = n.coordinateSystem, r = t.axis, a = {}, o = r.getAxesOnZeroOf()[0], s = r.position, l = o ? "onZero" : s, u = r.dim, h = i.getRect(), c = [h.x, h.x + h.width, h.y, h.y + h.height], f = { left: 0, right: 1, top: 0, bottom: 1, onZero: 2 }, g = t.get("offset") || 0, d = u === "x" ? [c[2] - g, c[3] + g] : [c[0] - g, c[1] + g];
        if (o) {
          var A = o.toGlobalCoord(o.dataToCoord(0));
          d[f.onZero] = Math.max(Math.min(A, d[1]), d[0]);
        }
        a.position = [u === "y" ? d[f[l]] : c[0], u === "x" ? d[f[l]] : c[3]], a.rotation = Math.PI / 2 * (u === "x" ? 0 : 1);
        var p = { top: -1, bottom: 1, left: -1, right: 1 };
        a.labelDirection = a.tickDirection = a.nameDirection = p[s], a.labelOffset = o ? d[f[s]] - d[f.onZero] : 0, t.get(["axisTick", "inside"]) && (a.tickDirection = -a.tickDirection), Dn(e.labelInside, t.get(["axisLabel", "inside"])) && (a.labelDirection = -a.labelDirection);
        var v = t.get(["axisLabel", "rotate"]);
        return a.labelRotate = l === "top" ? -v : v, a.z2 = 1, a;
      }
      function nj(n) {
        return n.get("coordinateSystem") === "cartesian2d";
      }
      function ij(n) {
        var t = { xAxisModel: null, yAxisModel: null };
        return M(t, function(e, i) {
          var r = i.replace(/Model$/, ""), a = n.getReferringComponents(r, Ln).models[0];
          if (!a) throw new Error(r + ' "' + ra(n.get(r + "Index"), n.get(r + "Id"), 0) + '" not found');
          t[i] = a;
        }), t;
      }
      var XT = Math.log;
      function rj(n, t, e) {
        var i = Gs.prototype, r = i.getTicks.call(e), a = i.getTicks.call(e, true), o = r.length - 1, s = i.getInterval.call(e), l = AU(n, t), u = l.extent, h = l.fixMin, c = l.fixMax;
        if (n.type === "log") {
          var f = XT(n.base);
          u = [XT(u[0]) / f, XT(u[1]) / f];
        }
        n.setExtent(u[0], u[1]), n.calcNiceExtent({ splitNumber: o, fixMin: h, fixMax: c });
        var g = i.getExtent.call(n);
        h && (u[0] = g[0]), c && (u[1] = g[1]);
        var d = i.getInterval.call(n), A = u[0], p = u[1];
        if (h && c) d = (p - A) / o;
        else if (h) for (p = u[0] + d * o; p < u[1] && isFinite(p) && isFinite(u[1]); ) d = cT(d), p = u[0] + d * o;
        else if (c) for (A = u[1] - d * o; A > u[0] && isFinite(A) && isFinite(u[0]); ) d = cT(d), A = u[1] - d * o;
        else {
          var v = n.getTicks().length - 1;
          v > o && (d = cT(d));
          var y = d * o;
          p = Math.ceil(u[1] / d) * d, A = vn(p - y), A < 0 && u[0] >= 0 ? (A = 0, p = vn(y)) : p > 0 && u[1] <= 0 && (p = 0, A = -vn(y));
        }
        var m = (r[0].value - a[0].value) / s, _ = (r[o].value - a[o].value) / s;
        if (i.setExtent.call(n, A + d * m, p + d * _), i.setInterval.call(n, d), (m || _) && i.setNiceExtent.call(n, A + d, p - d), true) {
          var E = i.getTicks.call(n);
          E[1] && (!gwt(d) || c2(E[1].value) > c2(d)) && un("The ticks may be not readable when set min: " + t.get("min") + ", max: " + t.get("max") + " and alignTicks: true");
        }
      }
      var ibt = function() {
        function n(t, e, i) {
          this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = true, this.dimensions = YT, this._initCartesian(t, e, i), this.model = t;
        }
        return n.prototype.getRect = function() {
          return this._rect;
        }, n.prototype.update = function(t, e) {
          var i = this._axesMap;
          this._updateScale(t, this.model);
          function r(o) {
            var s, l = re(o), u = l.length;
            if (u) {
              for (var h = [], c = u - 1; c >= 0; c--) {
                var f = +l[c], g = o[f], d = g.model, A = g.scale;
                hT(A) && d.get("alignTicks") && d.get("interval") == null ? h.push(g) : (Xg(A, d), hT(A) && (s = g));
              }
              h.length && (s || (s = h.pop(), Xg(s.scale, s.model)), M(h, function(p) {
                rj(p.scale, p.model, s.scale);
              }));
            }
          }
          r(i.x), r(i.y);
          var a = {};
          M(i.x, function(o) {
            aj(i, "y", o, a);
          }), M(i.y, function(o) {
            aj(i, "x", o, a);
          }), this.resize(this.model, e);
        }, n.prototype.resize = function(t, e, i) {
          var r = t.getBoxLayoutParams(), a = !i && t.get("containLabel"), o = Gn(r, { width: e.getWidth(), height: e.getHeight() });
          this._rect = o;
          var s = this._axesList;
          l(), a && (M(s, function(u) {
            if (!u.model.get(["axisLabel", "inside"])) {
              var h = Fwt(u);
              if (h) {
                var c = u.isHorizontal() ? "height" : "width", f = u.model.get(["axisLabel", "margin"]);
                o[c] -= h[c] + f, u.position === "top" ? o.y += h.height + f : u.position === "left" && (o.x += h.width + f);
              }
            }
          }), l()), M(this._coordsList, function(u) {
            u.calcAffineTransform();
          });
          function l() {
            M(s, function(u) {
              var h = u.isHorizontal(), c = h ? [0, o.width] : [0, o.height], f = u.inverse ? 1 : 0;
              u.setExtent(c[f], c[1 - f]), rbt(u, h ? o.x : o.y);
            });
          }
        }, n.prototype.getAxis = function(t, e) {
          var i = this._axesMap[t];
          if (i != null) return i[e || 0];
        }, n.prototype.getAxes = function() {
          return this._axesList.slice();
        }, n.prototype.getCartesian = function(t, e) {
          if (t != null && e != null) {
            var i = "x" + t + "y" + e;
            return this._coordsMap[i];
          }
          _t(t) && (e = t.yAxisIndex, t = t.xAxisIndex);
          for (var r = 0, a = this._coordsList; r < a.length; r++) if (a[r].getAxis("x").index === t || a[r].getAxis("y").index === e) return a[r];
        }, n.prototype.getCartesians = function() {
          return this._coordsList.slice();
        }, n.prototype.convertToPixel = function(t, e, i) {
          var r = this._findConvertTarget(e);
          return r.cartesian ? r.cartesian.dataToPoint(i) : r.axis ? r.axis.toGlobalCoord(r.axis.dataToCoord(i)) : null;
        }, n.prototype.convertFromPixel = function(t, e, i) {
          var r = this._findConvertTarget(e);
          return r.cartesian ? r.cartesian.pointToData(i) : r.axis ? r.axis.coordToData(r.axis.toLocalCoord(i)) : null;
        }, n.prototype._findConvertTarget = function(t) {
          var e = t.seriesModel, i = t.xAxisModel || e && e.getReferringComponents("xAxis", Ln).models[0], r = t.yAxisModel || e && e.getReferringComponents("yAxis", Ln).models[0], a = t.gridModel, o = this._coordsList, s, l;
          if (e) s = e.coordinateSystem, Wt(o, s) < 0 && (s = null);
          else if (i && r) s = this.getCartesian(i.componentIndex, r.componentIndex);
          else if (i) l = this.getAxis("x", i.componentIndex);
          else if (r) l = this.getAxis("y", r.componentIndex);
          else if (a) {
            var u = a.coordinateSystem;
            u === this && (s = this._coordsList[0]);
          }
          return { cartesian: s, axis: l };
        }, n.prototype.containPoint = function(t) {
          var e = this._coordsList[0];
          if (e) return e.containPoint(t);
        }, n.prototype._initCartesian = function(t, e, i) {
          var r = this, a = this, o = { left: false, right: false, top: false, bottom: false }, s = { x: {}, y: {} }, l = { x: 0, y: 0 };
          if (e.eachComponent("xAxis", u("x"), this), e.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
            this._axesMap = {}, this._axesList = [];
            return;
          }
          this._axesMap = s, M(s.x, function(h, c) {
            M(s.y, function(f, g) {
              var d = "x" + c + "y" + g, A = new ebt(d);
              A.master = r, A.model = t, r._coordsMap[d] = A, r._coordsList.push(A), A.addAxis(h), A.addAxis(f);
            });
          });
          function u(h) {
            return function(c, f) {
              if (ZT(c, t)) {
                var g = c.get("position");
                h === "x" ? g !== "top" && g !== "bottom" && (g = o.bottom ? "top" : "bottom") : g !== "left" && g !== "right" && (g = o.left ? "right" : "left"), o[g] = true;
                var d = new nbt(h, aI(c), [0, 0], c.get("type"), g), A = d.type === "category";
                d.onBand = A && c.get("boundaryGap"), d.inverse = c.get("inverse"), c.axis = d, d.model = c, d.grid = a, d.index = f, a._axesList.push(d), s[h][f] = d, l[h]++;
              }
            };
          }
        }, n.prototype._updateScale = function(t, e) {
          M(this._axesList, function(r) {
            if (r.scale.setExtent(1 / 0, -1 / 0), r.type === "category") {
              var a = r.model.get("categorySortInfo");
              r.scale.setSortInfo(a);
            }
          }), t.eachSeries(function(r) {
            if (nj(r)) {
              var a = ij(r), o = a.xAxisModel, s = a.yAxisModel;
              if (!ZT(o, e) || !ZT(s, e)) return;
              var l = this.getCartesian(o.componentIndex, s.componentIndex), u = r.getData(), h = l.getAxis("x"), c = l.getAxis("y");
              i(u, h), i(u, c);
            }
          }, this);
          function i(r, a) {
            M(oI(r, a.dim), function(o) {
              a.scale.unionExtentFromData(r, o);
            });
          }
        }, n.prototype.getTooltipAxes = function(t) {
          var e = [], i = [];
          return M(this.getCartesians(), function(r) {
            var a = t != null && t !== "auto" ? r.getAxis(t) : r.getBaseAxis(), o = r.getOtherAxis(a);
            Wt(e, a) < 0 && e.push(a), Wt(i, o) < 0 && i.push(o);
          }), { baseAxes: e, otherAxes: i };
        }, n.create = function(t, e) {
          var i = [];
          return t.eachComponent("grid", function(r, a) {
            var o = new n(r, t, e);
            o.name = "grid_" + a, o.resize(r, e, true), r.coordinateSystem = o, i.push(o);
          }), t.eachSeries(function(r) {
            if (nj(r)) {
              var a = ij(r), o = a.xAxisModel, s = a.yAxisModel, l = o.getCoordSysModel();
              if (true) {
                if (!l) throw new Error('Grid "' + ra(o.get("gridIndex"), o.get("gridId"), 0) + '" not found');
                if (o.getCoordSysModel() !== s.getCoordSysModel()) throw new Error("xAxis and yAxis must use the same grid");
              }
              var u = l.coordinateSystem;
              r.coordinateSystem = u.getCartesian(o.componentIndex, s.componentIndex);
            }
          }), i;
        }, n.dimensions = YT, n;
      }();
      function ZT(n, t) {
        return n.getCoordSysModel() === t;
      }
      function aj(n, t, e, i) {
        e.getAxesOnZeroOf = function() {
          return a ? [a] : [];
        };
        var r = n[t], a, o = e.model, s = o.get(["axisLine", "onZero"]), l = o.get(["axisLine", "onZeroAxisIndex"]);
        if (!s) return;
        if (l != null) oj(r[l]) && (a = r[l]);
        else for (var u in r) if (r.hasOwnProperty(u) && oj(r[u]) && !i[h(r[u])]) {
          a = r[u];
          break;
        }
        a && (i[h(a)] = true);
        function h(c) {
          return c.dim + "_" + c.index;
        }
      }
      function oj(n) {
        return n && n.type !== "category" && n.type !== "time" && kwt(n);
      }
      function rbt(n, t) {
        var e = n.getExtent(), i = e[0] + e[1];
        n.toGlobalCoord = n.dim === "x" ? function(r) {
          return r + t;
        } : function(r) {
          return i - r + t;
        }, n.toLocalCoord = n.dim === "x" ? function(r) {
          return r - t;
        } : function(r) {
          return i - r + t;
        };
      }
      var fu = Math.PI, Ji = function() {
        function n(t, e) {
          this.group = new Ct(), this.opt = e, this.axisModel = t, Et(e, { labelOffset: 0, nameDirection: 1, tickDirection: 1, labelDirection: 1, silent: true, handleAutoShown: function() {
            return true;
          } });
          var i = new Ct({ x: e.position[0], y: e.position[1], rotation: e.rotation });
          i.updateTransform(), this._transformGroup = i;
        }
        return n.prototype.hasBuilder = function(t) {
          return !!sj[t];
        }, n.prototype.add = function(t) {
          sj[t](this.opt, this.axisModel, this.group, this._transformGroup);
        }, n.prototype.getGroup = function() {
          return this.group;
        }, n.innerTextLayout = function(t, e, i) {
          var r = BG(e - t), a, o;
          return Bp(r) ? (o = i > 0 ? "top" : "bottom", a = "center") : Bp(r - fu) ? (o = i > 0 ? "bottom" : "top", a = "center") : (o = "middle", r > 0 && r < fu ? a = i > 0 ? "right" : "left" : a = i > 0 ? "left" : "right"), { rotation: r, textAlign: a, textVerticalAlign: o };
        }, n.makeAxisEventDataBase = function(t) {
          var e = { componentType: t.mainType, componentIndex: t.componentIndex };
          return e[t.mainType + "Index"] = t.componentIndex, e;
        }, n.isLabelSilent = function(t) {
          var e = t.get("tooltip");
          return t.get("silent") || !(t.get("triggerEvent") || e && e.show);
        }, n;
      }(), sj = { axisLine: function(n, t, e, i) {
        var r = t.get(["axisLine", "show"]);
        if (r === "auto" && n.handleAutoShown && (r = n.handleAutoShown("axisLine")), !!r) {
          var a = t.axis.getExtent(), o = i.transform, s = [a[0], 0], l = [a[1], 0], u = s[0] > l[0];
          o && (di(s, s, o), di(l, l, o));
          var h = Y({ lineCap: "round" }, t.getModel(["axisLine", "lineStyle"]).getLineStyle()), c = new Wn({ shape: { x1: s[0], y1: s[1], x2: l[0], y2: l[1] }, style: h, strokeContainThreshold: n.strokeContainThreshold || 5, silent: true, z2: 1 });
          Sg(c.shape, c.style.lineWidth), c.anid = "line", e.add(c);
          var f = t.get(["axisLine", "symbol"]);
          if (f != null) {
            var g = t.get(["axisLine", "symbolSize"]);
            ht(f) && (f = [f, f]), (ht(g) || pe(g)) && (g = [g, g]);
            var d = Uh(t.get(["axisLine", "symbolOffset"]) || 0, g), A = g[0], p = g[1];
            M([{ rotate: n.rotation + Math.PI / 2, offset: d[0], r: 0 }, { rotate: n.rotation - Math.PI / 2, offset: d[1], r: Math.sqrt((s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1])) }], function(v, y) {
              if (f[y] !== "none" && f[y] != null) {
                var m = Nn(f[y], -A / 2, -p / 2, A, p, h.stroke, true), _ = v.r + v.offset, E = u ? l : s;
                m.attr({ rotation: v.rotate, x: E[0] + _ * Math.cos(n.rotation), y: E[1] - _ * Math.sin(n.rotation), silent: true, z2: 11 }), e.add(m);
              }
            });
          }
        }
      }, axisTickLabel: function(n, t, e, i) {
        var r = sbt(e, i, t, n), a = ubt(e, i, t, n);
        if (obt(t, a, r), lbt(e, i, t, n.tickDirection), t.get(["axisLabel", "hideOverlap"])) {
          var o = kU(Z(a, function(s) {
            return { label: s, priority: s.z2, defaultAttr: { ignore: s.ignore } };
          }));
          OU(o);
        }
      }, axisName: function(n, t, e, i) {
        var r = Dn(n.axisName, t.get("name"));
        if (r) {
          var a = t.get("nameLocation"), o = n.nameDirection, s = t.getModel("nameTextStyle"), l = t.get("nameGap") || 0, u = t.axis.getExtent(), h = u[0] > u[1] ? -1 : 1, c = [a === "start" ? u[0] - h * l : a === "end" ? u[1] + h * l : (u[0] + u[1]) / 2, uj(a) ? n.labelOffset + o * l : 0], f, g = t.get("nameRotate");
          g != null && (g = g * fu / 180);
          var d;
          uj(a) ? f = Ji.innerTextLayout(n.rotation, g != null ? g : n.rotation, o) : (f = abt(n.rotation, a, g || 0, u), d = n.axisNameAvailableWidth, d != null && (d = Math.abs(d / Math.sin(f.rotation)), !isFinite(d) && (d = null)));
          var A = s.getFont(), p = t.get("nameTruncate", true) || {}, v = p.ellipsis, y = Dn(n.nameTruncateMaxWidth, p.maxWidth, d), m = new ge({ x: c[0], y: c[1], rotation: f.rotation, silent: Ji.isLabelSilent(t), style: Ke(s, { text: r, font: A, overflow: "truncate", width: y, ellipsis: v, fill: s.getTextColor() || t.get(["axisLine", "lineStyle", "color"]), align: s.get("align") || f.textAlign, verticalAlign: s.get("verticalAlign") || f.textVerticalAlign }), z2: 1 });
          if (bg({ el: m, componentModel: t, itemName: r }), m.__fullText = r, m.anid = "name", t.get("triggerEvent")) {
            var _ = Ji.makeAxisEventDataBase(t);
            _.targetType = "axisName", _.name = r, Dt(m).eventData = _;
          }
          i.add(m), m.updateTransform(), e.add(m), m.decomposeTransform();
        }
      } };
      function abt(n, t, e, i) {
        var r = BG(e - n), a, o, s = i[0] > i[1], l = t === "start" && !s || t !== "start" && s;
        return Bp(r - fu / 2) ? (o = l ? "bottom" : "top", a = "center") : Bp(r - fu * 1.5) ? (o = l ? "top" : "bottom", a = "center") : (o = "middle", r < fu * 1.5 && r > fu / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), { rotation: r, textAlign: a, textVerticalAlign: o };
      }
      function obt(n, t, e) {
        if (!pU(n.axis)) {
          var i = n.get(["axisLabel", "showMinLabel"]), r = n.get(["axisLabel", "showMaxLabel"]);
          t = t || [], e = e || [];
          var a = t[0], o = t[1], s = t[t.length - 1], l = t[t.length - 2], u = e[0], h = e[1], c = e[e.length - 1], f = e[e.length - 2];
          i === false ? (ma(a), ma(u)) : lj(a, o) && (i ? (ma(o), ma(h)) : (ma(a), ma(u))), r === false ? (ma(s), ma(c)) : lj(l, s) && (r ? (ma(l), ma(f)) : (ma(s), ma(c)));
        }
      }
      function ma(n) {
        n && (n.ignore = true);
      }
      function lj(n, t) {
        var e = n && n.getBoundingRect().clone(), i = t && t.getBoundingRect().clone();
        if (!(!e || !i)) {
          var r = d_([]);
          return oh(r, r, -n.rotation), e.applyTransform(Ss([], r, n.getLocalTransform())), i.applyTransform(Ss([], r, t.getLocalTransform())), e.intersect(i);
        }
      }
      function uj(n) {
        return n === "middle" || n === "center";
      }
      function hj(n, t, e, i, r) {
        for (var a = [], o = [], s = [], l = 0; l < n.length; l++) {
          var u = n[l].coord;
          o[0] = u, o[1] = 0, s[0] = u, s[1] = e, t && (di(o, o, t), di(s, s, t));
          var h = new Wn({ shape: { x1: o[0], y1: o[1], x2: s[0], y2: s[1] }, style: i, z2: 2, autoBatch: true, silent: true });
          Sg(h.shape, h.style.lineWidth), h.anid = r + "_" + n[l].tickValue, a.push(h);
        }
        return a;
      }
      function sbt(n, t, e, i) {
        var r = e.axis, a = e.getModel("axisTick"), o = a.get("show");
        if (o === "auto" && i.handleAutoShown && (o = i.handleAutoShown("axisTick")), !(!o || r.scale.isBlank())) {
          for (var s = a.getModel("lineStyle"), l = i.tickDirection * a.get("length"), u = r.getTicksCoords(), h = hj(u, t.transform, l, Et(s.getLineStyle(), { stroke: e.get(["axisLine", "lineStyle", "color"]) }), "ticks"), c = 0; c < h.length; c++) n.add(h[c]);
          return h;
        }
      }
      function lbt(n, t, e, i) {
        var r = e.axis, a = e.getModel("minorTick");
        if (!(!a.get("show") || r.scale.isBlank())) {
          var o = r.getMinorTicksCoords();
          if (o.length) for (var s = a.getModel("lineStyle"), l = i * a.get("length"), u = Et(s.getLineStyle(), Et(e.getModel("axisTick").getLineStyle(), { stroke: e.get(["axisLine", "lineStyle", "color"]) })), h = 0; h < o.length; h++) for (var c = hj(o[h], t.transform, l, u, "minorticks_" + h), f = 0; f < c.length; f++) n.add(c[f]);
        }
      }
      function ubt(n, t, e, i) {
        var r = e.axis, a = Dn(i.axisLabelShow, e.get(["axisLabel", "show"]));
        if (!(!a || r.scale.isBlank())) {
          var o = e.getModel("axisLabel"), s = o.get("margin"), l = r.getViewLabels(), u = (Dn(i.labelRotate, o.get("rotate")) || 0) * fu / 180, h = Ji.innerTextLayout(i.rotation, u, i.labelDirection), c = e.getCategories && e.getCategories(true), f = [], g = Ji.isLabelSilent(e), d = e.get("triggerEvent");
          return M(l, function(A, p) {
            var v = r.scale.type === "ordinal" ? r.scale.getRawOrdinalNumber(A.tickValue) : A.tickValue, y = A.formattedLabel, m = A.rawLabel, _ = o;
            if (c && c[v]) {
              var E = c[v];
              _t(E) && E.textStyle && (_ = new Te(E.textStyle, o, e.ecModel));
            }
            var I = _.getTextColor() || e.get(["axisLine", "lineStyle", "color"]), x = r.dataToCoord(v), w = _.getShallow("align", true) || h.textAlign, C = Pt(_.getShallow("alignMinLabel", true), w), S = Pt(_.getShallow("alignMaxLabel", true), w), b = _.getShallow("verticalAlign", true) || _.getShallow("baseline", true) || h.textVerticalAlign, B = Pt(_.getShallow("verticalAlignMinLabel", true), b), T = Pt(_.getShallow("verticalAlignMaxLabel", true), b), D = new ge({ x, y: i.labelOffset + i.labelDirection * s, rotation: h.rotation, silent: g, z2: 10 + (A.level || 0), style: Ke(_, { text: y, align: p === 0 ? C : p === l.length - 1 ? S : w, verticalAlign: p === 0 ? B : p === l.length - 1 ? T : b, fill: yt(I) ? I(r.type === "category" ? m : r.type === "value" ? v + "" : v, p) : I }) });
            if (D.anid = "label_" + v, d) {
              var R = Ji.makeAxisEventDataBase(e);
              R.targetType = "axisLabel", R.value = m, R.tickIndex = p, r.type === "category" && (R.dataIndex = v), Dt(D).eventData = R;
            }
            t.add(D), D.updateTransform(), f.push(D), n.add(D), D.decomposeTransform();
          }), f;
        }
      }
      function hbt(n, t) {
        var e = { axesInfo: {}, seriesInvolved: false, coordSysAxesInfo: {}, coordSysMap: {} };
        return cbt(e, n, t), e.seriesInvolved && gbt(e, n), e;
      }
      function cbt(n, t, e) {
        var i = t.getComponent("tooltip"), r = t.getComponent("axisPointer"), a = r.get("link", true) || [], o = [];
        M(e.getCoordinateSystems(), function(s) {
          if (!s.axisPointerEnabled) return;
          var l = Rv(s.model), u = n.coordSysAxesInfo[l] = {};
          n.coordSysMap[l] = s;
          var h = s.model, c = h.getModel("tooltip", i);
          if (M(s.getAxes(), Ot(A, false, null)), s.getTooltipAxes && i && c.get("show")) {
            var f = c.get("trigger") === "axis", g = c.get(["axisPointer", "type"]) === "cross", d = s.getTooltipAxes(c.get(["axisPointer", "axis"]));
            (f || g) && M(d.baseAxes, Ot(A, g ? "cross" : true, f)), g && M(d.otherAxes, Ot(A, "cross", false));
          }
          function A(p, v, y) {
            var m = y.model.getModel("axisPointer", r), _ = m.get("show");
            if (!(!_ || _ === "auto" && !p && !JT(m))) {
              v == null && (v = m.get("triggerTooltip")), m = p ? fbt(y, c, r, t, p, v) : m;
              var E = m.get("snap"), I = m.get("triggerEmphasis"), x = Rv(y.model), w = v || E || y.type === "category", C = n.axesInfo[x] = { key: x, axis: y, coordSys: s, axisPointerModel: m, triggerTooltip: v, triggerEmphasis: I, involveSeries: w, snap: E, useHandle: JT(m), seriesModels: [], linkGroup: null };
              u[x] = C, n.seriesInvolved = n.seriesInvolved || w;
              var S = dbt(a, y);
              if (S != null) {
                var b = o[S] || (o[S] = { axesInfo: {} });
                b.axesInfo[x] = C, b.mapper = a[S].mapper, C.linkGroup = b;
              }
            }
          }
        });
      }
      function fbt(n, t, e, i, r, a) {
        var o = t.getModel("axisPointer"), s = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
        M(s, function(f) {
          l[f] = xt(o.get(f));
        }), l.snap = n.type !== "category" && !!a, o.get("type") === "cross" && (l.type = "line");
        var u = l.label || (l.label = {});
        if (u.show == null && (u.show = false), r === "cross") {
          var h = o.get(["label", "show"]);
          if (u.show = h != null ? h : true, !a) {
            var c = l.lineStyle = o.get("crossStyle");
            c && Et(u, c.textStyle);
          }
        }
        return n.model.getModel("axisPointer", new Te(l, e, i));
      }
      function gbt(n, t) {
        t.eachSeries(function(e) {
          var i = e.coordinateSystem, r = e.get(["tooltip", "trigger"], true), a = e.get(["tooltip", "show"], true);
          !i || r === "none" || r === false || r === "item" || a === false || e.get(["axisPointer", "show"], true) === false || M(n.coordSysAxesInfo[Rv(i.model)], function(o) {
            var s = o.axis;
            i.getAxis(s.dim) === s && (o.seriesModels.push(e), o.seriesDataCount == null && (o.seriesDataCount = 0), o.seriesDataCount += e.getData().count());
          });
        });
      }
      function dbt(n, t) {
        for (var e = t.model, i = t.dim, r = 0; r < n.length; r++) {
          var a = n[r] || {};
          if (KT(a[i + "AxisId"], e.id) || KT(a[i + "AxisIndex"], e.componentIndex) || KT(a[i + "AxisName"], e.name)) return r;
        }
      }
      function KT(n, t) {
        return n === "all" || X(n) && Wt(n, t) >= 0 || n === t;
      }
      function Abt(n) {
        var t = $T(n);
        if (t) {
          var e = t.axisPointerModel, i = t.axis.scale, r = e.option, a = e.get("status"), o = e.get("value");
          o != null && (o = i.parse(o));
          var s = JT(e);
          a == null && (r.status = s ? "show" : "hide");
          var l = i.getExtent().slice();
          l[0] > l[1] && l.reverse(), (o == null || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), r.value = o, s && (r.status = t.axis.scale.isBlank() ? "hide" : "show");
        }
      }
      function $T(n) {
        var t = (n.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
        return t && t.axesInfo[Rv(n)];
      }
      function pbt(n) {
        var t = $T(n);
        return t && t.axisPointerModel;
      }
      function JT(n) {
        return !!n.get(["handle", "show"]);
      }
      function Rv(n) {
        return n.type + "||" + n.id;
      }
      var tM = {}, nc = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r, a) {
          this.axisPointerClass && Abt(e), n.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(e, r, true);
        }, t.prototype.updateAxisPointer = function(e, i, r, a) {
          this._doUpdateAxisPointerClass(e, r, false);
        }, t.prototype.remove = function(e, i) {
          var r = this._axisPointer;
          r && r.remove(i);
        }, t.prototype.dispose = function(e, i) {
          this._disposeAxisPointer(i), n.prototype.dispose.apply(this, arguments);
        }, t.prototype._doUpdateAxisPointerClass = function(e, i, r) {
          var a = t.getAxisPointerClass(this.axisPointerClass);
          if (a) {
            var o = pbt(e);
            o ? (this._axisPointer || (this._axisPointer = new a())).render(e, o, i, r) : this._disposeAxisPointer(i);
          }
        }, t.prototype._disposeAxisPointer = function(e) {
          this._axisPointer && this._axisPointer.dispose(e), this._axisPointer = null;
        }, t.registerAxisPointerClass = function(e, i) {
          if (tM[e]) throw new Error("axisPointer " + e + " exists");
          tM[e] = i;
        }, t.getAxisPointerClass = function(e) {
          return e && tM[e];
        }, t.type = "axis", t;
      }(on), eM = le();
      function cj(n, t, e, i) {
        var r = e.axis;
        if (!r.scale.isBlank()) {
          var a = e.getModel("splitArea"), o = a.getModel("areaStyle"), s = o.get("color"), l = i.coordinateSystem.getRect(), u = r.getTicksCoords({ tickModel: a, clamp: true });
          if (u.length) {
            var h = s.length, c = eM(n).splitAreaColors, f = dt(), g = 0;
            if (c) for (var d = 0; d < u.length; d++) {
              var A = c.get(u[d].tickValue);
              if (A != null) {
                g = (A + (h - 1) * d) % h;
                break;
              }
            }
            var p = r.toGlobalCoord(u[0].coord), v = o.getAreaStyle();
            s = X(s) ? s : [s];
            for (var d = 1; d < u.length; d++) {
              var y = r.toGlobalCoord(u[d].coord), m = void 0, _ = void 0, E = void 0, I = void 0;
              r.isHorizontal() ? (m = p, _ = l.y, E = y - m, I = l.height, p = m + E) : (m = l.x, _ = p, E = l.width, I = y - _, p = _ + I);
              var x = u[d - 1].tickValue;
              x != null && f.set(x, g), t.add(new ue({ anid: x != null ? "area_" + x : null, shape: { x: m, y: _, width: E, height: I }, style: Et({ fill: s[g] }, v), autoBatch: true, silent: true })), g = (g + 1) % h;
            }
            eM(n).splitAreaColors = f;
          }
        }
      }
      function fj(n) {
        eM(n).splitAreaColors = null;
      }
      var vbt = ["axisLine", "axisTickLabel", "axisName"], ybt = ["splitArea", "splitLine", "minorSplitLine"], gj = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.axisPointerClass = "CartesianAxisPointer", e;
        }
        return t.prototype.render = function(e, i, r, a) {
          this.group.removeAll();
          var o = this._axisGroup;
          if (this._axisGroup = new Ct(), this.group.add(this._axisGroup), !!e.get("show")) {
            var s = e.getCoordSysModel(), l = WT(s, e), u = new Ji(e, Y({ handleAutoShown: function(c) {
              for (var f = s.coordinateSystem.getCartesians(), g = 0; g < f.length; g++) if (hT(f[g].getOtherAxis(e.axis).scale)) return true;
              return false;
            } }, l));
            M(vbt, u.add, u), this._axisGroup.add(u.getGroup()), M(ybt, function(c) {
              e.get([c, "show"]) && mbt[c](this, this._axisGroup, e, s);
            }, this);
            var h = a && a.type === "changeAxisOrder" && a.isInitSort;
            h || qp(o, this._axisGroup, e), n.prototype.render.call(this, e, i, r, a);
          }
        }, t.prototype.remove = function() {
          fj(this);
        }, t.type = "cartesianAxis", t;
      }(nc), mbt = { splitLine: function(n, t, e, i) {
        var r = e.axis;
        if (!r.scale.isBlank()) {
          var a = e.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color");
          s = X(s) ? s : [s];
          for (var l = i.coordinateSystem.getRect(), u = r.isHorizontal(), h = 0, c = r.getTicksCoords({ tickModel: a }), f = [], g = [], d = o.getLineStyle(), A = 0; A < c.length; A++) {
            var p = r.toGlobalCoord(c[A].coord);
            u ? (f[0] = p, f[1] = l.y, g[0] = p, g[1] = l.y + l.height) : (f[0] = l.x, f[1] = p, g[0] = l.x + l.width, g[1] = p);
            var v = h++ % s.length, y = c[A].tickValue, m = new Wn({ anid: y != null ? "line_" + c[A].tickValue : null, autoBatch: true, shape: { x1: f[0], y1: f[1], x2: g[0], y2: g[1] }, style: Et({ stroke: s[v] }, d), silent: true });
            Sg(m.shape, d.lineWidth), t.add(m);
          }
        }
      }, minorSplitLine: function(n, t, e, i) {
        var r = e.axis, a = e.getModel("minorSplitLine"), o = a.getModel("lineStyle"), s = i.coordinateSystem.getRect(), l = r.isHorizontal(), u = r.getMinorTicksCoords();
        if (u.length) for (var h = [], c = [], f = o.getLineStyle(), g = 0; g < u.length; g++) for (var d = 0; d < u[g].length; d++) {
          var A = r.toGlobalCoord(u[g][d].coord);
          l ? (h[0] = A, h[1] = s.y, c[0] = A, c[1] = s.y + s.height) : (h[0] = s.x, h[1] = A, c[0] = s.x + s.width, c[1] = A);
          var p = new Wn({ anid: "minor_line_" + u[g][d].tickValue, autoBatch: true, shape: { x1: h[0], y1: h[1], x2: c[0], y2: c[1] }, style: f, silent: true });
          Sg(p.shape, f.lineWidth), t.add(p);
        }
      }, splitArea: function(n, t, e, i) {
        cj(n, t, e, i);
      } }, dj = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "xAxis", t;
      }(gj), _bt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = dj.type, e;
        }
        return t.type = "yAxis", t;
      }(gj), Ibt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "grid", e;
        }
        return t.prototype.render = function(e, i) {
          this.group.removeAll(), e.get("show") && this.group.add(new ue({ shape: e.coordinateSystem.getRect(), style: Et({ fill: e.get("backgroundColor") }, e.getItemStyle()), silent: true, z2: -1 }));
        }, t.type = "grid", t;
      }(on), Aj = { offset: 0 };
      function pj(n) {
        n.registerComponentView(Ibt), n.registerComponentModel(XSt), n.registerCoordinateSystem("cartesian2d", ibt), td(n, "x", qT, Aj), td(n, "y", qT, Aj), n.registerComponentView(dj), n.registerComponentView(_bt), n.registerPreprocessor(function(t) {
          t.xAxis && t.yAxis && !t.grid && (t.grid = {});
        });
      }
      function Ebt(n) {
        Zt(pj), n.registerSeriesModel(jSt), n.registerChartView(WSt), n.registerLayout(Bv("scatter"));
      }
      function xbt(n) {
        n.eachSeriesByType("radar", function(t) {
          var e = t.getData(), i = [], r = t.coordinateSystem;
          if (r) {
            var a = r.getIndicatorAxes();
            M(a, function(o, s) {
              e.each(e.mapDimension(a[s].dim), function(l, u) {
                i[u] = i[u] || [];
                var h = r.dataToPoint(l, s);
                i[u][s] = vj(h) ? h : yj(r);
              });
            }), e.each(function(o) {
              var s = s0t(i[o], function(l) {
                return vj(l);
              }) || yj(r);
              i[o].push(s.slice()), e.setItemLayout(o, i[o]);
            });
          }
        });
      }
      function vj(n) {
        return !isNaN(n[0]) && !isNaN(n[1]);
      }
      function yj(n) {
        return [n.cx, n.cy];
      }
      function wbt(n) {
        var t = n.polar;
        if (t) {
          X(t) || (t = [t]);
          var e = [];
          M(t, function(i, r) {
            i.indicator ? (i.type && !i.shape && (i.shape = i.type), n.radar = n.radar || [], X(n.radar) || (n.radar = [n.radar]), n.radar.push(i)) : e.push(i);
          }), n.polar = e;
        }
        M(n.series, function(i) {
          i && i.type === "radar" && i.polarIndex && (i.radarIndex = i.polarIndex);
        });
      }
      var Cbt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = e.coordinateSystem, o = this.group, s = e.getData(), l = this._data;
          function u(f, g) {
            var d = f.getItemVisual(g, "symbol") || "circle";
            if (d !== "none") {
              var A = Vg(f.getItemVisual(g, "symbolSize")), p = Nn(d, -1, -1, 2, 2), v = f.getItemVisual(g, "symbolRotate") || 0;
              return p.attr({ style: { strokeNoScale: true }, z2: 100, scaleX: A[0] / 2, scaleY: A[1] / 2, rotation: v * Math.PI / 180 || 0 }), p;
            }
          }
          function h(f, g, d, A, p, v) {
            d.removeAll();
            for (var y = 0; y < g.length - 1; y++) {
              var m = u(A, p);
              m && (m.__dimIdx = y, f[y] ? (m.setPosition(f[y]), Ph[v ? "initProps" : "updateProps"](m, { x: g[y][0], y: g[y][1] }, e, p)) : m.setPosition(g[y]), d.add(m));
            }
          }
          function c(f) {
            return Z(f, function(g) {
              return [a.cx, a.cy];
            });
          }
          s.diff(l).add(function(f) {
            var g = s.getItemLayout(f);
            if (g) {
              var d = new Yi(), A = new Wi(), p = { shape: { points: g } };
              d.shape.points = c(g), A.shape.points = c(g), nn(d, p, e, f), nn(A, p, e, f);
              var v = new Ct(), y = new Ct();
              v.add(A), v.add(d), v.add(y), h(A.shape.points, g, y, s, f, true), s.setItemGraphicEl(f, v);
            }
          }).update(function(f, g) {
            var d = l.getItemGraphicEl(g), A = d.childAt(0), p = d.childAt(1), v = d.childAt(2), y = { shape: { points: s.getItemLayout(f) } };
            y.shape.points && (h(A.shape.points, y.shape.points, v, s, f, false), Ya(p), Ya(A), _e(A, y, e), _e(p, y, e), s.setItemGraphicEl(f, d));
          }).remove(function(f) {
            o.remove(l.getItemGraphicEl(f));
          }).execute(), s.eachItemGraphicEl(function(f, g) {
            var d = s.getItemModel(g), A = f.childAt(0), p = f.childAt(1), v = f.childAt(2), y = s.getItemVisual(g, "style"), m = y.fill;
            o.add(f), A.useStyle(Et(d.getModel("lineStyle").getLineStyle(), { fill: "none", stroke: m })), pi(A, d, "lineStyle"), pi(p, d, "areaStyle");
            var _ = d.getModel("areaStyle"), E = _.isEmpty() && _.parentModel.isEmpty();
            p.ignore = E, M(["emphasis", "select", "blur"], function(w) {
              var C = d.getModel([w, "areaStyle"]), S = C.isEmpty() && C.parentModel.isEmpty();
              p.ensureState(w).ignore = S && E;
            }), p.useStyle(Et(_.getAreaStyle(), { fill: m, opacity: 0.7, decal: y.decal }));
            var I = d.getModel("emphasis"), x = I.getModel("itemStyle").getItemStyle();
            v.eachChild(function(w) {
              if (w instanceof li) {
                var C = w.style;
                w.useStyle(Y({ image: C.image, x: C.x, y: C.y, width: C.width, height: C.height }, y));
              } else w.useStyle(y), w.setColor(m), w.style.strokeNoScale = true;
              var S = w.ensureState("emphasis");
              S.style = xt(x);
              var b = s.getStore().get(s.getDimensionIndex(w.__dimIdx), g);
              (b == null || isNaN(b)) && (b = ""), vi(w, Xn(d), { labelFetcher: s.hostModel, labelDataIndex: g, labelDimIndex: w.__dimIdx, defaultText: b, inheritColor: m, defaultOpacity: y.opacity });
            }), hn(f, I.get("focus"), I.get("blurScope"), I.get("disabled"));
          }), this._data = s;
        }, t.prototype.remove = function() {
          this.group.removeAll(), this._data = null;
        }, t.type = "radar", t;
      }(Ve), Sbt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.hasSymbolVisual = true, e;
        }
        return t.prototype.init = function(e) {
          n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Dv(ct(this.getData, this), ct(this.getRawData, this));
        }, t.prototype.getInitialData = function(e, i) {
          return Jg(this, { generateCoord: "indicator_", generateCoordCount: 1 / 0 });
        }, t.prototype.formatTooltip = function(e, i, r) {
          var a = this.getData(), o = this.coordinateSystem, s = o.getIndicatorAxes(), l = this.getData().getName(e), u = l === "" ? this.name : l, h = D8(this, e);
          return Zn("section", { header: u, sortBlocks: true, blocks: Z(s, function(c) {
            var f = a.get(a.mapDimension(c.dim), e);
            return Zn("nameValue", { markerType: "subItem", markerColor: h, name: c.name, value: f, sortParam: f });
          }) });
        }, t.prototype.getTooltipPosition = function(e) {
          if (e != null) {
            for (var i = this.getData(), r = this.coordinateSystem, a = i.getValues(Z(r.dimensions, function(u) {
              return i.mapDimension(u);
            }), e), o = 0, s = a.length; o < s; o++) if (!isNaN(a[o])) {
              var l = r.getIndicatorAxes();
              return r.coordToPoint(l[o].dataToCoord(a[o]), o);
            }
          }
        }, t.type = "series.radar", t.dependencies = ["radar"], t.defaultOption = { z: 2, colorBy: "data", coordinateSystem: "radar", legendHoverLink: true, radarIndex: 0, lineStyle: { width: 2, type: "solid", join: "round" }, label: { position: "top" }, symbolSize: 8 }, t;
      }($e), Lv = JV.value;
      function mI(n, t) {
        return Et({ show: t }, n);
      }
      var bbt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.optionUpdated = function() {
          var e = this.get("boundaryGap"), i = this.get("splitNumber"), r = this.get("scale"), a = this.get("axisLine"), o = this.get("axisTick"), s = this.get("axisLabel"), l = this.get("axisName"), u = this.get(["axisName", "show"]), h = this.get(["axisName", "formatter"]), c = this.get("axisNameGap"), f = this.get("triggerEvent"), g = Z(this.get("indicator") || [], function(d) {
            d.max != null && d.max > 0 && !d.min ? d.min = 0 : d.min != null && d.min < 0 && !d.max && (d.max = 0);
            var A = l;
            d.color != null && (A = Et({ color: d.color }, l));
            var p = qt(xt(d), { boundaryGap: e, splitNumber: i, scale: r, axisLine: a, axisTick: o, axisLabel: s, name: d.text, showName: u, nameLocation: "end", nameGap: c, nameTextStyle: A, triggerEvent: f }, false);
            if (ht(h)) {
              var v = p.name;
              p.name = h.replace("{value}", v != null ? v : "");
            } else yt(h) && (p.name = h(p.name, p));
            var y = new Te(p, null, this.ecModel);
            return Mn(y, mv.prototype), y.mainType = "radar", y.componentIndex = this.componentIndex, y;
          }, this);
          this._indicatorModels = g;
        }, t.prototype.getIndicatorModels = function() {
          return this._indicatorModels;
        }, t.type = "radar", t.defaultOption = { z: 0, center: ["50%", "50%"], radius: "75%", startAngle: 90, axisName: { show: true }, boundaryGap: [0, 0], splitNumber: 5, axisNameGap: 15, scale: false, shape: "polygon", axisLine: qt({ lineStyle: { color: "#bbb" } }, Lv.axisLine), axisLabel: mI(Lv.axisLabel, false), axisTick: mI(Lv.axisTick, false), splitLine: mI(Lv.splitLine, true), splitArea: mI(Lv.splitArea, true), indicator: [] }, t;
      }(ne), Bbt = ["axisLine", "axisTickLabel", "axisName"], Tbt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = this.group;
          a.removeAll(), this._buildAxes(e), this._buildSplitLineAndArea(e);
        }, t.prototype._buildAxes = function(e) {
          var i = e.coordinateSystem, r = i.getIndicatorAxes(), a = Z(r, function(o) {
            var s = o.model.get("showName") ? o.name : "", l = new Ji(o.model, { axisName: s, position: [i.cx, i.cy], rotation: o.angle, labelDirection: -1, tickDirection: -1, nameDirection: 1 });
            return l;
          });
          M(a, function(o) {
            M(Bbt, o.add, o), this.group.add(o.getGroup());
          }, this);
        }, t.prototype._buildSplitLineAndArea = function(e) {
          var i = e.coordinateSystem, r = i.getIndicatorAxes();
          if (!r.length) return;
          var a = e.get("shape"), o = e.getModel("splitLine"), s = e.getModel("splitArea"), l = o.getModel("lineStyle"), u = s.getModel("areaStyle"), h = o.get("show"), c = s.get("show"), f = l.get("color"), g = u.get("color"), d = X(f) ? f : [f], A = X(g) ? g : [g], p = [], v = [];
          function y(R, L, k) {
            var P = k % L.length;
            return R[P] = R[P] || [], P;
          }
          if (a === "circle") for (var m = r[0].getTicksCoords(), _ = i.cx, E = i.cy, I = 0; I < m.length; I++) {
            if (h) {
              var x = y(p, d, I);
              p[x].push(new ks({ shape: { cx: _, cy: E, r: m[I].coord } }));
            }
            if (c && I < m.length - 1) {
              var x = y(v, A, I);
              v[x].push(new Gp({ shape: { cx: _, cy: E, r0: m[I].coord, r: m[I + 1].coord } }));
            }
          }
          else for (var w, C = Z(r, function(R, L) {
            var k = R.getTicksCoords();
            return w = w == null ? k.length - 1 : Math.min(k.length - 1, w), Z(k, function(P) {
              return i.coordToPoint(P.coord, L);
            });
          }), S = [], I = 0; I <= w; I++) {
            for (var b = [], B = 0; B < r.length; B++) b.push(C[B][I]);
            if (b[0] ? b.push(b[0].slice()) : "development", h) {
              var x = y(p, d, I);
              p[x].push(new Wi({ shape: { points: b } }));
            }
            if (c && S) {
              var x = y(v, A, I - 1);
              v[x].push(new Yi({ shape: { points: b.concat(S) } }));
            }
            S = b.slice().reverse();
          }
          var T = l.getLineStyle(), D = u.getAreaStyle();
          M(v, function(R, L) {
            this.group.add(fa(R, { style: Et({ stroke: "none", fill: A[L % A.length] }, D), silent: true }));
          }, this), M(p, function(R, L) {
            this.group.add(fa(R, { style: Et({ fill: "none", stroke: d[L % d.length] }, T), silent: true }));
          }, this);
        }, t.type = "radar", t;
      }(on), Mbt = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this, e, i, r) || this;
          return a.type = "value", a.angle = 0, a.name = "", a;
        }
        return t;
      }($a), Dbt = function() {
        function n(t, e, i) {
          this.dimensions = [], this._model = t, this._indicatorAxes = Z(t.getIndicatorModels(), function(r, a) {
            var o = "indicator_" + a, s = new Mbt(o, new Gs());
            return s.name = r.get("name"), s.model = r, r.axis = s, this.dimensions.push(o), s;
          }, this), this.resize(t, i);
        }
        return n.prototype.getIndicatorAxes = function() {
          return this._indicatorAxes;
        }, n.prototype.dataToPoint = function(t, e) {
          var i = this._indicatorAxes[e];
          return this.coordToPoint(i.dataToCoord(t), e);
        }, n.prototype.coordToPoint = function(t, e) {
          var i = this._indicatorAxes[e], r = i.angle, a = this.cx + t * Math.cos(r), o = this.cy - t * Math.sin(r);
          return [a, o];
        }, n.prototype.pointToData = function(t) {
          var e = t[0] - this.cx, i = t[1] - this.cy, r = Math.sqrt(e * e + i * i);
          e /= r, i /= r;
          for (var a = Math.atan2(-i, e), o = 1 / 0, s, l = -1, u = 0; u < this._indicatorAxes.length; u++) {
            var h = this._indicatorAxes[u], c = Math.abs(a - h.angle);
            c < o && (s = h, l = u, o = c);
          }
          return [l, +(s && s.coordToData(r))];
        }, n.prototype.resize = function(t, e) {
          var i = t.get("center"), r = e.getWidth(), a = e.getHeight(), o = Math.min(r, a) / 2;
          this.cx = ot(i[0], r), this.cy = ot(i[1], a), this.startAngle = t.get("startAngle") * Math.PI / 180;
          var s = t.get("radius");
          (ht(s) || pe(s)) && (s = [0, s]), this.r0 = ot(s[0], o), this.r = ot(s[1], o), M(this._indicatorAxes, function(l, u) {
            l.setExtent(this.r0, this.r);
            var h = this.startAngle + u * Math.PI * 2 / this._indicatorAxes.length;
            h = Math.atan2(Math.sin(h), Math.cos(h)), l.angle = h;
          }, this);
        }, n.prototype.update = function(t, e) {
          var i = this._indicatorAxes, r = this._model;
          M(i, function(s) {
            s.scale.setExtent(1 / 0, -1 / 0);
          }), t.eachSeriesByType("radar", function(s, l) {
            if (!(s.get("coordinateSystem") !== "radar" || t.getComponent("radar", s.get("radarIndex")) !== r)) {
              var u = s.getData();
              M(i, function(h) {
                h.scale.unionExtentFromData(u, u.mapDimension(h.dim));
              });
            }
          }, this);
          var a = r.get("splitNumber"), o = new Gs();
          o.setExtent(0, a), o.setInterval(1), M(i, function(s, l) {
            rj(s.scale, s.model, o);
          });
        }, n.prototype.convertToPixel = function(t, e, i) {
          return null;
        }, n.prototype.convertFromPixel = function(t, e, i) {
          return null;
        }, n.prototype.containPoint = function(t) {
          return false;
        }, n.create = function(t, e) {
          var i = [];
          return t.eachComponent("radar", function(r) {
            var a = new n(r, t, e);
            i.push(a), r.coordinateSystem = a;
          }), t.eachSeriesByType("radar", function(r) {
            r.get("coordinateSystem") === "radar" && (r.coordinateSystem = i[r.get("radarIndex") || 0]);
          }), i;
        }, n.dimensions = [], n;
      }();
      function Rbt(n) {
        n.registerCoordinateSystem("radar", Dbt), n.registerComponentModel(bbt), n.registerComponentView(Tbt), n.registerVisual({ seriesType: "radar", reset: function(t) {
          var e = t.getData();
          e.each(function(i) {
            e.setItemVisual(i, "legendIcon", "roundRect");
          }), e.setVisual("legendIcon", "roundRect");
        } });
      }
      function Lbt(n) {
        Zt(Rbt), n.registerChartView(Cbt), n.registerSeriesModel(Sbt), n.registerLayout(xbt), n.registerProcessor(Mv("radar")), n.registerPreprocessor(wbt);
      }
      var mj = "\0_ec_interaction_mutex";
      function Pbt(n, t, e) {
        var i = nM(n);
        i[t] = e;
      }
      function Nbt(n, t, e) {
        var i = nM(n), r = i[t];
        r === e && (i[t] = null);
      }
      function _j(n, t) {
        return !!nM(n)[t];
      }
      function nM(n) {
        return n[mj] || (n[mj] = {});
      }
      zo({ type: "takeGlobalCursor", event: "globalCursorTaken", update: "update" }, In);
      var Pv = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this) || this;
          i._zr = e;
          var r = ct(i._mousedownHandler, i), a = ct(i._mousemoveHandler, i), o = ct(i._mouseupHandler, i), s = ct(i._mousewheelHandler, i), l = ct(i._pinchHandler, i);
          return i.enable = function(u, h) {
            this.disable(), this._opt = Et(xt(h) || {}, { zoomOnMouseWheel: true, moveOnMouseMove: true, moveOnMouseWheel: false, preventDefaultMouseMove: true }), u == null && (u = true), (u === true || u === "move" || u === "pan") && (e.on("mousedown", r), e.on("mousemove", a), e.on("mouseup", o)), (u === true || u === "scale" || u === "zoom") && (e.on("mousewheel", s), e.on("pinch", l));
          }, i.disable = function() {
            e.off("mousedown", r), e.off("mousemove", a), e.off("mouseup", o), e.off("mousewheel", s), e.off("pinch", l);
          }, i;
        }
        return t.prototype.isDragging = function() {
          return this._dragging;
        }, t.prototype.isPinching = function() {
          return this._pinching;
        }, t.prototype.setPointerChecker = function(e) {
          this.pointerChecker = e;
        }, t.prototype.dispose = function() {
          this.disable();
        }, t.prototype._mousedownHandler = function(e) {
          if (!Dz(e)) {
            for (var i = e.target; i; ) {
              if (i.draggable) return;
              i = i.__hostTarget || i.parent;
            }
            var r = e.offsetX, a = e.offsetY;
            this.pointerChecker && this.pointerChecker(e, r, a) && (this._x = r, this._y = a, this._dragging = true);
          }
        }, t.prototype._mousemoveHandler = function(e) {
          if (!(!this._dragging || !_I("moveOnMouseMove", e, this._opt) || e.gestureEvent === "pinch" || _j(this._zr, "globalPan"))) {
            var i = e.offsetX, r = e.offsetY, a = this._x, o = this._y, s = i - a, l = r - o;
            this._x = i, this._y = r, this._opt.preventDefaultMouseMove && Cs(e.event), Ij(this, "pan", "moveOnMouseMove", e, { dx: s, dy: l, oldX: a, oldY: o, newX: i, newY: r, isAvailableBehavior: null });
          }
        }, t.prototype._mouseupHandler = function(e) {
          Dz(e) || (this._dragging = false);
        }, t.prototype._mousewheelHandler = function(e) {
          var i = _I("zoomOnMouseWheel", e, this._opt), r = _I("moveOnMouseWheel", e, this._opt), a = e.wheelDelta, o = Math.abs(a), s = e.offsetX, l = e.offsetY;
          if (!(a === 0 || !i && !r)) {
            if (i) {
              var u = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1, h = a > 0 ? u : 1 / u;
              iM(this, "zoom", "zoomOnMouseWheel", e, { scale: h, originX: s, originY: l, isAvailableBehavior: null });
            }
            if (r) {
              var c = Math.abs(a), f = (a > 0 ? 1 : -1) * (c > 3 ? 0.4 : c > 1 ? 0.15 : 0.05);
              iM(this, "scrollMove", "moveOnMouseWheel", e, { scrollDelta: f, originX: s, originY: l, isAvailableBehavior: null });
            }
          }
        }, t.prototype._pinchHandler = function(e) {
          if (!_j(this._zr, "globalPan")) {
            var i = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
            iM(this, "zoom", null, e, { scale: i, originX: e.pinchX, originY: e.pinchY, isAvailableBehavior: null });
          }
        }, t;
      }(aa);
      function iM(n, t, e, i, r) {
        n.pointerChecker && n.pointerChecker(i, r.originX, r.originY) && (Cs(i.event), Ij(n, t, e, i, r));
      }
      function Ij(n, t, e, i, r) {
        r.isAvailableBehavior = ct(_I, null, e, i), n.trigger(t, r);
      }
      function _I(n, t, e) {
        var i = e[n];
        return !n || i && (!ht(i) || t.event[i + "Key"]);
      }
      function rM(n, t, e) {
        var i = n.target;
        i.x += t, i.y += e, i.dirty();
      }
      function aM(n, t, e, i) {
        var r = n.target, a = n.zoomLimit, o = n.zoom = n.zoom || 1;
        if (o *= t, a) {
          var s = a.min || 0, l = a.max || 1 / 0;
          o = Math.max(Math.min(l, o), s);
        }
        var u = o / n.zoom;
        n.zoom = o, r.x -= (e - r.x) * (u - 1), r.y -= (i - r.y) * (u - 1), r.scaleX *= u, r.scaleY *= u, r.dirty();
      }
      var kbt = { axisPointer: 1, tooltip: 1, brush: 1 };
      function II(n, t, e) {
        var i = t.getComponentByElement(n.topTarget), r = i && i.coordinateSystem;
        return i && i !== e && !kbt.hasOwnProperty(i.mainType) && r && r.model !== e;
      }
      function Ej(n) {
        if (ht(n)) {
          var t = new DOMParser();
          n = t.parseFromString(n, "text/xml");
        }
        var e = n;
        for (e.nodeType === 9 && (e = e.firstChild); e.nodeName.toLowerCase() !== "svg" || e.nodeType !== 1; ) e = e.nextSibling;
        return e;
      }
      var oM, EI = { fill: "fill", stroke: "stroke", "stroke-width": "lineWidth", opacity: "opacity", "fill-opacity": "fillOpacity", "stroke-opacity": "strokeOpacity", "stroke-dasharray": "lineDash", "stroke-dashoffset": "lineDashOffset", "stroke-linecap": "lineCap", "stroke-linejoin": "lineJoin", "stroke-miterlimit": "miterLimit", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "text-anchor": "textAlign", visibility: "visibility", display: "display" }, xj = re(EI), xI = { "alignment-baseline": "textBaseline", "stop-color": "stopColor" }, wj = re(xI), Fbt = function() {
        function n() {
          this._defs = {}, this._root = null;
        }
        return n.prototype.parse = function(t, e) {
          e = e || {};
          var i = Ej(t);
          if (!i) throw new Error("Illegal svg");
          this._defsUsePending = [];
          var r = new Ct();
          this._root = r;
          var a = [], o = i.getAttribute("viewBox") || "", s = parseFloat(i.getAttribute("width") || e.width), l = parseFloat(i.getAttribute("height") || e.height);
          isNaN(s) && (s = null), isNaN(l) && (l = null), Vr(i, r, null, true, false);
          for (var u = i.firstChild; u; ) this._parseNode(u, r, a, null, false, false), u = u.nextSibling;
          zbt(this._defs, this._defsUsePending), this._defsUsePending = [];
          var h, c;
          if (o) {
            var f = wI(o);
            f.length >= 4 && (h = { x: parseFloat(f[0] || 0), y: parseFloat(f[1] || 0), width: parseFloat(f[2]), height: parseFloat(f[3]) });
          }
          if (h && s != null && l != null && (c = Rj(h, { x: 0, y: 0, width: s, height: l }), !e.ignoreViewBox)) {
            var g = r;
            r = new Ct(), r.add(g), g.scaleX = g.scaleY = c.scale, g.x = c.x, g.y = c.y;
          }
          return !e.ignoreRootClip && s != null && l != null && r.setClipPath(new ue({ shape: { x: 0, y: 0, width: s, height: l } })), { root: r, width: s, height: l, viewBoxRect: h, viewBoxTransform: c, named: a };
        }, n.prototype._parseNode = function(t, e, i, r, a, o) {
          var s = t.nodeName.toLowerCase(), l, u = r;
          if (s === "defs" && (a = true), s === "text" && (o = true), s === "defs" || s === "switch") l = e;
          else {
            if (!a) {
              var h = oM[s];
              if (h && ft(oM, s)) {
                l = h.call(this, t, e);
                var c = t.getAttribute("name");
                if (c) {
                  var f = { name: c, namedFrom: null, svgNodeTagLower: s, el: l };
                  i.push(f), s === "g" && (u = f);
                } else r && i.push({ name: r.name, namedFrom: r, svgNodeTagLower: s, el: l });
                e.add(l);
              }
            }
            var g = Cj[s];
            if (g && ft(Cj, s)) {
              var d = g.call(this, t), A = t.getAttribute("id");
              A && (this._defs[A] = d);
            }
          }
          if (l && l.isGroup) for (var p = t.firstChild; p; ) p.nodeType === 1 ? this._parseNode(p, l, i, u, a, o) : p.nodeType === 3 && o && this._parseText(p, l), p = p.nextSibling;
        }, n.prototype._parseText = function(t, e) {
          var i = new yg({ style: { text: t.textContent }, silent: true, x: this._textX || 0, y: this._textY || 0 });
          _a(e, i), Vr(t, i, this._defsUsePending, false, false), Qbt(i, e);
          var r = i.style, a = r.fontSize;
          a && a < 9 && (r.fontSize = 9, i.scaleX *= a / 9, i.scaleY *= a / 9);
          var o = (r.fontSize || r.fontFamily) && [r.fontStyle, r.fontWeight, (r.fontSize || 12) + "px", r.fontFamily || "sans-serif"].join(" ");
          r.font = o;
          var s = i.getBoundingRect();
          return this._textX += s.width, e.add(i), i;
        }, n.internalField = function() {
          oM = { g: function(t, e) {
            var i = new Ct();
            return _a(e, i), Vr(t, i, this._defsUsePending, false, false), i;
          }, rect: function(t, e) {
            var i = new ue();
            return _a(e, i), Vr(t, i, this._defsUsePending, false, false), i.setShape({ x: parseFloat(t.getAttribute("x") || "0"), y: parseFloat(t.getAttribute("y") || "0"), width: parseFloat(t.getAttribute("width") || "0"), height: parseFloat(t.getAttribute("height") || "0") }), i.silent = true, i;
          }, circle: function(t, e) {
            var i = new ks();
            return _a(e, i), Vr(t, i, this._defsUsePending, false, false), i.setShape({ cx: parseFloat(t.getAttribute("cx") || "0"), cy: parseFloat(t.getAttribute("cy") || "0"), r: parseFloat(t.getAttribute("r") || "0") }), i.silent = true, i;
          }, line: function(t, e) {
            var i = new Wn();
            return _a(e, i), Vr(t, i, this._defsUsePending, false, false), i.setShape({ x1: parseFloat(t.getAttribute("x1") || "0"), y1: parseFloat(t.getAttribute("y1") || "0"), x2: parseFloat(t.getAttribute("x2") || "0"), y2: parseFloat(t.getAttribute("y2") || "0") }), i.silent = true, i;
          }, ellipse: function(t, e) {
            var i = new n1();
            return _a(e, i), Vr(t, i, this._defsUsePending, false, false), i.setShape({ cx: parseFloat(t.getAttribute("cx") || "0"), cy: parseFloat(t.getAttribute("cy") || "0"), rx: parseFloat(t.getAttribute("rx") || "0"), ry: parseFloat(t.getAttribute("ry") || "0") }), i.silent = true, i;
          }, polygon: function(t, e) {
            var i = t.getAttribute("points"), r;
            i && (r = Bj(i));
            var a = new Yi({ shape: { points: r || [] }, silent: true });
            return _a(e, a), Vr(t, a, this._defsUsePending, false, false), a;
          }, polyline: function(t, e) {
            var i = t.getAttribute("points"), r;
            i && (r = Bj(i));
            var a = new Wi({ shape: { points: r || [] }, silent: true });
            return _a(e, a), Vr(t, a, this._defsUsePending, false, false), a;
          }, image: function(t, e) {
            var i = new li();
            return _a(e, i), Vr(t, i, this._defsUsePending, false, false), i.setStyle({ image: t.getAttribute("xlink:href") || t.getAttribute("href"), x: +t.getAttribute("x"), y: +t.getAttribute("y"), width: +t.getAttribute("width"), height: +t.getAttribute("height") }), i.silent = true, i;
          }, text: function(t, e) {
            var i = t.getAttribute("x") || "0", r = t.getAttribute("y") || "0", a = t.getAttribute("dx") || "0", o = t.getAttribute("dy") || "0";
            this._textX = parseFloat(i) + parseFloat(a), this._textY = parseFloat(r) + parseFloat(o);
            var s = new Ct();
            return _a(e, s), Vr(t, s, this._defsUsePending, false, true), s;
          }, tspan: function(t, e) {
            var i = t.getAttribute("x"), r = t.getAttribute("y");
            i != null && (this._textX = parseFloat(i)), r != null && (this._textY = parseFloat(r));
            var a = t.getAttribute("dx") || "0", o = t.getAttribute("dy") || "0", s = new Ct();
            return _a(e, s), Vr(t, s, this._defsUsePending, false, true), this._textX += parseFloat(a), this._textY += parseFloat(o), s;
          }, path: function(t, e) {
            var i = t.getAttribute("d") || "", r = V5(i);
            return _a(e, r), Vr(t, r, this._defsUsePending, false, false), r.silent = true, r;
          } };
        }(), n;
      }(), Cj = { lineargradient: function(n) {
        var t = parseInt(n.getAttribute("x1") || "0", 10), e = parseInt(n.getAttribute("y1") || "0", 10), i = parseInt(n.getAttribute("x2") || "10", 10), r = parseInt(n.getAttribute("y2") || "0", 10), a = new Vp(t, e, i, r);
        return Sj(n, a), bj(n, a), a;
      }, radialgradient: function(n) {
        var t = parseInt(n.getAttribute("cx") || "0", 10), e = parseInt(n.getAttribute("cy") || "0", 10), i = parseInt(n.getAttribute("r") || "0", 10), r = new X5(t, e, i);
        return Sj(n, r), bj(n, r), r;
      } };
      function Sj(n, t) {
        var e = n.getAttribute("gradientUnits");
        e === "userSpaceOnUse" && (t.global = true);
      }
      function bj(n, t) {
        for (var e = n.firstChild; e; ) {
          if (e.nodeType === 1 && e.nodeName.toLocaleLowerCase() === "stop") {
            var i = e.getAttribute("offset"), r = void 0;
            i && i.indexOf("%") > 0 ? r = parseInt(i, 10) / 100 : i ? r = parseFloat(i) : r = 0;
            var a = {};
            Dj(e, a, a);
            var o = a.stopColor || e.getAttribute("stop-color") || "#000000";
            t.colorStops.push({ offset: r, color: o });
          }
          e = e.nextSibling;
        }
      }
      function _a(n, t) {
        n && n.__inheritedStyle && (t.__inheritedStyle || (t.__inheritedStyle = {}), Et(t.__inheritedStyle, n.__inheritedStyle));
      }
      function Bj(n) {
        for (var t = wI(n), e = [], i = 0; i < t.length; i += 2) {
          var r = parseFloat(t[i]), a = parseFloat(t[i + 1]);
          e.push([r, a]);
        }
        return e;
      }
      function Vr(n, t, e, i, r) {
        var a = t, o = a.__inheritedStyle = a.__inheritedStyle || {}, s = {};
        n.nodeType === 1 && (Vbt(n, t), Dj(n, o, s), i || jbt(n, o, s)), a.style = a.style || {}, o.fill != null && (a.style.fill = Tj(a, "fill", o.fill, e)), o.stroke != null && (a.style.stroke = Tj(a, "stroke", o.stroke, e)), M(["lineWidth", "opacity", "fillOpacity", "strokeOpacity", "miterLimit", "fontSize"], function(l) {
          o[l] != null && (a.style[l] = parseFloat(o[l]));
        }), M(["lineDashOffset", "lineCap", "lineJoin", "fontWeight", "fontFamily", "fontStyle", "textAlign"], function(l) {
          o[l] != null && (a.style[l] = o[l]);
        }), r && (a.__selfStyle = s), o.lineDash && (a.style.lineDash = Z(wI(o.lineDash), function(l) {
          return parseFloat(l);
        })), (o.visibility === "hidden" || o.visibility === "collapse") && (a.invisible = true), o.display === "none" && (a.ignore = true);
      }
      function Qbt(n, t) {
        var e = t.__selfStyle;
        if (e) {
          var i = e.textBaseline, r = i;
          !i || i === "auto" || i === "baseline" ? r = "alphabetic" : i === "before-edge" || i === "text-before-edge" ? r = "top" : i === "after-edge" || i === "text-after-edge" ? r = "bottom" : (i === "central" || i === "mathematical") && (r = "middle"), n.style.textBaseline = r;
        }
        var a = t.__inheritedStyle;
        if (a) {
          var o = a.textAlign, s = o;
          o && (o === "middle" && (s = "center"), n.style.textAlign = s);
        }
      }
      var Obt = /^url\(\s*#(.*?)\)/;
      function Tj(n, t, e, i) {
        var r = e && e.match(Obt);
        if (r) {
          var a = Ga(r[1]);
          i.push([n, t, a]);
          return;
        }
        return e === "none" && (e = null), e;
      }
      function zbt(n, t) {
        for (var e = 0; e < t.length; e++) {
          var i = t[e];
          i[0].style[i[1]] = n[i[2]];
        }
      }
      var Gbt = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
      function wI(n) {
        return n.match(Gbt) || [];
      }
      var Ubt = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, sM = Math.PI / 180;
      function Vbt(n, t) {
        var e = n.getAttribute("transform");
        if (e) {
          e = e.replace(/,/g, " ");
          var i = [], r = null;
          e.replace(Ubt, function(c, f, g) {
            return i.push(f, g), "";
          });
          for (var a = i.length - 1; a > 0; a -= 2) {
            var o = i[a], s = i[a - 1], l = wI(o);
            switch (r = r || Fr(), s) {
              case "translate":
                bo(r, r, [parseFloat(l[0]), parseFloat(l[1] || "0")]);
                break;
              case "scale":
                Bb(r, r, [parseFloat(l[0]), parseFloat(l[1] || l[0])]);
                break;
              case "rotate":
                oh(r, r, -parseFloat(l[0]) * sM, [parseFloat(l[1] || "0"), parseFloat(l[2] || "0")]);
                break;
              case "skewX":
                var u = Math.tan(parseFloat(l[0]) * sM);
                Ss(r, [1, 0, u, 1, 0, 0], r);
                break;
              case "skewY":
                var h = Math.tan(parseFloat(l[0]) * sM);
                Ss(r, [1, h, 0, 1, 0, 0], r);
                break;
              case "matrix":
                r[0] = parseFloat(l[0]), r[1] = parseFloat(l[1]), r[2] = parseFloat(l[2]), r[3] = parseFloat(l[3]), r[4] = parseFloat(l[4]), r[5] = parseFloat(l[5]);
                break;
            }
          }
          t.setLocalTransform(r);
        }
      }
      var Mj = /([^\s:;]+)\s*:\s*([^:;]+)/g;
      function Dj(n, t, e) {
        var i = n.getAttribute("style");
        if (i) {
          Mj.lastIndex = 0;
          for (var r; (r = Mj.exec(i)) != null; ) {
            var a = r[1], o = ft(EI, a) ? EI[a] : null;
            o && (t[o] = r[2]);
            var s = ft(xI, a) ? xI[a] : null;
            s && (e[s] = r[2]);
          }
        }
      }
      function jbt(n, t, e) {
        for (var i = 0; i < xj.length; i++) {
          var r = xj[i], a = n.getAttribute(r);
          a != null && (t[EI[r]] = a);
        }
        for (var i = 0; i < wj.length; i++) {
          var r = wj[i], a = n.getAttribute(r);
          a != null && (e[xI[r]] = a);
        }
      }
      function Rj(n, t) {
        var e = t.width / n.width, i = t.height / n.height, r = Math.min(e, i);
        return { scale: r, x: -(n.x + n.width / 2) * r + (t.x + t.width / 2), y: -(n.y + n.height / 2) * r + (t.y + t.height / 2) };
      }
      function qbt(n, t) {
        var e = new Fbt();
        return e.parse(n, t);
      }
      var Hbt = dt(["rect", "circle", "line", "ellipse", "polygon", "polyline", "path", "text", "tspan", "g"]), Ybt = function() {
        function n(t, e) {
          this.type = "geoSVG", this._usedGraphicMap = dt(), this._freedGraphics = [], this._mapName = t, this._parsedXML = Ej(e);
        }
        return n.prototype.load = function() {
          var t = this._firstGraphic;
          if (!t) {
            t = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(t), this._boundingRect = this._firstGraphic.boundingRect.clone();
            var e = Xbt(t.named), i = e.regions, r = e.regionsMap;
            this._regions = i, this._regionsMap = r;
          }
          return { boundingRect: this._boundingRect, regions: this._regions, regionsMap: this._regionsMap };
        }, n.prototype._buildGraphic = function(t) {
          var e, i;
          try {
            e = t && qbt(t, { ignoreViewBox: true, ignoreRootClip: true }) || {}, i = e.root, It(i != null);
          } catch (p) {
            throw new Error(`Invalid svg format
` + p.message);
          }
          var r = new Ct();
          r.add(i), r.isGeoSVGGraphicRoot = true;
          var a = e.width, o = e.height, s = e.viewBoxRect, l = this._boundingRect;
          if (!l) {
            var u = void 0, h = void 0, c = void 0, f = void 0;
            if (a != null ? (u = 0, c = a) : s && (u = s.x, c = s.width), o != null ? (h = 0, f = o) : s && (h = s.y, f = s.height), u == null || h == null) {
              var g = i.getBoundingRect();
              u == null && (u = g.x, c = g.width), h == null && (h = g.y, f = g.height);
            }
            l = this._boundingRect = new Ht(u, h, c, f);
          }
          if (s) {
            var d = Rj(s, l);
            i.scaleX = i.scaleY = d.scale, i.x = d.x, i.y = d.y;
          }
          r.setClipPath(new ue({ shape: l.plain() }));
          var A = [];
          return M(e.named, function(p) {
            Hbt.get(p.svgNodeTagLower) != null && (A.push(p), Wbt(p.el));
          }), { root: r, boundingRect: l, named: A };
        }, n.prototype.useGraphic = function(t) {
          var e = this._usedGraphicMap, i = e.get(t);
          return i || (i = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), e.set(t, i), i);
        }, n.prototype.freeGraphic = function(t) {
          var e = this._usedGraphicMap, i = e.get(t);
          i && (e.removeKey(t), this._freedGraphics.push(i));
        }, n;
      }();
      function Wbt(n) {
        n.silent = false, n.isGroup && n.traverse(function(t) {
          t.silent = false;
        });
      }
      function Xbt(n) {
        var t = [], e = dt();
        return M(n, function(i) {
          if (i.namedFrom == null) {
            var r = new Vwt(i.name, i.el);
            t.push(r), e.set(i.name, r);
          }
        }), { regions: t, regionsMap: e };
      }
      for (var lM = [126, 25], Lj = "", ic = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]], rc = 0; rc < ic.length; rc++) for (var ed = 0; ed < ic[rc].length; ed++) ic[rc][ed][0] /= 10.5, ic[rc][ed][1] /= -10.5 / 0.75, ic[rc][ed][0] += lM[0], ic[rc][ed][1] += lM[1];
      function Zbt(n, t) {
        if (n === "china") {
          for (var e = 0; e < t.length; e++) if (t[e].name === Lj) return;
          t.push(new EU(Lj, Z(ic, function(i) {
            return { type: "polygon", exterior: i };
          }), lM));
        }
      }
      var Kbt = { : [32, 80], : [0, -10], : [10, 5], : [-10, 10], : [5, 5] };
      function $bt(n, t) {
        if (n === "china") {
          var e = Kbt[t.name];
          if (e) {
            var i = t.getCenter();
            i[0] += e[0] / 10.5, i[1] += -e[1] / (10.5 / 0.75), t.setCenter(i);
          }
        }
      }
      var Jbt = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
      function t2t(n, t) {
        n === "china" && t.name === "" && t.geometries.push({ type: "polygon", exterior: Jbt[0] });
      }
      var e2t = "name", n2t = function() {
        function n(t, e, i) {
          this.type = "geoJSON", this._parsedMap = dt(), this._mapName = t, this._specialAreas = i, this._geoJSON = r2t(e);
        }
        return n.prototype.load = function(t, e) {
          e = e || e2t;
          var i = this._parsedMap.get(e);
          if (!i) {
            var r = this._parseToRegions(e);
            i = this._parsedMap.set(e, { regions: r, boundingRect: i2t(r) });
          }
          var a = dt(), o = [];
          return M(i.regions, function(s) {
            var l = s.name;
            t && ft(t, l) && (s = s.cloneShallow(l = t[l])), o.push(s), a.set(l, s);
          }), { regions: o, boundingRect: i.boundingRect || new Ht(0, 0, 0, 0), regionsMap: a };
        }, n.prototype._parseToRegions = function(t) {
          var e = this._mapName, i = this._geoJSON, r;
          try {
            r = i ? qwt(i, t) : [];
          } catch (a) {
            throw new Error(`Invalid geoJson format
` + a.message);
          }
          return Zbt(e, r), M(r, function(a) {
            var o = a.name;
            $bt(e, a), t2t(e, a);
            var s = this._specialAreas && this._specialAreas[o];
            s && a.transformTo(s.left, s.top, s.width, s.height);
          }, this), r;
        }, n.prototype.getMapForUser = function() {
          return { geoJson: this._geoJSON, geoJSON: this._geoJSON, specialAreas: this._specialAreas };
        }, n;
      }();
      function i2t(n) {
        for (var t, e = 0; e < n.length; e++) {
          var i = n[e].getBoundingRect();
          t = t || i.clone(), t.union(i);
        }
        return t;
      }
      function r2t(n) {
        return ht(n) ? typeof JSON != "undefined" && JSON.parse ? JSON.parse(n) : new Function("return (" + n + ");")() : n;
      }
      var Nv = dt();
      const Us = { registerMap: function(n, t, e) {
        if (t.svg) {
          var i = new Ybt(n, t.svg);
          Nv.set(n, i);
        } else {
          var r = t.geoJson || t.geoJSON;
          r && !t.features ? e = t.specialAreas : r = t;
          var i = new n2t(n, r, e);
          Nv.set(n, i);
        }
      }, getGeoResource: function(n) {
        return Nv.get(n);
      }, getMapForUser: function(n) {
        var t = Nv.get(n);
        return t && t.type === "geoJSON" && t.getMapForUser();
      }, load: function(n, t, e) {
        var i = Nv.get(n);
        if (!i) {
          return;
        }
        return i.load(t, e);
      } };
      var uM = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"], a2t = dt(uM), o2t = dt(uM.concat(["g"])), s2t = dt(uM.concat(["g"])), Pj = le();
      function CI(n) {
        var t = n.getItemStyle(), e = n.get("areaColor");
        return e != null && (t.fill = e), t;
      }
      function Nj(n) {
        var t = n.style;
        t && (t.stroke = t.stroke || t.fill, t.fill = null);
      }
      var kj = function() {
        function n(t) {
          var e = new Ct();
          this.uid = Tg("ec_map_draw"), this._controller = new Pv(t.getZr()), this._controllerHost = { target: e }, this.group = e, e.add(this._regionsGroup = new Ct()), e.add(this._svgGroup = new Ct());
        }
        return n.prototype.draw = function(t, e, i, r, a) {
          var o = t.mainType === "geo", s = t.getData && t.getData();
          o && e.eachComponent({ mainType: "series", subType: "map" }, function(v) {
            !s && v.getHostGeoModel() === t && (s = v.getData());
          });
          var l = t.coordinateSystem, u = this._regionsGroup, h = this.group, c = l.getTransformInfo(), f = c.raw, g = c.roam, d = !u.childAt(0) || a;
          d ? (h.x = g.x, h.y = g.y, h.scaleX = g.scaleX, h.scaleY = g.scaleY, h.dirty()) : _e(h, g, t);
          var A = s && s.getVisual("visualMeta") && s.getVisual("visualMeta").length > 0, p = { api: i, geo: l, mapOrGeoModel: t, data: s, isVisualEncodedByVisualMap: A, isGeo: o, transformInfoRaw: f };
          l.resourceType === "geoJSON" ? this._buildGeoJSON(p) : l.resourceType === "geoSVG" && this._buildSVG(p), this._updateController(t, e, i), this._updateMapSelectHandler(t, u, i, r);
        }, n.prototype._buildGeoJSON = function(t) {
          var e = this._regionsGroupByName = dt(), i = dt(), r = this._regionsGroup, a = t.transformInfoRaw, o = t.mapOrGeoModel, s = t.data, l = t.geo.projection, u = l && l.stream;
          function h(g, d) {
            return d && (g = d(g)), g && [g[0] * a.scaleX + a.x, g[1] * a.scaleY + a.y];
          }
          function c(g) {
            for (var d = [], A = !u && l && l.project, p = 0; p < g.length; ++p) {
              var v = h(g[p], A);
              v && d.push(v);
            }
            return d;
          }
          function f(g) {
            return { shape: { points: c(g) } };
          }
          r.removeAll(), M(t.geo.regions, function(g) {
            var d = g.name, A = e.get(d), p = i.get(d) || {}, v = p.dataIdx, y = p.regionModel;
            A || (A = e.set(d, new Ct()), r.add(A), v = s ? s.indexOfName(d) : null, y = t.isGeo ? o.getRegionModel(d) : s ? s.getItemModel(v) : null, i.set(d, { dataIdx: v, regionModel: y }));
            var m = [], _ = [];
            M(g.geometries, function(x) {
              if (x.type === "polygon") {
                var w = [x.exterior].concat(x.interiors || []);
                u && (w = Uj(w, u)), M(w, function(S) {
                  m.push(new Yi(f(S)));
                });
              } else {
                var C = x.points;
                u && (C = Uj(C, u, true)), M(C, function(S) {
                  _.push(new Wi(f(S)));
                });
              }
            });
            var E = h(g.getCenter(), l && l.project);
            function I(x, w) {
              if (x.length) {
                var C = new Z2({ culling: true, segmentIgnoreThreshold: 1, shape: { paths: x } });
                A.add(C), Fj(t, C, v, y), Qj(t, C, d, y, o, v, E), w && (Nj(C), M(C.states, Nj));
              }
            }
            I(m), I(_, true);
          }), e.each(function(g, d) {
            var A = i.get(d), p = A.dataIdx, v = A.regionModel;
            Oj(t, g, d, v, o, p), zj(t, g, d, v, o), Gj(t, g, d, v, o);
          }, this);
        }, n.prototype._buildSVG = function(t) {
          var e = t.geo.map, i = t.transformInfoRaw;
          this._svgGroup.x = i.x, this._svgGroup.y = i.y, this._svgGroup.scaleX = i.scaleX, this._svgGroup.scaleY = i.scaleY, this._svgResourceChanged(e) && (this._freeSVG(), this._useSVG(e));
          var r = this._svgDispatcherMap = dt(), a = false;
          M(this._svgGraphicRecord.named, function(o) {
            var s = o.name, l = t.mapOrGeoModel, u = t.data, h = o.svgNodeTagLower, c = o.el, f = u ? u.indexOfName(s) : null, g = l.getRegionModel(s);
            if (a2t.get(h) != null && c instanceof ha && Fj(t, c, f, g), c instanceof ha && (c.culling = true), c.z2EmphasisLift = 0, !o.namedFrom && (s2t.get(h) != null && Qj(t, c, s, g, l, f, null), Oj(t, c, s, g, l, f), zj(t, c, s, g, l), o2t.get(h) != null)) {
              var d = Gj(t, c, s, g, l);
              d === "self" && (a = true);
              var A = r.get(s) || r.set(s, []);
              A.push(c);
            }
          }, this), this._enableBlurEntireSVG(a, t);
        }, n.prototype._enableBlurEntireSVG = function(t, e) {
          if (t && e.isGeo) {
            var i = e.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle(), r = i.opacity;
            this._svgGraphicRecord.root.traverse(function(a) {
              if (!a.isGroup) {
                bh(a);
                var o = a.ensureState("blur").style || {};
                o.opacity == null && r != null && (o.opacity = r), a.ensureState("emphasis");
              }
            });
          }
        }, n.prototype.remove = function() {
          this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
        }, n.prototype.findHighDownDispatchers = function(t, e) {
          if (t == null) return [];
          var i = e.coordinateSystem;
          if (i.resourceType === "geoJSON") {
            var r = this._regionsGroupByName;
            if (r) {
              var a = r.get(t);
              return a ? [a] : [];
            }
          } else if (i.resourceType === "geoSVG") return this._svgDispatcherMap && this._svgDispatcherMap.get(t) || [];
        }, n.prototype._svgResourceChanged = function(t) {
          return this._svgMapName !== t;
        }, n.prototype._useSVG = function(t) {
          var e = Us.getGeoResource(t);
          if (e && e.type === "geoSVG") {
            var i = e.useGraphic(this.uid);
            this._svgGroup.add(i.root), this._svgGraphicRecord = i, this._svgMapName = t;
          }
        }, n.prototype._freeSVG = function() {
          var t = this._svgMapName;
          if (t != null) {
            var e = Us.getGeoResource(t);
            e && e.type === "geoSVG" && e.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
          }
        }, n.prototype._updateController = function(t, e, i) {
          var r = t.coordinateSystem, a = this._controller, o = this._controllerHost;
          o.zoomLimit = t.get("scaleLimit"), o.zoom = r.getZoom(), a.enable(t.get("roam") || false);
          var s = t.mainType;
          function l() {
            var u = { type: "geoRoam", componentType: s };
            return u[s + "Id"] = t.id, u;
          }
          a.off("pan").on("pan", function(u) {
            this._mouseDownFlag = false, rM(o, u.dx, u.dy), i.dispatchAction(Y(l(), { dx: u.dx, dy: u.dy, animation: { duration: 0 } }));
          }, this), a.off("zoom").on("zoom", function(u) {
            this._mouseDownFlag = false, aM(o, u.scale, u.originX, u.originY), i.dispatchAction(Y(l(), { totalZoom: o.zoom, zoom: u.scale, originX: u.originX, originY: u.originY, animation: { duration: 0 } }));
          }, this), a.setPointerChecker(function(u, h, c) {
            return r.containPoint([h, c]) && !II(u, i, t);
          });
        }, n.prototype.resetForLabelLayout = function() {
          this.group.traverse(function(t) {
            var e = t.getTextContent();
            e && (e.ignore = Pj(e).ignore);
          });
        }, n.prototype._updateMapSelectHandler = function(t, e, i, r) {
          var a = this;
          e.off("mousedown"), e.off("click"), t.get("selectedMode") && (e.on("mousedown", function() {
            a._mouseDownFlag = true;
          }), e.on("click", function(o) {
            a._mouseDownFlag && (a._mouseDownFlag = false);
          }));
        }, n;
      }();
      function Fj(n, t, e, i) {
        var r = i.getModel("itemStyle"), a = i.getModel(["emphasis", "itemStyle"]), o = i.getModel(["blur", "itemStyle"]), s = i.getModel(["select", "itemStyle"]), l = CI(r), u = CI(a), h = CI(s), c = CI(o), f = n.data;
        if (f) {
          var g = f.getItemVisual(e, "style"), d = f.getItemVisual(e, "decal");
          n.isVisualEncodedByVisualMap && g.fill && (l.fill = g.fill), d && (l.decal = qg(d, n.api));
        }
        t.setStyle(l), t.style.strokeNoScale = true, t.ensureState("emphasis").style = u, t.ensureState("select").style = h, t.ensureState("blur").style = c, bh(t);
      }
      function Qj(n, t, e, i, r, a, o) {
        var s = n.data, l = n.isGeo, u = s && isNaN(s.get(s.mapDimension("value"), a)), h = s && s.getItemLayout(a);
        if (l || u || h && h.showLabel) {
          var c = l ? e : a, f = void 0;
          (!s || a >= 0) && (f = r);
          var g = o ? { normal: { align: "center", verticalAlign: "middle" } } : null;
          vi(t, Xn(i), { labelFetcher: f, labelDataIndex: c, defaultText: e }, g);
          var d = t.getTextContent();
          if (d && (Pj(d).ignore = d.ignore, t.textConfig && o)) {
            var A = t.getBoundingRect().clone();
            t.textConfig.layoutRect = A, t.textConfig.position = [(o[0] - A.x) / A.width * 100 + "%", (o[1] - A.y) / A.height * 100 + "%"];
          }
          t.disableLabelAnimation = true;
        } else t.removeTextContent(), t.removeTextConfig(), t.disableLabelAnimation = null;
      }
      function Oj(n, t, e, i, r, a) {
        n.data ? n.data.setItemGraphicEl(a, t) : Dt(t).eventData = { componentType: "geo", componentIndex: r.componentIndex, geoIndex: r.componentIndex, name: e, region: i && i.option || {} };
      }
      function zj(n, t, e, i, r) {
        n.data || bg({ el: t, componentModel: r, itemName: e, itemTooltipOption: i.get("tooltip") });
      }
      function Gj(n, t, e, i, r) {
        t.highDownSilentOnTouch = !!r.get("selectedMode");
        var a = i.getModel("emphasis"), o = a.get("focus");
        return hn(t, o, a.get("blurScope"), a.get("disabled")), n.isGeo && i1t(t, r, e), o;
      }
      function Uj(n, t, e) {
        var i = [], r;
        function a() {
          r = [];
        }
        function o() {
          r.length && (i.push(r), r = []);
        }
        var s = t({ polygonStart: a, polygonEnd: o, lineStart: a, lineEnd: o, point: function(l, u) {
          isFinite(l) && isFinite(u) && r.push([l, u]);
        }, sphere: function() {
        } });
        return !e && s.polygonStart(), M(n, function(l) {
          s.lineStart();
          for (var u = 0; u < l.length; u++) s.point(l[u][0], l[u][1]);
          s.lineEnd();
        }), !e && s.polygonEnd(), i;
      }
      var l2t = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r, a) {
          if (!(a && a.type === "mapToggleSelect" && a.from === this.uid)) {
            var o = this.group;
            if (o.removeAll(), !e.getHostGeoModel()) {
              if (this._mapDraw && a && a.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), a && a.type === "geoRoam" && a.componentType === "series" && a.seriesId === e.id) {
                var s = this._mapDraw;
                s && o.add(s.group);
              } else if (e.needsDrawMap) {
                var s = this._mapDraw || new kj(r);
                o.add(s.group), s.draw(e, i, r, this, a), this._mapDraw = s;
              } else this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
              e.get("showLegendSymbol") && i.getComponent("legend") && this._renderSymbols(e, i, r);
            }
          }
        }, t.prototype.remove = function() {
          this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
        }, t.prototype.dispose = function() {
          this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        }, t.prototype._renderSymbols = function(e, i, r) {
          var a = e.originalData, o = this.group;
          a.each(a.mapDimension("value"), function(s, l) {
            if (!isNaN(s)) {
              var u = a.getItemLayout(l);
              if (!(!u || !u.point)) {
                var h = u.point, c = u.offset, f = new ks({ style: { fill: e.getData().getVisual("style").fill }, shape: { cx: h[0] + c * 9, cy: h[1], r: 3 }, silent: true, z2: 8 + (c ? 0 : _g + 1) });
                if (!c) {
                  var g = e.mainSeries.getData(), d = a.getName(l), A = g.indexOfName(d), p = a.getItemModel(l), v = p.getModel("label"), y = g.getItemGraphicEl(A);
                  vi(f, Xn(p), { labelFetcher: { getFormattedLabel: function(m, _) {
                    return e.getFormattedLabel(A, _);
                  } }, defaultText: d }), f.disableLabelAnimation = true, v.get("position") || f.setTextConfig({ position: "bottom" }), y.onHoverStateChange = function(m) {
                    J_(f, m);
                  };
                }
                o.add(f);
              }
            }
          });
        }, t.type = "map", t;
      }(Ve), u2t = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.needsDrawMap = false, e.seriesGroup = [], e.getTooltipPosition = function(i) {
            if (i != null) {
              var r = this.getData().getName(i), a = this.coordinateSystem, o = a.getRegion(r);
              return o && a.dataToPoint(o.getCenter());
            }
          }, e;
        }
        return t.prototype.getInitialData = function(e) {
          for (var i = Jg(this, { coordDimensions: ["value"], encodeDefaulter: Ot(pB, this) }), r = dt(), a = [], o = 0, s = i.count(); o < s; o++) {
            var l = i.getName(o);
            r.set(l, true);
          }
          var u = Us.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
          return M(u.regions, function(h) {
            var c = h.name;
            r.get(c) || a.push(c);
          }), i.appendValues([], a), i;
        }, t.prototype.getHostGeoModel = function() {
          var e = this.option.geoIndex;
          return e != null ? this.ecModel.getComponent("geo", e) : null;
        }, t.prototype.getMapType = function() {
          return (this.getHostGeoModel() || this).option.map;
        }, t.prototype.getRawValue = function(e) {
          var i = this.getData();
          return i.get(i.mapDimension("value"), e);
        }, t.prototype.getRegionModel = function(e) {
          var i = this.getData();
          return i.getItemModel(i.indexOfName(e));
        }, t.prototype.formatTooltip = function(e, i, r) {
          for (var a = this.getData(), o = this.getRawValue(e), s = a.getName(e), l = this.seriesGroup, u = [], h = 0; h < l.length; h++) {
            var c = l[h].originalData.indexOfName(s), f = a.mapDimension("value");
            isNaN(l[h].originalData.get(f, c)) || u.push(l[h].name);
          }
          return Zn("section", { header: u.join(", "), noHeader: !u.length, blocks: [Zn("nameValue", { name: s, value: o })] });
        }, t.prototype.setZoom = function(e) {
          this.option.zoom = e;
        }, t.prototype.setCenter = function(e) {
          this.option.center = e;
        }, t.prototype.getLegendIcon = function(e) {
          var i = e.icon || "roundRect", r = Nn(i, 0, 0, e.itemWidth, e.itemHeight, e.itemStyle.fill);
          return r.setStyle(e.itemStyle), r.style.stroke = "none", i.indexOf("empty") > -1 && (r.style.stroke = r.style.fill, r.style.fill = "#fff", r.style.lineWidth = 2), r;
        }, t.type = "series.map", t.dependencies = ["geo"], t.layoutMode = "box", t.defaultOption = { z: 2, coordinateSystem: "geo", map: "", left: "center", top: "center", aspectScale: null, showLegendSymbol: true, boundingCoords: null, center: null, zoom: 1, scaleLimit: null, selectedMode: true, label: { show: false, color: "#000" }, itemStyle: { borderWidth: 0.5, borderColor: "#444", areaColor: "#eee" }, emphasis: { label: { show: true, color: "rgb(100,0,0)" }, itemStyle: { areaColor: "rgba(255,215,0,0.8)" } }, select: { label: { show: true, color: "rgb(100,0,0)" }, itemStyle: { color: "rgba(255,215,0,0.8)" } }, nameProperty: "name" }, t;
      }($e);
      function h2t(n, t) {
        var e = {};
        return M(n, function(i) {
          i.each(i.mapDimension("value"), function(r, a) {
            var o = "ec-" + i.getName(a);
            e[o] = e[o] || [], isNaN(r) || e[o].push(r);
          });
        }), n[0].map(n[0].mapDimension("value"), function(i, r) {
          for (var a = "ec-" + n[0].getName(r), o = 0, s = 1 / 0, l = -1 / 0, u = e[a].length, h = 0; h < u; h++) s = Math.min(s, e[a][h]), l = Math.max(l, e[a][h]), o += e[a][h];
          var c;
          return t === "min" ? c = s : t === "max" ? c = l : t === "average" ? c = o / u : c = o, u === 0 ? NaN : c;
        });
      }
      function c2t(n) {
        var t = {};
        n.eachSeriesByType("map", function(e) {
          var i = e.getHostGeoModel(), r = i ? "o" + i.id : "i" + e.getMapType();
          (t[r] = t[r] || []).push(e);
        }), M(t, function(e, i) {
          for (var r = h2t(Z(e, function(o) {
            return o.getData();
          }), e[0].get("mapValueCalculation")), a = 0; a < e.length; a++) e[a].originalData = e[a].getData();
          for (var a = 0; a < e.length; a++) e[a].seriesGroup = e, e[a].needsDrawMap = a === 0 && !e[a].getHostGeoModel(), e[a].setData(r.cloneShallow()), e[a].mainSeries = e[0];
        });
      }
      function f2t(n) {
        var t = {};
        n.eachSeriesByType("map", function(e) {
          var i = e.getMapType();
          if (!(e.getHostGeoModel() || t[i])) {
            var r = {};
            M(e.seriesGroup, function(o) {
              var s = o.coordinateSystem, l = o.originalData;
              o.get("showLegendSymbol") && n.getComponent("legend") && l.each(l.mapDimension("value"), function(u, h) {
                var c = l.getName(h), f = s.getRegion(c);
                if (!(!f || isNaN(u))) {
                  var g = r[c] || 0, d = s.dataToPoint(f.getCenter());
                  r[c] = g + 1, l.setItemLayout(h, { point: d, offset: g });
                }
              });
            });
            var a = e.getData();
            a.each(function(o) {
              var s = a.getName(o), l = a.getItemLayout(o) || {};
              l.showLabel = !r[s], a.setItemLayout(o, l);
            }), t[i] = true;
          }
        });
      }
      var Vj = di, kv = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this) || this;
          return i.type = "view", i.dimensions = ["x", "y"], i._roamTransformable = new Ts(), i._rawTransformable = new Ts(), i.name = e, i;
        }
        return t.prototype.setBoundingRect = function(e, i, r, a) {
          return this._rect = new Ht(e, i, r, a), this._rect;
        }, t.prototype.getBoundingRect = function() {
          return this._rect;
        }, t.prototype.setViewRect = function(e, i, r, a) {
          this._transformTo(e, i, r, a), this._viewRect = new Ht(e, i, r, a);
        }, t.prototype._transformTo = function(e, i, r, a) {
          var o = this.getBoundingRect(), s = this._rawTransformable;
          s.transform = o.calculateTransform(new Ht(e, i, r, a));
          var l = s.parent;
          s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform();
        }, t.prototype.setCenter = function(e, i) {
          e && (this._center = [ot(e[0], i.getWidth()), ot(e[1], i.getHeight())], this._updateCenterAndZoom());
        }, t.prototype.setZoom = function(e) {
          e = e || 1;
          var i = this.zoomLimit;
          i && (i.max != null && (e = Math.min(i.max, e)), i.min != null && (e = Math.max(i.min, e))), this._zoom = e, this._updateCenterAndZoom();
        }, t.prototype.getDefaultCenter = function() {
          var e = this.getBoundingRect(), i = e.x + e.width / 2, r = e.y + e.height / 2;
          return [i, r];
        }, t.prototype.getCenter = function() {
          return this._center || this.getDefaultCenter();
        }, t.prototype.getZoom = function() {
          return this._zoom || 1;
        }, t.prototype.getRoamTransform = function() {
          return this._roamTransformable.getLocalTransform();
        }, t.prototype._updateCenterAndZoom = function() {
          var e = this._rawTransformable.getLocalTransform(), i = this._roamTransformable, r = this.getDefaultCenter(), a = this.getCenter(), o = this.getZoom();
          a = di([], a, e), r = di([], r, e), i.originX = a[0], i.originY = a[1], i.x = r[0] - a[0], i.y = r[1] - a[1], i.scaleX = i.scaleY = o, this._updateTransform();
        }, t.prototype._updateTransform = function() {
          var e = this._roamTransformable, i = this._rawTransformable;
          i.parent = e, e.updateTransform(), i.updateTransform(), bb(this.transform || (this.transform = []), i.transform || Fr()), this._rawTransform = i.getLocalTransform(), this.invTransform = this.invTransform || [], lg(this.invTransform, this.transform), this.decomposeTransform();
        }, t.prototype.getTransformInfo = function() {
          var e = this._rawTransformable, i = this._roamTransformable, r = new Ts();
          return r.transform = i.transform, r.decomposeTransform(), { roam: { x: r.x, y: r.y, scaleX: r.scaleX, scaleY: r.scaleY }, raw: { x: e.x, y: e.y, scaleX: e.scaleX, scaleY: e.scaleY } };
        }, t.prototype.getViewRect = function() {
          return this._viewRect;
        }, t.prototype.getViewRectAfterRoam = function() {
          var e = this.getBoundingRect().clone();
          return e.applyTransform(this.transform), e;
        }, t.prototype.dataToPoint = function(e, i, r) {
          var a = i ? this._rawTransform : this.transform;
          return r = r || [], a ? Vj(r, e, a) : Vi(r, e);
        }, t.prototype.pointToData = function(e) {
          var i = this.invTransform;
          return i ? Vj([], e, i) : [e[0], e[1]];
        }, t.prototype.convertToPixel = function(e, i, r) {
          var a = jj(i);
          return a === this ? a.dataToPoint(r) : null;
        }, t.prototype.convertFromPixel = function(e, i, r) {
          var a = jj(i);
          return a === this ? a.pointToData(r) : null;
        }, t.prototype.containPoint = function(e) {
          return this.getViewRectAfterRoam().contain(e[0], e[1]);
        }, t.dimensions = ["x", "y"], t;
      }(Ts);
      function jj(n) {
        var t = n.seriesModel;
        return t ? t.coordinateSystem : null;
      }
      var g2t = { geoJSON: { aspectScale: 0.75, invertLongitute: true }, geoSVG: { aspectScale: 1, invertLongitute: false } }, qj = ["lng", "lat"], hM = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this, e) || this;
          a.dimensions = qj, a.type = "geo", a._nameCoordMap = dt(), a.map = i;
          var o = r.projection, s = Us.load(i, r.nameMap, r.nameProperty), l = Us.getGeoResource(i), u = a.resourceType = l ? l.type : null, h = a.regions = s.regions, c = g2t[l.type];
          a._regionsMap = s.regionsMap, a.regions = s.regions, o && (u === "geoSVG" && (un("Map " + i + " with SVG source can't use projection. Only GeoJSON source supports projection."), o = null), o.project && o.unproject || (un("project and unproject must be both provided in the projeciton."), o = null)), a.projection = o;
          var f;
          if (o) for (var g = 0; g < h.length; g++) {
            var d = h[g].getBoundingRect(o);
            f = f || d.clone(), f.union(d);
          }
          else f = s.boundingRect;
          return a.setBoundingRect(f.x, f.y, f.width, f.height), a.aspectScale = o ? 1 : Pt(r.aspectScale, c.aspectScale), a._invertLongitute = o ? false : c.invertLongitute, a;
        }
        return t.prototype._transformTo = function(e, i, r, a) {
          var o = this.getBoundingRect(), s = this._invertLongitute;
          o = o.clone(), s && (o.y = -o.y - o.height);
          var l = this._rawTransformable;
          l.transform = o.calculateTransform(new Ht(e, i, r, a));
          var u = l.parent;
          l.parent = null, l.decomposeTransform(), l.parent = u, s && (l.scaleY = -l.scaleY), this._updateTransform();
        }, t.prototype.getRegion = function(e) {
          return this._regionsMap.get(e);
        }, t.prototype.getRegionByCoord = function(e) {
          for (var i = this.regions, r = 0; r < i.length; r++) {
            var a = i[r];
            if (a.type === "geoJSON" && a.contain(e)) return i[r];
          }
        }, t.prototype.addGeoCoord = function(e, i) {
          this._nameCoordMap.set(e, i);
        }, t.prototype.getGeoCoord = function(e) {
          var i = this._regionsMap.get(e);
          return this._nameCoordMap.get(e) || i && i.getCenter();
        }, t.prototype.dataToPoint = function(e, i, r) {
          if (ht(e) && (e = this.getGeoCoord(e)), e) {
            var a = this.projection;
            return a && (e = a.project(e)), e && this.projectedToPoint(e, i, r);
          }
        }, t.prototype.pointToData = function(e) {
          var i = this.projection;
          return i && (e = i.unproject(e)), e && this.pointToProjected(e);
        }, t.prototype.pointToProjected = function(e) {
          return n.prototype.pointToData.call(this, e);
        }, t.prototype.projectedToPoint = function(e, i, r) {
          return n.prototype.dataToPoint.call(this, e, i, r);
        }, t.prototype.convertToPixel = function(e, i, r) {
          var a = Hj(i);
          return a === this ? a.dataToPoint(r) : null;
        }, t.prototype.convertFromPixel = function(e, i, r) {
          var a = Hj(i);
          return a === this ? a.pointToData(r) : null;
        }, t;
      }(kv);
      Mn(hM, kv);
      function Hj(n) {
        var t = n.geoModel, e = n.seriesModel;
        return t ? t.coordinateSystem : e ? e.coordinateSystem || (e.getReferringComponents("geo", Ln).models[0] || {}).coordinateSystem : null;
      }
      function Yj(n, t) {
        var e = n.get("boundingCoords");
        if (e != null) {
          var i = e[0], r = e[1];
          if (!(isFinite(i[0]) && isFinite(i[1]) && isFinite(r[0]) && isFinite(r[1]))) ;
          else {
            var a = this.projection;
            if (a) {
              var o = i[0], s = i[1], l = r[0], u = r[1];
              i = [1 / 0, 1 / 0], r = [-1 / 0, -1 / 0];
              var h = function(I, x, w, C) {
                for (var S = w - I, b = C - x, B = 0; B <= 100; B++) {
                  var T = B / 100, D = a.project([I + S * T, x + b * T]);
                  Gl(i, i, D), Ul(r, r, D);
                }
              };
              h(o, s, l, s), h(l, s, l, u), h(l, u, o, u), h(o, u, l, s);
            }
            this.setBoundingRect(i[0], i[1], r[0] - i[0], r[1] - i[1]);
          }
        }
        var c = this.getBoundingRect(), f = n.get("layoutCenter"), g = n.get("layoutSize"), d = t.getWidth(), A = t.getHeight(), p = c.width / c.height * this.aspectScale, v = false, y, m;
        f && g && (y = [ot(f[0], d), ot(f[1], A)], m = ot(g, Math.min(d, A)), !isNaN(y[0]) && !isNaN(y[1]) && !isNaN(m) ? v = true : "development");
        var _;
        if (v) _ = {}, p > 1 ? (_.width = m, _.height = m / p) : (_.height = m, _.width = m * p), _.y = y[1] - _.height / 2, _.x = y[0] - _.width / 2;
        else {
          var E = n.getBoxLayoutParams();
          E.aspect = p, _ = Gn(E, { width: d, height: A });
        }
        this.setViewRect(_.x, _.y, _.width, _.height), this.setCenter(n.get("center"), t), this.setZoom(n.get("zoom"));
      }
      function d2t(n, t) {
        M(t.get("geoCoord"), function(e, i) {
          n.addGeoCoord(i, e);
        });
      }
      var A2t = function() {
        function n() {
          this.dimensions = qj;
        }
        return n.prototype.create = function(t, e) {
          var i = [];
          function r(o) {
            return { nameProperty: o.get("nameProperty"), aspectScale: o.get("aspectScale"), projection: o.get("projection") };
          }
          t.eachComponent("geo", function(o, s) {
            var l = o.get("map"), u = new hM(l + s, l, Y({ nameMap: o.get("nameMap") }, r(o)));
            u.zoomLimit = o.get("scaleLimit"), i.push(u), o.coordinateSystem = u, u.model = o, u.resize = Yj, u.resize(o, e);
          }), t.eachSeries(function(o) {
            var s = o.get("coordinateSystem");
            if (s === "geo") {
              var l = o.get("geoIndex") || 0;
              o.coordinateSystem = i[l];
            }
          });
          var a = {};
          return t.eachSeriesByType("map", function(o) {
            if (!o.getHostGeoModel()) {
              var s = o.getMapType();
              a[s] = a[s] || [], a[s].push(o);
            }
          }), M(a, function(o, s) {
            var l = Z(o, function(h) {
              return h.get("nameMap");
            }), u = new hM(s, s, Y({ nameMap: gb(l) }, r(o[0])));
            u.zoomLimit = Dn.apply(null, Z(o, function(h) {
              return h.get("scaleLimit");
            })), i.push(u), u.resize = Yj, u.resize(o[0], e), M(o, function(h) {
              h.coordinateSystem = u, d2t(u, h);
            });
          }), i;
        }, n.prototype.getFilledRegions = function(t, e, i, r) {
          for (var a = (t || []).slice(), o = dt(), s = 0; s < a.length; s++) o.set(a[s].name, a[s]);
          var l = Us.load(e, i, r);
          return M(l.regions, function(u) {
            var h = u.name;
            !o.get(h) && a.push({ name: h });
          }), a;
        }, n;
      }(), Wj = new A2t(), p2t = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e, i, r) {
          var a = Us.getGeoResource(e.map);
          if (a && a.type === "geoJSON") {
            var o = e.itemStyle = e.itemStyle || {};
            "color" in o || (o.color = "#eee");
          }
          this.mergeDefaultAndTheme(e, r), dh(e, "label", ["show"]);
        }, t.prototype.optionUpdated = function() {
          var e = this, i = this.option;
          i.regions = Wj.getFilledRegions(i.regions, i.map, i.nameMap, i.nameProperty);
          var r = {};
          this._optionModelMap = So(i.regions || [], function(a, o) {
            var s = o.name;
            return s && (a.set(s, new Te(o, e, e.ecModel)), o.selected && (r[s] = true)), a;
          }, dt()), i.selectedMap || (i.selectedMap = r);
        }, t.prototype.getRegionModel = function(e) {
          return this._optionModelMap.get(e) || new Te(null, this, this.ecModel);
        }, t.prototype.getFormattedLabel = function(e, i) {
          var r = this.getRegionModel(e), a = i === "normal" ? r.get(["label", "formatter"]) : r.get(["emphasis", "label", "formatter"]), o = { name: e };
          if (yt(a)) return o.status = i, a(o);
          if (ht(a)) return a.replace("{a}", e != null ? e : "");
        }, t.prototype.setZoom = function(e) {
          this.option.zoom = e;
        }, t.prototype.setCenter = function(e) {
          this.option.center = e;
        }, t.prototype.select = function(e) {
          var i = this.option, r = i.selectedMode;
          if (r) {
            r !== "multiple" && (i.selectedMap = null);
            var a = i.selectedMap || (i.selectedMap = {});
            a[e] = true;
          }
        }, t.prototype.unSelect = function(e) {
          var i = this.option.selectedMap;
          i && (i[e] = false);
        }, t.prototype.toggleSelected = function(e) {
          this[this.isSelected(e) ? "unSelect" : "select"](e);
        }, t.prototype.isSelected = function(e) {
          var i = this.option.selectedMap;
          return !!(i && i[e]);
        }, t.type = "geo", t.layoutMode = "box", t.defaultOption = { z: 0, show: true, left: "center", top: "center", aspectScale: null, silent: false, map: "", boundingCoords: null, center: null, zoom: 1, scaleLimit: null, label: { show: false, color: "#000" }, itemStyle: { borderWidth: 0.5, borderColor: "#444" }, emphasis: { label: { show: true, color: "rgb(100,0,0)" }, itemStyle: { color: "rgba(255,215,0,0.8)" } }, select: { label: { show: true, color: "rgb(100,0,0)" }, itemStyle: { color: "rgba(255,215,0,0.8)" } }, regions: [] }, t;
      }(ne);
      function Xj(n, t) {
        return n.pointToProjected ? n.pointToProjected(t) : n.pointToData(t);
      }
      function cM(n, t, e, i) {
        var r = n.getZoom(), a = n.getCenter(), o = t.zoom, s = n.projectedToPoint ? n.projectedToPoint(a) : n.dataToPoint(a);
        if (t.dx != null && t.dy != null && (s[0] -= t.dx, s[1] -= t.dy, n.setCenter(Xj(n, s), i)), o != null) {
          if (e) {
            var l = e.min || 0, u = e.max || 1 / 0;
            o = Math.max(Math.min(r * o, u), l) / r;
          }
          n.scaleX *= o, n.scaleY *= o;
          var h = (t.originX - n.x) * (o - 1), c = (t.originY - n.y) * (o - 1);
          n.x -= h, n.y -= c, n.updateTransform(), n.setCenter(Xj(n, s), i), n.setZoom(o * r);
        }
        return { center: n.getCenter(), zoom: n.getZoom() };
      }
      var v2t = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.focusBlurEnabled = true, e;
        }
        return t.prototype.init = function(e, i) {
          this._api = i;
        }, t.prototype.render = function(e, i, r, a) {
          if (this._model = e, !e.get("show")) {
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
            return;
          }
          this._mapDraw || (this._mapDraw = new kj(r));
          var o = this._mapDraw;
          o.draw(e, i, r, this, a), o.group.on("click", this._handleRegionClick, this), o.group.silent = e.get("silent"), this.group.add(o.group), this.updateSelectStatus(e, i, r);
        }, t.prototype._handleRegionClick = function(e) {
          var i;
          Gh(e.target, function(r) {
            return (i = Dt(r).eventData) != null;
          }, true), i && this._api.dispatchAction({ type: "geoToggleSelect", geoId: this._model.id, name: i.name });
        }, t.prototype.updateSelectStatus = function(e, i, r) {
          var a = this;
          this._mapDraw.group.traverse(function(o) {
            var s = Dt(o).eventData;
            if (s) return a._model.isSelected(s.name) ? r.enterSelect(o) : r.leaveSelect(o), true;
          });
        }, t.prototype.findHighDownDispatchers = function(e) {
          return this._mapDraw && this._mapDraw.findHighDownDispatchers(e, this._model);
        }, t.prototype.dispose = function() {
          this._mapDraw && this._mapDraw.remove();
        }, t.type = "geo", t;
      }(on);
      function y2t(n, t, e) {
        Us.registerMap(n, t, e);
      }
      function Zj(n) {
        n.registerCoordinateSystem("geo", Wj), n.registerComponentModel(p2t), n.registerComponentView(v2t), n.registerImpl("registerMap", y2t), n.registerImpl("getMap", function(e) {
          return Us.getMapForUser(e);
        });
        function t(e, i) {
          i.update = "geo:updateSelectStatus", n.registerAction(i, function(r, a) {
            var o = {}, s = [];
            return a.eachComponent({ mainType: "geo", query: r }, function(l) {
              l[e](r.name);
              var u = l.coordinateSystem;
              M(u.regions, function(c) {
                o[c.name] = l.isSelected(c.name) || false;
              });
              var h = [];
              M(o, function(c, f) {
                o[f] && h.push(f);
              }), s.push({ geoIndex: l.componentIndex, name: h });
            }), { selected: o, allSelected: s, name: r.name };
          });
        }
        t("toggleSelected", { type: "geoToggleSelect", event: "geoselectchanged" }), t("select", { type: "geoSelect", event: "geoselected" }), t("unSelect", { type: "geoUnSelect", event: "geounselected" }), n.registerAction({ type: "geoRoam", event: "geoRoam", update: "updateTransform" }, function(e, i, r) {
          var a = e.componentType || "series";
          i.eachComponent({ mainType: a, query: e }, function(o) {
            var s = o.coordinateSystem;
            if (s.type === "geo") {
              var l = cM(s, e, o.get("scaleLimit"), r);
              o.setCenter && o.setCenter(l.center), o.setZoom && o.setZoom(l.zoom), a === "series" && M(o.seriesGroup, function(u) {
                u.setCenter(l.center), u.setZoom(l.zoom);
              });
            }
          });
        });
      }
      function m2t(n) {
        Zt(Zj), n.registerChartView(l2t), n.registerSeriesModel(u2t), n.registerLayout(f2t), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, c2t), e6("map", n.registerAction);
      }
      function _2t(n) {
        var t = n;
        t.hierNode = { defaultAncestor: null, ancestor: t, prelim: 0, modifier: 0, change: 0, shift: 0, i: 0, thread: null };
        for (var e = [t], i, r; i = e.pop(); ) if (r = i.children, i.isExpand && r.length) for (var a = r.length, o = a - 1; o >= 0; o--) {
          var s = r[o];
          s.hierNode = { defaultAncestor: null, ancestor: s, prelim: 0, modifier: 0, change: 0, shift: 0, i: o, thread: null }, e.push(s);
        }
      }
      function I2t(n, t) {
        var e = n.isExpand ? n.children : [], i = n.parentNode.children, r = n.hierNode.i ? i[n.hierNode.i - 1] : null;
        if (e.length) {
          w2t(n);
          var a = (e[0].hierNode.prelim + e[e.length - 1].hierNode.prelim) / 2;
          r ? (n.hierNode.prelim = r.hierNode.prelim + t(n, r), n.hierNode.modifier = n.hierNode.prelim - a) : n.hierNode.prelim = a;
        } else r && (n.hierNode.prelim = r.hierNode.prelim + t(n, r));
        n.parentNode.hierNode.defaultAncestor = C2t(n, r, n.parentNode.hierNode.defaultAncestor || i[0], t);
      }
      function E2t(n) {
        var t = n.hierNode.prelim + n.parentNode.hierNode.modifier;
        n.setLayout({ x: t }, true), n.hierNode.modifier += n.parentNode.hierNode.modifier;
      }
      function Kj(n) {
        return arguments.length ? n : B2t;
      }
      function Fv(n, t) {
        return n -= Math.PI / 2, { x: t * Math.cos(n), y: t * Math.sin(n) };
      }
      function x2t(n, t) {
        return Gn(n.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() });
      }
      function w2t(n) {
        for (var t = n.children, e = t.length, i = 0, r = 0; --e >= 0; ) {
          var a = t[e];
          a.hierNode.prelim += i, a.hierNode.modifier += i, r += a.hierNode.change, i += a.hierNode.shift + r;
        }
      }
      function C2t(n, t, e, i) {
        if (t) {
          for (var r = n, a = n, o = a.parentNode.children[0], s = t, l = r.hierNode.modifier, u = a.hierNode.modifier, h = o.hierNode.modifier, c = s.hierNode.modifier; s = fM(s), a = gM(a), s && a; ) {
            r = fM(r), o = gM(o), r.hierNode.ancestor = n;
            var f = s.hierNode.prelim + c - a.hierNode.prelim - u + i(s, a);
            f > 0 && (b2t(S2t(s, n, e), n, f), u += f, l += f), c += s.hierNode.modifier, u += a.hierNode.modifier, l += r.hierNode.modifier, h += o.hierNode.modifier;
          }
          s && !fM(r) && (r.hierNode.thread = s, r.hierNode.modifier += c - l), a && !gM(o) && (o.hierNode.thread = a, o.hierNode.modifier += u - h, e = n);
        }
        return e;
      }
      function fM(n) {
        var t = n.children;
        return t.length && n.isExpand ? t[t.length - 1] : n.hierNode.thread;
      }
      function gM(n) {
        var t = n.children;
        return t.length && n.isExpand ? t[0] : n.hierNode.thread;
      }
      function S2t(n, t, e) {
        return n.hierNode.ancestor.parentNode === t.parentNode ? n.hierNode.ancestor : e;
      }
      function b2t(n, t, e) {
        var i = e / (t.hierNode.i - n.hierNode.i);
        t.hierNode.change -= i, t.hierNode.shift += e, t.hierNode.modifier += e, t.hierNode.prelim += e, n.hierNode.change += i;
      }
      function B2t(n, t) {
        return n.parentNode === t.parentNode ? 1 : 2;
      }
      var T2t = /* @__PURE__ */ function() {
        function n() {
          this.parentPoint = [], this.childPoints = [];
        }
        return n;
      }(), M2t = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new T2t();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.childPoints, a = r.length, o = i.parentPoint, s = r[0], l = r[a - 1];
          if (a === 1) {
            e.moveTo(o[0], o[1]), e.lineTo(s[0], s[1]);
            return;
          }
          var u = i.orient, h = u === "TB" || u === "BT" ? 0 : 1, c = 1 - h, f = ot(i.forkPosition, 1), g = [];
          g[h] = o[h], g[c] = o[c] + (l[c] - o[c]) * f, e.moveTo(o[0], o[1]), e.lineTo(g[0], g[1]), e.moveTo(s[0], s[1]), g[h] = s[h], e.lineTo(g[0], g[1]), g[h] = l[h], e.lineTo(g[0], g[1]), e.lineTo(l[0], l[1]);
          for (var d = 1; d < a - 1; d++) {
            var A = r[d];
            e.moveTo(A[0], A[1]), g[h] = A[h], e.lineTo(g[0], g[1]);
          }
        }, t;
      }(Jt), D2t = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._mainGroup = new Ct(), e;
        }
        return t.prototype.init = function(e, i) {
          this._controller = new Pv(i.getZr()), this._controllerHost = { target: this.group }, this.group.add(this._mainGroup);
        }, t.prototype.render = function(e, i, r) {
          var a = e.getData(), o = e.layoutInfo, s = this._mainGroup, l = e.get("layout");
          l === "radial" ? (s.x = o.x + o.width / 2, s.y = o.y + o.height / 2) : (s.x = o.x, s.y = o.y), this._updateViewCoordSys(e, r), this._updateController(e, i, r);
          var u = this._data;
          a.diff(u).add(function(h) {
            $j(a, h) && Jj(a, h, null, s, e);
          }).update(function(h, c) {
            var f = u.getItemGraphicEl(c);
            if (!$j(a, h)) {
              f && n9(u, c, f, s, e);
              return;
            }
            Jj(a, h, f, s, e);
          }).remove(function(h) {
            var c = u.getItemGraphicEl(h);
            c && n9(u, h, c, s, e);
          }).execute(), this._nodeScaleRatio = e.get("nodeScaleRatio"), this._updateNodeAndLinkScale(e), e.get("expandAndCollapse") === true && a.eachItemGraphicEl(function(h, c) {
            h.off("click").on("click", function() {
              r.dispatchAction({ type: "treeExpandAndCollapse", seriesId: e.id, dataIndex: c });
            });
          }), this._data = a;
        }, t.prototype._updateViewCoordSys = function(e, i) {
          var r = e.getData(), a = [];
          r.each(function(c) {
            var f = r.getItemLayout(c);
            f && !isNaN(f.x) && !isNaN(f.y) && a.push([+f.x, +f.y]);
          });
          var o = [], s = [];
          Y_(a, o, s);
          var l = this._min, u = this._max;
          s[0] - o[0] === 0 && (o[0] = l ? l[0] : o[0] - 1, s[0] = u ? u[0] : s[0] + 1), s[1] - o[1] === 0 && (o[1] = l ? l[1] : o[1] - 1, s[1] = u ? u[1] : s[1] + 1);
          var h = e.coordinateSystem = new kv();
          h.zoomLimit = e.get("scaleLimit"), h.setBoundingRect(o[0], o[1], s[0] - o[0], s[1] - o[1]), h.setCenter(e.get("center"), i), h.setZoom(e.get("zoom")), this.group.attr({ x: h.x, y: h.y, scaleX: h.scaleX, scaleY: h.scaleY }), this._min = o, this._max = s;
        }, t.prototype._updateController = function(e, i, r) {
          var a = this, o = this._controller, s = this._controllerHost, l = this.group;
          o.setPointerChecker(function(u, h, c) {
            var f = l.getBoundingRect();
            return f.applyTransform(l.transform), f.contain(h, c) && !II(u, r, e);
          }), o.enable(e.get("roam")), s.zoomLimit = e.get("scaleLimit"), s.zoom = e.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(u) {
            rM(s, u.dx, u.dy), r.dispatchAction({ seriesId: e.id, type: "treeRoam", dx: u.dx, dy: u.dy });
          }).on("zoom", function(u) {
            aM(s, u.scale, u.originX, u.originY), r.dispatchAction({ seriesId: e.id, type: "treeRoam", zoom: u.scale, originX: u.originX, originY: u.originY }), a._updateNodeAndLinkScale(e), r.updateLabelLayout();
          });
        }, t.prototype._updateNodeAndLinkScale = function(e) {
          var i = e.getData(), r = this._getNodeGlobalScale(e);
          i.eachItemGraphicEl(function(a, o) {
            a.setSymbolScale(r);
          });
        }, t.prototype._getNodeGlobalScale = function(e) {
          var i = e.coordinateSystem;
          if (i.type !== "view") return 1;
          var r = this._nodeScaleRatio, a = i.scaleX || 1, o = i.getZoom(), s = (o - 1) * r + 1;
          return s / a;
        }, t.prototype.dispose = function() {
          this._controller && this._controller.dispose(), this._controllerHost = null;
        }, t.prototype.remove = function() {
          this._mainGroup.removeAll(), this._data = null;
        }, t.type = "tree", t;
      }(Ve);
      function $j(n, t) {
        var e = n.getItemLayout(t);
        return e && !isNaN(e.x) && !isNaN(e.y);
      }
      function Jj(n, t, e, i, r) {
        var a = !e, o = n.tree.getNodeByDataIndex(t), s = o.getModel(), l = o.getVisual("style").fill, u = o.isExpand === false && o.children.length !== 0 ? l : "#fff", h = n.tree.root, c = o.parentNode === h ? o : o.parentNode || o, f = n.getItemGraphicEl(c.dataIndex), g = c.getLayout(), d = f ? { x: f.__oldX, y: f.__oldY, rawX: f.__radialOldRawX, rawY: f.__radialOldRawY } : g, A = o.getLayout();
        a ? (e = new Cv(n, t, null, { symbolInnerColor: u, useNameLabel: true }), e.x = d.x, e.y = d.y) : e.updateData(n, t, null, { symbolInnerColor: u, useNameLabel: true }), e.__radialOldRawX = e.__radialRawX, e.__radialOldRawY = e.__radialRawY, e.__radialRawX = A.rawX, e.__radialRawY = A.rawY, i.add(e), n.setItemGraphicEl(t, e), e.__oldX = e.x, e.__oldY = e.y, _e(e, { x: A.x, y: A.y }, r);
        var p = e.getSymbolPath();
        if (r.get("layout") === "radial") {
          var v = h.children[0], y = v.getLayout(), m = v.children.length, _ = void 0, E = void 0;
          if (A.x === y.x && o.isExpand === true && v.children.length) {
            var I = { x: (v.children[0].getLayout().x + v.children[m - 1].getLayout().x) / 2, y: (v.children[0].getLayout().y + v.children[m - 1].getLayout().y) / 2 };
            _ = Math.atan2(I.y - y.y, I.x - y.x), _ < 0 && (_ = Math.PI * 2 + _), E = I.x < y.x, E && (_ = _ - Math.PI);
          } else _ = Math.atan2(A.y - y.y, A.x - y.x), _ < 0 && (_ = Math.PI * 2 + _), o.children.length === 0 || o.children.length !== 0 && o.isExpand === false ? (E = A.x < y.x, E && (_ = _ - Math.PI)) : (E = A.x > y.x, E || (_ = _ - Math.PI));
          var x = E ? "left" : "right", w = s.getModel("label"), C = w.get("rotate"), S = C * (Math.PI / 180), b = p.getTextContent();
          b && (p.setTextConfig({ position: w.get("position") || x, rotation: C == null ? -_ : S, origin: "center" }), b.setStyle("verticalAlign", "middle"));
        }
        var B = s.get(["emphasis", "focus"]), T = B === "relative" ? u_(o.getAncestorsIndices(), o.getDescendantIndices()) : B === "ancestor" ? o.getAncestorsIndices() : B === "descendant" ? o.getDescendantIndices() : null;
        T && (Dt(e).focus = T), R2t(r, o, h, e, d, g, A, i), e.__edge && (e.onHoverStateChange = function(D) {
          if (D !== "blur") {
            var R = o.parentNode && n.getItemGraphicEl(o.parentNode.dataIndex);
            R && R.hoverState === Pp || J_(e.__edge, D);
          }
        });
      }
      function R2t(n, t, e, i, r, a, o, s) {
        var l = t.getModel(), u = n.get("edgeShape"), h = n.get("layout"), c = n.getOrient(), f = n.get(["lineStyle", "curveness"]), g = n.get("edgeForkPosition"), d = l.getModel("lineStyle").getLineStyle(), A = i.__edge;
        if (u === "curve") t.parentNode && t.parentNode !== e && (A || (A = i.__edge = new Up({ shape: dM(h, c, f, r, r) })), _e(A, { shape: dM(h, c, f, a, o) }, n));
        else if (u === "polyline") {
          if (h === "orthogonal") {
            if (t !== e && t.children && t.children.length !== 0 && t.isExpand === true) {
              for (var p = t.children, v = [], y = 0; y < p.length; y++) {
                var m = p[y].getLayout();
                v.push([m.x, m.y]);
              }
              A || (A = i.__edge = new M2t({ shape: { parentPoint: [o.x, o.y], childPoints: [[o.x, o.y]], orient: c, forkPosition: g } })), _e(A, { shape: { parentPoint: [o.x, o.y], childPoints: v } }, n);
            }
          } else if (true) throw new Error("The polyline edgeShape can only be used in orthogonal layout");
        }
        A && !(u === "polyline" && !t.isExpand) && (A.useStyle(Et({ strokeNoScale: true, fill: null }, d)), pi(A, l, "lineStyle"), bh(A), s.add(A));
      }
      function t9(n, t, e, i, r) {
        var a = t.tree.root, o = e9(a, n), s = o.source, l = o.sourceLayout, u = t.getItemGraphicEl(n.dataIndex);
        if (u) {
          var h = t.getItemGraphicEl(s.dataIndex), c = h.__edge, f = u.__edge || (s.isExpand === false || s.children.length === 1 ? c : void 0), g = i.get("edgeShape"), d = i.get("layout"), A = i.get("orient"), p = i.get(["lineStyle", "curveness"]);
          f && (g === "curve" ? Jl(f, { shape: dM(d, A, p, l, l), style: { opacity: 0 } }, i, { cb: function() {
            e.remove(f);
          }, removeOpt: r }) : g === "polyline" && i.get("layout") === "orthogonal" && Jl(f, { shape: { parentPoint: [l.x, l.y], childPoints: [[l.x, l.y]] }, style: { opacity: 0 } }, i, { cb: function() {
            e.remove(f);
          }, removeOpt: r }));
        }
      }
      function e9(n, t) {
        for (var e = t.parentNode === n ? t : t.parentNode || t, i; i = e.getLayout(), i == null; ) e = e.parentNode === n ? e : e.parentNode || e;
        return { source: e, sourceLayout: i };
      }
      function n9(n, t, e, i, r) {
        var a = n.tree.getNodeByDataIndex(t), o = n.tree.root, s = e9(o, a).sourceLayout, l = { duration: r.get("animationDurationUpdate"), easing: r.get("animationEasingUpdate") };
        Jl(e, { x: s.x + 1, y: s.y + 1 }, r, { cb: function() {
          i.remove(e), n.setItemGraphicEl(t, null);
        }, removeOpt: l }), e.fadeOut(null, n.hostModel, { fadeLabel: true, animation: l }), a.children.forEach(function(u) {
          t9(u, n, i, r, l);
        }), t9(a, n, i, r, l);
      }
      function dM(n, t, e, i, r) {
        var a, o, s, l, u, h, c, f;
        if (n === "radial") {
          u = i.rawX, c = i.rawY, h = r.rawX, f = r.rawY;
          var g = Fv(u, c), d = Fv(u, c + (f - c) * e), A = Fv(h, f + (c - f) * e), p = Fv(h, f);
          return { x1: g.x || 0, y1: g.y || 0, x2: p.x || 0, y2: p.y || 0, cpx1: d.x || 0, cpy1: d.y || 0, cpx2: A.x || 0, cpy2: A.y || 0 };
        } else u = i.x, c = i.y, h = r.x, f = r.y, (t === "LR" || t === "RL") && (a = u + (h - u) * e, o = c, s = h + (u - h) * e, l = f), (t === "TB" || t === "BT") && (a = u, o = c + (f - c) * e, s = h, l = f + (c - f) * e);
        return { x1: u, y1: c, x2: h, y2: f, cpx1: a, cpy1: o, cpx2: s, cpy2: l };
      }
      var Ia = le();
      function i9(n) {
        var t = n.mainData, e = n.datas;
        e || (e = { main: t }, n.datasAttr = { main: "data" }), n.datas = n.mainData = null, r9(t, e, n), M(e, function(i) {
          M(t.TRANSFERABLE_METHODS, function(r) {
            i.wrapMethod(r, Ot(L2t, n));
          });
        }), t.wrapMethod("cloneShallow", Ot(N2t, n)), M(t.CHANGABLE_METHODS, function(i) {
          t.wrapMethod(i, Ot(P2t, n));
        }), It(e[t.dataType] === t);
      }
      function L2t(n, t) {
        if (Q2t(this)) {
          var e = Y({}, Ia(this).datas);
          e[this.dataType] = t, r9(t, e, n);
        } else AM(t, this.dataType, Ia(this).mainData, n);
        return t;
      }
      function P2t(n, t) {
        return n.struct && n.struct.update(), t;
      }
      function N2t(n, t) {
        return M(Ia(t).datas, function(e, i) {
          e !== t && AM(e.cloneShallow(), i, t, n);
        }), t;
      }
      function k2t(n) {
        var t = Ia(this).mainData;
        return n == null || t == null ? t : Ia(t).datas[n];
      }
      function F2t() {
        var n = Ia(this).mainData;
        return n == null ? [{ data: n }] : Z(re(Ia(n).datas), function(t) {
          return { type: t, data: Ia(n).datas[t] };
        });
      }
      function Q2t(n) {
        return Ia(n).mainData === n;
      }
      function r9(n, t, e) {
        Ia(n).datas = {}, M(t, function(i, r) {
          AM(i, r, n, e);
        });
      }
      function AM(n, t, e, i) {
        Ia(e).datas[t] = n, Ia(n).mainData = e, n.dataType = t, i.struct && (n[i.structAttr] = i.struct, i.struct[i.datasAttr[t]] = n), n.getLinkedData = k2t, n.getLinkedDataAll = F2t;
      }
      var O2t = function() {
        function n(t, e) {
          this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = false, this.name = t || "", this.hostTree = e;
        }
        return n.prototype.isRemoved = function() {
          return this.dataIndex < 0;
        }, n.prototype.eachNode = function(t, e, i) {
          yt(t) && (i = e, e = t, t = null), t = t || {}, ht(t) && (t = { order: t });
          var r = t.order || "preorder", a = this[t.attr || "children"], o;
          r === "preorder" && (o = e.call(i, this));
          for (var s = 0; !o && s < a.length; s++) a[s].eachNode(t, e, i);
          r === "postorder" && e.call(i, this);
        }, n.prototype.updateDepthAndHeight = function(t) {
          var e = 0;
          this.depth = t;
          for (var i = 0; i < this.children.length; i++) {
            var r = this.children[i];
            r.updateDepthAndHeight(t + 1), r.height > e && (e = r.height);
          }
          this.height = e + 1;
        }, n.prototype.getNodeById = function(t) {
          if (this.getId() === t) return this;
          for (var e = 0, i = this.children, r = i.length; e < r; e++) {
            var a = i[e].getNodeById(t);
            if (a) return a;
          }
        }, n.prototype.contains = function(t) {
          if (t === this) return true;
          for (var e = 0, i = this.children, r = i.length; e < r; e++) {
            var a = i[e].contains(t);
            if (a) return a;
          }
        }, n.prototype.getAncestors = function(t) {
          for (var e = [], i = t ? this : this.parentNode; i; ) e.push(i), i = i.parentNode;
          return e.reverse(), e;
        }, n.prototype.getAncestorsIndices = function() {
          for (var t = [], e = this; e; ) t.push(e.dataIndex), e = e.parentNode;
          return t.reverse(), t;
        }, n.prototype.getDescendantIndices = function() {
          var t = [];
          return this.eachNode(function(e) {
            t.push(e.dataIndex);
          }), t;
        }, n.prototype.getValue = function(t) {
          var e = this.hostTree.data;
          return e.getStore().get(e.getDimensionIndex(t || "value"), this.dataIndex);
        }, n.prototype.setLayout = function(t, e) {
          this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, t, e);
        }, n.prototype.getLayout = function() {
          return this.hostTree.data.getItemLayout(this.dataIndex);
        }, n.prototype.getModel = function(t) {
          if (!(this.dataIndex < 0)) {
            var e = this.hostTree, i = e.data.getItemModel(this.dataIndex);
            return i.getModel(t);
          }
        }, n.prototype.getLevelModel = function() {
          return (this.hostTree.levelModels || [])[this.depth];
        }, n.prototype.setVisual = function(t, e) {
          this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, t, e);
        }, n.prototype.getVisual = function(t) {
          return this.hostTree.data.getItemVisual(this.dataIndex, t);
        }, n.prototype.getRawIndex = function() {
          return this.hostTree.data.getRawIndex(this.dataIndex);
        }, n.prototype.getId = function() {
          return this.hostTree.data.getId(this.dataIndex);
        }, n.prototype.getChildIndex = function() {
          if (this.parentNode) {
            for (var t = this.parentNode.children, e = 0; e < t.length; ++e) if (t[e] === this) return e;
            return -1;
          }
          return -1;
        }, n.prototype.isAncestorOf = function(t) {
          for (var e = t.parentNode; e; ) {
            if (e === this) return true;
            e = e.parentNode;
          }
          return false;
        }, n.prototype.isDescendantOf = function(t) {
          return t !== this && t.isAncestorOf(this);
        }, n;
      }(), pM = function() {
        function n(t) {
          this.type = "tree", this._nodes = [], this.hostModel = t;
        }
        return n.prototype.eachNode = function(t, e, i) {
          this.root.eachNode(t, e, i);
        }, n.prototype.getNodeByDataIndex = function(t) {
          var e = this.data.getRawIndex(t);
          return this._nodes[e];
        }, n.prototype.getNodeById = function(t) {
          return this.root.getNodeById(t);
        }, n.prototype.update = function() {
          for (var t = this.data, e = this._nodes, i = 0, r = e.length; i < r; i++) e[i].dataIndex = -1;
          for (var i = 0, r = t.count(); i < r; i++) e[t.getRawIndex(i)].dataIndex = i;
        }, n.prototype.clearLayouts = function() {
          this.data.clearItemLayouts();
        }, n.createTree = function(t, e, i) {
          var r = new n(e), a = [], o = 1;
          s(t);
          function s(h, c) {
            var f = h.value;
            o = Math.max(o, X(f) ? f.length : 1), a.push(h);
            var g = new O2t(zn(h.name, ""), r);
            c ? z2t(g, c) : r.root = g, r._nodes.push(g);
            var d = h.children;
            if (d) for (var A = 0; A < d.length; A++) s(d[A], g);
          }
          r.root.updateDepthAndHeight(0);
          var l = vv(a, { coordDimensions: ["value"], dimensionsCount: o }).dimensions, u = new Zi(l, e);
          return u.initData(a), i && i(u), i9({ mainData: u, struct: r, structAttr: "tree" }), r.update(), r;
        }, n;
      }();
      function z2t(n, t) {
        var e = t.children;
        n.parentNode !== t && (e.push(n), n.parentNode = t);
      }
      function Qv(n, t, e) {
        if (n && Wt(t, n.type) >= 0) {
          var i = e.getData().tree.root, r = n.targetNode;
          if (ht(r) && (r = i.getNodeById(r)), r && i.contains(r)) return { node: r };
          var a = n.targetNodeId;
          if (a != null && (r = i.getNodeById(a))) return { node: r };
        }
      }
      function a9(n) {
        for (var t = []; n; ) n = n.parentNode, n && t.push(n);
        return t.reverse();
      }
      function vM(n, t) {
        var e = a9(n);
        return Wt(e, t) >= 0;
      }
      function SI(n, t) {
        for (var e = []; n; ) {
          var i = n.dataIndex;
          e.push({ name: n.name, dataIndex: i, value: t.getRawValue(i) }), n = n.parentNode;
        }
        return e.reverse(), e;
      }
      var G2t = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.hasSymbolVisual = true, e.ignoreStyleOnData = true, e;
        }
        return t.prototype.getInitialData = function(e) {
          var i = { name: e.name, children: e.data }, r = e.leaves || {}, a = new Te(r, this, this.ecModel), o = pM.createTree(i, this, s);
          function s(c) {
            c.wrapMethod("getItemModel", function(f, g) {
              var d = o.getNodeByDataIndex(g);
              return d && d.children.length && d.isExpand || (f.parentModel = a), f;
            });
          }
          var l = 0;
          o.eachNode("preorder", function(c) {
            c.depth > l && (l = c.depth);
          });
          var u = e.expandAndCollapse, h = u && e.initialTreeDepth >= 0 ? e.initialTreeDepth : l;
          return o.root.eachNode("preorder", function(c) {
            var f = c.hostTree.data.getRawDataItem(c.dataIndex);
            c.isExpand = f && f.collapsed != null ? !f.collapsed : c.depth <= h;
          }), o.data;
        }, t.prototype.getOrient = function() {
          var e = this.get("orient");
          return e === "horizontal" ? e = "LR" : e === "vertical" && (e = "TB"), e;
        }, t.prototype.setZoom = function(e) {
          this.option.zoom = e;
        }, t.prototype.setCenter = function(e) {
          this.option.center = e;
        }, t.prototype.formatTooltip = function(e, i, r) {
          for (var a = this.getData().tree, o = a.root.children[0], s = a.getNodeByDataIndex(e), l = s.getValue(), u = s.name; s && s !== o; ) u = s.parentNode.name + "." + u, s = s.parentNode;
          return Zn("nameValue", { name: u, value: l, noValue: isNaN(l) || l == null });
        }, t.prototype.getDataParams = function(e) {
          var i = n.prototype.getDataParams.apply(this, arguments), r = this.getData().tree.getNodeByDataIndex(e);
          return i.treeAncestors = SI(r, this), i.collapsed = !r.isExpand, i;
        }, t.type = "series.tree", t.layoutMode = "box", t.defaultOption = { z: 2, coordinateSystem: "view", left: "12%", top: "12%", right: "12%", bottom: "12%", layout: "orthogonal", edgeShape: "curve", edgeForkPosition: "50%", roam: false, nodeScaleRatio: 0.4, center: null, zoom: 1, orient: "LR", symbol: "emptyCircle", symbolSize: 7, expandAndCollapse: true, initialTreeDepth: 2, lineStyle: { color: "#ccc", width: 1.5, curveness: 0.5 }, itemStyle: { color: "lightsteelblue", borderWidth: 1.5 }, label: { show: true }, animationEasing: "linear", animationDuration: 700, animationDurationUpdate: 500 }, t;
      }($e);
      function U2t(n, t, e) {
        for (var i = [n], r = [], a; a = i.pop(); ) if (r.push(a), a.isExpand) {
          var o = a.children;
          if (o.length) for (var s = 0; s < o.length; s++) i.push(o[s]);
        }
        for (; a = r.pop(); ) t(a, e);
      }
      function Ov(n, t) {
        for (var e = [n], i; i = e.pop(); ) if (t(i), i.isExpand) {
          var r = i.children;
          if (r.length) for (var a = r.length - 1; a >= 0; a--) e.push(r[a]);
        }
      }
      function V2t(n, t) {
        n.eachSeriesByType("tree", function(e) {
          j2t(e, t);
        });
      }
      function j2t(n, t) {
        var e = x2t(n, t);
        n.layoutInfo = e;
        var i = n.get("layout"), r = 0, a = 0, o = null;
        i === "radial" ? (r = 2 * Math.PI, a = Math.min(e.height, e.width) / 2, o = Kj(function(m, _) {
          return (m.parentNode === _.parentNode ? 1 : 2) / m.depth;
        })) : (r = e.width, a = e.height, o = Kj());
        var s = n.getData().tree.root, l = s.children[0];
        if (l) {
          _2t(s), U2t(l, I2t, o), s.hierNode.modifier = -l.hierNode.prelim, Ov(l, E2t);
          var u = l, h = l, c = l;
          Ov(l, function(m) {
            var _ = m.getLayout().x;
            _ < u.getLayout().x && (u = m), _ > h.getLayout().x && (h = m), m.depth > c.depth && (c = m);
          });
          var f = u === h ? 1 : o(u, h) / 2, g = f - u.getLayout().x, d = 0, A = 0, p = 0, v = 0;
          if (i === "radial") d = r / (h.getLayout().x + f + g), A = a / (c.depth - 1 || 1), Ov(l, function(m) {
            p = (m.getLayout().x + g) * d, v = (m.depth - 1) * A;
            var _ = Fv(p, v);
            m.setLayout({ x: _.x, y: _.y, rawX: p, rawY: v }, true);
          });
          else {
            var y = n.getOrient();
            y === "RL" || y === "LR" ? (A = a / (h.getLayout().x + f + g), d = r / (c.depth - 1 || 1), Ov(l, function(m) {
              v = (m.getLayout().x + g) * A, p = y === "LR" ? (m.depth - 1) * d : r - (m.depth - 1) * d, m.setLayout({ x: p, y: v }, true);
            })) : (y === "TB" || y === "BT") && (d = r / (h.getLayout().x + f + g), A = a / (c.depth - 1 || 1), Ov(l, function(m) {
              p = (m.getLayout().x + g) * d, v = y === "TB" ? (m.depth - 1) * A : a - (m.depth - 1) * A, m.setLayout({ x: p, y: v }, true);
            }));
          }
        }
      }
      function q2t(n) {
        n.eachSeriesByType("tree", function(t) {
          var e = t.getData(), i = e.tree;
          i.eachNode(function(r) {
            var a = r.getModel(), o = a.getModel("itemStyle").getItemStyle(), s = e.ensureUniqueItemVisual(r.dataIndex, "style");
            Y(s, o);
          });
        });
      }
      function H2t(n) {
        n.registerAction({ type: "treeExpandAndCollapse", event: "treeExpandAndCollapse", update: "update" }, function(t, e) {
          e.eachComponent({ mainType: "series", subType: "tree", query: t }, function(i) {
            var r = t.dataIndex, a = i.getData().tree, o = a.getNodeByDataIndex(r);
            o.isExpand = !o.isExpand;
          });
        }), n.registerAction({ type: "treeRoam", event: "treeRoam", update: "none" }, function(t, e, i) {
          e.eachComponent({ mainType: "series", subType: "tree", query: t }, function(r) {
            var a = r.coordinateSystem, o = cM(a, t, void 0, i);
            r.setCenter && r.setCenter(o.center), r.setZoom && r.setZoom(o.zoom);
          });
        });
      }
      function Y2t(n) {
        n.registerChartView(D2t), n.registerSeriesModel(G2t), n.registerLayout(V2t), n.registerVisual(q2t), H2t(n);
      }
      var o9 = ["treemapZoomToNode", "treemapRender", "treemapMove"];
      function W2t(n) {
        for (var t = 0; t < o9.length; t++) n.registerAction({ type: o9[t], update: "updateView" }, In);
        n.registerAction({ type: "treemapRootToNode", update: "updateView" }, function(e, i) {
          i.eachComponent({ mainType: "series", subType: "treemap", query: e }, r);
          function r(a, o) {
            var s = ["treemapZoomToNode", "treemapRootToNode"], l = Qv(e, s, a);
            if (l) {
              var u = a.getViewRoot();
              u && (e.direction = vM(u, l.node) ? "rollUp" : "drillDown"), a.resetViewRoot(l.node);
            }
          }
        });
      }
      function s9(n) {
        var t = n.getData(), e = t.tree, i = {};
        e.eachNode(function(r) {
          for (var a = r; a && a.depth > 1; ) a = a.parentNode;
          var o = _B(n.ecModel, a.name || a.dataIndex + "", i);
          r.setVisual("decal", o);
        });
      }
      var X2t = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.preventUsingHoverLayer = true, e;
        }
        return t.prototype.getInitialData = function(e, i) {
          var r = { name: e.name, children: e.data };
          l9(r);
          var a = e.levels || [], o = this.designatedVisualItemStyle = {}, s = new Te({ itemStyle: o }, this, i);
          a = e.levels = Z2t(a, i);
          var l = Z(a || [], function(c) {
            return new Te(c, s, i);
          }, this), u = pM.createTree(r, this, h);
          function h(c) {
            c.wrapMethod("getItemModel", function(f, g) {
              var d = u.getNodeByDataIndex(g), A = d ? l[d.depth] : null;
              return f.parentModel = A || s, f;
            });
          }
          return u.data;
        }, t.prototype.optionUpdated = function() {
          this.resetViewRoot();
        }, t.prototype.formatTooltip = function(e, i, r) {
          var a = this.getData(), o = this.getRawValue(e), s = a.getName(e);
          return Zn("nameValue", { name: s, value: o });
        }, t.prototype.getDataParams = function(e) {
          var i = n.prototype.getDataParams.apply(this, arguments), r = this.getData().tree.getNodeByDataIndex(e);
          return i.treeAncestors = SI(r, this), i.treePathInfo = i.treeAncestors, i;
        }, t.prototype.setLayoutInfo = function(e) {
          this.layoutInfo = this.layoutInfo || {}, Y(this.layoutInfo, e);
        }, t.prototype.mapIdToIndex = function(e) {
          var i = this._idIndexMap;
          i || (i = this._idIndexMap = dt(), this._idIndexMapCount = 0);
          var r = i.get(e);
          return r == null && i.set(e, r = this._idIndexMapCount++), r;
        }, t.prototype.getViewRoot = function() {
          return this._viewRoot;
        }, t.prototype.resetViewRoot = function(e) {
          e ? this._viewRoot = e : e = this._viewRoot;
          var i = this.getRawData().tree.root;
          (!e || e !== i && !i.contains(e)) && (this._viewRoot = i);
        }, t.prototype.enableAriaDecal = function() {
          s9(this);
        }, t.type = "series.treemap", t.layoutMode = "box", t.defaultOption = { progressive: 0, left: "center", top: "middle", width: "80%", height: "80%", sort: true, clipWindow: "origin", squareRatio: 0.5 * (1 + Math.sqrt(5)), leafDepth: null, drillDownIcon: "", zoomToNodeRatio: 0.32 * 0.32, scaleLimit: null, roam: true, nodeClick: "zoomToNode", animation: true, animationDurationUpdate: 900, animationEasing: "quinticInOut", breadcrumb: { show: true, height: 22, left: "center", top: "bottom", emptyItemWidth: 25, itemStyle: { color: "rgba(0,0,0,0.7)", textStyle: { color: "#fff" } }, emphasis: { itemStyle: { color: "rgba(0,0,0,0.9)" } } }, label: { show: true, distance: 0, padding: 5, position: "inside", color: "#fff", overflow: "truncate" }, upperLabel: { show: false, position: [0, "50%"], height: 20, overflow: "truncate", verticalAlign: "middle" }, itemStyle: { color: null, colorAlpha: null, colorSaturation: null, borderWidth: 0, gapWidth: 0, borderColor: "#fff", borderColorSaturation: null }, emphasis: { upperLabel: { show: true, position: [0, "50%"], overflow: "truncate", verticalAlign: "middle" } }, visualDimension: 0, visualMin: null, visualMax: null, color: [], colorAlpha: null, colorSaturation: null, colorMappingBy: "index", visibleMin: 10, childrenVisibleMin: null, levels: [] }, t;
      }($e);
      function l9(n) {
        var t = 0;
        M(n.children, function(i) {
          l9(i);
          var r = i.value;
          X(r) && (r = r[0]), t += r;
        });
        var e = n.value;
        X(e) && (e = e[0]), (e == null || isNaN(e)) && (e = t), e < 0 && (e = 0), X(n.value) ? n.value[0] = e : n.value = e;
      }
      function Z2t(n, t) {
        var e = Qe(t.get("color")), i = Qe(t.get(["aria", "decal", "decals"]));
        if (e) {
          n = n || [];
          var r, a;
          M(n, function(s) {
            var l = new Te(s), u = l.get("color"), h = l.get("decal");
            (l.get(["itemStyle", "color"]) || u && u !== "none") && (r = true), (l.get(["itemStyle", "decal"]) || h && h !== "none") && (a = true);
          });
          var o = n[0] || (n[0] = {});
          return r || (o.color = e.slice()), !a && i && (o.decal = i.slice()), n;
        }
      }
      var K2t = 8, u9 = 8, yM = 5, $2t = function() {
        function n(t) {
          this.group = new Ct(), t.add(this.group);
        }
        return n.prototype.render = function(t, e, i, r) {
          var a = t.getModel("breadcrumb"), o = this.group;
          if (o.removeAll(), !(!a.get("show") || !i)) {
            var s = a.getModel("itemStyle"), l = a.getModel("emphasis"), u = s.getModel("textStyle"), h = l.getModel(["itemStyle", "textStyle"]), c = { pos: { left: a.get("left"), right: a.get("right"), top: a.get("top"), bottom: a.get("bottom") }, box: { width: e.getWidth(), height: e.getHeight() }, emptyItemWidth: a.get("emptyItemWidth"), totalWidth: 0, renderList: [] };
            this._prepare(i, c, u), this._renderContent(t, c, s, l, u, h, r), C1(o, c.pos, c.box);
          }
        }, n.prototype._prepare = function(t, e, i) {
          for (var r = t; r; r = r.parentNode) {
            var a = zn(r.getModel().get("name"), ""), o = i.getTextRect(a), s = Math.max(o.width + K2t * 2, e.emptyItemWidth);
            e.totalWidth += s + u9, e.renderList.push({ node: r, text: a, width: s });
          }
        }, n.prototype._renderContent = function(t, e, i, r, a, o, s) {
          for (var l = 0, u = e.emptyItemWidth, h = t.get(["breadcrumb", "height"]), c = aIt(e.pos, e.box), f = e.totalWidth, g = e.renderList, d = r.getModel("itemStyle").getItemStyle(), A = g.length - 1; A >= 0; A--) {
            var p = g[A], v = p.node, y = p.width, m = p.text;
            f > c.width && (f -= y - u, y = u, m = null);
            var _ = new Yi({ shape: { points: J2t(l, 0, y, h, A === g.length - 1, A === 0) }, style: Et(i.getItemStyle(), { lineJoin: "bevel" }), textContent: new ge({ style: Ke(a, { text: m }) }), textConfig: { position: "inside" }, z2: _g * 1e4, onclick: Ot(s, v) });
            _.disableLabelAnimation = true, _.getTextContent().ensureState("emphasis").style = Ke(o, { text: m }), _.ensureState("emphasis").style = d, hn(_, r.get("focus"), r.get("blurScope"), r.get("disabled")), this.group.add(_), tBt(_, t, v), l += y + u9;
          }
        }, n.prototype.remove = function() {
          this.group.removeAll();
        }, n;
      }();
      function J2t(n, t, e, i, r, a) {
        var o = [[r ? n : n - yM, t], [n + e, t], [n + e, t + i], [r ? n : n - yM, t + i]];
        return !a && o.splice(2, 0, [n + e + yM, t + i / 2]), !r && o.push([n, t + i / 2]), o;
      }
      function tBt(n, t, e) {
        Dt(n).eventData = { componentType: "series", componentSubType: "treemap", componentIndex: t.componentIndex, seriesIndex: t.seriesIndex, seriesName: t.name, seriesType: "treemap", selfType: "breadcrumb", nodeData: { dataIndex: e && e.dataIndex, name: e && e.name }, treePathInfo: e && SI(e, t) };
      }
      var eBt = function() {
        function n() {
          this._storage = [], this._elExistsMap = {};
        }
        return n.prototype.add = function(t, e, i, r, a) {
          return this._elExistsMap[t.id] ? false : (this._elExistsMap[t.id] = true, this._storage.push({ el: t, target: e, duration: i, delay: r, easing: a }), true);
        }, n.prototype.finished = function(t) {
          return this._finishedCallback = t, this;
        }, n.prototype.start = function() {
          for (var t = this, e = this._storage.length, i = function() {
            e--, e <= 0 && (t._storage.length = 0, t._elExistsMap = {}, t._finishedCallback && t._finishedCallback());
          }, r = 0, a = this._storage.length; r < a; r++) {
            var o = this._storage[r];
            o.el.animateTo(o.target, { duration: o.duration, delay: o.delay, easing: o.easing, setToFinal: true, done: i, aborted: i });
          }
          return this;
        }, n;
      }();
      function nBt() {
        return new eBt();
      }
      var mM = Ct, h9 = ue, c9 = 3, f9 = "label", g9 = "upperLabel", iBt = _g * 10, rBt = _g * 2, aBt = _g * 3, ac = vh([["fill", "color"], ["stroke", "strokeColor"], ["lineWidth", "strokeWidth"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]), d9 = function(n) {
        var t = ac(n);
        return t.stroke = t.fill = t.lineWidth = null, t;
      }, bI = le(), oBt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._state = "ready", e._storage = zv(), e;
        }
        return t.prototype.render = function(e, i, r, a) {
          var o = i.findComponents({ mainType: "series", subType: "treemap", query: a });
          if (!(Wt(o, e) < 0)) {
            this.seriesModel = e, this.api = r, this.ecModel = i;
            var s = ["treemapZoomToNode", "treemapRootToNode"], l = Qv(a, s, e), u = a && a.type, h = e.layoutInfo, c = !this._oldTree, f = this._storage, g = u === "treemapRootToNode" && l && f ? { rootNodeGroup: f.nodeGroup[l.node.getRawIndex()], direction: a.direction } : null, d = this._giveContainerGroup(h), A = e.get("animation"), p = this._doRender(d, e, g);
            A && !c && (!u || u === "treemapZoomToNode" || u === "treemapRootToNode") ? this._doAnimation(d, p, e, g) : p.renderFinally(), this._resetController(r), this._renderBreadcrumb(e, r, l);
          }
        }, t.prototype._giveContainerGroup = function(e) {
          var i = this._containerGroup;
          return i || (i = this._containerGroup = new mM(), this._initEvents(i), this.group.add(i)), i.x = e.x, i.y = e.y, i;
        }, t.prototype._doRender = function(e, i, r) {
          var a = i.getData().tree, o = this._oldTree, s = zv(), l = zv(), u = this._storage, h = [];
          function c(y, m, _, E) {
            return sBt(i, l, u, r, s, h, y, m, _, E);
          }
          A(a.root ? [a.root] : [], o && o.root ? [o.root] : [], e, a === o || !o, 0);
          var f = p(u);
          if (this._oldTree = a, this._storage = l, this._controllerHost) {
            var g = this.seriesModel.layoutInfo, d = a.root.getLayout();
            d.width === g.width && d.height === g.height && (this._controllerHost.zoom = 1);
          }
          return { lastsForAnimation: s, willDeleteEls: f, renderFinally: v };
          function A(y, m, _, E, I) {
            E ? (m = y, M(y, function(C, S) {
              !C.isRemoved() && w(S, S);
            })) : new Os(m, y, x, x).add(w).update(w).remove(Ot(w, null)).execute();
            function x(C) {
              return C.getId();
            }
            function w(C, S) {
              var b = C != null ? y[C] : null, B = S != null ? m[S] : null, T = c(b, B, _, I);
              T && A(b && b.viewChildren || [], B && B.viewChildren || [], T, E, I + 1);
            }
          }
          function p(y) {
            var m = zv();
            return y && M(y, function(_, E) {
              var I = m[E];
              M(_, function(x) {
                x && (I.push(x), bI(x).willDelete = true);
              });
            }), m;
          }
          function v() {
            M(f, function(y) {
              M(y, function(m) {
                m.parent && m.parent.remove(m);
              });
            }), M(h, function(y) {
              y.invisible = true, y.dirty();
            });
          }
        }, t.prototype._doAnimation = function(e, i, r, a) {
          var o = r.get("animationDurationUpdate"), s = r.get("animationEasing"), l = (yt(o) ? 0 : o) || 0, u = (yt(s) ? null : s) || "cubicOut", h = nBt();
          M(i.willDeleteEls, function(c, f) {
            M(c, function(g, d) {
              if (!g.invisible) {
                var A = g.parent, p, v = bI(A);
                if (a && a.direction === "drillDown") p = A === a.rootNodeGroup ? { shape: { x: 0, y: 0, width: v.nodeWidth, height: v.nodeHeight }, style: { opacity: 0 } } : { style: { opacity: 0 } };
                else {
                  var y = 0, m = 0;
                  v.willDelete || (y = v.nodeWidth / 2, m = v.nodeHeight / 2), p = f === "nodeGroup" ? { x: y, y: m, style: { opacity: 0 } } : { shape: { x: y, y: m, width: 0, height: 0 }, style: { opacity: 0 } };
                }
                p && h.add(g, p, l, 0, u);
              }
            });
          }), M(this._storage, function(c, f) {
            M(c, function(g, d) {
              var A = i.lastsForAnimation[f][d], p = {};
              A && (g instanceof Ct ? A.oldX != null && (p.x = g.x, p.y = g.y, g.x = A.oldX, g.y = A.oldY) : (A.oldShape && (p.shape = Y({}, g.shape), g.setShape(A.oldShape)), A.fadein ? (g.setStyle("opacity", 0), p.style = { opacity: 1 }) : g.style.opacity !== 1 && (p.style = { opacity: 1 })), h.add(g, p, l, 0, u));
            });
          }, this), this._state = "animating", h.finished(ct(function() {
            this._state = "ready", i.renderFinally();
          }, this)).start();
        }, t.prototype._resetController = function(e) {
          var i = this._controller, r = this._controllerHost;
          r || (this._controllerHost = { target: this.group }, r = this._controllerHost), i || (i = this._controller = new Pv(e.getZr()), i.enable(this.seriesModel.get("roam")), r.zoomLimit = this.seriesModel.get("scaleLimit"), r.zoom = this.seriesModel.get("zoom"), i.on("pan", ct(this._onPan, this)), i.on("zoom", ct(this._onZoom, this)));
          var a = new Ht(0, 0, e.getWidth(), e.getHeight());
          i.setPointerChecker(function(o, s, l) {
            return a.contain(s, l);
          });
        }, t.prototype._clearController = function() {
          var e = this._controller;
          this._controllerHost = null, e && (e.dispose(), e = null);
        }, t.prototype._onPan = function(e) {
          if (this._state !== "animating" && (Math.abs(e.dx) > c9 || Math.abs(e.dy) > c9)) {
            var i = this.seriesModel.getData().tree.root;
            if (!i) return;
            var r = i.getLayout();
            if (!r) return;
            this.api.dispatchAction({ type: "treemapMove", from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: r.x + e.dx, y: r.y + e.dy, width: r.width, height: r.height } });
          }
        }, t.prototype._onZoom = function(e) {
          var i = e.originX, r = e.originY, a = e.scale;
          if (this._state !== "animating") {
            var o = this.seriesModel.getData().tree.root;
            if (!o) return;
            var s = o.getLayout();
            if (!s) return;
            var l = new Ht(s.x, s.y, s.width, s.height), u = null, h = this._controllerHost;
            u = h.zoomLimit;
            var c = h.zoom = h.zoom || 1;
            if (c *= a, u) {
              var f = u.min || 0, g = u.max || 1 / 0;
              c = Math.max(Math.min(g, c), f);
            }
            var d = c / h.zoom;
            h.zoom = c;
            var A = this.seriesModel.layoutInfo;
            i -= A.x, r -= A.y;
            var p = Fr();
            bo(p, p, [-i, -r]), Bb(p, p, [d, d]), bo(p, p, [i, r]), l.applyTransform(p), this.api.dispatchAction({ type: "treemapRender", from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: l.x, y: l.y, width: l.width, height: l.height } });
          }
        }, t.prototype._initEvents = function(e) {
          var i = this;
          e.on("click", function(r) {
            if (i._state === "ready") {
              var a = i.seriesModel.get("nodeClick", true);
              if (a) {
                var o = i.findTarget(r.offsetX, r.offsetY);
                if (o) {
                  var s = o.node;
                  if (s.getLayout().isLeafRoot) i._rootToNode(o);
                  else if (a === "zoomToNode") i._zoomToNode(o);
                  else if (a === "link") {
                    var l = s.hostTree.data.getItemModel(s.dataIndex), u = l.get("link", true), h = l.get("target", true) || "blank";
                    u && x1(u, h);
                  }
                }
              }
            }
          }, this);
        }, t.prototype._renderBreadcrumb = function(e, i, r) {
          var a = this;
          r || (r = e.get("leafDepth", true) != null ? { node: e.getViewRoot() } : this.findTarget(i.getWidth() / 2, i.getHeight() / 2), r || (r = { node: e.getData().tree.root })), (this._breadcrumb || (this._breadcrumb = new $2t(this.group))).render(e, i, r.node, function(o) {
            a._state !== "animating" && (vM(e.getViewRoot(), o) ? a._rootToNode({ node: o }) : a._zoomToNode({ node: o }));
          });
        }, t.prototype.remove = function() {
          this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = zv(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
        }, t.prototype.dispose = function() {
          this._clearController();
        }, t.prototype._zoomToNode = function(e) {
          this.api.dispatchAction({ type: "treemapZoomToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: e.node });
        }, t.prototype._rootToNode = function(e) {
          this.api.dispatchAction({ type: "treemapRootToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: e.node });
        }, t.prototype.findTarget = function(e, i) {
          var r, a = this.seriesModel.getViewRoot();
          return a.eachNode({ attr: "viewChildren", order: "preorder" }, function(o) {
            var s = this._storage.background[o.getRawIndex()];
            if (s) {
              var l = s.transformCoordToLocal(e, i), u = s.shape;
              if (u.x <= l[0] && l[0] <= u.x + u.width && u.y <= l[1] && l[1] <= u.y + u.height) r = { node: o, offsetX: l[0], offsetY: l[1] };
              else return false;
            }
          }, this), r;
        }, t.type = "treemap", t;
      }(Ve);
      function zv() {
        return { nodeGroup: [], background: [], content: [] };
      }
      function sBt(n, t, e, i, r, a, o, s, l, u) {
        if (!o) return;
        var h = o.getLayout(), c = n.getData(), f = o.getModel();
        if (c.setItemGraphicEl(o.dataIndex, null), !h || !h.isInView) return;
        var g = h.width, d = h.height, A = h.borderWidth, p = h.invisible, v = o.getRawIndex(), y = s && s.getRawIndex(), m = o.viewChildren, _ = h.upperHeight, E = m && m.length, I = f.getModel("itemStyle"), x = f.getModel(["emphasis", "itemStyle"]), w = f.getModel(["blur", "itemStyle"]), C = f.getModel(["select", "itemStyle"]), S = I.get("borderRadius") || 0, b = G("nodeGroup", mM);
        if (!b) return;
        if (l.add(b), b.x = h.x || 0, b.y = h.y || 0, b.markRedraw(), bI(b).nodeWidth = g, bI(b).nodeHeight = d, h.isAboveViewRoot) return b;
        var B = G("background", h9, u, rBt);
        B && F(b, B, E && h.upperLabelHeight);
        var T = f.getModel("emphasis"), D = T.get("focus"), R = T.get("blurScope"), L = T.get("disabled"), k = D === "ancestor" ? o.getAncestorsIndices() : D === "descendant" ? o.getDescendantIndices() : D;
        if (E) $l(b) && Th(b, false), B && (Th(B, !L), c.setItemGraphicEl(o.dataIndex, B), j2(B, k, R));
        else {
          var P = G("content", h9, u, aBt);
          P && Q(b, P), B.disableMorphing = true, B && $l(B) && Th(B, false), Th(b, !L), c.setItemGraphicEl(o.dataIndex, b), j2(b, k, R);
        }
        return b;
        function F(et, nt, gt) {
          var H = Dt(nt);
          if (H.dataIndex = o.dataIndex, H.seriesIndex = n.seriesIndex, nt.setShape({ x: 0, y: 0, width: g, height: d, r: S }), p) z(nt);
          else {
            nt.invisible = false;
            var W = o.getVisual("style"), it = W.stroke, kt = d9(I);
            kt.fill = it;
            var vt = ac(x);
            vt.fill = x.get("borderColor");
            var St = ac(w);
            St.fill = w.get("borderColor");
            var bt = ac(C);
            if (bt.fill = C.get("borderColor"), gt) {
              var Ee = g - 2 * A;
              j(nt, it, W.opacity, { x: A, y: 0, width: Ee, height: _ });
            } else nt.removeTextContent();
            nt.setStyle(kt), nt.ensureState("emphasis").style = vt, nt.ensureState("blur").style = St, nt.ensureState("select").style = bt, bh(nt);
          }
          et.add(nt);
        }
        function Q(et, nt) {
          var gt = Dt(nt);
          gt.dataIndex = o.dataIndex, gt.seriesIndex = n.seriesIndex;
          var H = Math.max(g - 2 * A, 0), W = Math.max(d - 2 * A, 0);
          if (nt.culling = true, nt.setShape({ x: A, y: A, width: H, height: W, r: S }), p) z(nt);
          else {
            nt.invisible = false;
            var it = o.getVisual("style"), kt = it.fill, vt = d9(I);
            vt.fill = kt, vt.decal = it.decal;
            var St = ac(x), bt = ac(w), Ee = ac(C);
            j(nt, kt, it.opacity, null), nt.setStyle(vt), nt.ensureState("emphasis").style = St, nt.ensureState("blur").style = bt, nt.ensureState("select").style = Ee, bh(nt);
          }
          et.add(nt);
        }
        function z(et) {
          !et.invisible && a.push(et);
        }
        function j(et, nt, gt, H) {
          var W = f.getModel(H ? g9 : f9), it = zn(f.get("name"), null), kt = W.getShallow("show");
          vi(et, Xn(f, H ? g9 : f9), { defaultText: kt ? it : null, inheritColor: nt, defaultOpacity: gt, labelFetcher: n, labelDataIndex: o.dataIndex });
          var vt = et.getTextContent();
          if (vt) {
            var St = vt.style, bt = Ab(St.padding || 0);
            H && (et.setTextConfig({ layoutRect: H }), vt.disableLabelLayout = true), vt.beforeUpdate = function() {
              var rn = Math.max((H ? H.width : et.shape.width) - bt[1] - bt[3], 0), Ie = Math.max((H ? H.height : et.shape.height) - bt[0] - bt[2], 0);
              (St.width !== rn || St.height !== Ie) && vt.setStyle({ width: rn, height: Ie });
            }, St.truncateMinChar = 2, St.lineOverflow = "truncate", $(St, H, h);
            var Ee = vt.getState("emphasis");
            $(Ee ? Ee.style : null, H, h);
          }
        }
        function $(et, nt, gt) {
          var H = et ? et.text : null;
          if (!nt && gt.isLeafRoot && H != null) {
            var W = n.get("drillDownIcon", true);
            et.text = W ? W + " " + H : H;
          }
        }
        function G(et, nt, gt, H) {
          var W = y != null && e[et][y], it = r[et];
          return W ? (e[et][y] = null, tt(it, W)) : p || (W = new nt(), W instanceof ha && (W.z2 = lBt(gt, H)), J(it, W)), t[et][v] = W;
        }
        function tt(et, nt) {
          var gt = et[v] = {};
          nt instanceof mM ? (gt.oldX = nt.x, gt.oldY = nt.y) : gt.oldShape = Y({}, nt.shape);
        }
        function J(et, nt) {
          var gt = et[v] = {}, H = o.parentNode, W = nt instanceof Ct;
          if (H && (!i || i.direction === "drillDown")) {
            var it = 0, kt = 0, vt = r.background[H.getRawIndex()];
            !i && vt && vt.oldShape && (it = vt.oldShape.width, kt = vt.oldShape.height), W ? (gt.oldX = 0, gt.oldY = kt) : gt.oldShape = { x: it, y: kt, width: 0, height: 0 };
          }
          gt.fadein = !W;
        }
      }
      function lBt(n, t) {
        return n * iBt + t;
      }
      var Gv = M, uBt = _t, BI = -1, $n = function() {
        function n(t) {
          var e = t.mappingMethod, i = t.type, r = this.option = xt(t);
          this.type = i, this.mappingMethod = e, this._normalizeData = fBt[e];
          var a = n.visualHandlers[i];
          this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[e], e === "piecewise" ? (_M(r), hBt(r)) : e === "category" ? r.categories ? cBt(r) : _M(r, true) : (It(e !== "linear" || r.dataExtent), _M(r));
        }
        return n.prototype.mapValueToVisual = function(t) {
          var e = this._normalizeData(t);
          return this._normalizedToVisual(e, t);
        }, n.prototype.getNormalizer = function() {
          return ct(this._normalizeData, this);
        }, n.listVisualTypes = function() {
          return re(n.visualHandlers);
        }, n.isValidType = function(t) {
          return n.visualHandlers.hasOwnProperty(t);
        }, n.eachVisual = function(t, e, i) {
          _t(t) ? M(t, e, i) : e.call(i, t);
        }, n.mapVisual = function(t, e, i) {
          var r, a = X(t) ? [] : _t(t) ? {} : (r = true, null);
          return n.eachVisual(t, function(o, s) {
            var l = e.call(i, o, s);
            r ? a = l : a[s] = l;
          }), a;
        }, n.retrieveVisuals = function(t) {
          var e = {}, i;
          return t && Gv(n.visualHandlers, function(r, a) {
            t.hasOwnProperty(a) && (e[a] = t[a], i = true);
          }), i ? e : null;
        }, n.prepareVisualTypes = function(t) {
          if (X(t)) t = t.slice();
          else if (uBt(t)) {
            var e = [];
            Gv(t, function(i, r) {
              e.push(r);
            }), t = e;
          } else return [];
          return t.sort(function(i, r) {
            return r === "color" && i !== "color" && i.indexOf("color") === 0 ? 1 : -1;
          }), t;
        }, n.dependsOn = function(t, e) {
          return e === "color" ? !!(t && t.indexOf(e) === 0) : t === e;
        }, n.findPieceIndex = function(t, e, i) {
          for (var r, a = 1 / 0, o = 0, s = e.length; o < s; o++) {
            var l = e[o].value;
            if (l != null) {
              if (l === t || ht(l) && l === t + "") return o;
              i && f(l, o);
            }
          }
          for (var o = 0, s = e.length; o < s; o++) {
            var u = e[o], h = u.interval, c = u.close;
            if (h) {
              if (h[0] === -1 / 0) {
                if (MI(c[1], t, h[1])) return o;
              } else if (h[1] === 1 / 0) {
                if (MI(c[0], h[0], t)) return o;
              } else if (MI(c[0], h[0], t) && MI(c[1], t, h[1])) return o;
              i && f(h[0], o), i && f(h[1], o);
            }
          }
          if (i) return t === 1 / 0 ? e.length - 1 : t === -1 / 0 ? 0 : r;
          function f(g, d) {
            var A = Math.abs(g - t);
            A < a && (a = A, r = d);
          }
        }, n.visualHandlers = { color: { applyVisual: Uv("color"), getColorMapper: function() {
          var t = this.option;
          return ct(t.mappingMethod === "category" ? function(e, i) {
            return !i && (e = this._normalizeData(e)), Vv.call(this, e);
          } : function(e, i, r) {
            var a = !!r;
            return !i && (e = this._normalizeData(e)), r = zb(e, t.parsedVisual, r), a ? r : bs(r, "rgba");
          }, this);
        }, _normalizedToVisual: { linear: function(t) {
          return bs(zb(t, this.option.parsedVisual), "rgba");
        }, category: Vv, piecewise: function(t, e) {
          var i = EM.call(this, e);
          return i == null && (i = bs(zb(t, this.option.parsedVisual), "rgba")), i;
        }, fixed: oc } }, colorHue: TI(function(t, e) {
          return _p(t, e);
        }), colorSaturation: TI(function(t, e) {
          return _p(t, null, e);
        }), colorLightness: TI(function(t, e) {
          return _p(t, null, null, e);
        }), colorAlpha: TI(function(t, e) {
          return w_(t, e);
        }), decal: { applyVisual: Uv("decal"), _normalizedToVisual: { linear: null, category: Vv, piecewise: null, fixed: null } }, opacity: { applyVisual: Uv("opacity"), _normalizedToVisual: IM([0, 1]) }, liftZ: { applyVisual: Uv("liftZ"), _normalizedToVisual: { linear: oc, category: oc, piecewise: oc, fixed: oc } }, symbol: { applyVisual: function(t, e, i) {
          var r = this.mapValueToVisual(t);
          i("symbol", r);
        }, _normalizedToVisual: { linear: A9, category: Vv, piecewise: function(t, e) {
          var i = EM.call(this, e);
          return i == null && (i = A9.call(this, t)), i;
        }, fixed: oc } }, symbolSize: { applyVisual: Uv("symbolSize"), _normalizedToVisual: IM([0, 1]) } }, n;
      }();
      function hBt(n) {
        var t = n.pieceList;
        n.hasSpecialVisual = false, M(t, function(e, i) {
          e.originIndex = i, e.visual != null && (n.hasSpecialVisual = true);
        });
      }
      function cBt(n) {
        var t = n.categories, e = n.categoryMap = {}, i = n.visual;
        if (Gv(t, function(o, s) {
          e[o] = s;
        }), !X(i)) {
          var r = [];
          _t(i) ? Gv(i, function(o, s) {
            var l = e[s];
            r[l != null ? l : BI] = o;
          }) : r[BI] = i, i = p9(n, r);
        }
        for (var a = t.length - 1; a >= 0; a--) i[a] == null && (delete e[t[a]], t.pop());
      }
      function _M(n, t) {
        var e = n.visual, i = [];
        _t(e) ? Gv(e, function(a) {
          i.push(a);
        }) : e != null && i.push(e);
        var r = { color: 1, symbol: 1 };
        !t && i.length === 1 && !r.hasOwnProperty(n.type) && (i[1] = i[0]), p9(n, i);
      }
      function TI(n) {
        return { applyVisual: function(t, e, i) {
          var r = this.mapValueToVisual(t);
          i("color", n(e("color"), r));
        }, _normalizedToVisual: IM([0, 1]) };
      }
      function A9(n) {
        var t = this.option.visual;
        return t[Math.round(Le(n, [0, 1], [0, t.length - 1], true))] || {};
      }
      function Uv(n) {
        return function(t, e, i) {
          i(n, this.mapValueToVisual(t));
        };
      }
      function Vv(n) {
        var t = this.option.visual;
        return t[this.option.loop && n !== BI ? n % t.length : n];
      }
      function oc() {
        return this.option.visual[0];
      }
      function IM(n) {
        return { linear: function(t) {
          return Le(t, n, this.option.visual, true);
        }, category: Vv, piecewise: function(t, e) {
          var i = EM.call(this, e);
          return i == null && (i = Le(t, n, this.option.visual, true)), i;
        }, fixed: oc };
      }
      function EM(n) {
        var t = this.option, e = t.pieceList;
        if (t.hasSpecialVisual) {
          var i = $n.findPieceIndex(n, e), r = e[i];
          if (r && r.visual) return r.visual[this.type];
        }
      }
      function p9(n, t) {
        return n.visual = t, n.type === "color" && (n.parsedVisual = Z(t, function(e) {
          var i = Or(e);
          return !i && true && un("'" + e + "' is an illegal color, fallback to '#000000'", true), i || [0, 0, 0, 1];
        })), t;
      }
      var fBt = { linear: function(n) {
        return Le(n, this.option.dataExtent, [0, 1], true);
      }, piecewise: function(n) {
        var t = this.option.pieceList, e = $n.findPieceIndex(n, t, true);
        if (e != null) return Le(e, [0, t.length - 1], [0, 1], true);
      }, category: function(n) {
        var t = this.option.categories ? this.option.categoryMap[n] : n;
        return t == null ? BI : t;
      }, fixed: In };
      function MI(n, t, e) {
        return n ? t <= e : t < e;
      }
      var gBt = "itemStyle", v9 = le();
      const dBt = { seriesType: "treemap", reset: function(n) {
        var t = n.getData().tree, e = t.root;
        e.isRemoved() || y9(e, {}, n.getViewRoot().getAncestors(), n);
      } };
      function y9(n, t, e, i) {
        var r = n.getModel(), a = n.getLayout(), o = n.hostTree.data;
        if (!(!a || a.invisible || !a.isInView)) {
          var s = r.getModel(gBt), l = ABt(s, t, i), u = o.ensureUniqueItemVisual(n.dataIndex, "style"), h = s.get("borderColor"), c = s.get("borderColorSaturation"), f;
          c != null && (f = m9(l), h = pBt(c, f)), u.stroke = h;
          var g = n.viewChildren;
          if (!g || !g.length) f = m9(l), u.fill = f;
          else {
            var d = vBt(n, r, a, s, l, g);
            M(g, function(A, p) {
              if (A.depth >= e.length || A === e[A.depth]) {
                var v = yBt(r, l, A, p, d, i);
                y9(A, v, e, i);
              }
            });
          }
        }
      }
      function ABt(n, t, e) {
        var i = Y({}, t), r = e.designatedVisualItemStyle;
        return M(["color", "colorAlpha", "colorSaturation"], function(a) {
          r[a] = t[a];
          var o = n.get(a);
          r[a] = null, o != null && (i[a] = o);
        }), i;
      }
      function m9(n) {
        var t = xM(n, "color");
        if (t) {
          var e = xM(n, "colorAlpha"), i = xM(n, "colorSaturation");
          return i && (t = _p(t, null, null, i)), e && (t = w_(t, e)), t;
        }
      }
      function pBt(n, t) {
        return t != null ? _p(t, null, null, n) : null;
      }
      function xM(n, t) {
        var e = n[t];
        if (e != null && e !== "none") return e;
      }
      function vBt(n, t, e, i, r, a) {
        if (!(!a || !a.length)) {
          var o = wM(t, "color") || r.color != null && r.color !== "none" && (wM(t, "colorAlpha") || wM(t, "colorSaturation"));
          if (o) {
            var s = t.get("visualMin"), l = t.get("visualMax"), u = e.dataExtent.slice();
            s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l);
            var h = t.get("colorMappingBy"), c = { type: o.name, dataExtent: u, visual: o.range };
            c.type === "color" && (h === "index" || h === "id") ? (c.mappingMethod = "category", c.loop = true) : c.mappingMethod = "linear";
            var f = new $n(c);
            return v9(f).drColorMappingBy = h, f;
          }
        }
      }
      function wM(n, t) {
        var e = n.get(t);
        return X(e) && e.length ? { name: t, range: e } : null;
      }
      function yBt(n, t, e, i, r, a) {
        var o = Y({}, t);
        if (r) {
          var s = r.type, l = s === "color" && v9(r).drColorMappingBy, u = l === "index" ? i : l === "id" ? a.mapIdToIndex(e.getId()) : e.getValue(n.get("visualDimension"));
          o[s] = r.mapValueToVisual(u);
        }
        return o;
      }
      var jv = Math.max, DI = Math.min, _9 = Dn, CM = M, I9 = ["itemStyle", "borderWidth"], mBt = ["itemStyle", "gapWidth"], _Bt = ["upperLabel", "show"], IBt = ["upperLabel", "height"];
      const EBt = { seriesType: "treemap", reset: function(n, t, e, i) {
        var r = e.getWidth(), a = e.getHeight(), o = n.option, s = Gn(n.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }), l = o.size || [], u = ot(_9(s.width, l[0]), r), h = ot(_9(s.height, l[1]), a), c = i && i.type, f = ["treemapZoomToNode", "treemapRootToNode"], g = Qv(i, f, n), d = c === "treemapRender" || c === "treemapMove" ? i.rootRect : null, A = n.getViewRoot(), p = a9(A);
        if (c !== "treemapMove") {
          var v = c === "treemapZoomToNode" ? BBt(n, g, A, u, h) : d ? [d.width, d.height] : [u, h], y = o.sort;
          y && y !== "asc" && y !== "desc" && (y = "desc");
          var m = { squareRatio: o.squareRatio, sort: y, leafDepth: o.leafDepth };
          A.hostTree.clearLayouts();
          var _ = { x: 0, y: 0, width: v[0], height: v[1], area: v[0] * v[1] };
          A.setLayout(_), E9(A, m, false, 0), _ = A.getLayout(), CM(p, function(I, x) {
            var w = (p[x + 1] || A).getValue();
            I.setLayout(Y({ dataExtent: [w, w], borderWidth: 0, upperHeight: 0 }, _));
          });
        }
        var E = n.getData().tree.root;
        E.setLayout(TBt(s, d, g), true), n.setLayoutInfo(s), w9(E, new Ht(-s.x, -s.y, r, a), p, A, 0);
      } };
      function E9(n, t, e, i) {
        var r, a;
        if (!n.isRemoved()) {
          var o = n.getLayout();
          r = o.width, a = o.height;
          var s = n.getModel(), l = s.get(I9), u = s.get(mBt) / 2, h = C9(s), c = Math.max(l, h), f = l - u, g = c - u;
          n.setLayout({ borderWidth: l, upperHeight: c, upperLabelHeight: h }, true), r = jv(r - 2 * f, 0), a = jv(a - f - g, 0);
          var d = r * a, A = xBt(n, s, d, t, e, i);
          if (A.length) {
            var p = { x: f, y: g, width: r, height: a }, v = DI(r, a), y = 1 / 0, m = [];
            m.area = 0;
            for (var _ = 0, E = A.length; _ < E; ) {
              var I = A[_];
              m.push(I), m.area += I.getLayout().area;
              var x = bBt(m, v, t.squareRatio);
              x <= y ? (_++, y = x) : (m.area -= m.pop().getLayout().area, x9(m, v, p, u, false), v = DI(p.width, p.height), m.length = m.area = 0, y = 1 / 0);
            }
            if (m.length && x9(m, v, p, u, true), !e) {
              var w = s.get("childrenVisibleMin");
              w != null && d < w && (e = true);
            }
            for (var _ = 0, E = A.length; _ < E; _++) E9(A[_], t, e, i + 1);
          }
        }
      }
      function xBt(n, t, e, i, r, a) {
        var o = n.children || [], s = i.sort;
        s !== "asc" && s !== "desc" && (s = null);
        var l = i.leafDepth != null && i.leafDepth <= a;
        if (r && !l) return n.viewChildren = [];
        o = Ne(o, function(g) {
          return !g.isRemoved();
        }), CBt(o, s);
        var u = SBt(t, o, s);
        if (u.sum === 0) return n.viewChildren = [];
        if (u.sum = wBt(t, e, u.sum, s, o), u.sum === 0) return n.viewChildren = [];
        for (var h = 0, c = o.length; h < c; h++) {
          var f = o[h].getValue() / u.sum * e;
          o[h].setLayout({ area: f });
        }
        return l && (o.length && n.setLayout({ isLeafRoot: true }, true), o.length = 0), n.viewChildren = o, n.setLayout({ dataExtent: u.dataExtent }, true), o;
      }
      function wBt(n, t, e, i, r) {
        if (!i) return e;
        for (var a = n.get("visibleMin"), o = r.length, s = o, l = o - 1; l >= 0; l--) {
          var u = r[i === "asc" ? o - l - 1 : l].getValue();
          u / e * t < a && (s = l, e -= u);
        }
        return i === "asc" ? r.splice(0, o - s) : r.splice(s, o - s), e;
      }
      function CBt(n, t) {
        return t && n.sort(function(e, i) {
          var r = t === "asc" ? e.getValue() - i.getValue() : i.getValue() - e.getValue();
          return r === 0 ? t === "asc" ? e.dataIndex - i.dataIndex : i.dataIndex - e.dataIndex : r;
        }), n;
      }
      function SBt(n, t, e) {
        for (var i = 0, r = 0, a = t.length; r < a; r++) i += t[r].getValue();
        var o = n.get("visualDimension"), s;
        return !t || !t.length ? s = [NaN, NaN] : o === "value" && e ? (s = [t[t.length - 1].getValue(), t[0].getValue()], e === "asc" && s.reverse()) : (s = [1 / 0, -1 / 0], CM(t, function(l) {
          var u = l.getValue(o);
          u < s[0] && (s[0] = u), u > s[1] && (s[1] = u);
        })), { sum: i, dataExtent: s };
      }
      function bBt(n, t, e) {
        for (var i = 0, r = 1 / 0, a = 0, o = void 0, s = n.length; a < s; a++) o = n[a].getLayout().area, o && (o < r && (r = o), o > i && (i = o));
        var l = n.area * n.area, u = t * t * e;
        return l ? jv(u * i / l, l / (u * r)) : 1 / 0;
      }
      function x9(n, t, e, i, r) {
        var a = t === e.width ? 0 : 1, o = 1 - a, s = ["x", "y"], l = ["width", "height"], u = e[s[a]], h = t ? n.area / t : 0;
        (r || h > e[l[o]]) && (h = e[l[o]]);
        for (var c = 0, f = n.length; c < f; c++) {
          var g = n[c], d = {}, A = h ? g.getLayout().area / h : 0, p = d[l[o]] = jv(h - 2 * i, 0), v = e[s[a]] + e[l[a]] - u, y = c === f - 1 || v < A ? v : A, m = d[l[a]] = jv(y - 2 * i, 0);
          d[s[o]] = e[s[o]] + DI(i, p / 2), d[s[a]] = u + DI(i, m / 2), u += y, g.setLayout(d, true);
        }
        e[s[o]] += h, e[l[o]] -= h;
      }
      function BBt(n, t, e, i, r) {
        var a = (t || {}).node, o = [i, r];
        if (!a || a === e) return o;
        for (var s, l = i * r, u = l * n.option.zoomToNodeRatio; s = a.parentNode; ) {
          for (var h = 0, c = s.children, f = 0, g = c.length; f < g; f++) h += c[f].getValue();
          var d = a.getValue();
          if (d === 0) return o;
          u *= h / d;
          var A = s.getModel(), p = A.get(I9), v = Math.max(p, C9(A));
          u += 4 * p * p + (3 * p + v) * Math.pow(u, 0.5), u > bG && (u = bG), a = s;
        }
        u < l && (u = l);
        var y = Math.pow(u / l, 0.5);
        return [i * y, r * y];
      }
      function TBt(n, t, e) {
        if (t) return { x: t.x, y: t.y };
        var i = { x: 0, y: 0 };
        if (!e) return i;
        var r = e.node, a = r.getLayout();
        if (!a) return i;
        for (var o = [a.width / 2, a.height / 2], s = r; s; ) {
          var l = s.getLayout();
          o[0] += l.x, o[1] += l.y, s = s.parentNode;
        }
        return { x: n.width / 2 - o[0], y: n.height / 2 - o[1] };
      }
      function w9(n, t, e, i, r) {
        var a = n.getLayout(), o = e[r], s = o && o === n;
        if (!(o && !s || r === e.length && n !== i)) {
          n.setLayout({ isInView: true, invisible: !s && !t.intersect(a), isAboveViewRoot: s }, true);
          var l = new Ht(t.x - a.x, t.y - a.y, t.width, t.height);
          CM(n.viewChildren || [], function(u) {
            w9(u, l, e, i, r + 1);
          });
        }
      }
      function C9(n) {
        return n.get(_Bt) ? n.get(IBt) : 0;
      }
      function MBt(n) {
        n.registerSeriesModel(X2t), n.registerChartView(oBt), n.registerVisual(dBt), n.registerLayout(EBt), W2t(n);
      }
      function DBt(n) {
        var t = n.findComponents({ mainType: "legend" });
        !t || !t.length || n.eachSeriesByType("graph", function(e) {
          var i = e.getCategoriesData(), r = e.getGraph(), a = r.data, o = i.mapArray(i.getName);
          a.filterSelf(function(s) {
            var l = a.getItemModel(s), u = l.getShallow("category");
            if (u != null) {
              pe(u) && (u = o[u]);
              for (var h = 0; h < t.length; h++) if (!t[h].isSelected(u)) return false;
            }
            return true;
          });
        });
      }
      function RBt(n) {
        var t = {};
        n.eachSeriesByType("graph", function(e) {
          var i = e.getCategoriesData(), r = e.getData(), a = {};
          i.each(function(o) {
            var s = i.getName(o);
            a["ec-" + s] = o;
            var l = i.getItemModel(o), u = l.getModel("itemStyle").getItemStyle();
            u.fill || (u.fill = e.getColorFromPalette(s, t)), i.setItemVisual(o, "style", u);
            for (var h = ["symbol", "symbolSize", "symbolKeepAspect"], c = 0; c < h.length; c++) {
              var f = l.getShallow(h[c], true);
              f != null && i.setItemVisual(o, h[c], f);
            }
          }), i.count() && r.each(function(o) {
            var s = r.getItemModel(o), l = s.getShallow("category");
            if (l != null) {
              ht(l) && (l = a["ec-" + l]);
              var u = i.getItemVisual(l, "style"), h = r.ensureUniqueItemVisual(o, "style");
              Y(h, u);
              for (var c = ["symbol", "symbolSize", "symbolKeepAspect"], f = 0; f < c.length; f++) r.setItemVisual(o, c[f], i.getItemVisual(l, c[f]));
            }
          });
        });
      }
      function RI(n) {
        return n instanceof Array || (n = [n, n]), n;
      }
      function LBt(n) {
        n.eachSeriesByType("graph", function(t) {
          var e = t.getGraph(), i = t.getEdgeData(), r = RI(t.get("edgeSymbol")), a = RI(t.get("edgeSymbolSize"));
          i.setVisual("fromSymbol", r && r[0]), i.setVisual("toSymbol", r && r[1]), i.setVisual("fromSymbolSize", a && a[0]), i.setVisual("toSymbolSize", a && a[1]), i.setVisual("style", t.getModel("lineStyle").getLineStyle()), i.each(function(o) {
            var s = i.getItemModel(o), l = e.getEdgeByIndex(o), u = RI(s.getShallow("symbol", true)), h = RI(s.getShallow("symbolSize", true)), c = s.getModel("lineStyle").getLineStyle(), f = i.ensureUniqueItemVisual(o, "style");
            switch (Y(f, c), f.stroke) {
              case "source": {
                var g = l.node1.getVisual("style");
                f.stroke = g && g.fill;
                break;
              }
              case "target": {
                var g = l.node2.getVisual("style");
                f.stroke = g && g.fill;
                break;
              }
            }
            u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), h[0] && l.setVisual("fromSymbolSize", h[0]), h[1] && l.setVisual("toSymbolSize", h[1]);
          });
        });
      }
      var SM = "-->", LI = function(n) {
        return n.get("autoCurveness") || null;
      }, S9 = function(n, t) {
        var e = LI(n), i = 20, r = [];
        if (pe(e)) i = e;
        else if (X(e)) {
          n.__curvenessList = e;
          return;
        }
        t > i && (i = t);
        var a = i % 2 ? i + 2 : i + 3;
        r = [];
        for (var o = 0; o < a; o++) r.push((o % 2 ? o + 1 : o) / 10 * (o % 2 ? -1 : 1));
        n.__curvenessList = r;
      }, qv = function(n, t, e) {
        var i = [n.id, n.dataIndex].join("."), r = [t.id, t.dataIndex].join(".");
        return [e.uid, i, r].join(SM);
      }, b9 = function(n) {
        var t = n.split(SM);
        return [t[0], t[2], t[1]].join(SM);
      }, PBt = function(n, t) {
        var e = qv(n.node1, n.node2, t);
        return t.__edgeMap[e];
      }, NBt = function(n, t) {
        var e = bM(qv(n.node1, n.node2, t), t), i = bM(qv(n.node2, n.node1, t), t);
        return e + i;
      }, bM = function(n, t) {
        var e = t.__edgeMap;
        return e[n] ? e[n].length : 0;
      };
      function kBt(n) {
        LI(n) && (n.__curvenessList = [], n.__edgeMap = {}, S9(n));
      }
      function FBt(n, t, e, i) {
        if (LI(e)) {
          var r = qv(n, t, e), a = e.__edgeMap, o = a[b9(r)];
          a[r] && !o ? a[r].isForward = true : o && a[r] && (o.isForward = true, a[r].isForward = false), a[r] = a[r] || [], a[r].push(i);
        }
      }
      function BM(n, t, e, i) {
        var r = LI(t), a = X(r);
        if (!r) return null;
        var o = PBt(n, t);
        if (!o) return null;
        for (var s = -1, l = 0; l < o.length; l++) if (o[l] === e) {
          s = l;
          break;
        }
        var u = NBt(n, t);
        S9(t, u), n.lineStyle = n.lineStyle || {};
        var h = qv(n.node1, n.node2, t), c = t.__curvenessList, f = a || u % 2 ? 0 : 1;
        if (o.isForward) return c[f + s];
        var g = b9(h), d = bM(g, t), A = c[s + d + f];
        return i ? a ? r && r[0] === 0 ? (d + f) % 2 ? A : -A : ((d % 2 ? 0 : 1) + f) % 2 ? A : -A : (d + f) % 2 ? A : -A : c[s + d + f];
      }
      function B9(n) {
        var t = n.coordinateSystem;
        if (!(t && t.type !== "view")) {
          var e = n.getGraph();
          e.eachNode(function(i) {
            var r = i.getModel();
            i.setLayout([+r.get("x"), +r.get("y")]);
          }), TM(e, n);
        }
      }
      function TM(n, t) {
        n.eachEdge(function(e, i) {
          var r = ra(e.getModel().get(["lineStyle", "curveness"]), -BM(e, t, i, true), 0), a = ws(e.node1.getLayout()), o = ws(e.node2.getLayout()), s = [a, o];
          +r && s.push([(a[0] + o[0]) / 2 - (a[1] - o[1]) * r, (a[1] + o[1]) / 2 - (o[0] - a[0]) * r]), e.setLayout(s);
        });
      }
      function QBt(n, t) {
        n.eachSeriesByType("graph", function(e) {
          var i = e.get("layout"), r = e.coordinateSystem;
          if (r && r.type !== "view") {
            var a = e.getData(), o = [];
            M(r.dimensions, function(f) {
              o = o.concat(a.mapDimensionsAll(f));
            });
            for (var s = 0; s < a.count(); s++) {
              for (var l = [], u = false, h = 0; h < o.length; h++) {
                var c = a.get(o[h], s);
                isNaN(c) || (u = true), l.push(c);
              }
              u ? a.setItemLayout(s, r.dataToPoint(l)) : a.setItemLayout(s, [NaN, NaN]);
            }
            TM(a.graph, e);
          } else (!i || i === "none") && B9(e);
        });
      }
      function Hv(n) {
        var t = n.coordinateSystem;
        if (t.type !== "view") return 1;
        var e = n.option.nodeScaleRatio, i = t.scaleX, r = t.getZoom(), a = (r - 1) * e + 1;
        return a / i;
      }
      function Yv(n) {
        var t = n.getVisual("symbolSize");
        return t instanceof Array && (t = (t[0] + t[1]) / 2), +t;
      }
      var T9 = Math.PI, MM = [];
      function DM(n, t, e, i) {
        var r = n.coordinateSystem;
        if (!(r && r.type !== "view")) {
          var a = r.getBoundingRect(), o = n.getData(), s = o.graph, l = a.width / 2 + a.x, u = a.height / 2 + a.y, h = Math.min(a.width, a.height) / 2, c = o.count();
          if (o.setLayout({ cx: l, cy: u }), !!c) {
            if (e) {
              var f = r.pointToData(i), g = f[0], d = f[1], A = [g - l, d - u];
              og(A, A), f_(A, A, h), e.setLayout([l + A[0], u + A[1]], true);
              var p = n.get(["circular", "rotateLabel"]);
              M9(e, p, l, u);
            }
            OBt[t](n, s, o, h, l, u, c), s.eachEdge(function(v, y) {
              var m = ra(v.getModel().get(["lineStyle", "curveness"]), BM(v, n, y), 0), _ = ws(v.node1.getLayout()), E = ws(v.node2.getLayout()), I, x = (_[0] + E[0]) / 2, w = (_[1] + E[1]) / 2;
              +m && (m *= 3, I = [l * m + x * (1 - m), u * m + w * (1 - m)]), v.setLayout([_, E, I]);
            });
          }
        }
      }
      var OBt = { value: function(n, t, e, i, r, a, o) {
        var s = 0, l = e.getSum("value"), u = Math.PI * 2 / (l || o);
        t.eachNode(function(h) {
          var c = h.getValue("value"), f = u * (l ? c : 1) / 2;
          s += f, h.setLayout([i * Math.cos(s) + r, i * Math.sin(s) + a]), s += f;
        });
      }, symbolSize: function(n, t, e, i, r, a, o) {
        var s = 0;
        MM.length = o;
        var l = Hv(n);
        t.eachNode(function(c) {
          var f = Yv(c);
          isNaN(f) && (f = 2), f < 0 && (f = 0), f *= l;
          var g = Math.asin(f / 2 / i);
          isNaN(g) && (g = T9 / 2), MM[c.dataIndex] = g, s += g * 2;
        });
        var u = (2 * T9 - s) / o / 2, h = 0;
        t.eachNode(function(c) {
          var f = u + MM[c.dataIndex];
          h += f, (!c.getLayout() || !c.getLayout().fixed) && c.setLayout([i * Math.cos(h) + r, i * Math.sin(h) + a]), h += f;
        });
      } };
      function M9(n, t, e, i) {
        var r = n.getGraphicEl();
        if (r) {
          var a = n.getModel(), o = a.get(["label", "rotate"]) || 0, s = r.getSymbolPath();
          if (t) {
            var l = n.getLayout(), u = Math.atan2(l[1] - i, l[0] - e);
            u < 0 && (u = Math.PI * 2 + u);
            var h = l[0] < e;
            h && (u = u - Math.PI);
            var c = h ? "left" : "right";
            s.setTextConfig({ rotation: -u, position: c, origin: "center" });
            var f = s.ensureState("emphasis");
            Y(f.textConfig || (f.textConfig = {}), { position: c });
          } else s.setTextConfig({ rotation: o *= Math.PI / 180 });
        }
      }
      function zBt(n) {
        n.eachSeriesByType("graph", function(t) {
          t.get("layout") === "circular" && DM(t, "symbolSize");
        });
      }
      var nd = pb;
      function GBt(n, t, e) {
        for (var i = n, r = t, a = e.rect, o = a.width, s = a.height, l = [a.x + o / 2, a.y + s / 2], u = e.gravity == null ? 0.1 : e.gravity, h = 0; h < i.length; h++) {
          var c = i[h];
          c.p || (c.p = ih(o * (Math.random() - 0.5) + l[0], s * (Math.random() - 0.5) + l[1])), c.pp = ws(c.p), c.edges = null;
        }
        var f = e.friction == null ? 0.6 : e.friction, g = f, d, A;
        return { warmUp: function() {
          g = f * 0.8;
        }, setFixed: function(p) {
          i[p].fixed = true;
        }, setUnfixed: function(p) {
          i[p].fixed = false;
        }, beforeStep: function(p) {
          d = p;
        }, afterStep: function(p) {
          A = p;
        }, step: function(p) {
          d && d(i, r);
          for (var v = [], y = i.length, m = 0; m < r.length; m++) {
            var _ = r[m];
            if (!_.ignoreForceLayout) {
              var E = _.n1, I = _.n2;
              rh(v, I.p, E.p);
              var x = vb(v) - _.d, w = I.w / (E.w + I.w);
              isNaN(w) && (w = 0), og(v, v), !E.fixed && nd(E.p, E.p, v, w * x * g), !I.fixed && nd(I.p, I.p, v, -(1 - w) * x * g);
            }
          }
          for (var m = 0; m < y; m++) {
            var C = i[m];
            C.fixed || (rh(v, l, C.p), nd(C.p, C.p, v, u * g));
          }
          for (var m = 0; m < y; m++) for (var E = i[m], S = m + 1; S < y; S++) {
            var I = i[S];
            rh(v, I.p, E.p);
            var x = vb(v);
            x === 0 && (g0t(v, Math.random() - 0.5, Math.random() - 0.5), x = 1);
            var b = (E.rep + I.rep) / x / x;
            !E.fixed && nd(E.pp, E.pp, v, b), !I.fixed && nd(I.pp, I.pp, v, -b);
          }
          for (var B = [], m = 0; m < y; m++) {
            var C = i[m];
            C.fixed || (rh(B, C.p, C.pp), nd(C.p, C.p, B, g), Vi(C.pp, C.p));
          }
          g = g * 0.992;
          var T = g < 0.01;
          A && A(i, r, T), p && p(T);
        } };
      }
      function UBt(n) {
        n.eachSeriesByType("graph", function(t) {
          var e = t.coordinateSystem;
          if (!(e && e.type !== "view")) if (t.get("layout") === "force") {
            var i = t.preservedPoints || {}, r = t.getGraph(), a = r.data, o = r.edgeData, s = t.getModel("force"), l = s.get("initLayout");
            t.preservedPoints ? a.each(function(m) {
              var _ = a.getId(m);
              a.setItemLayout(m, i[_] || [NaN, NaN]);
            }) : !l || l === "none" ? B9(t) : l === "circular" && DM(t, "value");
            var u = a.getDataExtent("value"), h = o.getDataExtent("value"), c = s.get("repulsion"), f = s.get("edgeLength"), g = X(c) ? c : [c, c], d = X(f) ? f : [f, f];
            d = [d[1], d[0]];
            var A = a.mapArray("value", function(m, _) {
              var E = a.getItemLayout(_), I = Le(m, u, g);
              return isNaN(I) && (I = (g[0] + g[1]) / 2), { w: I, rep: I, fixed: a.getItemModel(_).get("fixed"), p: !E || isNaN(E[0]) || isNaN(E[1]) ? null : E };
            }), p = o.mapArray("value", function(m, _) {
              var E = r.getEdgeByIndex(_), I = Le(m, h, d);
              isNaN(I) && (I = (d[0] + d[1]) / 2);
              var x = E.getModel(), w = ra(E.getModel().get(["lineStyle", "curveness"]), -BM(E, t, _, true), 0);
              return { n1: A[E.node1.dataIndex], n2: A[E.node2.dataIndex], d: I, curveness: w, ignoreForceLayout: x.get("ignoreForceLayout") };
            }), v = e.getBoundingRect(), y = GBt(A, p, { rect: v, gravity: s.get("gravity"), friction: s.get("friction") });
            y.beforeStep(function(m, _) {
              for (var E = 0, I = m.length; E < I; E++) m[E].fixed && Vi(m[E].p, r.getNodeByIndex(E).getLayout());
            }), y.afterStep(function(m, _, E) {
              for (var I = 0, x = m.length; I < x; I++) m[I].fixed || r.getNodeByIndex(I).setLayout(m[I].p), i[a.getId(I)] = m[I].p;
              for (var I = 0, x = _.length; I < x; I++) {
                var w = _[I], C = r.getEdgeByIndex(I), S = w.n1.p, b = w.n2.p, B = C.getLayout();
                B = B ? B.slice() : [], B[0] = B[0] || [], B[1] = B[1] || [], Vi(B[0], S), Vi(B[1], b), +w.curveness && (B[2] = [(S[0] + b[0]) / 2 - (S[1] - b[1]) * w.curveness, (S[1] + b[1]) / 2 - (b[0] - S[0]) * w.curveness]), C.setLayout(B);
              }
            }), t.forceLayout = y, t.preservedPoints = i, y.step();
          } else t.forceLayout = null;
        });
      }
      function VBt(n, t, e) {
        var i = Y(n.getBoxLayoutParams(), { aspect: e });
        return Gn(i, { width: t.getWidth(), height: t.getHeight() });
      }
      function jBt(n, t) {
        var e = [];
        return n.eachSeriesByType("graph", function(i) {
          var r = i.get("coordinateSystem");
          if (!r || r === "view") {
            var a = i.getData(), o = a.mapArray(function(p) {
              var v = a.getItemModel(p);
              return [+v.get("x"), +v.get("y")];
            }), s = [], l = [];
            Y_(o, s, l), l[0] - s[0] === 0 && (l[0] += 1, s[0] -= 1), l[1] - s[1] === 0 && (l[1] += 1, s[1] -= 1);
            var u = (l[0] - s[0]) / (l[1] - s[1]), h = VBt(i, t, u);
            isNaN(u) && (s = [h.x, h.y], l = [h.x + h.width, h.y + h.height]);
            var c = l[0] - s[0], f = l[1] - s[1], g = h.width, d = h.height, A = i.coordinateSystem = new kv();
            A.zoomLimit = i.get("scaleLimit"), A.setBoundingRect(s[0], s[1], c, f), A.setViewRect(h.x, h.y, g, d), A.setCenter(i.get("center"), t), A.setZoom(i.get("zoom")), e.push(A);
          }
        }), e;
      }
      var D9 = Wn.prototype, RM = Up.prototype, R9 = /* @__PURE__ */ function() {
        function n() {
          this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
        }
        return n;
      }();
      (function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t;
      })(R9);
      function LM(n) {
        return isNaN(+n.cpx1) || isNaN(+n.cpy1);
      }
      var qBt = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "ec-line", i;
        }
        return t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new R9();
        }, t.prototype.buildPath = function(e, i) {
          LM(i) ? D9.buildPath.call(this, e, i) : RM.buildPath.call(this, e, i);
        }, t.prototype.pointAt = function(e) {
          return LM(this.shape) ? D9.pointAt.call(this, e) : RM.pointAt.call(this, e);
        }, t.prototype.tangentAt = function(e) {
          var i = this.shape, r = LM(i) ? [i.x2 - i.x1, i.y2 - i.y1] : RM.tangentAt.call(this, e);
          return og(r, r);
        }, t;
      }(Jt), PM = ["fromSymbol", "toSymbol"];
      function L9(n) {
        return "_" + n + "Type";
      }
      function P9(n, t, e) {
        var i = t.getItemVisual(e, n);
        if (!i || i === "none") return i;
        var r = t.getItemVisual(e, n + "Size"), a = t.getItemVisual(e, n + "Rotate"), o = t.getItemVisual(e, n + "Offset"), s = t.getItemVisual(e, n + "KeepAspect"), l = Vg(r), u = Uh(o || 0, l);
        return i + l + u + (a || "") + (s || "");
      }
      function N9(n, t, e) {
        var i = t.getItemVisual(e, n);
        if (!(!i || i === "none")) {
          var r = t.getItemVisual(e, n + "Size"), a = t.getItemVisual(e, n + "Rotate"), o = t.getItemVisual(e, n + "Offset"), s = t.getItemVisual(e, n + "KeepAspect"), l = Vg(r), u = Uh(o || 0, l), h = Nn(i, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s);
          return h.__specifiedRotation = a == null || isNaN(a) ? void 0 : +a * Math.PI / 180 || 0, h.name = n, h;
        }
      }
      function HBt(n) {
        var t = new qBt({ name: "line", subPixelOptimize: true });
        return NM(t.shape, n), t;
      }
      function NM(n, t) {
        n.x1 = t[0][0], n.y1 = t[0][1], n.x2 = t[1][0], n.y2 = t[1][1], n.percent = 1;
        var e = t[2];
        e ? (n.cpx1 = e[0], n.cpy1 = e[1]) : (n.cpx1 = NaN, n.cpy1 = NaN);
      }
      var kM = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this) || this;
          return a._createLine(e, i, r), a;
        }
        return t.prototype._createLine = function(e, i, r) {
          var a = e.hostModel, o = e.getItemLayout(i), s = HBt(o);
          s.shape.percent = 0, nn(s, { shape: { percent: 1 } }, a, i), this.add(s), M(PM, function(l) {
            var u = N9(l, e, i);
            this.add(u), this[L9(l)] = P9(l, e, i);
          }, this), this._updateCommonStl(e, i, r);
        }, t.prototype.updateData = function(e, i, r) {
          var a = e.hostModel, o = this.childOfName("line"), s = e.getItemLayout(i), l = { shape: {} };
          NM(l.shape, s), _e(o, l, a, i), M(PM, function(u) {
            var h = P9(u, e, i), c = L9(u);
            if (this[c] !== h) {
              this.remove(this.childOfName(u));
              var f = N9(u, e, i);
              this.add(f);
            }
            this[c] = h;
          }, this), this._updateCommonStl(e, i, r);
        }, t.prototype.getLinePath = function() {
          return this.childAt(0);
        }, t.prototype._updateCommonStl = function(e, i, r) {
          var a = e.hostModel, o = this.childOfName("line"), s = r && r.emphasisLineStyle, l = r && r.blurLineStyle, u = r && r.selectLineStyle, h = r && r.labelStatesModels, c = r && r.emphasisDisabled, f = r && r.focus, g = r && r.blurScope;
          if (!r || e.hasItemOption) {
            var d = e.getItemModel(i), A = d.getModel("emphasis");
            s = A.getModel("lineStyle").getLineStyle(), l = d.getModel(["blur", "lineStyle"]).getLineStyle(), u = d.getModel(["select", "lineStyle"]).getLineStyle(), c = A.get("disabled"), f = A.get("focus"), g = A.get("blurScope"), h = Xn(d);
          }
          var p = e.getItemVisual(i, "style"), v = p.stroke;
          o.useStyle(p), o.style.fill = null, o.style.strokeNoScale = true, o.ensureState("emphasis").style = s, o.ensureState("blur").style = l, o.ensureState("select").style = u, M(PM, function(I) {
            var x = this.childOfName(I);
            if (x) {
              x.setColor(v), x.style.opacity = p.opacity;
              for (var w = 0; w < qi.length; w++) {
                var C = qi[w], S = o.getState(C);
                if (S) {
                  var b = S.style || {}, B = x.ensureState(C), T = B.style || (B.style = {});
                  b.stroke != null && (T[x.__isEmptyBrush ? "stroke" : "fill"] = b.stroke), b.opacity != null && (T.opacity = b.opacity);
                }
              }
              x.markRedraw();
            }
          }, this);
          var y = a.getRawValue(i);
          vi(this, h, { labelDataIndex: i, labelFetcher: { getFormattedLabel: function(I, x) {
            return a.getFormattedLabel(I, x, e.dataType);
          } }, inheritColor: v || "#000", defaultOpacity: p.opacity, defaultText: (y == null ? e.getName(i) : isFinite(y) ? vn(y) : y) + "" });
          var m = this.getTextContent();
          if (m) {
            var _ = h.normal;
            m.__align = m.style.align, m.__verticalAlign = m.style.verticalAlign, m.__position = _.get("position") || "middle";
            var E = _.get("distance");
            X(E) || (E = [E, E]), m.__labelDistance = E;
          }
          this.setTextConfig({ position: null, local: true, inside: false }), hn(this, f, g, c);
        }, t.prototype.highlight = function() {
          Ps(this);
        }, t.prototype.downplay = function() {
          Ns(this);
        }, t.prototype.updateLayout = function(e, i) {
          this.setLinePoints(e.getItemLayout(i));
        }, t.prototype.setLinePoints = function(e) {
          var i = this.childOfName("line");
          NM(i.shape, e), i.dirty();
        }, t.prototype.beforeUpdate = function() {
          var e = this, i = e.childOfName("fromSymbol"), r = e.childOfName("toSymbol"), a = e.getTextContent();
          if (!i && !r && (!a || a.ignore)) return;
          for (var o = 1, s = this.parent; s; ) s.scaleX && (o /= s.scaleX), s = s.parent;
          var l = e.childOfName("line");
          if (!this.__dirty && !l.__dirty) return;
          var u = l.shape.percent, h = l.pointAt(0), c = l.pointAt(u), f = rh([], c, h);
          og(f, f);
          function g(S, b) {
            var B = S.__specifiedRotation;
            if (B == null) {
              var T = l.tangentAt(b);
              S.attr("rotation", (b === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(T[1], T[0]));
            } else S.attr("rotation", B);
          }
          if (i && (i.setPosition(h), g(i, 0), i.scaleX = i.scaleY = o * u, i.markRedraw()), r && (r.setPosition(c), g(r, 1), r.scaleX = r.scaleY = o * u, r.markRedraw()), a && !a.ignore) {
            a.x = a.y = 0, a.originX = a.originY = 0;
            var d = void 0, A = void 0, p = a.__labelDistance, v = p[0] * o, y = p[1] * o, m = u / 2, _ = l.tangentAt(m), E = [_[1], -_[0]], I = l.pointAt(m);
            E[1] > 0 && (E[0] = -E[0], E[1] = -E[1]);
            var x = _[0] < 0 ? -1 : 1;
            if (a.__position !== "start" && a.__position !== "end") {
              var w = -Math.atan2(_[1], _[0]);
              c[0] < h[0] && (w = Math.PI + w), a.rotation = w;
            }
            var C = void 0;
            switch (a.__position) {
              case "insideStartTop":
              case "insideMiddleTop":
              case "insideEndTop":
              case "middle":
                C = -y, A = "bottom";
                break;
              case "insideStartBottom":
              case "insideMiddleBottom":
              case "insideEndBottom":
                C = y, A = "top";
                break;
              default:
                C = 0, A = "middle";
            }
            switch (a.__position) {
              case "end":
                a.x = f[0] * v + c[0], a.y = f[1] * y + c[1], d = f[0] > 0.8 ? "left" : f[0] < -0.8 ? "right" : "center", A = f[1] > 0.8 ? "top" : f[1] < -0.8 ? "bottom" : "middle";
                break;
              case "start":
                a.x = -f[0] * v + h[0], a.y = -f[1] * y + h[1], d = f[0] > 0.8 ? "right" : f[0] < -0.8 ? "left" : "center", A = f[1] > 0.8 ? "bottom" : f[1] < -0.8 ? "top" : "middle";
                break;
              case "insideStartTop":
              case "insideStart":
              case "insideStartBottom":
                a.x = v * x + h[0], a.y = h[1] + C, d = _[0] < 0 ? "right" : "left", a.originX = -v * x, a.originY = -C;
                break;
              case "insideMiddleTop":
              case "insideMiddle":
              case "insideMiddleBottom":
              case "middle":
                a.x = I[0], a.y = I[1] + C, d = "center", a.originY = -C;
                break;
              case "insideEndTop":
              case "insideEnd":
              case "insideEndBottom":
                a.x = -v * x + c[0], a.y = c[1] + C, d = _[0] >= 0 ? "right" : "left", a.originX = v * x, a.originY = -C;
                break;
            }
            a.scaleX = a.scaleY = o, a.setStyle({ verticalAlign: a.__verticalAlign || A, align: a.__align || d });
          }
        }, t;
      }(Ct), FM = function() {
        function n(t) {
          this.group = new Ct(), this._LineCtor = t || kM;
        }
        return n.prototype.updateData = function(t) {
          var e = this;
          this._progressiveEls = null;
          var i = this, r = i.group, a = i._lineData;
          i._lineData = t, a || r.removeAll();
          var o = k9(t);
          t.diff(a).add(function(s) {
            e._doAdd(t, s, o);
          }).update(function(s, l) {
            e._doUpdate(a, t, l, s, o);
          }).remove(function(s) {
            r.remove(a.getItemGraphicEl(s));
          }).execute();
        }, n.prototype.updateLayout = function() {
          var t = this._lineData;
          t && t.eachItemGraphicEl(function(e, i) {
            e.updateLayout(t, i);
          }, this);
        }, n.prototype.incrementalPrepareUpdate = function(t) {
          this._seriesScope = k9(t), this._lineData = null, this.group.removeAll();
        }, n.prototype.incrementalUpdate = function(t, e) {
          this._progressiveEls = [];
          function i(s) {
            !s.isGroup && !YBt(s) && (s.incremental = true, s.ensureState("emphasis").hoverLayer = true);
          }
          for (var r = t.start; r < t.end; r++) {
            var a = e.getItemLayout(r);
            if (QM(a)) {
              var o = new this._LineCtor(e, r, this._seriesScope);
              o.traverse(i), this.group.add(o), e.setItemGraphicEl(r, o), this._progressiveEls.push(o);
            }
          }
        }, n.prototype.remove = function() {
          this.group.removeAll();
        }, n.prototype.eachRendered = function(t) {
          tu(this._progressiveEls || this.group, t);
        }, n.prototype._doAdd = function(t, e, i) {
          var r = t.getItemLayout(e);
          if (QM(r)) {
            var a = new this._LineCtor(t, e, i);
            t.setItemGraphicEl(e, a), this.group.add(a);
          }
        }, n.prototype._doUpdate = function(t, e, i, r, a) {
          var o = t.getItemGraphicEl(i);
          if (!QM(e.getItemLayout(r))) {
            this.group.remove(o);
            return;
          }
          o ? o.updateData(e, r, a) : o = new this._LineCtor(e, r, a), e.setItemGraphicEl(r, o), this.group.add(o);
        }, n;
      }();
      function YBt(n) {
        return n.animators && n.animators.length > 0;
      }
      function k9(n) {
        var t = n.hostModel, e = t.getModel("emphasis");
        return { lineStyle: t.getModel("lineStyle").getLineStyle(), emphasisLineStyle: e.getModel(["lineStyle"]).getLineStyle(), blurLineStyle: t.getModel(["blur", "lineStyle"]).getLineStyle(), selectLineStyle: t.getModel(["select", "lineStyle"]).getLineStyle(), emphasisDisabled: e.get("disabled"), blurScope: e.get("blurScope"), focus: e.get("focus"), labelStatesModels: Xn(t) };
      }
      function F9(n) {
        return isNaN(n[0]) || isNaN(n[1]);
      }
      function QM(n) {
        return n && !F9(n[0]) && !F9(n[1]);
      }
      var OM = [], zM = [], GM = [], id = si, UM = ah, Q9 = Math.abs;
      function O9(n, t, e) {
        for (var i = n[0], r = n[1], a = n[2], o = 1 / 0, s, l = e * e, u = 0.1, h = 0.1; h <= 0.9; h += 0.1) {
          OM[0] = id(i[0], r[0], a[0], h), OM[1] = id(i[1], r[1], a[1], h);
          var c = Q9(UM(OM, t) - l);
          c < o && (o = c, s = h);
        }
        for (var f = 0; f < 32; f++) {
          var g = s + u;
          zM[0] = id(i[0], r[0], a[0], s), zM[1] = id(i[1], r[1], a[1], s), GM[0] = id(i[0], r[0], a[0], g), GM[1] = id(i[1], r[1], a[1], g);
          var c = UM(zM, t) - l;
          if (Q9(c) < 0.01) break;
          var d = UM(GM, t) - l;
          u /= 2, c < 0 ? d >= 0 ? s = s + u : s = s - u : d >= 0 ? s = s - u : s = s + u;
        }
        return s;
      }
      function VM(n, t) {
        var e = [], i = vp, r = [[], [], []], a = [[], []], o = [];
        t /= 2, n.eachEdge(function(s, l) {
          var u = s.getLayout(), h = s.getVisual("fromSymbol"), c = s.getVisual("toSymbol");
          u.__original || (u.__original = [ws(u[0]), ws(u[1])], u[2] && u.__original.push(ws(u[2])));
          var f = u.__original;
          if (u[2] != null) {
            if (Vi(r[0], f[0]), Vi(r[1], f[2]), Vi(r[2], f[1]), h && h !== "none") {
              var g = Yv(s.node1), d = O9(r, f[0], g * t);
              i(r[0][0], r[1][0], r[2][0], d, e), r[0][0] = e[3], r[1][0] = e[4], i(r[0][1], r[1][1], r[2][1], d, e), r[0][1] = e[3], r[1][1] = e[4];
            }
            if (c && c !== "none") {
              var g = Yv(s.node2), d = O9(r, f[1], g * t);
              i(r[0][0], r[1][0], r[2][0], d, e), r[1][0] = e[1], r[2][0] = e[2], i(r[0][1], r[1][1], r[2][1], d, e), r[1][1] = e[1], r[2][1] = e[2];
            }
            Vi(u[0], r[0]), Vi(u[1], r[2]), Vi(u[2], r[1]);
          } else {
            if (Vi(a[0], f[0]), Vi(a[1], f[1]), rh(o, a[1], a[0]), og(o, o), h && h !== "none") {
              var g = Yv(s.node1);
              pb(a[0], a[0], o, g * t);
            }
            if (c && c !== "none") {
              var g = Yv(s.node2);
              pb(a[1], a[1], o, -g * t);
            }
            Vi(u[0], a[0]), Vi(u[1], a[1]);
          }
        });
      }
      function z9(n) {
        return n.type === "view";
      }
      var WBt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e, i) {
          var r = new Sv(), a = new FM(), o = this.group;
          this._controller = new Pv(i.getZr()), this._controllerHost = { target: o }, o.add(r.group), o.add(a.group), this._symbolDraw = r, this._lineDraw = a, this._firstRender = true;
        }, t.prototype.render = function(e, i, r) {
          var a = this, o = e.coordinateSystem;
          this._model = e;
          var s = this._symbolDraw, l = this._lineDraw, u = this.group;
          if (z9(o)) {
            var h = { x: o.x, y: o.y, scaleX: o.scaleX, scaleY: o.scaleY };
            this._firstRender ? u.attr(h) : _e(u, h, e);
          }
          VM(e.getGraph(), Hv(e));
          var c = e.getData();
          s.updateData(c);
          var f = e.getEdgeData();
          l.updateData(f), this._updateNodeAndLinkScale(), this._updateController(e, i, r), clearTimeout(this._layoutTimeout);
          var g = e.forceLayout, d = e.get(["force", "layoutAnimation"]);
          g && this._startForceLayoutIteration(g, d);
          var A = e.get("layout");
          c.graph.eachNode(function(m) {
            var _ = m.dataIndex, E = m.getGraphicEl(), I = m.getModel();
            if (E) {
              E.off("drag").off("dragend");
              var x = I.get("draggable");
              x && E.on("drag", function(C) {
                switch (A) {
                  case "force":
                    g.warmUp(), !a._layouting && a._startForceLayoutIteration(g, d), g.setFixed(_), c.setItemLayout(_, [E.x, E.y]);
                    break;
                  case "circular":
                    c.setItemLayout(_, [E.x, E.y]), m.setLayout({ fixed: true }, true), DM(e, "symbolSize", m, [C.offsetX, C.offsetY]), a.updateLayout(e);
                    break;
                  case "none":
                  default:
                    c.setItemLayout(_, [E.x, E.y]), TM(e.getGraph(), e), a.updateLayout(e);
                    break;
                }
              }).on("dragend", function() {
                g && g.setUnfixed(_);
              }), E.setDraggable(x, !!I.get("cursor"));
              var w = I.get(["emphasis", "focus"]);
              w === "adjacency" && (Dt(E).focus = m.getAdjacentDataIndices());
            }
          }), c.graph.eachEdge(function(m) {
            var _ = m.getGraphicEl(), E = m.getModel().get(["emphasis", "focus"]);
            _ && E === "adjacency" && (Dt(_).focus = { edge: [m.dataIndex], node: [m.node1.dataIndex, m.node2.dataIndex] });
          });
          var p = e.get("layout") === "circular" && e.get(["circular", "rotateLabel"]), v = c.getLayout("cx"), y = c.getLayout("cy");
          c.graph.eachNode(function(m) {
            M9(m, p, v, y);
          }), this._firstRender = false;
        }, t.prototype.dispose = function() {
          this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null;
        }, t.prototype._startForceLayoutIteration = function(e, i) {
          var r = this;
          (function a() {
            e.step(function(o) {
              r.updateLayout(r._model), (r._layouting = !o) && (i ? r._layoutTimeout = setTimeout(a, 16) : a());
            });
          })();
        }, t.prototype._updateController = function(e, i, r) {
          var a = this, o = this._controller, s = this._controllerHost, l = this.group;
          if (o.setPointerChecker(function(u, h, c) {
            var f = l.getBoundingRect();
            return f.applyTransform(l.transform), f.contain(h, c) && !II(u, r, e);
          }), !z9(e.coordinateSystem)) {
            o.disable();
            return;
          }
          o.enable(e.get("roam")), s.zoomLimit = e.get("scaleLimit"), s.zoom = e.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(u) {
            rM(s, u.dx, u.dy), r.dispatchAction({ seriesId: e.id, type: "graphRoam", dx: u.dx, dy: u.dy });
          }).on("zoom", function(u) {
            aM(s, u.scale, u.originX, u.originY), r.dispatchAction({ seriesId: e.id, type: "graphRoam", zoom: u.scale, originX: u.originX, originY: u.originY }), a._updateNodeAndLinkScale(), VM(e.getGraph(), Hv(e)), a._lineDraw.updateLayout(), r.updateLabelLayout();
          });
        }, t.prototype._updateNodeAndLinkScale = function() {
          var e = this._model, i = e.getData(), r = Hv(e);
          i.eachItemGraphicEl(function(a, o) {
            a && a.setSymbolScale(r);
          });
        }, t.prototype.updateLayout = function(e) {
          VM(e.getGraph(), Hv(e)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
        }, t.prototype.remove = function() {
          clearTimeout(this._layoutTimeout), this._layouting = false, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
        }, t.type = "graph", t;
      }(Ve);
      function rd(n) {
        return "_EC_" + n;
      }
      var XBt = function() {
        function n(t) {
          this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = t || false;
        }
        return n.prototype.isDirected = function() {
          return this._directed;
        }, n.prototype.addNode = function(t, e) {
          t = t == null ? "" + e : "" + t;
          var i = this._nodesMap;
          if (i[rd(t)]) {
            return;
          }
          var r = new sc(t, e);
          return r.hostGraph = this, this.nodes.push(r), i[rd(t)] = r, r;
        }, n.prototype.getNodeByIndex = function(t) {
          var e = this.data.getRawIndex(t);
          return this.nodes[e];
        }, n.prototype.getNodeById = function(t) {
          return this._nodesMap[rd(t)];
        }, n.prototype.addEdge = function(t, e, i) {
          var r = this._nodesMap, a = this._edgesMap;
          if (pe(t) && (t = this.nodes[t]), pe(e) && (e = this.nodes[e]), t instanceof sc || (t = r[rd(t)]), e instanceof sc || (e = r[rd(e)]), !(!t || !e)) {
            var o = t.id + "-" + e.id, s = new G9(t, e, i);
            return s.hostGraph = this, this._directed && (t.outEdges.push(s), e.inEdges.push(s)), t.edges.push(s), t !== e && e.edges.push(s), this.edges.push(s), a[o] = s, s;
          }
        }, n.prototype.getEdgeByIndex = function(t) {
          var e = this.edgeData.getRawIndex(t);
          return this.edges[e];
        }, n.prototype.getEdge = function(t, e) {
          t instanceof sc && (t = t.id), e instanceof sc && (e = e.id);
          var i = this._edgesMap;
          return this._directed ? i[t + "-" + e] : i[t + "-" + e] || i[e + "-" + t];
        }, n.prototype.eachNode = function(t, e) {
          for (var i = this.nodes, r = i.length, a = 0; a < r; a++) i[a].dataIndex >= 0 && t.call(e, i[a], a);
        }, n.prototype.eachEdge = function(t, e) {
          for (var i = this.edges, r = i.length, a = 0; a < r; a++) i[a].dataIndex >= 0 && i[a].node1.dataIndex >= 0 && i[a].node2.dataIndex >= 0 && t.call(e, i[a], a);
        }, n.prototype.breadthFirstTraverse = function(t, e, i, r) {
          if (e instanceof sc || (e = this._nodesMap[rd(e)]), !!e) {
            for (var a = i === "out" ? "outEdges" : i === "in" ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++) this.nodes[o].__visited = false;
            if (!t.call(r, e, null)) for (var s = [e]; s.length; ) for (var l = s.shift(), u = l[a], o = 0; o < u.length; o++) {
              var h = u[o], c = h.node1 === l ? h.node2 : h.node1;
              if (!c.__visited) {
                if (t.call(r, c, l)) return;
                s.push(c), c.__visited = true;
              }
            }
          }
        }, n.prototype.update = function() {
          for (var t = this.data, e = this.edgeData, i = this.nodes, r = this.edges, a = 0, o = i.length; a < o; a++) i[a].dataIndex = -1;
          for (var a = 0, o = t.count(); a < o; a++) i[t.getRawIndex(a)].dataIndex = a;
          e.filterSelf(function(s) {
            var l = r[e.getRawIndex(s)];
            return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
          });
          for (var a = 0, o = r.length; a < o; a++) r[a].dataIndex = -1;
          for (var a = 0, o = e.count(); a < o; a++) r[e.getRawIndex(a)].dataIndex = a;
        }, n.prototype.clone = function() {
          for (var t = new n(this._directed), e = this.nodes, i = this.edges, r = 0; r < e.length; r++) t.addNode(e[r].id, e[r].dataIndex);
          for (var r = 0; r < i.length; r++) {
            var a = i[r];
            t.addEdge(a.node1.id, a.node2.id, a.dataIndex);
          }
          return t;
        }, n;
      }(), sc = function() {
        function n(t, e) {
          this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = t == null ? "" : t, this.dataIndex = e == null ? -1 : e;
        }
        return n.prototype.degree = function() {
          return this.edges.length;
        }, n.prototype.inDegree = function() {
          return this.inEdges.length;
        }, n.prototype.outDegree = function() {
          return this.outEdges.length;
        }, n.prototype.getModel = function(t) {
          if (!(this.dataIndex < 0)) {
            var e = this.hostGraph, i = e.data.getItemModel(this.dataIndex);
            return i.getModel(t);
          }
        }, n.prototype.getAdjacentDataIndices = function() {
          for (var t = { edge: [], node: [] }, e = 0; e < this.edges.length; e++) {
            var i = this.edges[e];
            i.dataIndex < 0 || (t.edge.push(i.dataIndex), t.node.push(i.node1.dataIndex, i.node2.dataIndex));
          }
          return t;
        }, n.prototype.getTrajectoryDataIndices = function() {
          for (var t = dt(), e = dt(), i = 0; i < this.edges.length; i++) {
            var r = this.edges[i];
            if (!(r.dataIndex < 0)) {
              t.set(r.dataIndex, true);
              for (var a = [r.node1], o = [r.node2], s = 0; s < a.length; ) {
                var l = a[s];
                s++, e.set(l.dataIndex, true);
                for (var u = 0; u < l.inEdges.length; u++) t.set(l.inEdges[u].dataIndex, true), a.push(l.inEdges[u].node1);
              }
              for (s = 0; s < o.length; ) {
                var h = o[s];
                s++, e.set(h.dataIndex, true);
                for (var u = 0; u < h.outEdges.length; u++) t.set(h.outEdges[u].dataIndex, true), o.push(h.outEdges[u].node2);
              }
            }
          }
          return { edge: t.keys(), node: e.keys() };
        }, n;
      }(), G9 = function() {
        function n(t, e, i) {
          this.dataIndex = -1, this.node1 = t, this.node2 = e, this.dataIndex = i == null ? -1 : i;
        }
        return n.prototype.getModel = function(t) {
          if (!(this.dataIndex < 0)) {
            var e = this.hostGraph, i = e.edgeData.getItemModel(this.dataIndex);
            return i.getModel(t);
          }
        }, n.prototype.getAdjacentDataIndices = function() {
          return { edge: [this.dataIndex], node: [this.node1.dataIndex, this.node2.dataIndex] };
        }, n.prototype.getTrajectoryDataIndices = function() {
          var t = dt(), e = dt();
          t.set(this.dataIndex, true);
          for (var i = [this.node1], r = [this.node2], a = 0; a < i.length; ) {
            var o = i[a];
            a++, e.set(o.dataIndex, true);
            for (var s = 0; s < o.inEdges.length; s++) t.set(o.inEdges[s].dataIndex, true), i.push(o.inEdges[s].node1);
          }
          for (a = 0; a < r.length; ) {
            var l = r[a];
            a++, e.set(l.dataIndex, true);
            for (var s = 0; s < l.outEdges.length; s++) t.set(l.outEdges[s].dataIndex, true), r.push(l.outEdges[s].node2);
          }
          return { edge: t.keys(), node: e.keys() };
        }, n;
      }();
      function U9(n, t) {
        return { getValue: function(e) {
          var i = this[n][t];
          return i.getStore().get(i.getDimensionIndex(e || "value"), this.dataIndex);
        }, setVisual: function(e, i) {
          this.dataIndex >= 0 && this[n][t].setItemVisual(this.dataIndex, e, i);
        }, getVisual: function(e) {
          return this[n][t].getItemVisual(this.dataIndex, e);
        }, setLayout: function(e, i) {
          this.dataIndex >= 0 && this[n][t].setItemLayout(this.dataIndex, e, i);
        }, getLayout: function() {
          return this[n][t].getItemLayout(this.dataIndex);
        }, getGraphicEl: function() {
          return this[n][t].getItemGraphicEl(this.dataIndex);
        }, getRawIndex: function() {
          return this[n][t].getRawIndex(this.dataIndex);
        } };
      }
      Mn(sc, U9("hostGraph", "data")), Mn(G9, U9("hostGraph", "edgeData"));
      function V9(n, t, e, i, r) {
        for (var a = new XBt(i), o = 0; o < n.length; o++) a.addNode(Dn(n[o].id, n[o].name, o), o);
        for (var s = [], l = [], u = 0, o = 0; o < t.length; o++) {
          var h = t[o], c = h.source, f = h.target;
          a.addEdge(c, f, u) && (l.push(h), s.push(Dn(zn(h.id, null), c + " > " + f)), u++);
        }
        var g = e.get("coordinateSystem"), d;
        if (g === "cartesian2d" || g === "polar") d = zs(n, e);
        else {
          var A = Fg.get(g), p = A ? A.dimensions || [] : [];
          Wt(p, "value") < 0 && p.concat(["value"]);
          var v = vv(n, { coordDimensions: p, encodeDefine: e.getEncode() }).dimensions;
          d = new Zi(v, e), d.initData(n);
        }
        var y = new Zi(["value"], e);
        return y.initData(l, s), r && r(d, y), i9({ mainData: d, struct: a, structAttr: "graph", datas: { node: d, edge: y }, datasAttr: { node: "data", edge: "edgeData" } }), a.update(), a;
      }
      var ZBt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.hasSymbolVisual = true, e;
        }
        return t.prototype.init = function(e) {
          n.prototype.init.apply(this, arguments);
          var i = this;
          function r() {
            return i._categoriesData;
          }
          this.legendVisualProvider = new Dv(r, r), this.fillDataTextStyle(e.edges || e.links), this._updateCategoriesData();
        }, t.prototype.mergeOption = function(e) {
          n.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(e.edges || e.links), this._updateCategoriesData();
        }, t.prototype.mergeDefaultAndTheme = function(e) {
          n.prototype.mergeDefaultAndTheme.apply(this, arguments), dh(e, "edgeLabel", ["show"]);
        }, t.prototype.getInitialData = function(e, i) {
          var r = e.edges || e.links || [], a = e.data || e.nodes || [], o = this;
          if (a && r) {
            kBt(this);
            var s = V9(a, r, this, true, l);
            return M(s.edges, function(u) {
              FBt(u.node1, u.node2, this, u.dataIndex);
            }, this), s.data;
          }
          function l(u, h) {
            u.wrapMethod("getItemModel", function(d) {
              var A = o._categoriesModels, p = d.getShallow("category"), v = A[p];
              return v && (v.parentModel = d.parentModel, d.parentModel = v), d;
            });
            var c = Te.prototype.getModel;
            function f(d, A) {
              var p = c.call(this, d, A);
              return p.resolveParentPath = g, p;
            }
            h.wrapMethod("getItemModel", function(d) {
              return d.resolveParentPath = g, d.getModel = f, d;
            });
            function g(d) {
              if (d && (d[0] === "label" || d[1] === "label")) {
                var A = d.slice();
                return d[0] === "label" ? A[0] = "edgeLabel" : d[1] === "label" && (A[1] = "edgeLabel"), A;
              }
              return d;
            }
          }
        }, t.prototype.getGraph = function() {
          return this.getData().graph;
        }, t.prototype.getEdgeData = function() {
          return this.getGraph().edgeData;
        }, t.prototype.getCategoriesData = function() {
          return this._categoriesData;
        }, t.prototype.formatTooltip = function(e, i, r) {
          if (r === "edge") {
            var a = this.getData(), o = this.getDataParams(e, r), s = a.graph.getEdgeByIndex(e), l = a.getName(s.node1.dataIndex), u = a.getName(s.node2.dataIndex), h = [];
            return l != null && h.push(l), u != null && h.push(u), Zn("nameValue", { name: h.join(" > "), value: o.value, noValue: o.value == null });
          }
          var c = L8({ series: this, dataIndex: e, multipleSeries: i });
          return c;
        }, t.prototype._updateCategoriesData = function() {
          var e = Z(this.option.categories || [], function(r) {
            return r.value != null ? r : Y({ value: 0 }, r);
          }), i = new Zi(["value"], this);
          i.initData(e), this._categoriesData = i, this._categoriesModels = i.mapArray(function(r) {
            return i.getItemModel(r);
          });
        }, t.prototype.setZoom = function(e) {
          this.option.zoom = e;
        }, t.prototype.setCenter = function(e) {
          this.option.center = e;
        }, t.prototype.isAnimationEnabled = function() {
          return n.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
        }, t.type = "series.graph", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], t.defaultOption = { z: 2, coordinateSystem: "view", legendHoverLink: true, layout: null, circular: { rotateLabel: false }, force: { initLayout: null, repulsion: [0, 50], gravity: 0.1, friction: 0.6, edgeLength: 30, layoutAnimation: true }, left: "center", top: "center", symbol: "circle", symbolSize: 10, edgeSymbol: ["none", "none"], edgeSymbolSize: 10, edgeLabel: { position: "middle", distance: 5 }, draggable: false, roam: false, center: null, zoom: 1, nodeScaleRatio: 0.6, label: { show: false, formatter: "{b}" }, itemStyle: {}, lineStyle: { color: "#aaa", width: 1, opacity: 0.5 }, emphasis: { scale: true, label: { show: true } }, select: { itemStyle: { borderColor: "#212121" } } }, t;
      }($e), KBt = { type: "graphRoam", event: "graphRoam", update: "none" };
      function $Bt(n) {
        n.registerChartView(WBt), n.registerSeriesModel(ZBt), n.registerProcessor(DBt), n.registerVisual(RBt), n.registerVisual(LBt), n.registerLayout(QBt), n.registerLayout(n.PRIORITY.VISUAL.POST_CHART_LAYOUT, zBt), n.registerLayout(UBt), n.registerCoordinateSystem("graphView", { dimensions: kv.dimensions, create: jBt }), n.registerAction({ type: "focusNodeAdjacency", event: "focusNodeAdjacency", update: "series:focusNodeAdjacency" }, In), n.registerAction({ type: "unfocusNodeAdjacency", event: "unfocusNodeAdjacency", update: "series:unfocusNodeAdjacency" }, In), n.registerAction(KBt, function(t, e, i) {
          e.eachComponent({ mainType: "series", query: t }, function(r) {
            var a = r.coordinateSystem, o = cM(a, t, void 0, i);
            r.setCenter && r.setCenter(o.center), r.setZoom && r.setZoom(o.zoom);
          });
        });
      }
      var JBt = /* @__PURE__ */ function() {
        function n() {
          this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
        }
        return n;
      }(), tTt = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "pointer", i;
        }
        return t.prototype.getDefaultShape = function() {
          return new JBt();
        }, t.prototype.buildPath = function(e, i) {
          var r = Math.cos, a = Math.sin, o = i.r, s = i.width, l = i.angle, u = i.x - r(l) * s * (s >= o / 3 ? 1 : 2), h = i.y - a(l) * s * (s >= o / 3 ? 1 : 2);
          l = i.angle - Math.PI / 2, e.moveTo(u, h), e.lineTo(i.x + r(l) * s, i.y + a(l) * s), e.lineTo(i.x + r(i.angle) * o, i.y + a(i.angle) * o), e.lineTo(i.x - r(l) * s, i.y - a(l) * s), e.lineTo(u, h);
        }, t;
      }(Jt);
      function eTt(n, t) {
        var e = n.get("center"), i = t.getWidth(), r = t.getHeight(), a = Math.min(i, r), o = ot(e[0], t.getWidth()), s = ot(e[1], t.getHeight()), l = ot(n.get("radius"), a / 2);
        return { cx: o, cy: s, r: l };
      }
      function PI(n, t) {
        var e = n == null ? "" : n + "";
        return t && (ht(t) ? e = t.replace("{value}", e) : yt(t) && (e = t(n))), e;
      }
      var nTt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          this.group.removeAll();
          var a = e.get(["axisLine", "lineStyle", "color"]), o = eTt(e, r);
          this._renderMain(e, i, r, a, o), this._data = e.getData();
        }, t.prototype.dispose = function() {
        }, t.prototype._renderMain = function(e, i, r, a, o) {
          var s = this.group, l = e.get("clockwise"), u = -e.get("startAngle") / 180 * Math.PI, h = -e.get("endAngle") / 180 * Math.PI, c = e.getModel("axisLine"), f = c.get("roundCap"), g = f ? dI : Hi, d = c.get("show"), A = c.getModel("lineStyle"), p = A.get("width"), v = [u, h];
          R2(v, !l), u = v[0], h = v[1];
          for (var y = h - u, m = u, _ = [], E = 0; d && E < a.length; E++) {
            var I = Math.min(Math.max(a[E][0], 0), 1);
            h = u + y * I;
            var x = new g({ shape: { startAngle: m, endAngle: h, cx: o.cx, cy: o.cy, clockwise: l, r0: o.r - p, r: o.r }, silent: true });
            x.setStyle({ fill: a[E][1] }), x.setStyle(A.getLineStyle(["color", "width"])), _.push(x), m = h;
          }
          _.reverse(), M(_, function(C) {
            return s.add(C);
          });
          var w = function(C) {
            if (C <= 0) return a[0][1];
            var S;
            for (S = 0; S < a.length; S++) if (a[S][0] >= C && (S === 0 ? 0 : a[S - 1][0]) < C) return a[S][1];
            return a[S - 1][1];
          };
          this._renderTicks(e, i, r, w, o, u, h, l, p), this._renderTitleAndDetail(e, i, r, w, o), this._renderAnchor(e, o), this._renderPointer(e, i, r, w, o, u, h, l, p);
        }, t.prototype._renderTicks = function(e, i, r, a, o, s, l, u, h) {
          for (var c = this.group, f = o.cx, g = o.cy, d = o.r, A = +e.get("min"), p = +e.get("max"), v = e.getModel("splitLine"), y = e.getModel("axisTick"), m = e.getModel("axisLabel"), _ = e.get("splitNumber"), E = y.get("splitNumber"), I = ot(v.get("length"), d), x = ot(y.get("length"), d), w = s, C = (l - s) / _, S = C / E, b = v.getModel("lineStyle").getLineStyle(), B = y.getModel("lineStyle").getLineStyle(), T = v.get("distance"), D, R, L = 0; L <= _; L++) {
            if (D = Math.cos(w), R = Math.sin(w), v.get("show")) {
              var k = T ? T + h : h, P = new Wn({ shape: { x1: D * (d - k) + f, y1: R * (d - k) + g, x2: D * (d - I - k) + f, y2: R * (d - I - k) + g }, style: b, silent: true });
              b.stroke === "auto" && P.setStyle({ stroke: a(L / _) }), c.add(P);
            }
            if (m.get("show")) {
              var k = m.get("distance") + T, F = PI(vn(L / _ * (p - A) + A), m.get("formatter")), Q = a(L / _), z = D * (d - I - k) + f, j = R * (d - I - k) + g, $ = m.get("rotate"), G = 0;
              $ === "radial" ? (G = -w + 2 * Math.PI, G > Math.PI / 2 && (G += Math.PI)) : $ === "tangential" ? G = -w - Math.PI / 2 : pe($) && (G = $ * Math.PI / 180), G === 0 ? c.add(new ge({ style: Ke(m, { text: F, x: z, y: j, verticalAlign: R < -0.8 ? "top" : R > 0.8 ? "bottom" : "middle", align: D < -0.4 ? "left" : D > 0.4 ? "right" : "center" }, { inheritColor: Q }), silent: true })) : c.add(new ge({ style: Ke(m, { text: F, x: z, y: j, verticalAlign: "middle", align: "center" }, { inheritColor: Q }), silent: true, originX: z, originY: j, rotation: G }));
            }
            if (y.get("show") && L !== _) {
              var k = y.get("distance");
              k = k ? k + h : h;
              for (var tt = 0; tt <= E; tt++) {
                D = Math.cos(w), R = Math.sin(w);
                var J = new Wn({ shape: { x1: D * (d - k) + f, y1: R * (d - k) + g, x2: D * (d - x - k) + f, y2: R * (d - x - k) + g }, silent: true, style: B });
                B.stroke === "auto" && J.setStyle({ stroke: a((L + tt / E) / _) }), c.add(J), w += S;
              }
              w -= S;
            } else w += C;
          }
        }, t.prototype._renderPointer = function(e, i, r, a, o, s, l, u, h) {
          var c = this.group, f = this._data, g = this._progressEls, d = [], A = e.get(["pointer", "show"]), p = e.getModel("progress"), v = p.get("show"), y = e.getData(), m = y.mapDimension("value"), _ = +e.get("min"), E = +e.get("max"), I = [_, E], x = [s, l];
          function w(S, b) {
            var B = y.getItemModel(S), T = B.getModel("pointer"), D = ot(T.get("width"), o.r), R = ot(T.get("length"), o.r), L = e.get(["pointer", "icon"]), k = T.get("offsetCenter"), P = ot(k[0], o.r), F = ot(k[1], o.r), Q = T.get("keepAspect"), z;
            return L ? z = Nn(L, P - D / 2, F - R, D, R, null, Q) : z = new tTt({ shape: { angle: -Math.PI / 2, width: D, r: R, x: P, y: F } }), z.rotation = -(b + Math.PI / 2), z.x = o.cx, z.y = o.cy, z;
          }
          function C(S, b) {
            var B = p.get("roundCap"), T = B ? dI : Hi, D = p.get("overlap"), R = D ? p.get("width") : h / y.count(), L = D ? o.r - R : o.r - (S + 1) * R, k = D ? o.r : o.r - S * R, P = new T({ shape: { startAngle: s, endAngle: b, cx: o.cx, cy: o.cy, clockwise: u, r0: L, r: k } });
            return D && (P.z2 = E - y.get(m, S) % E), P;
          }
          (v || A) && (y.diff(f).add(function(S) {
            var b = y.get(m, S);
            if (A) {
              var B = w(S, s);
              nn(B, { rotation: -((isNaN(+b) ? x[0] : Le(b, I, x, true)) + Math.PI / 2) }, e), c.add(B), y.setItemGraphicEl(S, B);
            }
            if (v) {
              var T = C(S, s), D = p.get("clip");
              nn(T, { shape: { endAngle: Le(b, I, x, D) } }, e), c.add(T), N2(e.seriesIndex, y.dataType, S, T), d[S] = T;
            }
          }).update(function(S, b) {
            var B = y.get(m, S);
            if (A) {
              var T = f.getItemGraphicEl(b), D = T ? T.rotation : s, R = w(S, D);
              R.rotation = D, _e(R, { rotation: -((isNaN(+B) ? x[0] : Le(B, I, x, true)) + Math.PI / 2) }, e), c.add(R), y.setItemGraphicEl(S, R);
            }
            if (v) {
              var L = g[b], k = L ? L.shape.endAngle : s, P = C(S, k), F = p.get("clip");
              _e(P, { shape: { endAngle: Le(B, I, x, F) } }, e), c.add(P), N2(e.seriesIndex, y.dataType, S, P), d[S] = P;
            }
          }).execute(), y.each(function(S) {
            var b = y.getItemModel(S), B = b.getModel("emphasis"), T = B.get("focus"), D = B.get("blurScope"), R = B.get("disabled");
            if (A) {
              var L = y.getItemGraphicEl(S), k = y.getItemVisual(S, "style"), P = k.fill;
              if (L instanceof li) {
                var F = L.style;
                L.useStyle(Y({ image: F.image, x: F.x, y: F.y, width: F.width, height: F.height }, k));
              } else L.useStyle(k), L.type !== "pointer" && L.setColor(P);
              L.setStyle(b.getModel(["pointer", "itemStyle"]).getItemStyle()), L.style.fill === "auto" && L.setStyle("fill", a(Le(y.get(m, S), I, [0, 1], true))), L.z2EmphasisLift = 0, pi(L, b), hn(L, T, D, R);
            }
            if (v) {
              var Q = d[S];
              Q.useStyle(y.getItemVisual(S, "style")), Q.setStyle(b.getModel(["progress", "itemStyle"]).getItemStyle()), Q.z2EmphasisLift = 0, pi(Q, b), hn(Q, T, D, R);
            }
          }), this._progressEls = d);
        }, t.prototype._renderAnchor = function(e, i) {
          var r = e.getModel("anchor"), a = r.get("show");
          if (a) {
            var o = r.get("size"), s = r.get("icon"), l = r.get("offsetCenter"), u = r.get("keepAspect"), h = Nn(s, i.cx - o / 2 + ot(l[0], i.r), i.cy - o / 2 + ot(l[1], i.r), o, o, null, u);
            h.z2 = r.get("showAbove") ? 1 : 0, h.setStyle(r.getModel("itemStyle").getItemStyle()), this.group.add(h);
          }
        }, t.prototype._renderTitleAndDetail = function(e, i, r, a, o) {
          var s = this, l = e.getData(), u = l.mapDimension("value"), h = +e.get("min"), c = +e.get("max"), f = new Ct(), g = [], d = [], A = e.isAnimationEnabled(), p = e.get(["pointer", "showAbove"]);
          l.diff(this._data).add(function(v) {
            g[v] = new ge({ silent: true }), d[v] = new ge({ silent: true });
          }).update(function(v, y) {
            g[v] = s._titleEls[y], d[v] = s._detailEls[y];
          }).execute(), l.each(function(v) {
            var y = l.getItemModel(v), m = l.get(u, v), _ = new Ct(), E = a(Le(m, [h, c], [0, 1], true)), I = y.getModel("title");
            if (I.get("show")) {
              var x = I.get("offsetCenter"), w = o.cx + ot(x[0], o.r), C = o.cy + ot(x[1], o.r), S = g[v];
              S.attr({ z2: p ? 0 : 2, style: Ke(I, { x: w, y: C, text: l.getName(v), align: "center", verticalAlign: "middle" }, { inheritColor: E }) }), _.add(S);
            }
            var b = y.getModel("detail");
            if (b.get("show")) {
              var B = b.get("offsetCenter"), T = o.cx + ot(B[0], o.r), D = o.cy + ot(B[1], o.r), R = ot(b.get("width"), o.r), L = ot(b.get("height"), o.r), k = e.get(["progress", "show"]) ? l.getItemVisual(v, "style").fill : E, S = d[v], P = b.get("formatter");
              S.attr({ z2: p ? 0 : 2, style: Ke(b, { x: T, y: D, text: PI(m, P), width: isNaN(R) ? null : R, height: isNaN(L) ? null : L, align: "center", verticalAlign: "middle" }, { inheritColor: k }) }), h4(S, { normal: b }, m, function(Q) {
                return PI(Q, P);
              }), A && c4(S, v, l, e, { getFormattedLabel: function(Q, z, j, $, G, tt) {
                return PI(tt ? tt.interpolatedValue : m, P);
              } }), _.add(S);
            }
            f.add(_);
          }), this.group.add(f), this._titleEls = g, this._detailEls = d;
        }, t.type = "gauge", t;
      }(Ve), iTt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.visualStyleAccessPath = "itemStyle", e;
        }
        return t.prototype.getInitialData = function(e, i) {
          return Jg(this, ["value"]);
        }, t.type = "series.gauge", t.defaultOption = { z: 2, colorBy: "data", center: ["50%", "50%"], legendHoverLink: true, radius: "75%", startAngle: 225, endAngle: -45, clockwise: true, min: 0, max: 100, splitNumber: 10, axisLine: { show: true, roundCap: false, lineStyle: { color: [[1, "#E6EBF8"]], width: 10 } }, progress: { show: false, overlap: true, width: 10, roundCap: false, clip: true }, splitLine: { show: true, length: 10, distance: 10, lineStyle: { color: "#63677A", width: 3, type: "solid" } }, axisTick: { show: true, splitNumber: 5, length: 6, distance: 10, lineStyle: { color: "#63677A", width: 1, type: "solid" } }, axisLabel: { show: true, distance: 15, color: "#464646", fontSize: 12, rotate: 0 }, pointer: { icon: null, offsetCenter: [0, 0], show: true, showAbove: true, length: "60%", width: 6, keepAspect: false }, anchor: { show: false, showAbove: false, size: 6, icon: "circle", offsetCenter: [0, 0], keepAspect: false, itemStyle: { color: "#fff", borderWidth: 0, borderColor: "#5470c6" } }, title: { show: true, offsetCenter: [0, "20%"], color: "#464646", fontSize: 16, valueAnimation: false }, detail: { show: true, backgroundColor: "rgba(0,0,0,0)", borderWidth: 0, borderColor: "#ccc", width: 100, height: null, padding: [5, 10], offsetCenter: [0, "40%"], color: "#464646", fontSize: 30, fontWeight: "bold", lineHeight: 30, valueAnimation: false } }, t;
      }($e);
      function rTt(n) {
        n.registerChartView(nTt), n.registerSeriesModel(iTt);
      }
      var aTt = ["itemStyle", "opacity"], oTt = function(n) {
        V(t, n);
        function t(e, i) {
          var r = n.call(this) || this, a = r, o = new Wi(), s = new ge();
          return a.setTextContent(s), r.setTextGuideLine(o), r.updateData(e, i, true), r;
        }
        return t.prototype.updateData = function(e, i, r) {
          var a = this, o = e.hostModel, s = e.getItemModel(i), l = e.getItemLayout(i), u = s.getModel("emphasis"), h = s.get(aTt);
          h = h == null ? 1 : h, r || Ya(a), a.useStyle(e.getItemVisual(i, "style")), a.style.lineJoin = "round", r ? (a.setShape({ points: l.points }), a.style.opacity = 0, nn(a, { style: { opacity: h } }, o, i)) : _e(a, { style: { opacity: h }, shape: { points: l.points } }, o, i), pi(a, s), this._updateLabel(e, i), hn(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
        }, t.prototype._updateLabel = function(e, i) {
          var r = this, a = this.getTextGuideLine(), o = r.getTextContent(), s = e.hostModel, l = e.getItemModel(i), u = e.getItemLayout(i), h = u.label, c = e.getItemVisual(i, "style"), f = c.fill;
          vi(o, Xn(l), { labelFetcher: e.hostModel, labelDataIndex: i, defaultOpacity: c.opacity, defaultText: e.getName(i) }, { normal: { align: h.textAlign, verticalAlign: h.verticalAlign } }), r.setTextConfig({ local: true, inside: !!h.inside, insideStroke: f, outsideFill: f });
          var g = h.linePoints;
          a.setShape({ points: g }), r.textGuideLineConfig = { anchor: g ? new Ut(g[0][0], g[0][1]) : null }, _e(o, { style: { x: h.x, y: h.y } }, s, i), o.attr({ rotation: h.rotation, originX: h.x, originY: h.y, z2: 10 }), ET(r, xT(l), { stroke: f });
        }, t;
      }(Yi), sTt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.ignoreLabelLineUpdate = true, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = e.getData(), o = this._data, s = this.group;
          a.diff(o).add(function(l) {
            var u = new oTt(a, l);
            a.setItemGraphicEl(l, u), s.add(u);
          }).update(function(l, u) {
            var h = o.getItemGraphicEl(u);
            h.updateData(a, l), s.add(h), a.setItemGraphicEl(l, h);
          }).remove(function(l) {
            var u = o.getItemGraphicEl(l);
            jp(u, e, l);
          }).execute(), this._data = a;
        }, t.prototype.remove = function() {
          this.group.removeAll(), this._data = null;
        }, t.prototype.dispose = function() {
        }, t.type = "funnel", t;
      }(Ve), lTt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e) {
          n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Dv(ct(this.getData, this), ct(this.getRawData, this)), this._defaultLabelLine(e);
        }, t.prototype.getInitialData = function(e, i) {
          return Jg(this, { coordDimensions: ["value"], encodeDefaulter: Ot(pB, this) });
        }, t.prototype._defaultLabelLine = function(e) {
          dh(e, "labelLine", ["show"]);
          var i = e.labelLine, r = e.emphasis.labelLine;
          i.show = i.show && e.label.show, r.show = r.show && e.emphasis.label.show;
        }, t.prototype.getDataParams = function(e) {
          var i = this.getData(), r = n.prototype.getDataParams.call(this, e), a = i.mapDimension("value"), o = i.getSum(a);
          return r.percent = o ? +(i.get(a, e) / o * 100).toFixed(2) : 0, r.$vars.push("percent"), r;
        }, t.type = "series.funnel", t.defaultOption = { z: 2, legendHoverLink: true, colorBy: "data", left: 80, top: 60, right: 80, bottom: 60, minSize: "0%", maxSize: "100%", sort: "descending", orient: "vertical", gap: 0, funnelAlign: "center", label: { show: true, position: "outer" }, labelLine: { show: true, length: 20, lineStyle: { width: 1 } }, itemStyle: { borderColor: "#fff", borderWidth: 1 }, emphasis: { label: { show: true } }, select: { itemStyle: { borderColor: "#212121" } } }, t;
      }($e);
      function uTt(n, t) {
        return Gn(n.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() });
      }
      function hTt(n, t) {
        for (var e = n.mapDimension("value"), i = n.mapArray(e, function(l) {
          return l;
        }), r = [], a = t === "ascending", o = 0, s = n.count(); o < s; o++) r[o] = o;
        return yt(t) ? r.sort(t) : t !== "none" && r.sort(function(l, u) {
          return a ? i[l] - i[u] : i[u] - i[l];
        }), r;
      }
      function cTt(n) {
        var t = n.hostModel, e = t.get("orient");
        n.each(function(i) {
          var r = n.getItemModel(i), a = r.getModel("label"), o = a.get("position"), s = r.getModel("labelLine"), l = n.getItemLayout(i), u = l.points, h = o === "inner" || o === "inside" || o === "center" || o === "insideLeft" || o === "insideRight", c, f, g, d;
          if (h) o === "insideLeft" ? (f = (u[0][0] + u[3][0]) / 2 + 5, g = (u[0][1] + u[3][1]) / 2, c = "left") : o === "insideRight" ? (f = (u[1][0] + u[2][0]) / 2 - 5, g = (u[1][1] + u[2][1]) / 2, c = "right") : (f = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, g = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, c = "center"), d = [[f, g], [f, g]];
          else {
            var A = void 0, p = void 0, v = void 0, y = void 0, m = s.get("length");
            e === "vertical" && ["top", "bottom"].indexOf(o) > -1 && (o = "left"), e === "horizontal" && ["left", "right"].indexOf(o) > -1 && (o = "bottom"), o === "left" ? (A = (u[3][0] + u[0][0]) / 2, p = (u[3][1] + u[0][1]) / 2, v = A - m, f = v - 5, c = "right") : o === "right" ? (A = (u[1][0] + u[2][0]) / 2, p = (u[1][1] + u[2][1]) / 2, v = A + m, f = v + 5, c = "left") : o === "top" ? (A = (u[3][0] + u[0][0]) / 2, p = (u[3][1] + u[0][1]) / 2, y = p - m, g = y - 5, c = "center") : o === "bottom" ? (A = (u[1][0] + u[2][0]) / 2, p = (u[1][1] + u[2][1]) / 2, y = p + m, g = y + 5, c = "center") : o === "rightTop" ? (A = e === "horizontal" ? u[3][0] : u[1][0], p = e === "horizontal" ? u[3][1] : u[1][1], e === "horizontal" ? (y = p - m, g = y - 5, c = "center") : (v = A + m, f = v + 5, c = "top")) : o === "rightBottom" ? (A = u[2][0], p = u[2][1], e === "horizontal" ? (y = p + m, g = y + 5, c = "center") : (v = A + m, f = v + 5, c = "bottom")) : o === "leftTop" ? (A = u[0][0], p = e === "horizontal" ? u[0][1] : u[1][1], e === "horizontal" ? (y = p - m, g = y - 5, c = "center") : (v = A - m, f = v - 5, c = "right")) : o === "leftBottom" ? (A = e === "horizontal" ? u[1][0] : u[3][0], p = e === "horizontal" ? u[1][1] : u[2][1], e === "horizontal" ? (y = p + m, g = y + 5, c = "center") : (v = A - m, f = v - 5, c = "right")) : (A = (u[1][0] + u[2][0]) / 2, p = (u[1][1] + u[2][1]) / 2, e === "horizontal" ? (y = p + m, g = y + 5, c = "center") : (v = A + m, f = v + 5, c = "left")), e === "horizontal" ? (v = A, f = v) : (y = p, g = y), d = [[A, p], [v, y]];
          }
          l.label = { linePoints: d, x: f, y: g, verticalAlign: "middle", textAlign: c, inside: h };
        });
      }
      function fTt(n, t) {
        n.eachSeriesByType("funnel", function(e) {
          var i = e.getData(), r = i.mapDimension("value"), a = e.get("sort"), o = uTt(e, t), s = e.get("orient"), l = o.width, u = o.height, h = hTt(i, a), c = o.x, f = o.y, g = s === "horizontal" ? [ot(e.get("minSize"), u), ot(e.get("maxSize"), u)] : [ot(e.get("minSize"), l), ot(e.get("maxSize"), l)], d = i.getDataExtent(r), A = e.get("min"), p = e.get("max");
          A == null && (A = Math.min(d[0], 0)), p == null && (p = d[1]);
          var v = e.get("funnelAlign"), y = e.get("gap"), m = s === "horizontal" ? l : u, _ = (m - y * (i.count() - 1)) / i.count(), E = function(D, R) {
            if (s === "horizontal") {
              var L = i.get(r, D) || 0, k = Le(L, [A, p], g, true), P = void 0;
              switch (v) {
                case "top":
                  P = f;
                  break;
                case "center":
                  P = f + (u - k) / 2;
                  break;
                case "bottom":
                  P = f + (u - k);
                  break;
              }
              return [[R, P], [R, P + k]];
            }
            var F = i.get(r, D) || 0, Q = Le(F, [A, p], g, true), z;
            switch (v) {
              case "left":
                z = c;
                break;
              case "center":
                z = c + (l - Q) / 2;
                break;
              case "right":
                z = c + l - Q;
                break;
            }
            return [[z, R], [z + Q, R]];
          };
          a === "ascending" && (_ = -_, y = -y, s === "horizontal" ? c += l : f += u, h = h.reverse());
          for (var I = 0; I < h.length; I++) {
            var x = h[I], w = h[I + 1], C = i.getItemModel(x);
            if (s === "horizontal") {
              var S = C.get(["itemStyle", "width"]);
              S == null ? S = _ : (S = ot(S, l), a === "ascending" && (S = -S));
              var b = E(x, c), B = E(w, c + S);
              c += S + y, i.setItemLayout(x, { points: b.concat(B.slice().reverse()) });
            } else {
              var T = C.get(["itemStyle", "height"]);
              T == null ? T = _ : (T = ot(T, u), a === "ascending" && (T = -T));
              var b = E(x, f), B = E(w, f + T);
              f += T + y, i.setItemLayout(x, { points: b.concat(B.slice().reverse()) });
            }
          }
          cTt(i);
        });
      }
      function gTt(n) {
        n.registerChartView(sTt), n.registerSeriesModel(lTt), n.registerLayout(fTt), n.registerProcessor(Mv("funnel"));
      }
      var dTt = 0.3, ATt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._dataGroup = new Ct(), e._initialized = false, e;
        }
        return t.prototype.init = function() {
          this.group.add(this._dataGroup);
        }, t.prototype.render = function(e, i, r, a) {
          this._progressiveEls = null;
          var o = this._dataGroup, s = e.getData(), l = this._data, u = e.coordinateSystem, h = u.dimensions, c = H9(e);
          s.diff(l).add(f).update(g).remove(d).execute();
          function f(p) {
            var v = q9(s, o, p, h, u);
            jM(v, s, p, c);
          }
          function g(p, v) {
            var y = l.getItemGraphicEl(v), m = j9(s, p, h, u);
            s.setItemGraphicEl(p, y), _e(y, { shape: { points: m } }, e, p), Ya(y), jM(y, s, p, c);
          }
          function d(p) {
            var v = l.getItemGraphicEl(p);
            o.remove(v);
          }
          if (!this._initialized) {
            this._initialized = true;
            var A = pTt(u, e, function() {
              setTimeout(function() {
                o.removeClipPath();
              });
            });
            o.setClipPath(A);
          }
          this._data = s;
        }, t.prototype.incrementalPrepareRender = function(e, i, r) {
          this._initialized = true, this._data = null, this._dataGroup.removeAll();
        }, t.prototype.incrementalRender = function(e, i, r) {
          for (var a = i.getData(), o = i.coordinateSystem, s = o.dimensions, l = H9(i), u = this._progressiveEls = [], h = e.start; h < e.end; h++) {
            var c = q9(a, this._dataGroup, h, s, o);
            c.incremental = true, jM(c, a, h, l), u.push(c);
          }
        }, t.prototype.remove = function() {
          this._dataGroup && this._dataGroup.removeAll(), this._data = null;
        }, t.type = "parallel", t;
      }(Ve);
      function pTt(n, t, e) {
        var i = n.model, r = n.getRect(), a = new ue({ shape: { x: r.x, y: r.y, width: r.width, height: r.height } }), o = i.get("layout") === "horizontal" ? "width" : "height";
        return a.setShape(o, 0), nn(a, { shape: { width: r.width, height: r.height } }, t, e), a;
      }
      function j9(n, t, e, i) {
        for (var r = [], a = 0; a < e.length; a++) {
          var o = e[a], s = n.get(n.mapDimension(o), t);
          vTt(s, i.getAxis(o).type) || r.push(i.dataToPoint(s, o));
        }
        return r;
      }
      function q9(n, t, e, i, r) {
        var a = j9(n, e, i, r), o = new Wi({ shape: { points: a }, z2: 10 });
        return t.add(o), n.setItemGraphicEl(e, o), o;
      }
      function H9(n) {
        var t = n.get("smooth", true);
        return t === true && (t = dTt), t = Ms(t), nh(t) && (t = 0), { smooth: t };
      }
      function jM(n, t, e, i) {
        n.useStyle(t.getItemVisual(e, "style")), n.style.fill = null, n.setShape("smooth", i.smooth);
        var r = t.getItemModel(e), a = r.getModel("emphasis");
        pi(n, r, "lineStyle"), hn(n, a.get("focus"), a.get("blurScope"), a.get("disabled"));
      }
      function vTt(n, t) {
        return t === "category" ? n == null : n == null || isNaN(n);
      }
      var yTt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.visualStyleAccessPath = "lineStyle", e.visualDrawType = "stroke", e;
        }
        return t.prototype.getInitialData = function(e, i) {
          return zs(null, this, { useEncodeDefaulter: ct(mTt, null, this) });
        }, t.prototype.getRawIndicesByActiveState = function(e) {
          var i = this.coordinateSystem, r = this.getData(), a = [];
          return i.eachActiveState(r, function(o, s) {
            e === o && a.push(r.getRawIndex(s));
          }), a;
        }, t.type = "series.parallel", t.dependencies = ["parallel"], t.defaultOption = { z: 2, coordinateSystem: "parallel", parallelIndex: 0, label: { show: false }, inactiveOpacity: 0.05, activeOpacity: 1, lineStyle: { width: 1, opacity: 0.45, type: "solid" }, emphasis: { label: { show: false } }, progressive: 500, smooth: false, animationEasing: "linear" }, t;
      }($e);
      function mTt(n) {
        var t = n.ecModel.getComponent("parallel", n.get("parallelIndex"));
        if (t) {
          var e = {};
          return M(t.dimensions, function(i) {
            var r = _Tt(i);
            e[i] = r;
          }), e;
        }
      }
      function _Tt(n) {
        return +n.replace("dim", "");
      }
      var ITt = ["lineStyle", "opacity"], ETt = { seriesType: "parallel", reset: function(n, t) {
        var e = n.coordinateSystem, i = { normal: n.get(["lineStyle", "opacity"]), active: n.get("activeOpacity"), inactive: n.get("inactiveOpacity") };
        return { progress: function(r, a) {
          e.eachActiveState(a, function(o, s) {
            var l = i[o];
            if (o === "normal" && a.hasItemOption) {
              var u = a.getItemModel(s).get(ITt, true);
              u != null && (l = u);
            }
            var h = a.ensureUniqueItemVisual(s, "style");
            h.opacity = l;
          }, r.start, r.end);
        } };
      } };
      function xTt(n) {
        wTt(n), CTt(n);
      }
      function wTt(n) {
        if (!n.parallel) {
          var t = false;
          M(n.series, function(e) {
            e && e.type === "parallel" && (t = true);
          }), t && (n.parallel = [{}]);
        }
      }
      function CTt(n) {
        var t = Qe(n.parallelAxis);
        M(t, function(e) {
          if (_t(e)) {
            var i = e.parallelIndex || 0, r = Qe(n.parallel)[i];
            r && r.parallelAxisDefault && qt(e, r.parallelAxisDefault, false);
          }
        });
      }
      var STt = 5, bTt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          this._model = e, this._api = r, this._handlers || (this._handlers = {}, M(BTt, function(a, o) {
            r.getZr().on(o, this._handlers[o] = ct(a, this));
          }, this)), Gg(this, "_throttledDispatchExpand", e.get("axisExpandRate"), "fixRate");
        }, t.prototype.dispose = function(e, i) {
          av(this, "_throttledDispatchExpand"), M(this._handlers, function(r, a) {
            i.getZr().off(a, r);
          }), this._handlers = null;
        }, t.prototype._throttledDispatchExpand = function(e) {
          this._dispatchExpand(e);
        }, t.prototype._dispatchExpand = function(e) {
          e && this._api.dispatchAction(Y({ type: "parallelAxisExpand" }, e));
        }, t.type = "parallel", t;
      }(on), BTt = { mousedown: function(n) {
        qM(this, "click") && (this._mouseDownPoint = [n.offsetX, n.offsetY]);
      }, mouseup: function(n) {
        var t = this._mouseDownPoint;
        if (qM(this, "click") && t) {
          var e = [n.offsetX, n.offsetY], i = Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2);
          if (i > STt) return;
          var r = this._model.coordinateSystem.getSlidedAxisExpandWindow([n.offsetX, n.offsetY]);
          r.behavior !== "none" && this._dispatchExpand({ axisExpandWindow: r.axisExpandWindow });
        }
        this._mouseDownPoint = null;
      }, mousemove: function(n) {
        if (!(this._mouseDownPoint || !qM(this, "mousemove"))) {
          var t = this._model, e = t.coordinateSystem.getSlidedAxisExpandWindow([n.offsetX, n.offsetY]), i = e.behavior;
          i === "jump" && this._throttledDispatchExpand.debounceNextCall(t.get("axisExpandDebounce")), this._throttledDispatchExpand(i === "none" ? null : { axisExpandWindow: e.axisExpandWindow, animation: i === "jump" ? null : { duration: 0 } });
        }
      } };
      function qM(n, t) {
        var e = n._model;
        return e.get("axisExpandable") && e.get("axisExpandTriggerOn") === t;
      }
      var TTt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function() {
          n.prototype.init.apply(this, arguments), this.mergeOption({});
        }, t.prototype.mergeOption = function(e) {
          var i = this.option;
          e && qt(i, e, true), this._initDimensions();
        }, t.prototype.contains = function(e, i) {
          var r = e.get("parallelIndex");
          return r != null && i.getComponent("parallel", r) === this;
        }, t.prototype.setAxisExpand = function(e) {
          M(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(i) {
            e.hasOwnProperty(i) && (this.option[i] = e[i]);
          }, this);
        }, t.prototype._initDimensions = function() {
          var e = this.dimensions = [], i = this.parallelAxisIndex = [], r = Ne(this.ecModel.queryComponents({ mainType: "parallelAxis" }), function(a) {
            return (a.get("parallelIndex") || 0) === this.componentIndex;
          }, this);
          M(r, function(a) {
            e.push("dim" + a.get("dim")), i.push(a.componentIndex);
          });
        }, t.type = "parallel", t.dependencies = ["parallelAxis"], t.layoutMode = "box", t.defaultOption = { z: 0, left: 80, top: 60, right: 80, bottom: 60, layout: "horizontal", axisExpandable: false, axisExpandCenter: null, axisExpandCount: 0, axisExpandWidth: 50, axisExpandRate: 17, axisExpandDebounce: 50, axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4], axisExpandTriggerOn: "click", parallelAxisDefault: null }, t;
      }(ne), MTt = function(n) {
        V(t, n);
        function t(e, i, r, a, o) {
          var s = n.call(this, e, i, r) || this;
          return s.type = a || "value", s.axisIndex = o, s;
        }
        return t.prototype.isHorizontal = function() {
          return this.coordinateSystem.getModel().get("layout") !== "horizontal";
        }, t;
      }($a);
      function lc(n, t, e, i, r, a) {
        n = n || 0;
        var o = e[1] - e[0];
        if (r != null && (r = ad(r, [0, o])), a != null && (a = Math.max(a, r != null ? r : 0)), i === "all") {
          var s = Math.abs(t[1] - t[0]);
          s = ad(s, [0, o]), r = a = ad(s, [r, a]), i = 0;
        }
        t[0] = ad(t[0], e), t[1] = ad(t[1], e);
        var l = HM(t, i);
        t[i] += n;
        var u = r || 0, h = e.slice();
        l.sign < 0 ? h[0] += u : h[1] -= u, t[i] = ad(t[i], h);
        var c;
        return c = HM(t, i), r != null && (c.sign !== l.sign || c.span < r) && (t[1 - i] = t[i] + l.sign * r), c = HM(t, i), a != null && c.span > a && (t[1 - i] = t[i] + c.sign * a), t;
      }
      function HM(n, t) {
        var e = n[t] - n[1 - t];
        return { span: Math.abs(e), sign: e > 0 ? -1 : e < 0 ? 1 : t ? -1 : 1 };
      }
      function ad(n, t) {
        return Math.min(t[1] != null ? t[1] : 1 / 0, Math.max(t[0] != null ? t[0] : -1 / 0, n));
      }
      var YM = M, Y9 = Math.min, W9 = Math.max, X9 = Math.floor, DTt = Math.ceil, Z9 = vn, RTt = Math.PI, LTt = function() {
        function n(t, e, i) {
          this.type = "parallel", this._axesMap = dt(), this._axesLayout = {}, this.dimensions = t.dimensions, this._model = t, this._init(t, e, i);
        }
        return n.prototype._init = function(t, e, i) {
          var r = t.dimensions, a = t.parallelAxisIndex;
          YM(r, function(o, s) {
            var l = a[s], u = e.getComponent("parallelAxis", l), h = this._axesMap.set(o, new MTt(o, aI(u), [0, 0], u.get("type"), l)), c = h.type === "category";
            h.onBand = c && u.get("boundaryGap"), h.inverse = u.get("inverse"), u.axis = h, h.model = u, h.coordinateSystem = u.coordinateSystem = this;
          }, this);
        }, n.prototype.update = function(t, e) {
          this._updateAxesFromSeries(this._model, t);
        }, n.prototype.containPoint = function(t) {
          var e = this._makeLayoutInfo(), i = e.axisBase, r = e.layoutBase, a = e.pixelDimIndex, o = t[1 - a], s = t[a];
          return o >= i && o <= i + e.axisLength && s >= r && s <= r + e.layoutLength;
        }, n.prototype.getModel = function() {
          return this._model;
        }, n.prototype._updateAxesFromSeries = function(t, e) {
          e.eachSeries(function(i) {
            if (t.contains(i, e)) {
              var r = i.getData();
              YM(this.dimensions, function(a) {
                var o = this._axesMap.get(a);
                o.scale.unionExtentFromData(r, r.mapDimension(a)), Xg(o.scale, o.model);
              }, this);
            }
          }, this);
        }, n.prototype.resize = function(t, e) {
          this._rect = Gn(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }), this._layoutAxes();
        }, n.prototype.getRect = function() {
          return this._rect;
        }, n.prototype._makeLayoutInfo = function() {
          var t = this._model, e = this._rect, i = ["x", "y"], r = ["width", "height"], a = t.get("layout"), o = a === "horizontal" ? 0 : 1, s = e[r[o]], l = [0, s], u = this.dimensions.length, h = NI(t.get("axisExpandWidth"), l), c = NI(t.get("axisExpandCount") || 0, [0, u]), f = t.get("axisExpandable") && u > 3 && u > c && c > 1 && h > 0 && s > 0, g = t.get("axisExpandWindow"), d;
          if (g) d = NI(g[1] - g[0], l), g[1] = g[0] + d;
          else {
            d = NI(h * (c - 1), l);
            var A = t.get("axisExpandCenter") || X9(u / 2);
            g = [h * A - d / 2], g[1] = g[0] + d;
          }
          var p = (s - d) / (u - c);
          p < 3 && (p = 0);
          var v = [X9(Z9(g[0] / h, 1)) + 1, DTt(Z9(g[1] / h, 1)) - 1], y = p / h * g[0];
          return { layout: a, pixelDimIndex: o, layoutBase: e[i[o]], layoutLength: s, axisBase: e[i[1 - o]], axisLength: e[r[1 - o]], axisExpandable: f, axisExpandWidth: h, axisCollapseWidth: p, axisExpandWindow: g, axisCount: u, winInnerIndices: v, axisExpandWindow0Pos: y };
        }, n.prototype._layoutAxes = function() {
          var t = this._rect, e = this._axesMap, i = this.dimensions, r = this._makeLayoutInfo(), a = r.layout;
          e.each(function(o) {
            var s = [0, r.axisLength], l = o.inverse ? 1 : 0;
            o.setExtent(s[l], s[1 - l]);
          }), YM(i, function(o, s) {
            var l = (r.axisExpandable ? NTt : PTt)(s, r), u = { horizontal: { x: l.position, y: r.axisLength }, vertical: { x: 0, y: l.position } }, h = { horizontal: RTt / 2, vertical: 0 }, c = [u[a].x + t.x, u[a].y + t.y], f = h[a], g = Fr();
            oh(g, g, f), bo(g, g, c), this._axesLayout[o] = { position: c, rotation: f, transform: g, axisNameAvailableWidth: l.axisNameAvailableWidth, axisLabelShow: l.axisLabelShow, nameTruncateMaxWidth: l.nameTruncateMaxWidth, tickDirection: 1, labelDirection: 1 };
          }, this);
        }, n.prototype.getAxis = function(t) {
          return this._axesMap.get(t);
        }, n.prototype.dataToPoint = function(t, e) {
          return this.axisCoordToPoint(this._axesMap.get(e).dataToCoord(t), e);
        }, n.prototype.eachActiveState = function(t, e, i, r) {
          i == null && (i = 0), r == null && (r = t.count());
          var a = this._axesMap, o = this.dimensions, s = [], l = [];
          M(o, function(p) {
            s.push(t.mapDimension(p)), l.push(a.get(p).model);
          });
          for (var u = this.hasAxisBrushed(), h = i; h < r; h++) {
            var c = void 0;
            if (!u) c = "normal";
            else {
              c = "active";
              for (var f = t.getValues(s, h), g = 0, d = o.length; g < d; g++) {
                var A = l[g].getActiveState(f[g]);
                if (A === "inactive") {
                  c = "inactive";
                  break;
                }
              }
            }
            e(c, h);
          }
        }, n.prototype.hasAxisBrushed = function() {
          for (var t = this.dimensions, e = this._axesMap, i = false, r = 0, a = t.length; r < a; r++) e.get(t[r]).model.getActiveState() !== "normal" && (i = true);
          return i;
        }, n.prototype.axisCoordToPoint = function(t, e) {
          var i = this._axesLayout[e];
          return Xa([t, 0], i.transform);
        }, n.prototype.getAxisLayout = function(t) {
          return xt(this._axesLayout[t]);
        }, n.prototype.getSlidedAxisExpandWindow = function(t) {
          var e = this._makeLayoutInfo(), i = e.pixelDimIndex, r = e.axisExpandWindow.slice(), a = r[1] - r[0], o = [0, e.axisExpandWidth * (e.axisCount - 1)];
          if (!this.containPoint(t)) return { behavior: "none", axisExpandWindow: r };
          var s = t[i] - e.layoutBase - e.axisExpandWindow0Pos, l, u = "slide", h = e.axisCollapseWidth, c = this._model.get("axisExpandSlideTriggerArea"), f = c[0] != null;
          if (h) f && h && s < a * c[0] ? (u = "jump", l = s - a * c[2]) : f && h && s > a * (1 - c[0]) ? (u = "jump", l = s - a * (1 - c[2])) : (l = s - a * c[1]) >= 0 && (l = s - a * (1 - c[1])) <= 0 && (l = 0), l *= e.axisExpandWidth / h, l ? lc(l, r, o, "all") : u = "none";
          else {
            var g = r[1] - r[0], d = o[1] * s / g;
            r = [W9(0, d - g / 2)], r[1] = Y9(o[1], r[0] + g), r[0] = r[1] - g;
          }
          return { axisExpandWindow: r, behavior: u };
        }, n;
      }();
      function NI(n, t) {
        return Y9(W9(n, t[0]), t[1]);
      }
      function PTt(n, t) {
        var e = t.layoutLength / (t.axisCount - 1);
        return { position: e * n, axisNameAvailableWidth: e, axisLabelShow: true };
      }
      function NTt(n, t) {
        var e = t.layoutLength, i = t.axisExpandWidth, r = t.axisCount, a = t.axisCollapseWidth, o = t.winInnerIndices, s, l = a, u = false, h;
        return n < o[0] ? (s = n * a, h = a) : n <= o[1] ? (s = t.axisExpandWindow0Pos + n * i - t.axisExpandWindow[0], l = i, u = true) : (s = e - (r - 1 - n) * a, h = a), { position: s, axisNameAvailableWidth: l, axisLabelShow: u, nameTruncateMaxWidth: h };
      }
      function kTt(n, t) {
        var e = [];
        return n.eachComponent("parallel", function(i, r) {
          var a = new LTt(i, n, t);
          a.name = "parallel_" + r, a.resize(i, t), i.coordinateSystem = a, a.model = i, e.push(a);
        }), n.eachSeries(function(i) {
          if (i.get("coordinateSystem") === "parallel") {
            var r = i.getReferringComponents("parallel", Ln).models[0];
            i.coordinateSystem = r.coordinateSystem;
          }
        }), e;
      }
      var FTt = { create: kTt }, WM = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.activeIntervals = [], e;
        }
        return t.prototype.getAreaSelectStyle = function() {
          return vh([["fill", "color"], ["lineWidth", "borderWidth"], ["stroke", "borderColor"], ["width", "width"], ["opacity", "opacity"]])(this.getModel("areaSelectStyle"));
        }, t.prototype.setActiveIntervals = function(e) {
          var i = this.activeIntervals = xt(e);
          if (i) for (var r = i.length - 1; r >= 0; r--) ua(i[r]);
        }, t.prototype.getActiveState = function(e) {
          var i = this.activeIntervals;
          if (!i.length) return "normal";
          if (e == null || isNaN(+e)) return "inactive";
          if (i.length === 1) {
            var r = i[0];
            if (r[0] <= e && e <= r[1]) return "active";
          } else for (var a = 0, o = i.length; a < o; a++) if (i[a][0] <= e && e <= i[a][1]) return "active";
          return "inactive";
        }, t;
      }(ne);
      Mn(WM, mv);
      var uc = true, Wv = Math.min, od = Math.max, QTt = Math.pow, OTt = 1e4, zTt = 6, GTt = 6, K9 = "globalPan", UTt = { w: [0, 0], e: [0, 1], n: [1, 0], s: [1, 1] }, VTt = { w: "ew", e: "ew", n: "ns", s: "ns", ne: "nesw", sw: "nesw", nw: "nwse", se: "nwse" }, $9 = { brushStyle: { lineWidth: 2, stroke: "rgba(210,219,238,0.3)", fill: "#D2DBEE" }, transformable: true, brushMode: "single", removeOnClick: false }, jTt = 0, XM = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this) || this;
          return i._track = [], i._covers = [], i._handlers = {}, It(e), i._zr = e, i.group = new Ct(), i._uid = "brushController_" + jTt++, M(KTt, function(r, a) {
            this._handlers[a] = ct(r, this);
          }, i), i;
        }
        return t.prototype.enableBrush = function(e) {
          return It(this._mounted), this._brushType && this._doDisableBrush(), e.brushType && this._doEnableBrush(e), this;
        }, t.prototype._doEnableBrush = function(e) {
          var i = this._zr;
          this._enableGlobalPan || Pbt(i, K9, this._uid), M(this._handlers, function(r, a) {
            i.on(a, r);
          }), this._brushType = e.brushType, this._brushOption = qt(xt($9), e, true);
        }, t.prototype._doDisableBrush = function() {
          var e = this._zr;
          Nbt(e, K9, this._uid), M(this._handlers, function(i, r) {
            e.off(r, i);
          }), this._brushType = this._brushOption = null;
        }, t.prototype.setPanels = function(e) {
          if (e && e.length) {
            var i = this._panels = {};
            M(e, function(r) {
              i[r.panelId] = xt(r);
            });
          } else this._panels = null;
          return this;
        }, t.prototype.mount = function(e) {
          e = e || {}, this._mounted = true, this._enableGlobalPan = e.enableGlobalPan;
          var i = this.group;
          return this._zr.add(i), i.attr({ x: e.x || 0, y: e.y || 0, rotation: e.rotation || 0, scaleX: e.scaleX || 1, scaleY: e.scaleY || 1 }), this._transform = i.getLocalTransform(), this;
        }, t.prototype.updateCovers = function(e) {
          It(this._mounted), e = Z(e, function(f) {
            return qt(xt($9), f, true);
          });
          var i = "\0-brush-index-", r = this._covers, a = this._covers = [], o = this, s = this._creatingCover;
          return new Os(r, e, u, l).add(h).update(h).remove(c).execute(), this;
          function l(f, g) {
            return (f.id != null ? f.id : i + g) + "-" + f.brushType;
          }
          function u(f, g) {
            return l(f.__brushOption, g);
          }
          function h(f, g) {
            var d = e[f];
            if (g != null && r[g] === s) a[f] = r[g];
            else {
              var A = a[f] = g != null ? (r[g].__brushOption = d, r[g]) : tq(o, J9(o, d));
              ZM(o, A);
            }
          }
          function c(f) {
            r[f] !== s && o.group.remove(r[f]);
          }
        }, t.prototype.unmount = function() {
          if (!!this._mounted) return this.enableBrush(false), JM(this), this._zr.remove(this.group), this._mounted = false, this;
        }, t.prototype.dispose = function() {
          this.unmount(), this.off();
        }, t;
      }(aa);
      function J9(n, t) {
        var e = kI[t.brushType].createCover(n, t);
        return e.__brushOption = t, nq(e, t), n.group.add(e), e;
      }
      function tq(n, t) {
        var e = KM(t);
        return e.endCreating && (e.endCreating(n, t), nq(t, t.__brushOption)), t;
      }
      function eq(n, t) {
        var e = t.__brushOption;
        KM(t).updateCoverShape(n, t, e.range, e);
      }
      function nq(n, t) {
        var e = t.z;
        e == null && (e = OTt), n.traverse(function(i) {
          i.z = e, i.z2 = e;
        });
      }
      function ZM(n, t) {
        KM(t).updateCommon(n, t), eq(n, t);
      }
      function KM(n) {
        return kI[n.__brushOption.brushType];
      }
      function $M(n, t, e) {
        var i = n._panels;
        if (!i) return uc;
        var r, a = n._transform;
        return M(i, function(o) {
          o.isTargetByCursor(t, e, a) && (r = o);
        }), r;
      }
      function iq(n, t) {
        var e = n._panels;
        if (!e) return uc;
        var i = t.__brushOption.panelId;
        return i != null ? e[i] : uc;
      }
      function JM(n) {
        var t = n._covers, e = t.length;
        return M(t, function(i) {
          n.group.remove(i);
        }, n), t.length = 0, !!e;
      }
      function hc(n, t) {
        var e = Z(n._covers, function(i) {
          var r = i.__brushOption, a = xt(r.range);
          return { brushType: r.brushType, panelId: r.panelId, range: a };
        });
        n.trigger("brush", { areas: e, isEnd: !!t.isEnd, removeOnClick: !!t.removeOnClick });
      }
      function qTt(n) {
        var t = n._track;
        if (!t.length) return false;
        var e = t[t.length - 1], i = t[0], r = e[0] - i[0], a = e[1] - i[1], o = QTt(r * r + a * a, 0.5);
        return o > zTt;
      }
      function rq(n) {
        var t = n.length - 1;
        return t < 0 && (t = 0), [n[0], n[t]];
      }
      function aq(n, t, e, i) {
        var r = new Ct();
        return r.add(new ue({ name: "main", style: eD(e), silent: true, draggable: true, cursor: "move", drift: Ot(lq, n, t, r, ["n", "s", "w", "e"]), ondragend: Ot(hc, t, { isEnd: true }) })), M(i, function(a) {
          r.add(new ue({ name: a.join(""), style: { opacity: 0 }, draggable: true, silent: true, invisible: true, drift: Ot(lq, n, t, r, a), ondragend: Ot(hc, t, { isEnd: true }) }));
        }), r;
      }
      function oq(n, t, e, i) {
        var r = i.brushStyle.lineWidth || 0, a = od(r, GTt), o = e[0][0], s = e[1][0], l = o - r / 2, u = s - r / 2, h = e[0][1], c = e[1][1], f = h - a + r / 2, g = c - a + r / 2, d = h - o, A = c - s, p = d + r, v = A + r;
        Vs(n, t, "main", o, s, d, A), i.transformable && (Vs(n, t, "w", l, u, a, v), Vs(n, t, "e", f, u, a, v), Vs(n, t, "n", l, u, p, a), Vs(n, t, "s", l, g, p, a), Vs(n, t, "nw", l, u, a, a), Vs(n, t, "ne", f, u, a, a), Vs(n, t, "sw", l, g, a, a), Vs(n, t, "se", f, g, a, a));
      }
      function tD(n, t) {
        var e = t.__brushOption, i = e.transformable, r = t.childAt(0);
        r.useStyle(eD(e)), r.attr({ silent: !i, cursor: i ? "move" : "default" }), M([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(a) {
          var o = t.childOfName(a.join("")), s = a.length === 1 ? nD(n, a[0]) : YTt(n, a);
          o && o.attr({ silent: !i, invisible: !i, cursor: i ? VTt[s] + "-resize" : null });
        });
      }
      function Vs(n, t, e, i, r, a, o) {
        var s = t.childOfName(e);
        s && s.setShape(XTt(iD(n, t, [[i, r], [i + a, r + o]])));
      }
      function eD(n) {
        return Et({ strokeNoScale: true }, n.brushStyle);
      }
      function sq(n, t, e, i) {
        var r = [Wv(n, e), Wv(t, i)], a = [od(n, e), od(t, i)];
        return [[r[0], a[0]], [r[1], a[1]]];
      }
      function HTt(n) {
        return Lh(n.group);
      }
      function nD(n, t) {
        var e = { w: "left", e: "right", n: "top", s: "bottom" }, i = { left: "w", right: "e", top: "n", bottom: "s" }, r = f1(e[t], HTt(n));
        return i[r];
      }
      function YTt(n, t) {
        var e = [nD(n, t[0]), nD(n, t[1])];
        return (e[0] === "e" || e[0] === "w") && e.reverse(), e.join("");
      }
      function lq(n, t, e, i, r, a) {
        var o = e.__brushOption, s = n.toRectRange(o.range), l = uq(t, r, a);
        M(i, function(u) {
          var h = UTt[u];
          s[h[0]][h[1]] += l[h[0]];
        }), o.range = n.fromRectRange(sq(s[0][0], s[1][0], s[0][1], s[1][1])), ZM(t, e), hc(t, { isEnd: false });
      }
      function WTt(n, t, e, i) {
        var r = t.__brushOption.range, a = uq(n, e, i);
        M(r, function(o) {
          o[0] += a[0], o[1] += a[1];
        }), ZM(n, t), hc(n, { isEnd: false });
      }
      function uq(n, t, e) {
        var i = n.group, r = i.transformCoordToLocal(t, e), a = i.transformCoordToLocal(0, 0);
        return [r[0] - a[0], r[1] - a[1]];
      }
      function iD(n, t, e) {
        var i = iq(n, t);
        return i && i !== uc ? i.clipPath(e, n._transform) : xt(e);
      }
      function XTt(n) {
        var t = Wv(n[0][0], n[1][0]), e = Wv(n[0][1], n[1][1]), i = od(n[0][0], n[1][0]), r = od(n[0][1], n[1][1]);
        return { x: t, y: e, width: i - t, height: r - e };
      }
      function ZTt(n, t, e) {
        if (!(!n._brushType || $Tt(n, t.offsetX, t.offsetY))) {
          var i = n._zr, r = n._covers, a = $M(n, t, e);
          if (!n._dragging) for (var o = 0; o < r.length; o++) {
            var s = r[o].__brushOption;
            if (a && (a === uc || s.panelId === a.panelId) && kI[s.brushType].contain(r[o], e[0], e[1])) return;
          }
          a && i.setCursorStyle("crosshair");
        }
      }
      function rD(n) {
        var t = n.event;
        t.preventDefault && t.preventDefault();
      }
      function aD(n, t, e) {
        return n.childOfName("main").contain(t, e);
      }
      function hq(n, t, e, i) {
        var r = n._creatingCover, a = n._creatingPanel, o = n._brushOption, s;
        if (n._track.push(e.slice()), qTt(n) || r) {
          if (a && !r) {
            o.brushMode === "single" && JM(n);
            var l = xt(o);
            l.brushType = cq(l.brushType, a), l.panelId = a === uc ? null : a.panelId, r = n._creatingCover = J9(n, l), n._covers.push(r);
          }
          if (r) {
            var u = kI[cq(n._brushType, a)], h = r.__brushOption;
            h.range = u.getCreatingRange(iD(n, r, n._track)), i && (tq(n, r), u.updateCommon(n, r)), eq(n, r), s = { isEnd: i };
          }
        } else i && o.brushMode === "single" && o.removeOnClick && $M(n, t, e) && JM(n) && (s = { isEnd: i, removeOnClick: true });
        return s;
      }
      function cq(n, t) {
        return n === "auto" ? (It(t && t.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"'), t.defaultBrushType) : n;
      }
      var KTt = { mousedown: function(n) {
        if (this._dragging) fq(this, n);
        else if (!n.target || !n.target.draggable) {
          rD(n);
          var t = this.group.transformCoordToLocal(n.offsetX, n.offsetY);
          this._creatingCover = null;
          var e = this._creatingPanel = $M(this, n, t);
          e && (this._dragging = true, this._track = [t.slice()]);
        }
      }, mousemove: function(n) {
        var t = n.offsetX, e = n.offsetY, i = this.group.transformCoordToLocal(t, e);
        if (ZTt(this, n, i), this._dragging) {
          rD(n);
          var r = hq(this, n, i, false);
          r && hc(this, r);
        }
      }, mouseup: function(n) {
        fq(this, n);
      } };
      function fq(n, t) {
        if (n._dragging) {
          rD(t);
          var e = t.offsetX, i = t.offsetY, r = n.group.transformCoordToLocal(e, i), a = hq(n, t, r, true);
          n._dragging = false, n._track = [], n._creatingCover = null, a && hc(n, a);
        }
      }
      function $Tt(n, t, e) {
        var i = n._zr;
        return t < 0 || t > i.getWidth() || e < 0 || e > i.getHeight();
      }
      var kI = { lineX: gq(0), lineY: gq(1), rect: { createCover: function(n, t) {
        function e(i) {
          return i;
        }
        return aq({ toRectRange: e, fromRectRange: e }, n, t, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
      }, getCreatingRange: function(n) {
        var t = rq(n);
        return sq(t[1][0], t[1][1], t[0][0], t[0][1]);
      }, updateCoverShape: function(n, t, e, i) {
        oq(n, t, e, i);
      }, updateCommon: tD, contain: aD }, polygon: { createCover: function(n, t) {
        var e = new Ct();
        return e.add(new Wi({ name: "main", style: eD(t), silent: true })), e;
      }, getCreatingRange: function(n) {
        return n;
      }, endCreating: function(n, t) {
        t.remove(t.childAt(0)), t.add(new Yi({ name: "main", draggable: true, drift: Ot(WTt, n, t), ondragend: Ot(hc, n, { isEnd: true }) }));
      }, updateCoverShape: function(n, t, e, i) {
        t.childAt(0).setShape({ points: iD(n, t, e) });
      }, updateCommon: tD, contain: aD } };
      function gq(n) {
        return { createCover: function(t, e) {
          return aq({ toRectRange: function(i) {
            var r = [i, [0, 100]];
            return n && r.reverse(), r;
          }, fromRectRange: function(i) {
            return i[n];
          } }, t, e, [[["w"], ["e"]], [["n"], ["s"]]][n]);
        }, getCreatingRange: function(t) {
          var e = rq(t), i = Wv(e[0][n], e[1][n]), r = od(e[0][n], e[1][n]);
          return [i, r];
        }, updateCoverShape: function(t, e, i, r) {
          var a, o = iq(t, e);
          if (o !== uc && o.getLinearBrushOtherExtent) a = o.getLinearBrushOtherExtent(n);
          else {
            var s = t._zr;
            a = [0, [s.getWidth(), s.getHeight()][1 - n]];
          }
          var l = [i, a];
          n && l.reverse(), oq(t, e, l, r);
        }, updateCommon: tD, contain: aD };
      }
      function dq(n) {
        return n = oD(n), function(t) {
          return n4(t, n);
        };
      }
      function Aq(n, t) {
        return n = oD(n), function(e) {
          var i = t != null ? t : e, r = i ? n.width : n.height, a = i ? n.x : n.y;
          return [a, a + (r || 0)];
        };
      }
      function pq(n, t, e) {
        var i = oD(n);
        return function(r, a) {
          return i.contain(a[0], a[1]) && !II(r, t, e);
        };
      }
      function oD(n) {
        return Ht.create(n);
      }
      var JTt = ["axisLine", "axisTickLabel", "axisName"], tMt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e, i) {
          n.prototype.init.apply(this, arguments), (this._brushController = new XM(i.getZr())).on("brush", ct(this._onBrush, this));
        }, t.prototype.render = function(e, i, r, a) {
          if (!eMt(e, i, a)) {
            this.axisModel = e, this.api = r, this.group.removeAll();
            var o = this._axisGroup;
            if (this._axisGroup = new Ct(), this.group.add(this._axisGroup), !!e.get("show")) {
              var s = iMt(e, i), l = s.coordinateSystem, u = e.getAreaSelectStyle(), h = u.width, c = e.axis.dim, f = l.getAxisLayout(c), g = Y({ strokeContainThreshold: h }, f), d = new Ji(e, g);
              M(JTt, d.add, d), this._axisGroup.add(d.getGroup()), this._refreshBrushController(g, u, e, s, h, r), qp(o, this._axisGroup, e);
            }
          }
        }, t.prototype._refreshBrushController = function(e, i, r, a, o, s) {
          var l = r.axis.getExtent(), u = l[1] - l[0], h = Math.min(30, Math.abs(u) * 0.1), c = Ht.create({ x: l[0], y: -o / 2, width: u, height: o });
          c.x -= h, c.width += 2 * h, this._brushController.mount({ enableGlobalPan: true, rotation: e.rotation, x: e.position[0], y: e.position[1] }).setPanels([{ panelId: "pl", clipPath: dq(c), isTargetByCursor: pq(c, s, a), getLinearBrushOtherExtent: Aq(c, 0) }]).enableBrush({ brushType: "lineX", brushStyle: i, removeOnClick: true }).updateCovers(nMt(r));
        }, t.prototype._onBrush = function(e) {
          var i = e.areas, r = this.axisModel, a = r.axis, o = Z(i, function(s) {
            return [a.coordToData(s.range[0], true), a.coordToData(s.range[1], true)];
          });
          (!r.option.realtime === e.isEnd || e.removeOnClick) && this.api.dispatchAction({ type: "axisAreaSelect", parallelAxisId: r.id, intervals: o });
        }, t.prototype.dispose = function() {
          this._brushController.dispose();
        }, t.type = "parallelAxis", t;
      }(on);
      function eMt(n, t, e) {
        return e && e.type === "axisAreaSelect" && t.findComponents({ mainType: "parallelAxis", query: e })[0] === n;
      }
      function nMt(n) {
        var t = n.axis;
        return Z(n.activeIntervals, function(e) {
          return { brushType: "lineX", panelId: "pl", range: [t.dataToCoord(e[0], true), t.dataToCoord(e[1], true)] };
        });
      }
      function iMt(n, t) {
        return t.getComponent("parallel", n.get("parallelIndex"));
      }
      var rMt = { type: "axisAreaSelect", event: "axisAreaSelected" };
      function aMt(n) {
        n.registerAction(rMt, function(t, e) {
          e.eachComponent({ mainType: "parallelAxis", query: t }, function(i) {
            i.axis.model.setActiveIntervals(t.intervals);
          });
        }), n.registerAction("parallelAxisExpand", function(t, e) {
          e.eachComponent({ mainType: "parallel", query: t }, function(i) {
            i.setAxisExpand(t);
          });
        });
      }
      var oMt = { type: "value", areaSelectStyle: { width: 20, borderWidth: 1, borderColor: "rgba(160,197,232)", color: "rgba(160,197,232)", opacity: 0.3 }, realtime: true, z: 10 };
      function vq(n) {
        n.registerComponentView(bTt), n.registerComponentModel(TTt), n.registerCoordinateSystem("parallel", FTt), n.registerPreprocessor(xTt), n.registerComponentModel(WM), n.registerComponentView(tMt), td(n, "parallel", WM, oMt), aMt(n);
      }
      function sMt(n) {
        Zt(vq), n.registerChartView(ATt), n.registerSeriesModel(yTt), n.registerVisual(n.PRIORITY.VISUAL.BRUSH, ETt);
      }
      var lMt = /* @__PURE__ */ function() {
        function n() {
          this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
        }
        return n;
      }(), uMt = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultShape = function() {
          return new lMt();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.extent;
          e.moveTo(i.x1, i.y1), e.bezierCurveTo(i.cpx1, i.cpy1, i.cpx2, i.cpy2, i.x2, i.y2), i.orient === "vertical" ? (e.lineTo(i.x2 + r, i.y2), e.bezierCurveTo(i.cpx2 + r, i.cpy2, i.cpx1 + r, i.cpy1, i.x1 + r, i.y1)) : (e.lineTo(i.x2, i.y2 + r), e.bezierCurveTo(i.cpx2, i.cpy2 + r, i.cpx1, i.cpy1 + r, i.x1, i.y1 + r)), e.closePath();
        }, t.prototype.highlight = function() {
          Ps(this);
        }, t.prototype.downplay = function() {
          Ns(this);
        }, t;
      }(Jt), hMt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._focusAdjacencyDisabled = false, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = this, o = e.getGraph(), s = this.group, l = e.layoutInfo, u = l.width, h = l.height, c = e.getData(), f = e.getData("edge"), g = e.get("orient");
          this._model = e, s.removeAll(), s.x = l.x, s.y = l.y, o.eachEdge(function(d) {
            var A = new uMt(), p = Dt(A);
            p.dataIndex = d.dataIndex, p.seriesIndex = e.seriesIndex, p.dataType = "edge";
            var v = d.getModel(), y = v.getModel("lineStyle"), m = y.get("curveness"), _ = d.node1.getLayout(), E = d.node1.getModel(), I = E.get("localX"), x = E.get("localY"), w = d.node2.getLayout(), C = d.node2.getModel(), S = C.get("localX"), b = C.get("localY"), B = d.getLayout(), T, D, R, L, k, P, F, Q;
            A.shape.extent = Math.max(1, B.dy), A.shape.orient = g, g === "vertical" ? (T = (I != null ? I * u : _.x) + B.sy, D = (x != null ? x * h : _.y) + _.dy, R = (S != null ? S * u : w.x) + B.ty, L = b != null ? b * h : w.y, k = T, P = D * (1 - m) + L * m, F = R, Q = D * m + L * (1 - m)) : (T = (I != null ? I * u : _.x) + _.dx, D = (x != null ? x * h : _.y) + B.sy, R = S != null ? S * u : w.x, L = (b != null ? b * h : w.y) + B.ty, k = T * (1 - m) + R * m, P = D, F = T * m + R * (1 - m), Q = L), A.setShape({ x1: T, y1: D, x2: R, y2: L, cpx1: k, cpy1: P, cpx2: F, cpy2: Q }), A.useStyle(y.getItemStyle()), yq(A.style, g, d);
            var z = "" + v.get("value"), j = Xn(v, "edgeLabel");
            vi(A, j, { labelFetcher: { getFormattedLabel: function(tt, J, et, nt, gt, H) {
              return e.getFormattedLabel(tt, J, "edge", nt, ra(gt, j.normal && j.normal.get("formatter"), z), H);
            } }, labelDataIndex: d.dataIndex, defaultText: z }), A.setTextConfig({ position: "inside" });
            var $ = v.getModel("emphasis");
            pi(A, v, "lineStyle", function(tt) {
              var J = tt.getItemStyle();
              return yq(J, g, d), J;
            }), s.add(A), f.setItemGraphicEl(d.dataIndex, A);
            var G = $.get("focus");
            hn(A, G === "adjacency" ? d.getAdjacentDataIndices() : G === "trajectory" ? d.getTrajectoryDataIndices() : G, $.get("blurScope"), $.get("disabled"));
          }), o.eachNode(function(d) {
            var A = d.getLayout(), p = d.getModel(), v = p.get("localX"), y = p.get("localY"), m = p.getModel("emphasis"), _ = p.get(["itemStyle", "borderRadius"]) || 0, E = new ue({ shape: { x: v != null ? v * u : A.x, y: y != null ? y * h : A.y, width: A.dx, height: A.dy, r: _ }, style: p.getModel("itemStyle").getItemStyle(), z2: 10 });
            vi(E, Xn(p), { labelFetcher: { getFormattedLabel: function(x, w) {
              return e.getFormattedLabel(x, w, "node");
            } }, labelDataIndex: d.dataIndex, defaultText: d.id }), E.disableLabelAnimation = true, E.setStyle("fill", d.getVisual("color")), E.setStyle("decal", d.getVisual("style").decal), pi(E, p), s.add(E), c.setItemGraphicEl(d.dataIndex, E), Dt(E).dataType = "node";
            var I = m.get("focus");
            hn(E, I === "adjacency" ? d.getAdjacentDataIndices() : I === "trajectory" ? d.getTrajectoryDataIndices() : I, m.get("blurScope"), m.get("disabled"));
          }), c.eachItemGraphicEl(function(d, A) {
            var p = c.getItemModel(A);
            p.get("draggable") && (d.drift = function(v, y) {
              a._focusAdjacencyDisabled = true, this.shape.x += v, this.shape.y += y, this.dirty(), r.dispatchAction({ type: "dragNode", seriesId: e.id, dataIndex: c.getRawIndex(A), localX: this.shape.x / u, localY: this.shape.y / h });
            }, d.ondragend = function() {
              a._focusAdjacencyDisabled = false;
            }, d.draggable = true, d.cursor = "move");
          }), !this._data && e.isAnimationEnabled() && s.setClipPath(cMt(s.getBoundingRect(), e, function() {
            s.removeClipPath();
          })), this._data = e.getData();
        }, t.prototype.dispose = function() {
        }, t.type = "sankey", t;
      }(Ve);
      function yq(n, t, e) {
        switch (n.fill) {
          case "source":
            n.fill = e.node1.getVisual("color"), n.decal = e.node1.getVisual("style").decal;
            break;
          case "target":
            n.fill = e.node2.getVisual("color"), n.decal = e.node2.getVisual("style").decal;
            break;
          case "gradient":
            var i = e.node1.getVisual("color"), r = e.node2.getVisual("color");
            ht(i) && ht(r) && (n.fill = new Vp(0, 0, +(t === "horizontal"), +(t === "vertical"), [{ color: i, offset: 0 }, { color: r, offset: 1 }]));
        }
      }
      function cMt(n, t, e) {
        var i = new ue({ shape: { x: n.x - 10, y: n.y - 10, width: 0, height: n.height + 20 } });
        return nn(i, { shape: { width: n.width + 20 } }, t, e), i;
      }
      var fMt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.getInitialData = function(e, i) {
          var r = e.edges || e.links, a = e.data || e.nodes, o = e.levels;
          this.levelModels = [];
          for (var s = this.levelModels, l = 0; l < o.length; l++) if (o[l].depth != null && o[l].depth >= 0) s[o[l].depth] = new Te(o[l], this, i);
          else if (true) throw new Error("levels[i].depth is mandatory and should be natural number");
          if (a && r) {
            var u = V9(a, r, this, true, h);
            return u.data;
          }
          function h(c, f) {
            c.wrapMethod("getItemModel", function(g, d) {
              var A = g.parentModel, p = A.getData().getItemLayout(d);
              if (p) {
                var v = p.depth, y = A.levelModels[v];
                y && (g.parentModel = y);
              }
              return g;
            }), f.wrapMethod("getItemModel", function(g, d) {
              var A = g.parentModel, p = A.getGraph().getEdgeByIndex(d), v = p.node1.getLayout();
              if (v) {
                var y = v.depth, m = A.levelModels[y];
                m && (g.parentModel = m);
              }
              return g;
            });
          }
        }, t.prototype.setNodePosition = function(e, i) {
          var r = this.option.data || this.option.nodes, a = r[e];
          a.localX = i[0], a.localY = i[1];
        }, t.prototype.getGraph = function() {
          return this.getData().graph;
        }, t.prototype.getEdgeData = function() {
          return this.getGraph().edgeData;
        }, t.prototype.formatTooltip = function(e, i, r) {
          function a(g) {
            return isNaN(g) || g == null;
          }
          if (r === "edge") {
            var o = this.getDataParams(e, r), s = o.data, l = o.value, u = s.source + " -- " + s.target;
            return Zn("nameValue", { name: u, value: l, noValue: a(l) });
          } else {
            var h = this.getGraph().getNodeByIndex(e), c = h.getLayout().value, f = this.getDataParams(e, r).data.name;
            return Zn("nameValue", { name: f != null ? f + "" : null, value: c, noValue: a(c) });
          }
        }, t.prototype.optionUpdated = function() {
        }, t.prototype.getDataParams = function(e, i) {
          var r = n.prototype.getDataParams.call(this, e, i);
          if (r.value == null && i === "node") {
            var a = this.getGraph().getNodeByIndex(e), o = a.getLayout().value;
            r.value = o;
          }
          return r;
        }, t.type = "series.sankey", t.defaultOption = { z: 2, coordinateSystem: "view", left: "5%", top: "5%", right: "20%", bottom: "5%", orient: "horizontal", nodeWidth: 20, nodeGap: 8, draggable: true, layoutIterations: 32, label: { show: true, position: "right", fontSize: 12 }, edgeLabel: { show: false, fontSize: 12 }, levels: [], nodeAlign: "justify", lineStyle: { color: "#314656", opacity: 0.2, curveness: 0.5 }, emphasis: { label: { show: true }, lineStyle: { opacity: 0.5 } }, select: { itemStyle: { borderColor: "#212121" } }, animationEasing: "linear", animationDuration: 1e3 }, t;
      }($e);
      function gMt(n, t) {
        n.eachSeriesByType("sankey", function(e) {
          var i = e.get("nodeWidth"), r = e.get("nodeGap"), a = dMt(e, t);
          e.layoutInfo = a;
          var o = a.width, s = a.height, l = e.getGraph(), u = l.nodes, h = l.edges;
          pMt(u);
          var c = Ne(u, function(A) {
            return A.getLayout().value === 0;
          }), f = c.length !== 0 ? 0 : e.get("layoutIterations"), g = e.get("orient"), d = e.get("nodeAlign");
          AMt(u, h, i, r, o, s, f, g, d);
        });
      }
      function dMt(n, t) {
        return Gn(n.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() });
      }
      function AMt(n, t, e, i, r, a, o, s, l) {
        vMt(n, t, e, r, a, s, l), IMt(n, t, a, r, i, o, s), MMt(n, s);
      }
      function pMt(n) {
        M(n, function(t) {
          var e = du(t.outEdges, FI), i = du(t.inEdges, FI), r = t.getValue() || 0, a = Math.max(e, i, r);
          t.setLayout({ value: a }, true);
        });
      }
      function vMt(n, t, e, i, r, a, o) {
        for (var s = [], l = [], u = [], h = [], c = 0, f = 0; f < t.length; f++) s[f] = 1;
        for (var f = 0; f < n.length; f++) l[f] = n[f].inEdges.length, l[f] === 0 && u.push(n[f]);
        for (var g = -1; u.length; ) {
          for (var d = 0; d < u.length; d++) {
            var A = u[d], p = A.hostGraph.data.getRawDataItem(A.dataIndex), v = p.depth != null && p.depth >= 0;
            v && p.depth > g && (g = p.depth), A.setLayout({ depth: v ? p.depth : c }, true), a === "vertical" ? A.setLayout({ dy: e }, true) : A.setLayout({ dx: e }, true);
            for (var y = 0; y < A.outEdges.length; y++) {
              var m = A.outEdges[y], _ = t.indexOf(m);
              s[_] = 0;
              var E = m.node2, I = n.indexOf(E);
              --l[I] === 0 && h.indexOf(E) < 0 && h.push(E);
            }
          }
          ++c, u = h, h = [];
        }
        for (var f = 0; f < s.length; f++) if (s[f] === 1) throw new Error("Sankey is a DAG, the original data has cycle!");
        var x = g > c - 1 ? g : c - 1;
        o && o !== "left" && yMt(n, o, a, x);
        var w = a === "vertical" ? (r - e) / x : (i - e) / x;
        _Mt(n, w, a);
      }
      function mq(n) {
        var t = n.hostGraph.data.getRawDataItem(n.dataIndex);
        return t.depth != null && t.depth >= 0;
      }
      function yMt(n, t, e, i) {
        if (t === "right") {
          for (var r = [], a = n, o = 0; a.length; ) {
            for (var s = 0; s < a.length; s++) {
              var l = a[s];
              l.setLayout({ skNodeHeight: o }, true);
              for (var u = 0; u < l.inEdges.length; u++) {
                var h = l.inEdges[u];
                r.indexOf(h.node1) < 0 && r.push(h.node1);
              }
            }
            a = r, r = [], ++o;
          }
          M(n, function(c) {
            mq(c) || c.setLayout({ depth: Math.max(0, i - c.getLayout().skNodeHeight) }, true);
          });
        } else t === "justify" && mMt(n, i);
      }
      function mMt(n, t) {
        M(n, function(e) {
          !mq(e) && !e.outEdges.length && e.setLayout({ depth: t }, true);
        });
      }
      function _Mt(n, t, e) {
        M(n, function(i) {
          var r = i.getLayout().depth * t;
          e === "vertical" ? i.setLayout({ y: r }, true) : i.setLayout({ x: r }, true);
        });
      }
      function IMt(n, t, e, i, r, a, o) {
        var s = EMt(n, o);
        xMt(s, t, e, i, r, o), sD(s, r, e, i, o);
        for (var l = 1; a > 0; a--) l *= 0.99, wMt(s, l, o), sD(s, r, e, i, o), TMt(s, l, o), sD(s, r, e, i, o);
      }
      function EMt(n, t) {
        var e = [], i = t === "vertical" ? "y" : "x", r = p2(n, function(a) {
          return a.getLayout()[i];
        });
        return r.keys.sort(function(a, o) {
          return a - o;
        }), M(r.keys, function(a) {
          e.push(r.buckets.get(a));
        }), e;
      }
      function xMt(n, t, e, i, r, a) {
        var o = 1 / 0;
        M(n, function(s) {
          var l = s.length, u = 0;
          M(s, function(c) {
            u += c.getLayout().value;
          });
          var h = a === "vertical" ? (i - (l - 1) * r) / u : (e - (l - 1) * r) / u;
          h < o && (o = h);
        }), M(n, function(s) {
          M(s, function(l, u) {
            var h = l.getLayout().value * o;
            a === "vertical" ? (l.setLayout({ x: u }, true), l.setLayout({ dx: h }, true)) : (l.setLayout({ y: u }, true), l.setLayout({ dy: h }, true));
          });
        }), M(t, function(s) {
          var l = +s.getValue() * o;
          s.setLayout({ dy: l }, true);
        });
      }
      function sD(n, t, e, i, r) {
        var a = r === "vertical" ? "x" : "y";
        M(n, function(o) {
          o.sort(function(A, p) {
            return A.getLayout()[a] - p.getLayout()[a];
          });
          for (var s, l, u, h = 0, c = o.length, f = r === "vertical" ? "dx" : "dy", g = 0; g < c; g++) l = o[g], u = h - l.getLayout()[a], u > 0 && (s = l.getLayout()[a] + u, r === "vertical" ? l.setLayout({ x: s }, true) : l.setLayout({ y: s }, true)), h = l.getLayout()[a] + l.getLayout()[f] + t;
          var d = r === "vertical" ? i : e;
          if (u = h - t - d, u > 0) {
            s = l.getLayout()[a] - u, r === "vertical" ? l.setLayout({ x: s }, true) : l.setLayout({ y: s }, true), h = s;
            for (var g = c - 2; g >= 0; --g) l = o[g], u = l.getLayout()[a] + l.getLayout()[f] + t - h, u > 0 && (s = l.getLayout()[a] - u, r === "vertical" ? l.setLayout({ x: s }, true) : l.setLayout({ y: s }, true)), h = l.getLayout()[a];
          }
        });
      }
      function wMt(n, t, e) {
        M(n.slice().reverse(), function(i) {
          M(i, function(r) {
            if (r.outEdges.length) {
              var a = du(r.outEdges, CMt, e) / du(r.outEdges, FI);
              if (isNaN(a)) {
                var o = r.outEdges.length;
                a = o ? du(r.outEdges, SMt, e) / o : 0;
              }
              if (e === "vertical") {
                var s = r.getLayout().x + (a - gu(r, e)) * t;
                r.setLayout({ x: s }, true);
              } else {
                var l = r.getLayout().y + (a - gu(r, e)) * t;
                r.setLayout({ y: l }, true);
              }
            }
          });
        });
      }
      function CMt(n, t) {
        return gu(n.node2, t) * n.getValue();
      }
      function SMt(n, t) {
        return gu(n.node2, t);
      }
      function bMt(n, t) {
        return gu(n.node1, t) * n.getValue();
      }
      function BMt(n, t) {
        return gu(n.node1, t);
      }
      function gu(n, t) {
        return t === "vertical" ? n.getLayout().x + n.getLayout().dx / 2 : n.getLayout().y + n.getLayout().dy / 2;
      }
      function FI(n) {
        return n.getValue();
      }
      function du(n, t, e) {
        for (var i = 0, r = n.length, a = -1; ++a < r; ) {
          var o = +t(n[a], e);
          isNaN(o) || (i += o);
        }
        return i;
      }
      function TMt(n, t, e) {
        M(n, function(i) {
          M(i, function(r) {
            if (r.inEdges.length) {
              var a = du(r.inEdges, bMt, e) / du(r.inEdges, FI);
              if (isNaN(a)) {
                var o = r.inEdges.length;
                a = o ? du(r.inEdges, BMt, e) / o : 0;
              }
              if (e === "vertical") {
                var s = r.getLayout().x + (a - gu(r, e)) * t;
                r.setLayout({ x: s }, true);
              } else {
                var l = r.getLayout().y + (a - gu(r, e)) * t;
                r.setLayout({ y: l }, true);
              }
            }
          });
        });
      }
      function MMt(n, t) {
        var e = t === "vertical" ? "x" : "y";
        M(n, function(i) {
          i.outEdges.sort(function(r, a) {
            return r.node2.getLayout()[e] - a.node2.getLayout()[e];
          }), i.inEdges.sort(function(r, a) {
            return r.node1.getLayout()[e] - a.node1.getLayout()[e];
          });
        }), M(n, function(i) {
          var r = 0, a = 0;
          M(i.outEdges, function(o) {
            o.setLayout({ sy: r }, true), r += o.getLayout().dy;
          }), M(i.inEdges, function(o) {
            o.setLayout({ ty: a }, true), a += o.getLayout().dy;
          });
        });
      }
      function DMt(n) {
        n.eachSeriesByType("sankey", function(t) {
          var e = t.getGraph(), i = e.nodes, r = e.edges;
          if (i.length) {
            var a = 1 / 0, o = -1 / 0;
            M(i, function(s) {
              var l = s.getLayout().value;
              l < a && (a = l), l > o && (o = l);
            }), M(i, function(s) {
              var l = new $n({ type: "color", mappingMethod: "linear", dataExtent: [a, o], visual: t.get("color") }), u = l.mapValueToVisual(s.getLayout().value), h = s.getModel().get(["itemStyle", "color"]);
              h != null ? (s.setVisual("color", h), s.setVisual("style", { fill: h })) : (s.setVisual("color", u), s.setVisual("style", { fill: u }));
            });
          }
          r.length && M(r, function(s) {
            var l = s.getModel().get("lineStyle");
            s.setVisual("style", l);
          });
        });
      }
      function RMt(n) {
        n.registerChartView(hMt), n.registerSeriesModel(fMt), n.registerLayout(gMt), n.registerVisual(DMt), n.registerAction({ type: "dragNode", event: "dragnode", update: "update" }, function(t, e) {
          e.eachComponent({ mainType: "series", subType: "sankey", query: t }, function(i) {
            i.setNodePosition(t.dataIndex, [t.localX, t.localY]);
          });
        });
      }
      var _q = function() {
        function n() {
        }
        return n.prototype.getInitialData = function(t, e) {
          var i, r = e.getComponent("xAxis", this.get("xAxisIndex")), a = e.getComponent("yAxis", this.get("yAxisIndex")), o = r.get("type"), s = a.get("type"), l;
          o === "category" ? (t.layout = "horizontal", i = r.getOrdinalMeta(), l = true) : s === "category" ? (t.layout = "vertical", i = a.getOrdinalMeta(), l = true) : t.layout = t.layout || "horizontal";
          var u = ["x", "y"], h = t.layout === "horizontal" ? 0 : 1, c = this._baseAxisDim = u[h], f = u[1 - h], g = [r, a], d = g[h].get("type"), A = g[1 - h].get("type"), p = t.data;
          if (p && l) {
            var v = [];
            M(p, function(_, E) {
              var I;
              X(_) ? (I = _.slice(), _.unshift(E)) : X(_.value) ? (I = Y({}, _), I.value = I.value.slice(), _.value.unshift(E)) : I = _, v.push(I);
            }), t.data = v;
          }
          var y = this.defaultValueDimensions, m = [{ name: c, type: Y1(d), ordinalMeta: i, otherDims: { tooltip: false, itemName: 0 }, dimsDef: ["base"] }, { name: f, type: Y1(A), dimsDef: y.slice() }];
          return Jg(this, { coordDimensions: m, dimensionsCount: y.length + 1, encodeDefaulter: Ot(k4, m, this) });
        }, n.prototype.getBaseAxis = function() {
          var t = this._baseAxisDim;
          return this.ecModel.getComponent(t + "Axis", this.get(t + "AxisIndex")).axis;
        }, n;
      }(), Iq = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.defaultValueDimensions = [{ name: "min", defaultTooltip: true }, { name: "Q1", defaultTooltip: true }, { name: "median", defaultTooltip: true }, { name: "Q3", defaultTooltip: true }, { name: "max", defaultTooltip: true }], e.visualDrawType = "stroke", e;
        }
        return t.type = "series.boxplot", t.dependencies = ["xAxis", "yAxis", "grid"], t.defaultOption = { z: 2, coordinateSystem: "cartesian2d", legendHoverLink: true, layout: null, boxWidth: [7, 50], itemStyle: { color: "#fff", borderWidth: 1 }, emphasis: { scale: true, itemStyle: { borderWidth: 2, shadowBlur: 5, shadowOffsetX: 1, shadowOffsetY: 1, shadowColor: "rgba(0,0,0,0.2)" } }, animationDuration: 800 }, t;
      }($e);
      Mn(Iq, _q, true);
      var LMt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = e.getData(), o = this.group, s = this._data;
          this._data || o.removeAll();
          var l = e.get("layout") === "horizontal" ? 1 : 0;
          a.diff(s).add(function(u) {
            if (a.hasValue(u)) {
              var h = a.getItemLayout(u), c = Eq(h, a, u, l, true);
              a.setItemGraphicEl(u, c), o.add(c);
            }
          }).update(function(u, h) {
            var c = s.getItemGraphicEl(h);
            if (!a.hasValue(u)) {
              o.remove(c);
              return;
            }
            var f = a.getItemLayout(u);
            c ? (Ya(c), xq(f, c, a, u)) : c = Eq(f, a, u, l), o.add(c), a.setItemGraphicEl(u, c);
          }).remove(function(u) {
            var h = s.getItemGraphicEl(u);
            h && o.remove(h);
          }).execute(), this._data = a;
        }, t.prototype.remove = function(e) {
          var i = this.group, r = this._data;
          this._data = null, r && r.eachItemGraphicEl(function(a) {
            a && i.remove(a);
          });
        }, t.type = "boxplot", t;
      }(Ve), PMt = /* @__PURE__ */ function() {
        function n() {
        }
        return n;
      }(), NMt = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "boxplotBoxPath", i;
        }
        return t.prototype.getDefaultShape = function() {
          return new PMt();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.points, a = 0;
          for (e.moveTo(r[a][0], r[a][1]), a++; a < 4; a++) e.lineTo(r[a][0], r[a][1]);
          for (e.closePath(); a < r.length; a++) e.moveTo(r[a][0], r[a][1]), a++, e.lineTo(r[a][0], r[a][1]);
        }, t;
      }(Jt);
      function Eq(n, t, e, i, r) {
        var a = n.ends, o = new NMt({ shape: { points: r ? kMt(a, i, n) : a } });
        return xq(n, o, t, e, r), o;
      }
      function xq(n, t, e, i, r) {
        var a = e.hostModel, o = Ph[r ? "initProps" : "updateProps"];
        o(t, { shape: { points: n.ends } }, a, i), t.useStyle(e.getItemVisual(i, "style")), t.style.strokeNoScale = true, t.z2 = 100;
        var s = e.getItemModel(i), l = s.getModel("emphasis");
        pi(t, s), hn(t, l.get("focus"), l.get("blurScope"), l.get("disabled"));
      }
      function kMt(n, t, e) {
        return Z(n, function(i) {
          return i = i.slice(), i[t] = e.initBaseline, i;
        });
      }
      var Xv = M;
      function FMt(n) {
        var t = QMt(n);
        Xv(t, function(e) {
          var i = e.seriesModels;
          i.length && (OMt(e), Xv(i, function(r, a) {
            zMt(r, e.boxOffsetList[a], e.boxWidthList[a]);
          }));
        });
      }
      function QMt(n) {
        var t = [], e = [];
        return n.eachSeriesByType("boxplot", function(i) {
          var r = i.getBaseAxis(), a = Wt(e, r);
          a < 0 && (a = e.length, e[a] = r, t[a] = { axis: r, seriesModels: [] }), t[a].seriesModels.push(i);
        }), t;
      }
      function OMt(n) {
        var t = n.axis, e = n.seriesModels, i = e.length, r = n.boxWidthList = [], a = n.boxOffsetList = [], o = [], s;
        if (t.type === "category") s = t.getBandWidth();
        else {
          var l = 0;
          Xv(e, function(d) {
            l = Math.max(l, d.getData().count());
          });
          var u = t.getExtent();
          s = Math.abs(u[1] - u[0]) / l;
        }
        Xv(e, function(d) {
          var A = d.get("boxWidth");
          X(A) || (A = [A, A]), o.push([ot(A[0], s) || 0, ot(A[1], s) || 0]);
        });
        var h = s * 0.8 - 2, c = h / i * 0.3, f = (h - c * (i - 1)) / i, g = f / 2 - h / 2;
        Xv(e, function(d, A) {
          a.push(g), g += c + f, r.push(Math.min(Math.max(f, o[A][0]), o[A][1]));
        });
      }
      function zMt(n, t, e) {
        var i = n.coordinateSystem, r = n.getData(), a = e / 2, o = n.get("layout") === "horizontal" ? 0 : 1, s = 1 - o, l = ["x", "y"], u = r.mapDimension(l[o]), h = r.mapDimensionsAll(l[s]);
        if (u == null || h.length < 5) return;
        for (var c = 0; c < r.count(); c++) {
          var f = r.get(u, c), g = m(f, h[2], c), d = m(f, h[0], c), A = m(f, h[1], c), p = m(f, h[3], c), v = m(f, h[4], c), y = [];
          _(y, A, false), _(y, p, true), y.push(d, A, v, p), E(y, d), E(y, v), E(y, g), r.setItemLayout(c, { initBaseline: g[s], ends: y });
        }
        function m(I, x, w) {
          var C = r.get(x, w), S = [];
          S[o] = I, S[s] = C;
          var b;
          return isNaN(I) || isNaN(C) ? b = [NaN, NaN] : (b = i.dataToPoint(S), b[o] += t), b;
        }
        function _(I, x, w) {
          var C = x.slice(), S = x.slice();
          C[o] += a, S[o] -= a, w ? I.push(C, S) : I.push(S, C);
        }
        function E(I, x) {
          var w = x.slice(), C = x.slice();
          w[o] -= a, C[o] += a, I.push(w, C);
        }
      }
      function GMt(n, t) {
        t = t || {};
        for (var e = [], i = [], r = t.boundIQR, a = r === "none" || r === 0, o = 0; o < n.length; o++) {
          var s = ua(n[o].slice()), l = f2(s, 0.25), u = f2(s, 0.5), h = f2(s, 0.75), c = s[0], f = s[s.length - 1], g = (r == null ? 1.5 : r) * (h - l), d = a ? c : Math.max(c, l - g), A = a ? f : Math.min(f, h + g), p = t.itemNameFormatter, v = yt(p) ? p({ value: o }) : ht(p) ? p.replace("{value}", o + "") : o + "";
          e.push([v, d, l, u, h, A]);
          for (var y = 0; y < s.length; y++) {
            var m = s[y];
            if (m < d || m > A) {
              var _ = [v, m];
              i.push(_);
            }
          }
        }
        return { boxData: e, outliers: i };
      }
      var UMt = { type: "echarts:boxplot", transform: function(t) {
        var e = t.upstream;
        if (e.sourceFormat !== Ri) {
          var i = "";
          i = vr("source data is not applicable for this boxplot transform. Expect number[][]."), Ce(i);
        }
        var r = GMt(e.getRawData(), t.config);
        return [{ dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"], data: r.boxData }, { data: r.outliers }];
      } };
      function VMt(n) {
        n.registerSeriesModel(Iq), n.registerChartView(LMt), n.registerLayout(FMt), n.registerTransform(UMt);
      }
      var jMt = ["color", "borderColor"], qMt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(e), this._isLargeDraw ? this._renderLarge(e) : this._renderNormal(e);
        }, t.prototype.incrementalPrepareRender = function(e, i, r) {
          this._clear(), this._updateDrawMode(e);
        }, t.prototype.incrementalRender = function(e, i, r, a) {
          this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(e, i) : this._incrementalRenderNormal(e, i);
        }, t.prototype.eachRendered = function(e) {
          tu(this._progressiveEls || this.group, e);
        }, t.prototype._updateDrawMode = function(e) {
          var i = e.pipelineContext.large;
          (this._isLargeDraw == null || i !== this._isLargeDraw) && (this._isLargeDraw = i, this._clear());
        }, t.prototype._renderNormal = function(e) {
          var i = e.getData(), r = this._data, a = this.group, o = i.getLayout("isSimpleBox"), s = e.get("clip", true), l = e.coordinateSystem, u = l.getArea && l.getArea();
          this._data || a.removeAll(), i.diff(r).add(function(h) {
            if (i.hasValue(h)) {
              var c = i.getItemLayout(h);
              if (s && wq(u, c)) return;
              var f = lD(c, h, true);
              nn(f, { shape: { points: c.ends } }, e, h), uD(f, i, h, o), a.add(f), i.setItemGraphicEl(h, f);
            }
          }).update(function(h, c) {
            var f = r.getItemGraphicEl(c);
            if (!i.hasValue(h)) {
              a.remove(f);
              return;
            }
            var g = i.getItemLayout(h);
            if (s && wq(u, g)) {
              a.remove(f);
              return;
            }
            f ? (_e(f, { shape: { points: g.ends } }, e, h), Ya(f)) : f = lD(g), uD(f, i, h, o), a.add(f), i.setItemGraphicEl(h, f);
          }).remove(function(h) {
            var c = r.getItemGraphicEl(h);
            c && a.remove(c);
          }).execute(), this._data = i;
        }, t.prototype._renderLarge = function(e) {
          this._clear(), Cq(e, this.group);
          var i = e.get("clip", true) ? bv(e.coordinateSystem, false, e) : null;
          i ? this.group.setClipPath(i) : this.group.removeClipPath();
        }, t.prototype._incrementalRenderNormal = function(e, i) {
          for (var r = i.getData(), a = r.getLayout("isSimpleBox"), o; (o = e.next()) != null; ) {
            var s = r.getItemLayout(o), l = lD(s);
            uD(l, r, o, a), l.incremental = true, this.group.add(l), this._progressiveEls.push(l);
          }
        }, t.prototype._incrementalRenderLarge = function(e, i) {
          Cq(i, this.group, this._progressiveEls, true);
        }, t.prototype.remove = function(e) {
          this._clear();
        }, t.prototype._clear = function() {
          this.group.removeAll(), this._data = null;
        }, t.type = "candlestick", t;
      }(Ve), HMt = /* @__PURE__ */ function() {
        function n() {
        }
        return n;
      }(), YMt = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "normalCandlestickBox", i;
        }
        return t.prototype.getDefaultShape = function() {
          return new HMt();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.points;
          this.__simpleBox ? (e.moveTo(r[4][0], r[4][1]), e.lineTo(r[6][0], r[6][1])) : (e.moveTo(r[0][0], r[0][1]), e.lineTo(r[1][0], r[1][1]), e.lineTo(r[2][0], r[2][1]), e.lineTo(r[3][0], r[3][1]), e.closePath(), e.moveTo(r[4][0], r[4][1]), e.lineTo(r[5][0], r[5][1]), e.moveTo(r[6][0], r[6][1]), e.lineTo(r[7][0], r[7][1]));
        }, t;
      }(Jt);
      function lD(n, t, e) {
        var i = n.ends;
        return new YMt({ shape: { points: e ? WMt(i, n) : i }, z2: 100 });
      }
      function wq(n, t) {
        for (var e = true, i = 0; i < t.ends.length; i++) if (n.contain(t.ends[i][0], t.ends[i][1])) {
          e = false;
          break;
        }
        return e;
      }
      function uD(n, t, e, i) {
        var r = t.getItemModel(e);
        n.useStyle(t.getItemVisual(e, "style")), n.style.strokeNoScale = true, n.__simpleBox = i, pi(n, r);
      }
      function WMt(n, t) {
        return Z(n, function(e) {
          return e = e.slice(), e[1] = t.initBaseline, e;
        });
      }
      var XMt = /* @__PURE__ */ function() {
        function n() {
        }
        return n;
      }(), hD = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "largeCandlestickBox", i;
        }
        return t.prototype.getDefaultShape = function() {
          return new XMt();
        }, t.prototype.buildPath = function(e, i) {
          for (var r = i.points, a = 0; a < r.length; ) if (this.__sign === r[a++]) {
            var o = r[a++];
            e.moveTo(o, r[a++]), e.lineTo(o, r[a++]);
          } else a += 3;
        }, t;
      }(Jt);
      function Cq(n, t, e, i) {
        var r = n.getData(), a = r.getLayout("largePoints"), o = new hD({ shape: { points: a }, __sign: 1, ignoreCoarsePointer: true });
        t.add(o);
        var s = new hD({ shape: { points: a }, __sign: -1, ignoreCoarsePointer: true });
        t.add(s);
        var l = new hD({ shape: { points: a }, __sign: 0, ignoreCoarsePointer: true });
        t.add(l), cD(1, o, n), cD(-1, s, n), cD(0, l, n), i && (o.incremental = true, s.incremental = true), e && e.push(o, s);
      }
      function cD(n, t, e, i) {
        var r = e.get(["itemStyle", n > 0 ? "borderColor" : "borderColor0"]) || e.get(["itemStyle", n > 0 ? "color" : "color0"]);
        n === 0 && (r = e.get(["itemStyle", "borderColorDoji"]));
        var a = e.getModel("itemStyle").getItemStyle(jMt);
        t.useStyle(a), t.style.fill = null, t.style.stroke = r;
      }
      var Sq = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.defaultValueDimensions = [{ name: "open", defaultTooltip: true }, { name: "close", defaultTooltip: true }, { name: "lowest", defaultTooltip: true }, { name: "highest", defaultTooltip: true }], e;
        }
        return t.prototype.getShadowDim = function() {
          return "open";
        }, t.prototype.brushSelector = function(e, i, r) {
          var a = i.getItemLayout(e);
          return a && r.rect(a.brushRect);
        }, t.type = "series.candlestick", t.dependencies = ["xAxis", "yAxis", "grid"], t.defaultOption = { z: 2, coordinateSystem: "cartesian2d", legendHoverLink: true, layout: null, clip: true, itemStyle: { color: "#eb5454", color0: "#47b262", borderColor: "#eb5454", borderColor0: "#47b262", borderColorDoji: null, borderWidth: 1 }, emphasis: { scale: true, itemStyle: { borderWidth: 2 } }, barMaxWidth: null, barMinWidth: null, barWidth: null, large: true, largeThreshold: 600, progressive: 3e3, progressiveThreshold: 1e4, progressiveChunkMode: "mod", animationEasing: "linear", animationDuration: 300 }, t;
      }($e);
      Mn(Sq, _q, true);
      function ZMt(n) {
        !n || !X(n.series) || M(n.series, function(t) {
          _t(t) && t.type === "k" && (t.type = "candlestick");
        });
      }
      var KMt = ["itemStyle", "borderColor"], $Mt = ["itemStyle", "borderColor0"], JMt = ["itemStyle", "borderColorDoji"], tDt = ["itemStyle", "color"], eDt = ["itemStyle", "color0"], nDt = { seriesType: "candlestick", plan: zg(), performRawSeries: true, reset: function(n, t) {
        function e(a, o) {
          return o.get(a > 0 ? tDt : eDt);
        }
        function i(a, o) {
          return o.get(a === 0 ? JMt : a > 0 ? KMt : $Mt);
        }
        if (!t.isSeriesFiltered(n)) {
          var r = n.pipelineContext.large;
          return !r && { progress: function(a, o) {
            for (var s; (s = a.next()) != null; ) {
              var l = o.getItemModel(s), u = o.getItemLayout(s).sign, h = l.getItemStyle();
              h.fill = e(u, l), h.stroke = i(u, l) || h.fill;
              var c = o.ensureUniqueItemVisual(s, "style");
              Y(c, h);
            }
          } };
        }
      } }, iDt = { seriesType: "candlestick", plan: zg(), reset: function(n) {
        var t = n.coordinateSystem, e = n.getData(), i = rDt(n, e), r = 0, a = 1, o = ["x", "y"], s = e.getDimensionIndex(e.mapDimension(o[r])), l = Z(e.mapDimensionsAll(o[a]), e.getDimensionIndex, e), u = l[0], h = l[1], c = l[2], f = l[3];
        if (e.setLayout({ candleWidth: i, isSimpleBox: i <= 1.3 }), s < 0 || l.length < 4) return;
        return { progress: n.pipelineContext.large ? d : g };
        function g(A, p) {
          for (var v, y = p.getStore(); (v = A.next()) != null; ) {
            var m = y.get(s, v), _ = y.get(u, v), E = y.get(h, v), I = y.get(c, v), x = y.get(f, v), w = Math.min(_, E), C = Math.max(_, E), S = k(w, m), b = k(C, m), B = k(I, m), T = k(x, m), D = [];
            P(D, b, 0), P(D, S, 1), D.push(Q(T), Q(b), Q(B), Q(S));
            var R = p.getItemModel(v), L = !!R.get(["itemStyle", "borderColorDoji"]);
            p.setItemLayout(v, { sign: bq(y, v, _, E, h, L), initBaseline: _ > E ? b[a] : S[a], ends: D, brushRect: F(I, x, m) });
          }
          function k(z, j) {
            var $ = [];
            return $[r] = j, $[a] = z, isNaN(j) || isNaN(z) ? [NaN, NaN] : t.dataToPoint($);
          }
          function P(z, j, $) {
            var G = j.slice(), tt = j.slice();
            G[r] = c1(G[r] + i / 2, 1, false), tt[r] = c1(tt[r] - i / 2, 1, true), $ ? z.push(G, tt) : z.push(tt, G);
          }
          function F(z, j, $) {
            var G = k(z, $), tt = k(j, $);
            return G[r] -= i / 2, tt[r] -= i / 2, { x: G[0], y: G[1], width: i, height: tt[1] - G[1] };
          }
          function Q(z) {
            return z[r] = c1(z[r], 1), z;
          }
        }
        function d(A, p) {
          for (var v = Uo(A.count * 4), y = 0, m, _ = [], E = [], I, x = p.getStore(), w = !!n.get(["itemStyle", "borderColorDoji"]); (I = A.next()) != null; ) {
            var C = x.get(s, I), S = x.get(u, I), b = x.get(h, I), B = x.get(c, I), T = x.get(f, I);
            if (isNaN(C) || isNaN(B) || isNaN(T)) {
              v[y++] = NaN, y += 3;
              continue;
            }
            v[y++] = bq(x, I, S, b, h, w), _[r] = C, _[a] = B, m = t.dataToPoint(_, null, E), v[y++] = m ? m[0] : NaN, v[y++] = m ? m[1] : NaN, _[a] = T, m = t.dataToPoint(_, null, E), v[y++] = m ? m[1] : NaN;
          }
          p.setLayout("largePoints", v);
        }
      } };
      function bq(n, t, e, i, r, a) {
        var o;
        return e > i ? o = -1 : e < i ? o = 1 : o = a ? 0 : t > 0 ? n.get(r, t - 1) <= i ? 1 : -1 : 1, o;
      }
      function rDt(n, t) {
        var e = n.getBaseAxis(), i, r = e.type === "category" ? e.getBandWidth() : (i = e.getExtent(), Math.abs(i[1] - i[0]) / t.count()), a = ot(Pt(n.get("barMaxWidth"), r), r), o = ot(Pt(n.get("barMinWidth"), 1), r), s = n.get("barWidth");
        return s != null ? ot(s, r) : Math.max(Math.min(r / 2, a), o);
      }
      function aDt(n) {
        n.registerChartView(qMt), n.registerSeriesModel(Sq), n.registerPreprocessor(ZMt), n.registerVisual(nDt), n.registerLayout(iDt);
      }
      function Bq(n, t) {
        var e = t.rippleEffectColor || t.color;
        n.eachChild(function(i) {
          i.attr({ z: t.z, zlevel: t.zlevel, style: { stroke: t.brushType === "stroke" ? e : null, fill: t.brushType === "fill" ? e : null } });
        });
      }
      var oDt = function(n) {
        V(t, n);
        function t(e, i) {
          var r = n.call(this) || this, a = new Cv(e, i), o = new Ct();
          return r.add(a), r.add(o), r.updateData(e, i), r;
        }
        return t.prototype.stopEffectAnimation = function() {
          this.childAt(1).removeAll();
        }, t.prototype.startEffectAnimation = function(e) {
          for (var i = e.symbolType, r = e.color, a = e.rippleNumber, o = this.childAt(1), s = 0; s < a; s++) {
            var l = Nn(i, -1, -1, 2, 2, r);
            l.attr({ style: { strokeNoScale: true }, z2: 99, silent: true, scaleX: 0.5, scaleY: 0.5 });
            var u = -s / a * e.period + e.effectOffset;
            l.animate("", true).when(e.period, { scaleX: e.rippleScale / 2, scaleY: e.rippleScale / 2 }).delay(u).start(), l.animateStyle(true).when(e.period, { opacity: 0 }).delay(u).start(), o.add(l);
          }
          Bq(o, e);
        }, t.prototype.updateEffectAnimation = function(e) {
          for (var i = this._effectCfg, r = this.childAt(1), a = ["symbolType", "period", "rippleScale", "rippleNumber"], o = 0; o < a.length; o++) {
            var s = a[o];
            if (i[s] !== e[s]) {
              this.stopEffectAnimation(), this.startEffectAnimation(e);
              return;
            }
          }
          Bq(r, e);
        }, t.prototype.highlight = function() {
          Ps(this);
        }, t.prototype.downplay = function() {
          Ns(this);
        }, t.prototype.getSymbolType = function() {
          var e = this.childAt(0);
          return e && e.getSymbolType();
        }, t.prototype.updateData = function(e, i) {
          var r = this, a = e.hostModel;
          this.childAt(0).updateData(e, i);
          var o = this.childAt(1), s = e.getItemModel(i), l = e.getItemVisual(i, "symbol"), u = Vg(e.getItemVisual(i, "symbolSize")), h = e.getItemVisual(i, "style"), c = h && h.fill, f = s.getModel("emphasis");
          o.setScale(u), o.traverse(function(p) {
            p.setStyle("fill", c);
          });
          var g = Uh(e.getItemVisual(i, "symbolOffset"), u);
          g && (o.x = g[0], o.y = g[1]);
          var d = e.getItemVisual(i, "symbolRotate");
          o.rotation = (d || 0) * Math.PI / 180 || 0;
          var A = {};
          A.showEffectOn = a.get("showEffectOn"), A.rippleScale = s.get(["rippleEffect", "scale"]), A.brushType = s.get(["rippleEffect", "brushType"]), A.period = s.get(["rippleEffect", "period"]) * 1e3, A.effectOffset = i / e.count(), A.z = a.getShallow("z") || 0, A.zlevel = a.getShallow("zlevel") || 0, A.symbolType = l, A.color = c, A.rippleEffectColor = s.get(["rippleEffect", "color"]), A.rippleNumber = s.get(["rippleEffect", "number"]), A.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(A) : this.startEffectAnimation(A), this._effectCfg = A) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(p) {
            p === "emphasis" ? A.showEffectOn !== "render" && r.startEffectAnimation(A) : p === "normal" && A.showEffectOn !== "render" && r.stopEffectAnimation();
          }), this._effectCfg = A, hn(this, f.get("focus"), f.get("blurScope"), f.get("disabled"));
        }, t.prototype.fadeOut = function(e) {
          e && e();
        }, t;
      }(Ct), sDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function() {
          this._symbolDraw = new Sv(oDt);
        }, t.prototype.render = function(e, i, r) {
          var a = e.getData(), o = this._symbolDraw;
          o.updateData(a, { clipShape: this._getClipShape(e) }), this.group.add(o.group);
        }, t.prototype._getClipShape = function(e) {
          var i = e.coordinateSystem, r = i && i.getArea && i.getArea();
          return e.get("clip", true) ? r : null;
        }, t.prototype.updateTransform = function(e, i, r) {
          var a = e.getData();
          this.group.dirty();
          var o = Bv("").reset(e, i, r);
          o.progress && o.progress({ start: 0, end: a.count(), count: a.count() }, a), this._symbolDraw.updateLayout();
        }, t.prototype._updateGroupTransform = function(e) {
          var i = e.coordinateSystem;
          i && i.getRoamTransform && (this.group.transform = T0t(i.getRoamTransform()), this.group.decomposeTransform());
        }, t.prototype.remove = function(e, i) {
          this._symbolDraw && this._symbolDraw.remove(true);
        }, t.type = "effectScatter", t;
      }(Ve), lDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.hasSymbolVisual = true, e;
        }
        return t.prototype.getInitialData = function(e, i) {
          return zs(null, this, { useEncodeDefaulter: true });
        }, t.prototype.brushSelector = function(e, i, r) {
          return r.point(i.getItemLayout(e));
        }, t.type = "series.effectScatter", t.dependencies = ["grid", "polar"], t.defaultOption = { coordinateSystem: "cartesian2d", z: 2, legendHoverLink: true, effectType: "ripple", progressive: 0, showEffectOn: "render", clip: true, rippleEffect: { period: 4, scale: 2.5, brushType: "fill", number: 3 }, universalTransition: { divideShape: "clone" }, symbolSize: 10 }, t;
      }($e);
      function uDt(n) {
        n.registerChartView(sDt), n.registerSeriesModel(lDt), n.registerLayout(Bv("effectScatter"));
      }
      var Tq = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this) || this;
          return a.add(a.createLine(e, i, r)), a._updateEffectSymbol(e, i), a;
        }
        return t.prototype.createLine = function(e, i, r) {
          return new kM(e, i, r);
        }, t.prototype._updateEffectSymbol = function(e, i) {
          var r = e.getItemModel(i), a = r.getModel("effect"), o = a.get("symbolSize"), s = a.get("symbol");
          X(o) || (o = [o, o]);
          var l = e.getItemVisual(i, "style"), u = a.get("color") || l && l.stroke, h = this.childAt(1);
          this._symbolType !== s && (this.remove(h), h = Nn(s, -0.5, -0.5, 1, 1, u), h.z2 = 100, h.culling = true, this.add(h)), h && (h.setStyle("shadowColor", u), h.setStyle(a.getItemStyle(["color"])), h.scaleX = o[0], h.scaleY = o[1], h.setColor(u), this._symbolType = s, this._symbolScale = o, this._updateEffectAnimation(e, a, i));
        }, t.prototype._updateEffectAnimation = function(e, i, r) {
          var a = this.childAt(1);
          if (a) {
            var o = e.getItemLayout(r), s = i.get("period") * 1e3, l = i.get("loop"), u = i.get("roundTrip"), h = i.get("constantSpeed"), c = Dn(i.get("delay"), function(g) {
              return g / e.count() * s / 3;
            });
            if (a.ignore = true, this._updateAnimationPoints(a, o), h > 0 && (s = this._getLineLength(a) / h * 1e3), s !== this._period || l !== this._loop || u !== this._roundTrip) {
              a.stopAnimation();
              var f = void 0;
              yt(c) ? f = c(r) : f = c, a.__t > 0 && (f = -s * a.__t), this._animateSymbol(a, s, f, l, u);
            }
            this._period = s, this._loop = l, this._roundTrip = u;
          }
        }, t.prototype._animateSymbol = function(e, i, r, a, o) {
          if (i > 0) {
            e.__t = 0;
            var s = this, l = e.animate("", a).when(o ? i * 2 : i, { __t: o ? 2 : 1 }).delay(r).during(function() {
              s._updateSymbolPosition(e);
            });
            a || l.done(function() {
              s.remove(e);
            }), l.start();
          }
        }, t.prototype._getLineLength = function(e) {
          return zl(e.__p1, e.__cp1) + zl(e.__cp1, e.__p2);
        }, t.prototype._updateAnimationPoints = function(e, i) {
          e.__p1 = i[0], e.__p2 = i[1], e.__cp1 = i[2] || [(i[0][0] + i[1][0]) / 2, (i[0][1] + i[1][1]) / 2];
        }, t.prototype.updateData = function(e, i, r) {
          this.childAt(0).updateData(e, i, r), this._updateEffectSymbol(e, i);
        }, t.prototype._updateSymbolPosition = function(e) {
          var i = e.__p1, r = e.__p2, a = e.__cp1, o = e.__t < 1 ? e.__t : 2 - e.__t, s = [e.x, e.y], l = s.slice(), u = si, h = Lb;
          s[0] = u(i[0], a[0], r[0], o), s[1] = u(i[1], a[1], r[1], o);
          var c = e.__t < 1 ? h(i[0], a[0], r[0], o) : h(r[0], a[0], i[0], 1 - o), f = e.__t < 1 ? h(i[1], a[1], r[1], o) : h(r[1], a[1], i[1], 1 - o);
          e.rotation = -Math.atan2(f, c) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (e.__lastT !== void 0 && e.__lastT < e.__t ? (e.scaleY = zl(l, s) * 1.05, o === 1 && (s[0] = l[0] + (s[0] - l[0]) / 2, s[1] = l[1] + (s[1] - l[1]) / 2)) : e.__lastT === 1 ? e.scaleY = 2 * zl(i, s) : e.scaleY = this._symbolScale[1]), e.__lastT = e.__t, e.ignore = false, e.x = s[0], e.y = s[1];
        }, t.prototype.updateLayout = function(e, i) {
          this.childAt(0).updateLayout(e, i);
          var r = e.getItemModel(i).getModel("effect");
          this._updateEffectAnimation(e, r, i);
        }, t;
      }(Ct), Mq = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this) || this;
          return a._createPolyline(e, i, r), a;
        }
        return t.prototype._createPolyline = function(e, i, r) {
          var a = e.getItemLayout(i), o = new Wi({ shape: { points: a } });
          this.add(o), this._updateCommonStl(e, i, r);
        }, t.prototype.updateData = function(e, i, r) {
          var a = e.hostModel, o = this.childAt(0), s = { shape: { points: e.getItemLayout(i) } };
          _e(o, s, a, i), this._updateCommonStl(e, i, r);
        }, t.prototype._updateCommonStl = function(e, i, r) {
          var a = this.childAt(0), o = e.getItemModel(i), s = r && r.emphasisLineStyle, l = r && r.focus, u = r && r.blurScope, h = r && r.emphasisDisabled;
          if (!r || e.hasItemOption) {
            var c = o.getModel("emphasis");
            s = c.getModel("lineStyle").getLineStyle(), h = c.get("disabled"), l = c.get("focus"), u = c.get("blurScope");
          }
          a.useStyle(e.getItemVisual(i, "style")), a.style.fill = null, a.style.strokeNoScale = true;
          var f = a.ensureState("emphasis");
          f.style = s, hn(this, l, u, h);
        }, t.prototype.updateLayout = function(e, i) {
          var r = this.childAt(0);
          r.setShape("points", e.getItemLayout(i));
        }, t;
      }(Ct), hDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e._lastFrame = 0, e._lastFramePercent = 0, e;
        }
        return t.prototype.createLine = function(e, i, r) {
          return new Mq(e, i, r);
        }, t.prototype._updateAnimationPoints = function(e, i) {
          this._points = i;
          for (var r = [0], a = 0, o = 1; o < i.length; o++) {
            var s = i[o - 1], l = i[o];
            a += zl(s, l), r.push(a);
          }
          if (a === 0) {
            this._length = 0;
            return;
          }
          for (var o = 0; o < r.length; o++) r[o] /= a;
          this._offsets = r, this._length = a;
        }, t.prototype._getLineLength = function() {
          return this._length;
        }, t.prototype._updateSymbolPosition = function(e) {
          var i = e.__t < 1 ? e.__t : 2 - e.__t, r = this._points, a = this._offsets, o = r.length;
          if (a) {
            var s = this._lastFrame, l;
            if (i < this._lastFramePercent) {
              var u = Math.min(s + 1, o - 1);
              for (l = u; l >= 0 && !(a[l] <= i); l--) ;
              l = Math.min(l, o - 2);
            } else {
              for (l = s; l < o && !(a[l] > i); l++) ;
              l = Math.min(l - 1, o - 2);
            }
            var h = (i - a[l]) / (a[l + 1] - a[l]), c = r[l], f = r[l + 1];
            e.x = c[0] * (1 - h) + h * f[0], e.y = c[1] * (1 - h) + h * f[1];
            var g = e.__t < 1 ? f[0] - c[0] : c[0] - f[0], d = e.__t < 1 ? f[1] - c[1] : c[1] - f[1];
            e.rotation = -Math.atan2(d, g) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = i, e.ignore = false;
          }
        }, t;
      }(Tq), cDt = /* @__PURE__ */ function() {
        function n() {
          this.polyline = false, this.curveness = 0, this.segs = [];
        }
        return n;
      }(), fDt = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i._off = 0, i.hoverDataIdx = -1, i;
        }
        return t.prototype.reset = function() {
          this.notClear = false, this._off = 0;
        }, t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new cDt();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.segs, a = i.curveness, o;
          if (i.polyline) for (o = this._off; o < r.length; ) {
            var s = r[o++];
            if (s > 0) {
              e.moveTo(r[o++], r[o++]);
              for (var l = 1; l < s; l++) e.lineTo(r[o++], r[o++]);
            }
          }
          else for (o = this._off; o < r.length; ) {
            var u = r[o++], h = r[o++], c = r[o++], f = r[o++];
            if (e.moveTo(u, h), a > 0) {
              var g = (u + c) / 2 - (h - f) * a, d = (h + f) / 2 - (c - u) * a;
              e.quadraticCurveTo(g, d, c, f);
            } else e.lineTo(c, f);
          }
          this.incremental && (this._off = o, this.notClear = true);
        }, t.prototype.findDataIndex = function(e, i) {
          var r = this.shape, a = r.segs, o = r.curveness, s = this.style.lineWidth;
          if (r.polyline) for (var l = 0, u = 0; u < a.length; ) {
            var h = a[u++];
            if (h > 0) for (var c = a[u++], f = a[u++], g = 1; g < h; g++) {
              var d = a[u++], A = a[u++];
              if (Zl(c, f, d, A, s, e, i)) return l;
            }
            l++;
          }
          else for (var l = 0, u = 0; u < a.length; ) {
            var c = a[u++], f = a[u++], d = a[u++], A = a[u++];
            if (o > 0) {
              var p = (c + d) / 2 - (f - A) * o, v = (f + A) / 2 - (d - c) * o;
              if (n5(c, f, p, v, d, A, s, e, i)) return l;
            } else if (Zl(c, f, d, A, s, e, i)) return l;
            l++;
          }
          return -1;
        }, t.prototype.contain = function(e, i) {
          var r = this.transformCoordToLocal(e, i), a = this.getBoundingRect();
          if (e = r[0], i = r[1], a.contain(e, i)) {
            var o = this.hoverDataIdx = this.findDataIndex(e, i);
            return o >= 0;
          }
          return this.hoverDataIdx = -1, false;
        }, t.prototype.getBoundingRect = function() {
          var e = this._rect;
          if (!e) {
            for (var i = this.shape, r = i.segs, a = 1 / 0, o = 1 / 0, s = -1 / 0, l = -1 / 0, u = 0; u < r.length; ) {
              var h = r[u++], c = r[u++];
              a = Math.min(h, a), s = Math.max(h, s), o = Math.min(c, o), l = Math.max(c, l);
            }
            e = this._rect = new Ht(a, o, s, l);
          }
          return e;
        }, t;
      }(Jt), gDt = function() {
        function n() {
          this.group = new Ct();
        }
        return n.prototype.updateData = function(t) {
          this._clear();
          var e = this._create();
          e.setShape({ segs: t.getLayout("linesPoints") }), this._setCommon(e, t);
        }, n.prototype.incrementalPrepareUpdate = function(t) {
          this.group.removeAll(), this._clear();
        }, n.prototype.incrementalUpdate = function(t, e) {
          var i = this._newAdded[0], r = e.getLayout("linesPoints"), a = i && i.shape.segs;
          if (a && a.length < 2e4) {
            var o = a.length, s = new Float32Array(o + r.length);
            s.set(a), s.set(r, o), i.setShape({ segs: s });
          } else {
            this._newAdded = [];
            var l = this._create();
            l.incremental = true, l.setShape({ segs: r }), this._setCommon(l, e), l.__startIndex = t.start;
          }
        }, n.prototype.remove = function() {
          this._clear();
        }, n.prototype.eachRendered = function(t) {
          this._newAdded[0] && t(this._newAdded[0]);
        }, n.prototype._create = function() {
          var t = new fDt({ cursor: "default", ignoreCoarsePointer: true });
          return this._newAdded.push(t), this.group.add(t), t;
        }, n.prototype._setCommon = function(t, e, i) {
          var r = e.hostModel;
          t.setShape({ polyline: r.get("polyline"), curveness: r.get(["lineStyle", "curveness"]) }), t.useStyle(r.getModel("lineStyle").getLineStyle()), t.style.strokeNoScale = true;
          var a = e.getVisual("style");
          a && a.stroke && t.setStyle("stroke", a.stroke), t.setStyle("fill", null);
          var o = Dt(t);
          o.seriesIndex = r.seriesIndex, t.on("mousemove", function(s) {
            o.dataIndex = null;
            var l = t.hoverDataIdx;
            l > 0 && (o.dataIndex = l + t.__startIndex);
          });
        }, n.prototype._clear = function() {
          this._newAdded = [], this.group.removeAll();
        }, n;
      }(), Dq = { seriesType: "lines", plan: zg(), reset: function(n) {
        var t = n.coordinateSystem;
        if (!t) {
          Ai("The lines series must have a coordinate system.");
          return;
        }
        var e = n.get("polyline"), i = n.pipelineContext.large;
        return { progress: function(r, a) {
          var o = [];
          if (i) {
            var s = void 0, l = r.end - r.start;
            if (e) {
              for (var u = 0, h = r.start; h < r.end; h++) u += n.getLineCoordsCount(h);
              s = new Float32Array(l + u * 2);
            } else s = new Float32Array(l * 4);
            for (var c = 0, f = [], h = r.start; h < r.end; h++) {
              var g = n.getLineCoords(h, o);
              e && (s[c++] = g);
              for (var d = 0; d < g; d++) f = t.dataToPoint(o[d], false, f), s[c++] = f[0], s[c++] = f[1];
            }
            a.setLayout("linesPoints", s);
          } else for (var h = r.start; h < r.end; h++) {
            var A = a.getItemModel(h), g = n.getLineCoords(h, o), p = [];
            if (e) for (var v = 0; v < g; v++) p.push(t.dataToPoint(o[v]));
            else {
              p[0] = t.dataToPoint(o[0]), p[1] = t.dataToPoint(o[1]);
              var y = A.get(["lineStyle", "curveness"]);
              +y && (p[2] = [(p[0][0] + p[1][0]) / 2 - (p[0][1] - p[1][1]) * y, (p[0][1] + p[1][1]) / 2 - (p[1][0] - p[0][0]) * y]);
            }
            a.setItemLayout(h, p);
          }
        } };
      } }, dDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = e.getData(), o = this._updateLineDraw(a, e), s = e.get("zlevel"), l = e.get(["effect", "trailLength"]), u = r.getZr(), h = u.painter.getType() === "svg";
          h || u.painter.getLayer(s).clear(true), this._lastZlevel != null && !h && u.configLayer(this._lastZlevel, { motionBlur: false }), this._showEffect(e) && l > 0 && (h ? "development" : u.configLayer(s, { motionBlur: true, lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0) })), o.updateData(a);
          var c = e.get("clip", true) && bv(e.coordinateSystem, false, e);
          c ? this.group.setClipPath(c) : this.group.removeClipPath(), this._lastZlevel = s, this._finished = true;
        }, t.prototype.incrementalPrepareRender = function(e, i, r) {
          var a = e.getData(), o = this._updateLineDraw(a, e);
          o.incrementalPrepareUpdate(a), this._clearLayer(r), this._finished = false;
        }, t.prototype.incrementalRender = function(e, i, r) {
          this._lineDraw.incrementalUpdate(e, i.getData()), this._finished = e.end === i.getData().count();
        }, t.prototype.eachRendered = function(e) {
          this._lineDraw && this._lineDraw.eachRendered(e);
        }, t.prototype.updateTransform = function(e, i, r) {
          var a = e.getData(), o = e.pipelineContext;
          if (!this._finished || o.large || o.progressiveRender) return { update: true };
          var s = Dq.reset(e, i, r);
          s.progress && s.progress({ start: 0, end: a.count(), count: a.count() }, a), this._lineDraw.updateLayout(), this._clearLayer(r);
        }, t.prototype._updateLineDraw = function(e, i) {
          var r = this._lineDraw, a = this._showEffect(i), o = !!i.get("polyline"), s = i.pipelineContext, l = s.large;
          return "development", (!r || a !== this._hasEffet || o !== this._isPolyline || l !== this._isLargeDraw) && (r && r.remove(), r = this._lineDraw = l ? new gDt() : new FM(o ? a ? hDt : Mq : a ? Tq : kM), this._hasEffet = a, this._isPolyline = o, this._isLargeDraw = l), this.group.add(r.group), r;
        }, t.prototype._showEffect = function(e) {
          return !!e.get(["effect", "show"]);
        }, t.prototype._clearLayer = function(e) {
          var i = e.getZr(), r = i.painter.getType() === "svg";
          !r && this._lastZlevel != null && i.painter.getLayer(this._lastZlevel).clear(true);
        }, t.prototype.remove = function(e, i) {
          this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(i);
        }, t.prototype.dispose = function(e, i) {
          this.remove(e, i);
        }, t.type = "lines", t;
      }(Ve), ADt = typeof Uint32Array == "undefined" ? Array : Uint32Array, pDt = typeof Float64Array == "undefined" ? Array : Float64Array;
      function Rq(n) {
        var t = n.data;
        t && t[0] && t[0][0] && t[0][0].coord && ("development", n.data = Z(t, function(e) {
          var i = [e[0].coord, e[1].coord], r = { coords: i };
          return e[0].name && (r.fromName = e[0].name), e[1].name && (r.toName = e[1].name), gb([r, e[0], e[1]]);
        }));
      }
      var vDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.visualStyleAccessPath = "lineStyle", e.visualDrawType = "stroke", e;
        }
        return t.prototype.init = function(e) {
          e.data = e.data || [], Rq(e);
          var i = this._processFlatCoordsArray(e.data);
          this._flatCoords = i.flatCoords, this._flatCoordsOffset = i.flatCoordsOffset, i.flatCoords && (e.data = new Float32Array(i.count)), n.prototype.init.apply(this, arguments);
        }, t.prototype.mergeOption = function(e) {
          if (Rq(e), e.data) {
            var i = this._processFlatCoordsArray(e.data);
            this._flatCoords = i.flatCoords, this._flatCoordsOffset = i.flatCoordsOffset, i.flatCoords && (e.data = new Float32Array(i.count));
          }
          n.prototype.mergeOption.apply(this, arguments);
        }, t.prototype.appendData = function(e) {
          var i = this._processFlatCoordsArray(e.data);
          i.flatCoords && (this._flatCoords ? (this._flatCoords = u_(this._flatCoords, i.flatCoords), this._flatCoordsOffset = u_(this._flatCoordsOffset, i.flatCoordsOffset)) : (this._flatCoords = i.flatCoords, this._flatCoordsOffset = i.flatCoordsOffset), e.data = new Float32Array(i.count)), this.getRawData().appendData(e.data);
        }, t.prototype._getCoordsFromItemModel = function(e) {
          var i = this.getData().getItemModel(e), r = i.option instanceof Array ? i.option : i.getShallow("coords");
          if (!(r instanceof Array && r.length > 0 && r[0] instanceof Array)) throw new Error("Invalid coords " + JSON.stringify(r) + ". Lines must have 2d coords array in data item.");
          return r;
        }, t.prototype.getLineCoordsCount = function(e) {
          return this._flatCoordsOffset ? this._flatCoordsOffset[e * 2 + 1] : this._getCoordsFromItemModel(e).length;
        }, t.prototype.getLineCoords = function(e, i) {
          if (this._flatCoordsOffset) {
            for (var r = this._flatCoordsOffset[e * 2], a = this._flatCoordsOffset[e * 2 + 1], o = 0; o < a; o++) i[o] = i[o] || [], i[o][0] = this._flatCoords[r + o * 2], i[o][1] = this._flatCoords[r + o * 2 + 1];
            return a;
          } else {
            for (var s = this._getCoordsFromItemModel(e), o = 0; o < s.length; o++) i[o] = i[o] || [], i[o][0] = s[o][0], i[o][1] = s[o][1];
            return s.length;
          }
        }, t.prototype._processFlatCoordsArray = function(e) {
          var i = 0;
          if (this._flatCoords && (i = this._flatCoords.length), pe(e[0])) {
            for (var r = e.length, a = new ADt(r), o = new pDt(r), s = 0, l = 0, u = 0, h = 0; h < r; ) {
              u++;
              var c = e[h++];
              a[l++] = s + i, a[l++] = c;
              for (var f = 0; f < c; f++) {
                var g = e[h++], d = e[h++];
                if (o[s++] = g, o[s++] = d, h > r && true) throw new Error("Invalid data format.");
              }
            }
            return { flatCoordsOffset: new Uint32Array(a.buffer, 0, l), flatCoords: o, count: u };
          }
          return { flatCoordsOffset: null, flatCoords: null, count: e.length };
        }, t.prototype.getInitialData = function(e, i) {
          if (true) {
            var r = Fg.get(e.coordinateSystem);
            if (!r) throw new Error("Unknown coordinate system " + e.coordinateSystem);
          }
          var a = new Zi(["value"], this);
          return a.hasItemOption = false, a.initData(e.data, [], function(o, s, l, u) {
            if (o instanceof Array) return NaN;
            a.hasItemOption = true;
            var h = o.value;
            if (h != null) return h instanceof Array ? h[u] : h;
          }), a;
        }, t.prototype.formatTooltip = function(e, i, r) {
          var a = this.getData(), o = a.getItemModel(e), s = o.get("name");
          if (s) return s;
          var l = o.get("fromName"), u = o.get("toName"), h = [];
          return l != null && h.push(l), u != null && h.push(u), Zn("nameValue", { name: h.join(" > ") });
        }, t.prototype.preventIncremental = function() {
          return !!this.get(["effect", "show"]);
        }, t.prototype.getProgressive = function() {
          var e = this.option.progressive;
          return e == null ? this.option.large ? 1e4 : this.get("progressive") : e;
        }, t.prototype.getProgressiveThreshold = function() {
          var e = this.option.progressiveThreshold;
          return e == null ? this.option.large ? 2e4 : this.get("progressiveThreshold") : e;
        }, t.prototype.getZLevelKey = function() {
          var e = this.getModel("effect"), i = e.get("trailLength");
          return this.getData().count() > this.getProgressiveThreshold() ? this.id : e.get("show") && i > 0 ? i + "" : "";
        }, t.type = "series.lines", t.dependencies = ["grid", "polar", "geo", "calendar"], t.defaultOption = { coordinateSystem: "geo", z: 2, legendHoverLink: true, xAxisIndex: 0, yAxisIndex: 0, symbol: ["none", "none"], symbolSize: [10, 10], geoIndex: 0, effect: { show: false, period: 4, constantSpeed: 0, symbol: "circle", symbolSize: 3, loop: true, trailLength: 0.2 }, large: false, largeThreshold: 2e3, polyline: false, clip: true, label: { show: false, position: "end" }, lineStyle: { opacity: 0.5 } }, t;
      }($e);
      function QI(n) {
        return n instanceof Array || (n = [n, n]), n;
      }
      var yDt = { seriesType: "lines", reset: function(n) {
        var t = QI(n.get("symbol")), e = QI(n.get("symbolSize")), i = n.getData();
        i.setVisual("fromSymbol", t && t[0]), i.setVisual("toSymbol", t && t[1]), i.setVisual("fromSymbolSize", e && e[0]), i.setVisual("toSymbolSize", e && e[1]);
        function r(a, o) {
          var s = a.getItemModel(o), l = QI(s.getShallow("symbol", true)), u = QI(s.getShallow("symbolSize", true));
          l[0] && a.setItemVisual(o, "fromSymbol", l[0]), l[1] && a.setItemVisual(o, "toSymbol", l[1]), u[0] && a.setItemVisual(o, "fromSymbolSize", u[0]), u[1] && a.setItemVisual(o, "toSymbolSize", u[1]);
        }
        return { dataEach: i.hasItemOption ? r : null };
      } };
      function mDt(n) {
        n.registerChartView(dDt), n.registerSeriesModel(vDt), n.registerLayout(Dq), n.registerVisual(yDt);
      }
      var _Dt = 256, IDt = function() {
        function n() {
          this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = { inRange: null, outOfRange: null };
          var t = Ol.createCanvas();
          this.canvas = t;
        }
        return n.prototype.update = function(t, e, i, r, a, o) {
          var s = this._getBrush(), l = this._getGradient(a, "inRange"), u = this._getGradient(a, "outOfRange"), h = this.pointSize + this.blurSize, c = this.canvas, f = c.getContext("2d"), g = t.length;
          c.width = e, c.height = i;
          for (var d = 0; d < g; ++d) {
            var A = t[d], p = A[0], v = A[1], y = A[2], m = r(y);
            f.globalAlpha = m, f.drawImage(s, p - h, v - h);
          }
          if (!c.width || !c.height) return c;
          for (var _ = f.getImageData(0, 0, c.width, c.height), E = _.data, I = 0, x = E.length, w = this.minOpacity, C = this.maxOpacity, S = C - w; I < x; ) {
            var m = E[I + 3] / 256, b = Math.floor(m * (_Dt - 1)) * 4;
            if (m > 0) {
              var B = o(m) ? l : u;
              m > 0 && (m = m * S + w), E[I++] = B[b], E[I++] = B[b + 1], E[I++] = B[b + 2], E[I++] = B[b + 3] * m * 256;
            } else I += 4;
          }
          return f.putImageData(_, 0, 0), c;
        }, n.prototype._getBrush = function() {
          var t = this._brushCanvas || (this._brushCanvas = Ol.createCanvas()), e = this.pointSize + this.blurSize, i = e * 2;
          t.width = i, t.height = i;
          var r = t.getContext("2d");
          return r.clearRect(0, 0, i, i), r.shadowOffsetX = i, r.shadowBlur = this.blurSize, r.shadowColor = "#000", r.beginPath(), r.arc(-e, e, this.pointSize, 0, Math.PI * 2, true), r.closePath(), r.fill(), t;
        }, n.prototype._getGradient = function(t, e) {
          for (var i = this._gradientPixels, r = i[e] || (i[e] = new Uint8ClampedArray(256 * 4)), a = [0, 0, 0, 0], o = 0, s = 0; s < 256; s++) t[e](s / 255, true, a), r[o++] = a[0], r[o++] = a[1], r[o++] = a[2], r[o++] = a[3];
          return r;
        }, n;
      }();
      function EDt(n, t, e) {
        var i = n[1] - n[0];
        t = Z(t, function(o) {
          return { interval: [(o.interval[0] - n[0]) / i, (o.interval[1] - n[0]) / i] };
        });
        var r = t.length, a = 0;
        return function(o) {
          var s;
          for (s = a; s < r; s++) {
            var l = t[s].interval;
            if (l[0] <= o && o <= l[1]) {
              a = s;
              break;
            }
          }
          if (s === r) for (s = a - 1; s >= 0; s--) {
            var l = t[s].interval;
            if (l[0] <= o && o <= l[1]) {
              a = s;
              break;
            }
          }
          return s >= 0 && s < r && e[s];
        };
      }
      function xDt(n, t) {
        var e = n[1] - n[0];
        return t = [(t[0] - n[0]) / e, (t[1] - n[0]) / e], function(i) {
          return i >= t[0] && i <= t[1];
        };
      }
      function Lq(n) {
        var t = n.dimensions;
        return t[0] === "lng" && t[1] === "lat";
      }
      var wDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a;
          if (i.eachComponent("visualMap", function(s) {
            s.eachTargetSeries(function(l) {
              l === e && (a = s);
            });
          }), !a) throw new Error("Heatmap must use with visualMap");
          this._progressiveEls = null, this.group.removeAll();
          var o = e.coordinateSystem;
          o.type === "cartesian2d" || o.type === "calendar" ? this._renderOnCartesianAndCalendar(e, r, 0, e.getData().count()) : Lq(o) && this._renderOnGeo(o, e, a, r);
        }, t.prototype.incrementalPrepareRender = function(e, i, r) {
          this.group.removeAll();
        }, t.prototype.incrementalRender = function(e, i, r, a) {
          var o = i.coordinateSystem;
          o && (Lq(o) ? this.render(i, r, a) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(i, a, e.start, e.end, true)));
        }, t.prototype.eachRendered = function(e) {
          tu(this._progressiveEls || this.group, e);
        }, t.prototype._renderOnCartesianAndCalendar = function(e, i, r, a, o) {
          var s = e.coordinateSystem, l = tc(s, "cartesian2d"), u, h, c, f;
          if (l) {
            var g = s.getAxis("x"), d = s.getAxis("y");
            if (true) {
              if (!(g.type === "category" && d.type === "category")) throw new Error("Heatmap on cartesian must have two category axes");
              if (!(g.onBand && d.onBand)) throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
            }
            u = g.getBandWidth() + 0.5, h = d.getBandWidth() + 0.5, c = g.scale.getExtent(), f = d.scale.getExtent();
          }
          for (var A = this.group, p = e.getData(), v = e.getModel(["emphasis", "itemStyle"]).getItemStyle(), y = e.getModel(["blur", "itemStyle"]).getItemStyle(), m = e.getModel(["select", "itemStyle"]).getItemStyle(), _ = e.get(["itemStyle", "borderRadius"]), E = Xn(e), I = e.getModel("emphasis"), x = I.get("focus"), w = I.get("blurScope"), C = I.get("disabled"), S = l ? [p.mapDimension("x"), p.mapDimension("y"), p.mapDimension("value")] : [p.mapDimension("time"), p.mapDimension("value")], b = r; b < a; b++) {
            var B = void 0, T = p.getItemVisual(b, "style");
            if (l) {
              var D = p.get(S[0], b), R = p.get(S[1], b);
              if (isNaN(p.get(S[2], b)) || isNaN(D) || isNaN(R) || D < c[0] || D > c[1] || R < f[0] || R > f[1]) continue;
              var L = s.dataToPoint([D, R]);
              B = new ue({ shape: { x: L[0] - u / 2, y: L[1] - h / 2, width: u, height: h }, style: T });
            } else {
              if (isNaN(p.get(S[1], b))) continue;
              B = new ue({ z2: 1, shape: s.dataToRect([p.get(S[0], b)]).contentShape, style: T });
            }
            if (p.hasItemOption) {
              var k = p.getItemModel(b), P = k.getModel("emphasis");
              v = P.getModel("itemStyle").getItemStyle(), y = k.getModel(["blur", "itemStyle"]).getItemStyle(), m = k.getModel(["select", "itemStyle"]).getItemStyle(), _ = k.get(["itemStyle", "borderRadius"]), x = P.get("focus"), w = P.get("blurScope"), C = P.get("disabled"), E = Xn(k);
            }
            B.shape.r = _;
            var F = e.getRawValue(b), Q = "-";
            F && F[2] != null && (Q = F[2] + ""), vi(B, E, { labelFetcher: e, labelDataIndex: b, defaultOpacity: T.opacity, defaultText: Q }), B.ensureState("emphasis").style = v, B.ensureState("blur").style = y, B.ensureState("select").style = m, hn(B, x, w, C), B.incremental = o, o && (B.states.emphasis.hoverLayer = true), A.add(B), p.setItemGraphicEl(b, B), this._progressiveEls && this._progressiveEls.push(B);
          }
        }, t.prototype._renderOnGeo = function(e, i, r, a) {
          var o = r.targetVisuals.inRange, s = r.targetVisuals.outOfRange, l = i.getData(), u = this._hmLayer || this._hmLayer || new IDt();
          u.blurSize = i.get("blurSize"), u.pointSize = i.get("pointSize"), u.minOpacity = i.get("minOpacity"), u.maxOpacity = i.get("maxOpacity");
          var h = e.getViewRect().clone(), c = e.getRoamTransform();
          h.applyTransform(c);
          var f = Math.max(h.x, 0), g = Math.max(h.y, 0), d = Math.min(h.width + h.x, a.getWidth()), A = Math.min(h.height + h.y, a.getHeight()), p = d - f, v = A - g, y = [l.mapDimension("lng"), l.mapDimension("lat"), l.mapDimension("value")], m = l.mapArray(y, function(x, w, C) {
            var S = e.dataToPoint([x, w]);
            return S[0] -= f, S[1] -= g, S.push(C), S;
          }), _ = r.getExtent(), E = r.type === "visualMap.continuous" ? xDt(_, r.option.range) : EDt(_, r.getPieceList(), r.option.selected);
          u.update(m, p, v, o.color.getNormalizer(), { inRange: o.color.getColorMapper(), outOfRange: s.color.getColorMapper() }, E);
          var I = new li({ style: { width: p, height: v, x: f, y: g, image: u.canvas }, silent: true });
          this.group.add(I);
        }, t.type = "heatmap", t;
      }(Ve), CDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.getInitialData = function(e, i) {
          return zs(null, this, { generateCoord: "value" });
        }, t.prototype.preventIncremental = function() {
          var e = Fg.get(this.get("coordinateSystem"));
          if (e && e.dimensions) return e.dimensions[0] === "lng" && e.dimensions[1] === "lat";
        }, t.type = "series.heatmap", t.dependencies = ["grid", "geo", "calendar"], t.defaultOption = { coordinateSystem: "cartesian2d", z: 2, geoIndex: 0, blurSize: 30, pointSize: 20, maxOpacity: 1, minOpacity: 0, select: { itemStyle: { borderColor: "#212121" } } }, t;
      }($e);
      function SDt(n) {
        n.registerChartView(wDt), n.registerSeriesModel(CDt);
      }
      var bDt = ["itemStyle", "borderWidth"], Pq = [{ xy: "x", wh: "width", index: 0, posDesc: ["left", "right"] }, { xy: "y", wh: "height", index: 1, posDesc: ["top", "bottom"] }], fD = new ks(), BDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = this.group, o = e.getData(), s = this._data, l = e.coordinateSystem, u = l.getBaseAxis(), h = u.isHorizontal(), c = l.master.getRect(), f = { ecSize: { width: r.getWidth(), height: r.getHeight() }, seriesModel: e, coordSys: l, coordSysExtent: [[c.x, c.x + c.width], [c.y, c.y + c.height]], isHorizontal: h, valueDim: Pq[+h], categoryDim: Pq[1 - +h] };
          o.diff(s).add(function(d) {
            if (o.hasValue(d)) {
              var A = Gq(o, d), p = Nq(o, d, A, f), v = Uq(o, f, p);
              o.setItemGraphicEl(d, v), a.add(v), qq(v, f, p);
            }
          }).update(function(d, A) {
            var p = s.getItemGraphicEl(A);
            if (!o.hasValue(d)) {
              a.remove(p);
              return;
            }
            var v = Gq(o, d), y = Nq(o, d, v, f), m = jq(o, y);
            p && m !== p.__pictorialShapeStr && (a.remove(p), o.setItemGraphicEl(d, null), p = null), p ? NDt(p, f, y) : p = Uq(o, f, y, true), o.setItemGraphicEl(d, p), p.__pictorialSymbolMeta = y, a.add(p), qq(p, f, y);
          }).remove(function(d) {
            var A = s.getItemGraphicEl(d);
            A && Vq(s, d, A.__pictorialSymbolMeta.animationModel, A);
          }).execute();
          var g = e.get("clip", true) ? bv(e.coordinateSystem, false, e) : null;
          return g ? a.setClipPath(g) : a.removeClipPath(), this._data = o, this.group;
        }, t.prototype.remove = function(e, i) {
          var r = this.group, a = this._data;
          e.get("animation") ? a && a.eachItemGraphicEl(function(o) {
            Vq(a, Dt(o).dataIndex, e, o);
          }) : r.removeAll();
        }, t.type = "pictorialBar", t;
      }(Ve);
      function Nq(n, t, e, i) {
        var r = n.getItemLayout(t), a = e.get("symbolRepeat"), o = e.get("symbolClip"), s = e.get("symbolPosition") || "start", l = e.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0, h = e.get("symbolPatternSize") || 2, c = e.isAnimationEnabled(), f = { dataIndex: t, layout: r, itemModel: e, symbolType: n.getItemVisual(t, "symbol") || "circle", style: n.getItemVisual(t, "style"), symbolClip: o, symbolRepeat: a, symbolRepeatDirection: e.get("symbolRepeatDirection"), symbolPatternSize: h, rotation: u, animationModel: c ? e : null, hoverScale: c && e.get(["emphasis", "scale"]), z2: e.getShallow("z", true) || 0 };
        TDt(e, a, r, i, f), MDt(n, t, r, a, o, f.boundingLength, f.pxSign, h, i, f), DDt(e, f.symbolScale, u, i, f);
        var g = f.symbolSize, d = Uh(e.get("symbolOffset"), g);
        return RDt(e, g, r, a, o, d, s, f.valueLineWidth, f.boundingLength, f.repeatCutLength, i, f), f;
      }
      function TDt(n, t, e, i, r) {
        var a = i.valueDim, o = n.get("symbolBoundingData"), s = i.coordSys.getOtherAxis(i.coordSys.getBaseAxis()), l = s.toGlobalCoord(s.dataToCoord(0)), u = 1 - +(e[a.wh] <= 0), h;
        if (X(o)) {
          var c = [gD(s, o[0]) - l, gD(s, o[1]) - l];
          c[1] < c[0] && c.reverse(), h = c[u];
        } else o != null ? h = gD(s, o) - l : t ? h = i.coordSysExtent[a.index][u] - l : h = e[a.wh];
        r.boundingLength = h, t && (r.repeatCutLength = e[a.wh]), r.pxSign = h > 0 ? 1 : -1;
      }
      function gD(n, t) {
        return n.toGlobalCoord(n.dataToCoord(n.scale.parse(t)));
      }
      function MDt(n, t, e, i, r, a, o, s, l, u) {
        var h = l.valueDim, c = l.categoryDim, f = Math.abs(e[c.wh]), g = n.getItemVisual(t, "symbolSize"), d;
        X(g) ? d = g.slice() : g == null ? d = ["100%", "100%"] : d = [g, g], d[c.index] = ot(d[c.index], f), d[h.index] = ot(d[h.index], i ? f : Math.abs(a)), u.symbolSize = d;
        var A = u.symbolScale = [d[0] / s, d[1] / s];
        A[h.index] *= (l.isHorizontal ? -1 : 1) * o;
      }
      function DDt(n, t, e, i, r) {
        var a = n.get(bDt) || 0;
        a && (fD.attr({ scaleX: t[0], scaleY: t[1], rotation: e }), fD.updateTransform(), a /= fD.getLineScale(), a *= t[i.valueDim.index]), r.valueLineWidth = a || 0;
      }
      function RDt(n, t, e, i, r, a, o, s, l, u, h, c) {
        var f = h.categoryDim, g = h.valueDim, d = c.pxSign, A = Math.max(t[g.index] + s, 0), p = A;
        if (i) {
          var v = Math.abs(l), y = Dn(n.get("symbolMargin"), "15%") + "", m = false;
          y.lastIndexOf("!") === y.length - 1 && (m = true, y = y.slice(0, y.length - 1));
          var _ = ot(y, t[g.index]), E = Math.max(A + _ * 2, 0), I = m ? 0 : _ * 2, x = g2(i), w = x ? i : Hq((v + I) / E), C = v - w * A;
          _ = C / 2 / (m ? w : Math.max(w - 1, 1)), E = A + _ * 2, I = m ? 0 : _ * 2, !x && i !== "fixed" && (w = u ? Hq((Math.abs(u) + I) / E) : 0), p = w * E - I, c.repeatTimes = w, c.symbolMargin = _;
        }
        var S = d * (p / 2), b = c.pathPosition = [];
        b[f.index] = e[f.wh] / 2, b[g.index] = o === "start" ? S : o === "end" ? l - S : l / 2, a && (b[0] += a[0], b[1] += a[1]);
        var B = c.bundlePosition = [];
        B[f.index] = e[f.xy], B[g.index] = e[g.xy];
        var T = c.barRectShape = Y({}, e);
        T[g.wh] = d * Math.max(Math.abs(e[g.wh]), Math.abs(b[g.index] + S)), T[f.wh] = e[f.wh];
        var D = c.clipShape = {};
        D[f.xy] = -e[f.xy], D[f.wh] = h.ecSize[f.wh], D[g.xy] = 0, D[g.wh] = e[g.wh];
      }
      function kq(n) {
        var t = n.symbolPatternSize, e = Nn(n.symbolType, -t / 2, -t / 2, t, t);
        return e.attr({ culling: true }), e.type !== "image" && e.setStyle({ strokeNoScale: true }), e;
      }
      function Fq(n, t, e, i) {
        var r = n.__pictorialBundle, a = e.symbolSize, o = e.valueLineWidth, s = e.pathPosition, l = t.valueDim, u = e.repeatTimes || 0, h = 0, c = a[t.valueDim.index] + o + e.symbolMargin * 2;
        for (dD(n, function(A) {
          A.__pictorialAnimationIndex = h, A.__pictorialRepeatTimes = u, h < u ? sd(A, null, d(h), e, i) : sd(A, null, { scaleX: 0, scaleY: 0 }, e, i, function() {
            r.remove(A);
          }), h++;
        }); h < u; h++) {
          var f = kq(e);
          f.__pictorialAnimationIndex = h, f.__pictorialRepeatTimes = u, r.add(f);
          var g = d(h);
          sd(f, { x: g.x, y: g.y, scaleX: 0, scaleY: 0 }, { scaleX: g.scaleX, scaleY: g.scaleY, rotation: g.rotation }, e, i);
        }
        function d(A) {
          var p = s.slice(), v = e.pxSign, y = A;
          return (e.symbolRepeatDirection === "start" ? v > 0 : v < 0) && (y = u - 1 - A), p[l.index] = c * (y - u / 2 + 0.5) + s[l.index], { x: p[0], y: p[1], scaleX: e.symbolScale[0], scaleY: e.symbolScale[1], rotation: e.rotation };
        }
      }
      function Qq(n, t, e, i) {
        var r = n.__pictorialBundle, a = n.__pictorialMainPath;
        a ? sd(a, null, { x: e.pathPosition[0], y: e.pathPosition[1], scaleX: e.symbolScale[0], scaleY: e.symbolScale[1], rotation: e.rotation }, e, i) : (a = n.__pictorialMainPath = kq(e), r.add(a), sd(a, { x: e.pathPosition[0], y: e.pathPosition[1], scaleX: 0, scaleY: 0, rotation: e.rotation }, { scaleX: e.symbolScale[0], scaleY: e.symbolScale[1] }, e, i));
      }
      function Oq(n, t, e) {
        var i = Y({}, t.barRectShape), r = n.__pictorialBarRect;
        r ? sd(r, null, { shape: i }, t, e) : (r = n.__pictorialBarRect = new ue({ z2: 2, shape: i, silent: true, style: { stroke: "transparent", fill: "transparent", lineWidth: 0 } }), r.disableMorphing = true, n.add(r));
      }
      function zq(n, t, e, i) {
        if (e.symbolClip) {
          var r = n.__pictorialClipPath, a = Y({}, e.clipShape), o = t.valueDim, s = e.animationModel, l = e.dataIndex;
          if (r) _e(r, { shape: a }, s, l);
          else {
            a[o.wh] = 0, r = new ue({ shape: a }), n.__pictorialBundle.setClipPath(r), n.__pictorialClipPath = r;
            var u = {};
            u[o.wh] = e.clipShape[o.wh], Ph[i ? "updateProps" : "initProps"](r, { shape: u }, s, l);
          }
        }
      }
      function Gq(n, t) {
        var e = n.getItemModel(t);
        return e.getAnimationDelayParams = LDt, e.isAnimationEnabled = PDt, e;
      }
      function LDt(n) {
        return { index: n.__pictorialAnimationIndex, count: n.__pictorialRepeatTimes };
      }
      function PDt() {
        return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
      }
      function Uq(n, t, e, i) {
        var r = new Ct(), a = new Ct();
        return r.add(a), r.__pictorialBundle = a, a.x = e.bundlePosition[0], a.y = e.bundlePosition[1], e.symbolRepeat ? Fq(r, t, e) : Qq(r, t, e), Oq(r, e, i), zq(r, t, e, i), r.__pictorialShapeStr = jq(n, e), r.__pictorialSymbolMeta = e, r;
      }
      function NDt(n, t, e) {
        var i = e.animationModel, r = e.dataIndex, a = n.__pictorialBundle;
        _e(a, { x: e.bundlePosition[0], y: e.bundlePosition[1] }, i, r), e.symbolRepeat ? Fq(n, t, e, true) : Qq(n, t, e, true), Oq(n, e, true), zq(n, t, e, true);
      }
      function Vq(n, t, e, i) {
        var r = i.__pictorialBarRect;
        r && r.removeTextContent();
        var a = [];
        dD(i, function(o) {
          a.push(o);
        }), i.__pictorialMainPath && a.push(i.__pictorialMainPath), i.__pictorialClipPath && (e = null), M(a, function(o) {
          Jl(o, { scaleX: 0, scaleY: 0 }, e, t, function() {
            i.parent && i.parent.remove(i);
          });
        }), n.setItemGraphicEl(t, null);
      }
      function jq(n, t) {
        return [n.getItemVisual(t.dataIndex, "symbol") || "none", !!t.symbolRepeat, !!t.symbolClip].join(":");
      }
      function dD(n, t, e) {
        M(n.__pictorialBundle.children(), function(i) {
          i !== n.__pictorialBarRect && t.call(e, i);
        });
      }
      function sd(n, t, e, i, r, a) {
        t && n.attr(t), i.symbolClip && !r ? e && n.attr(e) : e && Ph[r ? "updateProps" : "initProps"](n, e, i.animationModel, i.dataIndex, a);
      }
      function qq(n, t, e) {
        var i = e.dataIndex, r = e.itemModel, a = r.getModel("emphasis"), o = a.getModel("itemStyle").getItemStyle(), s = r.getModel(["blur", "itemStyle"]).getItemStyle(), l = r.getModel(["select", "itemStyle"]).getItemStyle(), u = r.getShallow("cursor"), h = a.get("focus"), c = a.get("blurScope"), f = a.get("scale");
        dD(n, function(A) {
          if (A instanceof li) {
            var p = A.style;
            A.useStyle(Y({ image: p.image, x: p.x, y: p.y, width: p.width, height: p.height }, e.style));
          } else A.useStyle(e.style);
          var v = A.ensureState("emphasis");
          v.style = o, f && (v.scaleX = A.scaleX * 1.1, v.scaleY = A.scaleY * 1.1), A.ensureState("blur").style = s, A.ensureState("select").style = l, u && (A.cursor = u), A.z2 = e.z2;
        });
        var g = t.valueDim.posDesc[+(e.boundingLength > 0)], d = n.__pictorialBarRect;
        d.ignoreClip = true, vi(d, Xn(r), { labelFetcher: t.seriesModel, labelDataIndex: i, defaultText: $g(t.seriesModel.getData(), i), inheritColor: e.style.fill, defaultOpacity: e.style.opacity, defaultOutsidePosition: g }), hn(n, h, c, a.get("disabled"));
      }
      function Hq(n) {
        var t = Math.round(n);
        return Math.abs(n - t) < 1e-4 ? t : Math.ceil(n);
      }
      var kDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.hasSymbolVisual = true, e.defaultSymbol = "roundRect", e;
        }
        return t.prototype.getInitialData = function(e) {
          return e.stack = null, n.prototype.getInitialData.apply(this, arguments);
        }, t.type = "series.pictorialBar", t.dependencies = ["grid"], t.defaultOption = eu(Tv.defaultOption, { symbol: "circle", symbolSize: null, symbolRotate: null, symbolPosition: null, symbolOffset: null, symbolMargin: null, symbolRepeat: false, symbolRepeatDirection: "end", symbolClip: false, symbolBoundingData: null, symbolPatternSize: 400, barGap: "-100%", clip: false, progressive: 0, emphasis: { scale: false }, select: { itemStyle: { borderColor: "#212121" } } }), t;
      }(Tv);
      function FDt(n) {
        n.registerChartView(BDt), n.registerSeriesModel(kDt), n.registerLayout(n.PRIORITY.VISUAL.LAYOUT, Ot(sU, "pictorialBar")), n.registerLayout(n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, lU("pictorialBar"));
      }
      var QDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._layers = [], e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = e.getData(), o = this, s = this.group, l = e.getLayerSeries(), u = a.getLayout("layoutInfo"), h = u.rect, c = u.boundaryGap;
          s.x = 0, s.y = h.y + c[0];
          function f(p) {
            return p.name;
          }
          var g = new Os(this._layersSeries || [], l, f, f), d = [];
          g.add(ct(A, this, "add")).update(ct(A, this, "update")).remove(ct(A, this, "remove")).execute();
          function A(p, v, y) {
            var m = o._layers;
            if (p === "remove") {
              s.remove(m[v]);
              return;
            }
            for (var _ = [], E = [], I, x = l[v].indices, w = 0; w < x.length; w++) {
              var C = a.getItemLayout(x[w]), S = C.x, b = C.y0, B = C.y;
              _.push(S, b), E.push(S, b + B), I = a.getItemVisual(x[w], "style");
            }
            var T, D = a.getItemLayout(x[0]), R = e.getModel("label"), L = R.get("margin"), k = e.getModel("emphasis");
            if (p === "add") {
              var P = d[v] = new Ct();
              T = new wV({ shape: { points: _, stackedOnPoints: E, smooth: 0.4, stackedOnSmooth: 0.4, smoothConstraint: false }, z2: 0 }), P.add(T), s.add(P), e.isAnimationEnabled() && T.setClipPath(ODt(T.getBoundingRect(), e, function() {
                T.removeClipPath();
              }));
            } else {
              var P = m[y];
              T = P.childAt(0), s.add(P), d[v] = P, _e(T, { shape: { points: _, stackedOnPoints: E } }, e), Ya(T);
            }
            vi(T, Xn(e), { labelDataIndex: x[w - 1], defaultText: a.getName(x[w - 1]), inheritColor: I.fill }, { normal: { verticalAlign: "middle" } }), T.setTextConfig({ position: null, local: true });
            var F = T.getTextContent();
            F && (F.x = D.x - L, F.y = D.y0 + D.y / 2), T.useStyle(I), a.setItemGraphicEl(v, T), pi(T, e), hn(T, k.get("focus"), k.get("blurScope"), k.get("disabled"));
          }
          this._layersSeries = l, this._layers = d;
        }, t.type = "themeRiver", t;
      }(Ve);
      function ODt(n, t, e) {
        var i = new ue({ shape: { x: n.x - 10, y: n.y - 10, width: 0, height: n.height + 20 } });
        return nn(i, { shape: { x: n.x - 50, width: n.width + 100, height: n.height + 20 } }, t, e), i;
      }
      var AD = 2, zDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e) {
          n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Dv(ct(this.getData, this), ct(this.getRawData, this));
        }, t.prototype.fixData = function(e) {
          var i = e.length, r = {}, a = p2(e, function(f) {
            return r.hasOwnProperty(f[0] + "") || (r[f[0] + ""] = -1), f[2];
          }), o = [];
          a.buckets.each(function(f, g) {
            o.push({ name: g, dataList: f });
          });
          for (var s = o.length, l = 0; l < s; ++l) {
            for (var u = o[l].name, h = 0; h < o[l].dataList.length; ++h) {
              var c = o[l].dataList[h][0] + "";
              r[c] = l;
            }
            for (var c in r) r.hasOwnProperty(c) && r[c] !== l && (r[c] = l, e[i] = [c, 0, u], i++);
          }
          return e;
        }, t.prototype.getInitialData = function(e, i) {
          for (var r = this.getReferringComponents("singleAxis", Ln).models[0], a = r.get("type"), o = Ne(e.data, function(d) {
            return d[2] !== void 0;
          }), s = this.fixData(o || []), l = [], u = this.nameMap = dt(), h = 0, c = 0; c < s.length; ++c) l.push(s[c][AD]), u.get(s[c][AD]) || (u.set(s[c][AD], h), h++);
          var f = vv(s, { coordDimensions: ["single"], dimensionsDefine: [{ name: "time", type: Y1(a) }, { name: "value", type: "float" }, { name: "name", type: "ordinal" }], encodeDefine: { single: 0, value: 1, itemName: 2 } }).dimensions, g = new Zi(f, this);
          return g.initData(s), g;
        }, t.prototype.getLayerSeries = function() {
          for (var e = this.getData(), i = e.count(), r = [], a = 0; a < i; ++a) r[a] = a;
          var o = e.mapDimension("single"), s = p2(r, function(u) {
            return e.get("name", u);
          }), l = [];
          return s.buckets.each(function(u, h) {
            u.sort(function(c, f) {
              return e.get(o, c) - e.get(o, f);
            }), l.push({ name: h, indices: u });
          }), l;
        }, t.prototype.getAxisTooltipData = function(e, i, r) {
          X(e) || (e = e ? [e] : []);
          for (var a = this.getData(), o = this.getLayerSeries(), s = [], l = o.length, u, h = 0; h < l; ++h) {
            for (var c = Number.MAX_VALUE, f = -1, g = o[h].indices.length, d = 0; d < g; ++d) {
              var A = a.get(e[0], o[h].indices[d]), p = Math.abs(A - i);
              p <= c && (u = A, c = p, f = o[h].indices[d]);
            }
            s.push(f);
          }
          return { dataIndices: s, nestestValue: u };
        }, t.prototype.formatTooltip = function(e, i, r) {
          var a = this.getData(), o = a.getName(e), s = a.get(a.mapDimension("value"), e);
          return Zn("nameValue", { name: o, value: s });
        }, t.type = "series.themeRiver", t.dependencies = ["singleAxis"], t.defaultOption = { z: 2, colorBy: "data", coordinateSystem: "singleAxis", boundaryGap: ["10%", "10%"], singleAxisIndex: 0, animationEasing: "linear", label: { margin: 4, show: true, position: "left", fontSize: 11 }, emphasis: { label: { show: true } } }, t;
      }($e);
      function GDt(n, t) {
        n.eachSeriesByType("themeRiver", function(e) {
          var i = e.getData(), r = e.coordinateSystem, a = {}, o = r.getRect();
          a.rect = o;
          var s = e.get("boundaryGap"), l = r.getAxis();
          if (a.boundaryGap = s, l.orient === "horizontal") {
            s[0] = ot(s[0], o.height), s[1] = ot(s[1], o.height);
            var u = o.height - s[0] - s[1];
            Yq(i, e, u);
          } else {
            s[0] = ot(s[0], o.width), s[1] = ot(s[1], o.width);
            var h = o.width - s[0] - s[1];
            Yq(i, e, h);
          }
          i.setLayout("layoutInfo", a);
        });
      }
      function Yq(n, t, e) {
        if (n.count()) for (var i = t.coordinateSystem, r = t.getLayerSeries(), a = n.mapDimension("single"), o = n.mapDimension("value"), s = Z(r, function(p) {
          return Z(p.indices, function(v) {
            var y = i.dataToPoint(n.get(a, v));
            return y[1] = n.get(o, v), y;
          });
        }), l = UDt(s), u = l.y0, h = e / l.max, c = r.length, f = r[0].indices.length, g, d = 0; d < f; ++d) {
          g = u[d] * h, n.setItemLayout(r[0].indices[d], { layerIndex: 0, x: s[0][d][0], y0: g, y: s[0][d][1] * h });
          for (var A = 1; A < c; ++A) g += s[A - 1][d][1] * h, n.setItemLayout(r[A].indices[d], { layerIndex: A, x: s[A][d][0], y0: g, y: s[A][d][1] * h });
        }
      }
      function UDt(n) {
        for (var t = n.length, e = n[0].length, i = [], r = [], a = 0, o = 0; o < e; ++o) {
          for (var s = 0, l = 0; l < t; ++l) s += n[l][o][1];
          s > a && (a = s), i.push(s);
        }
        for (var u = 0; u < e; ++u) r[u] = (a - i[u]) / 2;
        a = 0;
        for (var h = 0; h < e; ++h) {
          var c = i[h] + r[h];
          c > a && (a = c);
        }
        return { y0: r, max: a };
      }
      function VDt(n) {
        n.registerChartView(QDt), n.registerSeriesModel(zDt), n.registerLayout(GDt), n.registerProcessor(Mv("themeRiver"));
      }
      var jDt = 2, qDt = 4, Wq = function(n) {
        V(t, n);
        function t(e, i, r, a) {
          var o = n.call(this) || this;
          o.z2 = jDt, o.textConfig = { inside: true }, Dt(o).seriesIndex = i.seriesIndex;
          var s = new ge({ z2: qDt, silent: e.getModel().get(["label", "silent"]) });
          return o.setTextContent(s), o.updateData(true, e, i, r, a), o;
        }
        return t.prototype.updateData = function(e, i, r, a, o) {
          this.node = i, i.piece = this, r = r || this._seriesModel, a = a || this._ecModel;
          var s = this;
          Dt(s).dataIndex = i.dataIndex;
          var l = i.getModel(), u = l.getModel("emphasis"), h = i.getLayout(), c = Y({}, h);
          c.label = null;
          var f = i.getVisual("style");
          f.lineJoin = "bevel";
          var g = i.getVisual("decal");
          g && (f.decal = qg(g, o));
          var d = ec(l.getModel("itemStyle"), c, true);
          Y(c, d), M(qi, function(y) {
            var m = s.ensureState(y), _ = l.getModel([y, "itemStyle"]);
            m.style = _.getItemStyle();
            var E = ec(_, c);
            E && (m.shape = E);
          }), e ? (s.setShape(c), s.shape.r = h.r0, nn(s, { shape: { r: h.r } }, r, i.dataIndex)) : (_e(s, { shape: c }, r), Ya(s)), s.useStyle(f), this._updateLabel(r);
          var A = l.getShallow("cursor");
          A && s.attr("cursor", A), this._seriesModel = r || this._seriesModel, this._ecModel = a || this._ecModel;
          var p = u.get("focus"), v = p === "ancestor" ? i.getAncestorsIndices() : p === "descendant" ? i.getDescendantIndices() : p;
          hn(this, v, u.get("blurScope"), u.get("disabled"));
        }, t.prototype._updateLabel = function(e) {
          var i = this, r = this.node.getModel(), a = r.getModel("label"), o = this.node.getLayout(), s = o.endAngle - o.startAngle, l = (o.startAngle + o.endAngle) / 2, u = Math.cos(l), h = Math.sin(l), c = this, f = c.getTextContent(), g = this.node.dataIndex, d = a.get("minAngle") / 180 * Math.PI, A = a.get("show") && !(d != null && Math.abs(s) < d);
          f.ignore = !A, M(Np, function(v) {
            var y = v === "normal" ? r.getModel("label") : r.getModel([v, "label"]), m = v === "normal", _ = m ? f : f.ensureState(v), E = e.getFormattedLabel(g, v);
            m && (E = E || i.node.name), _.style = Ke(y, {}, null, v !== "normal", true), E && (_.style.text = E);
            var I = y.get("show");
            I != null && !m && (_.ignore = !I);
            var x = p(y, "position"), w = m ? c : c.states[v], C = w.style.fill;
            w.textConfig = { outsideFill: y.get("color") === "inherit" ? C : null, inside: x !== "outside" };
            var S, b = p(y, "distance") || 0, B = p(y, "align"), T = p(y, "rotate"), D = Math.PI * 0.5, R = Math.PI * 1.5, L = Gr(T === "tangential" ? Math.PI / 2 - l : l), k = L > D && !Bp(L - D) && L < R;
            x === "outside" ? (S = o.r + b, B = k ? "right" : "left") : !B || B === "center" ? (s === 2 * Math.PI && o.r0 === 0 ? S = 0 : S = (o.r + o.r0) / 2, B = "center") : B === "left" ? (S = o.r0 + b, B = k ? "right" : "left") : B === "right" && (S = o.r - b, B = k ? "left" : "right"), _.style.align = B, _.style.verticalAlign = p(y, "verticalAlign") || "middle", _.x = S * u + o.cx, _.y = S * h + o.cy;
            var P = 0;
            T === "radial" ? P = Gr(-l) + (k ? Math.PI : 0) : T === "tangential" ? P = Gr(Math.PI / 2 - l) + (k ? Math.PI : 0) : pe(T) && (P = T * Math.PI / 180), _.rotation = Gr(P);
          });
          function p(v, y) {
            var m = v.get(y);
            return m == null ? a.get(y) : m;
          }
          f.dirtyStyle();
        }, t;
      }(Hi), pD = "sunburstRootToNode", Xq = "sunburstHighlight", HDt = "sunburstUnhighlight";
      function YDt(n) {
        n.registerAction({ type: pD, update: "updateView" }, function(t, e) {
          e.eachComponent({ mainType: "series", subType: "sunburst", query: t }, i);
          function i(r, a) {
            var o = Qv(t, [pD], r);
            if (o) {
              var s = r.getViewRoot();
              s && (t.direction = vM(s, o.node) ? "rollUp" : "drillDown"), r.resetViewRoot(o.node);
            }
          }
        }), n.registerAction({ type: Xq, update: "none" }, function(t, e, i) {
          t = Y({}, t), e.eachComponent({ mainType: "series", subType: "sunburst", query: t }, r);
          function r(a) {
            var o = Qv(t, [Xq], a);
            o && (t.dataIndex = o.node.dataIndex);
          }
          Rn("sunburstHighlight", "highlight"), i.dispatchAction(Y(t, { type: "highlight" }));
        }), n.registerAction({ type: HDt, update: "updateView" }, function(t, e, i) {
          t = Y({}, t), Rn("sunburstUnhighlight", "downplay"), i.dispatchAction(Y(t, { type: "downplay" }));
        });
      }
      var WDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r, a) {
          var o = this;
          this.seriesModel = e, this.api = r, this.ecModel = i;
          var s = e.getData(), l = s.tree.root, u = e.getViewRoot(), h = this.group, c = e.get("renderLabelForZeroData"), f = [];
          u.eachNode(function(y) {
            f.push(y);
          });
          var g = this._oldChildren || [];
          d(f, g), v(l, u), this._initEvents(), this._oldChildren = f;
          function d(y, m) {
            if (y.length === 0 && m.length === 0) return;
            new Os(m, y, _, _).add(E).update(E).remove(Ot(E, null)).execute();
            function _(I) {
              return I.getId();
            }
            function E(I, x) {
              var w = I == null ? null : y[I], C = x == null ? null : m[x];
              A(w, C);
            }
          }
          function A(y, m) {
            if (!c && y && !y.getValue() && (y = null), y !== l && m !== l) {
              if (m && m.piece) y ? (m.piece.updateData(false, y, e, i, r), s.setItemGraphicEl(y.dataIndex, m.piece)) : p(m);
              else if (y) {
                var _ = new Wq(y, e, i, r);
                h.add(_), s.setItemGraphicEl(y.dataIndex, _);
              }
            }
          }
          function p(y) {
            y && y.piece && (h.remove(y.piece), y.piece = null);
          }
          function v(y, m) {
            m.depth > 0 ? (o.virtualPiece ? o.virtualPiece.updateData(false, y, e, i, r) : (o.virtualPiece = new Wq(y, e, i, r), h.add(o.virtualPiece)), m.piece.off("click"), o.virtualPiece.on("click", function(_) {
              o._rootToNode(m.parentNode);
            })) : o.virtualPiece && (h.remove(o.virtualPiece), o.virtualPiece = null);
          }
        }, t.prototype._initEvents = function() {
          var e = this;
          this.group.off("click"), this.group.on("click", function(i) {
            var r = false, a = e.seriesModel.getViewRoot();
            a.eachNode(function(o) {
              if (!r && o.piece && o.piece === i.target) {
                var s = o.getModel().get("nodeClick");
                if (s === "rootToNode") e._rootToNode(o);
                else if (s === "link") {
                  var l = o.getModel(), u = l.get("link");
                  if (u) {
                    var h = l.get("target", true) || "_blank";
                    x1(u, h);
                  }
                }
                r = true;
              }
            });
          });
        }, t.prototype._rootToNode = function(e) {
          e !== this.seriesModel.getViewRoot() && this.api.dispatchAction({ type: pD, from: this.uid, seriesId: this.seriesModel.id, targetNode: e });
        }, t.prototype.containPoint = function(e, i) {
          var r = i.getData(), a = r.getItemLayout(0);
          if (a) {
            var o = e[0] - a.cx, s = e[1] - a.cy, l = Math.sqrt(o * o + s * s);
            return l <= a.r && l >= a.r0;
          }
        }, t.type = "sunburst", t;
      }(Ve), XDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.ignoreStyleOnData = true, e;
        }
        return t.prototype.getInitialData = function(e, i) {
          var r = { name: e.name, children: e.data };
          Zq(r);
          var a = this._levelModels = Z(e.levels || [], function(l) {
            return new Te(l, this, i);
          }, this), o = pM.createTree(r, this, s);
          function s(l) {
            l.wrapMethod("getItemModel", function(u, h) {
              var c = o.getNodeByDataIndex(h), f = a[c.depth];
              return f && (u.parentModel = f), u;
            });
          }
          return o.data;
        }, t.prototype.optionUpdated = function() {
          this.resetViewRoot();
        }, t.prototype.getDataParams = function(e) {
          var i = n.prototype.getDataParams.apply(this, arguments), r = this.getData().tree.getNodeByDataIndex(e);
          return i.treePathInfo = SI(r, this), i;
        }, t.prototype.getLevelModel = function(e) {
          return this._levelModels && this._levelModels[e.depth];
        }, t.prototype.getViewRoot = function() {
          return this._viewRoot;
        }, t.prototype.resetViewRoot = function(e) {
          e ? this._viewRoot = e : e = this._viewRoot;
          var i = this.getRawData().tree.root;
          (!e || e !== i && !i.contains(e)) && (this._viewRoot = i);
        }, t.prototype.enableAriaDecal = function() {
          s9(this);
        }, t.type = "series.sunburst", t.defaultOption = { z: 2, center: ["50%", "50%"], radius: [0, "75%"], clockwise: true, startAngle: 90, minAngle: 0, stillShowZeroSum: true, nodeClick: "rootToNode", renderLabelForZeroData: false, label: { rotate: "radial", show: true, opacity: 1, align: "center", position: "inside", distance: 5, silent: true }, itemStyle: { borderWidth: 1, borderColor: "white", borderType: "solid", shadowBlur: 0, shadowColor: "rgba(0, 0, 0, 0.2)", shadowOffsetX: 0, shadowOffsetY: 0, opacity: 1 }, emphasis: { focus: "descendant" }, blur: { itemStyle: { opacity: 0.2 }, label: { opacity: 0.1 } }, animationType: "expansion", animationDuration: 1e3, animationDurationUpdate: 500, data: [], sort: "desc" }, t;
      }($e);
      function Zq(n) {
        var t = 0;
        M(n.children, function(i) {
          Zq(i);
          var r = i.value;
          X(r) && (r = r[0]), t += r;
        });
        var e = n.value;
        X(e) && (e = e[0]), (e == null || isNaN(e)) && (e = t), e < 0 && (e = 0), X(n.value) ? n.value[0] = e : n.value = e;
      }
      var Kq = Math.PI / 180;
      function ZDt(n, t, e) {
        t.eachSeriesByType(n, function(i) {
          var r = i.get("center"), a = i.get("radius");
          X(a) || (a = [0, a]), X(r) || (r = [r, r]);
          var o = e.getWidth(), s = e.getHeight(), l = Math.min(o, s), u = ot(r[0], o), h = ot(r[1], s), c = ot(a[0], l / 2), f = ot(a[1], l / 2), g = -i.get("startAngle") * Kq, d = i.get("minAngle") * Kq, A = i.getData().tree.root, p = i.getViewRoot(), v = p.depth, y = i.get("sort");
          y != null && $q(p, y);
          var m = 0;
          M(p.children, function(L) {
            !isNaN(L.getValue()) && m++;
          });
          var _ = p.getValue(), E = Math.PI / (_ || m) * 2, I = p.depth > 0, x = p.height - (I ? -1 : 1), w = (f - c) / (x || 1), C = i.get("clockwise"), S = i.get("stillShowZeroSum"), b = C ? 1 : -1, B = function(L, k) {
            if (L) {
              var P = k;
              if (L !== A) {
                var F = L.getValue(), Q = _ === 0 && S ? E : F * E;
                Q < d && (Q = d), P = k + b * Q;
                var z = L.depth - v - (I ? -1 : 1), j = c + w * z, $ = c + w * (z + 1), G = i.getLevelModel(L);
                if (G) {
                  var tt = G.get("r0", true), J = G.get("r", true), et = G.get("radius", true);
                  et != null && (tt = et[0], J = et[1]), tt != null && (j = ot(tt, l / 2)), J != null && ($ = ot(J, l / 2));
                }
                L.setLayout({ angle: Q, startAngle: k, endAngle: P, clockwise: C, cx: u, cy: h, r0: j, r: $ });
              }
              if (L.children && L.children.length) {
                var nt = 0;
                M(L.children, function(gt) {
                  nt += B(gt, k + nt);
                });
              }
              return P - k;
            }
          };
          if (I) {
            var T = c, D = c + w, R = Math.PI * 2;
            A.setLayout({ angle: R, startAngle: g, endAngle: g + R, clockwise: C, cx: u, cy: h, r0: T, r: D });
          }
          B(p, g);
        });
      }
      function $q(n, t) {
        var e = n.children || [];
        n.children = KDt(e, t), e.length && M(n.children, function(i) {
          $q(i, t);
        });
      }
      function KDt(n, t) {
        if (yt(t)) {
          var e = Z(n, function(r, a) {
            var o = r.getValue();
            return { params: { depth: r.depth, height: r.height, dataIndex: r.dataIndex, getValue: function() {
              return o;
            } }, index: a };
          });
          return e.sort(function(r, a) {
            return t(r.params, a.params);
          }), Z(e, function(r) {
            return n[r.index];
          });
        } else {
          var i = t === "asc";
          return n.sort(function(r, a) {
            var o = (r.getValue() - a.getValue()) * (i ? 1 : -1);
            return o === 0 ? (r.dataIndex - a.dataIndex) * (i ? -1 : 1) : o;
          });
        }
      }
      function $Dt(n) {
        var t = {};
        function e(i, r, a) {
          for (var o = i; o && o.depth > 1; ) o = o.parentNode;
          var s = r.getColorFromPalette(o.name || o.dataIndex + "", t);
          return i.depth > 1 && ht(s) && (s = Ob(s, (i.depth - 1) / (a - 1) * 0.5)), s;
        }
        n.eachSeriesByType("sunburst", function(i) {
          var r = i.getData(), a = r.tree;
          a.eachNode(function(o) {
            var s = o.getModel(), l = s.getModel("itemStyle").getItemStyle();
            l.fill || (l.fill = e(o, i, a.root.height));
            var u = r.ensureUniqueItemVisual(o.dataIndex, "style");
            Y(u, l);
          });
        });
      }
      function JDt(n) {
        n.registerChartView(WDt), n.registerSeriesModel(XDt), n.registerLayout(Ot(ZDt, "sunburst")), n.registerProcessor(Ot(Mv, "sunburst")), n.registerVisual($Dt), YDt(n);
      }
      var Jq = { color: "fill", borderColor: "stroke" }, tRt = { symbol: 1, symbolSize: 1, symbolKeepAspect: 1, legendIcon: 1, visualMeta: 1, liftZ: 1, decal: 1 }, js = le(), eRt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.optionUpdated = function() {
          this.currentZLevel = this.get("zlevel", true), this.currentZ = this.get("z", true);
        }, t.prototype.getInitialData = function(e, i) {
          return zs(null, this);
        }, t.prototype.getDataParams = function(e, i, r) {
          var a = n.prototype.getDataParams.call(this, e, i);
          return r && (a.info = js(r).info), a;
        }, t.type = "series.custom", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], t.defaultOption = { coordinateSystem: "cartesian2d", z: 2, legendHoverLink: true, clip: false }, t;
      }($e);
      function nRt(n, t) {
        return t = t || [0, 0], Z(["x", "y"], function(e, i) {
          var r = this.getAxis(e), a = t[i], o = n[i] / 2;
          return r.type === "category" ? r.getBandWidth() : Math.abs(r.dataToCoord(a - o) - r.dataToCoord(a + o));
        }, this);
      }
      function iRt(n) {
        var t = n.master.getRect();
        return { coordSys: { type: "cartesian2d", x: t.x, y: t.y, width: t.width, height: t.height }, api: { coord: function(e) {
          return n.dataToPoint(e);
        }, size: ct(nRt, n) } };
      }
      function rRt(n, t) {
        return t = t || [0, 0], Z([0, 1], function(e) {
          var i = t[e], r = n[e] / 2, a = [], o = [];
          return a[e] = i - r, o[e] = i + r, a[1 - e] = o[1 - e] = t[1 - e], Math.abs(this.dataToPoint(a)[e] - this.dataToPoint(o)[e]);
        }, this);
      }
      function aRt(n) {
        var t = n.getBoundingRect();
        return { coordSys: { type: "geo", x: t.x, y: t.y, width: t.width, height: t.height, zoom: n.getZoom() }, api: { coord: function(e) {
          return n.dataToPoint(e);
        }, size: ct(rRt, n) } };
      }
      function oRt(n, t) {
        var e = this.getAxis(), i = t instanceof Array ? t[0] : t, r = (n instanceof Array ? n[0] : n) / 2;
        return e.type === "category" ? e.getBandWidth() : Math.abs(e.dataToCoord(i - r) - e.dataToCoord(i + r));
      }
      function sRt(n) {
        var t = n.getRect();
        return { coordSys: { type: "singleAxis", x: t.x, y: t.y, width: t.width, height: t.height }, api: { coord: function(e) {
          return n.dataToPoint(e);
        }, size: ct(oRt, n) } };
      }
      function lRt(n, t) {
        return t = t || [0, 0], Z(["Radius", "Angle"], function(e, i) {
          var r = "get" + e + "Axis", a = this[r](), o = t[i], s = n[i] / 2, l = a.type === "category" ? a.getBandWidth() : Math.abs(a.dataToCoord(o - s) - a.dataToCoord(o + s));
          return e === "Angle" && (l = l * Math.PI / 180), l;
        }, this);
      }
      function uRt(n) {
        var t = n.getRadiusAxis(), e = n.getAngleAxis(), i = t.getExtent();
        return i[0] > i[1] && i.reverse(), { coordSys: { type: "polar", cx: n.cx, cy: n.cy, r: i[1], r0: i[0] }, api: { coord: function(r) {
          var a = t.dataToRadius(r[0]), o = e.dataToAngle(r[1]), s = n.coordToPoint([a, o]);
          return s.push(a, o * Math.PI / 180), s;
        }, size: ct(lRt, n) } };
      }
      function hRt(n) {
        var t = n.getRect(), e = n.getRangeInfo();
        return { coordSys: { type: "calendar", x: t.x, y: t.y, width: t.width, height: t.height, cellWidth: n.getCellWidth(), cellHeight: n.getCellHeight(), rangeInfo: { start: e.start, end: e.end, weeks: e.weeks, dayCount: e.allDay } }, api: { coord: function(i, r) {
          return n.dataToPoint(i, r);
        } } };
      }
      var t7 = {};
      function e7(n, t, e, i) {
        return n && (n.legacy || n.legacy !== false && !e && !i && t !== "tspan" && (t === "text" || ft(n, "text")));
      }
      function n7(n, t, e) {
        var i = n, r, a, o;
        if (t === "text") o = i;
        else {
          o = {}, ft(i, "text") && (o.text = i.text), ft(i, "rich") && (o.rich = i.rich), ft(i, "textFill") && (o.fill = i.textFill), ft(i, "textStroke") && (o.stroke = i.textStroke), ft(i, "fontFamily") && (o.fontFamily = i.fontFamily), ft(i, "fontSize") && (o.fontSize = i.fontSize), ft(i, "fontStyle") && (o.fontStyle = i.fontStyle), ft(i, "fontWeight") && (o.fontWeight = i.fontWeight), a = { type: "text", style: o, silent: true }, r = {};
          var s = ft(i, "textPosition");
          e ? r.position = s ? i.textPosition : "inside" : s && (r.position = i.textPosition), ft(i, "textPosition") && (r.position = i.textPosition), ft(i, "textOffset") && (r.offset = i.textOffset), ft(i, "textRotation") && (r.rotation = i.textRotation), ft(i, "textDistance") && (r.distance = i.textDistance);
        }
        return i7(o, n), M(o.rich, function(l) {
          i7(l, l);
        }), { textConfig: r, textContent: a };
      }
      function i7(n, t) {
        t && (t.font = t.textFont || t.font, ft(t, "textStrokeWidth") && (n.lineWidth = t.textStrokeWidth), ft(t, "textAlign") && (n.align = t.textAlign), ft(t, "textVerticalAlign") && (n.verticalAlign = t.textVerticalAlign), ft(t, "textLineHeight") && (n.lineHeight = t.textLineHeight), ft(t, "textWidth") && (n.width = t.textWidth), ft(t, "textHeight") && (n.height = t.textHeight), ft(t, "textBackgroundColor") && (n.backgroundColor = t.textBackgroundColor), ft(t, "textPadding") && (n.padding = t.textPadding), ft(t, "textBorderColor") && (n.borderColor = t.textBorderColor), ft(t, "textBorderWidth") && (n.borderWidth = t.textBorderWidth), ft(t, "textBorderRadius") && (n.borderRadius = t.textBorderRadius), ft(t, "textBoxShadowColor") && (n.shadowColor = t.textBoxShadowColor), ft(t, "textBoxShadowBlur") && (n.shadowBlur = t.textBoxShadowBlur), ft(t, "textBoxShadowOffsetX") && (n.shadowOffsetX = t.textBoxShadowOffsetX), ft(t, "textBoxShadowOffsetY") && (n.shadowOffsetY = t.textBoxShadowOffsetY));
      }
      function r7(n, t, e) {
        var i = n;
        i.textPosition = i.textPosition || e.position || "inside", e.offset != null && (i.textOffset = e.offset), e.rotation != null && (i.textRotation = e.rotation), e.distance != null && (i.textDistance = e.distance);
        var r = i.textPosition.indexOf("inside") >= 0, a = n.fill || "#000";
        a7(i, t);
        var o = i.textFill == null;
        return r ? o && (i.textFill = e.insideFill || "#fff", !i.textStroke && e.insideStroke && (i.textStroke = e.insideStroke), !i.textStroke && (i.textStroke = a), i.textStrokeWidth == null && (i.textStrokeWidth = 2)) : (o && (i.textFill = n.fill || e.outsideFill || "#000"), !i.textStroke && e.outsideStroke && (i.textStroke = e.outsideStroke)), i.text = t.text, i.rich = t.rich, M(t.rich, function(s) {
          a7(s, s);
        }), i;
      }
      function a7(n, t) {
        t && (ft(t, "fill") && (n.textFill = t.fill), ft(t, "stroke") && (n.textStroke = t.fill), ft(t, "lineWidth") && (n.textStrokeWidth = t.lineWidth), ft(t, "font") && (n.font = t.font), ft(t, "fontStyle") && (n.fontStyle = t.fontStyle), ft(t, "fontWeight") && (n.fontWeight = t.fontWeight), ft(t, "fontSize") && (n.fontSize = t.fontSize), ft(t, "fontFamily") && (n.fontFamily = t.fontFamily), ft(t, "align") && (n.textAlign = t.align), ft(t, "verticalAlign") && (n.textVerticalAlign = t.verticalAlign), ft(t, "lineHeight") && (n.textLineHeight = t.lineHeight), ft(t, "width") && (n.textWidth = t.width), ft(t, "height") && (n.textHeight = t.height), ft(t, "backgroundColor") && (n.textBackgroundColor = t.backgroundColor), ft(t, "padding") && (n.textPadding = t.padding), ft(t, "borderColor") && (n.textBorderColor = t.borderColor), ft(t, "borderWidth") && (n.textBorderWidth = t.borderWidth), ft(t, "borderRadius") && (n.textBorderRadius = t.borderRadius), ft(t, "shadowColor") && (n.textBoxShadowColor = t.shadowColor), ft(t, "shadowBlur") && (n.textBoxShadowBlur = t.shadowBlur), ft(t, "shadowOffsetX") && (n.textBoxShadowOffsetX = t.shadowOffsetX), ft(t, "shadowOffsetY") && (n.textBoxShadowOffsetY = t.shadowOffsetY), ft(t, "textShadowColor") && (n.textShadowColor = t.textShadowColor), ft(t, "textShadowBlur") && (n.textShadowBlur = t.textShadowBlur), ft(t, "textShadowOffsetX") && (n.textShadowOffsetX = t.textShadowOffsetX), ft(t, "textShadowOffsetY") && (n.textShadowOffsetY = t.textShadowOffsetY));
      }
      function o7(n, t) {
        if (true) {
          var e = n + "^_^" + t;
          t7[e] || (t7[e] = true);
        }
      }
      var s7 = { position: ["x", "y"], scale: ["scaleX", "scaleY"], origin: ["originX", "originY"] }, l7 = re(s7), OI = So(To, function(n, t) {
        return n[t] = 1, n;
      }, {}), u7 = To.join(", "), zI = ["", "style", "shape", "extra"], ld = le();
      function vD(n, t, e, i, r) {
        var a = n + "Animation", o = wg(n, i, r) || {}, s = ld(t).userDuring;
        return o.duration > 0 && (o.during = s ? ct(ARt, { el: t, userDuring: s }) : null, o.setToFinal = true, o.scope = n), Y(o, e[a]), o;
      }
      function GI(n, t, e, i) {
        i = i || {};
        var r = i.dataIndex, a = i.isInit, o = i.clearStyle, s = e.isAnimationEnabled(), l = ld(n), u = t.style;
        l.userDuring = t.during;
        var h = {}, c = {};
        if (vRt(n, t, c), f7("shape", t, c), f7("extra", t, c), !a && s && (pRt(n, t, h), c7("shape", n, t, h), c7("extra", n, t, h), yRt(n, t, u, h)), c.style = u, cRt(n, c, o), gRt(n, t), s) if (a) {
          var f = {};
          M(zI, function(d) {
            var A = d ? t[d] : t;
            A && A.enterFrom && (d && (f[d] = f[d] || {}), Y(d ? f[d] : f, A.enterFrom));
          });
          var g = vD("enter", n, t, e, r);
          g.duration > 0 && n.animateFrom(f, g);
        } else fRt(n, t, r || 0, e, h);
        h7(n, t), u ? n.dirty() : n.markRedraw();
      }
      function h7(n, t) {
        for (var e = ld(n).leaveToProps, i = 0; i < zI.length; i++) {
          var r = zI[i], a = r ? t[r] : t;
          a && a.leaveTo && (e || (e = ld(n).leaveToProps = {}), r && (e[r] = e[r] || {}), Y(r ? e[r] : e, a.leaveTo));
        }
      }
      function UI(n, t, e, i) {
        if (n) {
          var r = n.parent, a = ld(n).leaveToProps;
          if (a) {
            var o = vD("update", n, t, e, 0);
            o.done = function() {
              r.remove(n);
            }, n.animateTo(a, o);
          } else r.remove(n);
        }
      }
      function cc(n) {
        return n === "all";
      }
      function cRt(n, t, e) {
        var i = t.style;
        if (!n.isGroup && i) {
          if (e) {
            n.useStyle({});
            for (var r = n.animators, a = 0; a < r.length; a++) {
              var o = r[a];
              o.targetName === "style" && o.changeTarget(n.style);
            }
          }
          n.setStyle(i);
        }
        t && (t.style = null, t && n.attr(t), t.style = i);
      }
      function fRt(n, t, e, i, r) {
        if (r) {
          var a = vD("update", n, t, i, e);
          a.duration > 0 && n.animateFrom(r, a);
        }
      }
      function gRt(n, t) {
        ft(t, "silent") && (n.silent = t.silent), ft(t, "ignore") && (n.ignore = t.ignore), n instanceof ha && ft(t, "invisible") && (n.invisible = t.invisible), n instanceof Jt && ft(t, "autoBatch") && (n.autoBatch = t.autoBatch);
      }
      var Ho = {}, dRt = { setTransform: function(n, t) {
        return It(ft(OI, n), "Only " + u7 + " available in `setTransform`."), Ho.el[n] = t, this;
      }, getTransform: function(n) {
        return It(ft(OI, n), "Only " + u7 + " available in `getTransform`."), Ho.el[n];
      }, setShape: function(n, t) {
        ud(n);
        var e = Ho.el, i = e.shape || (e.shape = {});
        return i[n] = t, e.dirtyShape && e.dirtyShape(), this;
      }, getShape: function(n) {
        ud(n);
        var t = Ho.el.shape;
        if (t) return t[n];
      }, setStyle: function(n, t) {
        ud(n);
        var e = Ho.el, i = e.style;
        return i && (nh(t) && un("style." + n + " must not be assigned with NaN."), i[n] = t, e.dirtyStyle && e.dirtyStyle()), this;
      }, getStyle: function(n) {
        ud(n);
        var t = Ho.el.style;
        if (t) return t[n];
      }, setExtra: function(n, t) {
        ud(n);
        var e = Ho.el.extra || (Ho.el.extra = {});
        return e[n] = t, this;
      }, getExtra: function(n) {
        ud(n);
        var t = Ho.el.extra;
        if (t) return t[n];
      } };
      function ud(n) {
        if (n === "transition" || n === "enterFrom" || n === "leaveTo") throw new Error('key must not be "' + n + '"');
      }
      function ARt() {
        var n = this, t = n.el;
        if (t) {
          var e = ld(t).userDuring, i = n.userDuring;
          if (e !== i) {
            n.el = n.userDuring = null;
            return;
          }
          Ho.el = t, i(dRt);
        }
      }
      function c7(n, t, e, i) {
        var r = e[n];
        if (r) {
          var a = t[n], o;
          if (a) {
            var s = e.transition, l = r.transition;
            if (l) if (!o && (o = i[n] = {}), cc(l)) Y(o, a);
            else for (var u = Qe(l), h = 0; h < u.length; h++) {
              var c = u[h], f = a[c];
              o[c] = f;
            }
            else if (cc(s) || Wt(s, n) >= 0) {
              !o && (o = i[n] = {});
              for (var g = re(a), h = 0; h < g.length; h++) {
                var c = g[h], f = a[c];
                mRt(r[c], f) && (o[c] = f);
              }
            }
          }
        }
      }
      function f7(n, t, e) {
        var i = t[n];
        if (i) for (var r = e[n] = {}, a = re(i), o = 0; o < a.length; o++) {
          var s = a[o];
          r[s] = Ep(i[s]);
        }
      }
      function pRt(n, t, e) {
        for (var i = t.transition, r = cc(i) ? To : Qe(i || []), a = 0; a < r.length; a++) {
          var o = r[a];
          if (!(o === "style" || o === "shape" || o === "extra")) {
            var s = n[o];
            g7(o, "el.transition"), e[o] = s;
          }
        }
      }
      function vRt(n, t, e) {
        for (var i = 0; i < l7.length; i++) {
          var r = l7[i], a = s7[r], o = t[r];
          o && (e[a[0]] = o[0], e[a[1]] = o[1]);
        }
        for (var i = 0; i < To.length; i++) {
          var s = To[i];
          t[s] != null && (e[s] = t[s]);
        }
      }
      function yRt(n, t, e, i) {
        if (e) {
          var r = n.style, a;
          if (r) {
            var o = e.transition, s = t.transition;
            if (o && !cc(o)) {
              var l = Qe(o);
              !a && (a = i.style = {});
              for (var u = 0; u < l.length; u++) {
                var h = l[u], c = r[h];
                a[h] = c;
              }
            } else if (n.getAnimationStyleProps && (cc(s) || cc(o) || Wt(s, "style") >= 0)) {
              var f = n.getAnimationStyleProps(), g = f ? f.style : null;
              if (g) {
                !a && (a = i.style = {});
                for (var d = re(e), u = 0; u < d.length; u++) {
                  var h = d[u];
                  if (g[h]) {
                    var c = r[h];
                    a[h] = c;
                  }
                }
              }
            }
          }
        }
      }
      function mRt(n, t) {
        return Mi(n) ? n !== t : n != null && isFinite(n);
      }
      var g7;
      g7 = function(n, t) {
        ft(OI, n) || un("Prop `" + n + "` is not a permitted in `" + t + "`. Only `" + re(OI).join("`, `") + "` are permitted.");
      };
      var d7 = le(), _Rt = ["percent", "easing", "shape", "style", "extra"];
      function A7(n) {
        n.stopAnimation("keyframe"), n.attr(d7(n));
      }
      function VI(n, t, e) {
        if (!(!e.isAnimationEnabled() || !t)) {
          if (X(t)) {
            M(t, function(s) {
              VI(n, s, e);
            });
            return;
          }
          var i = t.keyframes, r = t.duration;
          if (e && r == null) {
            var a = wg("enter", e, 0);
            r = a && a.duration;
          }
          if (!(!i || !r)) {
            var o = d7(n);
            M(zI, function(s) {
              if (!(s && !n[s])) {
                var l, u = false;
                i.sort(function(h, c) {
                  return h.percent - c.percent;
                }), M(i, function(h) {
                  var c = n.animators, f = s ? h[s] : h;
                  if (h.percent >= 1 && (u = true), !!f) {
                    var g = re(f);
                    if (s || (g = Ne(g, function(p) {
                      return Wt(_Rt, p) < 0;
                    })), !!g.length) {
                      l || (l = n.animate(s, t.loop, true), l.scope = "keyframe");
                      for (var d = 0; d < c.length; d++) c[d] !== l && c[d].targetName === l.targetName && c[d].stopTracks(g);
                      s && (o[s] = o[s] || {});
                      var A = s ? o[s] : o;
                      M(g, function(p) {
                        A[p] = ((s ? n[s] : n) || {})[p];
                      }), l.whenWithKeys(r * h.percent, f, g, h.easing);
                    }
                  }
                }), l && (u || un("End frame with percent: 1 is missing in the keyframeAnimation.", true), l.delay(t.delay || 0).duration(r).start(t.easing));
              }
            });
          }
        }
      }
      var qs = "emphasis", Au = "normal", yD = "blur", mD = "select", pu = [Au, qs, yD, mD], _D = { normal: ["itemStyle"], emphasis: [qs, "itemStyle"], blur: [yD, "itemStyle"], select: [mD, "itemStyle"] }, ID = { normal: ["label"], emphasis: [qs, "label"], blur: [yD, "label"], select: [mD, "label"] }, IRt = ["x", "y"], ERt = "e\0\0", Ea = { normal: {}, emphasis: {}, blur: {}, select: {} }, p7 = { cartesian2d: iRt, geo: aRt, single: sRt, polar: uRt, calendar: hRt };
      function jI(n) {
        return n instanceof Jt;
      }
      function ED(n) {
        return n instanceof ha;
      }
      function xRt(n, t) {
        t.copyTransform(n), ED(t) && ED(n) && (t.setStyle(n.style), t.z = n.z, t.z2 = n.z2, t.zlevel = n.zlevel, t.invisible = n.invisible, t.ignore = n.ignore, jI(t) && jI(n) && t.setShape(n.shape));
      }
      var wRt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r, a) {
          this._progressiveEls = null;
          var o = this._data, s = e.getData(), l = this.group, u = y7(e, s, i, r);
          o || l.removeAll(), s.diff(o).add(function(c) {
            CD(r, null, c, u(c, a), e, l, s);
          }).remove(function(c) {
            var f = o.getItemGraphicEl(c);
            f && UI(f, js(f).option, e);
          }).update(function(c, f) {
            var g = o.getItemGraphicEl(f);
            CD(r, g, c, u(c, a), e, l, s);
          }).execute();
          var h = e.get("clip", true) ? bv(e.coordinateSystem, false, e) : null;
          h ? l.setClipPath(h) : l.removeClipPath(), this._data = s;
        }, t.prototype.incrementalPrepareRender = function(e, i, r) {
          this.group.removeAll(), this._data = null;
        }, t.prototype.incrementalRender = function(e, i, r, a, o) {
          var s = i.getData(), l = y7(i, s, r, a), u = this._progressiveEls = [];
          function h(g) {
            g.isGroup || (g.incremental = true, g.ensureState("emphasis").hoverLayer = true);
          }
          for (var c = e.start; c < e.end; c++) {
            var f = CD(null, null, c, l(c, o), i, this.group, s);
            f && (f.traverse(h), u.push(f));
          }
        }, t.prototype.eachRendered = function(e) {
          tu(this._progressiveEls || this.group, e);
        }, t.prototype.filterForExposedEvent = function(e, i, r, a) {
          var o = i.element;
          if (o == null || r.name === o) return true;
          for (; (r = r.__hostTarget || r.parent) && r !== this.group; ) if (r.name === o) return true;
          return false;
        }, t.type = "custom", t;
      }(Ve);
      function xD(n) {
        var t = n.type, e;
        if (t === "path") {
          var i = n.shape, r = i.width != null && i.height != null ? { x: i.x || 0, y: i.y || 0, width: i.width, height: i.height } : null, a = x7(i);
          e = h1(a, null, r, i.layout || "center"), js(e).customPathData = a;
        } else if (t === "image") e = new li({}), js(e).customImagePath = n.style.image;
        else if (t === "text") e = new ge({});
        else if (t === "group") e = new Ct();
        else {
          if (t === "compoundPath") throw new Error('"compoundPath" is not supported yet.');
          var o = J2(t);
          if (!o) {
            var s = "";
            s = 'graphic type "' + t + '" can not be found.', Ce(s);
          }
          e = new o();
        }
        return js(e).customGraphicType = t, e.name = n.name, e.z2EmphasisLift = 1, e.z2SelectLift = 1, e;
      }
      function wD(n, t, e, i, r, a, o) {
        A7(t);
        var s = r && r.normal.cfg;
        s && t.setTextConfig(s), i && i.transition == null && (i.transition = IRt);
        var l = i && i.style;
        if (l) {
          if (t.type === "text") {
            var u = l;
            ft(u, "textFill") && (u.fill = u.textFill), ft(u, "textStroke") && (u.stroke = u.textStroke);
          }
          var h = void 0, c = jI(t) ? l.decal : null;
          n && c && (c.dirty = true, h = qg(c, n)), l.__decalPattern = h;
        }
        if (ED(t) && l) {
          var h = l.__decalPattern;
          h && (l.decal = h);
        }
        GI(t, i, a, { dataIndex: e, isInit: o, clearStyle: true }), VI(t, i.keyframeAnimation, a);
      }
      function v7(n, t, e, i, r) {
        var a = t.isGroup ? null : t, o = r && r[n].cfg;
        if (a) {
          var s = a.ensureState(n);
          if (i === false) {
            var l = a.getState(n);
            l && (l.style = null);
          } else s.style = i || null;
          o && (s.textConfig = o), bh(a);
        }
      }
      function CRt(n, t, e) {
        if (!n.isGroup) {
          var i = n, r = e.currentZ, a = e.currentZLevel;
          i.z = r, i.zlevel = a;
          var o = t.z2;
          o != null && (i.z2 = o || 0);
          for (var s = 0; s < pu.length; s++) SRt(i, t, pu[s]);
        }
      }
      function SRt(n, t, e) {
        var i = e === Au, r = i ? t : qI(t, e), a = r ? r.z2 : null, o;
        a != null && (o = i ? n : n.ensureState(e), o.z2 = a || 0);
      }
      function y7(n, t, e, i) {
        var r = n.get("renderItem"), a = n.coordinateSystem, o = {};
        a && (It(r, "series.render is required."), It(a.prepareCustoms || p7[a.type], "This coordSys does not support custom series."), o = a.prepareCustoms ? a.prepareCustoms(a) : p7[a.type](a));
        for (var s = Et({ getWidth: i.getWidth, getHeight: i.getHeight, getZr: i.getZr, getDevicePixelRatio: i.getDevicePixelRatio, value: _, style: I, ordinalRawValue: E, styleEmphasis: x, visual: S, barLayout: b, currentSeriesIndices: B, font: T }, o.api || {}), l = { context: {}, seriesId: n.id, seriesName: n.name, seriesIndex: n.seriesIndex, coordSys: o.coordSys, dataInsideLength: t.count(), encode: bRt(n.getData()) }, u, h, c = {}, f = {}, g = {}, d = {}, A = 0; A < pu.length; A++) {
          var p = pu[A];
          g[p] = n.getModel(_D[p]), d[p] = n.getModel(ID[p]);
        }
        function v(D) {
          return D === u ? h || (h = t.getItemModel(D)) : t.getItemModel(D);
        }
        function y(D, R) {
          return t.hasItemOption ? D === u ? c[R] || (c[R] = v(D).getModel(_D[R])) : v(D).getModel(_D[R]) : g[R];
        }
        function m(D, R) {
          return t.hasItemOption ? D === u ? f[R] || (f[R] = v(D).getModel(ID[R])) : v(D).getModel(ID[R]) : d[R];
        }
        return function(D, R) {
          return u = D, h = null, c = {}, f = {}, r && r(Et({ dataIndexInside: D, dataIndex: t.getRawIndex(D), actionType: R ? R.type : null }, l), s);
        };
        function _(D, R) {
          return R == null && (R = u), t.getStore().get(t.getDimensionIndex(D || 0), R);
        }
        function E(D, R) {
          R == null && (R = u), D = D || 0;
          var L = t.getDimensionInfo(D);
          if (!L) {
            var k = t.getDimensionIndex(D);
            return k >= 0 ? t.getStore().get(k, R) : void 0;
          }
          var P = t.get(L.name, R), F = L && L.ordinalMeta;
          return F ? F.categories[P] : P;
        }
        function I(D, R) {
          o7("api.style", "Please write literal style directly instead."), R == null && (R = u);
          var L = t.getItemVisual(R, "style"), k = L && L.fill, P = L && L.opacity, F = y(R, Au).getItemStyle();
          k != null && (F.fill = k), P != null && (F.opacity = P);
          var Q = { inheritColor: ht(k) ? k : "#000" }, z = m(R, Au), j = Ke(z, null, Q, false, true);
          j.text = z.getShallow("show") ? Pt(n.getFormattedLabel(R, Au), $g(t, R)) : null;
          var $ = d1(z, Q, false);
          return C(D, F), F = r7(F, j, $), D && w(F, D), F.legacy = true, F;
        }
        function x(D, R) {
          o7("api.styleEmphasis", "Please write literal style directly instead."), R == null && (R = u);
          var L = y(R, qs).getItemStyle(), k = m(R, qs), P = Ke(k, null, null, true, true);
          P.text = k.getShallow("show") ? ra(n.getFormattedLabel(R, qs), n.getFormattedLabel(R, Au), $g(t, R)) : null;
          var F = d1(k, null, true);
          return C(D, L), L = r7(L, P, F), D && w(L, D), L.legacy = true, L;
        }
        function w(D, R) {
          for (var L in R) ft(R, L) && (D[L] = R[L]);
        }
        function C(D, R) {
          D && (D.textFill && (R.textFill = D.textFill), D.textPosition && (R.textPosition = D.textPosition));
        }
        function S(D, R) {
          if (R == null && (R = u), ft(Jq, D)) {
            var L = t.getItemVisual(R, "style");
            return L ? L[Jq[D]] : null;
          }
          if (ft(tRt, D)) return t.getItemVisual(R, D);
        }
        function b(D) {
          if (a.type === "cartesian2d") {
            var R = a.getBaseAxis();
            return vwt(Et({ axis: R }, D));
          }
        }
        function B() {
          return e.getCurrentSeriesIndices();
        }
        function T(D) {
          return nB(D, e);
        }
      }
      function bRt(n) {
        var t = {};
        return M(n.dimensions, function(e) {
          var i = n.getDimensionInfo(e);
          if (!i.isExtraCoord) {
            var r = i.coordDim, a = t[r] = t[r] || [];
            a[i.coordDimIndex] = n.getDimensionIndex(e);
          }
        }), t;
      }
      function CD(n, t, e, i, r, a, o) {
        if (!i) {
          a.remove(t);
          return;
        }
        var s = SD(n, t, e, i, r, a);
        return s && o.setItemGraphicEl(e, s), s && hn(s, i.focus, i.blurScope, i.emphasisDisabled), s;
      }
      function SD(n, t, e, i, r, a) {
        It(i, "should not have an null/undefined element setting");
        var o = -1, s = t;
        t && m7(t, i, r) && (o = Wt(a.childrenRef(), t), t = null);
        var l = !t, u = t;
        u ? u.clearStates() : (u = xD(i), s && xRt(s, u)), i.morph === false ? u.disableMorphing = true : u.disableMorphing && (u.disableMorphing = false), Ea.normal.cfg = Ea.normal.conOpt = Ea.emphasis.cfg = Ea.emphasis.conOpt = Ea.blur.cfg = Ea.blur.conOpt = Ea.select.cfg = Ea.select.conOpt = null, Ea.isLegacy = false, TRt(u, e, i, r, l, Ea), BRt(u, e, i, r, l), wD(n, u, e, i, Ea, r, l), ft(i, "info") && (js(u).info = i.info);
        for (var h = 0; h < pu.length; h++) {
          var c = pu[h];
          if (c !== Au) {
            var f = qI(i, c), g = bD(i, f, c);
            v7(c, u, f, g, Ea);
          }
        }
        return CRt(u, i, r), i.type === "group" && MRt(n, u, e, i, r), o >= 0 ? a.replaceAt(u, o) : a.add(u), u;
      }
      function m7(n, t, e) {
        var i = js(n), r = t.type, a = t.shape, o = t.style;
        return e.isUniversalTransitionEnabled() || r != null && r !== i.customGraphicType || r === "path" && PRt(a) && x7(a) !== i.customPathData || r === "image" && ft(o, "image") && o.image !== i.customImagePath;
      }
      function BRt(n, t, e, i, r) {
        var a = e.clipPath;
        if (a === false) n && n.getClipPath() && n.removeClipPath();
        else if (a) {
          var o = n.getClipPath();
          o && m7(o, a, i) && (o = null), o || (o = xD(a), It(jI(o), "Only any type of `path` can be used in `clipPath`, rather than " + o.type + "."), n.setClipPath(o)), wD(null, o, t, a, null, i, r);
        }
      }
      function TRt(n, t, e, i, r, a) {
        if (!n.isGroup) {
          _7(e, null, a), _7(e, qs, a);
          var o = a.normal.conOpt, s = a.emphasis.conOpt, l = a.blur.conOpt, u = a.select.conOpt;
          if (o != null || s != null || u != null || l != null) {
            var h = n.getTextContent();
            if (o === false) h && n.removeTextContent();
            else {
              o = a.normal.conOpt = o || { type: "text" }, h ? h.clearStates() : (h = xD(o), n.setTextContent(h)), wD(null, h, t, o, null, i, r);
              for (var c = o && o.style, f = 0; f < pu.length; f++) {
                var g = pu[f];
                if (g !== Au) {
                  var d = a[g].conOpt;
                  v7(g, h, d, bD(o, d, g), null);
                }
              }
              c ? h.dirty() : h.markRedraw();
            }
          }
        }
      }
      function _7(n, t, e) {
        var i = t ? qI(n, t) : n, r = t ? bD(n, i, qs) : n.style, a = n.type, o = i ? i.textConfig : null, s = n.textContent, l = s ? t ? qI(s, t) : s : null;
        if (r && (e.isLegacy || e7(r, a, !!o, !!l))) {
          e.isLegacy = true;
          var u = n7(r, a, !t);
          !o && u.textConfig && (o = u.textConfig), !l && u.textContent && (l = u.textContent);
        }
        if (!t && l) {
          var h = l;
          !h.type && (h.type = "text"), It(h.type === "text", 'textContent.type must be "text"');
        }
        var c = t ? e[t] : e.normal;
        c.cfg = o, c.conOpt = l;
      }
      function qI(n, t) {
        return t ? n ? n[t] : null : n;
      }
      function bD(n, t, e) {
        var i = t && t.style;
        return i == null && e === qs && n && (i = n.styleEmphasis), i;
      }
      function MRt(n, t, e, i, r) {
        var a = i.children, o = a ? a.length : 0, s = i.$mergeChildren, l = s === "byName" || i.diffChildrenByName, u = s === false;
        if (!(!o && !l && !u)) {
          if (l) {
            RRt({ api: n, oldChildren: t.children() || [], newChildren: a || [], dataIndex: e, seriesModel: r, group: t });
            return;
          }
          u && t.removeAll();
          for (var h = 0; h < o; h++) {
            var c = a[h], f = t.childAt(h);
            c ? (c.ignore == null && (c.ignore = false), SD(n, f, e, c, r, t)) : (It(f, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before."), f.ignore = true);
          }
          for (var g = t.childCount() - 1; g >= h; g--) {
            var d = t.childAt(g);
            DRt(t, d, r);
          }
        }
      }
      function DRt(n, t, e) {
        t && UI(t, js(n).option, e);
      }
      function RRt(n) {
        new Os(n.oldChildren, n.newChildren, I7, I7, n).add(E7).update(E7).remove(LRt).execute();
      }
      function I7(n, t) {
        var e = n && n.name;
        return e != null ? e : ERt + t;
      }
      function E7(n, t) {
        var e = this.context, i = n != null ? e.newChildren[n] : null, r = t != null ? e.oldChildren[t] : null;
        SD(e.api, r, e.dataIndex, i, e.seriesModel, e.group);
      }
      function LRt(n) {
        var t = this.context, e = t.oldChildren[n];
        e && UI(e, js(e).option, t.seriesModel);
      }
      function x7(n) {
        return n && (n.pathData || n.d);
      }
      function PRt(n) {
        return n && (ft(n, "pathData") || ft(n, "d"));
      }
      function NRt(n) {
        n.registerChartView(wRt), n.registerSeriesModel(eRt);
      }
      var fc = le(), w7 = xt, BD = ct, TD = function() {
        function n() {
          this._dragging = false, this.animationThreshold = 15;
        }
        return n.prototype.render = function(t, e, i, r) {
          var a = e.get("value"), o = e.get("status");
          if (this._axisModel = t, this._axisPointerModel = e, this._api = i, !(!r && this._lastValue === a && this._lastStatus === o)) {
            this._lastValue = a, this._lastStatus = o;
            var s = this._group, l = this._handle;
            if (!o || o === "hide") {
              s && s.hide(), l && l.hide();
              return;
            }
            s && s.show(), l && l.show();
            var u = {};
            this.makeElOption(u, a, t, e, i);
            var h = u.graphicKey;
            h !== this._lastGraphicKey && this.clear(i), this._lastGraphicKey = h;
            var c = this._moveAnimation = this.determineAnimation(t, e);
            if (!s) s = this._group = new Ct(), this.createPointerEl(s, u, t, e), this.createLabelEl(s, u, t, e), i.getZr().add(s);
            else {
              var f = Ot(C7, e, c);
              this.updatePointerEl(s, u, f), this.updateLabelEl(s, u, f, e);
            }
            B7(s, e, true), this._renderHandle(a);
          }
        }, n.prototype.remove = function(t) {
          this.clear(t);
        }, n.prototype.dispose = function(t) {
          this.clear(t);
        }, n.prototype.determineAnimation = function(t, e) {
          var i = e.get("animation"), r = t.axis, a = r.type === "category", o = e.get("snap");
          if (!o && !a) return false;
          if (i === "auto" || i == null) {
            var s = this.animationThreshold;
            if (a && r.getBandWidth() > s) return true;
            if (o) {
              var l = $T(t).seriesDataCount, u = r.getExtent();
              return Math.abs(u[0] - u[1]) / l > s;
            }
            return false;
          }
          return i === true;
        }, n.prototype.makeElOption = function(t, e, i, r, a) {
        }, n.prototype.createPointerEl = function(t, e, i, r) {
          var a = e.pointer;
          if (a) {
            var o = fc(t).pointerEl = new Ph[a.type](w7(e.pointer));
            t.add(o);
          }
        }, n.prototype.createLabelEl = function(t, e, i, r) {
          if (e.label) {
            var a = fc(t).labelEl = new ge(w7(e.label));
            t.add(a), b7(a, r);
          }
        }, n.prototype.updatePointerEl = function(t, e, i) {
          var r = fc(t).pointerEl;
          r && e.pointer && (r.setStyle(e.pointer.style), i(r, { shape: e.pointer.shape }));
        }, n.prototype.updateLabelEl = function(t, e, i, r) {
          var a = fc(t).labelEl;
          a && (a.setStyle(e.label.style), i(a, { x: e.label.x, y: e.label.y }), b7(a, r));
        }, n.prototype._renderHandle = function(t) {
          if (!(this._dragging || !this.updateHandleTransform)) {
            var e = this._axisPointerModel, i = this._api.getZr(), r = this._handle, a = e.getModel("handle"), o = e.get("status");
            if (!a.get("show") || !o || o === "hide") {
              r && i.remove(r), this._handle = null;
              return;
            }
            var s;
            this._handle || (s = true, r = this._handle = Hp(a.get("icon"), { cursor: "move", draggable: true, onmousemove: function(u) {
              Cs(u.event);
            }, onmousedown: BD(this._onHandleDragMove, this, 0, 0), drift: BD(this._onHandleDragMove, this), ondragend: BD(this._onHandleDragEnd, this) }), i.add(r)), B7(r, e, false), r.setStyle(a.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
            var l = a.get("size");
            X(l) || (l = [l, l]), r.scaleX = l[0] / 2, r.scaleY = l[1] / 2, Gg(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, s);
          }
        }, n.prototype._moveHandleToValue = function(t, e) {
          C7(this._axisPointerModel, !e && this._moveAnimation, this._handle, MD(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
        }, n.prototype._onHandleDragMove = function(t, e) {
          var i = this._handle;
          if (i) {
            this._dragging = true;
            var r = this.updateHandleTransform(MD(i), [t, e], this._axisModel, this._axisPointerModel);
            this._payloadInfo = r, i.stopAnimation(), i.attr(MD(r)), fc(i).lastProp = null, this._doDispatchAxisPointer();
          }
        }, n.prototype._doDispatchAxisPointer = function() {
          var t = this._handle;
          if (t) {
            var e = this._payloadInfo, i = this._axisModel;
            this._api.dispatchAction({ type: "updateAxisPointer", x: e.cursorPoint[0], y: e.cursorPoint[1], tooltipOption: e.tooltipOption, axesInfo: [{ axisDim: i.axis.dim, axisIndex: i.componentIndex }] });
          }
        }, n.prototype._onHandleDragEnd = function() {
          this._dragging = false;
          var t = this._handle;
          if (t) {
            var e = this._axisPointerModel.get("value");
            this._moveHandleToValue(e), this._api.dispatchAction({ type: "hideTip" });
          }
        }, n.prototype.clear = function(t) {
          this._lastValue = null, this._lastStatus = null;
          var e = t.getZr(), i = this._group, r = this._handle;
          e && i && (this._lastGraphicKey = null, i && e.remove(i), r && e.remove(r), this._group = null, this._handle = null, this._payloadInfo = null), av(this, "_doDispatchAxisPointer");
        }, n.prototype.doClear = function() {
        }, n.prototype.buildLabel = function(t, e, i) {
          return i = i || 0, { x: t[i], y: t[1 - i], width: e[i], height: e[1 - i] };
        }, n;
      }();
      function C7(n, t, e, i) {
        S7(fc(e).lastProp, i) || (fc(e).lastProp = i, t ? _e(e, i, n) : (e.stopAnimation(), e.attr(i)));
      }
      function S7(n, t) {
        if (_t(n) && _t(t)) {
          var e = true;
          return M(t, function(i, r) {
            e = e && S7(n[r], i);
          }), !!e;
        } else return n === t;
      }
      function b7(n, t) {
        n[t.get(["label", "show"]) ? "show" : "hide"]();
      }
      function MD(n) {
        return { x: n.x || 0, y: n.y || 0, rotation: n.rotation || 0 };
      }
      function B7(n, t, e) {
        var i = t.get("z"), r = t.get("zlevel");
        n && n.traverse(function(a) {
          a.type !== "group" && (i != null && (a.z = i), r != null && (a.zlevel = r), a.silent = e);
        });
      }
      function DD(n) {
        var t = n.get("type"), e = n.getModel(t + "Style"), i;
        return t === "line" ? (i = e.getLineStyle(), i.fill = null) : t === "shadow" && (i = e.getAreaStyle(), i.stroke = null), i;
      }
      function T7(n, t, e, i, r) {
        var a = e.get("value"), o = M7(a, t.axis, t.ecModel, e.get("seriesDataIndices"), { precision: e.get(["label", "precision"]), formatter: e.get(["label", "formatter"]) }), s = e.getModel("label"), l = Lg(s.get("padding") || 0), u = s.getFont(), h = Cp(o, u), c = r.position, f = h.width + l[1] + l[3], g = h.height + l[0] + l[2], d = r.align;
        d === "right" && (c[0] -= f), d === "center" && (c[0] -= f / 2);
        var A = r.verticalAlign;
        A === "bottom" && (c[1] -= g), A === "middle" && (c[1] -= g / 2), kRt(c, f, g, i);
        var p = s.get("backgroundColor");
        (!p || p === "auto") && (p = t.get(["axisLine", "lineStyle", "color"])), n.label = { x: c[0], y: c[1], style: Ke(s, { text: o, font: u, fill: s.getTextColor(), padding: l, backgroundColor: p }), z2: 10 };
      }
      function kRt(n, t, e, i) {
        var r = i.getWidth(), a = i.getHeight();
        n[0] = Math.min(n[0] + t, r) - t, n[1] = Math.min(n[1] + e, a) - e, n[0] = Math.max(n[0], 0), n[1] = Math.max(n[1], 0);
      }
      function M7(n, t, e, i, r) {
        n = t.scale.parse(n);
        var a = t.scale.getLabel({ value: n }, { precision: r.precision }), o = r.formatter;
        if (o) {
          var s = { value: vT(t, { value: n }), axisDimension: t.dim, axisIndex: t.index, seriesData: [] };
          M(i, function(l) {
            var u = e.getSeriesByIndex(l.seriesIndex), h = l.dataIndexInside, c = u && u.getDataParams(h);
            c && s.seriesData.push(c);
          }), ht(o) ? a = o.replace("{value}", a) : yt(o) && (a = o(s));
        }
        return a;
      }
      function RD(n, t, e) {
        var i = Fr();
        return oh(i, i, e.rotation), bo(i, i, e.position), Xa([n.dataToCoord(t), (e.labelOffset || 0) + (e.labelDirection || 1) * (e.labelMargin || 0)], i);
      }
      function D7(n, t, e, i, r, a) {
        var o = Ji.innerTextLayout(e.rotation, 0, e.labelDirection);
        e.labelMargin = r.get(["label", "margin"]), T7(t, i, r, a, { position: RD(i.axis, n, e), align: o.textAlign, verticalAlign: o.textVerticalAlign });
      }
      function LD(n, t, e) {
        return e = e || 0, { x1: n[e], y1: n[1 - e], x2: t[e], y2: t[1 - e] };
      }
      function R7(n, t, e) {
        return e = e || 0, { x: n[e], y: n[1 - e], width: t[e], height: t[1 - e] };
      }
      function L7(n, t, e, i, r, a) {
        return { cx: n, cy: t, r0: e, r: i, startAngle: r, endAngle: a, clockwise: true };
      }
      var FRt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.makeElOption = function(e, i, r, a, o) {
          var s = r.axis, l = s.grid, u = a.get("type"), h = P7(l, s).getOtherAxis(s).getGlobalExtent(), c = s.toGlobalCoord(s.dataToCoord(i, true));
          if (u && u !== "none") {
            var f = DD(a), g = QRt[u](s, c, h);
            g.style = f, e.graphicKey = g.type, e.pointer = g;
          }
          var d = WT(l.model, r);
          D7(i, e, d, r, a, o);
        }, t.prototype.getHandleTransform = function(e, i, r) {
          var a = WT(i.axis.grid.model, i, { labelInside: false });
          a.labelMargin = r.get(["handle", "margin"]);
          var o = RD(i.axis, e, a);
          return { x: o[0], y: o[1], rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0) };
        }, t.prototype.updateHandleTransform = function(e, i, r, a) {
          var o = r.axis, s = o.grid, l = o.getGlobalExtent(true), u = P7(s, o).getOtherAxis(o).getGlobalExtent(), h = o.dim === "x" ? 0 : 1, c = [e.x, e.y];
          c[h] += i[h], c[h] = Math.min(l[1], c[h]), c[h] = Math.max(l[0], c[h]);
          var f = (u[1] + u[0]) / 2, g = [f, f];
          g[h] = c[h];
          var d = [{ verticalAlign: "middle" }, { align: "center" }];
          return { x: c[0], y: c[1], rotation: e.rotation, cursorPoint: g, tooltipOption: d[h] };
        }, t;
      }(TD);
      function P7(n, t) {
        var e = {};
        return e[t.dim + "AxisIndex"] = t.index, n.getCartesian(e);
      }
      var QRt = { line: function(n, t, e) {
        var i = LD([t, e[0]], [t, e[1]], N7(n));
        return { type: "Line", subPixelOptimize: true, shape: i };
      }, shadow: function(n, t, e) {
        var i = Math.max(1, n.getBandWidth()), r = e[1] - e[0];
        return { type: "Rect", shape: R7([t - i / 2, e[0]], [i, r], N7(n)) };
      } };
      function N7(n) {
        return n.dim === "x" ? 0 : 1;
      }
      var ORt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "axisPointer", t.defaultOption = { show: "auto", z: 50, type: "line", snap: false, triggerTooltip: true, triggerEmphasis: true, value: null, status: null, link: [], animation: null, animationDurationUpdate: 200, lineStyle: { color: "#B9BEC9", width: 1, type: "dashed" }, shadowStyle: { color: "rgba(210,219,238,0.2)" }, label: { show: true, formatter: null, precision: "auto", margin: 3, color: "#fff", padding: [5, 7, 5, 7], backgroundColor: "auto", borderColor: null, borderWidth: 0, borderRadius: 3 }, handle: { show: false, icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z", size: 45, margin: 50, color: "#333", shadowBlur: 3, shadowColor: "#aaa", shadowOffsetX: 0, shadowOffsetY: 2, throttle: 40 } }, t;
      }(ne), Hs = le(), zRt = M;
      function k7(n, t, e) {
        if (!ee.node) {
          var i = t.getZr();
          Hs(i).records || (Hs(i).records = {}), GRt(i, t);
          var r = Hs(i).records[n] || (Hs(i).records[n] = {});
          r.handler = e;
        }
      }
      function GRt(n, t) {
        if (Hs(n).initialized) return;
        Hs(n).initialized = true, e("click", Ot(F7, "click")), e("mousemove", Ot(F7, "mousemove")), e("globalout", VRt);
        function e(i, r) {
          n.on(i, function(a) {
            var o = jRt(t);
            zRt(Hs(n).records, function(s) {
              s && r(s, a, o.dispatchAction);
            }), URt(o.pendings, t);
          });
        }
      }
      function URt(n, t) {
        var e = n.showTip.length, i = n.hideTip.length, r;
        e ? r = n.showTip[e - 1] : i && (r = n.hideTip[i - 1]), r && (r.dispatchAction = null, t.dispatchAction(r));
      }
      function VRt(n, t, e) {
        n.handler("leave", null, e);
      }
      function F7(n, t, e, i) {
        t.handler(n, e, i);
      }
      function jRt(n) {
        var t = { showTip: [], hideTip: [] }, e = function(i) {
          var r = t[i.type];
          r ? r.push(i) : (i.dispatchAction = e, n.dispatchAction(i));
        };
        return { dispatchAction: e, pendings: t };
      }
      function PD(n, t) {
        if (!ee.node) {
          var e = t.getZr(), i = (Hs(e).records || {})[n];
          i && (Hs(e).records[n] = null);
        }
      }
      var qRt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = i.getComponent("tooltip"), o = e.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
          k7("axisPointer", r, function(s, l, u) {
            o !== "none" && (s === "leave" || o.indexOf(s) >= 0) && u({ type: "updateAxisPointer", currTrigger: s, x: l && l.offsetX, y: l && l.offsetY });
          });
        }, t.prototype.remove = function(e, i) {
          PD("axisPointer", i);
        }, t.prototype.dispose = function(e, i) {
          PD("axisPointer", i);
        }, t.type = "axisPointer", t;
      }(on);
      function Q7(n, t) {
        var e = [], i = n.seriesIndex, r;
        if (i == null || !(r = t.getSeriesByIndex(i))) return { point: [] };
        var a = r.getData(), o = Ah(a, n);
        if (o == null || o < 0 || X(o)) return { point: [] };
        var s = a.getItemGraphicEl(o), l = r.coordinateSystem;
        if (r.getTooltipPosition) e = r.getTooltipPosition(o) || [];
        else if (l && l.dataToPoint) if (n.isStacked) {
          var u = l.getBaseAxis(), h = l.getOtherAxis(u), c = h.dim, f = u.dim, g = c === "x" || c === "radius" ? 1 : 0, d = a.mapDimension(f), A = [];
          A[g] = a.get(d, o), A[1 - g] = a.get(a.getCalculationInfo("stackResultDimension"), o), e = l.dataToPoint(A) || [];
        } else e = l.dataToPoint(a.getValues(Z(l.dimensions, function(v) {
          return a.mapDimension(v);
        }), o)) || [];
        else if (s) {
          var p = s.getBoundingRect().clone();
          p.applyTransform(s.transform), e = [p.x + p.width / 2, p.y + p.height / 2];
        }
        return { point: e, el: s };
      }
      var O7 = le();
      function HRt(n, t, e) {
        var i = n.currTrigger, r = [n.x, n.y], a = n, o = n.dispatchAction || ct(e.dispatchAction, e), s = t.getComponent("axisPointer").coordSysAxesInfo;
        if (s) {
          HI(r) && (r = Q7({ seriesIndex: a.seriesIndex, dataIndex: a.dataIndex }, t).point);
          var l = HI(r), u = a.axesInfo, h = s.axesInfo, c = i === "leave" || HI(r), f = {}, g = {}, d = { list: [], map: {} }, A = { showPointer: Ot(WRt, g), showTooltip: Ot(XRt, d) };
          M(s.coordSysMap, function(v, y) {
            var m = l || v.containPoint(r);
            M(s.coordSysAxesInfo[y], function(_, E) {
              var I = _.axis, x = JRt(u, _);
              if (!c && m && (!u || x)) {
                var w = x && x.value;
                w == null && !l && (w = I.pointToData(r)), w != null && z7(_, w, A, false, f);
              }
            });
          });
          var p = {};
          return M(h, function(v, y) {
            var m = v.linkGroup;
            m && !g[y] && M(m.axesInfo, function(_, E) {
              var I = g[E];
              if (_ !== v && I) {
                var x = I.value;
                m.mapper && (x = v.axis.scale.parse(m.mapper(x, G7(_), G7(v)))), p[v.key] = x;
              }
            });
          }), M(p, function(v, y) {
            z7(h[y], v, A, true, f);
          }), ZRt(g, h, f), KRt(d, r, n, o), $Rt(h, o, e), f;
        }
      }
      function z7(n, t, e, i, r) {
        var a = n.axis;
        if (!(a.scale.isBlank() || !a.containData(t))) {
          if (!n.involveSeries) {
            e.showPointer(n, t);
            return;
          }
          var o = YRt(t, n), s = o.payloadBatch, l = o.snapToValue;
          s[0] && r.seriesIndex == null && Y(r, s[0]), !i && n.snap && a.containData(l) && l != null && (t = l), e.showPointer(n, t, s), e.showTooltip(n, o, l);
        }
      }
      function YRt(n, t) {
        var e = t.axis, i = e.dim, r = n, a = [], o = Number.MAX_VALUE, s = -1;
        return M(t.seriesModels, function(l, u) {
          var h = l.getData().mapDimensionsAll(i), c, f;
          if (l.getAxisTooltipData) {
            var g = l.getAxisTooltipData(h, n, e);
            f = g.dataIndices, c = g.nestestValue;
          } else {
            if (f = l.getData().indicesOfNearest(h[0], n, e.type === "category" ? 0.5 : null), !f.length) return;
            c = l.getData().get(h[0], f[0]);
          }
          if (!(c == null || !isFinite(c))) {
            var d = n - c, A = Math.abs(d);
            A <= o && ((A < o || d >= 0 && s < 0) && (o = A, s = d, r = c, a.length = 0), M(f, function(p) {
              a.push({ seriesIndex: l.seriesIndex, dataIndexInside: p, dataIndex: l.getData().getRawIndex(p) });
            }));
          }
        }), { payloadBatch: a, snapToValue: r };
      }
      function WRt(n, t, e, i) {
        n[t.key] = { value: e, payloadBatch: i };
      }
      function XRt(n, t, e, i) {
        var r = e.payloadBatch, a = t.axis, o = a.model, s = t.axisPointerModel;
        if (!(!t.triggerTooltip || !r.length)) {
          var l = t.coordSys.model, u = Rv(l), h = n.map[u];
          h || (h = n.map[u] = { coordSysId: l.id, coordSysIndex: l.componentIndex, coordSysType: l.type, coordSysMainType: l.mainType, dataByAxis: [] }, n.list.push(h)), h.dataByAxis.push({ axisDim: a.dim, axisIndex: o.componentIndex, axisType: o.type, axisId: o.id, value: i, valueLabelOpt: { precision: s.get(["label", "precision"]), formatter: s.get(["label", "formatter"]) }, seriesDataIndices: r.slice() });
        }
      }
      function ZRt(n, t, e) {
        var i = e.axesInfo = [];
        M(t, function(r, a) {
          var o = r.axisPointerModel.option, s = n[a];
          s ? (!r.useHandle && (o.status = "show"), o.value = s.value, o.seriesDataIndices = (s.payloadBatch || []).slice()) : !r.useHandle && (o.status = "hide"), o.status === "show" && i.push({ axisDim: r.axis.dim, axisIndex: r.axis.model.componentIndex, value: o.value });
        });
      }
      function KRt(n, t, e, i) {
        if (HI(t) || !n.list.length) {
          i({ type: "hideTip" });
          return;
        }
        var r = ((n.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
        i({ type: "showTip", escapeConnect: true, x: t[0], y: t[1], tooltipOption: e.tooltipOption, position: e.position, dataIndexInside: r.dataIndexInside, dataIndex: r.dataIndex, seriesIndex: r.seriesIndex, dataByCoordSys: n.list });
      }
      function $Rt(n, t, e) {
        var i = e.getZr(), r = "axisPointerLastHighlights", a = O7(i)[r] || {}, o = O7(i)[r] = {};
        M(n, function(u, h) {
          var c = u.axisPointerModel.option;
          c.status === "show" && u.triggerEmphasis && M(c.seriesDataIndices, function(f) {
            var g = f.seriesIndex + " | " + f.dataIndex;
            o[g] = f;
          });
        });
        var s = [], l = [];
        M(a, function(u, h) {
          !o[h] && l.push(u);
        }), M(o, function(u, h) {
          !a[h] && s.push(u);
        }), l.length && e.dispatchAction({ type: "downplay", escapeConnect: true, notBlur: true, batch: l }), s.length && e.dispatchAction({ type: "highlight", escapeConnect: true, notBlur: true, batch: s });
      }
      function JRt(n, t) {
        for (var e = 0; e < (n || []).length; e++) {
          var i = n[e];
          if (t.axis.dim === i.axisDim && t.axis.model.componentIndex === i.axisIndex) return i;
        }
      }
      function G7(n) {
        var t = n.axis.model, e = {}, i = e.axisDim = n.axis.dim;
        return e.axisIndex = e[i + "AxisIndex"] = t.componentIndex, e.axisName = e[i + "AxisName"] = t.name, e.axisId = e[i + "AxisId"] = t.id, e;
      }
      function HI(n) {
        return !n || n[0] == null || isNaN(n[0]) || n[1] == null || isNaN(n[1]);
      }
      function Zv(n) {
        nc.registerAxisPointerClass("CartesianAxisPointer", FRt), n.registerComponentModel(ORt), n.registerComponentView(qRt), n.registerPreprocessor(function(t) {
          if (t) {
            (!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {});
            var e = t.axisPointer.link;
            e && !X(e) && (t.axisPointer.link = [e]);
          }
        }), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, function(t, e) {
          t.getComponent("axisPointer").coordSysAxesInfo = hbt(t, e);
        }), n.registerAction({ type: "updateAxisPointer", event: "updateAxisPointer", update: ":updateAxisPointer" }, HRt);
      }
      function tLt(n) {
        Zt(pj), Zt(Zv);
      }
      var eLt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.makeElOption = function(e, i, r, a, o) {
          var s = r.axis;
          s.dim === "angle" && (this.animationThreshold = Math.PI / 18);
          var l = s.polar, u = l.getOtherAxis(s), h = u.getExtent(), c = s.dataToCoord(i), f = a.get("type");
          if (f && f !== "none") {
            var g = DD(a), d = iLt[f](s, l, c, h);
            d.style = g, e.graphicKey = d.type, e.pointer = d;
          }
          var A = a.get(["label", "margin"]), p = nLt(i, r, a, l, A);
          T7(e, r, a, o, p);
        }, t;
      }(TD);
      function nLt(n, t, e, i, r) {
        var a = t.axis, o = a.dataToCoord(n), s = i.getAngleAxis().getExtent()[0];
        s = s / 180 * Math.PI;
        var l = i.getRadiusAxis().getExtent(), u, h, c;
        if (a.dim === "radius") {
          var f = Fr();
          oh(f, f, s), bo(f, f, [i.cx, i.cy]), u = Xa([o, -r], f);
          var g = t.getModel("axisLabel").get("rotate") || 0, d = Ji.innerTextLayout(s, g * Math.PI / 180, -1);
          h = d.textAlign, c = d.textVerticalAlign;
        } else {
          var A = l[1];
          u = i.coordToPoint([A + r, o]);
          var p = i.cx, v = i.cy;
          h = Math.abs(u[0] - p) / A < 0.3 ? "center" : u[0] > p ? "left" : "right", c = Math.abs(u[1] - v) / A < 0.3 ? "middle" : u[1] > v ? "top" : "bottom";
        }
        return { position: u, align: h, verticalAlign: c };
      }
      var iLt = { line: function(n, t, e, i) {
        return n.dim === "angle" ? { type: "Line", shape: LD(t.coordToPoint([i[0], e]), t.coordToPoint([i[1], e])) } : { type: "Circle", shape: { cx: t.cx, cy: t.cy, r: e } };
      }, shadow: function(n, t, e, i) {
        var r = Math.max(1, n.getBandWidth()), a = Math.PI / 180;
        return n.dim === "angle" ? { type: "Sector", shape: L7(t.cx, t.cy, i[0], i[1], (-e - r / 2) * a, (-e + r / 2) * a) } : { type: "Sector", shape: L7(t.cx, t.cy, e - r / 2, e + r / 2, 0, Math.PI * 2) };
      } }, rLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.findAxisModel = function(e) {
          var i, r = this.ecModel;
          return r.eachComponent(e, function(a) {
            a.getCoordSysModel() === this && (i = a);
          }, this), i;
        }, t.type = "polar", t.dependencies = ["radiusAxis", "angleAxis"], t.defaultOption = { z: 0, center: ["50%", "50%"], radius: "80%" }, t;
      }(ne), ND = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.getCoordSysModel = function() {
          return this.getReferringComponents("polar", Ln).models[0];
        }, t.type = "polarAxis", t;
      }(ne);
      Mn(ND, mv);
      var aLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "angleAxis", t;
      }(ND), oLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "radiusAxis", t;
      }(ND), kD = function(n) {
        V(t, n);
        function t(e, i) {
          return n.call(this, "radius", e, i) || this;
        }
        return t.prototype.pointToData = function(e, i) {
          return this.polar.pointToData(e, i)[this.dim === "radius" ? 0 : 1];
        }, t;
      }($a);
      kD.prototype.dataToRadius = $a.prototype.dataToCoord, kD.prototype.radiusToData = $a.prototype.coordToData;
      var sLt = le(), FD = function(n) {
        V(t, n);
        function t(e, i) {
          return n.call(this, "angle", e, i || [0, 360]) || this;
        }
        return t.prototype.pointToData = function(e, i) {
          return this.polar.pointToData(e, i)[this.dim === "radius" ? 0 : 1];
        }, t.prototype.calculateCategoryInterval = function() {
          var e = this, i = e.getLabelModel(), r = e.scale, a = r.getExtent(), o = r.count();
          if (a[1] - a[0] < 1) return 0;
          var s = a[0], l = e.dataToCoord(s + 1) - e.dataToCoord(s), u = Math.abs(l), h = Cp(s == null ? "" : s + "", i.getFont(), "center", "top"), c = Math.max(h.height, 7), f = c / u;
          isNaN(f) && (f = 1 / 0);
          var g = Math.max(0, Math.floor(f)), d = sLt(e.model), A = d.lastAutoInterval, p = d.lastTickCount;
          return A != null && p != null && Math.abs(A - g) <= 1 && Math.abs(p - o) <= 1 && A > g ? g = A : (d.lastTickCount = o, d.lastAutoInterval = g), g;
        }, t;
      }($a);
      FD.prototype.dataToAngle = $a.prototype.dataToCoord, FD.prototype.angleToData = $a.prototype.coordToData;
      var U7 = ["radius", "angle"], lLt = function() {
        function n(t) {
          this.dimensions = U7, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new kD(), this._angleAxis = new FD(), this.axisPointerEnabled = true, this.name = t || "", this._radiusAxis.polar = this._angleAxis.polar = this;
        }
        return n.prototype.containPoint = function(t) {
          var e = this.pointToCoord(t);
          return this._radiusAxis.contain(e[0]) && this._angleAxis.contain(e[1]);
        }, n.prototype.containData = function(t) {
          return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1]);
        }, n.prototype.getAxis = function(t) {
          var e = "_" + t + "Axis";
          return this[e];
        }, n.prototype.getAxes = function() {
          return [this._radiusAxis, this._angleAxis];
        }, n.prototype.getAxesByScale = function(t) {
          var e = [], i = this._angleAxis, r = this._radiusAxis;
          return i.scale.type === t && e.push(i), r.scale.type === t && e.push(r), e;
        }, n.prototype.getAngleAxis = function() {
          return this._angleAxis;
        }, n.prototype.getRadiusAxis = function() {
          return this._radiusAxis;
        }, n.prototype.getOtherAxis = function(t) {
          var e = this._angleAxis;
          return t === e ? this._radiusAxis : e;
        }, n.prototype.getBaseAxis = function() {
          return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
        }, n.prototype.getTooltipAxes = function(t) {
          var e = t != null && t !== "auto" ? this.getAxis(t) : this.getBaseAxis();
          return { baseAxes: [e], otherAxes: [this.getOtherAxis(e)] };
        }, n.prototype.dataToPoint = function(t, e) {
          return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], e), this._angleAxis.dataToAngle(t[1], e)]);
        }, n.prototype.pointToData = function(t, e) {
          var i = this.pointToCoord(t);
          return [this._radiusAxis.radiusToData(i[0], e), this._angleAxis.angleToData(i[1], e)];
        }, n.prototype.pointToCoord = function(t) {
          var e = t[0] - this.cx, i = t[1] - this.cy, r = this.getAngleAxis(), a = r.getExtent(), o = Math.min(a[0], a[1]), s = Math.max(a[0], a[1]);
          r.inverse ? o = s - 360 : s = o + 360;
          var l = Math.sqrt(e * e + i * i);
          e /= l, i /= l;
          for (var u = Math.atan2(-i, e) / Math.PI * 180, h = u < o ? 1 : -1; u < o || u > s; ) u += h * 360;
          return [l, u];
        }, n.prototype.coordToPoint = function(t) {
          var e = t[0], i = t[1] / 180 * Math.PI, r = Math.cos(i) * e + this.cx, a = -Math.sin(i) * e + this.cy;
          return [r, a];
        }, n.prototype.getArea = function() {
          var t = this.getAngleAxis(), e = this.getRadiusAxis(), i = e.getExtent().slice();
          i[0] > i[1] && i.reverse();
          var r = t.getExtent(), a = Math.PI / 180;
          return { cx: this.cx, cy: this.cy, r0: i[0], r: i[1], startAngle: -r[0] * a, endAngle: -r[1] * a, clockwise: t.inverse, contain: function(o, s) {
            var l = o - this.cx, u = s - this.cy, h = l * l + u * u - 1e-4, c = this.r, f = this.r0;
            return h <= c * c && h >= f * f;
          } };
        }, n.prototype.convertToPixel = function(t, e, i) {
          var r = V7(e);
          return r === this ? this.dataToPoint(i) : null;
        }, n.prototype.convertFromPixel = function(t, e, i) {
          var r = V7(e);
          return r === this ? this.pointToData(i) : null;
        }, n;
      }();
      function V7(n) {
        var t = n.seriesModel, e = n.polarModel;
        return e && e.coordinateSystem || t && t.coordinateSystem;
      }
      function uLt(n, t, e) {
        var i = t.get("center"), r = e.getWidth(), a = e.getHeight();
        n.cx = ot(i[0], r), n.cy = ot(i[1], a);
        var o = n.getRadiusAxis(), s = Math.min(r, a) / 2, l = t.get("radius");
        l == null ? l = [0, "100%"] : X(l) || (l = [0, l]);
        var u = [ot(l[0], s), ot(l[1], s)];
        o.inverse ? o.setExtent(u[1], u[0]) : o.setExtent(u[0], u[1]);
      }
      function hLt(n, t) {
        var e = this, i = e.getAngleAxis(), r = e.getRadiusAxis();
        if (i.scale.setExtent(1 / 0, -1 / 0), r.scale.setExtent(1 / 0, -1 / 0), n.eachSeries(function(s) {
          if (s.coordinateSystem === e) {
            var l = s.getData();
            M(oI(l, "radius"), function(u) {
              r.scale.unionExtentFromData(l, u);
            }), M(oI(l, "angle"), function(u) {
              i.scale.unionExtentFromData(l, u);
            });
          }
        }), Xg(i.scale, i.model), Xg(r.scale, r.model), i.type === "category" && !i.onBand) {
          var a = i.getExtent(), o = 360 / i.scale.count();
          i.inverse ? a[1] += o : a[1] -= o, i.setExtent(a[0], a[1]);
        }
      }
      function cLt(n) {
        return n.mainType === "angleAxis";
      }
      function j7(n, t) {
        var e;
        if (n.type = t.get("type"), n.scale = aI(t), n.onBand = t.get("boundaryGap") && n.type === "category", n.inverse = t.get("inverse"), cLt(t)) {
          n.inverse = n.inverse !== t.get("clockwise");
          var i = t.get("startAngle"), r = (e = t.get("endAngle")) !== null && e !== void 0 ? e : i + (n.inverse ? -360 : 360);
          n.setExtent(i, r);
        }
        t.axis = n, n.model = t;
      }
      var fLt = { dimensions: U7, create: function(n, t) {
        var e = [];
        return n.eachComponent("polar", function(i, r) {
          var a = new lLt(r + "");
          a.update = hLt;
          var o = a.getRadiusAxis(), s = a.getAngleAxis(), l = i.findAxisModel("radiusAxis"), u = i.findAxisModel("angleAxis");
          j7(o, l), j7(s, u), uLt(a, i, t), e.push(a), i.coordinateSystem = a, a.model = i;
        }), n.eachSeries(function(i) {
          if (i.get("coordinateSystem") === "polar") {
            var r = i.getReferringComponents("polar", Ln).models[0];
            if (!r) throw new Error('Polar "' + Dn(i.get("polarIndex"), i.get("polarId"), 0) + '" not found');
            i.coordinateSystem = r.coordinateSystem;
          }
        }), e;
      } }, gLt = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
      function YI(n, t, e) {
        t[1] > t[0] && (t = t.slice().reverse());
        var i = n.coordToPoint([t[0], e]), r = n.coordToPoint([t[1], e]);
        return { x1: i[0], y1: i[1], x2: r[0], y2: r[1] };
      }
      function WI(n) {
        var t = n.getRadiusAxis();
        return t.inverse ? 0 : 1;
      }
      function q7(n) {
        var t = n[0], e = n[n.length - 1];
        t && e && Math.abs(Math.abs(t.coord - e.coord) - 360) < 1e-4 && n.pop();
      }
      var dLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.axisPointerClass = "PolarAxisPointer", e;
        }
        return t.prototype.render = function(e, i) {
          if (this.group.removeAll(), !!e.get("show")) {
            var r = e.axis, a = r.polar, o = a.getRadiusAxis().getExtent(), s = r.getTicksCoords(), l = r.getMinorTicksCoords(), u = Z(r.getViewLabels(), function(h) {
              h = xt(h);
              var c = r.scale, f = c.type === "ordinal" ? c.getRawOrdinalNumber(h.tickValue) : h.tickValue;
              return h.coord = r.dataToCoord(f), h;
            });
            q7(u), q7(s), M(gLt, function(h) {
              e.get([h, "show"]) && (!r.scale.isBlank() || h === "axisLine") && ALt[h](this.group, e, a, s, l, o, u);
            }, this);
          }
        }, t.type = "angleAxis", t;
      }(nc), ALt = { axisLine: function(n, t, e, i, r, a) {
        var o = t.getModel(["axisLine", "lineStyle"]), s = e.getAngleAxis(), l = Math.PI / 180, u = s.getExtent(), h = WI(e), c = h ? 0 : 1, f, g = Math.abs(u[1] - u[0]) === 360 ? "Circle" : "Arc";
        a[c] === 0 ? f = new Ph[g]({ shape: { cx: e.cx, cy: e.cy, r: a[h], startAngle: -u[0] * l, endAngle: -u[1] * l, clockwise: s.inverse }, style: o.getLineStyle(), z2: 1, silent: true }) : f = new Gp({ shape: { cx: e.cx, cy: e.cy, r: a[h], r0: a[c] }, style: o.getLineStyle(), z2: 1, silent: true }), f.style.fill = null, n.add(f);
      }, axisTick: function(n, t, e, i, r, a) {
        var o = t.getModel("axisTick"), s = (o.get("inside") ? -1 : 1) * o.get("length"), l = a[WI(e)], u = Z(i, function(h) {
          return new Wn({ shape: YI(e, [l, l + s], h.coord) });
        });
        n.add(fa(u, { style: Et(o.getModel("lineStyle").getLineStyle(), { stroke: t.get(["axisLine", "lineStyle", "color"]) }) }));
      }, minorTick: function(n, t, e, i, r, a) {
        if (r.length) {
          for (var o = t.getModel("axisTick"), s = t.getModel("minorTick"), l = (o.get("inside") ? -1 : 1) * s.get("length"), u = a[WI(e)], h = [], c = 0; c < r.length; c++) for (var f = 0; f < r[c].length; f++) h.push(new Wn({ shape: YI(e, [u, u + l], r[c][f].coord) }));
          n.add(fa(h, { style: Et(s.getModel("lineStyle").getLineStyle(), Et(o.getLineStyle(), { stroke: t.get(["axisLine", "lineStyle", "color"]) })) }));
        }
      }, axisLabel: function(n, t, e, i, r, a, o) {
        var s = t.getCategories(true), l = t.getModel("axisLabel"), u = l.get("margin"), h = t.get("triggerEvent");
        M(o, function(c, f) {
          var g = l, d = c.tickValue, A = a[WI(e)], p = e.coordToPoint([A + u, c.coord]), v = e.cx, y = e.cy, m = Math.abs(p[0] - v) / A < 0.3 ? "center" : p[0] > v ? "left" : "right", _ = Math.abs(p[1] - y) / A < 0.3 ? "middle" : p[1] > y ? "top" : "bottom";
          if (s && s[d]) {
            var E = s[d];
            _t(E) && E.textStyle && (g = new Te(E.textStyle, l, l.ecModel));
          }
          var I = new ge({ silent: Ji.isLabelSilent(t), style: Ke(g, { x: p[0], y: p[1], fill: g.getTextColor() || t.get(["axisLine", "lineStyle", "color"]), text: c.formattedLabel, align: m, verticalAlign: _ }) });
          if (n.add(I), h) {
            var x = Ji.makeAxisEventDataBase(t);
            x.targetType = "axisLabel", x.value = c.rawLabel, Dt(I).eventData = x;
          }
        }, this);
      }, splitLine: function(n, t, e, i, r, a) {
        var o = t.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0;
        l = l instanceof Array ? l : [l];
        for (var h = [], c = 0; c < i.length; c++) {
          var f = u++ % l.length;
          h[f] = h[f] || [], h[f].push(new Wn({ shape: YI(e, a, i[c].coord) }));
        }
        for (var c = 0; c < h.length; c++) n.add(fa(h[c], { style: Et({ stroke: l[c % l.length] }, s.getLineStyle()), silent: true, z: t.get("z") }));
      }, minorSplitLine: function(n, t, e, i, r, a) {
        if (r.length) {
          for (var o = t.getModel("minorSplitLine"), s = o.getModel("lineStyle"), l = [], u = 0; u < r.length; u++) for (var h = 0; h < r[u].length; h++) l.push(new Wn({ shape: YI(e, a, r[u][h].coord) }));
          n.add(fa(l, { style: s.getLineStyle(), silent: true, z: t.get("z") }));
        }
      }, splitArea: function(n, t, e, i, r, a) {
        if (i.length) {
          var o = t.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
          l = l instanceof Array ? l : [l];
          for (var h = [], c = Math.PI / 180, f = -i[0].coord * c, g = Math.min(a[0], a[1]), d = Math.max(a[0], a[1]), A = t.get("clockwise"), p = 1, v = i.length; p <= v; p++) {
            var y = p === v ? i[0].coord : i[p].coord, m = u++ % l.length;
            h[m] = h[m] || [], h[m].push(new Hi({ shape: { cx: e.cx, cy: e.cy, r0: g, r: d, startAngle: f, endAngle: -y * c, clockwise: A }, silent: true })), f = -y * c;
          }
          for (var p = 0; p < h.length; p++) n.add(fa(h[p], { style: Et({ fill: l[p % l.length] }, s.getAreaStyle()), silent: true }));
        }
      } }, pLt = ["axisLine", "axisTickLabel", "axisName"], vLt = ["splitLine", "splitArea", "minorSplitLine"], yLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.axisPointerClass = "PolarAxisPointer", e;
        }
        return t.prototype.render = function(e, i) {
          if (this.group.removeAll(), !!e.get("show")) {
            var r = this._axisGroup, a = this._axisGroup = new Ct();
            this.group.add(a);
            var o = e.axis, s = o.polar, l = s.getAngleAxis(), u = o.getTicksCoords(), h = o.getMinorTicksCoords(), c = l.getExtent()[0], f = o.getExtent(), g = _Lt(s, e, c), d = new Ji(e, g);
            M(pLt, d.add, d), a.add(d.getGroup()), qp(r, a, e), M(vLt, function(A) {
              e.get([A, "show"]) && !o.scale.isBlank() && mLt[A](this.group, e, s, c, f, u, h);
            }, this);
          }
        }, t.type = "radiusAxis", t;
      }(nc), mLt = { splitLine: function(n, t, e, i, r, a) {
        var o = t.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0, h = e.getAngleAxis(), c = Math.PI / 180, f = h.getExtent(), g = Math.abs(f[1] - f[0]) === 360 ? "Circle" : "Arc";
        l = l instanceof Array ? l : [l];
        for (var d = [], A = 0; A < a.length; A++) {
          var p = u++ % l.length;
          d[p] = d[p] || [], d[p].push(new Ph[g]({ shape: { cx: e.cx, cy: e.cy, r: Math.max(a[A].coord, 0), startAngle: -f[0] * c, endAngle: -f[1] * c, clockwise: h.inverse } }));
        }
        for (var A = 0; A < d.length; A++) n.add(fa(d[A], { style: Et({ stroke: l[A % l.length], fill: null }, s.getLineStyle()), silent: true }));
      }, minorSplitLine: function(n, t, e, i, r, a, o) {
        if (o.length) {
          for (var s = t.getModel("minorSplitLine"), l = s.getModel("lineStyle"), u = [], h = 0; h < o.length; h++) for (var c = 0; c < o[h].length; c++) u.push(new ks({ shape: { cx: e.cx, cy: e.cy, r: o[h][c].coord } }));
          n.add(fa(u, { style: Et({ fill: null }, l.getLineStyle()), silent: true }));
        }
      }, splitArea: function(n, t, e, i, r, a) {
        if (a.length) {
          var o = t.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
          l = l instanceof Array ? l : [l];
          for (var h = [], c = a[0].coord, f = 1; f < a.length; f++) {
            var g = u++ % l.length;
            h[g] = h[g] || [], h[g].push(new Hi({ shape: { cx: e.cx, cy: e.cy, r0: c, r: a[f].coord, startAngle: 0, endAngle: Math.PI * 2 }, silent: true })), c = a[f].coord;
          }
          for (var f = 0; f < h.length; f++) n.add(fa(h[f], { style: Et({ fill: l[f % l.length] }, s.getAreaStyle()), silent: true }));
        }
      } };
      function _Lt(n, t, e) {
        return { position: [n.cx, n.cy], rotation: e / 180 * Math.PI, labelDirection: -1, tickDirection: -1, nameDirection: 1, labelRotate: t.getModel("axisLabel").get("rotate"), z2: 1 };
      }
      function H7(n) {
        return n.get("stack") || "__ec_stack_" + n.seriesIndex;
      }
      function Y7(n, t) {
        return t.dim + n.model.componentIndex;
      }
      function ILt(n, t, e) {
        var i = {}, r = ELt(Ne(t.getSeriesByType(n), function(a) {
          return !t.isSeriesFiltered(a) && a.coordinateSystem && a.coordinateSystem.type === "polar";
        }));
        t.eachSeriesByType(n, function(a) {
          if (a.coordinateSystem.type === "polar") {
            var o = a.getData(), s = a.coordinateSystem, l = s.getBaseAxis(), u = Y7(s, l), h = H7(a), c = r[u][h], f = c.offset, g = c.width, d = s.getOtherAxis(l), A = a.coordinateSystem.cx, p = a.coordinateSystem.cy, v = a.get("barMinHeight") || 0, y = a.get("barMinAngle") || 0;
            i[h] = i[h] || [];
            for (var m = o.mapDimension(d.dim), _ = o.mapDimension(l.dim), E = lu(o, m), I = l.dim !== "radius" || !a.get("roundCap", true), x = d.model, w = x.get("startValue"), C = d.dataToCoord(w || 0), S = 0, b = o.count(); S < b; S++) {
              var B = o.get(m, S), T = o.get(_, S), D = B >= 0 ? "p" : "n", R = C;
              E && (i[h][T] || (i[h][T] = { p: C, n: C }), R = i[h][T][D]);
              var L = void 0, k = void 0, P = void 0, F = void 0;
              if (d.dim === "radius") {
                var Q = d.dataToCoord(B) - C, z = l.dataToCoord(T);
                Math.abs(Q) < v && (Q = (Q < 0 ? -1 : 1) * v), L = R, k = R + Q, P = z - f, F = P - g, E && (i[h][T][D] = k);
              } else {
                var j = d.dataToCoord(B, I) - C, $ = l.dataToCoord(T);
                Math.abs(j) < y && (j = (j < 0 ? -1 : 1) * y), L = $ + f, k = L + g, P = R, F = R + j, E && (i[h][T][D] = F);
              }
              o.setItemLayout(S, { cx: A, cy: p, r0: L, r: k, startAngle: -P * Math.PI / 180, endAngle: -F * Math.PI / 180, clockwise: P >= F });
            }
          }
        });
      }
      function ELt(n) {
        var t = {};
        M(n, function(i, r) {
          var a = i.getData(), o = i.coordinateSystem, s = o.getBaseAxis(), l = Y7(o, s), u = s.getExtent(), h = s.type === "category" ? s.getBandWidth() : Math.abs(u[1] - u[0]) / a.count(), c = t[l] || { bandWidth: h, remainedWidth: h, autoWidthCount: 0, categoryGap: "20%", gap: "30%", stacks: {} }, f = c.stacks;
          t[l] = c;
          var g = H7(i);
          f[g] || c.autoWidthCount++, f[g] = f[g] || { width: 0, maxWidth: 0 };
          var d = ot(i.get("barWidth"), h), A = ot(i.get("barMaxWidth"), h), p = i.get("barGap"), v = i.get("barCategoryGap");
          d && !f[g].width && (d = Math.min(c.remainedWidth, d), f[g].width = d, c.remainedWidth -= d), A && (f[g].maxWidth = A), p != null && (c.gap = p), v != null && (c.categoryGap = v);
        });
        var e = {};
        return M(t, function(i, r) {
          e[r] = {};
          var a = i.stacks, o = i.bandWidth, s = ot(i.categoryGap, o), l = ot(i.gap, 1), u = i.remainedWidth, h = i.autoWidthCount, c = (u - s) / (h + (h - 1) * l);
          c = Math.max(c, 0), M(a, function(A, p) {
            var v = A.maxWidth;
            v && v < c && (v = Math.min(v, u), A.width && (v = Math.min(v, A.width)), u -= v, A.width = v, h--);
          }), c = (u - s) / (h + (h - 1) * l), c = Math.max(c, 0);
          var f = 0, g;
          M(a, function(A, p) {
            A.width || (A.width = c), g = A, f += A.width * (1 + l);
          }), g && (f -= g.width * l);
          var d = -f / 2;
          M(a, function(A, p) {
            e[r][p] = e[r][p] || { offset: d, width: A.width }, d += A.width * (1 + l);
          });
        }), e;
      }
      var xLt = { startAngle: 90, clockwise: true, splitNumber: 12, axisLabel: { rotate: 0 } }, wLt = { splitNumber: 5 }, CLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "polar", t;
      }(on);
      function SLt(n) {
        Zt(Zv), nc.registerAxisPointerClass("PolarAxisPointer", eLt), n.registerCoordinateSystem("polar", fLt), n.registerComponentModel(rLt), n.registerComponentView(CLt), td(n, "angle", aLt, xLt), td(n, "radius", oLt, wLt), n.registerComponentView(dLt), n.registerComponentView(yLt), n.registerLayout(Ot(ILt, "bar"));
      }
      function QD(n, t) {
        t = t || {};
        var e = n.coordinateSystem, i = n.axis, r = {}, a = i.position, o = i.orient, s = e.getRect(), l = [s.x, s.x + s.width, s.y, s.y + s.height], u = { horizontal: { top: l[2], bottom: l[3] }, vertical: { left: l[0], right: l[1] } };
        r.position = [o === "vertical" ? u.vertical[a] : l[0], o === "horizontal" ? u.horizontal[a] : l[3]];
        var h = { horizontal: 0, vertical: 1 };
        r.rotation = Math.PI / 2 * h[o];
        var c = { top: -1, bottom: 1, right: 1, left: -1 };
        r.labelDirection = r.tickDirection = r.nameDirection = c[a], n.get(["axisTick", "inside"]) && (r.tickDirection = -r.tickDirection), Dn(t.labelInside, n.get(["axisLabel", "inside"])) && (r.labelDirection = -r.labelDirection);
        var f = t.rotate;
        return f == null && (f = n.get(["axisLabel", "rotate"])), r.labelRotation = a === "top" ? -f : f, r.z2 = 1, r;
      }
      var bLt = ["axisLine", "axisTickLabel", "axisName"], BLt = ["splitArea", "splitLine"], TLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.axisPointerClass = "SingleAxisPointer", e;
        }
        return t.prototype.render = function(e, i, r, a) {
          var o = this.group;
          o.removeAll();
          var s = this._axisGroup;
          this._axisGroup = new Ct();
          var l = QD(e), u = new Ji(e, l);
          M(bLt, u.add, u), o.add(this._axisGroup), o.add(u.getGroup()), M(BLt, function(h) {
            e.get([h, "show"]) && MLt[h](this, this.group, this._axisGroup, e);
          }, this), qp(s, this._axisGroup, e), n.prototype.render.call(this, e, i, r, a);
        }, t.prototype.remove = function() {
          fj(this);
        }, t.type = "singleAxis", t;
      }(nc), MLt = { splitLine: function(n, t, e, i) {
        var r = i.axis;
        if (!r.scale.isBlank()) {
          var a = i.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color");
          s = s instanceof Array ? s : [s];
          for (var l = o.get("width"), u = i.coordinateSystem.getRect(), h = r.isHorizontal(), c = [], f = 0, g = r.getTicksCoords({ tickModel: a }), d = [], A = [], p = 0; p < g.length; ++p) {
            var v = r.toGlobalCoord(g[p].coord);
            h ? (d[0] = v, d[1] = u.y, A[0] = v, A[1] = u.y + u.height) : (d[0] = u.x, d[1] = v, A[0] = u.x + u.width, A[1] = v);
            var y = new Wn({ shape: { x1: d[0], y1: d[1], x2: A[0], y2: A[1] }, silent: true });
            Sg(y.shape, l);
            var m = f++ % s.length;
            c[m] = c[m] || [], c[m].push(y);
          }
          for (var _ = o.getLineStyle(["color"]), p = 0; p < c.length; ++p) t.add(fa(c[p], { style: Et({ stroke: s[p % s.length] }, _), silent: true }));
        }
      }, splitArea: function(n, t, e, i) {
        cj(n, e, i, i);
      } }, XI = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.getCoordSysModel = function() {
          return this;
        }, t.type = "singleAxis", t.layoutMode = "box", t.defaultOption = { left: "5%", top: "5%", right: "5%", bottom: "5%", type: "value", position: "bottom", orient: "horizontal", axisLine: { show: true, lineStyle: { width: 1, type: "solid" } }, tooltip: { show: true }, axisTick: { show: true, length: 6, lineStyle: { width: 1 } }, axisLabel: { show: true, interval: "auto" }, splitLine: { show: true, lineStyle: { type: "dashed", opacity: 0.2 } } }, t;
      }(ne);
      Mn(XI, mv.prototype);
      var DLt = function(n) {
        V(t, n);
        function t(e, i, r, a, o) {
          var s = n.call(this, e, i, r) || this;
          return s.type = a || "value", s.position = o || "bottom", s;
        }
        return t.prototype.isHorizontal = function() {
          var e = this.position;
          return e === "top" || e === "bottom";
        }, t.prototype.pointToData = function(e, i) {
          return this.coordinateSystem.pointToData(e)[0];
        }, t;
      }($a), W7 = ["single"], RLt = function() {
        function n(t, e, i) {
          this.type = "single", this.dimension = "single", this.dimensions = W7, this.axisPointerEnabled = true, this.model = t, this._init(t, e, i);
        }
        return n.prototype._init = function(t, e, i) {
          var r = this.dimension, a = new DLt(r, aI(t), [0, 0], t.get("type"), t.get("position")), o = a.type === "category";
          a.onBand = o && t.get("boundaryGap"), a.inverse = t.get("inverse"), a.orient = t.get("orient"), t.axis = a, a.model = t, a.coordinateSystem = this, this._axis = a;
        }, n.prototype.update = function(t, e) {
          t.eachSeries(function(i) {
            if (i.coordinateSystem === this) {
              var r = i.getData();
              M(r.mapDimensionsAll(this.dimension), function(a) {
                this._axis.scale.unionExtentFromData(r, a);
              }, this), Xg(this._axis.scale, this._axis.model);
            }
          }, this);
        }, n.prototype.resize = function(t, e) {
          this._rect = Gn({ left: t.get("left"), top: t.get("top"), right: t.get("right"), bottom: t.get("bottom"), width: t.get("width"), height: t.get("height") }, { width: e.getWidth(), height: e.getHeight() }), this._adjustAxis();
        }, n.prototype.getRect = function() {
          return this._rect;
        }, n.prototype._adjustAxis = function() {
          var t = this._rect, e = this._axis, i = e.isHorizontal(), r = i ? [0, t.width] : [0, t.height], a = e.inverse ? 1 : 0;
          e.setExtent(r[a], r[1 - a]), this._updateAxisTransform(e, i ? t.x : t.y);
        }, n.prototype._updateAxisTransform = function(t, e) {
          var i = t.getExtent(), r = i[0] + i[1], a = t.isHorizontal();
          t.toGlobalCoord = a ? function(o) {
            return o + e;
          } : function(o) {
            return r - o + e;
          }, t.toLocalCoord = a ? function(o) {
            return o - e;
          } : function(o) {
            return r - o + e;
          };
        }, n.prototype.getAxis = function() {
          return this._axis;
        }, n.prototype.getBaseAxis = function() {
          return this._axis;
        }, n.prototype.getAxes = function() {
          return [this._axis];
        }, n.prototype.getTooltipAxes = function() {
          return { baseAxes: [this.getAxis()], otherAxes: [] };
        }, n.prototype.containPoint = function(t) {
          var e = this.getRect(), i = this.getAxis(), r = i.orient;
          return r === "horizontal" ? i.contain(i.toLocalCoord(t[0])) && t[1] >= e.y && t[1] <= e.y + e.height : i.contain(i.toLocalCoord(t[1])) && t[0] >= e.y && t[0] <= e.y + e.height;
        }, n.prototype.pointToData = function(t) {
          var e = this.getAxis();
          return [e.coordToData(e.toLocalCoord(t[e.orient === "horizontal" ? 0 : 1]))];
        }, n.prototype.dataToPoint = function(t) {
          var e = this.getAxis(), i = this.getRect(), r = [], a = e.orient === "horizontal" ? 0 : 1;
          return t instanceof Array && (t = t[0]), r[a] = e.toGlobalCoord(e.dataToCoord(+t)), r[1 - a] = a === 0 ? i.y + i.height / 2 : i.x + i.width / 2, r;
        }, n.prototype.convertToPixel = function(t, e, i) {
          var r = X7(e);
          return r === this ? this.dataToPoint(i) : null;
        }, n.prototype.convertFromPixel = function(t, e, i) {
          var r = X7(e);
          return r === this ? this.pointToData(i) : null;
        }, n;
      }();
      function X7(n) {
        var t = n.seriesModel, e = n.singleAxisModel;
        return e && e.coordinateSystem || t && t.coordinateSystem;
      }
      function LLt(n, t) {
        var e = [];
        return n.eachComponent("singleAxis", function(i, r) {
          var a = new RLt(i, n, t);
          a.name = "single_" + r, a.resize(i, t), i.coordinateSystem = a, e.push(a);
        }), n.eachSeries(function(i) {
          if (i.get("coordinateSystem") === "singleAxis") {
            var r = i.getReferringComponents("singleAxis", Ln).models[0];
            i.coordinateSystem = r && r.coordinateSystem;
          }
        }), e;
      }
      var PLt = { create: LLt, dimensions: W7 }, Z7 = ["x", "y"], NLt = ["width", "height"], kLt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.makeElOption = function(e, i, r, a, o) {
          var s = r.axis, l = s.coordinateSystem, u = OD(l, 1 - ZI(s)), h = l.dataToPoint(i)[0], c = a.get("type");
          if (c && c !== "none") {
            var f = DD(a), g = FLt[c](s, h, u);
            g.style = f, e.graphicKey = g.type, e.pointer = g;
          }
          var d = QD(r);
          D7(i, e, d, r, a, o);
        }, t.prototype.getHandleTransform = function(e, i, r) {
          var a = QD(i, { labelInside: false });
          a.labelMargin = r.get(["handle", "margin"]);
          var o = RD(i.axis, e, a);
          return { x: o[0], y: o[1], rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0) };
        }, t.prototype.updateHandleTransform = function(e, i, r, a) {
          var o = r.axis, s = o.coordinateSystem, l = ZI(o), u = OD(s, l), h = [e.x, e.y];
          h[l] += i[l], h[l] = Math.min(u[1], h[l]), h[l] = Math.max(u[0], h[l]);
          var c = OD(s, 1 - l), f = (c[1] + c[0]) / 2, g = [f, f];
          return g[l] = h[l], { x: h[0], y: h[1], rotation: e.rotation, cursorPoint: g, tooltipOption: { verticalAlign: "middle" } };
        }, t;
      }(TD), FLt = { line: function(n, t, e) {
        var i = LD([t, e[0]], [t, e[1]], ZI(n));
        return { type: "Line", subPixelOptimize: true, shape: i };
      }, shadow: function(n, t, e) {
        var i = n.getBandWidth(), r = e[1] - e[0];
        return { type: "Rect", shape: R7([t - i / 2, e[0]], [i, r], ZI(n)) };
      } };
      function ZI(n) {
        return n.isHorizontal() ? 0 : 1;
      }
      function OD(n, t) {
        var e = n.getRect();
        return [e[Z7[t]], e[Z7[t]] + e[NLt[t]]];
      }
      var QLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "single", t;
      }(on);
      function OLt(n) {
        Zt(Zv), nc.registerAxisPointerClass("SingleAxisPointer", kLt), n.registerComponentView(QLt), n.registerComponentView(TLt), n.registerComponentModel(XI), td(n, "single", XI, XI.defaultOption), n.registerCoordinateSystem("single", PLt);
      }
      var zLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e, i, r) {
          var a = Pg(e);
          n.prototype.init.apply(this, arguments), K7(e, a);
        }, t.prototype.mergeOption = function(e) {
          n.prototype.mergeOption.apply(this, arguments), K7(this.option, e);
        }, t.prototype.getCellSize = function() {
          return this.option.cellSize;
        }, t.type = "calendar", t.defaultOption = { z: 2, left: 80, top: 60, cellSize: 20, orient: "horizontal", splitLine: { show: true, lineStyle: { color: "#000", width: 1, type: "solid" } }, itemStyle: { color: "#fff", borderWidth: 1, borderColor: "#ccc" }, dayLabel: { show: true, firstDay: 0, position: "start", margin: "50%", color: "#000" }, monthLabel: { show: true, position: "start", margin: 5, align: "center", formatter: null, color: "#000" }, yearLabel: { show: true, position: null, margin: 30, formatter: null, color: "#ccc", fontFamily: "sans-serif", fontWeight: "bolder", fontSize: 20 } }, t;
      }(ne);
      function K7(n, t) {
        var e = n.cellSize, i;
        X(e) ? i = e : i = n.cellSize = [e, e], i.length === 1 && (i[1] = i[0]);
        var r = Z([0, 1], function(a) {
          return oIt(t, a) && (i[a] = "auto"), i[a] != null && i[a] !== "auto";
        });
        iu(n, t, { type: "box", ignoreSize: r });
      }
      var GLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = this.group;
          a.removeAll();
          var o = e.coordinateSystem, s = o.getRangeInfo(), l = o.getOrient(), u = i.getLocaleModel();
          this._renderDayRect(e, s, a), this._renderLines(e, s, l, a), this._renderYearText(e, s, l, a), this._renderMonthText(e, u, l, a), this._renderWeekText(e, u, s, l, a);
        }, t.prototype._renderDayRect = function(e, i, r) {
          for (var a = e.coordinateSystem, o = e.getModel("itemStyle").getItemStyle(), s = a.getCellWidth(), l = a.getCellHeight(), u = i.start.time; u <= i.end.time; u = a.getNextNDay(u, 1).time) {
            var h = a.dataToRect([u], false).tl, c = new ue({ shape: { x: h[0], y: h[1], width: s, height: l }, cursor: "default", style: o });
            r.add(c);
          }
        }, t.prototype._renderLines = function(e, i, r, a) {
          var o = this, s = e.coordinateSystem, l = e.getModel(["splitLine", "lineStyle"]).getLineStyle(), u = e.get(["splitLine", "show"]), h = l.lineWidth;
          this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
          for (var c = i.start, f = 0; c.time <= i.end.time; f++) {
            d(c.formatedDate), f === 0 && (c = s.getDateInfo(i.start.y + "-" + i.start.m));
            var g = c.date;
            g.setMonth(g.getMonth() + 1), c = s.getDateInfo(g);
          }
          d(s.getNextNDay(i.end.time, 1).formatedDate);
          function d(A) {
            o._firstDayOfMonth.push(s.getDateInfo(A)), o._firstDayPoints.push(s.dataToRect([A], false).tl);
            var p = o._getLinePointsOfOneWeek(e, A, r);
            o._tlpoints.push(p[0]), o._blpoints.push(p[p.length - 1]), u && o._drawSplitline(p, l, a);
          }
          u && this._drawSplitline(o._getEdgesPoints(o._tlpoints, h, r), l, a), u && this._drawSplitline(o._getEdgesPoints(o._blpoints, h, r), l, a);
        }, t.prototype._getEdgesPoints = function(e, i, r) {
          var a = [e[0].slice(), e[e.length - 1].slice()], o = r === "horizontal" ? 0 : 1;
          return a[0][o] = a[0][o] - i / 2, a[1][o] = a[1][o] + i / 2, a;
        }, t.prototype._drawSplitline = function(e, i, r) {
          var a = new Wi({ z2: 20, shape: { points: e }, style: i });
          r.add(a);
        }, t.prototype._getLinePointsOfOneWeek = function(e, i, r) {
          for (var a = e.coordinateSystem, o = a.getDateInfo(i), s = [], l = 0; l < 7; l++) {
            var u = a.getNextNDay(o.time, l), h = a.dataToRect([u.time], false);
            s[2 * u.day] = h.tl, s[2 * u.day + 1] = h[r === "horizontal" ? "bl" : "tr"];
          }
          return s;
        }, t.prototype._formatterLabel = function(e, i) {
          return ht(e) && e ? iIt(e, i) : yt(e) ? e(i) : i.nameMap;
        }, t.prototype._yearTextPositionControl = function(e, i, r, a, o) {
          var s = i[0], l = i[1], u = ["center", "bottom"];
          a === "bottom" ? (l += o, u = ["center", "top"]) : a === "left" ? s -= o : a === "right" ? (s += o, u = ["center", "top"]) : l -= o;
          var h = 0;
          return (a === "left" || a === "right") && (h = Math.PI / 2), { rotation: h, x: s, y: l, style: { align: u[0], verticalAlign: u[1] } };
        }, t.prototype._renderYearText = function(e, i, r, a) {
          var o = e.getModel("yearLabel");
          if (o.get("show")) {
            var s = o.get("margin"), l = o.get("position");
            l || (l = r !== "horizontal" ? "top" : "left");
            var u = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]], h = (u[0][0] + u[1][0]) / 2, c = (u[0][1] + u[1][1]) / 2, f = r === "horizontal" ? 0 : 1, g = { top: [h, u[f][1]], bottom: [h, u[1 - f][1]], left: [u[1 - f][0], c], right: [u[f][0], c] }, d = i.start.y;
            +i.end.y > +i.start.y && (d = d + "-" + i.end.y);
            var A = o.get("formatter"), p = { start: i.start.y, end: i.end.y, nameMap: d }, v = this._formatterLabel(A, p), y = new ge({ z2: 30, style: Ke(o, { text: v }) });
            y.attr(this._yearTextPositionControl(y, g[l], r, l, s)), a.add(y);
          }
        }, t.prototype._monthTextPositionControl = function(e, i, r, a, o) {
          var s = "left", l = "top", u = e[0], h = e[1];
          return r === "horizontal" ? (h = h + o, i && (s = "center"), a === "start" && (l = "bottom")) : (u = u + o, i && (l = "middle"), a === "start" && (s = "right")), { x: u, y: h, align: s, verticalAlign: l };
        }, t.prototype._renderMonthText = function(e, i, r, a) {
          var o = e.getModel("monthLabel");
          if (o.get("show")) {
            var s = o.get("nameMap"), l = o.get("margin"), u = o.get("position"), h = o.get("align"), c = [this._tlpoints, this._blpoints];
            (!s || ht(s)) && (s && (i = sB(s) || i), s = i.get(["time", "monthAbbr"]) || []);
            var f = u === "start" ? 0 : 1, g = r === "horizontal" ? 0 : 1;
            l = u === "start" ? -l : l;
            for (var d = h === "center", A = 0; A < c[f].length - 1; A++) {
              var p = c[f][A].slice(), v = this._firstDayOfMonth[A];
              if (d) {
                var y = this._firstDayPoints[A];
                p[g] = (y[g] + c[0][A + 1][g]) / 2;
              }
              var m = o.get("formatter"), _ = s[+v.m - 1], E = { yyyy: v.y, yy: (v.y + "").slice(2), MM: v.m, M: +v.m, nameMap: _ }, I = this._formatterLabel(m, E), x = new ge({ z2: 30, style: Y(Ke(o, { text: I }), this._monthTextPositionControl(p, d, r, u, l)) });
              a.add(x);
            }
          }
        }, t.prototype._weekTextPositionControl = function(e, i, r, a, o) {
          var s = "center", l = "middle", u = e[0], h = e[1], c = r === "start";
          return i === "horizontal" ? (u = u + a + (c ? 1 : -1) * o[0] / 2, s = c ? "right" : "left") : (h = h + a + (c ? 1 : -1) * o[1] / 2, l = c ? "bottom" : "top"), { x: u, y: h, align: s, verticalAlign: l };
        }, t.prototype._renderWeekText = function(e, i, r, a, o) {
          var s = e.getModel("dayLabel");
          if (s.get("show")) {
            var l = e.coordinateSystem, u = s.get("position"), h = s.get("nameMap"), c = s.get("margin"), f = l.getFirstDayOfWeek();
            if (!h || ht(h)) {
              h && (i = sB(h) || i);
              var g = i.get(["time", "dayOfWeekShort"]);
              h = g || Z(i.get(["time", "dayOfWeekAbbr"]), function(E) {
                return E[0];
              });
            }
            var d = l.getNextNDay(r.end.time, 7 - r.lweek).time, A = [l.getCellWidth(), l.getCellHeight()];
            c = ot(c, Math.min(A[1], A[0])), u === "start" && (d = l.getNextNDay(r.start.time, -(7 + r.fweek)).time, c = -c);
            for (var p = 0; p < 7; p++) {
              var v = l.getNextNDay(d, p), y = l.dataToRect([v.time], false).center, m = p;
              m = Math.abs((p + f) % 7);
              var _ = new ge({ z2: 30, style: Y(Ke(s, { text: h[m] }), this._weekTextPositionControl(y, a, u, c, A)) });
              o.add(_);
            }
          }
        }, t.type = "calendar", t;
      }(on), zD = 864e5, ULt = function() {
        function n(t, e, i) {
          this.type = "calendar", this.dimensions = n.dimensions, this.getDimensionsInfo = n.getDimensionsInfo, this._model = t;
        }
        return n.getDimensionsInfo = function() {
          return [{ name: "time", type: "time" }, "value"];
        }, n.prototype.getRangeInfo = function() {
          return this._rangeInfo;
        }, n.prototype.getModel = function() {
          return this._model;
        }, n.prototype.getRect = function() {
          return this._rect;
        }, n.prototype.getCellWidth = function() {
          return this._sw;
        }, n.prototype.getCellHeight = function() {
          return this._sh;
        }, n.prototype.getOrient = function() {
          return this._orient;
        }, n.prototype.getFirstDayOfWeek = function() {
          return this._firstDayOfWeek;
        }, n.prototype.getDateInfo = function(t) {
          t = Do(t);
          var e = t.getFullYear(), i = t.getMonth() + 1, r = i < 10 ? "0" + i : "" + i, a = t.getDate(), o = a < 10 ? "0" + a : "" + a, s = t.getDay();
          return s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7), { y: e + "", m: r, d: o, day: s, time: t.getTime(), formatedDate: e + "-" + r + "-" + o, date: t };
        }, n.prototype.getNextNDay = function(t, e) {
          return e = e || 0, e === 0 ? this.getDateInfo(t) : (t = new Date(this.getDateInfo(t).time), t.setDate(t.getDate() + e), this.getDateInfo(t));
        }, n.prototype.update = function(t, e) {
          this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
          var i = this._rangeInfo.weeks || 1, r = ["width", "height"], a = this._model.getCellSize().slice(), o = this._model.getBoxLayoutParams(), s = this._orient === "horizontal" ? [i, 7] : [7, i];
          M([0, 1], function(c) {
            h(a, c) && (o[r[c]] = a[c] * s[c]);
          });
          var l = { width: e.getWidth(), height: e.getHeight() }, u = this._rect = Gn(o, l);
          M([0, 1], function(c) {
            h(a, c) || (a[c] = u[r[c]] / s[c]);
          });
          function h(c, f) {
            return c[f] != null && c[f] !== "auto";
          }
          this._sw = a[0], this._sh = a[1];
        }, n.prototype.dataToPoint = function(t, e) {
          X(t) && (t = t[0]), e == null && (e = true);
          var i = this.getDateInfo(t), r = this._rangeInfo, a = i.formatedDate;
          if (e && !(i.time >= r.start.time && i.time < r.end.time + zD)) return [NaN, NaN];
          var o = i.day, s = this._getRangeInfo([r.start.time, a]).nthWeek;
          return this._orient === "vertical" ? [this._rect.x + o * this._sw + this._sw / 2, this._rect.y + s * this._sh + this._sh / 2] : [this._rect.x + s * this._sw + this._sw / 2, this._rect.y + o * this._sh + this._sh / 2];
        }, n.prototype.pointToData = function(t) {
          var e = this.pointToDate(t);
          return e && e.time;
        }, n.prototype.dataToRect = function(t, e) {
          var i = this.dataToPoint(t, e);
          return { contentShape: { x: i[0] - (this._sw - this._lineWidth) / 2, y: i[1] - (this._sh - this._lineWidth) / 2, width: this._sw - this._lineWidth, height: this._sh - this._lineWidth }, center: i, tl: [i[0] - this._sw / 2, i[1] - this._sh / 2], tr: [i[0] + this._sw / 2, i[1] - this._sh / 2], br: [i[0] + this._sw / 2, i[1] + this._sh / 2], bl: [i[0] - this._sw / 2, i[1] + this._sh / 2] };
        }, n.prototype.pointToDate = function(t) {
          var e = Math.floor((t[0] - this._rect.x) / this._sw) + 1, i = Math.floor((t[1] - this._rect.y) / this._sh) + 1, r = this._rangeInfo.range;
          return this._orient === "vertical" ? this._getDateByWeeksAndDay(i, e - 1, r) : this._getDateByWeeksAndDay(e, i - 1, r);
        }, n.prototype.convertToPixel = function(t, e, i) {
          var r = $7(e);
          return r === this ? r.dataToPoint(i) : null;
        }, n.prototype.convertFromPixel = function(t, e, i) {
          var r = $7(e);
          return r === this ? r.pointToData(i) : null;
        }, n.prototype.containPoint = function(t) {
          return false;
        }, n.prototype._initRangeOption = function() {
          var t = this._model.get("range"), e;
          if (X(t) && t.length === 1 && (t = t[0]), X(t)) e = t;
          else {
            var i = t.toString();
            if (/^\d{4}$/.test(i) && (e = [i + "-01-01", i + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(i)) {
              var r = this.getDateInfo(i), a = r.date;
              a.setMonth(a.getMonth() + 1);
              var o = this.getNextNDay(a, -1);
              e = [r.formatedDate, o.formatedDate];
            }
            /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(i) && (e = [i, i]);
          }
          if (!e) return za("Invalid date range."), t;
          var s = this._getRangeInfo(e);
          return s.start.time > s.end.time && e.reverse(), e;
        }, n.prototype._getRangeInfo = function(t) {
          var e = [this.getDateInfo(t[0]), this.getDateInfo(t[1])], i;
          e[0].time > e[1].time && (i = true, e.reverse());
          var r = Math.floor(e[1].time / zD) - Math.floor(e[0].time / zD) + 1, a = new Date(e[0].time), o = a.getDate(), s = e[1].date.getDate();
          a.setDate(o + r - 1);
          var l = a.getDate();
          if (l !== s) for (var u = a.getTime() - e[1].time > 0 ? 1 : -1; (l = a.getDate()) !== s && (a.getTime() - e[1].time) * u > 0; ) r -= u, a.setDate(l - u);
          var h = Math.floor((r + e[0].day + 6) / 7), c = i ? -h + 1 : h - 1;
          return i && e.reverse(), { range: [e[0].formatedDate, e[1].formatedDate], start: e[0], end: e[1], allDay: r, weeks: h, nthWeek: c, fweek: e[0].day, lweek: e[1].day };
        }, n.prototype._getDateByWeeksAndDay = function(t, e, i) {
          var r = this._getRangeInfo(i);
          if (t > r.weeks || t === 0 && e < r.fweek || t === r.weeks && e > r.lweek) return null;
          var a = (t - 1) * 7 - r.fweek + e, o = new Date(r.start.time);
          return o.setDate(+r.start.d + a), this.getDateInfo(o);
        }, n.create = function(t, e) {
          var i = [];
          return t.eachComponent("calendar", function(r) {
            var a = new n(r);
            i.push(a), r.coordinateSystem = a;
          }), t.eachSeries(function(r) {
            r.get("coordinateSystem") === "calendar" && (r.coordinateSystem = i[r.get("calendarIndex") || 0]);
          }), i;
        }, n.dimensions = ["time", "value"], n;
      }();
      function $7(n) {
        var t = n.calendarModel, e = n.seriesModel, i = t ? t.coordinateSystem : e ? e.coordinateSystem : null;
        return i;
      }
      function VLt(n) {
        n.registerComponentModel(zLt), n.registerComponentView(GLt), n.registerCoordinateSystem("calendar", ULt);
      }
      function jLt(n, t) {
        var e = n.existing;
        if (t.id = n.keyInfo.id, !t.type && e && (t.type = e.type), t.parentId == null) {
          var i = t.parentOption;
          i ? t.parentId = i.id : e && (t.parentId = e.parentId);
        }
        t.parentOption = null;
      }
      function J7(n, t) {
        var e;
        return M(t, function(i) {
          n[i] != null && n[i] !== "auto" && (e = true);
        }), e;
      }
      function qLt(n, t, e) {
        var i = Y({}, e), r = n[t], a = e.$action || "merge";
        if (a === "merge") if (r) {
          if (true) {
            var o = e.type;
            It(!o || r.type === o, 'Please set $action: "replace" to change `type`');
          }
          qt(r, i, true), iu(r, i, { ignoreSize: true }), R4(e, r), KI(e, r), KI(e, r, "shape"), KI(e, r, "style"), KI(e, r, "extra"), e.clipPath = r.clipPath;
        } else n[t] = i;
        else a === "replace" ? n[t] = i : a === "remove" && r && (n[t] = null);
      }
      var tH = ["transition", "enterFrom", "leaveTo"], HLt = tH.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
      function KI(n, t, e) {
        if (e && (!n[e] && t[e] && (n[e] = {}), n = n[e], t = t[e]), !(!n || !t)) for (var i = e ? tH : HLt, r = 0; r < i.length; r++) {
          var a = i[r];
          n[a] == null && t[a] != null && (n[a] = t[a]);
        }
      }
      function YLt(n, t) {
        if (n && (n.hv = t.hv = [J7(t, ["left", "right"]), J7(t, ["top", "bottom"])], n.type === "group")) {
          var e = n, i = t;
          e.width == null && (e.width = i.width = 0), e.height == null && (e.height = i.height = 0);
        }
      }
      var WLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.preventAutoZ = true, e;
        }
        return t.prototype.mergeOption = function(e, i) {
          var r = this.option.elements;
          this.option.elements = null, n.prototype.mergeOption.call(this, e, i), this.option.elements = r;
        }, t.prototype.optionUpdated = function(e, i) {
          var r = this.option, a = (i ? r : e).elements, o = r.elements = i ? [] : r.elements, s = [];
          this._flatten(a, s, null);
          var l = OG(o, s, "normalMerge"), u = this._elOptionsToUpdate = [];
          M(l, function(h, c) {
            var f = h.newOption;
            It(_t(f) || h.existing, "Empty graphic option definition"), f && (u.push(f), jLt(h, f), qLt(o, c, f), YLt(o[c], f));
          }, this), r.elements = Ne(o, function(h) {
            return h && delete h.$action, h != null;
          });
        }, t.prototype._flatten = function(e, i, r) {
          M(e, function(a) {
            if (a) {
              r && (a.parentOption = r), i.push(a);
              var o = a.children;
              o && o.length && this._flatten(o, i, a), delete a.children;
            }
          }, this);
        }, t.prototype.useElOptionsToUpdate = function() {
          var e = this._elOptionsToUpdate;
          return this._elOptionsToUpdate = null, e;
        }, t.type = "graphic", t.defaultOption = { elements: [] }, t;
      }(ne), eH = { path: null, compoundPath: null, group: Ct, image: li, text: ge }, xa = le(), XLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function() {
          this._elMap = dt();
        }, t.prototype.render = function(e, i, r) {
          e !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = e, this._updateElements(e), this._relocate(e, r);
        }, t.prototype._updateElements = function(e) {
          var i = e.useElOptionsToUpdate();
          if (i) {
            var r = this._elMap, a = this.group, o = e.get("z"), s = e.get("zlevel");
            M(i, function(l) {
              var u = zn(l.id, null), h = u != null ? r.get(u) : null, c = zn(l.parentId, null), f = c != null ? r.get(c) : a, g = l.type, d = l.style;
              g === "text" && d && l.hv && l.hv[1] && (d.textVerticalAlign = d.textBaseline = d.verticalAlign = d.align = null);
              var A = l.textContent, p = l.textConfig;
              if (d && e7(d, g, !!p, !!A)) {
                var v = n7(d, g, true);
                !p && v.textConfig && (p = l.textConfig = v.textConfig), !A && v.textContent && (A = v.textContent);
              }
              var y = ZLt(l);
              h && It(f === h.parent, "Changing parent is not supported.");
              var m = l.$action || "merge", _ = m === "merge", E = m === "replace";
              if (_) {
                var I = !h, x = h;
                I ? x = nH(u, f, l.type, r) : (x && (xa(x).isNew = false), A7(x)), x && (GI(x, y, e, { isInit: I }), iH(x, l, o, s));
              } else if (E) {
                $I(h, l, r, e);
                var w = nH(u, f, l.type, r);
                w && (GI(w, y, e, { isInit: true }), iH(w, l, o, s));
              } else m === "remove" && (h7(h, l), $I(h, l, r, e));
              var C = r.get(u);
              if (C && A) if (_) {
                var S = C.getTextContent();
                S ? S.attr(A) : C.setTextContent(new ge(A));
              } else E && C.setTextContent(new ge(A));
              if (C) {
                var b = l.clipPath;
                if (b) {
                  var B = b.type, T = void 0, I = false;
                  if (_) {
                    var D = C.getClipPath();
                    I = !D || xa(D).type !== B, T = I ? GD(B) : D;
                  } else E && (I = true, T = GD(B));
                  C.setClipPath(T), GI(T, b, e, { isInit: I }), VI(T, b.keyframeAnimation, e);
                }
                var R = xa(C);
                C.setTextConfig(p), R.option = l, KLt(C, e, l), bg({ el: C, componentModel: e, itemName: C.name, itemTooltipOption: l.tooltip }), VI(C, l.keyframeAnimation, e);
              }
            });
          }
        }, t.prototype._relocate = function(e, i) {
          for (var r = e.option.elements, a = this.group, o = this._elMap, s = i.getWidth(), l = i.getHeight(), u = ["x", "y"], h = 0; h < r.length; h++) {
            var c = r[h], f = zn(c.id, null), g = f != null ? o.get(f) : null;
            if (!(!g || !g.isGroup)) {
              var d = g.parent, A = d === a, p = xa(g), v = xa(d);
              p.width = ot(p.option.width, A ? s : v.width) || 0, p.height = ot(p.option.height, A ? l : v.height) || 0;
            }
          }
          for (var h = r.length - 1; h >= 0; h--) {
            var c = r[h], f = zn(c.id, null), g = f != null ? o.get(f) : null;
            if (g) {
              var d = g.parent, v = xa(d), y = d === a ? { width: s, height: l } : { width: v.width, height: v.height }, m = {}, _ = C1(g, c, y, null, { hv: c.hv, boundingMode: c.bounding }, m);
              if (!xa(g).isNew && _) {
                for (var E = c.transition, I = {}, x = 0; x < u.length; x++) {
                  var w = u[x], C = m[w];
                  E && (cc(E) || Wt(E, w) >= 0) ? I[w] = C : g[w] = C;
                }
                _e(g, I, e, 0);
              } else g.attr(m);
            }
          }
        }, t.prototype._clear = function() {
          var e = this, i = this._elMap;
          i.each(function(r) {
            $I(r, xa(r).option, i, e._lastGraphicModel);
          }), this._elMap = dt();
        }, t.prototype.dispose = function() {
          this._clear();
        }, t.type = "graphic", t;
      }(on);
      function GD(n) {
        It(n, "graphic type MUST be set");
        var t = ft(eH, n) ? eH[n] : J2(n);
        It(t, "graphic type " + n + " can not be found");
        var e = new t({});
        return xa(e).type = n, e;
      }
      function nH(n, t, e, i) {
        var r = GD(e);
        return t.add(r), i.set(n, r), xa(r).id = n, xa(r).isNew = true, r;
      }
      function $I(n, t, e, i) {
        var r = n && n.parent;
        r && (n.type === "group" && n.traverse(function(a) {
          $I(a, t, e, i);
        }), UI(n, t, i), e.removeKey(xa(n).id));
      }
      function iH(n, t, e, i) {
        n.isGroup || M([["cursor", ha.prototype.cursor], ["zlevel", i || 0], ["z", e || 0], ["z2", 0]], function(r) {
          var a = r[0];
          ft(t, a) ? n[a] = Pt(t[a], r[1]) : n[a] == null && (n[a] = r[1]);
        }), M(re(t), function(r) {
          if (r.indexOf("on") === 0) {
            var a = t[r];
            n[r] = yt(a) ? a : null;
          }
        }), ft(t, "draggable") && (n.draggable = t.draggable), t.name != null && (n.name = t.name), t.id != null && (n.id = t.id);
      }
      function ZLt(n) {
        return n = Y({}, n), M(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(D4), function(t) {
          delete n[t];
        }), n;
      }
      function KLt(n, t, e) {
        var i = Dt(n).eventData;
        !n.silent && !n.ignore && !i && (i = Dt(n).eventData = { componentType: "graphic", componentIndex: t.componentIndex, name: n.name }), i && (i.info = e.info);
      }
      function $Lt(n) {
        n.registerComponentModel(WLt), n.registerComponentView(XLt), n.registerPreprocessor(function(t) {
          var e = t.graphic;
          X(e) ? !e[0] || !e[0].elements ? t.graphic = [{ elements: e }] : t.graphic = [t.graphic[0]] : e && !e.elements && (t.graphic = [{ elements: [e] }]);
        });
      }
      var rH = ["x", "y", "radius", "angle", "single"], JLt = ["cartesian2d", "polar", "singleAxis"];
      function tPt(n) {
        var t = n.get("coordinateSystem");
        return Wt(JLt, t) >= 0;
      }
      function vu(n) {
        return It(n), n + "Axis";
      }
      function ePt(n, t) {
        var e = dt(), i = [], r = dt();
        n.eachComponent({ mainType: "dataZoom", query: t }, function(h) {
          r.get(h.uid) || s(h);
        });
        var a;
        do
          a = false, n.eachComponent("dataZoom", o);
        while (a);
        function o(h) {
          !r.get(h.uid) && l(h) && (s(h), a = true);
        }
        function s(h) {
          r.set(h.uid, true), i.push(h), u(h);
        }
        function l(h) {
          var c = false;
          return h.eachTargetAxis(function(f, g) {
            var d = e.get(f);
            d && d[g] && (c = true);
          }), c;
        }
        function u(h) {
          h.eachTargetAxis(function(c, f) {
            (e.get(c) || e.set(c, []))[f] = true;
          });
        }
        return i;
      }
      function aH(n) {
        var t = n.ecModel, e = { infoList: [], infoMap: dt() };
        return n.eachTargetAxis(function(i, r) {
          var a = t.getComponent(vu(i), r);
          if (a) {
            var o = a.getCoordSysModel();
            if (o) {
              var s = o.uid, l = e.infoMap.get(s);
              l || (l = { model: o, axisModels: [] }, e.infoList.push(l), e.infoMap.set(s, l)), l.axisModels.push(a);
            }
          }
        }), e;
      }
      var UD = function() {
        function n() {
          this.indexList = [], this.indexMap = [];
        }
        return n.prototype.add = function(t) {
          this.indexMap[t] || (this.indexList.push(t), this.indexMap[t] = true);
        }, n;
      }(), Kv = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._autoThrottle = true, e._noTarget = true, e._rangePropMode = ["percent", "percent"], e;
        }
        return t.prototype.init = function(e, i, r) {
          var a = oH(e);
          this.settledOption = a, this.mergeDefaultAndTheme(e, r), this._doInit(a);
        }, t.prototype.mergeOption = function(e) {
          var i = oH(e);
          qt(this.option, e, true), qt(this.settledOption, i, true), this._doInit(i);
        }, t.prototype._doInit = function(e) {
          var i = this.option;
          this._setDefaultThrottle(e), this._updateRangeUse(e);
          var r = this.settledOption;
          M([["start", "startValue"], ["end", "endValue"]], function(a, o) {
            this._rangePropMode[o] === "value" && (i[a[0]] = r[a[0]] = null);
          }, this), this._resetTarget();
        }, t.prototype._resetTarget = function() {
          var e = this.get("orient", true), i = this._targetAxisInfoMap = dt(), r = this._fillSpecifiedTargetAxis(i);
          r ? this._orient = e || this._makeAutoOrientByTargetAxis() : (this._orient = e || "horizontal", this._fillAutoTargetAxisByOrient(i, this._orient)), this._noTarget = true, i.each(function(a) {
            a.indexList.length && (this._noTarget = false);
          }, this);
        }, t.prototype._fillSpecifiedTargetAxis = function(e) {
          var i = false;
          return M(rH, function(r) {
            var a = this.getReferringComponents(vu(r), Hmt);
            if (a.specified) {
              i = true;
              var o = new UD();
              M(a.models, function(s) {
                o.add(s.componentIndex);
              }), e.set(r, o);
            }
          }, this), i;
        }, t.prototype._fillAutoTargetAxisByOrient = function(e, i) {
          var r = this.ecModel, a = true;
          if (a) {
            var o = i === "vertical" ? "y" : "x", s = r.findComponents({ mainType: o + "Axis" });
            l(s, o);
          }
          if (a) {
            var s = r.findComponents({ mainType: "singleAxis", filter: function(h) {
              return h.get("orient", true) === i;
            } });
            l(s, "single");
          }
          function l(u, h) {
            var c = u[0];
            if (c) {
              var f = new UD();
              if (f.add(c.componentIndex), e.set(h, f), a = false, h === "x" || h === "y") {
                var g = c.getReferringComponents("grid", Ln).models[0];
                g && M(u, function(d) {
                  c.componentIndex !== d.componentIndex && g === d.getReferringComponents("grid", Ln).models[0] && f.add(d.componentIndex);
                });
              }
            }
          }
          a && M(rH, function(u) {
            if (a) {
              var h = r.findComponents({ mainType: vu(u), filter: function(f) {
                return f.get("type", true) === "category";
              } });
              if (h[0]) {
                var c = new UD();
                c.add(h[0].componentIndex), e.set(u, c), a = false;
              }
            }
          }, this);
        }, t.prototype._makeAutoOrientByTargetAxis = function() {
          var e;
          return this.eachTargetAxis(function(i) {
            !e && (e = i);
          }, this), e === "y" ? "vertical" : "horizontal";
        }, t.prototype._setDefaultThrottle = function(e) {
          if (e.hasOwnProperty("throttle") && (this._autoThrottle = false), this._autoThrottle) {
            var i = this.ecModel.option;
            this.option.throttle = i.animation && i.animationDurationUpdate > 0 ? 100 : 20;
          }
        }, t.prototype._updateRangeUse = function(e) {
          var i = this._rangePropMode, r = this.get("rangeMode");
          M([["start", "startValue"], ["end", "endValue"]], function(a, o) {
            var s = e[a[0]] != null, l = e[a[1]] != null;
            s && !l ? i[o] = "percent" : !s && l ? i[o] = "value" : r ? i[o] = r[o] : s && (i[o] = "percent");
          });
        }, t.prototype.noTarget = function() {
          return this._noTarget;
        }, t.prototype.getFirstTargetAxisModel = function() {
          var e;
          return this.eachTargetAxis(function(i, r) {
            e == null && (e = this.ecModel.getComponent(vu(i), r));
          }, this), e;
        }, t.prototype.eachTargetAxis = function(e, i) {
          this._targetAxisInfoMap.each(function(r, a) {
            M(r.indexList, function(o) {
              e.call(i, a, o);
            });
          });
        }, t.prototype.getAxisProxy = function(e, i) {
          var r = this.getAxisModel(e, i);
          if (r) return r.__dzAxisProxy;
        }, t.prototype.getAxisModel = function(e, i) {
          It(e && i != null);
          var r = this._targetAxisInfoMap.get(e);
          if (r && r.indexMap[i]) return this.ecModel.getComponent(vu(e), i);
        }, t.prototype.setRawRange = function(e) {
          var i = this.option, r = this.settledOption;
          M([["start", "startValue"], ["end", "endValue"]], function(a) {
            (e[a[0]] != null || e[a[1]] != null) && (i[a[0]] = r[a[0]] = e[a[0]], i[a[1]] = r[a[1]] = e[a[1]]);
          }, this), this._updateRangeUse(e);
        }, t.prototype.setCalculatedRange = function(e) {
          var i = this.option;
          M(["start", "startValue", "end", "endValue"], function(r) {
            i[r] = e[r];
          });
        }, t.prototype.getPercentRange = function() {
          var e = this.findRepresentativeAxisProxy();
          if (e) return e.getDataPercentWindow();
        }, t.prototype.getValueRange = function(e, i) {
          if (e == null && i == null) {
            var r = this.findRepresentativeAxisProxy();
            if (r) return r.getDataValueWindow();
          } else return this.getAxisProxy(e, i).getDataValueWindow();
        }, t.prototype.findRepresentativeAxisProxy = function(e) {
          if (e) return e.__dzAxisProxy;
          for (var i, r = this._targetAxisInfoMap.keys(), a = 0; a < r.length; a++) for (var o = r[a], s = this._targetAxisInfoMap.get(o), l = 0; l < s.indexList.length; l++) {
            var u = this.getAxisProxy(o, s.indexList[l]);
            if (u.hostedBy(this)) return u;
            i || (i = u);
          }
          return i;
        }, t.prototype.getRangePropMode = function() {
          return this._rangePropMode.slice();
        }, t.prototype.getOrient = function() {
          return It(this._orient), this._orient;
        }, t.type = "dataZoom", t.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"], t.defaultOption = { z: 4, filterMode: "filter", start: 0, end: 100 }, t;
      }(ne);
      function oH(n) {
        var t = {};
        return M(["start", "end", "startValue", "endValue", "throttle"], function(e) {
          n.hasOwnProperty(e) && (t[e] = n[e]);
        }), t;
      }
      var nPt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "dataZoom.select", t;
      }(Kv), VD = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r, a) {
          this.dataZoomModel = e, this.ecModel = i, this.api = r;
        }, t.type = "dataZoom", t;
      }(on), iPt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "dataZoom.select", t;
      }(VD), hd = M, sH = ua, rPt = function() {
        function n(t, e, i, r) {
          this._dimName = t, this._axisIndex = e, this.ecModel = r, this._dataZoomModel = i;
        }
        return n.prototype.hostedBy = function(t) {
          return this._dataZoomModel === t;
        }, n.prototype.getDataValueWindow = function() {
          return this._valueWindow.slice();
        }, n.prototype.getDataPercentWindow = function() {
          return this._percentWindow.slice();
        }, n.prototype.getTargetSeriesModels = function() {
          var t = [];
          return this.ecModel.eachSeries(function(e) {
            if (tPt(e)) {
              var i = vu(this._dimName), r = e.getReferringComponents(i, Ln).models[0];
              r && this._axisIndex === r.componentIndex && t.push(e);
            }
          }, this), t;
        }, n.prototype.getAxisModel = function() {
          return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
        }, n.prototype.getMinMaxSpan = function() {
          return xt(this._minMaxSpan);
        }, n.prototype.calculateDataWindow = function(t) {
          var e = this._dataExtent, i = this.getAxisModel(), r = i.axis.scale, a = this._dataZoomModel.getRangePropMode(), o = [0, 100], s = [], l = [], u;
          hd(["start", "end"], function(f, g) {
            var d = t[f], A = t[f + "Value"];
            a[g] === "percent" ? (d == null && (d = o[g]), A = r.parse(Le(d, o, e))) : (u = true, A = A == null ? e[g] : r.parse(A), d = Le(A, e, o)), l[g] = A == null || isNaN(A) ? e[g] : A, s[g] = d == null || isNaN(d) ? o[g] : d;
          }), sH(l), sH(s);
          var h = this._minMaxSpan;
          u ? c(l, s, e, o, false) : c(s, l, o, e, true);
          function c(f, g, d, A, p) {
            var v = p ? "Span" : "ValueSpan";
            lc(0, f, d, "all", h["min" + v], h["max" + v]);
            for (var y = 0; y < 2; y++) g[y] = Le(f[y], d, A, true), p && (g[y] = r.parse(g[y]));
          }
          return { valueWindow: l, percentWindow: s };
        }, n.prototype.reset = function(t) {
          if (t === this._dataZoomModel) {
            var e = this.getTargetSeriesModels();
            this._dataExtent = aPt(this, this._dimName, e), this._updateMinMaxSpan();
            var i = this.calculateDataWindow(t.settledOption);
            this._valueWindow = i.valueWindow, this._percentWindow = i.percentWindow, this._setAxisModel();
          }
        }, n.prototype.filterData = function(t, e) {
          if (t !== this._dataZoomModel) return;
          var i = this._dimName, r = this.getTargetSeriesModels(), a = t.get("filterMode"), o = this._valueWindow;
          if (a === "none") return;
          hd(r, function(l) {
            var u = l.getData(), h = u.mapDimensionsAll(i);
            if (h.length) {
              if (a === "weakFilter") {
                var c = u.getStore(), f = Z(h, function(g) {
                  return u.getDimensionIndex(g);
                }, u);
                u.filterSelf(function(g) {
                  for (var d, A, p, v = 0; v < h.length; v++) {
                    var y = c.get(f[v], g), m = !isNaN(y), _ = y < o[0], E = y > o[1];
                    if (m && !_ && !E) return true;
                    m && (p = true), _ && (d = true), E && (A = true);
                  }
                  return p && d && A;
                });
              } else hd(h, function(g) {
                if (a === "empty") l.setData(u = u.map(g, function(A) {
                  return s(A) ? A : NaN;
                }));
                else {
                  var d = {};
                  d[g] = o, u.selectRange(d);
                }
              });
              hd(h, function(g) {
                u.setApproximateExtent(o, g);
              });
            }
          });
          function s(l) {
            return l >= o[0] && l <= o[1];
          }
        }, n.prototype._updateMinMaxSpan = function() {
          var t = this._minMaxSpan = {}, e = this._dataZoomModel, i = this._dataExtent;
          hd(["min", "max"], function(r) {
            var a = e.get(r + "Span"), o = e.get(r + "ValueSpan");
            o != null && (o = this.getAxisModel().axis.scale.parse(o)), o != null ? a = Le(i[0] + o, i, [0, 100], true) : a != null && (o = Le(a, [0, 100], i, true) - i[0]), t[r + "Span"] = a, t[r + "ValueSpan"] = o;
          }, this);
        }, n.prototype._setAxisModel = function() {
          var t = this.getAxisModel(), e = this._percentWindow, i = this._valueWindow;
          if (e) {
            var r = SG(i, [0, 500]);
            r = Math.min(r, 20);
            var a = t.axis.scale.rawExtentInfo;
            e[0] !== 0 && a.setDeterminedMinMax("min", +i[0].toFixed(r)), e[1] !== 100 && a.setDeterminedMinMax("max", +i[1].toFixed(r)), a.freeze();
          }
        }, n;
      }();
      function aPt(n, t, e) {
        var i = [1 / 0, -1 / 0];
        hd(e, function(o) {
          Owt(i, o.getData(), t);
        });
        var r = n.getAxisModel(), a = dU(r.axis.scale, r, i).calculate();
        return [a.min, a.max];
      }
      var oPt = { getTargetSeries: function(n) {
        function t(r) {
          n.eachComponent("dataZoom", function(a) {
            a.eachTargetAxis(function(o, s) {
              var l = n.getComponent(vu(o), s);
              r(o, s, l, a);
            });
          });
        }
        t(function(r, a, o, s) {
          o.__dzAxisProxy = null;
        });
        var e = [];
        t(function(r, a, o, s) {
          o.__dzAxisProxy || (o.__dzAxisProxy = new rPt(r, a, s, n), e.push(o.__dzAxisProxy));
        });
        var i = dt();
        return M(e, function(r) {
          M(r.getTargetSeriesModels(), function(a) {
            i.set(a.uid, a);
          });
        }), i;
      }, overallReset: function(n, t) {
        n.eachComponent("dataZoom", function(e) {
          e.eachTargetAxis(function(i, r) {
            e.getAxisProxy(i, r).reset(e);
          }), e.eachTargetAxis(function(i, r) {
            e.getAxisProxy(i, r).filterData(e, t);
          });
        }), n.eachComponent("dataZoom", function(e) {
          var i = e.findRepresentativeAxisProxy();
          if (i) {
            var r = i.getDataPercentWindow(), a = i.getDataValueWindow();
            e.setCalculatedRange({ start: r[0], end: r[1], startValue: a[0], endValue: a[1] });
          }
        });
      } };
      function sPt(n) {
        n.registerAction("dataZoom", function(t, e) {
          var i = ePt(e, t);
          M(i, function(r) {
            r.setRawRange({ start: t.start, end: t.end, startValue: t.startValue, endValue: t.endValue });
          });
        });
      }
      var lH = false;
      function jD(n) {
        lH || (lH = true, n.registerProcessor(n.PRIORITY.PROCESSOR.FILTER, oPt), sPt(n), n.registerSubTypeDefaulter("dataZoom", function() {
          return "slider";
        }));
      }
      function lPt(n) {
        n.registerComponentModel(nPt), n.registerComponentView(iPt), jD(n);
      }
      var wa = /* @__PURE__ */ function() {
        function n() {
        }
        return n;
      }(), uH = {};
      function cd(n, t) {
        uH[n] = t;
      }
      function hH(n) {
        return uH[n];
      }
      var uPt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.optionUpdated = function() {
          n.prototype.optionUpdated.apply(this, arguments);
          var e = this.ecModel;
          M(this.option.feature, function(i, r) {
            var a = hH(r);
            a && (a.getDefaultOption && (a.defaultOption = a.getDefaultOption(e)), qt(i, a.defaultOption));
          });
        }, t.type = "toolbox", t.layoutMode = { type: "box", ignoreSize: true }, t.defaultOption = { show: true, z: 6, orient: "horizontal", left: "right", top: "top", backgroundColor: "transparent", borderColor: "#ccc", borderRadius: 0, borderWidth: 0, padding: 5, itemSize: 15, itemGap: 8, showTitle: true, iconStyle: { borderColor: "#666", color: "none" }, emphasis: { iconStyle: { borderColor: "#3E98C5" } }, tooltip: { show: false, position: "bottom" } }, t;
      }(ne);
      function hPt(n, t, e) {
        var i = t.getBoxLayoutParams(), r = t.get("padding"), a = { width: e.getWidth(), height: e.getHeight() }, o = Gn(i, a, r);
        Fh(t.get("orient"), n, t.get("itemGap"), o.width, o.height), C1(n, i, a, r);
      }
      function cH(n, t) {
        var e = Lg(t.get("padding")), i = t.getItemStyle(["color", "opacity"]);
        return i.fill = t.get("backgroundColor"), n = new ue({ shape: { x: n.x - e[3], y: n.y - e[0], width: n.width + e[1] + e[3], height: n.height + e[0] + e[2], r: t.get("borderRadius") }, style: i, silent: true, z2: -1 }), n;
      }
      var cPt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.render = function(e, i, r, a) {
          var o = this.group;
          if (o.removeAll(), !e.get("show")) return;
          var s = +e.get("itemSize"), l = e.get("orient") === "vertical", u = e.get("feature") || {}, h = this._features || (this._features = {}), c = [];
          M(u, function(d, A) {
            c.push(A);
          }), new Os(this._featureNames || [], c).add(f).update(f).remove(Ot(f, null)).execute(), this._featureNames = c;
          function f(d, A) {
            var p = c[d], v = c[A], y = u[p], m = new Te(y, e, e.ecModel), _;
            if (a && a.newTitle != null && a.featureName === p && (y.title = a.newTitle), p && !v) {
              if (fPt(p)) _ = { onclick: m.option.onclick, featureName: p };
              else {
                var E = hH(p);
                if (!E) return;
                _ = new E();
              }
              h[p] = _;
            } else if (_ = h[v], !_) return;
            _.uid = Tg("toolbox-feature"), _.model = m, _.ecModel = i, _.api = r;
            var I = _ instanceof wa;
            if (!p && v) {
              I && _.dispose && _.dispose(i, r);
              return;
            }
            if (!m.get("show") || I && _.unusable) {
              I && _.remove && _.remove(i, r);
              return;
            }
            g(m, _, p), m.setIconStatus = function(x, w) {
              var C = this.option, S = this.iconPaths;
              C.iconStatus = C.iconStatus || {}, C.iconStatus[x] = w, S[x] && (w === "emphasis" ? Ps : Ns)(S[x]);
            }, _ instanceof wa && _.render && _.render(m, i, r, a);
          }
          function g(d, A, p) {
            var v = d.getModel("iconStyle"), y = d.getModel(["emphasis", "iconStyle"]), m = A instanceof wa && A.getIcons ? A.getIcons() : d.get("icon"), _ = d.get("title") || {}, E, I;
            ht(m) ? (E = {}, E[p] = m) : E = m, ht(_) ? (I = {}, I[p] = _) : I = _;
            var x = d.iconPaths = {};
            M(E, function(w, C) {
              var S = Hp(w, {}, { x: -s / 2, y: -s / 2, width: s, height: s });
              S.setStyle(v.getItemStyle());
              var b = S.ensureState("emphasis");
              b.style = y.getItemStyle();
              var B = new ge({ style: { text: I[C], align: y.get("textAlign"), borderRadius: y.get("textBorderRadius"), padding: y.get("textPadding"), fill: null, font: nB({ fontStyle: y.get("textFontStyle"), fontFamily: y.get("textFontFamily"), fontSize: y.get("textFontSize"), fontWeight: y.get("textFontWeight") }, i) }, ignore: true });
              S.setTextContent(B), bg({ el: S, componentModel: e, itemName: C, formatterParamsExtra: { title: I[C] } }), S.__title = I[C], S.on("mouseover", function() {
                var T = y.getItemStyle(), D = l ? e.get("right") == null && e.get("left") !== "right" ? "right" : "left" : e.get("bottom") == null && e.get("top") !== "bottom" ? "bottom" : "top";
                B.setStyle({ fill: y.get("textFill") || T.fill || T.stroke || "#000", backgroundColor: y.get("textBackgroundColor") }), S.setTextConfig({ position: y.get("textPosition") || D }), B.ignore = !e.get("showTitle"), r.enterEmphasis(this);
              }).on("mouseout", function() {
                d.get(["iconStatus", C]) !== "emphasis" && r.leaveEmphasis(this), B.hide();
              }), (d.get(["iconStatus", C]) === "emphasis" ? Ps : Ns)(S), o.add(S), S.on("click", ct(A.onclick, A, i, r, C)), x[C] = S;
            });
          }
          hPt(o, e, r), o.add(cH(o.getBoundingRect(), e)), l || o.eachChild(function(d) {
            var A = d.__title, p = d.ensureState("emphasis"), v = p.textConfig || (p.textConfig = {}), y = d.getTextContent(), m = y && y.ensureState("emphasis");
            if (m && !yt(m) && A) {
              var _ = m.style || (m.style = {}), E = Cp(A, ge.makeFont(_)), I = d.x + o.x, x = d.y + o.y + s, w = false;
              x + E.height > r.getHeight() && (v.position = "top", w = true);
              var C = w ? -5 - E.height : s + 10;
              I + E.width / 2 > r.getWidth() ? (v.position = ["100%", C], _.align = "right") : I - E.width / 2 < 0 && (v.position = [0, C], _.align = "left");
            }
          });
        }, t.prototype.updateView = function(e, i, r, a) {
          M(this._features, function(o) {
            o instanceof wa && o.updateView && o.updateView(o.model, i, r, a);
          });
        }, t.prototype.remove = function(e, i) {
          M(this._features, function(r) {
            r instanceof wa && r.remove && r.remove(e, i);
          }), this.group.removeAll();
        }, t.prototype.dispose = function(e, i) {
          M(this._features, function(r) {
            r instanceof wa && r.dispose && r.dispose(e, i);
          });
        }, t.type = "toolbox", t;
      }(on);
      function fPt(n) {
        return n.indexOf("my") === 0;
      }
      var gPt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.onclick = function(e, i) {
          var r = this.model, a = r.get("name") || e.get("title.0.text") || "echarts", o = i.getZr().painter.getType() === "svg", s = o ? "svg" : r.get("type", true) || "png", l = i.getConnectedDataURL({ type: s, backgroundColor: r.get("backgroundColor", true) || e.get("backgroundColor") || "#fff", connectedBackgroundColor: r.get("connectedBackgroundColor"), excludeComponents: r.get("excludeComponents"), pixelRatio: r.get("pixelRatio") }), u = ee.browser;
          if (typeof MouseEvent == "function" && (u.newEdge || !u.ie && !u.edge)) {
            var h = document.createElement("a");
            h.download = a + "." + s, h.target = "_blank", h.href = l;
            var c = new MouseEvent("click", { view: document.defaultView, bubbles: true, cancelable: false });
            h.dispatchEvent(c);
          } else if (window.navigator.msSaveOrOpenBlob || o) {
            var f = l.split(","), g = f[0].indexOf("base64") > -1, d = o ? decodeURIComponent(f[1]) : f[1];
            g && (d = window.atob(d));
            var A = a + "." + s;
            if (window.navigator.msSaveOrOpenBlob) {
              for (var p = d.length, v = new Uint8Array(p); p--; ) v[p] = d.charCodeAt(p);
              var y = new Blob([v]);
              window.navigator.msSaveOrOpenBlob(y, A);
            } else {
              var m = document.createElement("iframe");
              document.body.appendChild(m);
              var _ = m.contentWindow, E = _.document;
              E.open("image/svg+xml", "replace"), E.write(d), E.close(), _.focus(), E.execCommand("SaveAs", true, A), document.body.removeChild(m);
            }
          } else {
            var I = r.get("lang"), x = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (I && I[0] || "") + '" /></body>', w = window.open();
            w.document.write(x), w.document.title = a;
          }
        }, t.getDefaultOption = function(e) {
          var i = { show: true, icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0", title: e.getLocaleModel().get(["toolbox", "saveAsImage", "title"]), type: "png", connectedBackgroundColor: "#fff", name: "", excludeComponents: ["toolbox"], lang: e.getLocaleModel().get(["toolbox", "saveAsImage", "lang"]) };
          return i;
        }, t;
      }(wa), fH = "__ec_magicType_stack__", dPt = [["line", "bar"], ["stack"]], APt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.getIcons = function() {
          var e = this.model, i = e.get("icon"), r = {};
          return M(e.get("type"), function(a) {
            i[a] && (r[a] = i[a]);
          }), r;
        }, t.getDefaultOption = function(e) {
          var i = { show: true, type: [], icon: { line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4", bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7", stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z" }, title: e.getLocaleModel().get(["toolbox", "magicType", "title"]), option: {}, seriesIndex: {} };
          return i;
        }, t.prototype.onclick = function(e, i, r) {
          var a = this.model, o = a.get(["seriesIndex", r]);
          if (gH[r]) {
            var s = { series: [] }, l = function(c) {
              var f = c.subType, g = c.id, d = gH[r](f, g, c, a);
              d && (Et(d, c.option), s.series.push(d));
              var A = c.coordinateSystem;
              if (A && A.type === "cartesian2d" && (r === "line" || r === "bar")) {
                var p = A.getAxesByScale("ordinal")[0];
                if (p) {
                  var v = p.dim, y = v + "Axis", m = c.getReferringComponents(y, Ln).models[0], _ = m.componentIndex;
                  s[y] = s[y] || [];
                  for (var E = 0; E <= _; E++) s[y][_] = s[y][_] || {};
                  s[y][_].boundaryGap = r === "bar";
                }
              }
            };
            M(dPt, function(c) {
              Wt(c, r) >= 0 && M(c, function(f) {
                a.setIconStatus(f, "normal");
              });
            }), a.setIconStatus(r, "emphasis"), e.eachComponent({ mainType: "series", query: o == null ? null : { seriesIndex: o } }, l);
            var u, h = r;
            r === "stack" && (u = qt({ stack: a.option.title.tiled, tiled: a.option.title.stack }, a.option.title), a.get(["iconStatus", r]) !== "emphasis" && (h = "tiled")), i.dispatchAction({ type: "changeMagicType", currentType: h, newOption: s, newTitle: u, featureName: "magicType" });
          }
        }, t;
      }(wa), gH = { line: function(n, t, e, i) {
        if (n === "bar") return qt({ id: t, type: "line", data: e.get("data"), stack: e.get("stack"), markPoint: e.get("markPoint"), markLine: e.get("markLine") }, i.get(["option", "line"]) || {}, true);
      }, bar: function(n, t, e, i) {
        if (n === "line") return qt({ id: t, type: "bar", data: e.get("data"), stack: e.get("stack"), markPoint: e.get("markPoint"), markLine: e.get("markLine") }, i.get(["option", "bar"]) || {}, true);
      }, stack: function(n, t, e, i) {
        var r = e.get("stack") === fH;
        if (n === "line" || n === "bar") return i.setIconStatus("stack", r ? "normal" : "emphasis"), qt({ id: t, stack: r ? "" : fH }, i.get(["option", "stack"]) || {}, true);
      } };
      zo({ type: "changeMagicType", event: "magicTypeChanged", update: "prepareAndUpdate" }, function(n, t) {
        t.mergeOption(n.newOption);
      });
      var JI = new Array(60).join("-"), fd = "	";
      function pPt(n) {
        var t = {}, e = [], i = [];
        return n.eachRawSeries(function(r) {
          var a = r.coordinateSystem;
          if (a && (a.type === "cartesian2d" || a.type === "polar")) {
            var o = a.getBaseAxis();
            if (o.type === "category") {
              var s = o.dim + "_" + o.index;
              t[s] || (t[s] = { categoryAxis: o, valueAxis: a.getOtherAxis(o), series: [] }, i.push({ axisDim: o.dim, axisIndex: o.index })), t[s].series.push(r);
            } else e.push(r);
          } else e.push(r);
        }), { seriesGroupByCategoryAxis: t, other: e, meta: i };
      }
      function vPt(n) {
        var t = [];
        return M(n, function(e, i) {
          var r = e.categoryAxis, a = e.valueAxis, o = a.dim, s = [" "].concat(Z(e.series, function(g) {
            return g.name;
          })), l = [r.model.getCategories()];
          M(e.series, function(g) {
            var d = g.getRawData();
            l.push(g.getRawData().mapArray(d.mapDimension(o), function(A) {
              return A;
            }));
          });
          for (var u = [s.join(fd)], h = 0; h < l[0].length; h++) {
            for (var c = [], f = 0; f < l.length; f++) c.push(l[f][h]);
            u.push(c.join(fd));
          }
          t.push(u.join(`
`));
        }), t.join(`

` + JI + `

`);
      }
      function yPt(n) {
        return Z(n, function(t) {
          var e = t.getRawData(), i = [t.name], r = [];
          return e.each(e.dimensions, function() {
            for (var a = arguments.length, o = arguments[a - 1], s = e.getName(o), l = 0; l < a - 1; l++) r[l] = arguments[l];
            i.push((s ? s + fd : "") + r.join(fd));
          }), i.join(`
`);
        }).join(`

` + JI + `

`);
      }
      function mPt(n) {
        var t = pPt(n);
        return { value: Ne([vPt(t.seriesGroupByCategoryAxis), yPt(t.other)], function(e) {
          return !!e.replace(/[\n\t\s]/g, "");
        }).join(`

` + JI + `

`), meta: t.meta };
      }
      function tE(n) {
        return n.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function _Pt(n) {
        var t = n.slice(0, n.indexOf(`
`));
        if (t.indexOf(fd) >= 0) return true;
      }
      var qD = new RegExp("[" + fd + "]+", "g");
      function IPt(n) {
        for (var t = n.split(/\n+/g), e = tE(t.shift()).split(qD), i = [], r = Z(e, function(l) {
          return { name: l, data: [] };
        }), a = 0; a < t.length; a++) {
          var o = tE(t[a]).split(qD);
          i.push(o.shift());
          for (var s = 0; s < o.length; s++) r[s] && (r[s].data[a] = o[s]);
        }
        return { series: r, categories: i };
      }
      function EPt(n) {
        for (var t = n.split(/\n+/g), e = tE(t.shift()), i = [], r = 0; r < t.length; r++) {
          var a = tE(t[r]);
          if (a) {
            var o = a.split(qD), s = "", l = void 0, u = false;
            isNaN(o[0]) ? (u = true, s = o[0], o = o.slice(1), i[r] = { name: s, value: [] }, l = i[r].value) : l = i[r] = [];
            for (var h = 0; h < o.length; h++) l.push(+o[h]);
            l.length === 1 && (u ? i[r].value = l[0] : i[r] = l[0]);
          }
        }
        return { name: e, data: i };
      }
      function xPt(n, t) {
        var e = n.split(new RegExp(`
*` + JI + `
*`, "g")), i = { series: [] };
        return M(e, function(r, a) {
          if (_Pt(r)) {
            var o = IPt(r), s = t[a], l = s.axisDim + "Axis";
            s && (i[l] = i[l] || [], i[l][s.axisIndex] = { data: o.categories }, i.series = i.series.concat(o.series));
          } else {
            var o = EPt(r);
            i.series.push(o);
          }
        }), i;
      }
      var wPt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.onclick = function(e, i) {
          setTimeout(function() {
            i.dispatchAction({ type: "hideTip" });
          });
          var r = i.getDom(), a = this.model;
          this._dom && r.removeChild(this._dom);
          var o = document.createElement("div");
          o.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", o.style.backgroundColor = a.get("backgroundColor") || "#fff";
          var s = document.createElement("h4"), l = a.get("lang") || [];
          s.innerHTML = l[0] || a.get("title"), s.style.cssText = "margin:10px 20px", s.style.color = a.get("textColor");
          var u = document.createElement("div"), h = document.createElement("textarea");
          u.style.cssText = "overflow:auto";
          var c = a.get("optionToContent"), f = a.get("contentToOption"), g = mPt(e);
          if (yt(c)) {
            var d = c(i.getOption());
            ht(d) ? u.innerHTML = d : eh(d) && u.appendChild(d);
          } else {
            h.readOnly = a.get("readOnly");
            var A = h.style;
            A.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", A.color = a.get("textColor"), A.borderColor = a.get("textareaBorderColor"), A.backgroundColor = a.get("textareaColor"), h.value = g.value, u.appendChild(h);
          }
          var p = g.meta, v = document.createElement("div");
          v.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
          var y = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", m = document.createElement("div"), _ = document.createElement("div");
          y += ";background-color:" + a.get("buttonColor"), y += ";color:" + a.get("buttonTextColor");
          var E = this;
          function I() {
            r.removeChild(o), E._dom = null;
          }
          Cb(m, "click", I), Cb(_, "click", function() {
            if (f == null && c != null || f != null && c == null) {
              un("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored."), I();
              return;
            }
            var x;
            try {
              yt(f) ? x = f(u, i.getOption()) : x = xPt(h.value, p);
            } catch (w) {
              throw I(), new Error("Data view format error " + w);
            }
            x && i.dispatchAction({ type: "changeDataView", newOption: x }), I();
          }), m.innerHTML = l[1], _.innerHTML = l[2], _.style.cssText = m.style.cssText = y, !a.get("readOnly") && v.appendChild(_), v.appendChild(m), o.appendChild(s), o.appendChild(u), o.appendChild(v), u.style.height = r.clientHeight - 80 + "px", r.appendChild(o), this._dom = o;
        }, t.prototype.remove = function(e, i) {
          this._dom && i.getDom().removeChild(this._dom);
        }, t.prototype.dispose = function(e, i) {
          this.remove(e, i);
        }, t.getDefaultOption = function(e) {
          var i = { show: true, readOnly: false, optionToContent: null, contentToOption: null, icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28", title: e.getLocaleModel().get(["toolbox", "dataView", "title"]), lang: e.getLocaleModel().get(["toolbox", "dataView", "lang"]), backgroundColor: "#fff", textColor: "#000", textareaColor: "#fff", textareaBorderColor: "#333", buttonColor: "#c23531", buttonTextColor: "#fff" };
          return i;
        }, t;
      }(wa);
      function CPt(n, t) {
        return Z(n, function(e, i) {
          var r = t && t[i];
          if (_t(r) && !X(r)) {
            var a = _t(e) && !X(e);
            a || (e = { value: e });
            var o = r.name != null && e.name == null;
            return e = Et(e, r), o && delete e.name, e;
          } else return e;
        });
      }
      zo({ type: "changeDataView", event: "dataViewChanged", update: "prepareAndUpdate" }, function(n, t) {
        var e = [];
        M(n.newOption.series, function(i) {
          var r = t.getSeriesByName(i.name)[0];
          if (!r) e.push(Y({ type: "scatter" }, i));
          else {
            var a = r.get("data");
            e.push({ name: i.name, data: CPt(i.data, a) });
          }
        }), t.mergeOption(Et({ series: e }, n.newOption));
      });
      var dH = M, AH = le();
      function SPt(n, t) {
        var e = HD(n);
        dH(t, function(i, r) {
          for (var a = e.length - 1; a >= 0; a--) {
            var o = e[a];
            if (o[r]) break;
          }
          if (a < 0) {
            var s = n.queryComponents({ mainType: "dataZoom", subType: "select", id: r })[0];
            if (s) {
              var l = s.getPercentRange();
              e[0][r] = { dataZoomId: r, start: l[0], end: l[1] };
            }
          }
        }), e.push(t);
      }
      function bPt(n) {
        var t = HD(n), e = t[t.length - 1];
        t.length > 1 && t.pop();
        var i = {};
        return dH(e, function(r, a) {
          for (var o = t.length - 1; o >= 0; o--) if (r = t[o][a], r) {
            i[a] = r;
            break;
          }
        }), i;
      }
      function BPt(n) {
        AH(n).snapshots = null;
      }
      function TPt(n) {
        return HD(n).length;
      }
      function HD(n) {
        var t = AH(n);
        return t.snapshots || (t.snapshots = [{}]), t.snapshots;
      }
      var MPt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.onclick = function(e, i) {
          BPt(e), i.dispatchAction({ type: "restore", from: this.uid });
        }, t.getDefaultOption = function(e) {
          var i = { show: true, icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5", title: e.getLocaleModel().get(["toolbox", "restore", "title"]) };
          return i;
        }, t;
      }(wa);
      zo({ type: "restore", event: "restore", update: "prepareAndUpdate" }, function(n, t) {
        t.resetOption("recreate");
      });
      var DPt = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"], YD = function() {
        function n(t, e, i) {
          var r = this;
          this._targetInfoList = [];
          var a = pH(e, t);
          M(RPt, function(o, s) {
            (!i || !i.include || Wt(i.include, s) >= 0) && o(a, r._targetInfoList);
          });
        }
        return n.prototype.setOutputRanges = function(t, e) {
          return this.matchOutputRanges(t, e, function(i, r, a) {
            if ((i.coordRanges || (i.coordRanges = [])).push(r), !i.coordRange) {
              i.coordRange = r;
              var o = XD[i.brushType](0, a, r);
              i.__rangeOffset = { offset: _H[i.brushType](o.values, i.range, [1, 1]), xyMinMax: o.xyMinMax };
            }
          }), t;
        }, n.prototype.matchOutputRanges = function(t, e, i) {
          M(t, function(r) {
            var a = this.findTargetInfo(r, e);
            a && a !== true && M(a.coordSyses, function(o) {
              var s = XD[r.brushType](1, o, r.range, true);
              i(r, s.values, o, e);
            });
          }, this);
        }, n.prototype.setInputRanges = function(t, e) {
          M(t, function(i) {
            var r = this.findTargetInfo(i, e);
            if (It(!r || r === true || i.coordRange, "coordRange must be specified when coord index specified."), It(!r || r !== true || i.range, "range must be specified in global brush."), i.range = i.range || [], r && r !== true) {
              i.panelId = r.panelId;
              var a = XD[i.brushType](0, r.coordSys, i.coordRange), o = i.__rangeOffset;
              i.range = o ? _H[i.brushType](a.values, o.offset, LPt(a.xyMinMax, o.xyMinMax)) : a.values;
            }
          }, this);
        }, n.prototype.makePanelOpts = function(t, e) {
          return Z(this._targetInfoList, function(i) {
            var r = i.getPanelRect();
            return { panelId: i.panelId, defaultBrushType: e ? e(i) : null, clipPath: dq(r), isTargetByCursor: pq(r, t, i.coordSysModel), getLinearBrushOtherExtent: Aq(r) };
          });
        }, n.prototype.controlSeries = function(t, e, i) {
          var r = this.findTargetInfo(t, i);
          return r === true || r && Wt(r.coordSyses, e.coordinateSystem) >= 0;
        }, n.prototype.findTargetInfo = function(t, e) {
          for (var i = this._targetInfoList, r = pH(e, t), a = 0; a < i.length; a++) {
            var o = i[a], s = t.panelId;
            if (s) {
              if (o.panelId === s) return o;
            } else for (var l = 0; l < vH.length; l++) if (vH[l](r, o)) return o;
          }
          return true;
        }, n;
      }();
      function WD(n) {
        return n[0] > n[1] && n.reverse(), n;
      }
      function pH(n, t) {
        return Mp(n, t, { includeMainTypes: DPt });
      }
      var RPt = { grid: function(n, t) {
        var e = n.xAxisModels, i = n.yAxisModels, r = n.gridModels, a = dt(), o = {}, s = {};
        !e && !i && !r || (M(e, function(l) {
          var u = l.axis.grid.model;
          a.set(u.id, u), o[u.id] = true;
        }), M(i, function(l) {
          var u = l.axis.grid.model;
          a.set(u.id, u), s[u.id] = true;
        }), M(r, function(l) {
          a.set(l.id, l), o[l.id] = true, s[l.id] = true;
        }), a.each(function(l) {
          var u = l.coordinateSystem, h = [];
          M(u.getCartesians(), function(c, f) {
            (Wt(e, c.getAxis("x").model) >= 0 || Wt(i, c.getAxis("y").model) >= 0) && h.push(c);
          }), t.push({ panelId: "grid--" + l.id, gridModel: l, coordSysModel: l, coordSys: h[0], coordSyses: h, getPanelRect: yH.grid, xAxisDeclared: o[l.id], yAxisDeclared: s[l.id] });
        }));
      }, geo: function(n, t) {
        M(n.geoModels, function(e) {
          var i = e.coordinateSystem;
          t.push({ panelId: "geo--" + e.id, geoModel: e, coordSysModel: e, coordSys: i, coordSyses: [i], getPanelRect: yH.geo });
        });
      } }, vH = [function(n, t) {
        var e = n.xAxisModel, i = n.yAxisModel, r = n.gridModel;
        return !r && e && (r = e.axis.grid.model), !r && i && (r = i.axis.grid.model), r && r === t.gridModel;
      }, function(n, t) {
        var e = n.geoModel;
        return e && e === t.geoModel;
      }], yH = { grid: function() {
        return this.coordSys.master.getRect().clone();
      }, geo: function() {
        var n = this.coordSys, t = n.getBoundingRect().clone();
        return t.applyTransform(Lh(n)), t;
      } }, XD = { lineX: Ot(mH, 0), lineY: Ot(mH, 1), rect: function(n, t, e, i) {
        var r = n ? t.pointToData([e[0][0], e[1][0]], i) : t.dataToPoint([e[0][0], e[1][0]], i), a = n ? t.pointToData([e[0][1], e[1][1]], i) : t.dataToPoint([e[0][1], e[1][1]], i), o = [WD([r[0], a[0]]), WD([r[1], a[1]])];
        return { values: o, xyMinMax: o };
      }, polygon: function(n, t, e, i) {
        var r = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]], a = Z(e, function(o) {
          var s = n ? t.pointToData(o, i) : t.dataToPoint(o, i);
          return r[0][0] = Math.min(r[0][0], s[0]), r[1][0] = Math.min(r[1][0], s[1]), r[0][1] = Math.max(r[0][1], s[0]), r[1][1] = Math.max(r[1][1], s[1]), s;
        });
        return { values: a, xyMinMax: r };
      } };
      function mH(n, t, e, i) {
        It(e.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
        var r = e.getAxis(["x", "y"][n]), a = WD(Z([0, 1], function(s) {
          return t ? r.coordToData(r.toLocalCoord(i[s]), true) : r.toGlobalCoord(r.dataToCoord(i[s]));
        })), o = [];
        return o[n] = a, o[1 - n] = [NaN, NaN], { values: a, xyMinMax: o };
      }
      var _H = { lineX: Ot(IH, 0), lineY: Ot(IH, 1), rect: function(n, t, e) {
        return [[n[0][0] - e[0] * t[0][0], n[0][1] - e[0] * t[0][1]], [n[1][0] - e[1] * t[1][0], n[1][1] - e[1] * t[1][1]]];
      }, polygon: function(n, t, e) {
        return Z(n, function(i, r) {
          return [i[0] - e[0] * t[r][0], i[1] - e[1] * t[r][1]];
        });
      } };
      function IH(n, t, e, i) {
        return [t[0] - i[n] * e[0], t[1] - i[n] * e[1]];
      }
      function LPt(n, t) {
        var e = EH(n), i = EH(t), r = [e[0] / i[0], e[1] / i[1]];
        return isNaN(r[0]) && (r[0] = 1), isNaN(r[1]) && (r[1] = 1), r;
      }
      function EH(n) {
        return n ? [n[0][1] - n[0][0], n[1][1] - n[1][0]] : [NaN, NaN];
      }
      var ZD = M, PPt = Gmt("toolbox-dataZoom_"), NPt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.render = function(e, i, r, a) {
          this._brushController || (this._brushController = new XM(r.getZr()), this._brushController.on("brush", ct(this._onBrush, this)).mount()), QPt(e, i, this, a, r), FPt(e, i);
        }, t.prototype.onclick = function(e, i, r) {
          kPt[r].call(this);
        }, t.prototype.remove = function(e, i) {
          this._brushController && this._brushController.unmount();
        }, t.prototype.dispose = function(e, i) {
          this._brushController && this._brushController.dispose();
        }, t.prototype._onBrush = function(e) {
          var i = e.areas;
          if (!e.isEnd || !i.length) return;
          var r = {}, a = this.ecModel;
          this._brushController.updateCovers([]);
          var o = new YD(KD(this.model), a, { include: ["grid"] });
          o.matchOutputRanges(i, a, function(u, h, c) {
            if (c.type === "cartesian2d") {
              var f = u.brushType;
              f === "rect" ? (s("x", c, h[0]), s("y", c, h[1])) : s({ lineX: "x", lineY: "y" }[f], c, h);
            }
          }), SPt(a, r), this._dispatchZoomAction(r);
          function s(u, h, c) {
            var f = h.getAxis(u), g = f.model, d = l(u, g, a), A = d.findRepresentativeAxisProxy(g).getMinMaxSpan();
            (A.minValueSpan != null || A.maxValueSpan != null) && (c = lc(0, c.slice(), f.scale.getExtent(), 0, A.minValueSpan, A.maxValueSpan)), d && (r[d.id] = { dataZoomId: d.id, startValue: c[0], endValue: c[1] });
          }
          function l(u, h, c) {
            var f;
            return c.eachComponent({ mainType: "dataZoom", subType: "select" }, function(g) {
              var d = g.getAxisModel(u, h.componentIndex);
              d && (f = g);
            }), f;
          }
        }, t.prototype._dispatchZoomAction = function(e) {
          var i = [];
          ZD(e, function(r, a) {
            i.push(xt(r));
          }), i.length && this.api.dispatchAction({ type: "dataZoom", from: this.uid, batch: i });
        }, t.getDefaultOption = function(e) {
          var i = { show: true, filterMode: "filter", icon: { zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1", back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26" }, title: e.getLocaleModel().get(["toolbox", "dataZoom", "title"]), brushStyle: { borderWidth: 0, color: "rgba(210,219,238,0.2)" } };
          return i;
        }, t;
      }(wa), kPt = { zoom: function() {
        var n = !this._isZoomActive;
        this.api.dispatchAction({ type: "takeGlobalCursor", key: "dataZoomSelect", dataZoomSelectActive: n });
      }, back: function() {
        this._dispatchZoomAction(bPt(this.ecModel));
      } };
      function KD(n) {
        var t = { xAxisIndex: n.get("xAxisIndex", true), yAxisIndex: n.get("yAxisIndex", true), xAxisId: n.get("xAxisId", true), yAxisId: n.get("yAxisId", true) };
        return t.xAxisIndex == null && t.xAxisId == null && (t.xAxisIndex = "all"), t.yAxisIndex == null && t.yAxisId == null && (t.yAxisIndex = "all"), t;
      }
      function FPt(n, t) {
        n.setIconStatus("back", TPt(t) > 1 ? "emphasis" : "normal");
      }
      function QPt(n, t, e, i, r) {
        var a = e._isZoomActive;
        i && i.type === "takeGlobalCursor" && (a = i.key === "dataZoomSelect" ? i.dataZoomSelectActive : false), e._isZoomActive = a, n.setIconStatus("zoom", a ? "emphasis" : "normal");
        var o = new YD(KD(n), t, { include: ["grid"] }), s = o.makePanelOpts(r, function(l) {
          return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect";
        });
        e._brushController.setPanels(s).enableBrush(a && s.length ? { brushType: "auto", brushStyle: n.getModel("brushStyle").getItemStyle() } : false);
      }
      fIt("dataZoom", function(n) {
        var t = n.getComponent("toolbox", 0), e = ["feature", "dataZoom"];
        if (!t || t.get(e) == null) return;
        var i = t.getModel(e), r = [], a = KD(i), o = Mp(n, a);
        ZD(o.xAxisModels, function(l) {
          return s(l, "xAxis", "xAxisIndex");
        }), ZD(o.yAxisModels, function(l) {
          return s(l, "yAxis", "yAxisIndex");
        });
        function s(l, u, h) {
          var c = l.componentIndex, f = { type: "select", $fromToolbox: true, filterMode: i.get("filterMode", true) || "filter", id: PPt + u + c };
          f[h] = c, r.push(f);
        }
        return r;
      });
      function OPt(n) {
        n.registerComponentModel(uPt), n.registerComponentView(cPt), cd("saveAsImage", gPt), cd("magicType", APt), cd("dataView", wPt), cd("dataZoom", NPt), cd("restore", MPt), Zt(lPt);
      }
      var zPt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "tooltip", t.dependencies = ["axisPointer"], t.defaultOption = { z: 60, show: true, showContent: true, trigger: "item", triggerOn: "mousemove|click", alwaysShowContent: false, displayMode: "single", renderMode: "auto", confine: null, showDelay: 0, hideDelay: 100, transitionDuration: 0.4, enterable: false, backgroundColor: "#fff", shadowBlur: 10, shadowColor: "rgba(0, 0, 0, .2)", shadowOffsetX: 1, shadowOffsetY: 2, borderRadius: 4, borderWidth: 1, padding: null, extraCssText: "", axisPointer: { type: "line", axis: "auto", animation: "auto", animationDurationUpdate: 200, animationEasingUpdate: "exponentialOut", crossStyle: { color: "#999", width: 1, type: "dashed", textStyle: {} } }, textStyle: { color: "#666", fontSize: 14 } }, t;
      }(ne);
      function xH(n) {
        var t = n.get("confine");
        return t != null ? !!t : n.get("renderMode") === "richText";
      }
      function wH(n) {
        if (ee.domSupported) {
          for (var t = document.documentElement.style, e = 0, i = n.length; e < i; e++) if (n[e] in t) return n[e];
        }
      }
      var CH = wH(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), GPt = wH(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
      function SH(n, t) {
        if (!n) return t;
        t = B4(t, true);
        var e = n.indexOf(t);
        return n = e === -1 ? t : "-" + n.slice(0, e) + "-" + t, n.toLowerCase();
      }
      function UPt(n, t) {
        var e = n.currentStyle || document.defaultView && document.defaultView.getComputedStyle(n);
        return e ? e[t] : null;
      }
      var VPt = SH(GPt, "transition"), $D = SH(CH, "transform"), jPt = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (ee.transform3dSupported ? "will-change:transform;" : "");
      function qPt(n) {
        return n = n === "left" ? "right" : n === "right" ? "left" : n === "top" ? "bottom" : "top", n;
      }
      function HPt(n, t, e) {
        if (!ht(e) || e === "inside") return "";
        var i = n.get("backgroundColor"), r = n.get("borderWidth");
        t = Nh(t);
        var a = qPt(e), o = Math.max(Math.round(r) * 1.5, 6), s = "", l = $D + ":", u;
        Wt(["left", "right"], a) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
        var h = u * Math.PI / 180, c = o + r, f = c * Math.abs(Math.cos(h)) + c * Math.abs(Math.sin(h)), g = Math.round(((f - Math.SQRT2 * r) / 2 + Math.SQRT2 * r - (f - c) / 2) * 100) / 100;
        s += ";" + a + ":-" + g + "px";
        var d = t + " solid " + r + "px;", A = ["position:absolute;width:" + o + "px;height:" + o + "px;z-index:-1;", s + ";" + l + ";", "border-bottom:" + d, "border-right:" + d, "background-color:" + i + ";"];
        return '<div style="' + A.join("") + '"></div>';
      }
      function YPt(n, t) {
        var e = "cubic-bezier(0.23,1,0.32,1)", i = " " + n / 2 + "s " + e, r = "opacity" + i + ",visibility" + i;
        return t || (i = " " + n + "s " + e, r += ee.transformSupported ? "," + $D + i : ",left" + i + ",top" + i), VPt + ":" + r;
      }
      function bH(n, t, e) {
        var i = n.toFixed(0) + "px", r = t.toFixed(0) + "px";
        if (!ee.transformSupported) return e ? "top:" + r + ";left:" + i + ";" : [["top", r], ["left", i]];
        var a = ee.transform3dSupported, o = "translate" + (a ? "3d" : "") + "(" + i + "," + r + (a ? ",0" : "") + ")";
        return e ? "top:0;left:0;" + $D + ":" + o + ";" : [["top", 0], ["left", 0], [CH, o]];
      }
      function WPt(n) {
        var t = [], e = n.get("fontSize"), i = n.getTextColor();
        i && t.push("color:" + i), t.push("font:" + n.getFont()), e && t.push("line-height:" + Math.round(e * 3 / 2) + "px");
        var r = n.get("textShadowColor"), a = n.get("textShadowBlur") || 0, o = n.get("textShadowOffsetX") || 0, s = n.get("textShadowOffsetY") || 0;
        return r && a && t.push("text-shadow:" + o + "px " + s + "px " + a + "px " + r), M(["decoration", "align"], function(l) {
          var u = n.get(l);
          u && t.push("text-" + l + ":" + u);
        }), t.join(";");
      }
      function XPt(n, t, e) {
        var i = [], r = n.get("transitionDuration"), a = n.get("backgroundColor"), o = n.get("shadowBlur"), s = n.get("shadowColor"), l = n.get("shadowOffsetX"), u = n.get("shadowOffsetY"), h = n.getModel("textStyle"), c = R8(n, "html"), f = l + "px " + u + "px " + o + "px " + s;
        return i.push("box-shadow:" + f), t && r && i.push(YPt(r, e)), a && i.push("background-color:" + a), M(["width", "color", "radius"], function(g) {
          var d = "border-" + g, A = B4(d), p = n.get(A);
          p != null && i.push(d + ":" + p + (g === "color" ? "" : "px"));
        }), i.push(WPt(h)), c != null && i.push("padding:" + Lg(c).join("px ") + "px"), i.join(";") + ";";
      }
      function BH(n, t, e, i, r) {
        var a = t && t.painter;
        if (e) {
          var o = a && a.getViewportRoot();
          o && y0t(n, o, e, i, r);
        } else {
          n[0] = i, n[1] = r;
          var s = a && a.getViewportRootOffset();
          s && (n[0] += s.offsetLeft, n[1] += s.offsetTop);
        }
        n[2] = n[0] / t.getWidth(), n[3] = n[1] / t.getHeight();
      }
      var ZPt = function() {
        function n(t, e) {
          if (this._show = false, this._styleCoord = [0, 0, 0, 0], this._enterable = true, this._alwaysShowContent = false, this._firstShow = true, this._longHide = true, ee.wxa) return null;
          var i = document.createElement("div");
          i.domBelongToZr = true, this.el = i;
          var r = this._zr = t.getZr(), a = e.appendTo, o = a && (ht(a) ? document.querySelector(a) : eh(a) ? a : yt(a) && a(t.getDom()));
          BH(this._styleCoord, r, o, t.getWidth() / 2, t.getHeight() / 2), (o || t.getDom()).appendChild(i), this._api = t, this._container = o;
          var s = this;
          i.onmouseenter = function() {
            s._enterable && (clearTimeout(s._hideTimeout), s._show = true), s._inContent = true;
          }, i.onmousemove = function(l) {
            if (l = l || window.event, !s._enterable) {
              var u = r.handler, h = r.painter.getViewportRoot();
              oa(h, l, true), u.dispatch("mousemove", l);
            }
          }, i.onmouseleave = function() {
            s._inContent = false, s._enterable && s._show && s.hideLater(s._hideDelay);
          };
        }
        return n.prototype.update = function(t) {
          if (!this._container) {
            var e = this._api.getDom(), i = UPt(e, "position"), r = e.style;
            r.position !== "absolute" && i !== "absolute" && (r.position = "relative");
          }
          var a = t.get("alwaysShowContent");
          a && this._moveIfResized(), this._alwaysShowContent = a, this.el.className = t.get("className") || "";
        }, n.prototype.show = function(t, e) {
          clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
          var i = this.el, r = i.style, a = this._styleCoord;
          i.innerHTML ? r.cssText = jPt + XPt(t, !this._firstShow, this._longHide) + bH(a[0], a[1], true) + ("border-color:" + Nh(e) + ";") + (t.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : r.display = "none", this._show = true, this._firstShow = false, this._longHide = false;
        }, n.prototype.setContent = function(t, e, i, r, a) {
          var o = this.el;
          if (t == null) {
            o.innerHTML = "";
            return;
          }
          var s = "";
          if (ht(a) && i.get("trigger") === "item" && !xH(i) && (s = HPt(i, r, a)), ht(t)) o.innerHTML = t + s;
          else if (t) {
            o.innerHTML = "", X(t) || (t = [t]);
            for (var l = 0; l < t.length; l++) eh(t[l]) && t[l].parentNode !== o && o.appendChild(t[l]);
            if (s && o.childNodes.length) {
              var u = document.createElement("div");
              u.innerHTML = s, o.appendChild(u);
            }
          }
        }, n.prototype.setEnterable = function(t) {
          this._enterable = t;
        }, n.prototype.getSize = function() {
          var t = this.el;
          return [t.offsetWidth, t.offsetHeight];
        }, n.prototype.moveTo = function(t, e) {
          var i = this._styleCoord;
          if (BH(i, this._zr, this._container, t, e), i[0] != null && i[1] != null) {
            var r = this.el.style, a = bH(i[0], i[1]);
            M(a, function(o) {
              r[o[0]] = o[1];
            });
          }
        }, n.prototype._moveIfResized = function() {
          var t = this._styleCoord[2], e = this._styleCoord[3];
          this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight());
        }, n.prototype.hide = function() {
          var t = this, e = this.el.style;
          e.visibility = "hidden", e.opacity = "0", ee.transform3dSupported && (e.willChange = ""), this._show = false, this._longHideTimeout = setTimeout(function() {
            return t._longHide = true;
          }, 500);
        }, n.prototype.hideLater = function(t) {
          this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = false, this._hideTimeout = setTimeout(ct(this.hide, this), t)) : this.hide());
        }, n.prototype.isShow = function() {
          return this._show;
        }, n.prototype.dispose = function() {
          clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
          var t = this.el.parentNode;
          t && t.removeChild(this.el), this.el = this._container = null;
        }, n;
      }(), KPt = function() {
        function n(t) {
          this._show = false, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = false, this._enterable = true, this._zr = t.getZr(), MH(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2);
        }
        return n.prototype.update = function(t) {
          var e = t.get("alwaysShowContent");
          e && this._moveIfResized(), this._alwaysShowContent = e;
        }, n.prototype.show = function() {
          this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = true;
        }, n.prototype.setContent = function(t, e, i, r, a) {
          var o = this;
          _t(t) && Ce(true ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
          var s = i.getModel("textStyle");
          this.el = new ge({ style: { rich: e.richTextStyles, text: t, lineHeight: 22, borderWidth: 1, borderColor: r, textShadowColor: s.get("textShadowColor"), fill: i.get(["textStyle", "color"]), padding: R8(i, "richText"), verticalAlign: "top", align: "left" }, z: i.get("z") }), M(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
            o.el.style[u] = i.get(u);
          }), M(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
            o.el.style[u] = s.get(u) || 0;
          }), this._zr.add(this.el);
          var l = this;
          this.el.on("mouseover", function() {
            l._enterable && (clearTimeout(l._hideTimeout), l._show = true), l._inContent = true;
          }), this.el.on("mouseout", function() {
            l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = false;
          });
        }, n.prototype.setEnterable = function(t) {
          this._enterable = t;
        }, n.prototype.getSize = function() {
          var t = this.el, e = this.el.getBoundingRect(), i = TH(t.style);
          return [e.width + i.left + i.right, e.height + i.top + i.bottom];
        }, n.prototype.moveTo = function(t, e) {
          var i = this.el;
          if (i) {
            var r = this._styleCoord;
            MH(r, this._zr, t, e), t = r[0], e = r[1];
            var a = i.style, o = yu(a.borderWidth || 0), s = TH(a);
            i.x = t + o + s.left, i.y = e + o + s.top, i.markRedraw();
          }
        }, n.prototype._moveIfResized = function() {
          var t = this._styleCoord[2], e = this._styleCoord[3];
          this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight());
        }, n.prototype.hide = function() {
          this.el && this.el.hide(), this._show = false;
        }, n.prototype.hideLater = function(t) {
          this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = false, this._hideTimeout = setTimeout(ct(this.hide, this), t)) : this.hide());
        }, n.prototype.isShow = function() {
          return this._show;
        }, n.prototype.dispose = function() {
          this._zr.remove(this.el);
        }, n;
      }();
      function yu(n) {
        return Math.max(0, n);
      }
      function TH(n) {
        var t = yu(n.shadowBlur || 0), e = yu(n.shadowOffsetX || 0), i = yu(n.shadowOffsetY || 0);
        return { left: yu(t - e), right: yu(t + e), top: yu(t - i), bottom: yu(t + i) };
      }
      function MH(n, t, e, i) {
        n[0] = e, n[1] = i, n[2] = n[0] / t.getWidth(), n[3] = n[1] / t.getHeight();
      }
      var $Pt = new ue({ shape: { x: -1, y: -1, width: 2, height: 2 } }), JPt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e, i) {
          if (!(ee.node || !i.getDom())) {
            var r = e.getComponent("tooltip"), a = this._renderMode = Wmt(r.get("renderMode"));
            this._tooltipContent = a === "richText" ? new KPt(i) : new ZPt(i, { appendTo: r.get("appendToBody", true) ? "body" : r.get("appendTo", true) });
          }
        }, t.prototype.render = function(e, i, r) {
          if (!(ee.node || !r.getDom())) {
            this.group.removeAll(), this._tooltipModel = e, this._ecModel = i, this._api = r;
            var a = this._tooltipContent;
            a.update(e), a.setEnterable(e.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && e.get("transitionDuration") ? Gg(this, "_updatePosition", 50, "fixRate") : av(this, "_updatePosition");
          }
        }, t.prototype._initGlobalListener = function() {
          var e = this._tooltipModel, i = e.get("triggerOn");
          k7("itemTooltip", this._api, ct(function(r, a, o) {
            i !== "none" && (i.indexOf(r) >= 0 ? this._tryShow(a, o) : r === "leave" && this._hide(o));
          }, this));
        }, t.prototype._keepShow = function() {
          var e = this._tooltipModel, i = this._ecModel, r = this._api, a = e.get("triggerOn");
          if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
            var o = this;
            clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
              !r.isDisposed() && o.manuallyShowTip(e, i, r, { x: o._lastX, y: o._lastY, dataByCoordSys: o._lastDataByCoordSys });
            });
          }
        }, t.prototype.manuallyShowTip = function(e, i, r, a) {
          if (!(a.from === this.uid || ee.node || !r.getDom())) {
            var o = DH(a, r);
            this._ticket = "";
            var s = a.dataByCoordSys, l = iNt(a, i, r);
            if (l) {
              var u = l.el.getBoundingRect().clone();
              u.applyTransform(l.el.transform), this._tryShow({ offsetX: u.x + u.width / 2, offsetY: u.y + u.height / 2, target: l.el, position: a.position, positionDefault: "bottom" }, o);
            } else if (a.tooltip && a.x != null && a.y != null) {
              var h = $Pt;
              h.x = a.x, h.y = a.y, h.update(), Dt(h).tooltipConfig = { name: null, option: a.tooltip }, this._tryShow({ offsetX: a.x, offsetY: a.y, target: h }, o);
            } else if (s) this._tryShow({ offsetX: a.x, offsetY: a.y, position: a.position, dataByCoordSys: s, tooltipOption: a.tooltipOption }, o);
            else if (a.seriesIndex != null) {
              if (this._manuallyAxisShowTip(e, i, r, a)) return;
              var c = Q7(a, i), f = c.point[0], g = c.point[1];
              f != null && g != null && this._tryShow({ offsetX: f, offsetY: g, target: c.el, position: a.position, positionDefault: "bottom" }, o);
            } else a.x != null && a.y != null && (r.dispatchAction({ type: "updateAxisPointer", x: a.x, y: a.y }), this._tryShow({ offsetX: a.x, offsetY: a.y, position: a.position, target: r.getZr().findHover(a.x, a.y).target }, o));
          }
        }, t.prototype.manuallyHideTip = function(e, i, r, a) {
          var o = this._tooltipContent;
          this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(DH(a, r));
        }, t.prototype._manuallyAxisShowTip = function(e, i, r, a) {
          var o = a.seriesIndex, s = a.dataIndex, l = i.getComponent("axisPointer").coordSysAxesInfo;
          if (!(o == null || s == null || l == null)) {
            var u = i.getSeriesByIndex(o);
            if (u) {
              var h = u.getData(), c = $v([h.getItemModel(s), u, (u.coordinateSystem || {}).model], this._tooltipModel);
              if (c.get("trigger") === "axis") return r.dispatchAction({ type: "updateAxisPointer", seriesIndex: o, dataIndex: s, position: a.position }), true;
            }
          }
        }, t.prototype._tryShow = function(e, i) {
          var r = e.target, a = this._tooltipModel;
          if (a) {
            this._lastX = e.offsetX, this._lastY = e.offsetY;
            var o = e.dataByCoordSys;
            if (o && o.length) this._showAxisTooltip(o, e);
            else if (r) {
              var s = Dt(r);
              if (s.ssrType === "legend") return;
              this._lastDataByCoordSys = null;
              var l, u;
              Gh(r, function(h) {
                if (Dt(h).dataIndex != null) return l = h, true;
                if (Dt(h).tooltipConfig != null) return u = h, true;
              }, true), l ? this._showSeriesItemTooltip(e, l, i) : u ? this._showComponentItemTooltip(e, u, i) : this._hide(i);
            } else this._lastDataByCoordSys = null, this._hide(i);
          }
        }, t.prototype._showOrMove = function(e, i) {
          var r = e.get("showDelay");
          i = ct(i, this), clearTimeout(this._showTimout), r > 0 ? this._showTimout = setTimeout(i, r) : i();
        }, t.prototype._showAxisTooltip = function(e, i) {
          var r = this._ecModel, a = this._tooltipModel, o = [i.offsetX, i.offsetY], s = $v([i.tooltipOption], a), l = this._renderMode, u = [], h = Zn("section", { blocks: [], noHeader: true }), c = [], f = new kB();
          M(e, function(y) {
            M(y.dataByAxis, function(m) {
              var _ = r.getComponent(m.axisDim + "Axis", m.axisIndex), E = m.value;
              if (!(!_ || E == null)) {
                var I = M7(E, _.axis, r, m.seriesDataIndices, m.valueLabelOpt), x = Zn("section", { header: I, noHeader: !Ga(I), sortBlocks: true, blocks: [] });
                h.blocks.push(x), M(m.seriesDataIndices, function(w) {
                  var C = r.getSeriesByIndex(w.seriesIndex), S = w.dataIndexInside, b = C.getDataParams(S);
                  if (!(b.dataIndex < 0)) {
                    b.axisDim = m.axisDim, b.axisIndex = m.axisIndex, b.axisType = m.axisType, b.axisId = m.axisId, b.axisValue = vT(_.axis, { value: E }), b.axisValueLabel = I, b.marker = f.makeTooltipMarker("item", Nh(b.color), l);
                    var B = f8(C.formatTooltip(S, true, null)), T = B.frag;
                    if (T) {
                      var D = $v([C], a).get("valueFormatter");
                      x.blocks.push(D ? Y({ valueFormatter: D }, T) : T);
                    }
                    B.text && c.push(B.text), u.push(b);
                  }
                });
              }
            });
          }), h.blocks.reverse(), c.reverse();
          var g = i.position, d = s.get("order"), A = T8(h, f, l, d, r.get("useUTC"), s.get("textStyle"));
          A && c.unshift(A);
          var p = l === "richText" ? `

` : "<br/>", v = c.join(p);
          this._showOrMove(s, function() {
            this._updateContentNotChangedOnAxis(e, u) ? this._updatePosition(s, g, o[0], o[1], this._tooltipContent, u) : this._showTooltipContent(s, v, u, Math.random() + "", o[0], o[1], g, null, f);
          });
        }, t.prototype._showSeriesItemTooltip = function(e, i, r) {
          var a = this._ecModel, o = Dt(i), s = o.seriesIndex, l = a.getSeriesByIndex(s), u = o.dataModel || l, h = o.dataIndex, c = o.dataType, f = u.getData(c), g = this._renderMode, d = e.positionDefault, A = $v([f.getItemModel(h), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, d ? { position: d } : null), p = A.get("trigger");
          if (!(p != null && p !== "item")) {
            var v = u.getDataParams(h, c), y = new kB();
            v.marker = y.makeTooltipMarker("item", Nh(v.color), g);
            var m = f8(u.formatTooltip(h, false, c)), _ = A.get("order"), E = A.get("valueFormatter"), I = m.frag, x = I ? T8(E ? Y({ valueFormatter: E }, I) : I, y, g, _, a.get("useUTC"), A.get("textStyle")) : m.text, w = "item_" + u.name + "_" + h;
            this._showOrMove(A, function() {
              this._showTooltipContent(A, x, v, w, e.offsetX, e.offsetY, e.position, e.target, y);
            }), r({ type: "showTip", dataIndexInside: h, dataIndex: f.getRawIndex(h), seriesIndex: s, from: this.uid });
          }
        }, t.prototype._showComponentItemTooltip = function(e, i, r) {
          var a = this._renderMode === "html", o = Dt(i), s = o.tooltipConfig, l = s.option || {}, u = l.encodeHTMLContent;
          if (ht(l)) {
            var h = l;
            l = { content: h, formatter: h }, u = true;
          }
          u && a && l.content && (l = xt(l), l.content = pr(l.content));
          var c = [l], f = this._ecModel.getComponent(o.componentMainType, o.componentIndex);
          f && c.push(f), c.push({ formatter: l.content });
          var g = e.positionDefault, d = $v(c, this._tooltipModel, g ? { position: g } : null), A = d.get("content"), p = Math.random() + "", v = new kB();
          this._showOrMove(d, function() {
            var y = xt(d.get("formatterParams") || {});
            this._showTooltipContent(d, A, y, p, e.offsetX, e.offsetY, e.position, i, v);
          }), r({ type: "showTip", from: this.uid });
        }, t.prototype._showTooltipContent = function(e, i, r, a, o, s, l, u, h) {
          if (this._ticket = "", !(!e.get("showContent") || !e.get("show"))) {
            var c = this._tooltipContent;
            c.setEnterable(e.get("enterable"));
            var f = e.get("formatter");
            l = l || e.get("position");
            var g = i, d = this._getNearestPoint([o, s], r, e.get("trigger"), e.get("borderColor")), A = d.color;
            if (f) if (ht(f)) {
              var p = e.ecModel.get("useUTC"), v = X(r) ? r[0] : r, y = v && v.axisType && v.axisType.indexOf("time") >= 0;
              g = f, y && (g = y1(v.axisValue, g, p)), g = M4(g, r, true);
            } else if (yt(f)) {
              var m = ct(function(_, E) {
                _ === this._ticket && (c.setContent(E, h, e, A, l), this._updatePosition(e, l, o, s, c, r, u));
              }, this);
              this._ticket = a, g = f(r, a, m);
            } else g = f;
            c.setContent(g, h, e, A, l), c.show(e, A), this._updatePosition(e, l, o, s, c, r, u);
          }
        }, t.prototype._getNearestPoint = function(e, i, r, a) {
          if (r === "axis" || X(i)) return { color: a || (this._renderMode === "html" ? "#fff" : "none") };
          if (!X(i)) return { color: a || i.color || i.borderColor };
        }, t.prototype._updatePosition = function(e, i, r, a, o, s, l) {
          var u = this._api.getWidth(), h = this._api.getHeight();
          i = i || e.get("position");
          var c = o.getSize(), f = e.get("align"), g = e.get("verticalAlign"), d = l && l.getBoundingRect().clone();
          if (l && d.applyTransform(l.transform), yt(i) && (i = i([r, a], s, o.el, d, { viewSize: [u, h], contentSize: c.slice() })), X(i)) r = ot(i[0], u), a = ot(i[1], h);
          else if (_t(i)) {
            var A = i;
            A.width = c[0], A.height = c[1];
            var p = Gn(A, { width: u, height: h });
            r = p.x, a = p.y, f = null, g = null;
          } else if (ht(i) && l) {
            var v = nNt(i, d, c, e.get("borderWidth"));
            r = v[0], a = v[1];
          } else {
            var v = tNt(r, a, o, u, h, f ? null : 20, g ? null : 20);
            r = v[0], a = v[1];
          }
          if (f && (r -= RH(f) ? c[0] / 2 : f === "right" ? c[0] : 0), g && (a -= RH(g) ? c[1] / 2 : g === "bottom" ? c[1] : 0), xH(e)) {
            var v = eNt(r, a, o, u, h);
            r = v[0], a = v[1];
          }
          o.moveTo(r, a);
        }, t.prototype._updateContentNotChangedOnAxis = function(e, i) {
          var r = this._lastDataByCoordSys, a = this._cbParamsList, o = !!r && r.length === e.length;
          return o && M(r, function(s, l) {
            var u = s.dataByAxis || [], h = e[l] || {}, c = h.dataByAxis || [];
            o = o && u.length === c.length, o && M(u, function(f, g) {
              var d = c[g] || {}, A = f.seriesDataIndices || [], p = d.seriesDataIndices || [];
              o = o && f.value === d.value && f.axisType === d.axisType && f.axisId === d.axisId && A.length === p.length, o && M(A, function(v, y) {
                var m = p[y];
                o = o && v.seriesIndex === m.seriesIndex && v.dataIndex === m.dataIndex;
              }), a && M(f.seriesDataIndices, function(v) {
                var y = v.seriesIndex, m = i[y], _ = a[y];
                m && _ && _.data !== m.data && (o = false);
              });
            });
          }), this._lastDataByCoordSys = e, this._cbParamsList = i, !!o;
        }, t.prototype._hide = function(e) {
          this._lastDataByCoordSys = null, e({ type: "hideTip", from: this.uid });
        }, t.prototype.dispose = function(e, i) {
          ee.node || !i.getDom() || (av(this, "_updatePosition"), this._tooltipContent.dispose(), PD("itemTooltip", i));
        }, t.type = "tooltip", t;
      }(on);
      function $v(n, t, e) {
        var i = t.ecModel, r;
        e ? (r = new Te(e, i, i), r = new Te(t.option, r, i)) : r = t;
        for (var a = n.length - 1; a >= 0; a--) {
          var o = n[a];
          o && (o instanceof Te && (o = o.get("tooltip", true)), ht(o) && (o = { formatter: o }), o && (r = new Te(o, r, i)));
        }
        return r;
      }
      function DH(n, t) {
        return n.dispatchAction || ct(t.dispatchAction, t);
      }
      function tNt(n, t, e, i, r, a, o) {
        var s = e.getSize(), l = s[0], u = s[1];
        return a != null && (n + l + a + 2 > i ? n -= l + a : n += a), o != null && (t + u + o > r ? t -= u + o : t += o), [n, t];
      }
      function eNt(n, t, e, i, r) {
        var a = e.getSize(), o = a[0], s = a[1];
        return n = Math.min(n + o, i) - o, t = Math.min(t + s, r) - s, n = Math.max(n, 0), t = Math.max(t, 0), [n, t];
      }
      function nNt(n, t, e, i) {
        var r = e[0], a = e[1], o = Math.ceil(Math.SQRT2 * i) + 8, s = 0, l = 0, u = t.width, h = t.height;
        switch (n) {
          case "inside":
            s = t.x + u / 2 - r / 2, l = t.y + h / 2 - a / 2;
            break;
          case "top":
            s = t.x + u / 2 - r / 2, l = t.y - a - o;
            break;
          case "bottom":
            s = t.x + u / 2 - r / 2, l = t.y + h + o;
            break;
          case "left":
            s = t.x - r - o, l = t.y + h / 2 - a / 2;
            break;
          case "right":
            s = t.x + u + o, l = t.y + h / 2 - a / 2;
        }
        return [s, l];
      }
      function RH(n) {
        return n === "center" || n === "middle";
      }
      function iNt(n, t, e) {
        var i = A2(n).queryOptionMap, r = i.keys()[0];
        if (!(!r || r === "series")) {
          var a = Dp(t, r, i.get(r), { useDefault: false, enableAll: false, enableNone: false }), o = a.models[0];
          if (o) {
            var s = e.getViewOfComponentModel(o), l;
            if (s.group.traverse(function(u) {
              var h = Dt(u).tooltipConfig;
              if (h && h.name === n.name) return l = u, true;
            }), l) return { componentMainType: r, componentIndex: o.componentIndex, el: l };
          }
        }
      }
      function rNt(n) {
        Zt(Zv), n.registerComponentModel(zPt), n.registerComponentView(JPt), n.registerAction({ type: "showTip", event: "showTip", update: "tooltip:manuallyShowTip" }, In), n.registerAction({ type: "hideTip", event: "hideTip", update: "tooltip:manuallyHideTip" }, In);
      }
      var aNt = ["rect", "polygon", "keep", "clear"];
      function oNt(n, t) {
        var e = Qe(n ? n.brush : []);
        if (e.length) {
          var i = [];
          M(e, function(l) {
            var u = l.hasOwnProperty("toolbox") ? l.toolbox : [];
            u instanceof Array && (i = i.concat(u));
          });
          var r = n && n.toolbox;
          X(r) && (r = r[0]), r || (r = { feature: {} }, n.toolbox = [r]);
          var a = r.feature || (r.feature = {}), o = a.brush || (a.brush = {}), s = o.type || (o.type = []);
          s.push.apply(s, i), sNt(s), t && !s.length && s.push.apply(s, aNt);
        }
      }
      function sNt(n) {
        var t = {};
        M(n, function(e) {
          t[e] = 1;
        }), n.length = 0, M(t, function(e, i) {
          n.push(i);
        });
      }
      var LH = M;
      function PH(n) {
        if (n) {
          for (var t in n) if (n.hasOwnProperty(t)) return true;
        }
      }
      function JD(n, t, e) {
        var i = {};
        return LH(t, function(a) {
          var o = i[a] = r();
          LH(n[a], function(s, l) {
            if ($n.isValidType(l)) {
              var u = { type: l, visual: s };
              e && e(u, a), o[l] = new $n(u), l === "opacity" && (u = xt(u), u.type = "colorAlpha", o.__hidden.__alphaForOpacity = new $n(u));
            }
          });
        }), i;
        function r() {
          var a = function() {
          };
          a.prototype.__hidden = a.prototype;
          var o = new a();
          return o;
        }
      }
      function NH(n, t, e) {
        var i;
        M(e, function(r) {
          t.hasOwnProperty(r) && PH(t[r]) && (i = true);
        }), i && M(e, function(r) {
          t.hasOwnProperty(r) && PH(t[r]) ? n[r] = xt(t[r]) : delete n[r];
        });
      }
      function lNt(n, t, e, i, r, a) {
        var o = {};
        M(n, function(c) {
          var f = $n.prepareVisualTypes(t[c]);
          o[c] = f;
        });
        var s;
        function l(c) {
          return zB(e, s, c);
        }
        function u(c, f) {
          t6(e, s, c, f);
        }
        e.each(h);
        function h(c, f) {
          s = c;
          var g = e.getRawDataItem(s);
          if (!(g && g.visualMap === false)) for (var d = i.call(r, c), A = t[d], p = o[d], v = 0, y = p.length; v < y; v++) {
            var m = p[v];
            A[m] && A[m].applyVisual(c, l, u);
          }
        }
      }
      function uNt(n, t, e, i) {
        var r = {};
        return M(n, function(a) {
          var o = $n.prepareVisualTypes(t[a]);
          r[a] = o;
        }), { progress: function(o, s) {
          var l;
          i != null && (l = s.getDimensionIndex(i));
          function u(E) {
            return zB(s, c, E);
          }
          function h(E, I) {
            t6(s, c, E, I);
          }
          for (var c, f = s.getStore(); (c = o.next()) != null; ) {
            var g = s.getRawDataItem(c);
            if (!(g && g.visualMap === false)) for (var d = i != null ? f.get(l, c) : c, A = e(d), p = t[A], v = r[A], y = 0, m = v.length; y < m; y++) {
              var _ = v[y];
              p[_] && p[_].applyVisual(d, u, h);
            }
          }
        } };
      }
      function hNt(n) {
        var t = n.brushType, e = { point: function(i) {
          return kH[t].point(i, e, n);
        }, rect: function(i) {
          return kH[t].rect(i, e, n);
        } };
        return e;
      }
      var kH = { lineX: FH(0), lineY: FH(1), rect: { point: function(n, t, e) {
        return n && e.boundingRect.contain(n[0], n[1]);
      }, rect: function(n, t, e) {
        return n && e.boundingRect.intersect(n);
      } }, polygon: { point: function(n, t, e) {
        return n && e.boundingRect.contain(n[0], n[1]) && Yh(e.range, n[0], n[1]);
      }, rect: function(n, t, e) {
        var i = e.range;
        if (!n || i.length <= 1) return false;
        var r = n.x, a = n.y, o = n.width, s = n.height, l = i[0];
        if (Yh(i, r, a) || Yh(i, r + o, a) || Yh(i, r, a + s) || Yh(i, r + o, a + s) || Ht.create(n).contain(l[0], l[1]) || Yp(r, a, r + o, a, i) || Yp(r, a, r, a + s, i) || Yp(r + o, a, r + o, a + s, i) || Yp(r, a + s, r + o, a + s, i)) return true;
      } } };
      function FH(n) {
        var t = ["x", "y"], e = ["width", "height"];
        return { point: function(i, r, a) {
          if (i) {
            var o = a.range, s = i[n];
            return Jv(s, o);
          }
        }, rect: function(i, r, a) {
          if (i) {
            var o = a.range, s = [i[t[n]], i[t[n]] + i[e[n]]];
            return s[1] < s[0] && s.reverse(), Jv(s[0], o) || Jv(s[1], o) || Jv(o[0], s) || Jv(o[1], s);
          }
        } };
      }
      function Jv(n, t) {
        return t[0] <= n && n <= t[1];
      }
      var QH = ["inBrush", "outOfBrush"], tR = "__ecBrushSelect", eR = "__ecInBrushSelectEvent";
      function OH(n) {
        n.eachComponent({ mainType: "brush" }, function(t) {
          var e = t.brushTargetManager = new YD(t.option, n);
          e.setInputRanges(t.areas, n);
        });
      }
      function cNt(n, t, e) {
        var i = [], r, a;
        n.eachComponent({ mainType: "brush" }, function(o) {
          e && e.type === "takeGlobalCursor" && o.setBrushOption(e.key === "brush" ? e.brushOption : { brushType: false });
        }), OH(n), n.eachComponent({ mainType: "brush" }, function(o, s) {
          var l = { brushId: o.id, brushIndex: s, brushName: o.name, areas: xt(o.areas), selected: [] };
          i.push(l);
          var u = o.option, h = u.brushLink, c = [], f = [], g = [], d = false;
          s || (r = u.throttleType, a = u.throttleDelay);
          var A = Z(o.areas, function(E) {
            var I = ANt[E.brushType], x = Et({ boundingRect: I ? I(E) : void 0 }, E);
            return x.selectors = hNt(x), x;
          }), p = JD(o.option, QH, function(E) {
            E.mappingMethod = "fixed";
          });
          X(h) && M(h, function(E) {
            c[E] = 1;
          });
          function v(E) {
            return h === "all" || !!c[E];
          }
          function y(E) {
            return !!E.length;
          }
          n.eachSeries(function(E, I) {
            var x = g[I] = [];
            E.subType === "parallel" ? m(E, I) : _(E, I, x);
          });
          function m(E, I) {
            var x = E.coordinateSystem;
            d = d || x.hasAxisBrushed(), v(I) && x.eachActiveState(E.getData(), function(w, C) {
              w === "active" && (f[C] = 1);
            });
          }
          function _(E, I, x) {
            if (!(!E.brushSelector || dNt(o, I)) && (M(A, function(C) {
              o.brushTargetManager.controlSeries(C, E, n) && x.push(C), d = d || y(x);
            }), v(I) && y(x))) {
              var w = E.getData();
              w.each(function(C) {
                zH(E, x, w, C) && (f[C] = 1);
              });
            }
          }
          n.eachSeries(function(E, I) {
            var x = { seriesId: E.id, seriesIndex: I, seriesName: E.name, dataIndex: [] };
            l.selected.push(x);
            var w = g[I], C = E.getData(), S = v(I) ? function(b) {
              return f[b] ? (x.dataIndex.push(C.getRawIndex(b)), "inBrush") : "outOfBrush";
            } : function(b) {
              return zH(E, w, C, b) ? (x.dataIndex.push(C.getRawIndex(b)), "inBrush") : "outOfBrush";
            };
            (v(I) ? d : y(w)) && lNt(QH, p, C, S);
          });
        }), fNt(t, r, a, i, e);
      }
      function fNt(n, t, e, i, r) {
        if (r) {
          var a = n.getZr();
          if (!a[eR]) {
            a[tR] || (a[tR] = gNt);
            var o = Gg(a, tR, e, t);
            o(n, i);
          }
        }
      }
      function gNt(n, t) {
        if (!n.isDisposed()) {
          var e = n.getZr();
          e[eR] = true, n.dispatchAction({ type: "brushSelect", batch: t }), e[eR] = false;
        }
      }
      function zH(n, t, e, i) {
        for (var r = 0, a = t.length; r < a; r++) {
          var o = t[r];
          if (n.brushSelector(i, e, o.selectors, o)) return true;
        }
      }
      function dNt(n, t) {
        var e = n.option.seriesIndex;
        return e != null && e !== "all" && (X(e) ? Wt(e, t) < 0 : t !== e);
      }
      var ANt = { rect: function(n) {
        return GH(n.range);
      }, polygon: function(n) {
        for (var t, e = n.range, i = 0, r = e.length; i < r; i++) {
          t = t || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
          var a = e[i];
          a[0] < t[0][0] && (t[0][0] = a[0]), a[0] > t[0][1] && (t[0][1] = a[0]), a[1] < t[1][0] && (t[1][0] = a[1]), a[1] > t[1][1] && (t[1][1] = a[1]);
        }
        return t && GH(t);
      } };
      function GH(n) {
        return new Ht(n[0][0], n[1][0], n[0][1] - n[0][0], n[1][1] - n[1][0]);
      }
      var pNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e, i) {
          this.ecModel = e, this.api = i, this.model, (this._brushController = new XM(i.getZr())).on("brush", ct(this._onBrush, this)).mount();
        }, t.prototype.render = function(e, i, r, a) {
          this.model = e, this._updateController(e, i, r, a);
        }, t.prototype.updateTransform = function(e, i, r, a) {
          OH(i), this._updateController(e, i, r, a);
        }, t.prototype.updateVisual = function(e, i, r, a) {
          this.updateTransform(e, i, r, a);
        }, t.prototype.updateView = function(e, i, r, a) {
          this._updateController(e, i, r, a);
        }, t.prototype._updateController = function(e, i, r, a) {
          (!a || a.$from !== e.id) && this._brushController.setPanels(e.brushTargetManager.makePanelOpts(r)).enableBrush(e.brushOption).updateCovers(e.areas.slice());
        }, t.prototype.dispose = function() {
          this._brushController.dispose();
        }, t.prototype._onBrush = function(e) {
          var i = this.model.id, r = this.model.brushTargetManager.setOutputRanges(e.areas, this.ecModel);
          (!e.isEnd || e.removeOnClick) && this.api.dispatchAction({ type: "brush", brushId: i, areas: xt(r), $from: i }), e.isEnd && this.api.dispatchAction({ type: "brushEnd", brushId: i, areas: xt(r), $from: i });
        }, t.type = "brush", t;
      }(on), vNt = "#ddd", yNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.areas = [], e.brushOption = {}, e;
        }
        return t.prototype.optionUpdated = function(e, i) {
          var r = this.option;
          !i && NH(r, e, ["inBrush", "outOfBrush"]);
          var a = r.inBrush = r.inBrush || {};
          r.outOfBrush = r.outOfBrush || { color: vNt }, a.hasOwnProperty("liftZ") || (a.liftZ = 5);
        }, t.prototype.setAreas = function(e) {
          It(X(e)), M(e, function(i) {
            It(i.brushType, "Illegal areas");
          }), e && (this.areas = Z(e, function(i) {
            return UH(this.option, i);
          }, this));
        }, t.prototype.setBrushOption = function(e) {
          this.brushOption = UH(this.option, e), this.brushType = this.brushOption.brushType;
        }, t.type = "brush", t.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], t.defaultOption = { seriesIndex: "all", brushType: "rect", brushMode: "single", transformable: true, brushStyle: { borderWidth: 1, color: "rgba(210,219,238,0.3)", borderColor: "#D2DBEE" }, throttleType: "fixRate", throttleDelay: 0, removeOnClick: true, z: 1e4 }, t;
      }(ne);
      function UH(n, t) {
        return qt({ brushType: n.brushType, brushMode: n.brushMode, transformable: n.transformable, brushStyle: new Te(n.brushStyle).getItemStyle(), removeOnClick: n.removeOnClick, z: n.z }, t, true);
      }
      var mNt = ["rect", "polygon", "lineX", "lineY", "keep", "clear"], _Nt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.render = function(e, i, r) {
          var a, o, s;
          i.eachComponent({ mainType: "brush" }, function(l) {
            a = l.brushType, o = l.brushOption.brushMode || "single", s = s || !!l.areas.length;
          }), this._brushType = a, this._brushMode = o, M(e.get("type", true), function(l) {
            e.setIconStatus(l, (l === "keep" ? o === "multiple" : l === "clear" ? s : l === a) ? "emphasis" : "normal");
          });
        }, t.prototype.updateView = function(e, i, r) {
          this.render(e, i, r);
        }, t.prototype.getIcons = function() {
          var e = this.model, i = e.get("icon", true), r = {};
          return M(e.get("type", true), function(a) {
            i[a] && (r[a] = i[a]);
          }), r;
        }, t.prototype.onclick = function(e, i, r) {
          var a = this._brushType, o = this._brushMode;
          r === "clear" ? (i.dispatchAction({ type: "axisAreaSelect", intervals: [] }), i.dispatchAction({ type: "brush", command: "clear", areas: [] })) : i.dispatchAction({ type: "takeGlobalCursor", key: "brush", brushOption: { brushType: r === "keep" ? a : a === r ? false : r, brushMode: r === "keep" ? o === "multiple" ? "single" : "multiple" : o } });
        }, t.getDefaultOption = function(e) {
          var i = { show: true, type: mNt.slice(), icon: { rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13", polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2", lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4", lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4", keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z", clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2" }, title: e.getLocaleModel().get(["toolbox", "brush", "title"]) };
          return i;
        }, t;
      }(wa);
      function INt(n) {
        n.registerComponentView(pNt), n.registerComponentModel(yNt), n.registerPreprocessor(oNt), n.registerVisual(n.PRIORITY.VISUAL.BRUSH, cNt), n.registerAction({ type: "brush", event: "brush", update: "updateVisual" }, function(t, e) {
          e.eachComponent({ mainType: "brush", query: t }, function(i) {
            i.setAreas(t.areas);
          });
        }), n.registerAction({ type: "brushSelect", event: "brushSelected", update: "none" }, In), n.registerAction({ type: "brushEnd", event: "brushEnd", update: "none" }, In), cd("brush", _Nt);
      }
      var ENt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.layoutMode = { type: "box", ignoreSize: true }, e;
        }
        return t.type = "title", t.defaultOption = { z: 6, show: true, text: "", target: "blank", subtext: "", subtarget: "blank", left: 0, top: 0, backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, padding: 5, itemGap: 10, textStyle: { fontSize: 18, fontWeight: "bold", color: "#464646" }, subtextStyle: { fontSize: 12, color: "#6E7079" } }, t;
      }(ne), xNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          if (this.group.removeAll(), !!e.get("show")) {
            var a = this.group, o = e.getModel("textStyle"), s = e.getModel("subtextStyle"), l = e.get("textAlign"), u = Pt(e.get("textBaseline"), e.get("textVerticalAlign")), h = new ge({ style: Ke(o, { text: e.get("text"), fill: o.getTextColor() }, { disableBox: true }), z2: 10 }), c = h.getBoundingRect(), f = e.get("subtext"), g = new ge({ style: Ke(s, { text: f, fill: s.getTextColor(), y: c.height + e.get("itemGap"), verticalAlign: "top" }, { disableBox: true }), z2: 10 }), d = e.get("link"), A = e.get("sublink"), p = e.get("triggerEvent", true);
            h.silent = !d && !p, g.silent = !A && !p, d && h.on("click", function() {
              x1(d, "_" + e.get("target"));
            }), A && g.on("click", function() {
              x1(A, "_" + e.get("subtarget"));
            }), Dt(h).eventData = Dt(g).eventData = p ? { componentType: "title", componentIndex: e.componentIndex } : null, a.add(h), f && a.add(g);
            var v = a.getBoundingRect(), y = e.getBoxLayoutParams();
            y.width = v.width, y.height = v.height;
            var m = Gn(y, { width: r.getWidth(), height: r.getHeight() }, e.get("padding"));
            l || (l = e.get("left") || e.get("right"), l === "middle" && (l = "center"), l === "right" ? m.x += m.width : l === "center" && (m.x += m.width / 2)), u || (u = e.get("top") || e.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? m.y += m.height : u === "middle" && (m.y += m.height / 2), u = u || "top"), a.x = m.x, a.y = m.y, a.markRedraw();
            var _ = { align: l, verticalAlign: u };
            h.setStyle(_), g.setStyle(_), v = a.getBoundingRect();
            var E = m.margin, I = e.getItemStyle(["color", "opacity"]);
            I.fill = e.get("backgroundColor");
            var x = new ue({ shape: { x: v.x - E[3], y: v.y - E[0], width: v.width + E[1] + E[3], height: v.height + E[0] + E[2], r: e.get("borderRadius") }, style: I, subPixelOptimize: true, silent: true });
            a.add(x);
          }
        }, t.type = "title", t;
      }(on);
      function wNt(n) {
        n.registerComponentModel(ENt), n.registerComponentView(xNt);
      }
      var VH = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.layoutMode = "box", e;
        }
        return t.prototype.init = function(e, i, r) {
          this.mergeDefaultAndTheme(e, r), this._initData();
        }, t.prototype.mergeOption = function(e) {
          n.prototype.mergeOption.apply(this, arguments), this._initData();
        }, t.prototype.setCurrentIndex = function(e) {
          e == null && (e = this.option.currentIndex);
          var i = this._data.count();
          this.option.loop ? e = (e % i + i) % i : (e >= i && (e = i - 1), e < 0 && (e = 0)), this.option.currentIndex = e;
        }, t.prototype.getCurrentIndex = function() {
          return this.option.currentIndex;
        }, t.prototype.isIndexMax = function() {
          return this.getCurrentIndex() >= this._data.count() - 1;
        }, t.prototype.setPlayState = function(e) {
          this.option.autoPlay = !!e;
        }, t.prototype.getPlayState = function() {
          return !!this.option.autoPlay;
        }, t.prototype._initData = function() {
          var e = this.option, i = e.data || [], r = e.axisType, a = this._names = [], o;
          r === "category" ? (o = [], M(i, function(u, h) {
            var c = zn(pg(u), ""), f;
            _t(u) ? (f = xt(u), f.value = h) : f = h, o.push(f), a.push(c);
          })) : o = i;
          var s = { category: "ordinal", time: "time", value: "number" }[r] || "number", l = this._data = new Zi([{ name: "value", type: s }], this);
          l.initData(o, a);
        }, t.prototype.getData = function() {
          return this._data;
        }, t.prototype.getCategories = function() {
          if (this.get("axisType") === "category") return this._names.slice();
        }, t.type = "timeline", t.defaultOption = { z: 4, show: true, axisType: "time", realtime: true, left: "20%", top: null, right: "20%", bottom: 0, width: null, height: 40, padding: 5, controlPosition: "left", autoPlay: false, rewind: false, loop: true, playInterval: 2e3, currentIndex: 0, itemStyle: {}, label: { color: "#000" }, data: [] }, t;
      }(ne), jH = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "timeline.slider", t.defaultOption = eu(VH.defaultOption, { backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, orient: "horizontal", inverse: false, tooltip: { trigger: "item" }, symbol: "circle", symbolSize: 12, lineStyle: { show: true, width: 2, color: "#DAE1F5" }, label: { position: "auto", show: true, interval: "auto", rotate: 0, color: "#A4B1D7" }, itemStyle: { color: "#A4B1D7", borderWidth: 1 }, checkpointStyle: { symbol: "circle", symbolSize: 15, color: "#316bf3", borderColor: "#fff", borderWidth: 2, shadowBlur: 2, shadowOffsetX: 1, shadowOffsetY: 1, shadowColor: "rgba(0, 0, 0, 0.3)", animation: true, animationDuration: 300, animationEasing: "quinticInOut" }, controlStyle: { show: true, showPlayBtn: true, showPrevBtn: true, showNextBtn: true, itemSize: 24, itemGap: 12, position: "left", playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z", stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z", nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z", prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z", prevBtnSize: 18, nextBtnSize: 18, color: "#A4B1D7", borderColor: "#A4B1D7", borderWidth: 1 }, emphasis: { label: { show: true, color: "#6f778d" }, itemStyle: { color: "#316BF3" }, controlStyle: { color: "#316BF3", borderColor: "#316BF3", borderWidth: 2 } }, progress: { lineStyle: { color: "#316BF3" }, itemStyle: { color: "#316BF3" }, label: { color: "#6f778d" } }, data: [] }), t;
      }(VH);
      Mn(jH, T1.prototype);
      var CNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "timeline", t;
      }(on), SNt = function(n) {
        V(t, n);
        function t(e, i, r, a) {
          var o = n.call(this, e, i, r) || this;
          return o.type = a || "value", o;
        }
        return t.prototype.getLabelModel = function() {
          return this.model.getModel("label");
        }, t.prototype.isHorizontal = function() {
          return this.model.get("orient") === "horizontal";
        }, t;
      }($a), nR = Math.PI, qH = le(), bNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e, i) {
          this.api = i;
        }, t.prototype.render = function(e, i, r) {
          if (this.model = e, this.api = r, this.ecModel = i, this.group.removeAll(), e.get("show", true)) {
            var a = this._layout(e, r), o = this._createGroup("_mainGroup"), s = this._createGroup("_labelGroup"), l = this._axis = this._createAxis(a, e);
            e.formatTooltip = function(u) {
              var h = l.scale.getLabel({ value: u });
              return Zn("nameValue", { noName: true, value: h });
            }, M(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(u) {
              this["_render" + u](a, o, l, e);
            }, this), this._renderAxisLabel(a, s, l, e), this._position(a, e);
          }
          this._doPlayStop(), this._updateTicksStatus();
        }, t.prototype.remove = function() {
          this._clearTimer(), this.group.removeAll();
        }, t.prototype.dispose = function() {
          this._clearTimer();
        }, t.prototype._layout = function(e, i) {
          var r = e.get(["label", "position"]), a = e.get("orient"), o = TNt(e, i), s;
          r == null || r === "auto" ? s = a === "horizontal" ? o.y + o.height / 2 < i.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < i.getWidth() / 2 ? "+" : "-" : ht(r) ? s = { horizontal: { top: "-", bottom: "+" }, vertical: { left: "-", right: "+" } }[a][r] : s = r;
          var l = { horizontal: "center", vertical: s >= 0 || s === "+" ? "left" : "right" }, u = { horizontal: s >= 0 || s === "+" ? "top" : "bottom", vertical: "middle" }, h = { horizontal: 0, vertical: nR / 2 }, c = a === "vertical" ? o.height : o.width, f = e.getModel("controlStyle"), g = f.get("show", true), d = g ? f.get("itemSize") : 0, A = g ? f.get("itemGap") : 0, p = d + A, v = e.get(["label", "rotate"]) || 0;
          v = v * nR / 180;
          var y, m, _, E = f.get("position", true), I = g && f.get("showPlayBtn", true), x = g && f.get("showPrevBtn", true), w = g && f.get("showNextBtn", true), C = 0, S = c;
          E === "left" || E === "bottom" ? (I && (y = [0, 0], C += p), x && (m = [C, 0], C += p), w && (_ = [S - d, 0], S -= p)) : (I && (y = [S - d, 0], S -= p), x && (m = [0, 0], C += p), w && (_ = [S - d, 0], S -= p));
          var b = [C, S];
          return e.get("inverse") && b.reverse(), { viewRect: o, mainLength: c, orient: a, rotation: h[a], labelRotation: v, labelPosOpt: s, labelAlign: e.get(["label", "align"]) || l[a], labelBaseline: e.get(["label", "verticalAlign"]) || e.get(["label", "baseline"]) || u[a], playPosition: y, prevBtnPosition: m, nextBtnPosition: _, axisExtent: b, controlSize: d, controlGap: A };
        }, t.prototype._position = function(e, i) {
          var r = this._mainGroup, a = this._labelGroup, o = e.viewRect;
          if (e.orient === "vertical") {
            var s = Fr(), l = o.x, u = o.y + o.height;
            bo(s, s, [-l, -u]), oh(s, s, -nR / 2), bo(s, s, [l, u]), o = o.clone(), o.applyTransform(s);
          }
          var h = y(o), c = y(r.getBoundingRect()), f = y(a.getBoundingRect()), g = [r.x, r.y], d = [a.x, a.y];
          d[0] = g[0] = h[0][0];
          var A = e.labelPosOpt;
          if (A == null || ht(A)) {
            var p = A === "+" ? 0 : 1;
            m(g, c, h, 1, p), m(d, f, h, 1, 1 - p);
          } else {
            var p = A >= 0 ? 0 : 1;
            m(g, c, h, 1, p), d[1] = g[1] + A;
          }
          r.setPosition(g), a.setPosition(d), r.rotation = a.rotation = e.rotation, v(r), v(a);
          function v(_) {
            _.originX = h[0][0] - _.x, _.originY = h[1][0] - _.y;
          }
          function y(_) {
            return [[_.x, _.x + _.width], [_.y, _.y + _.height]];
          }
          function m(_, E, I, x, w) {
            _[x] += I[x][w] - E[x][w];
          }
        }, t.prototype._createAxis = function(e, i) {
          var r = i.getData(), a = i.get("axisType"), o = BNt(i, a);
          o.getTicks = function() {
            return r.mapArray(["value"], function(u) {
              return { value: u };
            });
          };
          var s = r.getDataExtent("value");
          o.setExtent(s[0], s[1]), o.calcNiceTicks();
          var l = new SNt("value", o, e.axisExtent, a);
          return l.model = i, l;
        }, t.prototype._createGroup = function(e) {
          var i = this[e] = new Ct();
          return this.group.add(i), i;
        }, t.prototype._renderAxisLine = function(e, i, r, a) {
          var o = r.getExtent();
          if (a.get(["lineStyle", "show"])) {
            var s = new Wn({ shape: { x1: o[0], y1: 0, x2: o[1], y2: 0 }, style: Y({ lineCap: "round" }, a.getModel("lineStyle").getLineStyle()), silent: true, z2: 1 });
            i.add(s);
            var l = this._progressLine = new Wn({ shape: { x1: o[0], x2: this._currentPointer ? this._currentPointer.x : o[0], y1: 0, y2: 0 }, style: Et({ lineCap: "round", lineWidth: s.style.lineWidth }, a.getModel(["progress", "lineStyle"]).getLineStyle()), silent: true, z2: 1 });
            i.add(l);
          }
        }, t.prototype._renderAxisTick = function(e, i, r, a) {
          var o = this, s = a.getData(), l = r.scale.getTicks();
          this._tickSymbols = [], M(l, function(u) {
            var h = r.dataToCoord(u.value), c = s.getItemModel(u.value), f = c.getModel("itemStyle"), g = c.getModel(["emphasis", "itemStyle"]), d = c.getModel(["progress", "itemStyle"]), A = { x: h, y: 0, onclick: ct(o._changeTimeline, o, u.value) }, p = HH(c, f, i, A);
            p.ensureState("emphasis").style = g.getItemStyle(), p.ensureState("progress").style = d.getItemStyle(), Bh(p);
            var v = Dt(p);
            c.get("tooltip") ? (v.dataIndex = u.value, v.dataModel = a) : v.dataIndex = v.dataModel = null, o._tickSymbols.push(p);
          });
        }, t.prototype._renderAxisLabel = function(e, i, r, a) {
          var o = this, s = r.getLabelModel();
          if (s.get("show")) {
            var l = a.getData(), u = r.getViewLabels();
            this._tickLabels = [], M(u, function(h) {
              var c = h.tickValue, f = l.getItemModel(c), g = f.getModel("label"), d = f.getModel(["emphasis", "label"]), A = f.getModel(["progress", "label"]), p = r.dataToCoord(h.tickValue), v = new ge({ x: p, y: 0, rotation: e.labelRotation - e.rotation, onclick: ct(o._changeTimeline, o, c), silent: false, style: Ke(g, { text: h.formattedLabel, align: e.labelAlign, verticalAlign: e.labelBaseline }) });
              v.ensureState("emphasis").style = Ke(d), v.ensureState("progress").style = Ke(A), i.add(v), Bh(v), qH(v).dataIndex = c, o._tickLabels.push(v);
            });
          }
        }, t.prototype._renderControl = function(e, i, r, a) {
          var o = e.controlSize, s = e.rotation, l = a.getModel("controlStyle").getItemStyle(), u = a.getModel(["emphasis", "controlStyle"]).getItemStyle(), h = a.getPlayState(), c = a.get("inverse", true);
          f(e.nextBtnPosition, "next", ct(this._changeTimeline, this, c ? "-" : "+")), f(e.prevBtnPosition, "prev", ct(this._changeTimeline, this, c ? "+" : "-")), f(e.playPosition, h ? "stop" : "play", ct(this._handlePlayClick, this, !h), true);
          function f(g, d, A, p) {
            if (g) {
              var v = ja(Pt(a.get(["controlStyle", d + "BtnSize"]), o), o), y = [0, -v / 2, v, v], m = MNt(a, d + "Icon", y, { x: g[0], y: g[1], originX: o / 2, originY: 0, rotation: p ? -s : 0, rectHover: true, style: l, onclick: A });
              m.ensureState("emphasis").style = u, i.add(m), Bh(m);
            }
          }
        }, t.prototype._renderCurrentPointer = function(e, i, r, a) {
          var o = a.getData(), s = a.getCurrentIndex(), l = o.getItemModel(s).getModel("checkpointStyle"), u = this, h = { onCreate: function(c) {
            c.draggable = true, c.drift = ct(u._handlePointerDrag, u), c.ondragend = ct(u._handlePointerDragend, u), YH(c, u._progressLine, s, r, a, true);
          }, onUpdate: function(c) {
            YH(c, u._progressLine, s, r, a);
          } };
          this._currentPointer = HH(l, l, this._mainGroup, {}, this._currentPointer, h);
        }, t.prototype._handlePlayClick = function(e) {
          this._clearTimer(), this.api.dispatchAction({ type: "timelinePlayChange", playState: e, from: this.uid });
        }, t.prototype._handlePointerDrag = function(e, i, r) {
          this._clearTimer(), this._pointerChangeTimeline([r.offsetX, r.offsetY]);
        }, t.prototype._handlePointerDragend = function(e) {
          this._pointerChangeTimeline([e.offsetX, e.offsetY], true);
        }, t.prototype._pointerChangeTimeline = function(e, i) {
          var r = this._toAxisCoord(e)[0], a = this._axis, o = ua(a.getExtent().slice());
          r > o[1] && (r = o[1]), r < o[0] && (r = o[0]), this._currentPointer.x = r, this._currentPointer.markRedraw();
          var s = this._progressLine;
          s && (s.shape.x2 = r, s.dirty());
          var l = this._findNearestTick(r), u = this.model;
          (i || l !== u.getCurrentIndex() && u.get("realtime")) && this._changeTimeline(l);
        }, t.prototype._doPlayStop = function() {
          var e = this;
          this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
            var i = e.model;
            e._changeTimeline(i.getCurrentIndex() + (i.get("rewind", true) ? -1 : 1));
          }, this.model.get("playInterval")));
        }, t.prototype._toAxisCoord = function(e) {
          var i = this._mainGroup.getLocalTransform();
          return Xa(e, i, true);
        }, t.prototype._findNearestTick = function(e) {
          var i = this.model.getData(), r = 1 / 0, a, o = this._axis;
          return i.each(["value"], function(s, l) {
            var u = o.dataToCoord(s), h = Math.abs(u - e);
            h < r && (r = h, a = l);
          }), a;
        }, t.prototype._clearTimer = function() {
          this._timer && (clearTimeout(this._timer), this._timer = null);
        }, t.prototype._changeTimeline = function(e) {
          var i = this.model.getCurrentIndex();
          e === "+" ? e = i + 1 : e === "-" && (e = i - 1), this.api.dispatchAction({ type: "timelineChange", currentIndex: e, from: this.uid });
        }, t.prototype._updateTicksStatus = function() {
          var e = this.model.getCurrentIndex(), i = this._tickSymbols, r = this._tickLabels;
          if (i) for (var a = 0; a < i.length; a++) i && i[a] && i[a].toggleState("progress", a < e);
          if (r) for (var a = 0; a < r.length; a++) r && r[a] && r[a].toggleState("progress", qH(r[a]).dataIndex <= e);
        }, t.type = "timeline.slider", t;
      }(CNt);
      function BNt(n, t) {
        if (t = t || n.get("type"), t) switch (t) {
          case "category":
            return new tI({ ordinalMeta: n.getCategories(), extent: [1 / 0, -1 / 0] });
          case "time":
            return new AT({ locale: n.ecModel.getLocaleModel(), useUTC: n.ecModel.get("useUTC") });
          default:
            return new Gs();
        }
      }
      function TNt(n, t) {
        return Gn(n.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() }, n.get("padding"));
      }
      function MNt(n, t, e, i) {
        var r = i.style, a = Hp(n.get(["controlStyle", t]), i || {}, new Ht(e[0], e[1], e[2], e[3]));
        return r && a.setStyle(r), a;
      }
      function HH(n, t, e, i, r, a) {
        var o = t.get("color");
        if (r) r.setColor(o), e.add(r), a && a.onUpdate(r);
        else {
          var s = n.get("symbol");
          r = Nn(s, -1, -1, 2, 2, o), r.setStyle("strokeNoScale", true), e.add(r), a && a.onCreate(r);
        }
        var l = t.getItemStyle(["color"]);
        r.setStyle(l), i = qt({ rectHover: true, z2: 100 }, i, true);
        var u = Vg(n.get("symbolSize"));
        i.scaleX = u[0] / 2, i.scaleY = u[1] / 2;
        var h = Uh(n.get("symbolOffset"), u);
        h && (i.x = (i.x || 0) + h[0], i.y = (i.y || 0) + h[1]);
        var c = n.get("symbolRotate");
        return i.rotation = (c || 0) * Math.PI / 180 || 0, r.attr(i), r.updateTransform(), r;
      }
      function YH(n, t, e, i, r, a) {
        if (!n.dragging) {
          var o = r.getModel("checkpointStyle"), s = i.dataToCoord(r.getData().get("value", e));
          if (a || !o.get("animation", true)) n.attr({ x: s, y: 0 }), t && t.attr({ shape: { x2: s } });
          else {
            var l = { duration: o.get("animationDuration", true), easing: o.get("animationEasing", true) };
            n.stopAnimation(null, true), n.animateTo({ x: s, y: 0 }, l), t && t.animateTo({ shape: { x2: s } }, l);
          }
        }
      }
      function DNt(n) {
        n.registerAction({ type: "timelineChange", event: "timelineChanged", update: "prepareAndUpdate" }, function(t, e, i) {
          var r = e.getComponent("timeline");
          return r && t.currentIndex != null && (r.setCurrentIndex(t.currentIndex), !r.get("loop", true) && r.isIndexMax() && r.getPlayState() && (r.setPlayState(false), i.dispatchAction({ type: "timelinePlayChange", playState: false, from: t.from }))), e.resetOption("timeline", { replaceMerge: r.get("replaceMerge", true) }), Et({ currentIndex: r.option.currentIndex }, t);
        }), n.registerAction({ type: "timelinePlayChange", event: "timelinePlayChanged", update: "update" }, function(t, e) {
          var i = e.getComponent("timeline");
          i && t.playState != null && i.setPlayState(t.playState);
        });
      }
      function RNt(n) {
        var t = n && n.timeline;
        X(t) || (t = t ? [t] : []), M(t, function(e) {
          e && LNt(e);
        });
      }
      function LNt(n) {
        var t = n.type, e = { number: "value", time: "time" };
        if (e[t] && (n.axisType = e[t], delete n.type), WH(n), gc(n, "controlPosition")) {
          var i = n.controlStyle || (n.controlStyle = {});
          gc(i, "position") || (i.position = n.controlPosition), i.position === "none" && !gc(i, "show") && (i.show = false, delete i.position), delete n.controlPosition;
        }
        M(n.data || [], function(r) {
          _t(r) && !X(r) && (!gc(r, "value") && gc(r, "name") && (r.value = r.name), WH(r));
        });
      }
      function WH(n) {
        var t = n.itemStyle || (n.itemStyle = {}), e = t.emphasis || (t.emphasis = {}), i = n.label || n.label || {}, r = i.normal || (i.normal = {}), a = { normal: 1, emphasis: 1 };
        M(i, function(o, s) {
          !a[s] && !gc(r, s) && (r[s] = o);
        }), e.label && !gc(i, "emphasis") && (i.emphasis = e.label, delete e.label);
      }
      function gc(n, t) {
        return n.hasOwnProperty(t);
      }
      function PNt(n) {
        n.registerComponentModel(jH), n.registerComponentView(bNt), n.registerSubTypeDefaulter("timeline", function() {
          return "slider";
        }), DNt(n), n.registerPreprocessor(RNt);
      }
      function iR(n, t) {
        if (!n) return false;
        for (var e = X(n) ? n : [n], i = 0; i < e.length; i++) if (e[i] && e[i][t]) return true;
        return false;
      }
      function eE(n) {
        dh(n, "label", ["show"]);
      }
      var nE = le(), Ys = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.createdBySelf = false, e;
        }
        return t.prototype.init = function(e, i, r) {
          if (this.type === "marker") throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
          this.mergeDefaultAndTheme(e, r), this._mergeOption(e, r, false, true);
        }, t.prototype.isAnimationEnabled = function() {
          if (ee.node) return false;
          var e = this.__hostSeries;
          return this.getShallow("animation") && e && e.isAnimationEnabled();
        }, t.prototype.mergeOption = function(e, i) {
          this._mergeOption(e, i, false, false);
        }, t.prototype._mergeOption = function(e, i, r, a) {
          var o = this.mainType;
          r || i.eachSeries(function(s) {
            var l = s.get(this.mainType, true), u = nE(s)[o];
            if (!l || !l.data) {
              nE(s)[o] = null;
              return;
            }
            u ? u._mergeOption(l, i, true) : (a && eE(l), M(l.data, function(h) {
              h instanceof Array ? (eE(h[0]), eE(h[1])) : eE(h);
            }), u = this.createMarkerModelFromSeries(l, this, i), Y(u, { mainType: this.mainType, seriesIndex: s.seriesIndex, name: s.name, createdBySelf: true }), u.__hostSeries = s), nE(s)[o] = u;
          }, this);
        }, t.prototype.formatTooltip = function(e, i, r) {
          var a = this.getData(), o = this.getRawValue(e), s = a.getName(e);
          return Zn("section", { header: this.name, blocks: [Zn("nameValue", { name: s, value: o, noName: !s, noValue: o == null })] });
        }, t.prototype.getData = function() {
          return this._data;
        }, t.prototype.setData = function(e) {
          this._data = e;
        }, t.prototype.getDataParams = function(e, i) {
          var r = T1.prototype.getDataParams.call(this, e, i), a = this.__hostSeries;
          return a && (r.seriesId = a.id, r.seriesName = a.name, r.seriesType = a.subType), r;
        }, t.getMarkerModelFromSeries = function(e, i) {
          return nE(e)[i];
        }, t.type = "marker", t.dependencies = ["series", "grid", "polar", "geo"], t;
      }(ne);
      Mn(Ys, T1.prototype);
      var NNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.createMarkerModelFromSeries = function(e, i, r) {
          return new t(e, i, r);
        }, t.type = "markPoint", t.defaultOption = { z: 5, symbol: "pin", symbolSize: 50, tooltip: { trigger: "item" }, label: { show: true, position: "inside" }, itemStyle: { borderWidth: 2 }, emphasis: { label: { show: true } } }, t;
      }(Ys);
      function rR(n) {
        return !(isNaN(parseFloat(n.x)) && isNaN(parseFloat(n.y)));
      }
      function kNt(n) {
        return !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
      }
      function iE(n, t, e, i, r, a) {
        var o = [], s = lu(t, i), l = s ? t.getCalculationInfo("stackResultDimension") : i, u = oR(t, l, n), h = t.indicesOfNearest(l, u)[0];
        o[r] = t.get(e, h), o[a] = t.get(l, h);
        var c = t.get(i, h), f = Mo(t.get(i, h));
        return f = Math.min(f, 20), f >= 0 && (o[a] = +o[a].toFixed(f)), [o, c];
      }
      var aR = { min: Ot(iE, "min"), max: Ot(iE, "max"), average: Ot(iE, "average"), median: Ot(iE, "median") };
      function ty(n, t) {
        if (t) {
          var e = n.getData(), i = n.coordinateSystem, r = i && i.dimensions;
          if (!kNt(t) && !X(t.coord) && X(r)) {
            var a = XH(t, e, i, n);
            if (t = xt(t), t.type && aR[t.type] && a.baseAxis && a.valueAxis) {
              var o = Wt(r, a.baseAxis.dim), s = Wt(r, a.valueAxis.dim), l = aR[t.type](e, a.baseDataDim, a.valueDataDim, o, s);
              t.coord = l[0], t.value = l[1];
            } else t.coord = [t.xAxis != null ? t.xAxis : t.radiusAxis, t.yAxis != null ? t.yAxis : t.angleAxis];
          }
          if (t.coord == null || !X(r)) t.coord = [];
          else for (var u = t.coord, h = 0; h < 2; h++) aR[u[h]] && (u[h] = oR(e, e.mapDimension(r[h]), u[h]));
          return t;
        }
      }
      function XH(n, t, e, i) {
        var r = {};
        return n.valueIndex != null || n.valueDim != null ? (r.valueDataDim = n.valueIndex != null ? t.getDimension(n.valueIndex) : n.valueDim, r.valueAxis = e.getAxis(FNt(i, r.valueDataDim)), r.baseAxis = e.getOtherAxis(r.valueAxis), r.baseDataDim = t.mapDimension(r.baseAxis.dim)) : (r.baseAxis = i.getBaseAxis(), r.valueAxis = e.getOtherAxis(r.baseAxis), r.baseDataDim = t.mapDimension(r.baseAxis.dim), r.valueDataDim = t.mapDimension(r.valueAxis.dim)), r;
      }
      function FNt(n, t) {
        var e = n.getData().getDimensionInfo(t);
        return e && e.coordDim;
      }
      function ey(n, t) {
        return n && n.containData && t.coord && !rR(t) ? n.containData(t.coord) : true;
      }
      function QNt(n, t, e) {
        return n && n.containZone && t.coord && e.coord && !rR(t) && !rR(e) ? n.containZone(t.coord, e.coord) : true;
      }
      function ZH(n, t) {
        return n ? function(e, i, r, a) {
          var o = a < 2 ? e.coord && e.coord[a] : e.value;
          return ru(o, t[a]);
        } : function(e, i, r, a) {
          return ru(e.value, t[a]);
        };
      }
      function oR(n, t, e) {
        if (e === "average") {
          var i = 0, r = 0;
          return n.each(t, function(a, o) {
            isNaN(a) || (i += a, r++);
          }), i / r;
        } else return e === "median" ? n.getMedian(t) : n.getDataExtent(t)[e === "max" ? 1 : 0];
      }
      var sR = le(), lR = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function() {
          this.markerGroupMap = dt();
        }, t.prototype.render = function(e, i, r) {
          var a = this, o = this.markerGroupMap;
          o.each(function(s) {
            sR(s).keep = false;
          }), i.eachSeries(function(s) {
            var l = Ys.getMarkerModelFromSeries(s, a.type);
            l && a.renderSeries(s, l, i, r);
          }), o.each(function(s) {
            !sR(s).keep && a.group.remove(s.group);
          });
        }, t.prototype.markKeep = function(e) {
          sR(e).keep = true;
        }, t.prototype.toggleBlurSeries = function(e, i) {
          var r = this;
          M(e, function(a) {
            var o = Ys.getMarkerModelFromSeries(a, r.type);
            if (o) {
              var s = o.getData();
              s.eachItemGraphicEl(function(l) {
                l && (i ? b5(l) : z2(l));
              });
            }
          });
        }, t.type = "marker", t;
      }(on);
      function KH(n, t, e) {
        var i = t.coordinateSystem;
        n.each(function(r) {
          var a = n.getItemModel(r), o, s = ot(a.get("x"), e.getWidth()), l = ot(a.get("y"), e.getHeight());
          if (!isNaN(s) && !isNaN(l)) o = [s, l];
          else if (t.getMarkerPosition) o = t.getMarkerPosition(n.getValues(n.dimensions, r));
          else if (i) {
            var u = n.get(i.dimensions[0], r), h = n.get(i.dimensions[1], r);
            o = i.dataToPoint([u, h]);
          }
          isNaN(s) || (o[0] = s), isNaN(l) || (o[1] = l), n.setItemLayout(r, o);
        });
      }
      var ONt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.updateTransform = function(e, i, r) {
          i.eachSeries(function(a) {
            var o = Ys.getMarkerModelFromSeries(a, "markPoint");
            o && (KH(o.getData(), a, r), this.markerGroupMap.get(a.id).updateLayout());
          }, this);
        }, t.prototype.renderSeries = function(e, i, r, a) {
          var o = e.coordinateSystem, s = e.id, l = e.getData(), u = this.markerGroupMap, h = u.get(s) || u.set(s, new Sv()), c = zNt(o, e, i);
          i.setData(c), KH(i.getData(), e, a), c.each(function(f) {
            var g = c.getItemModel(f), d = g.getShallow("symbol"), A = g.getShallow("symbolSize"), p = g.getShallow("symbolRotate"), v = g.getShallow("symbolOffset"), y = g.getShallow("symbolKeepAspect");
            if (yt(d) || yt(A) || yt(p) || yt(v)) {
              var m = i.getRawValue(f), _ = i.getDataParams(f);
              yt(d) && (d = d(m, _)), yt(A) && (A = A(m, _)), yt(p) && (p = p(m, _)), yt(v) && (v = v(m, _));
            }
            var E = g.getModel("itemStyle").getItemStyle(), I = lv(l, "color");
            E.fill || (E.fill = I), c.setItemVisual(f, { symbol: d, symbolSize: A, symbolRotate: p, symbolOffset: v, symbolKeepAspect: y, style: E });
          }), h.updateData(c), this.group.add(h.group), c.eachItemGraphicEl(function(f) {
            f.traverse(function(g) {
              Dt(g).dataModel = i;
            });
          }), this.markKeep(h), h.group.silent = i.get("silent") || e.get("silent");
        }, t.type = "markPoint", t;
      }(lR);
      function zNt(n, t, e) {
        var i;
        n ? i = Z(n && n.dimensions, function(s) {
          var l = t.getData().getDimensionInfo(t.getData().mapDimension(s)) || {};
          return Y(Y({}, l), { name: s, ordinalMeta: null });
        }) : i = [{ name: "value", type: "float" }];
        var r = new Zi(i, e), a = Z(e.get("data"), Ot(ty, t));
        n && (a = Ne(a, Ot(ey, n)));
        var o = ZH(!!n, i);
        return r.initData(a, null, o), r;
      }
      function GNt(n) {
        n.registerComponentModel(NNt), n.registerComponentView(ONt), n.registerPreprocessor(function(t) {
          iR(t.series, "markPoint") && (t.markPoint = t.markPoint || {});
        });
      }
      var UNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.createMarkerModelFromSeries = function(e, i, r) {
          return new t(e, i, r);
        }, t.type = "markLine", t.defaultOption = { z: 5, symbol: ["circle", "arrow"], symbolSize: [8, 16], symbolOffset: 0, precision: 2, tooltip: { trigger: "item" }, label: { show: true, position: "end", distance: 5 }, lineStyle: { type: "dashed" }, emphasis: { label: { show: true }, lineStyle: { width: 3 } }, animationEasing: "linear" }, t;
      }(Ys), rE = le(), VNt = function(n, t, e, i) {
        var r = n.getData(), a;
        if (X(i)) a = i;
        else {
          var o = i.type;
          if (o === "min" || o === "max" || o === "average" || o === "median" || i.xAxis != null || i.yAxis != null) {
            var s = void 0, l = void 0;
            if (i.yAxis != null || i.xAxis != null) s = t.getAxis(i.yAxis != null ? "y" : "x"), l = Dn(i.yAxis, i.xAxis);
            else {
              var u = XH(i, r, t, n);
              s = u.valueAxis;
              var h = tU(r, u.valueDataDim);
              l = oR(r, h, o);
            }
            var c = s.dim === "x" ? 0 : 1, f = 1 - c, g = xt(i), d = { coord: [] };
            g.type = null, g.coord = [], g.coord[f] = -1 / 0, d.coord[f] = 1 / 0;
            var A = e.get("precision");
            A >= 0 && pe(l) && (l = +l.toFixed(Math.min(A, 20))), g.coord[c] = d.coord[c] = l, a = [g, d, { type: o, valueIndex: i.valueIndex, value: l }];
          } else za("Invalid markLine data."), a = [];
        }
        var p = [ty(n, a[0]), ty(n, a[1]), Y({}, a[2])];
        return p[2].type = p[2].type || null, qt(p[2], p[0]), qt(p[2], p[1]), p;
      };
      function aE(n) {
        return !isNaN(n) && !isFinite(n);
      }
      function $H(n, t, e, i) {
        var r = 1 - n, a = i.dimensions[n];
        return aE(t[r]) && aE(e[r]) && t[n] === e[n] && i.getAxis(a).containData(t[n]);
      }
      function jNt(n, t) {
        if (n.type === "cartesian2d") {
          var e = t[0].coord, i = t[1].coord;
          if (e && i && ($H(1, e, i, n) || $H(0, e, i, n))) return true;
        }
        return ey(n, t[0]) && ey(n, t[1]);
      }
      function uR(n, t, e, i, r) {
        var a = i.coordinateSystem, o = n.getItemModel(t), s, l = ot(o.get("x"), r.getWidth()), u = ot(o.get("y"), r.getHeight());
        if (!isNaN(l) && !isNaN(u)) s = [l, u];
        else {
          if (i.getMarkerPosition) s = i.getMarkerPosition(n.getValues(n.dimensions, t));
          else {
            var h = a.dimensions, c = n.get(h[0], t), f = n.get(h[1], t);
            s = a.dataToPoint([c, f]);
          }
          if (tc(a, "cartesian2d")) {
            var g = a.getAxis("x"), d = a.getAxis("y"), h = a.dimensions;
            aE(n.get(h[0], t)) ? s[0] = g.toGlobalCoord(g.getExtent()[e ? 0 : 1]) : aE(n.get(h[1], t)) && (s[1] = d.toGlobalCoord(d.getExtent()[e ? 0 : 1]));
          }
          isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
        }
        n.setItemLayout(t, s);
      }
      var qNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.updateTransform = function(e, i, r) {
          i.eachSeries(function(a) {
            var o = Ys.getMarkerModelFromSeries(a, "markLine");
            if (o) {
              var s = o.getData(), l = rE(o).from, u = rE(o).to;
              l.each(function(h) {
                uR(l, h, true, a, r), uR(u, h, false, a, r);
              }), s.each(function(h) {
                s.setItemLayout(h, [l.getItemLayout(h), u.getItemLayout(h)]);
              }), this.markerGroupMap.get(a.id).updateLayout();
            }
          }, this);
        }, t.prototype.renderSeries = function(e, i, r, a) {
          var o = e.coordinateSystem, s = e.id, l = e.getData(), u = this.markerGroupMap, h = u.get(s) || u.set(s, new FM());
          this.group.add(h.group);
          var c = HNt(o, e, i), f = c.from, g = c.to, d = c.line;
          rE(i).from = f, rE(i).to = g, i.setData(d);
          var A = i.get("symbol"), p = i.get("symbolSize"), v = i.get("symbolRotate"), y = i.get("symbolOffset");
          X(A) || (A = [A, A]), X(p) || (p = [p, p]), X(v) || (v = [v, v]), X(y) || (y = [y, y]), c.from.each(function(_) {
            m(f, _, true), m(g, _, false);
          }), d.each(function(_) {
            var E = d.getItemModel(_).getModel("lineStyle").getLineStyle();
            d.setItemLayout(_, [f.getItemLayout(_), g.getItemLayout(_)]), E.stroke == null && (E.stroke = f.getItemVisual(_, "style").fill), d.setItemVisual(_, { fromSymbolKeepAspect: f.getItemVisual(_, "symbolKeepAspect"), fromSymbolOffset: f.getItemVisual(_, "symbolOffset"), fromSymbolRotate: f.getItemVisual(_, "symbolRotate"), fromSymbolSize: f.getItemVisual(_, "symbolSize"), fromSymbol: f.getItemVisual(_, "symbol"), toSymbolKeepAspect: g.getItemVisual(_, "symbolKeepAspect"), toSymbolOffset: g.getItemVisual(_, "symbolOffset"), toSymbolRotate: g.getItemVisual(_, "symbolRotate"), toSymbolSize: g.getItemVisual(_, "symbolSize"), toSymbol: g.getItemVisual(_, "symbol"), style: E });
          }), h.updateData(d), c.line.eachItemGraphicEl(function(_) {
            Dt(_).dataModel = i, _.traverse(function(E) {
              Dt(E).dataModel = i;
            });
          });
          function m(_, E, I) {
            var x = _.getItemModel(E);
            uR(_, E, I, e, a);
            var w = x.getModel("itemStyle").getItemStyle();
            w.fill == null && (w.fill = lv(l, "color")), _.setItemVisual(E, { symbolKeepAspect: x.get("symbolKeepAspect"), symbolOffset: Pt(x.get("symbolOffset", true), y[I ? 0 : 1]), symbolRotate: Pt(x.get("symbolRotate", true), v[I ? 0 : 1]), symbolSize: Pt(x.get("symbolSize"), p[I ? 0 : 1]), symbol: Pt(x.get("symbol", true), A[I ? 0 : 1]), style: w });
          }
          this.markKeep(h), h.group.silent = i.get("silent") || e.get("silent");
        }, t.type = "markLine", t;
      }(lR);
      function HNt(n, t, e) {
        var i;
        n ? i = Z(n && n.dimensions, function(u) {
          var h = t.getData().getDimensionInfo(t.getData().mapDimension(u)) || {};
          return Y(Y({}, h), { name: u, ordinalMeta: null });
        }) : i = [{ name: "value", type: "float" }];
        var r = new Zi(i, e), a = new Zi(i, e), o = new Zi([], e), s = Z(e.get("data"), Ot(VNt, t, n, e));
        n && (s = Ne(s, Ot(jNt, n)));
        var l = ZH(!!n, i);
        return r.initData(Z(s, function(u) {
          return u[0];
        }), null, l), a.initData(Z(s, function(u) {
          return u[1];
        }), null, l), o.initData(Z(s, function(u) {
          return u[2];
        })), o.hasItemOption = true, { from: r, to: a, line: o };
      }
      function YNt(n) {
        n.registerComponentModel(UNt), n.registerComponentView(qNt), n.registerPreprocessor(function(t) {
          iR(t.series, "markLine") && (t.markLine = t.markLine || {});
        });
      }
      var WNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.createMarkerModelFromSeries = function(e, i, r) {
          return new t(e, i, r);
        }, t.type = "markArea", t.defaultOption = { z: 1, tooltip: { trigger: "item" }, animation: false, label: { show: true, position: "top" }, itemStyle: { borderWidth: 0 }, emphasis: { label: { show: true, position: "top" } } }, t;
      }(Ys), oE = le(), XNt = function(n, t, e, i) {
        var r = i[0], a = i[1];
        if (!(!r || !a)) {
          var o = ty(n, r), s = ty(n, a), l = o.coord, u = s.coord;
          l[0] = Dn(l[0], -1 / 0), l[1] = Dn(l[1], -1 / 0), u[0] = Dn(u[0], 1 / 0), u[1] = Dn(u[1], 1 / 0);
          var h = gb([{}, o, s]);
          return h.coord = [o.coord, s.coord], h.x0 = o.x, h.y0 = o.y, h.x1 = s.x, h.y1 = s.y, h;
        }
      };
      function sE(n) {
        return !isNaN(n) && !isFinite(n);
      }
      function JH(n, t, e, i) {
        var r = 1 - n;
        return sE(t[r]) && sE(e[r]);
      }
      function ZNt(n, t) {
        var e = t.coord[0], i = t.coord[1], r = { coord: e, x: t.x0, y: t.y0 }, a = { coord: i, x: t.x1, y: t.y1 };
        return tc(n, "cartesian2d") ? e && i && (JH(1, e, i) || JH(0, e, i)) ? true : QNt(n, r, a) : ey(n, r) || ey(n, a);
      }
      function tY(n, t, e, i, r) {
        var a = i.coordinateSystem, o = n.getItemModel(t), s, l = ot(o.get(e[0]), r.getWidth()), u = ot(o.get(e[1]), r.getHeight());
        if (!isNaN(l) && !isNaN(u)) s = [l, u];
        else {
          if (i.getMarkerPosition) {
            var h = n.getValues(["x0", "y0"], t), c = n.getValues(["x1", "y1"], t), f = a.clampData(h), g = a.clampData(c), d = [];
            e[0] === "x0" ? d[0] = f[0] > g[0] ? c[0] : h[0] : d[0] = f[0] > g[0] ? h[0] : c[0], e[1] === "y0" ? d[1] = f[1] > g[1] ? c[1] : h[1] : d[1] = f[1] > g[1] ? h[1] : c[1], s = i.getMarkerPosition(d, e, true);
          } else {
            var A = n.get(e[0], t), p = n.get(e[1], t), v = [A, p];
            a.clampData && a.clampData(v, v), s = a.dataToPoint(v, true);
          }
          if (tc(a, "cartesian2d")) {
            var y = a.getAxis("x"), m = a.getAxis("y"), A = n.get(e[0], t), p = n.get(e[1], t);
            sE(A) ? s[0] = y.toGlobalCoord(y.getExtent()[e[0] === "x0" ? 0 : 1]) : sE(p) && (s[1] = m.toGlobalCoord(m.getExtent()[e[1] === "y0" ? 0 : 1]));
          }
          isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
        }
        return s;
      }
      var eY = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]], KNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.updateTransform = function(e, i, r) {
          i.eachSeries(function(a) {
            var o = Ys.getMarkerModelFromSeries(a, "markArea");
            if (o) {
              var s = o.getData();
              s.each(function(l) {
                var u = Z(eY, function(c) {
                  return tY(s, l, c, a, r);
                });
                s.setItemLayout(l, u);
                var h = s.getItemGraphicEl(l);
                h.setShape("points", u);
              });
            }
          }, this);
        }, t.prototype.renderSeries = function(e, i, r, a) {
          var o = e.coordinateSystem, s = e.id, l = e.getData(), u = this.markerGroupMap, h = u.get(s) || u.set(s, { group: new Ct() });
          this.group.add(h.group), this.markKeep(h);
          var c = $Nt(o, e, i);
          i.setData(c), c.each(function(f) {
            var g = Z(eY, function(w) {
              return tY(c, f, w, e, a);
            }), d = o.getAxis("x").scale, A = o.getAxis("y").scale, p = d.getExtent(), v = A.getExtent(), y = [d.parse(c.get("x0", f)), d.parse(c.get("x1", f))], m = [A.parse(c.get("y0", f)), A.parse(c.get("y1", f))];
            ua(y), ua(m);
            var _ = !(p[0] > y[1] || p[1] < y[0] || v[0] > m[1] || v[1] < m[0]), E = !_;
            c.setItemLayout(f, { points: g, allClipped: E });
            var I = c.getItemModel(f).getModel("itemStyle").getItemStyle(), x = lv(l, "color");
            I.fill || (I.fill = x, ht(I.fill) && (I.fill = w_(I.fill, 0.4))), I.stroke || (I.stroke = x), c.setItemVisual(f, "style", I);
          }), c.diff(oE(h).data).add(function(f) {
            var g = c.getItemLayout(f);
            if (!g.allClipped) {
              var d = new Yi({ shape: { points: g.points } });
              c.setItemGraphicEl(f, d), h.group.add(d);
            }
          }).update(function(f, g) {
            var d = oE(h).data.getItemGraphicEl(g), A = c.getItemLayout(f);
            A.allClipped ? d && h.group.remove(d) : (d ? _e(d, { shape: { points: A.points } }, i, f) : d = new Yi({ shape: { points: A.points } }), c.setItemGraphicEl(f, d), h.group.add(d));
          }).remove(function(f) {
            var g = oE(h).data.getItemGraphicEl(f);
            h.group.remove(g);
          }).execute(), c.eachItemGraphicEl(function(f, g) {
            var d = c.getItemModel(g), A = c.getItemVisual(g, "style");
            f.useStyle(c.getItemVisual(g, "style")), vi(f, Xn(d), { labelFetcher: i, labelDataIndex: g, defaultText: c.getName(g) || "", inheritColor: ht(A.fill) ? w_(A.fill, 1) : "#000" }), pi(f, d), hn(f, null, null, d.get(["emphasis", "disabled"])), Dt(f).dataModel = i;
          }), oE(h).data = c, h.group.silent = i.get("silent") || e.get("silent");
        }, t.type = "markArea", t;
      }(lR);
      function $Nt(n, t, e) {
        var i, r, a = ["x0", "y0", "x1", "y1"];
        if (n) {
          var o = Z(n && n.dimensions, function(u) {
            var h = t.getData(), c = h.getDimensionInfo(h.mapDimension(u)) || {};
            return Y(Y({}, c), { name: u, ordinalMeta: null });
          });
          r = Z(a, function(u, h) {
            return { name: u, type: o[h % 2].type };
          }), i = new Zi(r, e);
        } else r = [{ name: "value", type: "float" }], i = new Zi(r, e);
        var s = Z(e.get("data"), Ot(XNt, t, n, e));
        n && (s = Ne(s, Ot(ZNt, n)));
        var l = n ? function(u, h, c, f) {
          var g = u.coord[Math.floor(f / 2)][f % 2];
          return ru(g, r[f]);
        } : function(u, h, c, f) {
          return ru(u.value, r[f]);
        };
        return i.initData(s, null, l), i.hasItemOption = true, i;
      }
      function JNt(n) {
        n.registerComponentModel(WNt), n.registerComponentView(KNt), n.registerPreprocessor(function(t) {
          iR(t.series, "markArea") && (t.markArea = t.markArea || {});
        });
      }
      var tkt = function(n, t) {
        if (t === "all") return { type: "all", title: n.getLocaleModel().get(["legend", "selector", "all"]) };
        if (t === "inverse") return { type: "inverse", title: n.getLocaleModel().get(["legend", "selector", "inverse"]) };
      }, hR = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.layoutMode = { type: "box", ignoreSize: true }, e;
        }
        return t.prototype.init = function(e, i, r) {
          this.mergeDefaultAndTheme(e, r), e.selected = e.selected || {}, this._updateSelector(e);
        }, t.prototype.mergeOption = function(e, i) {
          n.prototype.mergeOption.call(this, e, i), this._updateSelector(e);
        }, t.prototype._updateSelector = function(e) {
          var i = e.selector, r = this.ecModel;
          i === true && (i = e.selector = ["all", "inverse"]), X(i) && M(i, function(a, o) {
            ht(a) && (a = { type: a }), i[o] = qt(a, tkt(r, a.type));
          });
        }, t.prototype.optionUpdated = function() {
          this._updateData(this.ecModel);
          var e = this._data;
          if (e[0] && this.get("selectedMode") === "single") {
            for (var i = false, r = 0; r < e.length; r++) {
              var a = e[r].get("name");
              if (this.isSelected(a)) {
                this.select(a), i = true;
                break;
              }
            }
            !i && this.select(e[0].get("name"));
          }
        }, t.prototype._updateData = function(e) {
          var i = [], r = [];
          e.eachRawSeries(function(l) {
            var u = l.name;
            r.push(u);
            var h;
            if (l.legendVisualProvider) {
              var c = l.legendVisualProvider, f = c.getAllNames();
              e.isSeriesFiltered(l) || (r = r.concat(f)), f.length ? i = i.concat(f) : h = true;
            } else h = true;
            h && d2(l) && i.push(l.name);
          }), this._availableNames = r;
          var a = this.get("data") || i, o = dt(), s = Z(a, function(l) {
            return (ht(l) || pe(l)) && (l = { name: l }), o.get(l.name) ? null : (o.set(l.name, true), new Te(l, this, this.ecModel));
          }, this);
          this._data = Ne(s, function(l) {
            return !!l;
          });
        }, t.prototype.getData = function() {
          return this._data;
        }, t.prototype.select = function(e) {
          var i = this.option.selected, r = this.get("selectedMode");
          if (r === "single") {
            var a = this._data;
            M(a, function(o) {
              i[o.get("name")] = false;
            });
          }
          i[e] = true;
        }, t.prototype.unSelect = function(e) {
          this.get("selectedMode") !== "single" && (this.option.selected[e] = false);
        }, t.prototype.toggleSelected = function(e) {
          var i = this.option.selected;
          i.hasOwnProperty(e) || (i[e] = true), this[i[e] ? "unSelect" : "select"](e);
        }, t.prototype.allSelect = function() {
          var e = this._data, i = this.option.selected;
          M(e, function(r) {
            i[r.get("name", true)] = true;
          });
        }, t.prototype.inverseSelect = function() {
          var e = this._data, i = this.option.selected;
          M(e, function(r) {
            var a = r.get("name", true);
            i.hasOwnProperty(a) || (i[a] = true), i[a] = !i[a];
          });
        }, t.prototype.isSelected = function(e) {
          var i = this.option.selected;
          return !(i.hasOwnProperty(e) && !i[e]) && Wt(this._availableNames, e) >= 0;
        }, t.prototype.getOrient = function() {
          return this.get("orient") === "vertical" ? { index: 1, name: "vertical" } : { index: 0, name: "horizontal" };
        }, t.type = "legend.plain", t.dependencies = ["series"], t.defaultOption = { z: 4, show: true, orient: "horizontal", left: "center", top: 0, align: "auto", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderRadius: 0, borderWidth: 0, padding: 5, itemGap: 10, itemWidth: 25, itemHeight: 14, symbolRotate: "inherit", symbolKeepAspect: true, inactiveColor: "#ccc", inactiveBorderColor: "#ccc", inactiveBorderWidth: "auto", itemStyle: { color: "inherit", opacity: "inherit", borderColor: "inherit", borderWidth: "auto", borderCap: "inherit", borderJoin: "inherit", borderDashOffset: "inherit", borderMiterLimit: "inherit" }, lineStyle: { width: "auto", color: "inherit", inactiveColor: "#ccc", inactiveWidth: 2, opacity: "inherit", type: "inherit", cap: "inherit", join: "inherit", dashOffset: "inherit", miterLimit: "inherit" }, textStyle: { color: "#333" }, selectedMode: true, selector: false, selectorLabel: { show: true, borderRadius: 10, padding: [3, 5, 3, 5], fontSize: 12, fontFamily: "sans-serif", color: "#666", borderWidth: 1, borderColor: "#666" }, emphasis: { selectorLabel: { show: true, color: "#eee", backgroundColor: "#666" } }, selectorPosition: "auto", selectorItemGap: 7, selectorButtonGap: 10, tooltip: { show: false } }, t;
      }(ne), gd = Ot, cR = M, lE = Ct, nY = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.newlineDisabled = false, e;
        }
        return t.prototype.init = function() {
          this.group.add(this._contentGroup = new lE()), this.group.add(this._selectorGroup = new lE()), this._isFirstRender = true;
        }, t.prototype.getContentGroup = function() {
          return this._contentGroup;
        }, t.prototype.getSelectorGroup = function() {
          return this._selectorGroup;
        }, t.prototype.render = function(e, i, r) {
          var a = this._isFirstRender;
          if (this._isFirstRender = false, this.resetInner(), !!e.get("show", true)) {
            var o = e.get("align"), s = e.get("orient");
            (!o || o === "auto") && (o = e.get("left") === "right" && s === "vertical" ? "right" : "left");
            var l = e.get("selector", true), u = e.get("selectorPosition", true);
            l && (!u || u === "auto") && (u = s === "horizontal" ? "end" : "start"), this.renderInner(o, e, i, r, l, s, u);
            var h = e.getBoxLayoutParams(), c = { width: r.getWidth(), height: r.getHeight() }, f = e.get("padding"), g = Gn(h, c, f), d = this.layoutInner(e, o, g, a, l, u), A = Gn(Et({ width: d.width, height: d.height }, h), c, f);
            this.group.x = A.x - d.x, this.group.y = A.y - d.y, this.group.markRedraw(), this.group.add(this._backgroundEl = cH(d, e));
          }
        }, t.prototype.resetInner = function() {
          this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
        }, t.prototype.renderInner = function(e, i, r, a, o, s, l) {
          var u = this.getContentGroup(), h = dt(), c = i.get("selectedMode"), f = [];
          r.eachRawSeries(function(g) {
            !g.get("legendHoverLink") && f.push(g.id);
          }), cR(i.getData(), function(g, d) {
            var A = g.get("name");
            if (!this.newlineDisabled && (A === "" || A === `
`)) {
              var p = new lE();
              p.newline = true, u.add(p);
              return;
            }
            var v = r.getSeriesByName(A)[0];
            if (!h.get(A)) {
              if (v) {
                var y = v.getData(), m = y.getVisual("legendLineStyle") || {}, _ = y.getVisual("legendIcon"), E = y.getVisual("style"), I = this._createItem(v, A, d, g, i, e, m, E, _, c, a);
                I.on("click", gd(iY, A, null, a, f)).on("mouseover", gd(fR, v.name, null, a, f)).on("mouseout", gd(gR, v.name, null, a, f)), r.ssr && I.eachChild(function(x) {
                  var w = Dt(x);
                  w.seriesIndex = v.seriesIndex, w.dataIndex = d, w.ssrType = "legend";
                }), h.set(A, true);
              } else r.eachRawSeries(function(x) {
                if (!h.get(A) && x.legendVisualProvider) {
                  var w = x.legendVisualProvider;
                  if (!w.containName(A)) return;
                  var C = w.indexOfName(A), S = w.getItemVisual(C, "style"), b = w.getItemVisual(C, "legendIcon"), B = Or(S.fill);
                  B && B[3] === 0 && (B[3] = 0.2, S = Y(Y({}, S), { fill: bs(B, "rgba") }));
                  var T = this._createItem(x, A, d, g, i, e, {}, S, b, c, a);
                  T.on("click", gd(iY, null, A, a, f)).on("mouseover", gd(fR, null, A, a, f)).on("mouseout", gd(gR, null, A, a, f)), r.ssr && T.eachChild(function(D) {
                    var R = Dt(D);
                    R.seriesIndex = x.seriesIndex, R.dataIndex = d, R.ssrType = "legend";
                  }), h.set(A, true);
                }
              }, this);
              h.get(A);
            }
          }, this), o && this._createSelector(o, i, a, s, l);
        }, t.prototype._createSelector = function(e, i, r, a, o) {
          var s = this.getSelectorGroup();
          cR(e, function(u) {
            var h = u.type, c = new ge({ style: { x: 0, y: 0, align: "center", verticalAlign: "middle" }, onclick: function() {
              r.dispatchAction({ type: h === "all" ? "legendAllSelect" : "legendInverseSelect" });
            } });
            s.add(c);
            var f = i.getModel("selectorLabel"), g = i.getModel(["emphasis", "selectorLabel"]);
            vi(c, { normal: f, emphasis: g }, { defaultText: u.title }), Bh(c);
          });
        }, t.prototype._createItem = function(e, i, r, a, o, s, l, u, h, c, f) {
          var g = e.visualDrawType, d = o.get("itemWidth"), A = o.get("itemHeight"), p = o.isSelected(i), v = a.get("symbolRotate"), y = a.get("symbolKeepAspect"), m = a.get("icon");
          h = m || h || "roundRect";
          var _ = ekt(h, a, l, u, g, p, f), E = new lE(), I = a.getModel("textStyle");
          if (yt(e.getLegendIcon) && (!m || m === "inherit")) E.add(e.getLegendIcon({ itemWidth: d, itemHeight: A, icon: h, iconRotate: v, itemStyle: _.itemStyle, lineStyle: _.lineStyle, symbolKeepAspect: y }));
          else {
            var x = m === "inherit" && e.getData().getVisual("symbol") ? v === "inherit" ? e.getData().getVisual("symbolRotate") : v : 0;
            E.add(nkt({ itemWidth: d, itemHeight: A, icon: h, iconRotate: x, itemStyle: _.itemStyle, lineStyle: _.lineStyle, symbolKeepAspect: y }));
          }
          var w = s === "left" ? d + 5 : -5, C = s, S = o.get("formatter"), b = i;
          ht(S) && S ? b = S.replace("{name}", i != null ? i : "") : yt(S) && (b = S(i));
          var B = p ? I.getTextColor() : a.get("inactiveColor");
          E.add(new ge({ style: Ke(I, { text: b, x: w, y: A / 2, fill: B, align: C, verticalAlign: "middle" }, { inheritColor: B }) }));
          var T = new ue({ shape: E.getBoundingRect(), style: { fill: "transparent" } }), D = a.getModel("tooltip");
          return D.get("show") && bg({ el: T, componentModel: o, itemName: i, itemTooltipOption: D.option }), E.add(T), E.eachChild(function(R) {
            R.silent = true;
          }), T.silent = !c, this.getContentGroup().add(E), Bh(E), E.__legendDataIndex = r, E;
        }, t.prototype.layoutInner = function(e, i, r, a, o, s) {
          var l = this.getContentGroup(), u = this.getSelectorGroup();
          Fh(e.get("orient"), l, e.get("itemGap"), r.width, r.height);
          var h = l.getBoundingRect(), c = [-h.x, -h.y];
          if (u.markRedraw(), l.markRedraw(), o) {
            Fh("horizontal", u, e.get("selectorItemGap", true));
            var f = u.getBoundingRect(), g = [-f.x, -f.y], d = e.get("selectorButtonGap", true), A = e.getOrient().index, p = A === 0 ? "width" : "height", v = A === 0 ? "height" : "width", y = A === 0 ? "y" : "x";
            s === "end" ? g[A] += h[p] + d : c[A] += f[p] + d, g[1 - A] += h[v] / 2 - f[v] / 2, u.x = g[0], u.y = g[1], l.x = c[0], l.y = c[1];
            var m = { x: 0, y: 0 };
            return m[p] = h[p] + d + f[p], m[v] = Math.max(h[v], f[v]), m[y] = Math.min(0, f[y] + g[1 - A]), m;
          } else return l.x = c[0], l.y = c[1], this.group.getBoundingRect();
        }, t.prototype.remove = function() {
          this.getContentGroup().removeAll(), this._isFirstRender = true;
        }, t.type = "legend.plain", t;
      }(on);
      function ekt(n, t, e, i, r, a, o) {
        function s(p, v) {
          p.lineWidth === "auto" && (p.lineWidth = v.lineWidth > 0 ? 2 : 0), cR(p, function(y, m) {
            p[m] === "inherit" && (p[m] = v[m]);
          });
        }
        var l = t.getModel("itemStyle"), u = l.getItemStyle(), h = n.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", c = l.getShallow("decal");
        u.decal = !c || c === "inherit" ? i.decal : qg(c, o), u.fill === "inherit" && (u.fill = i[r]), u.stroke === "inherit" && (u.stroke = i[h]), u.opacity === "inherit" && (u.opacity = (r === "fill" ? i : e).opacity), s(u, i);
        var f = t.getModel("lineStyle"), g = f.getLineStyle();
        if (s(g, e), u.fill === "auto" && (u.fill = i.fill), u.stroke === "auto" && (u.stroke = i.fill), g.stroke === "auto" && (g.stroke = i.fill), !a) {
          var d = t.get("inactiveBorderWidth"), A = u[h];
          u.lineWidth = d === "auto" ? i.lineWidth > 0 && A ? 2 : 0 : u.lineWidth, u.fill = t.get("inactiveColor"), u.stroke = t.get("inactiveBorderColor"), g.stroke = f.get("inactiveColor"), g.lineWidth = f.get("inactiveWidth");
        }
        return { itemStyle: u, lineStyle: g };
      }
      function nkt(n) {
        var t = n.icon || "roundRect", e = Nn(t, 0, 0, n.itemWidth, n.itemHeight, n.itemStyle.fill, n.symbolKeepAspect);
        return e.setStyle(n.itemStyle), e.rotation = (n.iconRotate || 0) * Math.PI / 180, e.setOrigin([n.itemWidth / 2, n.itemHeight / 2]), t.indexOf("empty") > -1 && (e.style.stroke = e.style.fill, e.style.fill = "#fff", e.style.lineWidth = 2), e;
      }
      function iY(n, t, e, i) {
        gR(n, t, e, i), e.dispatchAction({ type: "legendToggleSelect", name: n != null ? n : t }), fR(n, t, e, i);
      }
      function rY(n) {
        for (var t = n.getZr().storage.getDisplayList(), e, i = 0, r = t.length; i < r && !(e = t[i].states.emphasis); ) i++;
        return e && e.hoverLayer;
      }
      function fR(n, t, e, i) {
        rY(e) || e.dispatchAction({ type: "highlight", seriesName: n, name: t, excludeSeriesId: i });
      }
      function gR(n, t, e, i) {
        rY(e) || e.dispatchAction({ type: "downplay", seriesName: n, name: t, excludeSeriesId: i });
      }
      function ikt(n) {
        var t = n.findComponents({ mainType: "legend" });
        t && t.length && n.filterSeries(function(e) {
          for (var i = 0; i < t.length; i++) if (!t[i].isSelected(e.name)) return false;
          return true;
        });
      }
      function ny(n, t, e) {
        var i = {}, r = n === "toggleSelected", a;
        return e.eachComponent("legend", function(o) {
          r && a != null ? o[a ? "select" : "unSelect"](t.name) : n === "allSelect" || n === "inverseSelect" ? o[n]() : (o[n](t.name), a = o.isSelected(t.name));
          var s = o.getData();
          M(s, function(l) {
            var u = l.get("name");
            if (!(u === `
` || u === "")) {
              var h = o.isSelected(u);
              i.hasOwnProperty(u) ? i[u] = i[u] && h : i[u] = h;
            }
          });
        }), n === "allSelect" || n === "inverseSelect" ? { selected: i } : { name: t.name, selected: i };
      }
      function rkt(n) {
        n.registerAction("legendToggleSelect", "legendselectchanged", Ot(ny, "toggleSelected")), n.registerAction("legendAllSelect", "legendselectall", Ot(ny, "allSelect")), n.registerAction("legendInverseSelect", "legendinverseselect", Ot(ny, "inverseSelect")), n.registerAction("legendSelect", "legendselected", Ot(ny, "select")), n.registerAction("legendUnSelect", "legendunselected", Ot(ny, "unSelect"));
      }
      function aY(n) {
        n.registerComponentModel(hR), n.registerComponentView(nY), n.registerProcessor(n.PRIORITY.PROCESSOR.SERIES_FILTER, ikt), n.registerSubTypeDefaulter("legend", function() {
          return "plain";
        }), rkt(n);
      }
      var akt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.setScrollDataIndex = function(e) {
          this.option.scrollDataIndex = e;
        }, t.prototype.init = function(e, i, r) {
          var a = Pg(e);
          n.prototype.init.call(this, e, i, r), oY(this, e, a);
        }, t.prototype.mergeOption = function(e, i) {
          n.prototype.mergeOption.call(this, e, i), oY(this, this.option, e);
        }, t.type = "legend.scroll", t.defaultOption = eu(hR.defaultOption, { scrollDataIndex: 0, pageButtonItemGap: 5, pageButtonGap: null, pageButtonPosition: "end", pageFormatter: "{current}/{total}", pageIcons: { horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"], vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"] }, pageIconColor: "#2f4554", pageIconInactiveColor: "#aaa", pageIconSize: 15, pageTextStyle: { color: "#333" }, animationDurationUpdate: 800 }), t;
      }(hR);
      function oY(n, t, e) {
        var i = n.getOrient(), r = [1, 1];
        r[i.index] = 0, iu(t, e, { type: "box", ignoreSize: !!r });
      }
      var sY = Ct, dR = ["width", "height"], AR = ["x", "y"], okt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.newlineDisabled = true, e._currentIndex = 0, e;
        }
        return t.prototype.init = function() {
          n.prototype.init.call(this), this.group.add(this._containerGroup = new sY()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new sY());
        }, t.prototype.resetInner = function() {
          n.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
        }, t.prototype.renderInner = function(e, i, r, a, o, s, l) {
          var u = this;
          n.prototype.renderInner.call(this, e, i, r, a, o, s, l);
          var h = this._controllerGroup, c = i.get("pageIconSize", true), f = X(c) ? c : [c, c];
          d("pagePrev", 0);
          var g = i.getModel("pageTextStyle");
          h.add(new ge({ name: "pageText", style: { text: "xx/xx", fill: g.getTextColor(), font: g.getFont(), verticalAlign: "middle", align: "center" }, silent: true })), d("pageNext", 1);
          function d(A, p) {
            var v = A + "DataIndex", y = Hp(i.get("pageIcons", true)[i.getOrient().name][p], { onclick: ct(u._pageGo, u, v, i, a) }, { x: -f[0] / 2, y: -f[1] / 2, width: f[0], height: f[1] });
            y.name = A, h.add(y);
          }
        }, t.prototype.layoutInner = function(e, i, r, a, o, s) {
          var l = this.getSelectorGroup(), u = e.getOrient().index, h = dR[u], c = AR[u], f = dR[1 - u], g = AR[1 - u];
          o && Fh("horizontal", l, e.get("selectorItemGap", true));
          var d = e.get("selectorButtonGap", true), A = l.getBoundingRect(), p = [-A.x, -A.y], v = xt(r);
          o && (v[h] = r[h] - A[h] - d);
          var y = this._layoutContentAndController(e, a, v, u, h, f, g, c);
          if (o) {
            if (s === "end") p[u] += y[h] + d;
            else {
              var m = A[h] + d;
              p[u] -= m, y[c] -= m;
            }
            y[h] += A[h] + d, p[1 - u] += y[g] + y[f] / 2 - A[f] / 2, y[f] = Math.max(y[f], A[f]), y[g] = Math.min(y[g], A[g] + p[1 - u]), l.x = p[0], l.y = p[1], l.markRedraw();
          }
          return y;
        }, t.prototype._layoutContentAndController = function(e, i, r, a, o, s, l, u) {
          var h = this.getContentGroup(), c = this._containerGroup, f = this._controllerGroup;
          Fh(e.get("orient"), h, e.get("itemGap"), a ? r.width : null, a ? null : r.height), Fh("horizontal", f, e.get("pageButtonItemGap", true));
          var g = h.getBoundingRect(), d = f.getBoundingRect(), A = this._showController = g[o] > r[o], p = [-g.x, -g.y];
          i || (p[a] = h[u]);
          var v = [0, 0], y = [-d.x, -d.y], m = Pt(e.get("pageButtonGap", true), e.get("itemGap", true));
          if (A) {
            var _ = e.get("pageButtonPosition", true);
            _ === "end" ? y[a] += r[o] - d[o] : v[a] += d[o] + m;
          }
          y[1 - a] += g[s] / 2 - d[s] / 2, h.setPosition(p), c.setPosition(v), f.setPosition(y);
          var E = { x: 0, y: 0 };
          if (E[o] = A ? r[o] : g[o], E[s] = Math.max(g[s], d[s]), E[l] = Math.min(0, d[l] + y[1 - a]), c.__rectSize = r[o], A) {
            var I = { x: 0, y: 0 };
            I[o] = Math.max(r[o] - d[o] - m, 0), I[s] = E[s], c.setClipPath(new ue({ shape: I })), c.__rectSize = I[o];
          } else f.eachChild(function(w) {
            w.attr({ invisible: true, silent: true });
          });
          var x = this._getPageInfo(e);
          return x.pageIndex != null && _e(h, { x: x.contentPosition[0], y: x.contentPosition[1] }, A ? e : null), this._updatePageInfoView(e, x), E;
        }, t.prototype._pageGo = function(e, i, r) {
          var a = this._getPageInfo(i)[e];
          a != null && r.dispatchAction({ type: "legendScroll", scrollDataIndex: a, legendId: i.id });
        }, t.prototype._updatePageInfoView = function(e, i) {
          var r = this._controllerGroup;
          M(["pagePrev", "pageNext"], function(h) {
            var c = h + "DataIndex", f = i[c] != null, g = r.childOfName(h);
            g && (g.setStyle("fill", f ? e.get("pageIconColor", true) : e.get("pageIconInactiveColor", true)), g.cursor = f ? "pointer" : "default");
          });
          var a = r.childOfName("pageText"), o = e.get("pageFormatter"), s = i.pageIndex, l = s != null ? s + 1 : 0, u = i.pageCount;
          a && o && a.setStyle("text", ht(o) ? o.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : o({ current: l, total: u }));
        }, t.prototype._getPageInfo = function(e) {
          var i = e.get("scrollDataIndex", true), r = this.getContentGroup(), a = this._containerGroup.__rectSize, o = e.getOrient().index, s = dR[o], l = AR[o], u = this._findTargetItemIndex(i), h = r.children(), c = h[u], f = h.length, g = f ? 1 : 0, d = { contentPosition: [r.x, r.y], pageCount: g, pageIndex: g - 1, pagePrevDataIndex: null, pageNextDataIndex: null };
          if (!c) return d;
          var A = _(c);
          d.contentPosition[o] = -A.s;
          for (var p = u + 1, v = A, y = A, m = null; p <= f; ++p) m = _(h[p]), (!m && y.e > v.s + a || m && !E(m, v.s)) && (y.i > v.i ? v = y : v = m, v && (d.pageNextDataIndex == null && (d.pageNextDataIndex = v.i), ++d.pageCount)), y = m;
          for (var p = u - 1, v = A, y = A, m = null; p >= -1; --p) m = _(h[p]), (!m || !E(y, m.s)) && v.i < y.i && (y = v, d.pagePrevDataIndex == null && (d.pagePrevDataIndex = v.i), ++d.pageCount, ++d.pageIndex), v = m;
          return d;
          function _(I) {
            if (I) {
              var x = I.getBoundingRect(), w = x[l] + I[l];
              return { s: w, e: w + x[s], i: I.__legendDataIndex };
            }
          }
          function E(I, x) {
            return I.e >= x && I.s <= x + a;
          }
        }, t.prototype._findTargetItemIndex = function(e) {
          if (!this._showController) return 0;
          var i, r = this.getContentGroup(), a;
          return r.eachChild(function(o, s) {
            var l = o.__legendDataIndex;
            a == null && l != null && (a = s), l === e && (i = s);
          }), i != null ? i : a;
        }, t.type = "legend.scroll", t;
      }(nY);
      function skt(n) {
        n.registerAction("legendScroll", "legendscroll", function(t, e) {
          var i = t.scrollDataIndex;
          i != null && e.eachComponent({ mainType: "legend", subType: "scroll", query: t }, function(r) {
            r.setScrollDataIndex(i);
          });
        });
      }
      function lkt(n) {
        Zt(aY), n.registerComponentModel(akt), n.registerComponentView(okt), skt(n);
      }
      function ukt(n) {
        Zt(aY), Zt(lkt);
      }
      var hkt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "dataZoom.inside", t.defaultOption = eu(Kv.defaultOption, { disabled: false, zoomLock: false, zoomOnMouseWheel: true, moveOnMouseMove: true, moveOnMouseWheel: false, preventDefaultMouseMove: true }), t;
      }(Kv), pR = le();
      function ckt(n, t, e) {
        pR(n).coordSysRecordMap.each(function(i) {
          var r = i.dataZoomInfoMap.get(t.uid);
          r && (r.getRange = e);
        });
      }
      function fkt(n, t) {
        for (var e = pR(n).coordSysRecordMap, i = e.keys(), r = 0; r < i.length; r++) {
          var a = i[r], o = e.get(a), s = o.dataZoomInfoMap;
          if (s) {
            var l = t.uid, u = s.get(l);
            u && (s.removeKey(l), s.keys().length || lY(e, o));
          }
        }
      }
      function lY(n, t) {
        if (t) {
          n.removeKey(t.model.uid);
          var e = t.controller;
          e && e.dispose();
        }
      }
      function gkt(n, t) {
        var e = { model: t, containsPoint: Ot(Akt, t), dispatchAction: Ot(dkt, n), dataZoomInfoMap: null, controller: null }, i = e.controller = new Pv(n.getZr());
        return M(["pan", "zoom", "scrollMove"], function(r) {
          i.on(r, function(a) {
            var o = [];
            e.dataZoomInfoMap.each(function(s) {
              if (a.isAvailableBehavior(s.model.option)) {
                var l = (s.getRange || {})[r], u = l && l(s.dzReferCoordSysInfo, e.model.mainType, e.controller, a);
                !s.model.get("disabled", true) && u && o.push({ dataZoomId: s.model.id, start: u[0], end: u[1] });
              }
            }), o.length && e.dispatchAction(o);
          });
        }), e;
      }
      function dkt(n, t) {
        n.isDisposed() || n.dispatchAction({ type: "dataZoom", animation: { easing: "cubicOut", duration: 100 }, batch: t });
      }
      function Akt(n, t, e, i) {
        return n.coordinateSystem.containPoint([e, i]);
      }
      function pkt(n) {
        var t, e = "type_", i = { type_true: 2, type_move: 1, type_false: 0, type_undefined: -1 }, r = true;
        return n.each(function(a) {
          var o = a.model, s = o.get("disabled", true) ? false : o.get("zoomLock", true) ? "move" : true;
          i[e + s] > i[e + t] && (t = s), r = r && o.get("preventDefaultMouseMove", true);
        }), { controlType: t, opt: { zoomOnMouseWheel: true, moveOnMouseMove: true, moveOnMouseWheel: true, preventDefaultMouseMove: !!r } };
      }
      function vkt(n) {
        n.registerProcessor(n.PRIORITY.PROCESSOR.FILTER, function(t, e) {
          var i = pR(e), r = i.coordSysRecordMap || (i.coordSysRecordMap = dt());
          r.each(function(a) {
            a.dataZoomInfoMap = null;
          }), t.eachComponent({ mainType: "dataZoom", subType: "inside" }, function(a) {
            var o = aH(a);
            M(o.infoList, function(s) {
              var l = s.model.uid, u = r.get(l) || r.set(l, gkt(e, s.model)), h = u.dataZoomInfoMap || (u.dataZoomInfoMap = dt());
              h.set(a.uid, { dzReferCoordSysInfo: s, model: a, getRange: null });
            });
          }), r.each(function(a) {
            var o = a.controller, s, l = a.dataZoomInfoMap;
            if (l) {
              var u = l.keys()[0];
              u != null && (s = l.get(u));
            }
            if (!s) {
              lY(r, a);
              return;
            }
            var h = pkt(l);
            o.enable(h.controlType, h.opt), o.setPointerChecker(a.containsPoint), Gg(a, "dispatchAction", s.model.get("throttle", true), "fixRate");
          });
        });
      }
      var ykt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "dataZoom.inside", e;
        }
        return t.prototype.render = function(e, i, r) {
          if (n.prototype.render.apply(this, arguments), e.noTarget()) {
            this._clear();
            return;
          }
          this.range = e.getPercentRange(), ckt(r, e, { pan: ct(vR.pan, this), zoom: ct(vR.zoom, this), scrollMove: ct(vR.scrollMove, this) });
        }, t.prototype.dispose = function() {
          this._clear(), n.prototype.dispose.apply(this, arguments);
        }, t.prototype._clear = function() {
          fkt(this.api, this.dataZoomModel), this.range = null;
        }, t.type = "dataZoom.inside", t;
      }(VD), vR = { zoom: function(n, t, e, i) {
        var r = this.range, a = r.slice(), o = n.axisModels[0];
        if (o) {
          var s = yR[t](null, [i.originX, i.originY], o, e, n), l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (a[1] - a[0]) + a[0], u = Math.max(1 / i.scale, 0);
          a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l;
          var h = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
          if (lc(0, a, [0, 100], 0, h.minSpan, h.maxSpan), this.range = a, r[0] !== a[0] || r[1] !== a[1]) return a;
        }
      }, pan: uY(function(n, t, e, i, r, a) {
        var o = yR[i]([a.oldX, a.oldY], [a.newX, a.newY], t, r, e);
        return o.signal * (n[1] - n[0]) * o.pixel / o.pixelLength;
      }), scrollMove: uY(function(n, t, e, i, r, a) {
        var o = yR[i]([0, 0], [a.scrollDelta, a.scrollDelta], t, r, e);
        return o.signal * (n[1] - n[0]) * a.scrollDelta;
      }) };
      function uY(n) {
        return function(t, e, i, r) {
          var a = this.range, o = a.slice(), s = t.axisModels[0];
          if (s) {
            var l = n(o, s, t, e, i, r);
            if (lc(l, o, [0, 100], "all"), this.range = o, a[0] !== o[0] || a[1] !== o[1]) return o;
          }
        };
      }
      var yR = { grid: function(n, t, e, i, r) {
        var a = e.axis, o = {}, s = r.model.coordinateSystem.getRect();
        return n = n || [0, 0], a.dim === "x" ? (o.pixel = t[0] - n[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = a.inverse ? 1 : -1) : (o.pixel = t[1] - n[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = a.inverse ? -1 : 1), o;
      }, polar: function(n, t, e, i, r) {
        var a = e.axis, o = {}, s = r.model.coordinateSystem, l = s.getRadiusAxis().getExtent(), u = s.getAngleAxis().getExtent();
        return n = n ? s.pointToCoord(n) : [0, 0], t = s.pointToCoord(t), e.mainType === "radiusAxis" ? (o.pixel = t[0] - n[0], o.pixelLength = l[1] - l[0], o.pixelStart = l[0], o.signal = a.inverse ? 1 : -1) : (o.pixel = t[1] - n[1], o.pixelLength = u[1] - u[0], o.pixelStart = u[0], o.signal = a.inverse ? -1 : 1), o;
      }, singleAxis: function(n, t, e, i, r) {
        var a = e.axis, o = r.model.coordinateSystem.getRect(), s = {};
        return n = n || [0, 0], a.orient === "horizontal" ? (s.pixel = t[0] - n[0], s.pixelLength = o.width, s.pixelStart = o.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = t[1] - n[1], s.pixelLength = o.height, s.pixelStart = o.y, s.signal = a.inverse ? -1 : 1), s;
      } };
      function hY(n) {
        jD(n), n.registerComponentModel(hkt), n.registerComponentView(ykt), vkt(n);
      }
      var mkt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "dataZoom.slider", t.layoutMode = "box", t.defaultOption = eu(Kv.defaultOption, { show: true, right: "ph", top: "ph", width: "ph", height: "ph", left: null, bottom: null, borderColor: "#d2dbee", borderRadius: 3, backgroundColor: "rgba(47,69,84,0)", dataBackground: { lineStyle: { color: "#d2dbee", width: 0.5 }, areaStyle: { color: "#d2dbee", opacity: 0.2 } }, selectedDataBackground: { lineStyle: { color: "#8fb0f7", width: 0.5 }, areaStyle: { color: "#8fb0f7", opacity: 0.2 } }, fillerColor: "rgba(135,175,274,0.2)", handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z", handleSize: "100%", handleStyle: { color: "#fff", borderColor: "#ACB8D1" }, moveHandleSize: 7, moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z", moveHandleStyle: { color: "#D2DBEE", opacity: 0.7 }, showDetail: true, showDataShadow: "auto", realtime: true, zoomLock: false, textStyle: { color: "#6E7079" }, brushSelect: true, brushStyle: { color: "rgba(135,175,274,0.15)" }, emphasis: { handleStyle: { borderColor: "#8FB0F7" }, moveHandleStyle: { color: "#8FB0F7" } } }), t;
      }(Kv), iy = ue, cY = 7, _kt = 1, mR = 30, Ikt = 7, ry = "horizontal", fY = "vertical", Ekt = 5, xkt = ["line", "bar", "candlestick", "scatter"], wkt = { easing: "cubicOut", duration: 100, delay: 0 }, Ckt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._displayables = {}, e;
        }
        return t.prototype.init = function(e, i) {
          this.api = i, this._onBrush = ct(this._onBrush, this), this._onBrushEnd = ct(this._onBrushEnd, this);
        }, t.prototype.render = function(e, i, r, a) {
          if (n.prototype.render.apply(this, arguments), Gg(this, "_dispatchZoomAction", e.get("throttle"), "fixRate"), this._orient = e.getOrient(), e.get("show") === false) {
            this.group.removeAll();
            return;
          }
          if (e.noTarget()) {
            this._clear(), this.group.removeAll();
            return;
          }
          (!a || a.type !== "dataZoom" || a.from !== this.uid) && this._buildView(), this._updateView();
        }, t.prototype.dispose = function() {
          this._clear(), n.prototype.dispose.apply(this, arguments);
        }, t.prototype._clear = function() {
          av(this, "_dispatchZoomAction");
          var e = this.api.getZr();
          e.off("mousemove", this._onBrush), e.off("mouseup", this._onBrushEnd);
        }, t.prototype._buildView = function() {
          var e = this.group;
          e.removeAll(), this._brushing = false, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
          var i = this._displayables.sliderGroup = new Ct();
          this._renderBackground(), this._renderHandle(), this._renderDataShadow(), e.add(i), this._positionGroup();
        }, t.prototype._resetLocation = function() {
          var e = this.dataZoomModel, i = this.api, r = e.get("brushSelect"), a = r ? Ikt : 0, o = this._findCoordRect(), s = { width: i.getWidth(), height: i.getHeight() }, l = this._orient === ry ? { right: s.width - o.x - o.width, top: s.height - mR - cY - a, width: o.width, height: mR } : { right: cY, top: o.y, width: mR, height: o.height }, u = Pg(e.option);
          M(["right", "top", "width", "height"], function(c) {
            u[c] === "ph" && (u[c] = l[c]);
          });
          var h = Gn(u, s);
          this._location = { x: h.x, y: h.y }, this._size = [h.width, h.height], this._orient === fY && this._size.reverse();
        }, t.prototype._positionGroup = function() {
          var e = this.group, i = this._location, r = this._orient, a = this.dataZoomModel.getFirstTargetAxisModel(), o = a && a.get("inverse"), s = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse;
          s.attr(r === ry && !o ? { scaleY: l ? 1 : -1, scaleX: 1 } : r === ry && o ? { scaleY: l ? 1 : -1, scaleX: -1 } : r === fY && !o ? { scaleY: l ? -1 : 1, scaleX: 1, rotation: Math.PI / 2 } : { scaleY: l ? -1 : 1, scaleX: -1, rotation: Math.PI / 2 });
          var u = e.getBoundingRect([s]);
          e.x = i.x - u.x, e.y = i.y - u.y, e.markRedraw();
        }, t.prototype._getViewExtent = function() {
          return [0, this._size[0]];
        }, t.prototype._renderBackground = function() {
          var e = this.dataZoomModel, i = this._size, r = this._displayables.sliderGroup, a = e.get("brushSelect");
          r.add(new iy({ silent: true, shape: { x: 0, y: 0, width: i[0], height: i[1] }, style: { fill: e.get("backgroundColor") }, z2: -40 }));
          var o = new iy({ shape: { x: 0, y: 0, width: i[0], height: i[1] }, style: { fill: "transparent" }, z2: 0, onclick: ct(this._onClickPanel, this) }), s = this.api.getZr();
          a ? (o.on("mousedown", this._onBrushStart, this), o.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), r.add(o);
        }, t.prototype._renderDataShadow = function() {
          var e = this._dataShadowInfo = this._prepareDataShadowInfo();
          if (this._displayables.dataShadowSegs = [], !e) return;
          var i = this._size, r = this._shadowSize || [], a = e.series, o = a.getRawData(), s = a.getShadowDim && a.getShadowDim(), l = s && o.getDimensionInfo(s) ? a.getShadowDim() : e.otherDim;
          if (l == null) return;
          var u = this._shadowPolygonPts, h = this._shadowPolylinePts;
          if (o !== this._shadowData || l !== this._shadowDim || i[0] !== r[0] || i[1] !== r[1]) {
            var c = o.getDataExtent(l), f = (c[1] - c[0]) * 0.3;
            c = [c[0] - f, c[1] + f];
            var g = [0, i[1]], d = [0, i[0]], A = [[i[0], 0], [0, 0]], p = [], v = d[1] / (o.count() - 1), y = 0, m = Math.round(o.count() / i[0]), _;
            o.each([l], function(C, S) {
              if (m > 0 && S % m) {
                y += v;
                return;
              }
              var b = C == null || isNaN(C) || C === "", B = b ? 0 : Le(C, c, g, true);
              b && !_ && S ? (A.push([A[A.length - 1][0], 0]), p.push([p[p.length - 1][0], 0])) : !b && _ && (A.push([y, 0]), p.push([y, 0])), A.push([y, B]), p.push([y, B]), y += v, _ = b;
            }), u = this._shadowPolygonPts = A, h = this._shadowPolylinePts = p;
          }
          this._shadowData = o, this._shadowDim = l, this._shadowSize = [i[0], i[1]];
          var E = this.dataZoomModel;
          function I(C) {
            var S = E.getModel(C ? "selectedDataBackground" : "dataBackground"), b = new Ct(), B = new Yi({ shape: { points: u }, segmentIgnoreThreshold: 1, style: S.getModel("areaStyle").getAreaStyle(), silent: true, z2: -20 }), T = new Wi({ shape: { points: h }, segmentIgnoreThreshold: 1, style: S.getModel("lineStyle").getLineStyle(), silent: true, z2: -19 });
            return b.add(B), b.add(T), b;
          }
          for (var x = 0; x < 3; x++) {
            var w = I(x === 1);
            this._displayables.sliderGroup.add(w), this._displayables.dataShadowSegs.push(w);
          }
        }, t.prototype._prepareDataShadowInfo = function() {
          var e = this.dataZoomModel, i = e.get("showDataShadow");
          if (i !== false) {
            var r, a = this.ecModel;
            return e.eachTargetAxis(function(o, s) {
              var l = e.getAxisProxy(o, s).getTargetSeriesModels();
              M(l, function(u) {
                if (!r && !(i !== true && Wt(xkt, u.get("type")) < 0)) {
                  var h = a.getComponent(vu(o), s).axis, c = Skt(o), f, g = u.coordinateSystem;
                  c != null && g.getOtherAxis && (f = g.getOtherAxis(h).inverse), c = u.getData().mapDimension(c), r = { thisAxis: h, series: u, thisDim: o, otherDim: c, otherAxisInverse: f };
                }
              }, this);
            }, this), r;
          }
        }, t.prototype._renderHandle = function() {
          var e = this.group, i = this._displayables, r = i.handles = [null, null], a = i.handleLabels = [null, null], o = this._displayables.sliderGroup, s = this._size, l = this.dataZoomModel, u = this.api, h = l.get("borderRadius") || 0, c = l.get("brushSelect"), f = i.filler = new iy({ silent: c, style: { fill: l.get("fillerColor") }, textConfig: { position: "inside" } });
          o.add(f), o.add(new iy({ silent: true, subPixelOptimize: true, shape: { x: 0, y: 0, width: s[0], height: s[1], r: h }, style: { stroke: l.get("dataBackgroundColor") || l.get("borderColor"), lineWidth: _kt, fill: "rgba(0,0,0,0)" } })), M([0, 1], function(m) {
            var _ = l.get("handleIcon");
            !F1[_] && _.indexOf("path://") < 0 && _.indexOf("image://") < 0 && (_ = "path://" + _, qa("handleIcon now needs 'path://' prefix when using a path string"));
            var E = Nn(_, -1, 0, 2, 2, null, true);
            E.attr({ cursor: gY(this._orient), draggable: true, drift: ct(this._onDragMove, this, m), ondragend: ct(this._onDragEnd, this), onmouseover: ct(this._showDataInfo, this, true), onmouseout: ct(this._showDataInfo, this, false), z2: 5 });
            var I = E.getBoundingRect(), x = l.get("handleSize");
            this._handleHeight = ot(x, this._size[1]), this._handleWidth = I.width / I.height * this._handleHeight, E.setStyle(l.getModel("handleStyle").getItemStyle()), E.style.strokeNoScale = true, E.rectHover = true, E.ensureState("emphasis").style = l.getModel(["emphasis", "handleStyle"]).getItemStyle(), Bh(E);
            var w = l.get("handleColor");
            w != null && (E.style.fill = w), o.add(r[m] = E);
            var C = l.getModel("textStyle");
            e.add(a[m] = new ge({ silent: true, invisible: true, style: Ke(C, { x: 0, y: 0, text: "", verticalAlign: "middle", align: "center", fill: C.getTextColor(), font: C.getFont() }), z2: 10 }));
          }, this);
          var g = f;
          if (c) {
            var d = ot(l.get("moveHandleSize"), s[1]), A = i.moveHandle = new ue({ style: l.getModel("moveHandleStyle").getItemStyle(), silent: true, shape: { r: [0, 0, 2, 2], y: s[1] - 0.5, height: d } }), p = d * 0.8, v = i.moveHandleIcon = Nn(l.get("moveHandleIcon"), -p / 2, -p / 2, p, p, "#fff", true);
            v.silent = true, v.y = s[1] + d / 2 - 0.5, A.ensureState("emphasis").style = l.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
            var y = Math.min(s[1] / 2, Math.max(d, 10));
            g = i.moveZone = new ue({ invisible: true, shape: { y: s[1] - y, height: d + y } }), g.on("mouseover", function() {
              u.enterEmphasis(A);
            }).on("mouseout", function() {
              u.leaveEmphasis(A);
            }), o.add(A), o.add(v), o.add(g);
          }
          g.attr({ draggable: true, cursor: gY(this._orient), drift: ct(this._onDragMove, this, "all"), ondragstart: ct(this._showDataInfo, this, true), ondragend: ct(this._onDragEnd, this), onmouseover: ct(this._showDataInfo, this, true), onmouseout: ct(this._showDataInfo, this, false) });
        }, t.prototype._resetInterval = function() {
          var e = this._range = this.dataZoomModel.getPercentRange(), i = this._getViewExtent();
          this._handleEnds = [Le(e[0], [0, 100], i, true), Le(e[1], [0, 100], i, true)];
        }, t.prototype._updateInterval = function(e, i) {
          var r = this.dataZoomModel, a = this._handleEnds, o = this._getViewExtent(), s = r.findRepresentativeAxisProxy().getMinMaxSpan(), l = [0, 100];
          lc(i, a, o, r.get("zoomLock") ? "all" : e, s.minSpan != null ? Le(s.minSpan, l, o, true) : null, s.maxSpan != null ? Le(s.maxSpan, l, o, true) : null);
          var u = this._range, h = this._range = ua([Le(a[0], o, l, true), Le(a[1], o, l, true)]);
          return !u || u[0] !== h[0] || u[1] !== h[1];
        }, t.prototype._updateView = function(e) {
          var i = this._displayables, r = this._handleEnds, a = ua(r.slice()), o = this._size;
          M([0, 1], function(g) {
            var d = i.handles[g], A = this._handleHeight;
            d.attr({ scaleX: A / 2, scaleY: A / 2, x: r[g] + (g ? -1 : 1), y: o[1] / 2 - A / 2 });
          }, this), i.filler.setShape({ x: a[0], y: 0, width: a[1] - a[0], height: o[1] });
          var s = { x: a[0], width: a[1] - a[0] };
          i.moveHandle && (i.moveHandle.setShape(s), i.moveZone.setShape(s), i.moveZone.getBoundingRect(), i.moveHandleIcon && i.moveHandleIcon.attr("x", s.x + s.width / 2));
          for (var l = i.dataShadowSegs, u = [0, a[0], a[1], o[0]], h = 0; h < l.length; h++) {
            var c = l[h], f = c.getClipPath();
            f || (f = new ue(), c.setClipPath(f)), f.setShape({ x: u[h], y: 0, width: u[h + 1] - u[h], height: o[1] });
          }
          this._updateDataInfo(e);
        }, t.prototype._updateDataInfo = function(e) {
          var i = this.dataZoomModel, r = this._displayables, a = r.handleLabels, o = this._orient, s = ["", ""];
          if (i.get("showDetail")) {
            var l = i.findRepresentativeAxisProxy();
            if (l) {
              var u = l.getAxisModel().axis, h = this._range, c = e ? l.calculateDataWindow({ start: h[0], end: h[1] }).valueWindow : l.getDataValueWindow();
              s = [this._formatLabel(c[0], u), this._formatLabel(c[1], u)];
            }
          }
          var f = ua(this._handleEnds.slice());
          g.call(this, 0), g.call(this, 1);
          function g(d) {
            var A = Lh(r.handles[d].parent, this.group), p = f1(d === 0 ? "right" : "left", A), v = this._handleWidth / 2 + Ekt, y = Xa([f[d] + (d === 0 ? -v : v), this._size[1] / 2], A);
            a[d].setStyle({ x: y[0], y: y[1], verticalAlign: o === ry ? "middle" : p, align: o === ry ? p : "center", text: s[d] });
          }
        }, t.prototype._formatLabel = function(e, i) {
          var r = this.dataZoomModel, a = r.get("labelFormatter"), o = r.get("labelPrecision");
          (o == null || o === "auto") && (o = i.getPixelPrecision());
          var s = e == null || isNaN(e) ? "" : i.type === "category" || i.type === "time" ? i.scale.getLabel({ value: Math.round(e) }) : e.toFixed(Math.min(o, 20));
          return yt(a) ? a(e, s) : ht(a) ? a.replace("{value}", s) : s;
        }, t.prototype._showDataInfo = function(e) {
          e = this._dragging || e;
          var i = this._displayables, r = i.handleLabels;
          r[0].attr("invisible", !e), r[1].attr("invisible", !e), i.moveHandle && this.api[e ? "enterEmphasis" : "leaveEmphasis"](i.moveHandle, 1);
        }, t.prototype._onDragMove = function(e, i, r, a) {
          this._dragging = true, Cs(a.event);
          var o = this._displayables.sliderGroup.getLocalTransform(), s = Xa([i, r], o, true), l = this._updateInterval(e, s[0]), u = this.dataZoomModel.get("realtime");
          this._updateView(!u), l && u && this._dispatchZoomAction(true);
        }, t.prototype._onDragEnd = function() {
          this._dragging = false, this._showDataInfo(false);
          var e = this.dataZoomModel.get("realtime");
          !e && this._dispatchZoomAction(false);
        }, t.prototype._onClickPanel = function(e) {
          var i = this._size, r = this._displayables.sliderGroup.transformCoordToLocal(e.offsetX, e.offsetY);
          if (!(r[0] < 0 || r[0] > i[0] || r[1] < 0 || r[1] > i[1])) {
            var a = this._handleEnds, o = (a[0] + a[1]) / 2, s = this._updateInterval("all", r[0] - o);
            this._updateView(), s && this._dispatchZoomAction(false);
          }
        }, t.prototype._onBrushStart = function(e) {
          var i = e.offsetX, r = e.offsetY;
          this._brushStart = new Ut(i, r), this._brushing = true, this._brushStartTime = +/* @__PURE__ */ new Date();
        }, t.prototype._onBrushEnd = function(e) {
          if (this._brushing) {
            var i = this._displayables.brushRect;
            if (this._brushing = false, !!i) {
              i.attr("ignore", true);
              var r = i.shape, a = +/* @__PURE__ */ new Date();
              if (!(a - this._brushStartTime < 200 && Math.abs(r.width) < 5)) {
                var o = this._getViewExtent(), s = [0, 100];
                this._range = ua([Le(r.x, o, s, true), Le(r.x + r.width, o, s, true)]), this._handleEnds = [r.x, r.x + r.width], this._updateView(), this._dispatchZoomAction(false);
              }
            }
          }
        }, t.prototype._onBrush = function(e) {
          this._brushing && (Cs(e.event), this._updateBrushRect(e.offsetX, e.offsetY));
        }, t.prototype._updateBrushRect = function(e, i) {
          var r = this._displayables, a = this.dataZoomModel, o = r.brushRect;
          o || (o = r.brushRect = new iy({ silent: true, style: a.getModel("brushStyle").getItemStyle() }), r.sliderGroup.add(o)), o.attr("ignore", false);
          var s = this._brushStart, l = this._displayables.sliderGroup, u = l.transformCoordToLocal(e, i), h = l.transformCoordToLocal(s.x, s.y), c = this._size;
          u[0] = Math.max(Math.min(c[0], u[0]), 0), o.setShape({ x: h[0], y: 0, width: u[0] - h[0], height: c[1] });
        }, t.prototype._dispatchZoomAction = function(e) {
          var i = this._range;
          this.api.dispatchAction({ type: "dataZoom", from: this.uid, dataZoomId: this.dataZoomModel.id, animation: e ? wkt : null, start: i[0], end: i[1] });
        }, t.prototype._findCoordRect = function() {
          var e, i = aH(this.dataZoomModel).infoList;
          if (!e && i.length) {
            var r = i[0].model.coordinateSystem;
            e = r.getRect && r.getRect();
          }
          if (!e) {
            var a = this.api.getWidth(), o = this.api.getHeight();
            e = { x: a * 0.2, y: o * 0.2, width: a * 0.6, height: o * 0.6 };
          }
          return e;
        }, t.type = "dataZoom.slider", t;
      }(VD);
      function Skt(n) {
        var t = { x: "y", y: "x", radius: "angle", angle: "radius" };
        return t[n];
      }
      function gY(n) {
        return n === "vertical" ? "ns-resize" : "ew-resize";
      }
      function dY(n) {
        n.registerComponentModel(mkt), n.registerComponentView(Ckt), jD(n);
      }
      function bkt(n) {
        Zt(hY), Zt(dY);
      }
      var AY = { get: function(n, t, e) {
        var i = xt((Bkt[n] || {})[t]);
        return e && X(i) ? i[i.length - 1] : i;
      } }, Bkt = { color: { active: ["#006edd", "#e0ffff"], inactive: ["rgba(0,0,0,0)"] }, colorHue: { active: [0, 360], inactive: [0, 0] }, colorSaturation: { active: [0.3, 1], inactive: [0, 0] }, colorLightness: { active: [0.9, 0.5], inactive: [0, 0] }, colorAlpha: { active: [0.3, 1], inactive: [0, 0] }, opacity: { active: [0.3, 1], inactive: [0, 0] }, symbol: { active: ["circle", "roundRect", "diamond"], inactive: ["none"] }, symbolSize: { active: [10, 50], inactive: [0, 0] } }, pY = $n.mapVisual, Tkt = $n.eachVisual, Mkt = X, vY = M, Dkt = ua, Rkt = Le, uE = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.stateList = ["inRange", "outOfRange"], e.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"], e.layoutMode = { type: "box", ignoreSize: true }, e.dataBound = [-1 / 0, 1 / 0], e.targetVisuals = {}, e.controllerVisuals = {}, e;
        }
        return t.prototype.init = function(e, i, r) {
          this.mergeDefaultAndTheme(e, r);
        }, t.prototype.optionUpdated = function(e, i) {
          var r = this.option;
          !i && NH(r, e, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
        }, t.prototype.resetVisual = function(e) {
          var i = this.stateList;
          e = ct(e, this), this.controllerVisuals = JD(this.option.controller, i, e), this.targetVisuals = JD(this.option.target, i, e);
        }, t.prototype.getItemSymbol = function() {
          return null;
        }, t.prototype.getTargetSeriesIndices = function() {
          var e = this.option.seriesIndex, i = [];
          return e == null || e === "all" ? this.ecModel.eachSeries(function(r, a) {
            i.push(a);
          }) : i = Qe(e), i;
        }, t.prototype.eachTargetSeries = function(e, i) {
          M(this.getTargetSeriesIndices(), function(r) {
            var a = this.ecModel.getSeriesByIndex(r);
            a && e.call(i, a);
          }, this);
        }, t.prototype.isTargetSeries = function(e) {
          var i = false;
          return this.eachTargetSeries(function(r) {
            r === e && (i = true);
          }), i;
        }, t.prototype.formatValueText = function(e, i, r) {
          var a = this.option, o = a.precision, s = this.dataBound, l = a.formatter, u;
          r = r || ["<", ">"], X(e) && (e = e.slice(), u = true);
          var h = i ? e : u ? [c(e[0]), c(e[1])] : c(e);
          if (ht(l)) return l.replace("{value}", u ? h[0] : h).replace("{value2}", u ? h[1] : h);
          if (yt(l)) return u ? l(e[0], e[1]) : l(e);
          if (u) return e[0] === s[0] ? r[0] + " " + h[1] : e[1] === s[1] ? r[1] + " " + h[0] : h[0] + " - " + h[1];
          return h;
          function c(f) {
            return f === s[0] ? "min" : f === s[1] ? "max" : (+f).toFixed(Math.min(o, 20));
          }
        }, t.prototype.resetExtent = function() {
          var e = this.option, i = Dkt([e.min, e.max]);
          this._dataExtent = i;
        }, t.prototype.getDataDimensionIndex = function(e) {
          var i = this.option.dimension;
          if (i != null) return e.getDimensionIndex(i);
          for (var r = e.dimensions, a = r.length - 1; a >= 0; a--) {
            var o = r[a], s = e.getDimensionInfo(o);
            if (!s.isCalculationCoord) return s.storeDimIndex;
          }
        }, t.prototype.getExtent = function() {
          return this._dataExtent.slice();
        }, t.prototype.completeVisualOption = function() {
          var e = this.ecModel, i = this.option, r = { inRange: i.inRange, outOfRange: i.outOfRange }, a = i.target || (i.target = {}), o = i.controller || (i.controller = {});
          qt(a, r), qt(o, r);
          var s = this.isCategory();
          l.call(this, a), l.call(this, o), u.call(this, a, "inRange", "outOfRange"), h.call(this, o);
          function l(c) {
            Mkt(i.color) && !c.inRange && (c.inRange = { color: i.color.slice().reverse() }), c.inRange = c.inRange || { color: e.get("gradientColor") };
          }
          function u(c, f, g) {
            var d = c[f], A = c[g];
            d && !A && (A = c[g] = {}, vY(d, function(p, v) {
              if ($n.isValidType(v)) {
                var y = AY.get(v, "inactive", s);
                y != null && (A[v] = y, v === "color" && !A.hasOwnProperty("opacity") && !A.hasOwnProperty("colorAlpha") && (A.opacity = [0, 0]));
              }
            }));
          }
          function h(c) {
            var f = (c.inRange || {}).symbol || (c.outOfRange || {}).symbol, g = (c.inRange || {}).symbolSize || (c.outOfRange || {}).symbolSize, d = this.get("inactiveColor"), A = this.getItemSymbol(), p = A || "roundRect";
            vY(this.stateList, function(v) {
              var y = this.itemSize, m = c[v];
              m || (m = c[v] = { color: s ? d : [d] }), m.symbol == null && (m.symbol = f && xt(f) || (s ? p : [p])), m.symbolSize == null && (m.symbolSize = g && xt(g) || (s ? y[0] : [y[0], y[0]])), m.symbol = pY(m.symbol, function(I) {
                return I === "none" ? p : I;
              });
              var _ = m.symbolSize;
              if (_ != null) {
                var E = -1 / 0;
                Tkt(_, function(I) {
                  I > E && (E = I);
                }), m.symbolSize = pY(_, function(I) {
                  return Rkt(I, [0, E], [0, y[0]], true);
                });
              }
            }, this);
          }
        }, t.prototype.resetItemSize = function() {
          this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
        }, t.prototype.isCategory = function() {
          return !!this.option.categories;
        }, t.prototype.setSelected = function(e) {
        }, t.prototype.getSelected = function() {
          return null;
        }, t.prototype.getValueState = function(e) {
          return null;
        }, t.prototype.getVisualMeta = function(e) {
          return null;
        }, t.type = "visualMap", t.dependencies = ["series"], t.defaultOption = { show: true, z: 4, seriesIndex: "all", min: 0, max: 200, left: 0, right: null, top: null, bottom: 0, itemWidth: null, itemHeight: null, inverse: false, orient: "vertical", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", contentColor: "#5793f3", inactiveColor: "#aaa", borderWidth: 0, padding: 5, textGap: 10, precision: 0, textStyle: { color: "#333" } }, t;
      }(ne), yY = [20, 140], Lkt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.optionUpdated = function(e, i) {
          n.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(r) {
            r.mappingMethod = "linear", r.dataExtent = this.getExtent();
          }), this._resetRange();
        }, t.prototype.resetItemSize = function() {
          n.prototype.resetItemSize.apply(this, arguments);
          var e = this.itemSize;
          (e[0] == null || isNaN(e[0])) && (e[0] = yY[0]), (e[1] == null || isNaN(e[1])) && (e[1] = yY[1]);
        }, t.prototype._resetRange = function() {
          var e = this.getExtent(), i = this.option.range;
          !i || i.auto ? (e.auto = 1, this.option.range = e) : X(i) && (i[0] > i[1] && i.reverse(), i[0] = Math.max(i[0], e[0]), i[1] = Math.min(i[1], e[1]));
        }, t.prototype.completeVisualOption = function() {
          n.prototype.completeVisualOption.apply(this, arguments), M(this.stateList, function(e) {
            var i = this.option.controller[e].symbolSize;
            i && i[0] !== i[1] && (i[0] = i[1] / 3);
          }, this);
        }, t.prototype.setSelected = function(e) {
          this.option.range = e.slice(), this._resetRange();
        }, t.prototype.getSelected = function() {
          var e = this.getExtent(), i = ua((this.get("range") || []).slice());
          return i[0] > e[1] && (i[0] = e[1]), i[1] > e[1] && (i[1] = e[1]), i[0] < e[0] && (i[0] = e[0]), i[1] < e[0] && (i[1] = e[0]), i;
        }, t.prototype.getValueState = function(e) {
          var i = this.option.range, r = this.getExtent();
          return (i[0] <= r[0] || i[0] <= e) && (i[1] >= r[1] || e <= i[1]) ? "inRange" : "outOfRange";
        }, t.prototype.findTargetDataIndices = function(e) {
          var i = [];
          return this.eachTargetSeries(function(r) {
            var a = [], o = r.getData();
            o.each(this.getDataDimensionIndex(o), function(s, l) {
              e[0] <= s && s <= e[1] && a.push(l);
            }, this), i.push({ seriesId: r.id, dataIndex: a });
          }, this), i;
        }, t.prototype.getVisualMeta = function(e) {
          var i = mY(this, "outOfRange", this.getExtent()), r = mY(this, "inRange", this.option.range.slice()), a = [];
          function o(g, d) {
            a.push({ value: g, color: e(g, d) });
          }
          for (var s = 0, l = 0, u = r.length, h = i.length; l < h && (!r.length || i[l] <= r[0]); l++) i[l] < r[s] && o(i[l], "outOfRange");
          for (var c = 1; s < u; s++, c = 0) c && a.length && o(r[s], "outOfRange"), o(r[s], "inRange");
          for (var c = 1; l < h; l++) (!r.length || r[r.length - 1] < i[l]) && (c && (a.length && o(a[a.length - 1].value, "outOfRange"), c = 0), o(i[l], "outOfRange"));
          var f = a.length;
          return { stops: a, outerColors: [f ? a[0].color : "transparent", f ? a[f - 1].color : "transparent"] };
        }, t.type = "visualMap.continuous", t.defaultOption = eu(uE.defaultOption, { align: "auto", calculable: false, hoverLink: true, realtime: true, handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z", handleSize: "120%", handleStyle: { borderColor: "#fff", borderWidth: 1 }, indicatorIcon: "circle", indicatorSize: "50%", indicatorStyle: { borderColor: "#fff", borderWidth: 2, shadowBlur: 2, shadowOffsetX: 1, shadowOffsetY: 1, shadowColor: "rgba(0,0,0,0.2)" } }), t;
      }(uE);
      function mY(n, t, e) {
        if (e[0] === e[1]) return e.slice();
        for (var i = 200, r = (e[1] - e[0]) / i, a = e[0], o = [], s = 0; s <= i && a < e[1]; s++) o.push(a), a += r;
        return o.push(e[1]), o;
      }
      var _Y = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.autoPositionValues = { left: 1, right: 1, top: 1, bottom: 1 }, e;
        }
        return t.prototype.init = function(e, i) {
          this.ecModel = e, this.api = i;
        }, t.prototype.render = function(e, i, r, a) {
          if (this.visualMapModel = e, e.get("show") === false) {
            this.group.removeAll();
            return;
          }
          this.doRender(e, i, r, a);
        }, t.prototype.renderBackground = function(e) {
          var i = this.visualMapModel, r = Lg(i.get("padding") || 0), a = e.getBoundingRect();
          e.add(new ue({ z2: -1, silent: true, shape: { x: a.x - r[3], y: a.y - r[0], width: a.width + r[3] + r[1], height: a.height + r[0] + r[2] }, style: { fill: i.get("backgroundColor"), stroke: i.get("borderColor"), lineWidth: i.get("borderWidth") } }));
        }, t.prototype.getControllerVisual = function(e, i, r) {
          r = r || {};
          var a = r.forceState, o = this.visualMapModel, s = {};
          if (i === "color") {
            var l = o.get("contentColor");
            s.color = l;
          }
          function u(g) {
            return s[g];
          }
          function h(g, d) {
            s[g] = d;
          }
          var c = o.controllerVisuals[a || o.getValueState(e)], f = $n.prepareVisualTypes(c);
          return M(f, function(g) {
            var d = c[g];
            r.convertOpacityToAlpha && g === "opacity" && (g = "colorAlpha", d = c.__alphaForOpacity), $n.dependsOn(g, i) && d && d.applyVisual(e, u, h);
          }), s[i];
        }, t.prototype.positionGroup = function(e) {
          var i = this.visualMapModel, r = this.api;
          C1(e, i.getBoxLayoutParams(), { width: r.getWidth(), height: r.getHeight() });
        }, t.prototype.doRender = function(e, i, r, a) {
        }, t.type = "visualMap", t;
      }(on), IY = [["left", "right", "width"], ["top", "bottom", "height"]];
      function EY(n, t, e) {
        var i = n.option, r = i.align;
        if (r != null && r !== "auto") return r;
        for (var a = { width: t.getWidth(), height: t.getHeight() }, o = i.orient === "horizontal" ? 1 : 0, s = IY[o], l = [0, null, 10], u = {}, h = 0; h < 3; h++) u[IY[1 - o][h]] = l[h], u[s[h]] = h === 2 ? e[0] : i[s[h]];
        var c = [["x", "width", 3], ["y", "height", 0]][o], f = Gn(u, a, i.padding);
        return s[(f.margin[c[2]] || 0) + f[c[0]] + f[c[1]] * 0.5 < a[c[1]] * 0.5 ? 0 : 1];
      }
      function hE(n, t) {
        return M(n || [], function(e) {
          e.dataIndex != null && (e.dataIndexInside = e.dataIndex, e.dataIndex = null), e.highlightKey = "visualMap" + (t ? t.componentIndex : "");
        }), n;
      }
      var Yo = Le, Pkt = M, xY = Math.min, _R = Math.max, Nkt = 12, kkt = 6, Fkt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._shapes = {}, e._dataInterval = [], e._handleEnds = [], e._hoverLinkDataIndices = [], e;
        }
        return t.prototype.init = function(e, i) {
          n.prototype.init.call(this, e, i), this._hoverLinkFromSeriesMouseOver = ct(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = ct(this._hideIndicator, this);
        }, t.prototype.doRender = function(e, i, r, a) {
          (!a || a.type !== "selectDataRange" || a.from !== this.uid) && this._buildView();
        }, t.prototype._buildView = function() {
          this.group.removeAll();
          var e = this.visualMapModel, i = this.group;
          this._orient = e.get("orient"), this._useHandle = e.get("calculable"), this._resetInterval(), this._renderBar(i);
          var r = e.get("text");
          this._renderEndsText(i, r, 0), this._renderEndsText(i, r, 1), this._updateView(true), this.renderBackground(i), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(i);
        }, t.prototype._renderEndsText = function(e, i, r) {
          if (i) {
            var a = i[1 - r];
            a = a != null ? a + "" : "";
            var o = this.visualMapModel, s = o.get("textGap"), l = o.itemSize, u = this._shapes.mainGroup, h = this._applyTransform([l[0] / 2, r === 0 ? -s : l[1] + s], u), c = this._applyTransform(r === 0 ? "bottom" : "top", u), f = this._orient, g = this.visualMapModel.textStyleModel;
            this.group.add(new ge({ style: Ke(g, { x: h[0], y: h[1], verticalAlign: f === "horizontal" ? "middle" : c, align: f === "horizontal" ? c : "center", text: a }) }));
          }
        }, t.prototype._renderBar = function(e) {
          var i = this.visualMapModel, r = this._shapes, a = i.itemSize, o = this._orient, s = this._useHandle, l = EY(i, this.api, a), u = r.mainGroup = this._createBarGroup(l), h = new Ct();
          u.add(h), h.add(r.outOfRange = wY()), h.add(r.inRange = wY(null, s ? SY(this._orient) : null, ct(this._dragHandle, this, "all", false), ct(this._dragHandle, this, "all", true))), h.setClipPath(new ue({ shape: { x: 0, y: 0, width: a[0], height: a[1], r: 3 } }));
          var c = i.textStyleModel.getTextRect(""), f = _R(c.width, c.height);
          s && (r.handleThumbs = [], r.handleLabels = [], r.handleLabelPoints = [], this._createHandle(i, u, 0, a, f, o), this._createHandle(i, u, 1, a, f, o)), this._createIndicator(i, u, a, f, o), e.add(u);
        }, t.prototype._createHandle = function(e, i, r, a, o, s) {
          var l = ct(this._dragHandle, this, r, false), u = ct(this._dragHandle, this, r, true), h = ja(e.get("handleSize"), a[0]), c = Nn(e.get("handleIcon"), -h / 2, -h / 2, h, h, null, true), f = SY(this._orient);
          c.attr({ cursor: f, draggable: true, drift: l, ondragend: u, onmousemove: function(v) {
            Cs(v.event);
          } }), c.x = a[0] / 2, c.useStyle(e.getModel("handleStyle").getItemStyle()), c.setStyle({ strokeNoScale: true, strokeFirst: true }), c.style.lineWidth *= 2, c.ensureState("emphasis").style = e.getModel(["emphasis", "handleStyle"]).getItemStyle(), Th(c, true), i.add(c);
          var g = this.visualMapModel.textStyleModel, d = new ge({ cursor: f, draggable: true, drift: l, onmousemove: function(v) {
            Cs(v.event);
          }, ondragend: u, style: Ke(g, { x: 0, y: 0, text: "" }) });
          d.ensureState("blur").style = { opacity: 0.1 }, d.stateTransition = { duration: 200 }, this.group.add(d);
          var A = [h, 0], p = this._shapes;
          p.handleThumbs[r] = c, p.handleLabelPoints[r] = A, p.handleLabels[r] = d;
        }, t.prototype._createIndicator = function(e, i, r, a, o) {
          var s = ja(e.get("indicatorSize"), r[0]), l = Nn(e.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, true);
          l.attr({ cursor: "move", invisible: true, silent: true, x: r[0] / 2 });
          var u = e.getModel("indicatorStyle").getItemStyle();
          if (l instanceof li) {
            var h = l.style;
            l.useStyle(Y({ image: h.image, x: h.x, y: h.y, width: h.width, height: h.height }, u));
          } else l.useStyle(u);
          i.add(l);
          var c = this.visualMapModel.textStyleModel, f = new ge({ silent: true, invisible: true, style: Ke(c, { x: 0, y: 0, text: "" }) });
          this.group.add(f);
          var g = [(o === "horizontal" ? a / 2 : kkt) + r[0] / 2, 0], d = this._shapes;
          d.indicator = l, d.indicatorLabel = f, d.indicatorLabelPoint = g, this._firstShowIndicator = true;
        }, t.prototype._dragHandle = function(e, i, r, a) {
          if (this._useHandle) {
            if (this._dragging = !i, !i) {
              var o = this._applyTransform([r, a], this._shapes.mainGroup, true);
              this._updateInterval(e, o[1]), this._hideIndicator(), this._updateView();
            }
            i === !this.visualMapModel.get("realtime") && this.api.dispatchAction({ type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: this._dataInterval.slice() }), i ? !this._hovering && this._clearHoverLinkToSeries() : CY(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[e], false);
          }
        }, t.prototype._resetInterval = function() {
          var e = this.visualMapModel, i = this._dataInterval = e.getSelected(), r = e.getExtent(), a = [0, e.itemSize[1]];
          this._handleEnds = [Yo(i[0], r, a, true), Yo(i[1], r, a, true)];
        }, t.prototype._updateInterval = function(e, i) {
          i = i || 0;
          var r = this.visualMapModel, a = this._handleEnds, o = [0, r.itemSize[1]];
          lc(i, a, o, e, 0);
          var s = r.getExtent();
          this._dataInterval = [Yo(a[0], o, s, true), Yo(a[1], o, s, true)];
        }, t.prototype._updateView = function(e) {
          var i = this.visualMapModel, r = i.getExtent(), a = this._shapes, o = [0, i.itemSize[1]], s = e ? o : this._handleEnds, l = this._createBarVisual(this._dataInterval, r, s, "inRange"), u = this._createBarVisual(r, r, o, "outOfRange");
          a.inRange.setStyle({ fill: l.barColor }).setShape("points", l.barPoints), a.outOfRange.setStyle({ fill: u.barColor }).setShape("points", u.barPoints), this._updateHandle(s, l);
        }, t.prototype._createBarVisual = function(e, i, r, a) {
          var o = { forceState: a, convertOpacityToAlpha: true }, s = this._makeColorGradient(e, o), l = [this.getControllerVisual(e[0], "symbolSize", o), this.getControllerVisual(e[1], "symbolSize", o)], u = this._createBarPoints(r, l);
          return { barColor: new Vp(0, 0, 0, 1, s), barPoints: u, handlesColor: [s[0].color, s[s.length - 1].color] };
        }, t.prototype._makeColorGradient = function(e, i) {
          var r = 100, a = [], o = (e[1] - e[0]) / r;
          a.push({ color: this.getControllerVisual(e[0], "color", i), offset: 0 });
          for (var s = 1; s < r; s++) {
            var l = e[0] + o * s;
            if (l > e[1]) break;
            a.push({ color: this.getControllerVisual(l, "color", i), offset: s / r });
          }
          return a.push({ color: this.getControllerVisual(e[1], "color", i), offset: 1 }), a;
        }, t.prototype._createBarPoints = function(e, i) {
          var r = this.visualMapModel.itemSize;
          return [[r[0] - i[0], e[0]], [r[0], e[0]], [r[0], e[1]], [r[0] - i[1], e[1]]];
        }, t.prototype._createBarGroup = function(e) {
          var i = this._orient, r = this.visualMapModel.get("inverse");
          return new Ct(i === "horizontal" && !r ? { scaleX: e === "bottom" ? 1 : -1, rotation: Math.PI / 2 } : i === "horizontal" && r ? { scaleX: e === "bottom" ? -1 : 1, rotation: -Math.PI / 2 } : i === "vertical" && !r ? { scaleX: e === "left" ? 1 : -1, scaleY: -1 } : { scaleX: e === "left" ? 1 : -1 });
        }, t.prototype._updateHandle = function(e, i) {
          if (this._useHandle) {
            var r = this._shapes, a = this.visualMapModel, o = r.handleThumbs, s = r.handleLabels, l = a.itemSize, u = a.getExtent();
            Pkt([0, 1], function(h) {
              var c = o[h];
              c.setStyle("fill", i.handlesColor[h]), c.y = e[h];
              var f = Yo(e[h], [0, l[1]], u, true), g = this.getControllerVisual(f, "symbolSize");
              c.scaleX = c.scaleY = g / l[0], c.x = l[0] - g / 2;
              var d = Xa(r.handleLabelPoints[h], Lh(c, this.group));
              s[h].setStyle({ x: d[0], y: d[1], text: a.formatValueText(this._dataInterval[h]), verticalAlign: "middle", align: this._orient === "vertical" ? this._applyTransform("left", r.mainGroup) : "center" });
            }, this);
          }
        }, t.prototype._showIndicator = function(e, i, r, a) {
          var o = this.visualMapModel, s = o.getExtent(), l = o.itemSize, u = [0, l[1]], h = this._shapes, c = h.indicator;
          if (c) {
            c.attr("invisible", false);
            var f = { convertOpacityToAlpha: true }, g = this.getControllerVisual(e, "color", f), d = this.getControllerVisual(e, "symbolSize"), A = Yo(e, s, u, true), p = l[0] - d / 2, v = { x: c.x, y: c.y };
            c.y = A, c.x = p;
            var y = Xa(h.indicatorLabelPoint, Lh(c, this.group)), m = h.indicatorLabel;
            m.attr("invisible", false);
            var _ = this._applyTransform("left", h.mainGroup), E = this._orient, I = E === "horizontal";
            m.setStyle({ text: (r || "") + o.formatValueText(i), verticalAlign: I ? _ : "middle", align: I ? "center" : _ });
            var x = { x: p, y: A, style: { fill: g } }, w = { style: { x: y[0], y: y[1] } };
            if (o.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
              var C = { duration: 100, easing: "cubicInOut", additive: true };
              c.x = v.x, c.y = v.y, c.animateTo(x, C), m.animateTo(w, C);
            } else c.attr(x), m.attr(w);
            this._firstShowIndicator = false;
            var S = this._shapes.handleLabels;
            if (S) for (var b = 0; b < S.length; b++) this.api.enterBlur(S[b]);
          }
        }, t.prototype._enableHoverLinkToSeries = function() {
          var e = this;
          this._shapes.mainGroup.on("mousemove", function(i) {
            if (e._hovering = true, !e._dragging) {
              var r = e.visualMapModel.itemSize, a = e._applyTransform([i.offsetX, i.offsetY], e._shapes.mainGroup, true, true);
              a[1] = xY(_R(0, a[1]), r[1]), e._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= r[0]);
            }
          }).on("mouseout", function() {
            e._hovering = false, !e._dragging && e._clearHoverLinkToSeries();
          });
        }, t.prototype._enableHoverLinkFromSeries = function() {
          var e = this.api.getZr();
          this.visualMapModel.option.hoverLink ? (e.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), e.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
        }, t.prototype._doHoverLinkToSeries = function(e, i) {
          var r = this.visualMapModel, a = r.itemSize;
          if (r.option.hoverLink) {
            var o = [0, a[1]], s = r.getExtent();
            e = xY(_R(o[0], e), o[1]);
            var l = Qkt(r, s, o), u = [e - l, e + l], h = Yo(e, o, s, true), c = [Yo(u[0], o, s, true), Yo(u[1], o, s, true)];
            u[0] < o[0] && (c[0] = -1 / 0), u[1] > o[1] && (c[1] = 1 / 0), i && (c[0] === -1 / 0 ? this._showIndicator(h, c[1], "< ", l) : c[1] === 1 / 0 ? this._showIndicator(h, c[0], "> ", l) : this._showIndicator(h, h, " ", l));
            var f = this._hoverLinkDataIndices, g = [];
            (i || CY(r)) && (g = this._hoverLinkDataIndices = r.findTargetDataIndices(c));
            var d = jmt(f, g);
            this._dispatchHighDown("downplay", hE(d[0], r)), this._dispatchHighDown("highlight", hE(d[1], r));
          }
        }, t.prototype._hoverLinkFromSeriesMouseOver = function(e) {
          var i;
          if (Gh(e.target, function(l) {
            var u = Dt(l);
            if (u.dataIndex != null) return i = u, true;
          }, true), !!i) {
            var r = this.ecModel.getSeriesByIndex(i.seriesIndex), a = this.visualMapModel;
            if (a.isTargetSeries(r)) {
              var o = r.getData(i.dataType), s = o.getStore().get(a.getDataDimensionIndex(o), i.dataIndex);
              isNaN(s) || this._showIndicator(s, s);
            }
          }
        }, t.prototype._hideIndicator = function() {
          var e = this._shapes;
          e.indicator && e.indicator.attr("invisible", true), e.indicatorLabel && e.indicatorLabel.attr("invisible", true);
          var i = this._shapes.handleLabels;
          if (i) for (var r = 0; r < i.length; r++) this.api.leaveBlur(i[r]);
        }, t.prototype._clearHoverLinkToSeries = function() {
          this._hideIndicator();
          var e = this._hoverLinkDataIndices;
          this._dispatchHighDown("downplay", hE(e, this.visualMapModel)), e.length = 0;
        }, t.prototype._clearHoverLinkFromSeries = function() {
          this._hideIndicator();
          var e = this.api.getZr();
          e.off("mouseover", this._hoverLinkFromSeriesMouseOver), e.off("mouseout", this._hideIndicator);
        }, t.prototype._applyTransform = function(e, i, r, a) {
          var o = Lh(i, a ? null : this.group);
          return X(e) ? Xa(e, o, r) : f1(e, o, r);
        }, t.prototype._dispatchHighDown = function(e, i) {
          i && i.length && this.api.dispatchAction({ type: e, batch: i });
        }, t.prototype.dispose = function() {
          this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
        }, t.type = "visualMap.continuous", t;
      }(_Y);
      function wY(n, t, e, i) {
        return new Yi({ shape: { points: n }, draggable: !!e, cursor: t, drift: e, onmousemove: function(r) {
          Cs(r.event);
        }, ondragend: i });
      }
      function Qkt(n, t, e) {
        var i = Nkt / 2, r = n.get("hoverLinkDataSize");
        return r && (i = Yo(r, t, e, true) / 2), i;
      }
      function CY(n) {
        var t = n.get("hoverLinkOnHandle");
        return !!(t == null ? n.get("realtime") : t);
      }
      function SY(n) {
        return n === "vertical" ? "ns-resize" : "ew-resize";
      }
      var Okt = { type: "selectDataRange", event: "dataRangeSelected", update: "update" }, zkt = function(n, t) {
        t.eachComponent({ mainType: "visualMap", query: n }, function(e) {
          e.setSelected(n.selected);
        });
      }, Gkt = [{ createOnAllSeries: true, reset: function(n, t) {
        var e = [];
        return t.eachComponent("visualMap", function(i) {
          var r = n.pipelineContext;
          !i.isTargetSeries(n) || r && r.large || e.push(uNt(i.stateList, i.targetVisuals, ct(i.getValueState, i), i.getDataDimensionIndex(n.getData())));
        }), e;
      } }, { createOnAllSeries: true, reset: function(n, t) {
        var e = n.getData(), i = [];
        t.eachComponent("visualMap", function(r) {
          if (r.isTargetSeries(n)) {
            var a = r.getVisualMeta(ct(Ukt, null, n, r)) || { stops: [], outerColors: [] }, o = r.getDataDimensionIndex(e);
            o >= 0 && (a.dimension = o, i.push(a));
          }
        }), n.getData().setVisual("visualMeta", i);
      } }];
      function Ukt(n, t, e, i) {
        for (var r = t.targetVisuals[i], a = $n.prepareVisualTypes(r), o = { color: lv(n.getData(), "color") }, s = 0, l = a.length; s < l; s++) {
          var u = a[s], h = r[u === "opacity" ? "__alphaForOpacity" : u];
          h && h.applyVisual(e, c, f);
        }
        return o.color;
        function c(g) {
          return o[g];
        }
        function f(g, d) {
          o[g] = d;
        }
      }
      var bY = M;
      function Vkt(n) {
        var t = n && n.visualMap;
        X(t) || (t = t ? [t] : []), bY(t, function(e) {
          if (e) {
            dd(e, "splitList") && !dd(e, "pieces") && (e.pieces = e.splitList, delete e.splitList);
            var i = e.pieces;
            i && X(i) && bY(i, function(r) {
              _t(r) && (dd(r, "start") && !dd(r, "min") && (r.min = r.start), dd(r, "end") && !dd(r, "max") && (r.max = r.end));
            });
          }
        });
      }
      function dd(n, t) {
        return n && n.hasOwnProperty && n.hasOwnProperty(t);
      }
      var BY = false;
      function TY(n) {
        BY || (BY = true, n.registerSubTypeDefaulter("visualMap", function(t) {
          return !t.categories && (!(t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) || t.calculable) ? "continuous" : "piecewise";
        }), n.registerAction(Okt, zkt), M(Gkt, function(t) {
          n.registerVisual(n.PRIORITY.VISUAL.COMPONENT, t);
        }), n.registerPreprocessor(Vkt));
      }
      function MY(n) {
        n.registerComponentModel(Lkt), n.registerComponentView(Fkt), TY(n);
      }
      var jkt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._pieceList = [], e;
        }
        return t.prototype.optionUpdated = function(e, i) {
          n.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
          var r = this._mode = this._determineMode();
          this._pieceList = [], qkt[this._mode].call(this, this._pieceList), this._resetSelected(e, i);
          var a = this.option.categories;
          this.resetVisual(function(o, s) {
            r === "categories" ? (o.mappingMethod = "category", o.categories = xt(a)) : (o.dataExtent = this.getExtent(), o.mappingMethod = "piecewise", o.pieceList = Z(this._pieceList, function(l) {
              return l = xt(l), s !== "inRange" && (l.visual = null), l;
            }));
          });
        }, t.prototype.completeVisualOption = function() {
          var e = this.option, i = {}, r = $n.listVisualTypes(), a = this.isCategory();
          M(e.pieces, function(s) {
            M(r, function(l) {
              s.hasOwnProperty(l) && (i[l] = 1);
            });
          }), M(i, function(s, l) {
            var u = false;
            M(this.stateList, function(h) {
              u = u || o(e, h, l) || o(e.target, h, l);
            }, this), !u && M(this.stateList, function(h) {
              (e[h] || (e[h] = {}))[l] = AY.get(l, h === "inRange" ? "active" : "inactive", a);
            });
          }, this);
          function o(s, l, u) {
            return s && s[l] && s[l].hasOwnProperty(u);
          }
          n.prototype.completeVisualOption.apply(this, arguments);
        }, t.prototype._resetSelected = function(e, i) {
          var r = this.option, a = this._pieceList, o = (i ? r : e).selected || {};
          if (r.selected = o, M(a, function(l, u) {
            var h = this.getSelectedMapKey(l);
            o.hasOwnProperty(h) || (o[h] = true);
          }, this), r.selectedMode === "single") {
            var s = false;
            M(a, function(l, u) {
              var h = this.getSelectedMapKey(l);
              o[h] && (s ? o[h] = false : s = true);
            }, this);
          }
        }, t.prototype.getItemSymbol = function() {
          return this.get("itemSymbol");
        }, t.prototype.getSelectedMapKey = function(e) {
          return this._mode === "categories" ? e.value + "" : e.index + "";
        }, t.prototype.getPieceList = function() {
          return this._pieceList;
        }, t.prototype._determineMode = function() {
          var e = this.option;
          return e.pieces && e.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
        }, t.prototype.setSelected = function(e) {
          this.option.selected = xt(e);
        }, t.prototype.getValueState = function(e) {
          var i = $n.findPieceIndex(e, this._pieceList);
          return i != null && this.option.selected[this.getSelectedMapKey(this._pieceList[i])] ? "inRange" : "outOfRange";
        }, t.prototype.findTargetDataIndices = function(e) {
          var i = [], r = this._pieceList;
          return this.eachTargetSeries(function(a) {
            var o = [], s = a.getData();
            s.each(this.getDataDimensionIndex(s), function(l, u) {
              var h = $n.findPieceIndex(l, r);
              h === e && o.push(u);
            }, this), i.push({ seriesId: a.id, dataIndex: o });
          }, this), i;
        }, t.prototype.getRepresentValue = function(e) {
          var i;
          if (this.isCategory()) i = e.value;
          else if (e.value != null) i = e.value;
          else {
            var r = e.interval || [];
            i = r[0] === -1 / 0 && r[1] === 1 / 0 ? 0 : (r[0] + r[1]) / 2;
          }
          return i;
        }, t.prototype.getVisualMeta = function(e) {
          if (this.isCategory()) return;
          var i = [], r = ["", ""], a = this;
          function o(h, c) {
            var f = a.getRepresentValue({ interval: h });
            c || (c = a.getValueState(f));
            var g = e(f, c);
            h[0] === -1 / 0 ? r[0] = g : h[1] === 1 / 0 ? r[1] = g : i.push({ value: h[0], color: g }, { value: h[1], color: g });
          }
          var s = this._pieceList.slice();
          if (!s.length) s.push({ interval: [-1 / 0, 1 / 0] });
          else {
            var l = s[0].interval[0];
            l !== -1 / 0 && s.unshift({ interval: [-1 / 0, l] }), l = s[s.length - 1].interval[1], l !== 1 / 0 && s.push({ interval: [l, 1 / 0] });
          }
          var u = -1 / 0;
          return M(s, function(h) {
            var c = h.interval;
            c && (c[0] > u && o([u, c[0]], "outOfRange"), o(c.slice()), u = c[1]);
          }, this), { stops: i, outerColors: r };
        }, t.type = "visualMap.piecewise", t.defaultOption = eu(uE.defaultOption, { selected: null, minOpen: false, maxOpen: false, align: "auto", itemWidth: 20, itemHeight: 14, itemSymbol: "roundRect", pieces: null, categories: null, splitNumber: 5, selectedMode: "multiple", itemGap: 10, hoverLink: true }), t;
      }(uE), qkt = { splitNumber: function(n) {
        var t = this.option, e = Math.min(t.precision, 20), i = this.getExtent(), r = t.splitNumber;
        r = Math.max(parseInt(r, 10), 1), t.splitNumber = r;
        for (var a = (i[1] - i[0]) / r; +a.toFixed(e) !== a && e < 5; ) e++;
        t.precision = e, a = +a.toFixed(e), t.minOpen && n.push({ interval: [-1 / 0, i[0]], close: [0, 0] });
        for (var o = 0, s = i[0]; o < r; s += a, o++) {
          var l = o === r - 1 ? i[1] : s + a;
          n.push({ interval: [s, l], close: [1, 1] });
        }
        t.maxOpen && n.push({ interval: [i[1], 1 / 0], close: [0, 0] }), MG(n), M(n, function(u, h) {
          u.index = h, u.text = this.formatValueText(u.interval);
        }, this);
      }, categories: function(n) {
        var t = this.option;
        M(t.categories, function(e) {
          n.push({ text: this.formatValueText(e, true), value: e });
        }, this), DY(t, n);
      }, pieces: function(n) {
        var t = this.option;
        M(t.pieces, function(e, i) {
          _t(e) || (e = { value: e });
          var r = { text: "", index: i };
          if (e.label != null && (r.text = e.label), e.hasOwnProperty("value")) {
            var a = r.value = e.value;
            r.interval = [a, a], r.close = [1, 1];
          } else {
            for (var o = r.interval = [], s = r.close = [0, 0], l = [1, 0, 1], u = [-1 / 0, 1 / 0], h = [], c = 0; c < 2; c++) {
              for (var f = [["gte", "gt", "min"], ["lte", "lt", "max"]][c], g = 0; g < 3 && o[c] == null; g++) o[c] = e[f[g]], s[c] = l[g], h[c] = g === 2;
              o[c] == null && (o[c] = u[c]);
            }
            h[0] && o[1] === 1 / 0 && (s[0] = 0), h[1] && o[0] === -1 / 0 && (s[1] = 0), o[0] > o[1], o[0] === o[1] && s[0] && s[1] && (r.value = o[0]);
          }
          r.visual = $n.retrieveVisuals(e), n.push(r);
        }, this), DY(t, n), MG(n), M(n, function(e) {
          var i = e.close, r = [["<", ""][i[1]], [">", ""][i[0]]];
          e.text = e.text || this.formatValueText(e.value != null ? e.value : e.interval, false, r);
        }, this);
      } };
      function DY(n, t) {
        var e = n.inverse;
        (n.orient === "vertical" ? !e : e) && t.reverse();
      }
      var Hkt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.doRender = function() {
          var e = this.group;
          e.removeAll();
          var i = this.visualMapModel, r = i.get("textGap"), a = i.textStyleModel, o = a.getFont(), s = a.getTextColor(), l = this._getItemAlign(), u = i.itemSize, h = this._getViewData(), c = h.endsText, f = Dn(i.get("showLabel", true), !c);
          c && this._renderEndsText(e, c[0], u, f, l), M(h.viewPieceList, function(g) {
            var d = g.piece, A = new Ct();
            A.onclick = ct(this._onItemClick, this, d), this._enableHoverLink(A, g.indexInModelPieceList);
            var p = i.getRepresentValue(d);
            if (this._createItemSymbol(A, p, [0, 0, u[0], u[1]]), f) {
              var v = this.visualMapModel.getValueState(p);
              A.add(new ge({ style: { x: l === "right" ? -r : u[0] + r, y: u[1] / 2, text: d.text, verticalAlign: "middle", align: l, font: o, fill: s, opacity: v === "outOfRange" ? 0.5 : 1 } }));
            }
            e.add(A);
          }, this), c && this._renderEndsText(e, c[1], u, f, l), Fh(i.get("orient"), e, i.get("itemGap")), this.renderBackground(e), this.positionGroup(e);
        }, t.prototype._enableHoverLink = function(e, i) {
          var r = this;
          e.on("mouseover", function() {
            return a("highlight");
          }).on("mouseout", function() {
            return a("downplay");
          });
          var a = function(o) {
            var s = r.visualMapModel;
            s.option.hoverLink && r.api.dispatchAction({ type: o, batch: hE(s.findTargetDataIndices(i), s) });
          };
        }, t.prototype._getItemAlign = function() {
          var e = this.visualMapModel, i = e.option;
          if (i.orient === "vertical") return EY(e, this.api, e.itemSize);
          var r = i.align;
          return (!r || r === "auto") && (r = "left"), r;
        }, t.prototype._renderEndsText = function(e, i, r, a, o) {
          if (i) {
            var s = new Ct(), l = this.visualMapModel.textStyleModel;
            s.add(new ge({ style: Ke(l, { x: a ? o === "right" ? r[0] : 0 : r[0] / 2, y: r[1] / 2, verticalAlign: "middle", align: a ? o : "center", text: i }) })), e.add(s);
          }
        }, t.prototype._getViewData = function() {
          var e = this.visualMapModel, i = Z(e.getPieceList(), function(s, l) {
            return { piece: s, indexInModelPieceList: l };
          }), r = e.get("text"), a = e.get("orient"), o = e.get("inverse");
          return (a === "horizontal" ? o : !o) ? i.reverse() : r && (r = r.slice().reverse()), { viewPieceList: i, endsText: r };
        }, t.prototype._createItemSymbol = function(e, i, r) {
          e.add(Nn(this.getControllerVisual(i, "symbol"), r[0], r[1], r[2], r[3], this.getControllerVisual(i, "color")));
        }, t.prototype._onItemClick = function(e) {
          var i = this.visualMapModel, r = i.option, a = r.selectedMode;
          if (a) {
            var o = xt(r.selected), s = i.getSelectedMapKey(e);
            a === "single" || a === true ? (o[s] = true, M(o, function(l, u) {
              o[u] = u === s;
            })) : o[s] = !o[s], this.api.dispatchAction({ type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: o });
          }
        }, t.type = "visualMap.piecewise", t;
      }(_Y);
      function RY(n) {
        n.registerComponentModel(jkt), n.registerComponentView(Hkt), TY(n);
      }
      function Ykt(n) {
        Zt(MY), Zt(RY);
      }
      var Wkt = { label: { enabled: true }, decal: { show: false } }, LY = le(), Xkt = {};
      function Zkt(n, t) {
        var e = n.getModel("aria");
        if (!e.get("enabled")) return;
        var i = xt(Wkt);
        qt(i.label, n.getLocaleModel().get("aria"), false), qt(e.option, i, false), r(), a();
        function r() {
          var u = e.getModel("decal"), h = u.get("show");
          if (h) {
            var c = dt();
            n.eachSeries(function(f) {
              if (!f.isColorBySeries()) {
                var g = c.get(f.type);
                g || (g = {}, c.set(f.type, g)), LY(f).scope = g;
              }
            }), n.eachRawSeries(function(f) {
              if (n.isSeriesFiltered(f)) return;
              if (yt(f.enableAriaDecal)) {
                f.enableAriaDecal();
                return;
              }
              var g = f.getData();
              if (f.isColorBySeries()) {
                var y = _B(f.ecModel, f.name, Xkt, n.getSeriesCount()), m = g.getVisual("decal");
                g.setVisual("decal", _(m, y));
              } else {
                var d = f.getRawData(), A = {}, p = LY(f).scope;
                g.each(function(E) {
                  var I = g.getRawIndex(E);
                  A[I] = E;
                });
                var v = d.count();
                d.each(function(E) {
                  var I = A[E], x = d.getName(E) || E + "", w = _B(f.ecModel, x, p, v), C = g.getItemVisual(I, "decal");
                  g.setItemVisual(I, "decal", _(C, w));
                });
              }
              function _(E, I) {
                var x = E ? Y(Y({}, I), E) : I;
                return x.dirty = true, x;
              }
            });
          }
        }
        function a() {
          var u = t.getZr().dom;
          if (u) {
            var h = n.getLocaleModel().get("aria"), c = e.getModel("label");
            if (c.option = Et(c.option, h), !!c.get("enabled")) {
              if (c.get("description")) {
                u.setAttribute("aria-label", c.get("description"));
                return;
              }
              var f = n.getSeriesCount(), g = c.get(["data", "maxCount"]) || 10, d = c.get(["series", "maxCount"]) || 10, A = Math.min(f, d), p;
              if (!(f < 1)) {
                var v = s();
                if (v) {
                  var y = c.get(["general", "withTitle"]);
                  p = o(y, { title: v });
                } else p = c.get(["general", "withoutTitle"]);
                var m = [], _ = f > 1 ? c.get(["series", "multiple", "prefix"]) : c.get(["series", "single", "prefix"]);
                p += o(_, { seriesCount: f }), n.eachSeries(function(w, C) {
                  if (C < A) {
                    var S = void 0, b = w.get("name"), B = b ? "withName" : "withoutName";
                    S = f > 1 ? c.get(["series", "multiple", B]) : c.get(["series", "single", B]), S = o(S, { seriesId: w.seriesIndex, seriesName: w.get("name"), seriesType: l(w.subType) });
                    var T = w.getData();
                    if (T.count() > g) {
                      var D = c.get(["data", "partialData"]);
                      S += o(D, { displayCnt: g });
                    } else S += c.get(["data", "allData"]);
                    for (var R = c.get(["data", "separator", "middle"]), L = c.get(["data", "separator", "end"]), k = [], P = 0; P < T.count(); P++) if (P < g) {
                      var F = T.getName(P), Q = T.getValues(P), z = c.get(["data", F ? "withName" : "withoutName"]);
                      k.push(o(z, { name: F, value: Q.join(R) }));
                    }
                    S += k.join(R) + L, m.push(S);
                  }
                });
                var E = c.getModel(["series", "multiple", "separator"]), I = E.get("middle"), x = E.get("end");
                p += m.join(I) + x, u.setAttribute("aria-label", p);
              }
            }
          }
        }
        function o(u, h) {
          if (!ht(u)) return u;
          var c = u;
          return M(h, function(f, g) {
            c = c.replace(new RegExp("\\{\\s*" + g + "\\s*\\}", "g"), f);
          }), c;
        }
        function s() {
          var u = n.get("title");
          return u && u.length && (u = u[0]), u && u.text;
        }
        function l(u) {
          var h = n.getLocaleModel().get(["series", "typeNames"]);
          return h[u] || h.chart;
        }
      }
      function Kkt(n) {
        if (!(!n || !n.aria)) {
          var t = n.aria;
          t.show != null && (t.enabled = t.show), t.label = t.label || {}, M(["description", "general", "series", "data"], function(e) {
            t[e] != null && (t.label[e] = t[e]);
          });
        }
      }
      function $kt(n) {
        n.registerPreprocessor(Kkt), n.registerVisual(n.PRIORITY.VISUAL.ARIA, Zkt);
      }
      var PY = { value: "eq", "<": "lt", "<=": "lte", ">": "gt", ">=": "gte", "=": "eq", "!=": "ne", "<>": "ne" }, Jkt = function() {
        function n(t) {
          var e = this._condVal = ht(t) ? new RegExp(t) : Ez(t) ? t : null;
          if (e == null) {
            var i = "";
            i = vr("Illegal regexp", t, "in"), Ce(i);
          }
        }
        return n.prototype.evaluate = function(t) {
          var e = typeof t;
          return ht(e) ? this._condVal.test(t) : pe(e) ? this._condVal.test(t + "") : false;
        }, n;
      }(), tFt = function() {
        function n() {
        }
        return n.prototype.evaluate = function() {
          return this.value;
        }, n;
      }(), eFt = function() {
        function n() {
        }
        return n.prototype.evaluate = function() {
          for (var t = this.children, e = 0; e < t.length; e++) if (!t[e].evaluate()) return false;
          return true;
        }, n;
      }(), nFt = function() {
        function n() {
        }
        return n.prototype.evaluate = function() {
          for (var t = this.children, e = 0; e < t.length; e++) if (t[e].evaluate()) return true;
          return false;
        }, n;
      }(), iFt = function() {
        function n() {
        }
        return n.prototype.evaluate = function() {
          return !this.child.evaluate();
        }, n;
      }(), rFt = function() {
        function n() {
        }
        return n.prototype.evaluate = function() {
          for (var t = !!this.valueParser, e = this.getValue, i = e(this.valueGetterParam), r = t ? this.valueParser(i) : null, a = 0; a < this.subCondList.length; a++) if (!this.subCondList[a].evaluate(t ? r : i)) return false;
          return true;
        }, n;
      }();
      function IR(n, t) {
        if (n === true || n === false) {
          var e = new tFt();
          return e.value = n, e;
        }
        var i = "";
        return kY(n) || (i = vr("Illegal config. Expect a plain object but actually", n), Ce(i)), n.and ? NY("and", n, t) : n.or ? NY("or", n, t) : n.not ? aFt(n, t) : oFt(n, t);
      }
      function NY(n, t, e) {
        var i = t[n], r = "";
        r = vr('"and"/"or" condition should only be `' + n + ": [...]` and must not be empty array.", "Illegal condition:", t), X(i) || Ce(r), i.length || Ce(r);
        var a = n === "and" ? new eFt() : new nFt();
        return a.children = Z(i, function(o) {
          return IR(o, e);
        }), a.children.length || Ce(r), a;
      }
      function aFt(n, t) {
        var e = n.not, i = "";
        i = vr('"not" condition should only be `not: {}`.', "Illegal condition:", n), kY(e) || Ce(i);
        var r = new iFt();
        return r.child = IR(e, t), r.child || Ce(i), r;
      }
      function oFt(n, t) {
        for (var e = "", i = t.prepareGetValue(n), r = [], a = re(n), o = n.parser, s = o ? d8(o) : null, l = 0; l < a.length; l++) {
          var u = a[l];
          if (!(u === "parser" || t.valueGetterAttrMap.get(u))) {
            var h = ft(PY, u) ? PY[u] : u, c = n[u], f = s ? s(c) : c, g = XIt(h, f) || h === "reg" && new Jkt(f);
            g || (e = vr('Illegal relational operation: "' + u + '" in condition:', n), Ce(e)), r.push(g);
          }
        }
        r.length || (e = vr("Relational condition must have at least one operator.", "Illegal condition:", n), Ce(e));
        var d = new rFt();
        return d.valueGetterParam = i, d.valueParser = s, d.getValue = t.getValue, d.subCondList = r, d;
      }
      function kY(n) {
        return _t(n) && !Mi(n);
      }
      var sFt = function() {
        function n(t, e) {
          this._cond = IR(t, e);
        }
        return n.prototype.evaluate = function() {
          return this._cond.evaluate();
        }, n;
      }();
      function lFt(n, t) {
        return new sFt(n, t);
      }
      var uFt = { type: "echarts:filter", transform: function(n) {
        for (var t = n.upstream, e, i = lFt(n.config, { valueGetterAttrMap: dt({ dimension: true }), prepareGetValue: function(s) {
          var l = "", u = s.dimension;
          ft(s, "dimension") || (l = vr('Relation condition must has prop "dimension" specified.', "Illegal condition:", s), Ce(l));
          var h = t.getDimensionInfo(u);
          return h || (l = vr("Can not find dimension info via: " + u + `.
`, "Existing dimensions: ", t.cloneAllDimensionInfo(), `.
`, "Illegal condition:", s, `.
`), Ce(l)), { dimIdx: h.index };
        }, getValue: function(s) {
          return t.retrieveValueFromItem(e, s.dimIdx);
        } }), r = [], a = 0, o = t.count(); a < o; a++) e = t.getRawDataItem(a), i.evaluate() && r.push(e);
        return { data: r };
      } }, ER = "";
      ER = ["Valid config is like:", '{ dimension: "age", order: "asc" }', 'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'].join(" ");
      var hFt = { type: "echarts:sort", transform: function(n) {
        var t = n.upstream, e = n.config, i = "", r = Qe(e);
        r.length || (i = "Empty `config` in sort transform.", Ce(i));
        var a = [];
        M(r, function(h) {
          var c = h.dimension, f = h.order, g = h.parser, d = h.incomparable;
          if (c == null && (i = 'Sort transform config must has "dimension" specified.' + ER, Ce(i)), f !== "asc" && f !== "desc" && (i = 'Sort transform config must has "order" specified.' + ER, Ce(i)), d && d !== "min" && d !== "max") {
            var A = "";
            A = 'incomparable must be "min" or "max" rather than "' + d + '".', Ce(A);
          }
          if (f !== "asc" && f !== "desc") {
            var p = "";
            p = 'order must be "asc" or "desc" rather than "' + f + '".', Ce(p);
          }
          var v = t.getDimensionInfo(c);
          v || (i = vr("Can not find dimension info via: " + c + `.
`, "Existing dimensions: ", t.cloneAllDimensionInfo(), `.
`, "Illegal config:", h, `.
`), Ce(i));
          var y = g ? d8(g) : null;
          g && !y && (i = vr("Invalid parser name " + g + `.
`, "Illegal config:", h, `.
`), Ce(i)), a.push({ dimIdx: v.index, parser: y, comparator: new p8(f, d) });
        });
        var o = t.sourceFormat;
        o !== Ri && o !== Aa && (i = 'sourceFormat "' + o + '" is not supported yet', Ce(i));
        for (var s = [], l = 0, u = t.count(); l < u; l++) s.push(t.getRawDataItem(l));
        return s.sort(function(h, c) {
          for (var f = 0; f < a.length; f++) {
            var g = a[f], d = t.retrieveValueFromItem(h, g.dimIdx), A = t.retrieveValueFromItem(c, g.dimIdx);
            g.parser && (d = g.parser(d), A = g.parser(A));
            var p = g.comparator.evaluate(d, A);
            if (p !== 0) return p;
          }
          return 0;
        }), { data: s };
      } };
      function cFt(n) {
        n.registerTransform(uFt), n.registerTransform(hFt);
      }
      var fFt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "dataset", e;
        }
        return t.prototype.init = function(e, i, r) {
          n.prototype.init.call(this, e, i, r), this._sourceManager = new E8(this), x8(this);
        }, t.prototype.mergeOption = function(e, i) {
          n.prototype.mergeOption.call(this, e, i), x8(this);
        }, t.prototype.optionUpdated = function() {
          this._sourceManager.dirty();
        }, t.prototype.getSourceManager = function() {
          return this._sourceManager;
        }, t.type = "dataset", t.defaultOption = { seriesLayoutBy: Oo }, t;
      }(ne), gFt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "dataset", e;
        }
        return t.type = "dataset", t;
      }(on);
      function dFt(n) {
        n.registerComponentModel(fFt), n.registerComponentView(gFt);
      }
      var Wo = ko.CMD;
      function Ad(n, t) {
        return Math.abs(n - t) < 1e-5;
      }
      function xR(n) {
        var t = n.data, e = n.len(), i = [], r, a = 0, o = 0, s = 0, l = 0;
        function u(T, D) {
          r && r.length > 2 && i.push(r), r = [T, D];
        }
        function h(T, D, R, L) {
          Ad(T, R) && Ad(D, L) || r.push(T, D, R, L, R, L);
        }
        function c(T, D, R, L, k, P) {
          var F = Math.abs(D - T), Q = Math.tan(F / 4) * 4 / 3, z = D < T ? -1 : 1, j = Math.cos(T), $ = Math.sin(T), G = Math.cos(D), tt = Math.sin(D), J = j * k + R, et = $ * P + L, nt = G * k + R, gt = tt * P + L, H = k * Q * z, W = P * Q * z;
          r.push(J - H * $, et + W * j, nt + H * tt, gt - W * G, nt, gt);
        }
        for (var f, g, d, A, p = 0; p < e; ) {
          var v = t[p++], y = p === 1;
          switch (y && (a = t[p], o = t[p + 1], s = a, l = o, (v === Wo.L || v === Wo.C || v === Wo.Q) && (r = [s, l])), v) {
            case Wo.M:
              a = s = t[p++], o = l = t[p++], u(s, l);
              break;
            case Wo.L:
              f = t[p++], g = t[p++], h(a, o, f, g), a = f, o = g;
              break;
            case Wo.C:
              r.push(t[p++], t[p++], t[p++], t[p++], a = t[p++], o = t[p++]);
              break;
            case Wo.Q:
              f = t[p++], g = t[p++], d = t[p++], A = t[p++], r.push(a + 2 / 3 * (f - a), o + 2 / 3 * (g - o), d + 2 / 3 * (f - d), A + 2 / 3 * (g - A), d, A), a = d, o = A;
              break;
            case Wo.A:
              var m = t[p++], _ = t[p++], E = t[p++], I = t[p++], x = t[p++], w = t[p++] + x;
              p += 1;
              var C = !t[p++];
              f = Math.cos(x) * E + m, g = Math.sin(x) * I + _, y ? (s = f, l = g, u(s, l)) : h(a, o, f, g), a = Math.cos(w) * E + m, o = Math.sin(w) * I + _;
              for (var S = (C ? -1 : 1) * Math.PI / 2, b = x; C ? b > w : b < w; b += S) {
                var B = C ? Math.max(b + S, w) : Math.min(b + S, w);
                c(b, B, m, _, E, I);
              }
              break;
            case Wo.R:
              s = a = t[p++], l = o = t[p++], f = s + t[p++], g = l + t[p++], u(f, l), h(f, l, f, g), h(f, g, s, g), h(s, g, s, l), h(s, l, f, l);
              break;
            case Wo.Z:
              r && h(a, o, s, l), a = s, o = l;
              break;
          }
        }
        return r && r.length > 2 && i.push(r), i;
      }
      function wR(n, t, e, i, r, a, o, s, l, u) {
        if (Ad(n, e) && Ad(t, i) && Ad(r, o) && Ad(a, s)) {
          l.push(o, s);
          return;
        }
        var h = 2 / u, c = h * h, f = o - n, g = s - t, d = Math.sqrt(f * f + g * g);
        f /= d, g /= d;
        var A = e - n, p = i - t, v = r - o, y = a - s, m = A * A + p * p, _ = v * v + y * y;
        if (m < c && _ < c) {
          l.push(o, s);
          return;
        }
        var E = f * A + g * p, I = -f * v - g * y, x = m - E * E, w = _ - I * I;
        if (x < c && E >= 0 && w < c && I >= 0) {
          l.push(o, s);
          return;
        }
        var C = [], S = [];
        ql(n, e, r, o, 0.5, C), ql(t, i, a, s, 0.5, S), wR(C[0], S[0], C[1], S[1], C[2], S[2], C[3], S[3], l, u), wR(C[4], S[4], C[5], S[5], C[6], S[6], C[7], S[7], l, u);
      }
      function AFt(n, t) {
        var e = xR(n), i = [];
        t = t || 1;
        for (var r = 0; r < e.length; r++) {
          var a = e[r], o = [], s = a[0], l = a[1];
          o.push(s, l);
          for (var u = 2; u < a.length; ) {
            var h = a[u++], c = a[u++], f = a[u++], g = a[u++], d = a[u++], A = a[u++];
            wR(s, l, h, c, f, g, d, A, o, t), s = d, l = A;
          }
          i.push(o);
        }
        return i;
      }
      function FY(n, t, e) {
        var i = n[t], r = n[1 - t], a = Math.abs(i / r), o = Math.ceil(Math.sqrt(a * e)), s = Math.floor(e / o);
        s === 0 && (s = 1, o = e);
        for (var l = [], u = 0; u < o; u++) l.push(s);
        var h = o * s, c = e - h;
        if (c > 0) for (var u = 0; u < c; u++) l[u % o] += 1;
        return l;
      }
      function QY(n, t, e) {
        for (var i = n.r0, r = n.r, a = n.startAngle, o = n.endAngle, s = Math.abs(o - a), l = s * r, u = r - i, h = l > Math.abs(u), c = FY([l, u], h ? 0 : 1, t), f = (h ? s : u) / c.length, g = 0; g < c.length; g++) for (var d = (h ? u : s) / c[g], A = 0; A < c[g]; A++) {
          var p = {};
          h ? (p.startAngle = a + f * g, p.endAngle = a + f * (g + 1), p.r0 = i + d * A, p.r = i + d * (A + 1)) : (p.startAngle = a + d * A, p.endAngle = a + d * (A + 1), p.r0 = i + f * g, p.r = i + f * (g + 1)), p.clockwise = n.clockwise, p.cx = n.cx, p.cy = n.cy, e.push(p);
        }
      }
      function pFt(n, t, e) {
        for (var i = n.width, r = n.height, a = i > r, o = FY([i, r], a ? 0 : 1, t), s = a ? "width" : "height", l = a ? "height" : "width", u = a ? "x" : "y", h = a ? "y" : "x", c = n[s] / o.length, f = 0; f < o.length; f++) for (var g = n[l] / o[f], d = 0; d < o[f]; d++) {
          var A = {};
          A[u] = f * c, A[h] = d * g, A[s] = c, A[l] = g, A.x += n.x, A.y += n.y, e.push(A);
        }
      }
      function OY(n, t, e, i) {
        return n * i - e * t;
      }
      function vFt(n, t, e, i, r, a, o, s) {
        var l = e - n, u = i - t, h = o - r, c = s - a, f = OY(h, c, l, u);
        if (Math.abs(f) < 1e-6) return null;
        var g = n - r, d = t - a, A = OY(g, d, h, c) / f;
        return A < 0 || A > 1 ? null : new Ut(A * l + n, A * u + t);
      }
      function yFt(n, t, e) {
        var i = new Ut();
        Ut.sub(i, e, t), i.normalize();
        var r = new Ut();
        Ut.sub(r, n, t);
        var a = r.dot(i);
        return a;
      }
      function pd(n, t) {
        var e = n[n.length - 1];
        e && e[0] === t[0] && e[1] === t[1] || n.push(t);
      }
      function mFt(n, t, e) {
        for (var i = n.length, r = [], a = 0; a < i; a++) {
          var o = n[a], s = n[(a + 1) % i], l = vFt(o[0], o[1], s[0], s[1], t.x, t.y, e.x, e.y);
          l && r.push({ projPt: yFt(l, t, e), pt: l, idx: a });
        }
        if (r.length < 2) return [{ points: n }, { points: n }];
        r.sort(function(p, v) {
          return p.projPt - v.projPt;
        });
        var u = r[0], h = r[r.length - 1];
        if (h.idx < u.idx) {
          var c = u;
          u = h, h = c;
        }
        for (var f = [u.pt.x, u.pt.y], g = [h.pt.x, h.pt.y], d = [f], A = [g], a = u.idx + 1; a <= h.idx; a++) pd(d, n[a].slice());
        pd(d, g), pd(d, f);
        for (var a = h.idx + 1; a <= u.idx + i; a++) pd(A, n[a % i].slice());
        return pd(A, f), pd(A, g), [{ points: d }, { points: A }];
      }
      function zY(n) {
        var t = n.points, e = [], i = [];
        Y_(t, e, i);
        var r = new Ht(e[0], e[1], i[0] - e[0], i[1] - e[1]), a = r.width, o = r.height, s = r.x, l = r.y, u = new Ut(), h = new Ut();
        return a > o ? (u.x = h.x = s + a / 2, u.y = l, h.y = l + o) : (u.y = h.y = l + o / 2, u.x = s, h.x = s + a), mFt(t, u, h);
      }
      function cE(n, t, e, i) {
        if (e === 1) i.push(t);
        else {
          var r = Math.floor(e / 2), a = n(t);
          cE(n, a[0], r, i), cE(n, a[1], e - r, i);
        }
        return i;
      }
      function _Ft(n, t) {
        for (var e = [], i = 0; i < t; i++) e.push(W2(n));
        return e;
      }
      function IFt(n, t) {
        t.setStyle(n.style), t.z = n.z, t.z2 = n.z2, t.zlevel = n.zlevel;
      }
      function EFt(n) {
        for (var t = [], e = 0; e < n.length; ) t.push([n[e++], n[e++]]);
        return t;
      }
      function xFt(n, t) {
        var e = [], i = n.shape, r;
        switch (n.type) {
          case "rect":
            pFt(i, t, e), r = ue;
            break;
          case "sector":
            QY(i, t, e), r = Hi;
            break;
          case "circle":
            QY({ r0: 0, r: i.r, startAngle: 0, endAngle: Math.PI * 2, cx: i.cx, cy: i.cy }, t, e), r = Hi;
            break;
          default:
            var a = n.getComputedTransform(), o = a ? Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1], a[2] * a[2] + a[3] * a[3])) : 1, s = Z(AFt(n.getUpdatedPathProxy(), o), function(v) {
              return EFt(v);
            }), l = s.length;
            if (l === 0) cE(zY, { points: s[0] }, t, e);
            else if (l === t) for (var u = 0; u < l; u++) e.push({ points: s[u] });
            else {
              var h = 0, c = Z(s, function(v) {
                var y = [], m = [];
                Y_(v, y, m);
                var _ = (m[1] - y[1]) * (m[0] - y[0]);
                return h += _, { poly: v, area: _ };
              });
              c.sort(function(v, y) {
                return y.area - v.area;
              });
              for (var f = t, u = 0; u < l; u++) {
                var g = c[u];
                if (f <= 0) break;
                var d = u === l - 1 ? f : Math.ceil(g.area / h * t);
                d < 0 || (cE(zY, { points: g.poly }, d, e), f -= d);
              }
            }
            r = Yi;
            break;
        }
        if (!r) return _Ft(n, t);
        for (var A = [], u = 0; u < e.length; u++) {
          var p = new r();
          p.setShape(e[u]), IFt(n, p), A.push(p);
        }
        return A;
      }
      function wFt(n, t) {
        var e = n.length, i = t.length;
        if (e === i) return [n, t];
        for (var r = [], a = [], o = e < i ? n : t, s = Math.min(e, i), l = Math.abs(i - e) / 6, u = (s - 2) / 6, h = Math.ceil(l / u) + 1, c = [o[0], o[1]], f = l, g = 2; g < s; ) {
          var d = o[g - 2], A = o[g - 1], p = o[g++], v = o[g++], y = o[g++], m = o[g++], _ = o[g++], E = o[g++];
          if (f <= 0) {
            c.push(p, v, y, m, _, E);
            continue;
          }
          for (var I = Math.min(f, h - 1) + 1, x = 1; x <= I; x++) {
            var w = x / I;
            ql(d, p, y, _, w, r), ql(A, v, m, E, w, a), d = r[3], A = a[3], c.push(r[1], a[1], r[2], a[2], d, A), p = r[5], v = a[5], y = r[6], m = a[6];
          }
          f -= I - 1;
        }
        return o === n ? [c, t] : [n, c];
      }
      function GY(n, t) {
        for (var e = n.length, i = n[e - 2], r = n[e - 1], a = [], o = 0; o < t.length; ) a[o++] = i, a[o++] = r;
        return a;
      }
      function CFt(n, t) {
        for (var e, i, r, a = [], o = [], s = 0; s < Math.max(n.length, t.length); s++) {
          var l = n[s], u = t[s], h = void 0, c = void 0;
          l ? u ? (e = wFt(l, u), h = e[0], c = e[1], i = h, r = c) : (c = GY(r || l, l), h = l) : (h = GY(i || u, u), c = u), a.push(h), o.push(c);
        }
        return [a, o];
      }
      function UY(n) {
        for (var t = 0, e = 0, i = 0, r = n.length, a = 0, o = r - 2; a < r; o = a, a += 2) {
          var s = n[o], l = n[o + 1], u = n[a], h = n[a + 1], c = s * h - u * l;
          t += c, e += (s + u) * c, i += (l + h) * c;
        }
        return t === 0 ? [n[0] || 0, n[1] || 0] : [e / t / 3, i / t / 3, t];
      }
      function SFt(n, t, e, i) {
        for (var r = (n.length - 2) / 6, a = 1 / 0, o = 0, s = n.length, l = s - 2, u = 0; u < r; u++) {
          for (var h = u * 6, c = 0, f = 0; f < s; f += 2) {
            var g = f === 0 ? h : (h + f - 2) % l + 2, d = n[g] - e[0], A = n[g + 1] - e[1], p = t[f] - i[0], v = t[f + 1] - i[1], y = p - d, m = v - A;
            c += y * y + m * m;
          }
          c < a && (a = c, o = u);
        }
        return o;
      }
      function bFt(n) {
        for (var t = [], e = n.length, i = 0; i < e; i += 2) t[i] = n[e - i - 2], t[i + 1] = n[e - i - 1];
        return t;
      }
      function BFt(n, t, e, i) {
        for (var r = [], a, o = 0; o < n.length; o++) {
          var s = n[o], l = t[o], u = UY(s), h = UY(l);
          a == null && (a = u[2] < 0 != h[2] < 0);
          var c = [], f = [], g = 0, d = 1 / 0, A = [], p = s.length;
          a && (s = bFt(s));
          for (var v = SFt(s, l, u, h) * 6, y = p - 2, m = 0; m < y; m += 2) {
            var _ = (v + m) % y + 2;
            c[m + 2] = s[_] - u[0], c[m + 3] = s[_ + 1] - u[1];
          }
          c[0] = s[v] - u[0], c[1] = s[v + 1] - u[1];
          for (var E = i / e, I = -i / 2; I <= i / 2; I += E) {
            for (var x = Math.sin(I), w = Math.cos(I), C = 0, m = 0; m < s.length; m += 2) {
              var S = c[m], b = c[m + 1], B = l[m] - h[0], T = l[m + 1] - h[1], D = B * w - T * x, R = B * x + T * w;
              A[m] = D, A[m + 1] = R;
              var L = D - S, k = R - b;
              C += L * L + k * k;
            }
            if (C < d) {
              d = C, g = I;
              for (var P = 0; P < A.length; P++) f[P] = A[P];
            }
          }
          r.push({ from: c, to: f, fromCp: u, toCp: h, rotation: -g });
        }
        return r;
      }
      function fE(n) {
        return n.__isCombineMorphing;
      }
      var VY = "__mOriginal_";
      function gE(n, t, e) {
        var i = VY + t, r = n[i] || n[t];
        n[i] || (n[i] = n[t]);
        var a = e.replace, o = e.after, s = e.before;
        n[t] = function() {
          var l = arguments, u;
          return s && s.apply(this, l), a ? u = a.apply(this, l) : u = r.apply(this, l), o && o.apply(this, l), u;
        };
      }
      function ay(n, t) {
        var e = VY + t;
        n[e] && (n[t] = n[e], n[e] = null);
      }
      function jY(n, t) {
        for (var e = 0; e < n.length; e++) for (var i = n[e], r = 0; r < i.length; ) {
          var a = i[r], o = i[r + 1];
          i[r++] = t[0] * a + t[2] * o + t[4], i[r++] = t[1] * a + t[3] * o + t[5];
        }
      }
      function qY(n, t) {
        var e = n.getUpdatedPathProxy(), i = t.getUpdatedPathProxy(), r = CFt(xR(e), xR(i)), a = r[0], o = r[1], s = n.getComputedTransform(), l = t.getComputedTransform();
        function u() {
          this.transform = null;
        }
        s && jY(a, s), l && jY(o, l), gE(t, "updateTransform", { replace: u }), t.transform = null;
        var h = BFt(a, o, 10, Math.PI), c = [];
        gE(t, "buildPath", { replace: function(f) {
          for (var g = t.__morphT, d = 1 - g, A = [], p = 0; p < h.length; p++) {
            var v = h[p], y = v.from, m = v.to, _ = v.rotation * g, E = v.fromCp, I = v.toCp, x = Math.sin(_), w = Math.cos(_);
            g_(A, E, I, g);
            for (var C = 0; C < y.length; C += 2) {
              var S = y[C], b = y[C + 1], B = m[C], T = m[C + 1], D = S * d + B * g, R = b * d + T * g;
              c[C] = D * w - R * x + A[0], c[C + 1] = D * x + R * w + A[1];
            }
            var L = c[0], k = c[1];
            f.moveTo(L, k);
            for (var C = 2; C < y.length; ) {
              var B = c[C++], T = c[C++], P = c[C++], F = c[C++], Q = c[C++], z = c[C++];
              L === B && k === T && P === Q && F === z ? f.lineTo(Q, z) : f.bezierCurveTo(B, T, P, F, Q, z), L = Q, k = z;
            }
          }
        } });
      }
      function CR(n, t, e) {
        if (!n || !t) return t;
        var i = e.done, r = e.during;
        qY(n, t), t.__morphT = 0;
        function a() {
          ay(t, "buildPath"), ay(t, "updateTransform"), t.__morphT = -1, t.createPathProxy(), t.dirtyShape();
        }
        return t.animateTo({ __morphT: 1 }, Et({ during: function(o) {
          t.dirtyShape(), r && r(o);
        }, done: function() {
          a(), i && i();
        } }, e)), t;
      }
      function TFt(n, t, e, i, r, a) {
        var o = 16;
        n = r === e ? 0 : Math.round(32767 * (n - e) / (r - e)), t = a === i ? 0 : Math.round(32767 * (t - i) / (a - i));
        for (var s = 0, l, u = (1 << o) / 2; u > 0; u /= 2) {
          var h = 0, c = 0;
          (n & u) > 0 && (h = 1), (t & u) > 0 && (c = 1), s += u * u * (3 * h ^ c), c === 0 && (h === 1 && (n = u - 1 - n, t = u - 1 - t), l = n, n = t, t = l);
        }
        return s;
      }
      function dE(n) {
        var t = 1 / 0, e = 1 / 0, i = -1 / 0, r = -1 / 0, a = Z(n, function(s) {
          var l = s.getBoundingRect(), u = s.getComputedTransform(), h = l.x + l.width / 2 + (u ? u[4] : 0), c = l.y + l.height / 2 + (u ? u[5] : 0);
          return t = Math.min(h, t), e = Math.min(c, e), i = Math.max(h, i), r = Math.max(c, r), [h, c];
        }), o = Z(a, function(s, l) {
          return { cp: s, z: TFt(s[0], s[1], t, e, i, r), path: n[l] };
        });
        return o.sort(function(s, l) {
          return s.z - l.z;
        }).map(function(s) {
          return s.path;
        });
      }
      function HY(n) {
        return xFt(n.path, n.count);
      }
      function SR() {
        return { fromIndividuals: [], toIndividuals: [], count: 0 };
      }
      function MFt(n, t, e) {
        var i = [];
        function r(E) {
          for (var I = 0; I < E.length; I++) {
            var x = E[I];
            fE(x) ? r(x.childrenRef()) : x instanceof Jt && i.push(x);
          }
        }
        r(n);
        var a = i.length;
        if (!a) return SR();
        var o = e.dividePath || HY, s = o({ path: t, count: a });
        if (s.length !== a) return SR();
        i = dE(i), s = dE(s);
        for (var l = e.done, u = e.during, h = e.individualDelay, c = new Ts(), f = 0; f < a; f++) {
          var g = i[f], d = s[f];
          d.parent = t, d.copyTransform(c), h || qY(g, d);
        }
        t.__isCombineMorphing = true, t.childrenRef = function() {
          return s;
        };
        function A(E) {
          for (var I = 0; I < s.length; I++) s[I].addSelfToZr(E);
        }
        gE(t, "addSelfToZr", { after: function(E) {
          A(E);
        } }), gE(t, "removeSelfFromZr", { after: function(E) {
          for (var I = 0; I < s.length; I++) s[I].removeSelfFromZr(E);
        } });
        function p() {
          t.__isCombineMorphing = false, t.__morphT = -1, t.childrenRef = null, ay(t, "addSelfToZr"), ay(t, "removeSelfFromZr");
        }
        var v = s.length;
        if (h) for (var y = v, m = function() {
          y--, y === 0 && (p(), l && l());
        }, f = 0; f < v; f++) {
          var _ = h ? Et({ delay: (e.delay || 0) + h(f, v, i[f], s[f]), done: m }, e) : e;
          CR(i[f], s[f], _);
        }
        else t.__morphT = 0, t.animateTo({ __morphT: 1 }, Et({ during: function(E) {
          for (var I = 0; I < v; I++) {
            var x = s[I];
            x.__morphT = t.__morphT, x.dirtyShape();
          }
          u && u(E);
        }, done: function() {
          p();
          for (var E = 0; E < n.length; E++) ay(n[E], "updateTransform");
          l && l();
        } }, e));
        return t.__zr && A(t.__zr), { fromIndividuals: i, toIndividuals: s, count: v };
      }
      function DFt(n, t, e) {
        var i = t.length, r = [], a = e.dividePath || HY;
        function o(g) {
          for (var d = 0; d < g.length; d++) {
            var A = g[d];
            fE(A) ? o(A.childrenRef()) : A instanceof Jt && r.push(A);
          }
        }
        if (fE(n)) {
          o(n.childrenRef());
          var s = r.length;
          if (s < i) for (var l = 0, u = s; u < i; u++) r.push(W2(r[l++ % s]));
          r.length = i;
        } else {
          r = a({ path: n, count: i });
          for (var h = n.getComputedTransform(), u = 0; u < r.length; u++) r[u].setLocalTransform(h);
          if (r.length !== i) return SR();
        }
        r = dE(r), t = dE(t);
        for (var c = e.individualDelay, u = 0; u < i; u++) {
          var f = c ? Et({ delay: (e.delay || 0) + c(u, i, r[u], t[u]) }, e) : e;
          CR(r[u], t[u], f);
        }
        return { fromIndividuals: r, toIndividuals: t, count: t.length };
      }
      function YY(n) {
        return X(n[0]);
      }
      function WY(n, t) {
        for (var e = [], i = n.length, r = 0; r < i; r++) e.push({ one: n[r], many: [] });
        for (var r = 0; r < t.length; r++) {
          var a = t[r].length, o = void 0;
          for (o = 0; o < a; o++) e[o % i].many.push(t[r][o]);
        }
        for (var s = 0, r = i - 1; r >= 0; r--) if (!e[r].many.length) {
          var l = e[s].many;
          if (l.length <= 1) if (s) s = 0;
          else return e;
          var a = l.length, u = Math.ceil(a / 2);
          e[r].many = l.slice(u, a), e[s].many = l.slice(0, u), s++;
        }
        return e;
      }
      var RFt = { clone: function(n) {
        for (var t = [], e = 1 - Math.pow(1 - n.path.style.opacity, 1 / n.count), i = 0; i < n.count; i++) {
          var r = W2(n.path);
          r.setStyle("opacity", e), t.push(r);
        }
        return t;
      }, split: null };
      function bR(n, t, e, i, r, a) {
        if (!n.length || !t.length) return;
        var o = wg("update", i, r);
        if (!(o && o.duration > 0)) return;
        var s = i.getModel("universalTransition").get("delay"), l = Object.assign({ setToFinal: true }, o), u, h;
        YY(n) && (u = n, h = t), YY(t) && (u = t, h = n);
        function c(v, y, m, _, E) {
          var I = v.many, x = v.one;
          if (I.length === 1 && !E) {
            var w = y ? I[0] : x, C = y ? x : I[0];
            if (fE(w)) c({ many: [w], one: C }, true, m, _, true);
            else {
              var S = s ? Et({ delay: s(m, _) }, l) : l;
              CR(w, C, S), a(w, C, w, C, S);
            }
          } else for (var b = Et({ dividePath: RFt[e], individualDelay: s && function(k, P, F, Q) {
            return s(k + m, _);
          } }, l), B = y ? MFt(I, x, b) : DFt(x, I, b), T = B.fromIndividuals, D = B.toIndividuals, R = T.length, L = 0; L < R; L++) {
            var S = s ? Et({ delay: s(L, R) }, l) : l;
            a(T[L], D[L], y ? I[L] : v.one, y ? v.one : I[L], S);
          }
        }
        for (var f = u ? u === n : n.length > t.length, g = u ? WY(h, u) : WY(f ? t : n, [f ? n : t]), d = 0, A = 0; A < g.length; A++) d += g[A].many.length;
        for (var p = 0, A = 0; A < g.length; A++) c(g[A], f, p, d), p += g[A].many.length;
      }
      function dc(n) {
        if (!n) return [];
        if (X(n)) {
          for (var t = [], e = 0; e < n.length; e++) t.push(dc(n[e]));
          return t;
        }
        var i = [];
        return n.traverse(function(r) {
          r instanceof Jt && !r.disableMorphing && !r.invisible && !r.ignore && i.push(r);
        }), i;
      }
      var XY = 1e4, LFt = 0, ZY = 1, KY = 2, PFt = le();
      function NFt(n, t) {
        for (var e = n.dimensions, i = 0; i < e.length; i++) {
          var r = n.getDimensionInfo(e[i]);
          if (r && r.otherDims[t] === 0) return e[i];
        }
      }
      function kFt(n, t, e) {
        var i = n.getDimensionInfo(e), r = i && i.ordinalMeta;
        if (i) {
          var a = n.get(i.name, t);
          return r && r.categories[a] || a + "";
        }
      }
      function $Y(n, t, e, i) {
        var r = i ? "itemChildGroupId" : "itemGroupId", a = NFt(n, r);
        if (a) {
          var o = kFt(n, t, a);
          return o;
        }
        var s = n.getRawDataItem(t), l = i ? "childGroupId" : "groupId";
        if (s && s[l]) return s[l] + "";
        if (!i) return e || n.getId(t);
      }
      function JY(n) {
        var t = [];
        return M(n, function(e) {
          var i = e.data, r = e.dataGroupId;
          if (i.count() > XY) {
            un("Universal transition is disabled on large data > 10k.");
            return;
          }
          for (var a = i.getIndices(), o = 0; o < a.length; o++) t.push({ data: i, groupId: $Y(i, o, r, false), childGroupId: $Y(i, o, r, true), divide: e.divide, dataIndex: o });
        }), t;
      }
      function BR(n, t, e) {
        n.traverse(function(i) {
          i instanceof Jt && nn(i, { style: { opacity: 0 } }, t, { dataIndex: e, isFrom: true });
        });
      }
      function TR(n) {
        if (n.parent) {
          var t = n.getComputedTransform();
          n.setLocalTransform(t), n.parent.remove(n);
        }
      }
      function vd(n) {
        n.stopAnimation(), n.isGroup && n.traverse(function(t) {
          t.stopAnimation();
        });
      }
      function FFt(n, t, e) {
        var i = wg("update", e, t);
        i && n.traverse(function(r) {
          if (r instanceof ha) {
            var a = M1t(r);
            a && r.animateFrom({ style: a }, i);
          }
        });
      }
      function QFt(n, t) {
        var e = n.length;
        if (e !== t.length) return false;
        for (var i = 0; i < e; i++) {
          var r = n[i], a = t[i];
          if (r.data.getId(r.dataIndex) !== a.data.getId(a.dataIndex)) return false;
        }
        return true;
      }
      function tW(n, t, e) {
        var i = JY(n), r = JY(t);
        function a(m, _, E, I, x) {
          (E || m) && _.animateFrom({ style: E && E !== m ? Y(Y({}, E.style), m.style) : m.style }, x);
        }
        var o = false, s = LFt, l = dt(), u = dt();
        i.forEach(function(m) {
          m.groupId && l.set(m.groupId, true), m.childGroupId && u.set(m.childGroupId, true);
        });
        for (var h = 0; h < r.length; h++) {
          var c = r[h].groupId;
          if (u.get(c)) {
            s = ZY;
            break;
          }
          var f = r[h].childGroupId;
          if (f && l.get(f)) {
            s = KY;
            break;
          }
        }
        function g(m, _) {
          return function(E) {
            var I = E.data, x = E.dataIndex;
            return _ ? I.getId(x) : m ? s === ZY ? E.childGroupId : E.groupId : s === KY ? E.childGroupId : E.groupId;
          };
        }
        var d = QFt(i, r), A = {};
        if (!d) for (var h = 0; h < r.length; h++) {
          var p = r[h], v = p.data.getItemGraphicEl(p.dataIndex);
          v && (A[v.id] = true);
        }
        function y(m, _) {
          var E = i[_], I = r[m], x = I.data.hostModel, w = E.data.getItemGraphicEl(E.dataIndex), C = I.data.getItemGraphicEl(I.dataIndex);
          if (w === C) {
            C && FFt(C, I.dataIndex, x);
            return;
          }
          w && A[w.id] || C && (vd(C), w ? (vd(w), TR(w), o = true, bR(dc(w), dc(C), I.divide, x, m, a)) : BR(C, x, m));
        }
        new Os(i, r, g(true, d), g(false, d), null, "multiple").update(y).updateManyToOne(function(m, _) {
          var E = r[m], I = E.data, x = I.hostModel, w = I.getItemGraphicEl(E.dataIndex), C = Ne(Z(_, function(S) {
            return i[S].data.getItemGraphicEl(i[S].dataIndex);
          }), function(S) {
            return S && S !== w && !A[S.id];
          });
          w && (vd(w), C.length ? (M(C, function(S) {
            vd(S), TR(S);
          }), o = true, bR(dc(C), dc(w), E.divide, x, m, a)) : BR(w, x, E.dataIndex));
        }).updateOneToMany(function(m, _) {
          var E = i[_], I = E.data.getItemGraphicEl(E.dataIndex);
          if (!(I && A[I.id])) {
            var x = Ne(Z(m, function(C) {
              return r[C].data.getItemGraphicEl(r[C].dataIndex);
            }), function(C) {
              return C && C !== I;
            }), w = r[m[0]].data.hostModel;
            x.length && (M(x, function(C) {
              return vd(C);
            }), I ? (vd(I), TR(I), o = true, bR(dc(I), dc(x), E.divide, w, m[0], a)) : M(x, function(C) {
              return BR(C, w, m[0]);
            }));
          }
        }).updateManyToMany(function(m, _) {
          new Os(_, m, function(E) {
            return i[E].data.getId(i[E].dataIndex);
          }, function(E) {
            return r[E].data.getId(r[E].dataIndex);
          }).update(function(E, I) {
            y(m[E], _[I]);
          }).execute();
        }).execute(), o && M(t, function(m) {
          var _ = m.data, E = _.hostModel, I = E && e.getViewOfSeriesModel(E), x = wg("update", E, 0);
          I && E.isAnimationEnabled() && x && x.duration > 0 && I.group.traverse(function(w) {
            w instanceof Jt && !w.animators.length && w.animateFrom({ style: { opacity: 0 } }, x);
          });
        });
      }
      function eW(n) {
        var t = n.getModel("universalTransition").get("seriesKey");
        return t || n.id;
      }
      function nW(n) {
        return X(n) ? n.sort().join(",") : n;
      }
      function mu(n) {
        if (n.hostModel) return n.hostModel.getModel("universalTransition").get("divideShape");
      }
      function OFt(n, t) {
        var e = dt(), i = dt(), r = dt();
        M(n.oldSeries, function(o, s) {
          var l = n.oldDataGroupIds[s], u = n.oldData[s], h = eW(o), c = nW(h);
          i.set(c, { dataGroupId: l, data: u }), X(h) && M(h, function(f) {
            r.set(f, { key: c, dataGroupId: l, data: u });
          });
        });
        function a(o) {
          e.get(o) && un("Duplicated seriesKey in universalTransition " + o);
        }
        return M(t.updatedSeries, function(o) {
          if (o.isUniversalTransitionEnabled() && o.isAnimationEnabled()) {
            var s = o.get("dataGroupId"), l = o.getData(), u = eW(o), h = nW(u), c = i.get(h);
            if (c) a(h), e.set(h, { oldSeries: [{ dataGroupId: c.dataGroupId, divide: mu(c.data), data: c.data }], newSeries: [{ dataGroupId: s, divide: mu(l), data: l }] });
            else if (X(u)) {
              a(h);
              var f = [];
              M(u, function(A) {
                var p = i.get(A);
                p.data && f.push({ dataGroupId: p.dataGroupId, divide: mu(p.data), data: p.data });
              }), f.length && e.set(h, { oldSeries: f, newSeries: [{ dataGroupId: s, data: l, divide: mu(l) }] });
            } else {
              var g = r.get(u);
              if (g) {
                var d = e.get(g.key);
                d || (d = { oldSeries: [{ dataGroupId: g.dataGroupId, data: g.data, divide: mu(g.data) }], newSeries: [] }, e.set(g.key, d)), d.newSeries.push({ dataGroupId: s, data: l, divide: mu(l) });
              }
            }
          }
        }), e;
      }
      function iW(n, t) {
        for (var e = 0; e < n.length; e++) {
          var i = t.seriesIndex != null && t.seriesIndex === n[e].seriesIndex || t.seriesId != null && t.seriesId === n[e].id;
          if (i) return e;
        }
      }
      function zFt(n, t, e, i) {
        var r = [], a = [];
        M(Qe(n.from), function(o) {
          var s = iW(t.oldSeries, o);
          s >= 0 && r.push({ dataGroupId: t.oldDataGroupIds[s], data: t.oldData[s], divide: mu(t.oldData[s]), groupIdDim: o.dimension });
        }), M(Qe(n.to), function(o) {
          var s = iW(e.updatedSeries, o);
          if (s >= 0) {
            var l = e.updatedSeries[s].getData();
            a.push({ dataGroupId: t.oldDataGroupIds[s], data: l, divide: mu(l), groupIdDim: o.dimension });
          }
        }), r.length > 0 && a.length > 0 && tW(r, a, i);
      }
      function GFt(n) {
        n.registerUpdateLifecycle("series:beforeupdate", function(t, e, i) {
          M(Qe(i.seriesTransition), function(r) {
            M(Qe(r.to), function(a) {
              for (var o = i.updatedSeries, s = 0; s < o.length; s++) (a.seriesIndex != null && a.seriesIndex === o[s].seriesIndex || a.seriesId != null && a.seriesId === o[s].id) && (o[s][R1] = true);
            });
          });
        }), n.registerUpdateLifecycle("series:transition", function(t, e, i) {
          var r = PFt(e);
          if (r.oldSeries && i.updatedSeries && i.optionChanged) {
            var a = i.seriesTransition;
            if (a) M(Qe(a), function(g) {
              zFt(g, r, i, e);
            });
            else {
              var o = OFt(r, i);
              M(o.keys(), function(g) {
                var d = o.get(g);
                tW(d.oldSeries, d.newSeries, e);
              });
            }
            M(i.updatedSeries, function(g) {
              g[R1] && (g[R1] = false);
            });
          }
          for (var s = t.getSeries(), l = r.oldSeries = [], u = r.oldDataGroupIds = [], h = r.oldData = [], c = 0; c < s.length; c++) {
            var f = s[c].getData();
            f.count() < XY && (l.push(s[c]), u.push(s[c].get("dataGroupId")), h.push(f));
          }
        });
      }
      Zt([$Ct]), Zt([YCt]), Zt([ySt, LSt, VSt, Ebt, Lbt, m2t, Y2t, MBt, $Bt, rTt, gTt, sMt, RMt, VMt, aDt, uDt, mDt, SDt, FDt, VDt, JDt, NRt]), Zt(tLt), Zt(SLt), Zt(Zj), Zt(OLt), Zt(vq), Zt(VLt), Zt($Lt), Zt(OPt), Zt(rNt), Zt(Zv), Zt(INt), Zt(wNt), Zt(PNt), Zt(GNt), Zt(YNt), Zt(JNt), Zt(ukt), Zt(bkt), Zt(hY), Zt(dY), Zt(Ykt), Zt(MY), Zt(RY), Zt($kt), Zt(cFt), Zt(dFt), Zt(GFt), Zt(gCt);
      function AE() {
        return [1, 0, 0, 1, 0, 0];
      }
      function UFt(n) {
        return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 1, n[4] = 0, n[5] = 0, n;
      }
      function VFt(n, t) {
        return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n;
      }
      function MR(n, t, e) {
        var i = t[0] * e[0] + t[2] * e[1], r = t[1] * e[0] + t[3] * e[1], a = t[0] * e[2] + t[2] * e[3], o = t[1] * e[2] + t[3] * e[3], s = t[0] * e[4] + t[2] * e[5] + t[4], l = t[1] * e[4] + t[3] * e[5] + t[5];
        return n[0] = i, n[1] = r, n[2] = a, n[3] = o, n[4] = s, n[5] = l, n;
      }
      function rW(n, t, e) {
        return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4] + e[0], n[5] = t[5] + e[1], n;
      }
      function jFt(n, t, e) {
        var i = t[0], r = t[2], a = t[4], o = t[1], s = t[3], l = t[5], u = Math.sin(e), h = Math.cos(e);
        return n[0] = i * h + o * u, n[1] = -i * u + o * h, n[2] = r * h + s * u, n[3] = -r * u + h * s, n[4] = h * a + u * l, n[5] = h * l - u * a, n;
      }
      function qFt(n, t, e) {
        var i = e[0], r = e[1];
        return n[0] = t[0] * i, n[1] = t[1] * r, n[2] = t[2] * i, n[3] = t[3] * r, n[4] = t[4] * i, n[5] = t[5] * r, n;
      }
      function HFt(n, t) {
        var e = t[0], i = t[2], r = t[4], a = t[1], o = t[3], s = t[5], l = e * o - a * i;
        return l ? (l = 1 / l, n[0] = o * l, n[1] = -a * l, n[2] = -i * l, n[3] = e * l, n[4] = (i * s - o * r) * l, n[5] = (a * r - e * s) * l, n) : null;
      }
      function aW(n, t, e) {
        var i = t[0], r = t[1];
        return n[0] = e[0] * i + e[2] * r + e[4], n[1] = e[1] * i + e[3] * r + e[5], n;
      }
      var oW = UFt, sW = 5e-5;
      function Ac(n) {
        return n > sW || n < -sW;
      }
      var pc = [], yd = [], DR = AE(), RR = Math.abs, LR = function() {
        function n() {
        }
        return n.prototype.getLocalTransform = function(t) {
          return n.getLocalTransform(this, t);
        }, n.prototype.setPosition = function(t) {
          this.x = t[0], this.y = t[1];
        }, n.prototype.setScale = function(t) {
          this.scaleX = t[0], this.scaleY = t[1];
        }, n.prototype.setSkew = function(t) {
          this.skewX = t[0], this.skewY = t[1];
        }, n.prototype.setOrigin = function(t) {
          this.originX = t[0], this.originY = t[1];
        }, n.prototype.needLocalTransform = function() {
          return Ac(this.rotation) || Ac(this.x) || Ac(this.y) || Ac(this.scaleX - 1) || Ac(this.scaleY - 1) || Ac(this.skewX) || Ac(this.skewY);
        }, n.prototype.updateTransform = function() {
          var t = this.parent && this.parent.transform, e = this.needLocalTransform(), i = this.transform;
          if (!(e || t)) {
            i && oW(i);
            return;
          }
          i = i || AE(), e ? this.getLocalTransform(i) : oW(i), t && (e ? MR(i, t, i) : VFt(i, t)), this.transform = i, this._resolveGlobalScaleRatio(i);
        }, n.prototype._resolveGlobalScaleRatio = function(t) {
          var e = this.globalScaleRatio;
          if (e != null && e !== 1) {
            this.getGlobalScale(pc);
            var i = pc[0] < 0 ? -1 : 1, r = pc[1] < 0 ? -1 : 1, a = ((pc[0] - i) * e + i) / pc[0] || 0, o = ((pc[1] - r) * e + r) / pc[1] || 0;
            t[0] *= a, t[1] *= a, t[2] *= o, t[3] *= o;
          }
          this.invTransform = this.invTransform || AE(), HFt(this.invTransform, t);
        }, n.prototype.getComputedTransform = function() {
          for (var t = this, e = []; t; ) e.push(t), t = t.parent;
          for (; t = e.pop(); ) t.updateTransform();
          return this.transform;
        }, n.prototype.setLocalTransform = function(t) {
          if (t) {
            var e = t[0] * t[0] + t[1] * t[1], i = t[2] * t[2] + t[3] * t[3], r = Math.atan2(t[1], t[0]), a = Math.PI / 2 + r - Math.atan2(t[3], t[2]);
            i = Math.sqrt(i) * Math.cos(a), e = Math.sqrt(e), this.skewX = a, this.skewY = 0, this.rotation = -r, this.x = +t[4], this.y = +t[5], this.scaleX = e, this.scaleY = i, this.originX = 0, this.originY = 0;
          }
        }, n.prototype.decomposeTransform = function() {
          if (this.transform) {
            var t = this.parent, e = this.transform;
            t && t.transform && (MR(yd, t.invTransform, e), e = yd);
            var i = this.originX, r = this.originY;
            (i || r) && (DR[4] = i, DR[5] = r, MR(yd, e, DR), yd[4] -= i, yd[5] -= r, e = yd), this.setLocalTransform(e);
          }
        }, n.prototype.getGlobalScale = function(t) {
          var e = this.transform;
          return t = t || [], e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), e[0] < 0 && (t[0] = -t[0]), e[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t);
        }, n.prototype.transformCoordToLocal = function(t, e) {
          var i = [t, e], r = this.invTransform;
          return r && aW(i, i, r), i;
        }, n.prototype.transformCoordToGlobal = function(t, e) {
          var i = [t, e], r = this.transform;
          return r && aW(i, i, r), i;
        }, n.prototype.getLineScale = function() {
          var t = this.transform;
          return t && RR(t[0] - 1) > 1e-10 && RR(t[3] - 1) > 1e-10 ? Math.sqrt(RR(t[0] * t[3] - t[2] * t[1])) : 1;
        }, n.prototype.copyTransform = function(t) {
          YFt(this, t);
        }, n.getLocalTransform = function(t, e) {
          e = e || [];
          var i = t.originX || 0, r = t.originY || 0, a = t.scaleX, o = t.scaleY, s = t.anchorX, l = t.anchorY, u = t.rotation || 0, h = t.x, c = t.y, f = t.skewX ? Math.tan(t.skewX) : 0, g = t.skewY ? Math.tan(-t.skewY) : 0;
          if (i || r || s || l) {
            var d = i + s, A = r + l;
            e[4] = -d * a - f * A * o, e[5] = -A * o - g * d * a;
          } else e[4] = e[5] = 0;
          return e[0] = a, e[3] = o, e[1] = g * a, e[2] = f * o, u && jFt(e, e, u), e[4] += i + h, e[5] += r + c, e;
        }, n.initDefaultProps = function() {
          var t = n.prototype;
          t.scaleX = t.scaleY = t.globalScaleRatio = 1, t.x = t.y = t.originX = t.originY = t.skewX = t.skewY = t.rotation = t.anchorX = t.anchorY = 0;
        }(), n;
      }(), lW = ["x", "y", "originX", "originY", "anchorX", "anchorY", "rotation", "scaleX", "scaleY", "skewX", "skewY"];
      function YFt(n, t) {
        for (var e = 0; e < lW.length; e++) {
          var i = lW[e];
          n[i] = t[i];
        }
      }
      var tr = function() {
        function n(t, e) {
          this.x = t || 0, this.y = e || 0;
        }
        return n.prototype.copy = function(t) {
          return this.x = t.x, this.y = t.y, this;
        }, n.prototype.clone = function() {
          return new n(this.x, this.y);
        }, n.prototype.set = function(t, e) {
          return this.x = t, this.y = e, this;
        }, n.prototype.equal = function(t) {
          return t.x === this.x && t.y === this.y;
        }, n.prototype.add = function(t) {
          return this.x += t.x, this.y += t.y, this;
        }, n.prototype.scale = function(t) {
          this.x *= t, this.y *= t;
        }, n.prototype.scaleAndAdd = function(t, e) {
          this.x += t.x * e, this.y += t.y * e;
        }, n.prototype.sub = function(t) {
          return this.x -= t.x, this.y -= t.y, this;
        }, n.prototype.dot = function(t) {
          return this.x * t.x + this.y * t.y;
        }, n.prototype.len = function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, n.prototype.lenSquare = function() {
          return this.x * this.x + this.y * this.y;
        }, n.prototype.normalize = function() {
          var t = this.len();
          return this.x /= t, this.y /= t, this;
        }, n.prototype.distance = function(t) {
          var e = this.x - t.x, i = this.y - t.y;
          return Math.sqrt(e * e + i * i);
        }, n.prototype.distanceSquare = function(t) {
          var e = this.x - t.x, i = this.y - t.y;
          return e * e + i * i;
        }, n.prototype.negate = function() {
          return this.x = -this.x, this.y = -this.y, this;
        }, n.prototype.transform = function(t) {
          if (t) {
            var e = this.x, i = this.y;
            return this.x = t[0] * e + t[2] * i + t[4], this.y = t[1] * e + t[3] * i + t[5], this;
          }
        }, n.prototype.toArray = function(t) {
          return t[0] = this.x, t[1] = this.y, t;
        }, n.prototype.fromArray = function(t) {
          this.x = t[0], this.y = t[1];
        }, n.set = function(t, e, i) {
          t.x = e, t.y = i;
        }, n.copy = function(t, e) {
          t.x = e.x, t.y = e.y;
        }, n.len = function(t) {
          return Math.sqrt(t.x * t.x + t.y * t.y);
        }, n.lenSquare = function(t) {
          return t.x * t.x + t.y * t.y;
        }, n.dot = function(t, e) {
          return t.x * e.x + t.y * e.y;
        }, n.add = function(t, e, i) {
          t.x = e.x + i.x, t.y = e.y + i.y;
        }, n.sub = function(t, e, i) {
          t.x = e.x - i.x, t.y = e.y - i.y;
        }, n.scale = function(t, e, i) {
          t.x = e.x * i, t.y = e.y * i;
        }, n.scaleAndAdd = function(t, e, i, r) {
          t.x = e.x + i.x * r, t.y = e.y + i.y * r;
        }, n.lerp = function(t, e, i, r) {
          var a = 1 - r;
          t.x = a * e.x + r * i.x, t.y = a * e.y + r * i.y;
        }, n;
      }(), pE = Math.min, vE = Math.max, vc = new tr(), yc = new tr(), mc = new tr(), _c = new tr(), oy = new tr(), sy = new tr(), uW = function() {
        function n(t, e, i, r) {
          i < 0 && (t = t + i, i = -i), r < 0 && (e = e + r, r = -r), this.x = t, this.y = e, this.width = i, this.height = r;
        }
        return n.prototype.union = function(t) {
          var e = pE(t.x, this.x), i = pE(t.y, this.y);
          isFinite(this.x) && isFinite(this.width) ? this.width = vE(t.x + t.width, this.x + this.width) - e : this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = vE(t.y + t.height, this.y + this.height) - i : this.height = t.height, this.x = e, this.y = i;
        }, n.prototype.applyTransform = function(t) {
          n.applyTransform(this, this, t);
        }, n.prototype.calculateTransform = function(t) {
          var e = this, i = t.width / e.width, r = t.height / e.height, a = AE();
          return rW(a, a, [-e.x, -e.y]), qFt(a, a, [i, r]), rW(a, a, [t.x, t.y]), a;
        }, n.prototype.intersect = function(t, e) {
          if (!t) return false;
          t instanceof n || (t = n.create(t));
          var i = this, r = i.x, a = i.x + i.width, o = i.y, s = i.y + i.height, l = t.x, u = t.x + t.width, h = t.y, c = t.y + t.height, f = !(a < l || u < r || s < h || c < o);
          if (e) {
            var g = 1 / 0, d = 0, A = Math.abs(a - l), p = Math.abs(u - r), v = Math.abs(s - h), y = Math.abs(c - o), m = Math.min(A, p), _ = Math.min(v, y);
            a < l || u < r ? m > d && (d = m, A < p ? tr.set(sy, -A, 0) : tr.set(sy, p, 0)) : m < g && (g = m, A < p ? tr.set(oy, A, 0) : tr.set(oy, -p, 0)), s < h || c < o ? _ > d && (d = _, v < y ? tr.set(sy, 0, -v) : tr.set(sy, 0, y)) : m < g && (g = m, v < y ? tr.set(oy, 0, v) : tr.set(oy, 0, -y));
          }
          return e && tr.copy(e, f ? oy : sy), f;
        }, n.prototype.contain = function(t, e) {
          var i = this;
          return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i.height;
        }, n.prototype.clone = function() {
          return new n(this.x, this.y, this.width, this.height);
        }, n.prototype.copy = function(t) {
          n.copy(this, t);
        }, n.prototype.plain = function() {
          return { x: this.x, y: this.y, width: this.width, height: this.height };
        }, n.prototype.isFinite = function() {
          return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
        }, n.prototype.isZero = function() {
          return this.width === 0 || this.height === 0;
        }, n.create = function(t) {
          return new n(t.x, t.y, t.width, t.height);
        }, n.copy = function(t, e) {
          t.x = e.x, t.y = e.y, t.width = e.width, t.height = e.height;
        }, n.applyTransform = function(t, e, i) {
          if (!i) {
            t !== e && n.copy(t, e);
            return;
          }
          if (i[1] < 1e-5 && i[1] > -1e-5 && i[2] < 1e-5 && i[2] > -1e-5) {
            var r = i[0], a = i[3], o = i[4], s = i[5];
            t.x = e.x * r + o, t.y = e.y * a + s, t.width = e.width * r, t.height = e.height * a, t.width < 0 && (t.x += t.width, t.width = -t.width), t.height < 0 && (t.y += t.height, t.height = -t.height);
            return;
          }
          vc.x = mc.x = e.x, vc.y = _c.y = e.y, yc.x = _c.x = e.x + e.width, yc.y = mc.y = e.y + e.height, vc.transform(i), _c.transform(i), yc.transform(i), mc.transform(i), t.x = pE(vc.x, yc.x, mc.x, _c.x), t.y = pE(vc.y, yc.y, mc.y, _c.y);
          var l = vE(vc.x, yc.x, mc.x, _c.x), u = vE(vc.y, yc.y, mc.y, _c.y);
          t.width = l - t.x, t.height = u - t.y;
        }, n;
      }(), Ic = (n) => {
        var t = typeof n;
        return n !== null && (t === "object" || t === "function");
      }, hW = (n, t) => (Object.keys(t).forEach((e) => {
        Ic(t[e]) && Ic(n[e]) ? hW(n[e], t[e]) : n[e] = t[e];
      }), n), PR = function(n, t, ...e) {
        return function(...i) {
          return n.apply(t, e.concat(Array.prototype.slice.call(i)));
        };
      }, cW = function(n, t) {
        for (var e = 0, i, r = n.length; e < r; e++) if (n[e].index === t.index) {
          i = e;
          break;
        }
        return i === void 0 ? n.push(t) : n[i] = t, n;
      }, fW = function() {
        function n(t) {
          return t ? (t ^ Math.random() * 16 >> t / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, n);
        }
        return n();
      };
      function gW(n, t) {
        n.forEach((e) => {
          t[e] && (t[e] = t[e].bind(t));
        });
      }
      function NR(n) {
        return n && n.parentNode ? n.parentNode.removeChild(n) : null;
      }
      function yE(n, t) {
        var e = new MouseEvent(n, { bubbles: true, cancelable: true, button: t.pointerEvent.button, buttons: t.pointerEvent.buttons, clientX: t.pointerEvent.clientX, clientY: t.pointerEvent.clientY, zrX: t.pointerEvent.offsetX, zrY: t.pointerEvent.offsetY, movementX: t.pointerEvent.movementX, movementY: t.pointerEvent.movementY, relatedTarget: t.pointerEvent.relatedTarget, screenX: t.pointerEvent.screenX, screenY: t.pointerEvent.screenY, view: window });
        return e.zrX = t.pointerEvent.offsetX, e.zrY = t.pointerEvent.offsetY, e.event = e, e;
      }
      function WFt(n, t) {
        for (var e = n.split("."), i = t.split("."), r = 0; r < 3; r++) {
          var a = Number(e[r]), o = Number(i[r]);
          if (a > o) return 1;
          if (o > a) return -1;
          if (!isNaN(a) && isNaN(o)) return 1;
          if (isNaN(a) && !isNaN(o)) return -1;
        }
        return 0;
      }
      var XFt = (n) => !n.UTF8Encoding, dW = (n, t, e) => {
        for (var i = [], r = [t[0], t[1]], a = r[0], o = r[1], s = 0; s < n.length; s += 2) {
          var l = n.charCodeAt(s) - 64, u = n.charCodeAt(s + 1) - 64;
          l = l >> 1 ^ -(l & 1), u = u >> 1 ^ -(u & 1), l += a, u += o, a = l, o = u, i.push([l / e, u / e]);
        }
        return i;
      }, ZFt = (n) => {
        if (XFt(n)) return n;
        var t = n.UTF8Scale;
        t == null && (t = 1024);
        for (var e = n.features, i = 0; i < e.length; i++) for (var r = e[i], a = r.geometry, o = [a.coordinates, a.encodeOffsets], s = o[0], l = o[1], u = 0; u < s.length; u++) {
          var h = s[u];
          if (a.type === "Polygon") s[u] = dW(h, l[u], t);
          else if (a.type === "MultiPolygon") for (var c = 0; c < h.length; c++) {
            var f = h[c];
            h[c] = dW(f, l[u][c], t);
          }
        }
        return n.UTF8Encoding = false, n;
      };
      function KFt(n) {
        var t = ZFt(n), e = t.features.filter((r) => r.geometry && r.properties && r.geometry.coordinates.length > 0), i = e.map((r) => {
          var a = r.properties, o = r.geometry, s = o.coordinates, l = [];
          return o.type === "Polygon" && l.push(s[0]), o.type === "MultiPolygon" && s.forEach((u) => {
            u[0] && l.push(u[0]);
          }), { properties: a, type: "Feature", geometry: { type: "Polygon", coordinates: l } };
        });
        return { type: "FeatureCollection", crs: {}, features: i };
      }
      var $Ft = function(n, t, e) {
        return t.center = e.dataToPoint(t.coordinates), t;
      }, JFt = function(n, t, e) {
        return Ic(n.grid) && !Array.isArray(n.grid) || Array.isArray(n.grid) && (n.grid = n.grid.map((i, r) => {
          var a = e.dataToPoint(n.series[r].coordinates);
          return i.left = a[0] - parseFloat(i.width) / 2, i.top = a[1] - parseFloat(i.height) / 2, i;
        })), t;
      }, tQt = function(n, t, e) {
        return Ic(n.grid) && !Array.isArray(n.grid) || Array.isArray(n.grid) && (n.grid = n.grid.map((i, r) => {
          var a = e.dataToPoint(n.series[r].coordinates);
          return i.left = a[0] - parseFloat(i.width) / 2, i.top = a[1] - parseFloat(i.height) / 2, i;
        })), t;
      }, eQt = Object.freeze({ pie: $Ft, bar: JFt, line: tQt }), nQt = { forcedRerender: false, forcedPrecomposeRerender: false, hideOnZooming: false, hideOnMoving: false, hideOnRotating: false, convertTypes: ["pie", "line", "bar"], insertFirst: false, stopEvent: false, polyfillEvents: WFt(JX, "6.1.1") <= 0 };
      class Ws extends Yr {
        constructor(t, e, i) {
          var r = Object.assign(nQt, e);
          super(r), this._options = r, this._chartOptions = t, this.set("chartOptions", t), this.$chart = null, this.$container = void 0, this._isRegistered = false, this._initEvent = false, this._incremental = [], this._coordinateSystem = null, this.coordinateSystemId = "", this.prevVisibleState = "", gW(["redraw", "onResize", "onZoomEnd", "onCenterChange", "onDragRotateEnd", "onMoveStart", "onMoveEnd", "mouseDown", "mouseUp", "onClick", "mouseMove"], this), i && this.setMap(i);
        }
        appendTo(t, e = false) {
          this.setMap(t, e);
        }
        getMap() {
          return this._map;
        }
        setMap(t, e = false) {
          if (t && (e || t instanceof lw)) this._map = t, this._map.once("postrender", () => {
            this.handleMapChanged();
          }), this._map.renderSync();
          else throw new Error("not ol map object");
        }
        getChartOptions() {
          return this.get("chartOptions");
        }
        setChartOptions(t = {}) {
          return this._chartOptions = t, this.set("chartOptions", t), this.clearAndRedraw(), this;
        }
        appendData(t, e = true) {
          return t && (e && (this._incremental = cW(this._incremental, { index: this._incremental.length, data: t.data, seriesIndex: t.seriesIndex })), this.$chart.appendData({ data: t.data.copyWithin(), seriesIndex: t.seriesIndex })), this;
        }
        clear(t) {
          t || (this._incremental = []), this.$chart && this.$chart.clear();
        }
        remove() {
          this.clear(), this.$chart && this.$chart.dispose(), this._initEvent && this.$container && (this.$container && NR(this.$container), this.unBindEvent()), delete this.$chart, delete this._map;
        }
        show() {
          this.setVisible(true);
        }
        innerShow() {
          this.$container && (this.$container.style.display = this.prevVisibleState, this.prevVisibleState = "");
        }
        hide() {
          this.setVisible(false);
        }
        innerHide() {
          this.$container && (this.prevVisibleState = this.$container.style.display, this.$container.style.display = "none");
        }
        isVisible() {
          return this.$container && this.$container.style.display !== "none";
        }
        showLoading() {
          this.$chart && this.$chart.showLoading();
        }
        hideLoading() {
          this.$chart && this.$chart.hideLoading();
        }
        setZIndex(t) {
          this.$container && (typeof t == "number" && (t = String(t)), this.$container.style.zIndex = t);
        }
        getZIndex() {
          return this.$container && this.$container.style.zIndex;
        }
        setVisible(t) {
          t ? (this.$container && (this.$container.style.display = ""), this._chartOptions = this.getChartOptions(), this.clearAndRedraw()) : (this.$container && (this.$container.style.display = "none"), this.clear(true), this._chartOptions = {}, this.clearAndRedraw());
        }
        render() {
          !this.$chart && this.$container ? (this.$chart = kxt(this.$container), this._chartOptions && (this.registerMap(), this.$chart.setOption(this.convertData(this._chartOptions), false)), this.dispatchEvent({ type: "load", source: this, value: this.$chart })) : this.isVisible() && this.redraw();
        }
        redraw() {
          this.clearAndRedraw();
        }
        updateViewSize(t) {
          this.$container && (this.$container.style.width = `${t[0]}px`, this.$container.style.height = `${t[1]}px`, this.$container.setAttribute("width", String(t[0])), this.$container.setAttribute("height", String(t[1])));
        }
        onResize(t) {
          var e = this.getMap();
          if (e) {
            var i = e.getSize();
            this.updateViewSize(i), this.clearAndRedraw(), t && this.dispatchEvent({ type: "change:size", source: this, value: i });
          }
        }
        onZoomEnd() {
          this._options.hideOnZooming && this.innerShow();
          var t = this.getMap();
          t && t.getView() && (this.clearAndRedraw(), this.dispatchEvent({ type: "zoomend", source: this, value: t.getView().getZoom() }));
        }
        onDragRotateEnd() {
          this._options.hideOnRotating && this.innerShow();
          var t = this.getMap();
          t && t.getView() && (this.clearAndRedraw(), this.dispatchEvent({ type: "change:rotation", source: this, value: t.getView().getRotation() }));
        }
        onMoveStart() {
          this._options.hideOnMoving && this.innerHide();
          var t = this.getMap();
          t && t.getView() && this.dispatchEvent({ type: "movestart", source: this, value: t.getView().getCenter() });
        }
        onMoveEnd() {
          this._options.hideOnMoving && this.innerShow();
          var t = this.getMap();
          t && t.getView() && (this.clearAndRedraw(), this.dispatchEvent({ type: "moveend", source: this, value: t.getView().getCenter() }));
        }
        onClick(t) {
          this.$chart && this.$chart.getZr().painter.getViewportRoot().dispatchEvent(yE("click", t));
        }
        mouseDown(t) {
          this.$chart && this.$chart.getZr().painter.getViewportRoot().dispatchEvent(yE("mousedown", t));
        }
        mouseUp(t) {
          this.$chart && this.$chart.getZr().painter.getViewportRoot().dispatchEvent(yE("mouseup", t));
        }
        mouseMove(t) {
          if (this.$chart) for (var e = t.originalEvent.target; e; ) {
            if (e.className === "ol-overlaycontainer-stopevent") {
              this.$chart.getZr().painter.getViewportRoot().dispatchEvent(yE("mousemove", t));
              return;
            }
            e = e.parentElement;
          }
        }
        onCenterChange() {
          var t = this.getMap();
          t && t.getView() && (this.clearAndRedraw(), this.dispatchEvent({ type: "change:center", source: this, value: t.getView().getCenter() }));
        }
        handleMapChanged() {
          var t = this.getMap();
          if (this._initEvent && this.$container && (this.$container && NR(this.$container), this.unBindEvent()), this.$container || (this.createLayerContainer(), this.onResize(false)), t) {
            var e = this._options.stopEvent ? t.getOverlayContainerStopEvent() : t.getOverlayContainer();
            this._options.insertFirst ? e.insertBefore(this.$container, e.childNodes[0] || null) : e.appendChild(this.$container), this.render(), this.bindEvent(t);
          }
        }
        createLayerContainer() {
          this.$container = document.createElement("div"), this.$container.style.position = "absolute", this.$container.style.top = "0px", this.$container.style.left = "0px", this.$container.style.right = "0px", this.$container.style.bottom = "0px", this.$container.style.pointerEvents = "auto";
        }
        bindEvent(t) {
          var e = t.getView();
          this._options.forcedPrecomposeRerender && t.on("precompose", this.redraw), t.on("change:size", this.onResize), e.on("change:resolution", this.onZoomEnd), e.on("change:center", this.onCenterChange), e.on("change:rotation", this.onDragRotateEnd), t.on("movestart", this.onMoveStart), t.on("moveend", this.onMoveEnd), this._options.polyfillEvents && (t.on("pointerdown", this.mouseDown), t.on("pointerup", this.mouseUp), t.on("pointermove", this.mouseMove), t.on("click", this.onClick)), this._initEvent = true;
        }
        unBindEvent() {
          var t = this.getMap();
          if (t) {
            var e = t.getView();
            e && (t.un("precompose", this.redraw), t.un("change:size", this.onResize), e.un("change:resolution", this.onZoomEnd), e.un("change:center", this.onCenterChange), e.un("change:rotation", this.onDragRotateEnd), t.un("movestart", this.onMoveStart), t.un("moveend", this.onMoveEnd), this._options.polyfillEvents && (t.un("pointerdown", this.mouseDown), t.un("pointerup", this.mouseUp), t.un("pointermove", this.mouseMove), t.un("click", this.onClick)), this._initEvent = false);
          }
        }
        clearAndRedraw() {
          if (!(!this.$chart || !this.isVisible())) {
            if (this._options.forcedRerender && this.$chart.clear(), this.$chart.resize(), this._chartOptions && (this.registerMap(), this.$chart.setOption(this.convertData(this._chartOptions), false), this._incremental && this._incremental.length > 0)) for (var t = 0; t < this._incremental.length; t++) this.appendData(this._incremental[t], false);
            this.dispatchEvent({ type: "redraw", source: this });
          }
        }
        registerMap() {
          if (this._isRegistered || (this.coordinateSystemId = `openlayers_${fW()}`, U6(this.coordinateSystemId, this.getCoordinateSystem(this._options)), this._isRegistered = true), this._chartOptions) {
            var t = this._chartOptions.series;
            if (t && Ic(t)) {
              var e = this._options.convertTypes;
              if (e) for (var i = t.length - 1; i >= 0; i--) e.indexOf(t[i].type) > -1 || (t[i].coordinateSystem = this.coordinateSystemId), t[i].animation = false;
            }
          }
        }
        convertData(t) {
          var e = t.series;
          if (e && e.length > 0) {
            if (!this._coordinateSystem) {
              var i = this.getCoordinateSystem(this._options);
              this._coordinateSystem = new i(this.getMap());
            }
            if (e && Ic(e)) {
              var r = this._options.convertTypes;
              if (r) for (var a = e.length - 1; a >= 0; a--) r.indexOf(e[a].type) > -1 && e[a] && e[a].hasOwnProperty("coordinates") && (e[a] = eQt[e[a].type](t, e[a], this._coordinateSystem));
            }
          }
          return t;
        }
        getCoordinateSystem(t) {
          var e = this.getMap(), i = this.coordinateSystemId;
          class r {
            constructor(o) {
              this._mapOffset = [0, 0], this.dimensions = ["lng", "lat"], this._roamTransformable = new LR(), this._rawTransformable = new LR(), this._viewRect = new uW(0, 0, 0, 0), this.map = o, this.dimensions = ["lng", "lat"], this.projCode = r.getProjectionCode(this.map);
            }
            getZoom() {
              return this.map.getView().getZoom();
            }
            setZoom(o) {
              return this.map.getView().setZoom(o);
            }
            getViewRectAfterRoam() {
              return this.getViewRect().clone();
            }
            setMapOffset(o) {
              this._mapOffset = o;
            }
            dataToPoint(o) {
              var s;
              if (o && Array.isArray(o) && o.length > 0) {
                s = o.map((f) => {
                  var g = 0;
                  return typeof f == "string" ? g = Number(f) : g = f, g;
                });
                var l = t && t.source || "EPSG:4326", u = t && t.destination || this.projCode, h = this.map.getPixelFromCoordinate(as(s, l, u)), c = this._mapOffset;
                return [h[0] - c[0], h[1] - c[1]];
              }
              return [0, 0];
            }
            pointToData(o) {
              var s = this._mapOffset;
              return this.map.getCoordinateFromPixel([o[0] + s[0], o[1] + s[1]]);
            }
            setViewRect() {
              var o = this.map.getSize();
              this._viewRect = new uW(0, 0, o[0], o[1]);
            }
            getViewRect() {
              return this._viewRect;
            }
            getRoamTransform() {
              return this._roamTransformable.getLocalTransform();
            }
            prepareCustoms() {
              var o = this.getViewRect();
              return { coordSys: { type: i, x: o.x, y: o.y, width: o.width, height: o.height }, api: { coord: PR(this.dataToPoint, this), size: PR(this.dataToCoordsSize, this) } };
            }
            dataToCoordsSize(o, s = [0, 0]) {
              return [0, 1].map((l) => {
                var u = s[l], h = [], c = [], f = o[l] / 2;
                h[l] = u - f, c[l] = u + f, h[1 - l] = s[1 - l], c[1 - l] = s[1 - l];
                var g = this.dataToPoint(h)[l] - this.dataToPoint(c)[l];
                return Math.abs(g);
              });
            }
            getTransformInfo() {
              var o = this._rawTransformable, s = this._roamTransformable, l = new LR();
              return l.transform = s.transform, l.decomposeTransform(), { roam: { x: l.x, y: l.y, scaleX: l.scaleX, scaleY: l.scaleY }, raw: { x: o.x, y: o.y, scaleX: o.scaleX, scaleY: o.scaleY } };
            }
          }
          return r.dimensions = r.prototype.dimensions || ["lng", "lat"], r.create = function(a) {
            a.eachSeries((o) => {
              o.get("coordinateSystem") === i && (o.coordinateSystem = new r(e));
            });
          }, r.getProjectionCode = function(a) {
            var o = "";
            return a ? o = a.getView() && a.getView().getProjection().getCode() : o = "EPSG:3857", o;
          }, r;
        }
        dispatchEvent(t) {
          return super.dispatchEvent(t);
        }
        set(t, e, i) {
          return super.set(t, e, i);
        }
        get(t) {
          return super.get(t);
        }
        unset(t, e) {
          return super.unset(t, e);
        }
        on(t, e) {
          return super.on(t, e);
        }
        un(t, e) {
          return super.un(t, e);
        }
      }
      Ws.formatGeoJSON = KFt, Ws.bind = PR, Ws.merge = hW, Ws.uuid = fW, Ws.bindAll = gW, Ws.arrayAdd = cW, Ws.removeNode = NR, Ws.isObject = Ic;
      const kR = N.defineComponent({ name: "OlEcharts", __name: "index", props: { chartOptions: {}, options: {}, zIndex: {}, visible: { type: Boolean, default: true } }, emits: ["load"], setup(n, { emit: t }) {
        const e = N.inject("VMap"), i = N.unref(e).map;
        let r = N.shallowRef(), a = N.ref(false);
        const o = n, s = t, l = () => {
          var u;
          r.value = new Ws(o.chartOptions, o.options), r.value.on("load", () => {
            a.value = true, s("load");
          }), o.zIndex && r.value.setZIndex(o.zIndex), r.value.setVisible(o.visible), (u = r.value) == null || u.appendTo(i);
        };
        return N.watch(() => o.visible, (u) => {
          var h;
          (h = r.value) == null || h.setVisible(u);
        }), N.watch(() => o.zIndex, (u) => {
          var h;
          (u || u === 0 || u === null) && ((h = r.value) == null || h.setZIndex(u));
        }), N.watch(() => o.chartOptions, (u) => {
          var h;
          u && ((h = r.value) == null || h.setChartOptions(u));
        }, { deep: true }), N.onMounted(() => {
          l();
        }), N.onBeforeUnmount(() => {
          var u;
          (u = r.value) == null || u.remove();
        }), (u, h) => N.unref(a) ? N.renderSlot(u.$slots, "default", { key: 0 }) : N.createCommentVNode("", true);
      } }), iQt = (n) => n.component(kR.name || "OlEcharts", kR), FR = N.defineComponent({ name: "OlConfig", __name: "index", props: { tdt: {}, baidu: {}, amap: {} }, setup(n) {
        let t = N.ref(false);
        const e = n, i = () => Rt(this, null, function* () {
          N.provide("ConfigProvide", e);
        });
        return N.onMounted(() => Rt(this, null, function* () {
          i().then(() => {
            t.value = true;
          });
        })), (r, a) => N.unref(t) ? N.renderSlot(r.$slots, "default", { key: 0 }) : N.createCommentVNode("", true);
      } }), rQt = [zat, hut, cut, FAt, XAt, ZAt, KAt, $At, JAt, rpt, apt, opt, spt, cpt, fpt, wpt, Yyt, iQt, (n) => n.component(FR.name || "OlConfig", FR)], ly = { tdt: { ak: "", Normal: "https://t0.tianditu.gov.cn/DataServer?T=vec_w&X={x}&Y={y}&L={z}&tk=", Normal_Label: "https://t0.tianditu.gov.cn/DataServer?T=cva_w&X={x}&Y={y}&L={z}&tk=", Satellite: "https://t0.tianditu.gov.cn/DataServer?T=img_w&X={x}&Y={y}&L={z}&tk=", Satellite_Label: "https://t0.tianditu.gov.cn/DataServer?T=cia_w&X={x}&Y={y}&L={z}&tk=", Terrain: "https://t0.tianditu.gov.cn/DataServer?T=ter_w&X={x}&Y={y}&L={z}&tk=", Terrain_Label: "https://t0.tianditu.gov.cn/DataServer?T=cta_w&X={x}&Y={y}&L={z}&tk=" }, baidu: { ak: "", Normal: "https://maponline1.bdimg.com/tile/?qt=vtile&x={x}&y={y}&z={z}&styles=pl&scaler=1&udt=20220113&from=jsapi2_0", Satellite: "https://maponline3.bdimg.com/starpic/?qt=satepc&u=x={x};y={y};z={z};v=009;type=sate&fm=46&udt=20240910", Satellite_Label: "https://maponline0.bdimg.com/tile/?qt=vtile&x={x}&y={y}&z={z}&styles=sl&udt=20240910", midnight: "http://api0.map.bdimg.com/customimage/tile?&x={x}&y={y}&z={z}&udt=20220819&scale=1&customid=midnight&ak=" }, amap: { Normal: "http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}", Satellite: "http://webst01.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}", Satellite_Label: "http://webst01.is.autonavi.com/appmaptile?style=8&x={x}&y={y}&z={z}" } }, mE = ly, aQt = Symbol(), AW = (n = []) => ({ install: (e, i) => {
        n.forEach((a) => e.use(a));
        let r = ly;
        i && (e.config.globalProperties.$OlMapConfig = i, i.tdt && (r.tdt = st(st({}, ly.tdt), i.tdt)), i.baidu && (r.baidu = st(st({}, ly.baidu), i.baidu)), r.amap = st(st({}, ly.amap), i.amap)), e.provide("$OlMapConfig", { TDT: r.tdt, Baidu: r.tdt, AMap: r.tdt });
      } }), oQt = AW([...rQt]);
      var pW = ((n) => (n.TDT = "TDT", n.TDT_SATELLITE = "TDT_SATELLITE", n.TDT_TERRAIN = "TDT_TERRAIN", n.MAPBOX = "MAPBOX", n.BAIDU = "BAIDU", n.BAIDU_SATELLITE = "BAIDU_SATELLITE", n.BAIDU_MIDNIGHT = "BAIDU_MIDNIGHT", n.AMAP = "AMAP", n.AMAP_SATELLITE = "AMAP_SATELLITE", n.GEOTIFF = "GEOTIFF", n.CUSTOMER = "CUSTOMER", n.XYZ = "XYZ", n.OSM = "OSM", n))(pW || {});
      class sQt extends Vu {
        decodeBlock(t) {
          return t;
        }
      }
      const lQt = Object.freeze(Object.defineProperty({ __proto__: null, default: sQt }, Symbol.toStringTag, { value: "Module" })), vW = 9, QR = 256, OR = 257, uQt = 12;
      function hQt(n, t, e) {
        const i = t % 8, r = Math.floor(t / 8), a = 8 - i, o = t + e - (r + 1) * 8;
        let s = 8 * (r + 2) - (t + e);
        const l = (r + 2) * 8 - t;
        if (s = Math.max(0, s), r >= n.length) return OR;
        let u = n[r] & _i(2, 8 - i) - 1;
        u <<= e - a;
        let h = u;
        if (r + 1 < n.length) {
          let c = n[r + 1] >>> s;
          c <<= Math.max(0, e - l), h += c;
        }
        if (o > 8 && r + 2 < n.length) {
          const c = (r + 3) * 8 - (t + e), f = n[r + 2] >>> c;
          h += f;
        }
        return h;
      }
      function zR(n, t) {
        for (let e = t.length - 1; e >= 0; e--) n.push(t[e]);
        return n;
      }
      function cQt(n) {
        const t = new Uint16Array(4093), e = new Uint8Array(4093);
        for (let d = 0; d <= 257; d++) t[d] = 4096, e[d] = d;
        let i = 258, r = vW, a = 0;
        function o() {
          i = 258, r = vW;
        }
        function s(d) {
          const A = hQt(d, a, r);
          return a += r, A;
        }
        function l(d, A) {
          return e[i] = A, t[i] = d, i++, i - 1;
        }
        function u(d) {
          const A = [];
          for (let p = d; p !== 4096; p = t[p]) A.push(e[p]);
          return A;
        }
        const h = [];
        o();
        const c = new Uint8Array(n);
        let f = s(c), g;
        for (; f !== OR; ) {
          if (f === QR) {
            for (o(), f = s(c); f === QR; ) f = s(c);
            if (f === OR) break;
            if (f > QR) throw new Error(`corrupted code at scanline ${f}`);
            {
              const d = u(f);
              zR(h, d), g = f;
            }
          } else if (f < i) {
            const d = u(f);
            zR(h, d), l(g, d[d.length - 1]), g = f;
          } else {
            const d = u(g);
            if (!d) throw new Error(`Bogus entry. Not in dictionary, ${g} / ${i}, position: ${a}`);
            zR(h, d), h.push(d[d.length - 1]), l(g, d[d.length - 1]), g = f;
          }
          i + 1 >= _i(2, r) && (r === uQt ? g = void 0 : r++), f = s(c);
        }
        return new Uint8Array(h);
      }
      class fQt extends Vu {
        decodeBlock(t) {
          return cQt(t).buffer;
        }
      }
      const gQt = Object.freeze(Object.defineProperty({ __proto__: null, default: fQt }, Symbol.toStringTag, { value: "Module" })), uy = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), _E = 4017, IE = 799, EE = 3406, xE = 2276, wE = 1567, CE = 3784, md = 5793, SE = 2896;
      function yW(n, t) {
        let e = 0;
        const i = [];
        let r = 16;
        for (; r > 0 && !n[r - 1]; ) --r;
        i.push({ children: [], index: 0 });
        let a = i[0], o;
        for (let s = 0; s < r; s++) {
          for (let l = 0; l < n[s]; l++) {
            for (a = i.pop(), a.children[a.index] = t[e]; a.index > 0; ) a = i.pop();
            for (a.index++, i.push(a); i.length <= s; ) i.push(o = { children: [], index: 0 }), a.children[a.index] = o.children, a = o;
            e++;
          }
          s + 1 < r && (i.push(o = { children: [], index: 0 }), a.children[a.index] = o.children, a = o);
        }
        return i[0].children;
      }
      function dQt(n, t, e, i, r, a, o, s, l) {
        const { mcusPerLine: u, progressive: h } = e, c = t;
        let f = t, g = 0, d = 0;
        function A() {
          if (d > 0) return d--, g >> d & 1;
          if (g = n[f++], g === 255) {
            const G = n[f++];
            if (G) throw new Error(`unexpected marker: ${(g << 8 | G).toString(16)}`);
          }
          return d = 7, g >>> 7;
        }
        function p(G) {
          let tt = G, J;
          for (; (J = A()) !== null; ) {
            if (tt = tt[J], typeof tt == "number") return tt;
            if (typeof tt != "object") throw new Error("invalid huffman sequence");
          }
          return null;
        }
        function v(G) {
          let tt = G, J = 0;
          for (; tt > 0; ) {
            const et = A();
            if (et === null) return;
            J = J << 1 | et, --tt;
          }
          return J;
        }
        function y(G) {
          const tt = v(G);
          return tt >= 1 << G - 1 ? tt : tt + (-1 << G) + 1;
        }
        function m(G, tt) {
          const J = p(G.huffmanTableDC), et = J === 0 ? 0 : y(J);
          G.pred += et, tt[0] = G.pred;
          let nt = 1;
          for (; nt < 64; ) {
            const gt = p(G.huffmanTableAC), H = gt & 15, W = gt >> 4;
            if (H === 0) {
              if (W < 15) break;
              nt += 16;
            } else {
              nt += W;
              const it = uy[nt];
              tt[it] = y(H), nt++;
            }
          }
        }
        function _(G, tt) {
          const J = p(G.huffmanTableDC), et = J === 0 ? 0 : y(J) << l;
          G.pred += et, tt[0] = G.pred;
        }
        function E(G, tt) {
          tt[0] |= A() << l;
        }
        let I = 0;
        function x(G, tt) {
          if (I > 0) {
            I--;
            return;
          }
          let J = a;
          const et = o;
          for (; J <= et; ) {
            const nt = p(G.huffmanTableAC), gt = nt & 15, H = nt >> 4;
            if (gt === 0) {
              if (H < 15) {
                I = v(H) + (1 << H) - 1;
                break;
              }
              J += 16;
            } else {
              J += H;
              const W = uy[J];
              tt[W] = y(gt) * (1 << l), J++;
            }
          }
        }
        let w = 0, C;
        function S(G, tt) {
          let J = a;
          const et = o;
          let nt = 0;
          for (; J <= et; ) {
            const gt = uy[J], H = tt[gt] < 0 ? -1 : 1;
            switch (w) {
              case 0: {
                const W = p(G.huffmanTableAC), it = W & 15;
                if (nt = W >> 4, it === 0) nt < 15 ? (I = v(nt) + (1 << nt), w = 4) : (nt = 16, w = 1);
                else {
                  if (it !== 1) throw new Error("invalid ACn encoding");
                  C = y(it), w = nt ? 2 : 3;
                }
                continue;
              }
              case 1:
              case 2:
                tt[gt] ? tt[gt] += (A() << l) * H : (nt--, nt === 0 && (w = w === 2 ? 3 : 0));
                break;
              case 3:
                tt[gt] ? tt[gt] += (A() << l) * H : (tt[gt] = C << l, w = 0);
                break;
              case 4:
                tt[gt] && (tt[gt] += (A() << l) * H);
                break;
            }
            J++;
          }
          w === 4 && (I--, I === 0 && (w = 0));
        }
        function b(G, tt, J, et, nt) {
          const gt = J / u | 0, H = J % u, W = gt * G.v + et, it = H * G.h + nt;
          tt(G, G.blocks[W][it]);
        }
        function B(G, tt, J) {
          const et = J / G.blocksPerLine | 0, nt = J % G.blocksPerLine;
          tt(G, G.blocks[et][nt]);
        }
        const T = i.length;
        let D, R, L, k, P, F;
        h ? a === 0 ? F = s === 0 ? _ : E : F = s === 0 ? x : S : F = m;
        let Q = 0, z, j;
        T === 1 ? j = i[0].blocksPerLine * i[0].blocksPerColumn : j = u * e.mcusPerColumn;
        const $ = r || j;
        for (; Q < j; ) {
          for (R = 0; R < T; R++) i[R].pred = 0;
          if (I = 0, T === 1) for (D = i[0], P = 0; P < $; P++) B(D, F, Q), Q++;
          else for (P = 0; P < $; P++) {
            for (R = 0; R < T; R++) {
              D = i[R];
              const { h: G, v: tt } = D;
              for (L = 0; L < tt; L++) for (k = 0; k < G; k++) b(D, F, Q, L, k);
            }
            if (Q++, Q === j) break;
          }
          if (d = 0, z = n[f] << 8 | n[f + 1], z < 65280) throw new Error("marker was not found");
          if (z >= 65488 && z <= 65495) f += 2;
          else break;
        }
        return f - c;
      }
      function AQt(n, t) {
        const e = [], { blocksPerLine: i, blocksPerColumn: r } = t, a = i << 3, o = new Int32Array(64), s = new Uint8Array(64);
        function l(u, h, c) {
          const f = t.quantizationTable;
          let g, d, A, p, v, y, m, _, E;
          const I = c;
          let x;
          for (x = 0; x < 64; x++) I[x] = u[x] * f[x];
          for (x = 0; x < 8; ++x) {
            const w = 8 * x;
            if (I[1 + w] === 0 && I[2 + w] === 0 && I[3 + w] === 0 && I[4 + w] === 0 && I[5 + w] === 0 && I[6 + w] === 0 && I[7 + w] === 0) {
              E = md * I[0 + w] + 512 >> 10, I[0 + w] = E, I[1 + w] = E, I[2 + w] = E, I[3 + w] = E, I[4 + w] = E, I[5 + w] = E, I[6 + w] = E, I[7 + w] = E;
              continue;
            }
            g = md * I[0 + w] + 128 >> 8, d = md * I[4 + w] + 128 >> 8, A = I[2 + w], p = I[6 + w], v = SE * (I[1 + w] - I[7 + w]) + 128 >> 8, _ = SE * (I[1 + w] + I[7 + w]) + 128 >> 8, y = I[3 + w] << 4, m = I[5 + w] << 4, E = g - d + 1 >> 1, g = g + d + 1 >> 1, d = E, E = A * CE + p * wE + 128 >> 8, A = A * wE - p * CE + 128 >> 8, p = E, E = v - m + 1 >> 1, v = v + m + 1 >> 1, m = E, E = _ + y + 1 >> 1, y = _ - y + 1 >> 1, _ = E, E = g - p + 1 >> 1, g = g + p + 1 >> 1, p = E, E = d - A + 1 >> 1, d = d + A + 1 >> 1, A = E, E = v * xE + _ * EE + 2048 >> 12, v = v * EE - _ * xE + 2048 >> 12, _ = E, E = y * IE + m * _E + 2048 >> 12, y = y * _E - m * IE + 2048 >> 12, m = E, I[0 + w] = g + _, I[7 + w] = g - _, I[1 + w] = d + m, I[6 + w] = d - m, I[2 + w] = A + y, I[5 + w] = A - y, I[3 + w] = p + v, I[4 + w] = p - v;
          }
          for (x = 0; x < 8; ++x) {
            const w = x;
            if (I[1 * 8 + w] === 0 && I[2 * 8 + w] === 0 && I[3 * 8 + w] === 0 && I[4 * 8 + w] === 0 && I[5 * 8 + w] === 0 && I[6 * 8 + w] === 0 && I[7 * 8 + w] === 0) {
              E = md * c[x + 0] + 8192 >> 14, I[0 * 8 + w] = E, I[1 * 8 + w] = E, I[2 * 8 + w] = E, I[3 * 8 + w] = E, I[4 * 8 + w] = E, I[5 * 8 + w] = E, I[6 * 8 + w] = E, I[7 * 8 + w] = E;
              continue;
            }
            g = md * I[0 * 8 + w] + 2048 >> 12, d = md * I[4 * 8 + w] + 2048 >> 12, A = I[2 * 8 + w], p = I[6 * 8 + w], v = SE * (I[1 * 8 + w] - I[7 * 8 + w]) + 2048 >> 12, _ = SE * (I[1 * 8 + w] + I[7 * 8 + w]) + 2048 >> 12, y = I[3 * 8 + w], m = I[5 * 8 + w], E = g - d + 1 >> 1, g = g + d + 1 >> 1, d = E, E = A * CE + p * wE + 2048 >> 12, A = A * wE - p * CE + 2048 >> 12, p = E, E = v - m + 1 >> 1, v = v + m + 1 >> 1, m = E, E = _ + y + 1 >> 1, y = _ - y + 1 >> 1, _ = E, E = g - p + 1 >> 1, g = g + p + 1 >> 1, p = E, E = d - A + 1 >> 1, d = d + A + 1 >> 1, A = E, E = v * xE + _ * EE + 2048 >> 12, v = v * EE - _ * xE + 2048 >> 12, _ = E, E = y * IE + m * _E + 2048 >> 12, y = y * _E - m * IE + 2048 >> 12, m = E, I[0 * 8 + w] = g + _, I[7 * 8 + w] = g - _, I[1 * 8 + w] = d + m, I[6 * 8 + w] = d - m, I[2 * 8 + w] = A + y, I[5 * 8 + w] = A - y, I[3 * 8 + w] = p + v, I[4 * 8 + w] = p - v;
          }
          for (x = 0; x < 64; ++x) {
            const w = 128 + (I[x] + 8 >> 4);
            w < 0 ? h[x] = 0 : w > 255 ? h[x] = 255 : h[x] = w;
          }
        }
        for (let u = 0; u < r; u++) {
          const h = u << 3;
          for (let c = 0; c < 8; c++) e.push(new Uint8Array(a));
          for (let c = 0; c < i; c++) {
            l(t.blocks[u][c], s, o);
            let f = 0;
            const g = c << 3;
            for (let d = 0; d < 8; d++) {
              const A = e[h + d];
              for (let p = 0; p < 8; p++) A[g + p] = s[f++];
            }
          }
        }
        return e;
      }
      class pQt {
        constructor() {
          this.jfif = null, this.adobe = null, this.quantizationTables = [], this.huffmanTablesAC = [], this.huffmanTablesDC = [], this.resetFrames();
        }
        resetFrames() {
          this.frames = [];
        }
        parse(t) {
          let e = 0;
          function i() {
            const s = t[e] << 8 | t[e + 1];
            return e += 2, s;
          }
          function r() {
            const s = i(), l = t.subarray(e, e + s - 2);
            return e += l.length, l;
          }
          function a(s) {
            let l = 0, u = 0, h, c;
            for (c in s.components) s.components.hasOwnProperty(c) && (h = s.components[c], l < h.h && (l = h.h), u < h.v && (u = h.v));
            const f = Math.ceil(s.samplesPerLine / 8 / l), g = Math.ceil(s.scanLines / 8 / u);
            for (c in s.components) if (s.components.hasOwnProperty(c)) {
              h = s.components[c];
              const d = Math.ceil(Math.ceil(s.samplesPerLine / 8) * h.h / l), A = Math.ceil(Math.ceil(s.scanLines / 8) * h.v / u), p = f * h.h, v = g * h.v, y = [];
              for (let m = 0; m < v; m++) {
                const _ = [];
                for (let E = 0; E < p; E++) _.push(new Int32Array(64));
                y.push(_);
              }
              h.blocksPerLine = d, h.blocksPerColumn = A, h.blocks = y;
            }
            s.maxH = l, s.maxV = u, s.mcusPerLine = f, s.mcusPerColumn = g;
          }
          let o = i();
          if (o !== 65496) throw new Error("SOI not found");
          for (o = i(); o !== 65497; ) {
            switch (o) {
              case 65280:
                break;
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534: {
                const s = r();
                o === 65504 && s[0] === 74 && s[1] === 70 && s[2] === 73 && s[3] === 70 && s[4] === 0 && (this.jfif = { version: { major: s[5], minor: s[6] }, densityUnits: s[7], xDensity: s[8] << 8 | s[9], yDensity: s[10] << 8 | s[11], thumbWidth: s[12], thumbHeight: s[13], thumbData: s.subarray(14, 14 + 3 * s[12] * s[13]) }), o === 65518 && s[0] === 65 && s[1] === 100 && s[2] === 111 && s[3] === 98 && s[4] === 101 && s[5] === 0 && (this.adobe = { version: s[6], flags0: s[7] << 8 | s[8], flags1: s[9] << 8 | s[10], transformCode: s[11] });
                break;
              }
              case 65499: {
                const l = i() + e - 2;
                for (; e < l; ) {
                  const u = t[e++], h = new Int32Array(64);
                  if (u >> 4) if (u >> 4 === 1) for (let c = 0; c < 64; c++) {
                    const f = uy[c];
                    h[f] = i();
                  }
                  else throw new Error("DQT: invalid table spec");
                  else for (let c = 0; c < 64; c++) {
                    const f = uy[c];
                    h[f] = t[e++];
                  }
                  this.quantizationTables[u & 15] = h;
                }
                break;
              }
              case 65472:
              case 65473:
              case 65474: {
                i();
                const s = { extended: o === 65473, progressive: o === 65474, precision: t[e++], scanLines: i(), samplesPerLine: i(), components: {}, componentsOrder: [] }, l = t[e++];
                let u;
                for (let h = 0; h < l; h++) {
                  u = t[e];
                  const c = t[e + 1] >> 4, f = t[e + 1] & 15, g = t[e + 2];
                  s.componentsOrder.push(u), s.components[u] = { h: c, v: f, quantizationIdx: g }, e += 3;
                }
                a(s), this.frames.push(s);
                break;
              }
              case 65476: {
                const s = i();
                for (let l = 2; l < s; ) {
                  const u = t[e++], h = new Uint8Array(16);
                  let c = 0;
                  for (let g = 0; g < 16; g++, e++) h[g] = t[e], c += h[g];
                  const f = new Uint8Array(c);
                  for (let g = 0; g < c; g++, e++) f[g] = t[e];
                  l += 17 + c, u >> 4 ? this.huffmanTablesAC[u & 15] = yW(h, f) : this.huffmanTablesDC[u & 15] = yW(h, f);
                }
                break;
              }
              case 65501:
                i(), this.resetInterval = i();
                break;
              case 65498: {
                i();
                const s = t[e++], l = [], u = this.frames[0];
                for (let d = 0; d < s; d++) {
                  const A = u.components[t[e++]], p = t[e++];
                  A.huffmanTableDC = this.huffmanTablesDC[p >> 4], A.huffmanTableAC = this.huffmanTablesAC[p & 15], l.push(A);
                }
                const h = t[e++], c = t[e++], f = t[e++], g = dQt(t, e, u, l, this.resetInterval, h, c, f >> 4, f & 15);
                e += g;
                break;
              }
              case 65535:
                t[e] !== 255 && e--;
                break;
              default:
                if (t[e - 3] === 255 && t[e - 2] >= 192 && t[e - 2] <= 254) {
                  e -= 3;
                  break;
                }
                throw new Error(`unknown JPEG marker ${o.toString(16)}`);
            }
            o = i();
          }
        }
        getResult() {
          const { frames: t } = this;
          if (this.frames.length === 0) throw new Error("no frames were decoded");
          this.frames.length > 1;
          for (let h = 0; h < this.frames.length; h++) {
            const c = this.frames[h].components;
            for (const f of Object.keys(c)) c[f].quantizationTable = this.quantizationTables[c[f].quantizationIdx], delete c[f].quantizationIdx;
          }
          const e = t[0], { components: i, componentsOrder: r } = e, a = [], o = e.samplesPerLine, s = e.scanLines;
          for (let h = 0; h < r.length; h++) {
            const c = i[r[h]];
            a.push({ lines: AQt(e, c), scaleX: c.h / e.maxH, scaleY: c.v / e.maxV });
          }
          const l = new Uint8Array(o * s * a.length);
          let u = 0;
          for (let h = 0; h < s; ++h) for (let c = 0; c < o; ++c) for (let f = 0; f < a.length; ++f) {
            const g = a[f];
            l[u] = g.lines[0 | h * g.scaleY][0 | c * g.scaleX], ++u;
          }
          return l;
        }
      }
      class vQt extends Vu {
        constructor(t) {
          super(), this.reader = new pQt(), t.JPEGTables && this.reader.parse(t.JPEGTables);
        }
        decodeBlock(t) {
          return this.reader.resetFrames(), this.reader.parse(new Uint8Array(t)), this.reader.getResult().buffer;
        }
      }
      const yQt = Object.freeze(Object.defineProperty({ __proto__: null, default: vQt }, Symbol.toStringTag, { value: "Module" }));
      const mQt = 4, mW = 0, _W = 1, _Qt = 2;
      function _d(n) {
        let t = n.length;
        for (; --t >= 0; ) n[t] = 0;
      }
      const IQt = 0, IW = 1, EQt = 2, xQt = 3, wQt = 258, GR = 29, hy = 256, cy = hy + 1 + GR, Id = 30, UR = 19, EW = 2 * cy + 1, Ec = 15, VR = 16, CQt = 7, jR = 256, xW = 16, wW = 17, CW = 18, qR = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]), bE = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), SQt = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]), SW = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), bQt = 512, Xs = new Array((cy + 2) * 2);
      _d(Xs);
      const fy = new Array(Id * 2);
      _d(fy);
      const gy = new Array(bQt);
      _d(gy);
      const dy = new Array(wQt - xQt + 1);
      _d(dy);
      const HR = new Array(GR);
      _d(HR);
      const BE = new Array(Id);
      _d(BE);
      function YR(n, t, e, i, r) {
        this.static_tree = n, this.extra_bits = t, this.extra_base = e, this.elems = i, this.max_length = r, this.has_stree = n && n.length;
      }
      let bW, BW, TW;
      function WR(n, t) {
        this.dyn_tree = n, this.max_code = 0, this.stat_desc = t;
      }
      const MW = (n) => n < 256 ? gy[n] : gy[256 + (n >>> 7)], Ay = (n, t) => {
        n.pending_buf[n.pending++] = t & 255, n.pending_buf[n.pending++] = t >>> 8 & 255;
      }, xr = (n, t, e) => {
        n.bi_valid > VR - e ? (n.bi_buf |= t << n.bi_valid & 65535, Ay(n, n.bi_buf), n.bi_buf = t >> VR - n.bi_valid, n.bi_valid += e - VR) : (n.bi_buf |= t << n.bi_valid & 65535, n.bi_valid += e);
      }, Xo = (n, t, e) => {
        xr(n, e[t * 2], e[t * 2 + 1]);
      }, DW = (n, t) => {
        let e = 0;
        do
          e |= n & 1, n >>>= 1, e <<= 1;
        while (--t > 0);
        return e >>> 1;
      }, BQt = (n) => {
        n.bi_valid === 16 ? (Ay(n, n.bi_buf), n.bi_buf = 0, n.bi_valid = 0) : n.bi_valid >= 8 && (n.pending_buf[n.pending++] = n.bi_buf & 255, n.bi_buf >>= 8, n.bi_valid -= 8);
      }, TQt = (n, t) => {
        const e = t.dyn_tree, i = t.max_code, r = t.stat_desc.static_tree, a = t.stat_desc.has_stree, o = t.stat_desc.extra_bits, s = t.stat_desc.extra_base, l = t.stat_desc.max_length;
        let u, h, c, f, g, d, A = 0;
        for (f = 0; f <= Ec; f++) n.bl_count[f] = 0;
        for (e[n.heap[n.heap_max] * 2 + 1] = 0, u = n.heap_max + 1; u < EW; u++) h = n.heap[u], f = e[e[h * 2 + 1] * 2 + 1] + 1, f > l && (f = l, A++), e[h * 2 + 1] = f, !(h > i) && (n.bl_count[f]++, g = 0, h >= s && (g = o[h - s]), d = e[h * 2], n.opt_len += d * (f + g), a && (n.static_len += d * (r[h * 2 + 1] + g)));
        if (A !== 0) {
          do {
            for (f = l - 1; n.bl_count[f] === 0; ) f--;
            n.bl_count[f]--, n.bl_count[f + 1] += 2, n.bl_count[l]--, A -= 2;
          } while (A > 0);
          for (f = l; f !== 0; f--) for (h = n.bl_count[f]; h !== 0; ) c = n.heap[--u], !(c > i) && (e[c * 2 + 1] !== f && (n.opt_len += (f - e[c * 2 + 1]) * e[c * 2], e[c * 2 + 1] = f), h--);
        }
      }, RW = (n, t, e) => {
        const i = new Array(Ec + 1);
        let r = 0, a, o;
        for (a = 1; a <= Ec; a++) r = r + e[a - 1] << 1, i[a] = r;
        for (o = 0; o <= t; o++) {
          let s = n[o * 2 + 1];
          s !== 0 && (n[o * 2] = DW(i[s]++, s));
        }
      }, MQt = () => {
        let n, t, e, i, r;
        const a = new Array(Ec + 1);
        for (e = 0, i = 0; i < GR - 1; i++) for (HR[i] = e, n = 0; n < 1 << qR[i]; n++) dy[e++] = i;
        for (dy[e - 1] = i, r = 0, i = 0; i < 16; i++) for (BE[i] = r, n = 0; n < 1 << bE[i]; n++) gy[r++] = i;
        for (r >>= 7; i < Id; i++) for (BE[i] = r << 7, n = 0; n < 1 << bE[i] - 7; n++) gy[256 + r++] = i;
        for (t = 0; t <= Ec; t++) a[t] = 0;
        for (n = 0; n <= 143; ) Xs[n * 2 + 1] = 8, n++, a[8]++;
        for (; n <= 255; ) Xs[n * 2 + 1] = 9, n++, a[9]++;
        for (; n <= 279; ) Xs[n * 2 + 1] = 7, n++, a[7]++;
        for (; n <= 287; ) Xs[n * 2 + 1] = 8, n++, a[8]++;
        for (RW(Xs, cy + 1, a), n = 0; n < Id; n++) fy[n * 2 + 1] = 5, fy[n * 2] = DW(n, 5);
        bW = new YR(Xs, qR, hy + 1, cy, Ec), BW = new YR(fy, bE, 0, Id, Ec), TW = new YR(new Array(0), SQt, 0, UR, CQt);
      }, LW = (n) => {
        let t;
        for (t = 0; t < cy; t++) n.dyn_ltree[t * 2] = 0;
        for (t = 0; t < Id; t++) n.dyn_dtree[t * 2] = 0;
        for (t = 0; t < UR; t++) n.bl_tree[t * 2] = 0;
        n.dyn_ltree[jR * 2] = 1, n.opt_len = n.static_len = 0, n.sym_next = n.matches = 0;
      }, PW = (n) => {
        n.bi_valid > 8 ? Ay(n, n.bi_buf) : n.bi_valid > 0 && (n.pending_buf[n.pending++] = n.bi_buf), n.bi_buf = 0, n.bi_valid = 0;
      }, NW = (n, t, e, i) => {
        const r = t * 2, a = e * 2;
        return n[r] < n[a] || n[r] === n[a] && i[t] <= i[e];
      }, XR = (n, t, e) => {
        const i = n.heap[e];
        let r = e << 1;
        for (; r <= n.heap_len && (r < n.heap_len && NW(t, n.heap[r + 1], n.heap[r], n.depth) && r++, !NW(t, i, n.heap[r], n.depth)); ) n.heap[e] = n.heap[r], e = r, r <<= 1;
        n.heap[e] = i;
      }, kW = (n, t, e) => {
        let i, r, a = 0, o, s;
        if (n.sym_next !== 0) do
          i = n.pending_buf[n.sym_buf + a++] & 255, i += (n.pending_buf[n.sym_buf + a++] & 255) << 8, r = n.pending_buf[n.sym_buf + a++], i === 0 ? Xo(n, r, t) : (o = dy[r], Xo(n, o + hy + 1, t), s = qR[o], s !== 0 && (r -= HR[o], xr(n, r, s)), i--, o = MW(i), Xo(n, o, e), s = bE[o], s !== 0 && (i -= BE[o], xr(n, i, s)));
        while (a < n.sym_next);
        Xo(n, jR, t);
      }, ZR = (n, t) => {
        const e = t.dyn_tree, i = t.stat_desc.static_tree, r = t.stat_desc.has_stree, a = t.stat_desc.elems;
        let o, s, l = -1, u;
        for (n.heap_len = 0, n.heap_max = EW, o = 0; o < a; o++) e[o * 2] !== 0 ? (n.heap[++n.heap_len] = l = o, n.depth[o] = 0) : e[o * 2 + 1] = 0;
        for (; n.heap_len < 2; ) u = n.heap[++n.heap_len] = l < 2 ? ++l : 0, e[u * 2] = 1, n.depth[u] = 0, n.opt_len--, r && (n.static_len -= i[u * 2 + 1]);
        for (t.max_code = l, o = n.heap_len >> 1; o >= 1; o--) XR(n, e, o);
        u = a;
        do
          o = n.heap[1], n.heap[1] = n.heap[n.heap_len--], XR(n, e, 1), s = n.heap[1], n.heap[--n.heap_max] = o, n.heap[--n.heap_max] = s, e[u * 2] = e[o * 2] + e[s * 2], n.depth[u] = (n.depth[o] >= n.depth[s] ? n.depth[o] : n.depth[s]) + 1, e[o * 2 + 1] = e[s * 2 + 1] = u, n.heap[1] = u++, XR(n, e, 1);
        while (n.heap_len >= 2);
        n.heap[--n.heap_max] = n.heap[1], TQt(n, t), RW(e, l, n.bl_count);
      }, FW = (n, t, e) => {
        let i, r = -1, a, o = t[0 * 2 + 1], s = 0, l = 7, u = 4;
        for (o === 0 && (l = 138, u = 3), t[(e + 1) * 2 + 1] = 65535, i = 0; i <= e; i++) a = o, o = t[(i + 1) * 2 + 1], !(++s < l && a === o) && (s < u ? n.bl_tree[a * 2] += s : a !== 0 ? (a !== r && n.bl_tree[a * 2]++, n.bl_tree[xW * 2]++) : s <= 10 ? n.bl_tree[wW * 2]++ : n.bl_tree[CW * 2]++, s = 0, r = a, o === 0 ? (l = 138, u = 3) : a === o ? (l = 6, u = 3) : (l = 7, u = 4));
      }, QW = (n, t, e) => {
        let i, r = -1, a, o = t[0 * 2 + 1], s = 0, l = 7, u = 4;
        for (o === 0 && (l = 138, u = 3), i = 0; i <= e; i++) if (a = o, o = t[(i + 1) * 2 + 1], !(++s < l && a === o)) {
          if (s < u) do
            Xo(n, a, n.bl_tree);
          while (--s !== 0);
          else a !== 0 ? (a !== r && (Xo(n, a, n.bl_tree), s--), Xo(n, xW, n.bl_tree), xr(n, s - 3, 2)) : s <= 10 ? (Xo(n, wW, n.bl_tree), xr(n, s - 3, 3)) : (Xo(n, CW, n.bl_tree), xr(n, s - 11, 7));
          s = 0, r = a, o === 0 ? (l = 138, u = 3) : a === o ? (l = 6, u = 3) : (l = 7, u = 4);
        }
      }, DQt = (n) => {
        let t;
        for (FW(n, n.dyn_ltree, n.l_desc.max_code), FW(n, n.dyn_dtree, n.d_desc.max_code), ZR(n, n.bl_desc), t = UR - 1; t >= 3 && n.bl_tree[SW[t] * 2 + 1] === 0; t--) ;
        return n.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
      }, RQt = (n, t, e, i) => {
        let r;
        for (xr(n, t - 257, 5), xr(n, e - 1, 5), xr(n, i - 4, 4), r = 0; r < i; r++) xr(n, n.bl_tree[SW[r] * 2 + 1], 3);
        QW(n, n.dyn_ltree, t - 1), QW(n, n.dyn_dtree, e - 1);
      }, LQt = (n) => {
        let t = 4093624447, e;
        for (e = 0; e <= 31; e++, t >>>= 1) if (t & 1 && n.dyn_ltree[e * 2] !== 0) return mW;
        if (n.dyn_ltree[9 * 2] !== 0 || n.dyn_ltree[10 * 2] !== 0 || n.dyn_ltree[13 * 2] !== 0) return _W;
        for (e = 32; e < hy; e++) if (n.dyn_ltree[e * 2] !== 0) return _W;
        return mW;
      };
      let OW = false;
      const PQt = (n) => {
        OW || (MQt(), OW = true), n.l_desc = new WR(n.dyn_ltree, bW), n.d_desc = new WR(n.dyn_dtree, BW), n.bl_desc = new WR(n.bl_tree, TW), n.bi_buf = 0, n.bi_valid = 0, LW(n);
      }, zW = (n, t, e, i) => {
        xr(n, (IQt << 1) + (i ? 1 : 0), 3), PW(n), Ay(n, e), Ay(n, ~e), e && n.pending_buf.set(n.window.subarray(t, t + e), n.pending), n.pending += e;
      }, NQt = (n) => {
        xr(n, IW << 1, 3), Xo(n, jR, Xs), BQt(n);
      }, kQt = (n, t, e, i) => {
        let r, a, o = 0;
        n.level > 0 ? (n.strm.data_type === _Qt && (n.strm.data_type = LQt(n)), ZR(n, n.l_desc), ZR(n, n.d_desc), o = DQt(n), r = n.opt_len + 3 + 7 >>> 3, a = n.static_len + 3 + 7 >>> 3, a <= r && (r = a)) : r = a = e + 5, e + 4 <= r && t !== -1 ? zW(n, t, e, i) : n.strategy === mQt || a === r ? (xr(n, (IW << 1) + (i ? 1 : 0), 3), kW(n, Xs, fy)) : (xr(n, (EQt << 1) + (i ? 1 : 0), 3), RQt(n, n.l_desc.max_code + 1, n.d_desc.max_code + 1, o + 1), kW(n, n.dyn_ltree, n.dyn_dtree)), LW(n), i && PW(n);
      }, FQt = (n, t, e) => (n.pending_buf[n.sym_buf + n.sym_next++] = t, n.pending_buf[n.sym_buf + n.sym_next++] = t >> 8, n.pending_buf[n.sym_buf + n.sym_next++] = e, t === 0 ? n.dyn_ltree[e * 2]++ : (n.matches++, t--, n.dyn_ltree[(dy[e] + hy + 1) * 2]++, n.dyn_dtree[MW(t) * 2]++), n.sym_next === n.sym_end);
      var QQt = PQt, OQt = zW, zQt = kQt, GQt = FQt, UQt = NQt, VQt = { _tr_init: QQt, _tr_stored_block: OQt, _tr_flush_block: zQt, _tr_tally: GQt, _tr_align: UQt }, py = (n, t, e, i) => {
        let r = n & 65535 | 0, a = n >>> 16 & 65535 | 0, o = 0;
        for (; e !== 0; ) {
          o = e > 2e3 ? 2e3 : e, e -= o;
          do
            r = r + t[i++] | 0, a = a + r | 0;
          while (--o);
          r %= 65521, a %= 65521;
        }
        return r | a << 16 | 0;
      };
      const jQt = () => {
        let n, t = [];
        for (var e = 0; e < 256; e++) {
          n = e;
          for (var i = 0; i < 8; i++) n = n & 1 ? 3988292384 ^ n >>> 1 : n >>> 1;
          t[e] = n;
        }
        return t;
      }, qQt = new Uint32Array(jQt());
      var ui = (n, t, e, i) => {
        const r = qQt, a = i + e;
        n ^= -1;
        for (let o = i; o < a; o++) n = n >>> 8 ^ r[(n ^ t[o]) & 255];
        return n ^ -1;
      }, Ed = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }, vy = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      const { _tr_init: HQt, _tr_stored_block: KR, _tr_flush_block: YQt, _tr_tally: _u, _tr_align: WQt } = VQt, { Z_NO_FLUSH: Iu, Z_PARTIAL_FLUSH: XQt, Z_FULL_FLUSH: ZQt, Z_FINISH: Ca, Z_BLOCK: GW, Z_OK: mi, Z_STREAM_END: UW, Z_STREAM_ERROR: Zo, Z_DATA_ERROR: KQt, Z_BUF_ERROR: $R, Z_DEFAULT_COMPRESSION: $Qt, Z_FILTERED: JQt, Z_HUFFMAN_ONLY: TE, Z_RLE: tOt, Z_FIXED: eOt, Z_DEFAULT_STRATEGY: nOt, Z_UNKNOWN: iOt, Z_DEFLATED: ME } = vy, rOt = 9, aOt = 15, oOt = 8, JR = 256 + 1 + 29, sOt = 30, lOt = 19, uOt = 2 * JR + 1, hOt = 15, Me = 3, Eu = 258, Ko = Eu + Me + 1, cOt = 32, xd = 42, tL = 57, eL = 69, nL = 73, iL = 91, rL = 103, xc = 113, yy = 666, er = 1, wd = 2, wc = 3, Cd = 4, fOt = 3, Cc = (n, t) => (n.msg = Ed[t], t), VW = (n) => n * 2 - (n > 4 ? 9 : 0), xu = (n) => {
        let t = n.length;
        for (; --t >= 0; ) n[t] = 0;
      }, gOt = (n) => {
        let t, e, i, r = n.w_size;
        t = n.hash_size, i = t;
        do
          e = n.head[--i], n.head[i] = e >= r ? e - r : 0;
        while (--t);
        t = r, i = t;
        do
          e = n.prev[--i], n.prev[i] = e >= r ? e - r : 0;
        while (--t);
      };
      let wu = (n, t, e) => (t << n.hash_shift ^ e) & n.hash_mask;
      const jr = (n) => {
        const t = n.state;
        let e = t.pending;
        e > n.avail_out && (e = n.avail_out), e !== 0 && (n.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + e), n.next_out), n.next_out += e, t.pending_out += e, n.total_out += e, n.avail_out -= e, t.pending -= e, t.pending === 0 && (t.pending_out = 0));
      }, qr = (n, t) => {
        YQt(n, n.block_start >= 0 ? n.block_start : -1, n.strstart - n.block_start, t), n.block_start = n.strstart, jr(n.strm);
      }, je = (n, t) => {
        n.pending_buf[n.pending++] = t;
      }, my = (n, t) => {
        n.pending_buf[n.pending++] = t >>> 8 & 255, n.pending_buf[n.pending++] = t & 255;
      }, aL = (n, t, e, i) => {
        let r = n.avail_in;
        return r > i && (r = i), r === 0 ? 0 : (n.avail_in -= r, t.set(n.input.subarray(n.next_in, n.next_in + r), e), n.state.wrap === 1 ? n.adler = py(n.adler, t, r, e) : n.state.wrap === 2 && (n.adler = ui(n.adler, t, r, e)), n.next_in += r, n.total_in += r, r);
      }, jW = (n, t) => {
        let e = n.max_chain_length, i = n.strstart, r, a, o = n.prev_length, s = n.nice_match;
        const l = n.strstart > n.w_size - Ko ? n.strstart - (n.w_size - Ko) : 0, u = n.window, h = n.w_mask, c = n.prev, f = n.strstart + Eu;
        let g = u[i + o - 1], d = u[i + o];
        n.prev_length >= n.good_match && (e >>= 2), s > n.lookahead && (s = n.lookahead);
        do
          if (r = t, !(u[r + o] !== d || u[r + o - 1] !== g || u[r] !== u[i] || u[++r] !== u[i + 1])) {
            i += 2, r++;
            do
              ;
            while (u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && i < f);
            if (a = Eu - (f - i), i = f - Eu, a > o) {
              if (n.match_start = t, o = a, a >= s) break;
              g = u[i + o - 1], d = u[i + o];
            }
          }
        while ((t = c[t & h]) > l && --e !== 0);
        return o <= n.lookahead ? o : n.lookahead;
      }, Sd = (n) => {
        const t = n.w_size;
        let e, i, r;
        do {
          if (i = n.window_size - n.lookahead - n.strstart, n.strstart >= t + (t - Ko) && (n.window.set(n.window.subarray(t, t + t - i), 0), n.match_start -= t, n.strstart -= t, n.block_start -= t, n.insert > n.strstart && (n.insert = n.strstart), gOt(n), i += t), n.strm.avail_in === 0) break;
          if (e = aL(n.strm, n.window, n.strstart + n.lookahead, i), n.lookahead += e, n.lookahead + n.insert >= Me) for (r = n.strstart - n.insert, n.ins_h = n.window[r], n.ins_h = wu(n, n.ins_h, n.window[r + 1]); n.insert && (n.ins_h = wu(n, n.ins_h, n.window[r + Me - 1]), n.prev[r & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = r, r++, n.insert--, !(n.lookahead + n.insert < Me)); ) ;
        } while (n.lookahead < Ko && n.strm.avail_in !== 0);
      }, qW = (n, t) => {
        let e = n.pending_buf_size - 5 > n.w_size ? n.w_size : n.pending_buf_size - 5, i, r, a, o = 0, s = n.strm.avail_in;
        do {
          if (i = 65535, a = n.bi_valid + 42 >> 3, n.strm.avail_out < a || (a = n.strm.avail_out - a, r = n.strstart - n.block_start, i > r + n.strm.avail_in && (i = r + n.strm.avail_in), i > a && (i = a), i < e && (i === 0 && t !== Ca || t === Iu || i !== r + n.strm.avail_in))) break;
          o = t === Ca && i === r + n.strm.avail_in ? 1 : 0, KR(n, 0, 0, o), n.pending_buf[n.pending - 4] = i, n.pending_buf[n.pending - 3] = i >> 8, n.pending_buf[n.pending - 2] = ~i, n.pending_buf[n.pending - 1] = ~i >> 8, jr(n.strm), r && (r > i && (r = i), n.strm.output.set(n.window.subarray(n.block_start, n.block_start + r), n.strm.next_out), n.strm.next_out += r, n.strm.avail_out -= r, n.strm.total_out += r, n.block_start += r, i -= r), i && (aL(n.strm, n.strm.output, n.strm.next_out, i), n.strm.next_out += i, n.strm.avail_out -= i, n.strm.total_out += i);
        } while (o === 0);
        return s -= n.strm.avail_in, s && (s >= n.w_size ? (n.matches = 2, n.window.set(n.strm.input.subarray(n.strm.next_in - n.w_size, n.strm.next_in), 0), n.strstart = n.w_size, n.insert = n.strstart) : (n.window_size - n.strstart <= s && (n.strstart -= n.w_size, n.window.set(n.window.subarray(n.w_size, n.w_size + n.strstart), 0), n.matches < 2 && n.matches++, n.insert > n.strstart && (n.insert = n.strstart)), n.window.set(n.strm.input.subarray(n.strm.next_in - s, n.strm.next_in), n.strstart), n.strstart += s, n.insert += s > n.w_size - n.insert ? n.w_size - n.insert : s), n.block_start = n.strstart), n.high_water < n.strstart && (n.high_water = n.strstart), o ? Cd : t !== Iu && t !== Ca && n.strm.avail_in === 0 && n.strstart === n.block_start ? wd : (a = n.window_size - n.strstart, n.strm.avail_in > a && n.block_start >= n.w_size && (n.block_start -= n.w_size, n.strstart -= n.w_size, n.window.set(n.window.subarray(n.w_size, n.w_size + n.strstart), 0), n.matches < 2 && n.matches++, a += n.w_size, n.insert > n.strstart && (n.insert = n.strstart)), a > n.strm.avail_in && (a = n.strm.avail_in), a && (aL(n.strm, n.window, n.strstart, a), n.strstart += a, n.insert += a > n.w_size - n.insert ? n.w_size - n.insert : a), n.high_water < n.strstart && (n.high_water = n.strstart), a = n.bi_valid + 42 >> 3, a = n.pending_buf_size - a > 65535 ? 65535 : n.pending_buf_size - a, e = a > n.w_size ? n.w_size : a, r = n.strstart - n.block_start, (r >= e || (r || t === Ca) && t !== Iu && n.strm.avail_in === 0 && r <= a) && (i = r > a ? a : r, o = t === Ca && n.strm.avail_in === 0 && i === r ? 1 : 0, KR(n, n.block_start, i, o), n.block_start += i, jr(n.strm)), o ? wc : er);
      }, oL = (n, t) => {
        let e, i;
        for (; ; ) {
          if (n.lookahead < Ko) {
            if (Sd(n), n.lookahead < Ko && t === Iu) return er;
            if (n.lookahead === 0) break;
          }
          if (e = 0, n.lookahead >= Me && (n.ins_h = wu(n, n.ins_h, n.window[n.strstart + Me - 1]), e = n.prev[n.strstart & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = n.strstart), e !== 0 && n.strstart - e <= n.w_size - Ko && (n.match_length = jW(n, e)), n.match_length >= Me) if (i = _u(n, n.strstart - n.match_start, n.match_length - Me), n.lookahead -= n.match_length, n.match_length <= n.max_lazy_match && n.lookahead >= Me) {
            n.match_length--;
            do
              n.strstart++, n.ins_h = wu(n, n.ins_h, n.window[n.strstart + Me - 1]), e = n.prev[n.strstart & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = n.strstart;
            while (--n.match_length !== 0);
            n.strstart++;
          } else n.strstart += n.match_length, n.match_length = 0, n.ins_h = n.window[n.strstart], n.ins_h = wu(n, n.ins_h, n.window[n.strstart + 1]);
          else i = _u(n, 0, n.window[n.strstart]), n.lookahead--, n.strstart++;
          if (i && (qr(n, false), n.strm.avail_out === 0)) return er;
        }
        return n.insert = n.strstart < Me - 1 ? n.strstart : Me - 1, t === Ca ? (qr(n, true), n.strm.avail_out === 0 ? wc : Cd) : n.sym_next && (qr(n, false), n.strm.avail_out === 0) ? er : wd;
      }, bd = (n, t) => {
        let e, i, r;
        for (; ; ) {
          if (n.lookahead < Ko) {
            if (Sd(n), n.lookahead < Ko && t === Iu) return er;
            if (n.lookahead === 0) break;
          }
          if (e = 0, n.lookahead >= Me && (n.ins_h = wu(n, n.ins_h, n.window[n.strstart + Me - 1]), e = n.prev[n.strstart & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = n.strstart), n.prev_length = n.match_length, n.prev_match = n.match_start, n.match_length = Me - 1, e !== 0 && n.prev_length < n.max_lazy_match && n.strstart - e <= n.w_size - Ko && (n.match_length = jW(n, e), n.match_length <= 5 && (n.strategy === JQt || n.match_length === Me && n.strstart - n.match_start > 4096) && (n.match_length = Me - 1)), n.prev_length >= Me && n.match_length <= n.prev_length) {
            r = n.strstart + n.lookahead - Me, i = _u(n, n.strstart - 1 - n.prev_match, n.prev_length - Me), n.lookahead -= n.prev_length - 1, n.prev_length -= 2;
            do
              ++n.strstart <= r && (n.ins_h = wu(n, n.ins_h, n.window[n.strstart + Me - 1]), e = n.prev[n.strstart & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = n.strstart);
            while (--n.prev_length !== 0);
            if (n.match_available = 0, n.match_length = Me - 1, n.strstart++, i && (qr(n, false), n.strm.avail_out === 0)) return er;
          } else if (n.match_available) {
            if (i = _u(n, 0, n.window[n.strstart - 1]), i && qr(n, false), n.strstart++, n.lookahead--, n.strm.avail_out === 0) return er;
          } else n.match_available = 1, n.strstart++, n.lookahead--;
        }
        return n.match_available && (i = _u(n, 0, n.window[n.strstart - 1]), n.match_available = 0), n.insert = n.strstart < Me - 1 ? n.strstart : Me - 1, t === Ca ? (qr(n, true), n.strm.avail_out === 0 ? wc : Cd) : n.sym_next && (qr(n, false), n.strm.avail_out === 0) ? er : wd;
      }, dOt = (n, t) => {
        let e, i, r, a;
        const o = n.window;
        for (; ; ) {
          if (n.lookahead <= Eu) {
            if (Sd(n), n.lookahead <= Eu && t === Iu) return er;
            if (n.lookahead === 0) break;
          }
          if (n.match_length = 0, n.lookahead >= Me && n.strstart > 0 && (r = n.strstart - 1, i = o[r], i === o[++r] && i === o[++r] && i === o[++r])) {
            a = n.strstart + Eu;
            do
              ;
            while (i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && r < a);
            n.match_length = Eu - (a - r), n.match_length > n.lookahead && (n.match_length = n.lookahead);
          }
          if (n.match_length >= Me ? (e = _u(n, 1, n.match_length - Me), n.lookahead -= n.match_length, n.strstart += n.match_length, n.match_length = 0) : (e = _u(n, 0, n.window[n.strstart]), n.lookahead--, n.strstart++), e && (qr(n, false), n.strm.avail_out === 0)) return er;
        }
        return n.insert = 0, t === Ca ? (qr(n, true), n.strm.avail_out === 0 ? wc : Cd) : n.sym_next && (qr(n, false), n.strm.avail_out === 0) ? er : wd;
      }, AOt = (n, t) => {
        let e;
        for (; ; ) {
          if (n.lookahead === 0 && (Sd(n), n.lookahead === 0)) {
            if (t === Iu) return er;
            break;
          }
          if (n.match_length = 0, e = _u(n, 0, n.window[n.strstart]), n.lookahead--, n.strstart++, e && (qr(n, false), n.strm.avail_out === 0)) return er;
        }
        return n.insert = 0, t === Ca ? (qr(n, true), n.strm.avail_out === 0 ? wc : Cd) : n.sym_next && (qr(n, false), n.strm.avail_out === 0) ? er : wd;
      };
      function $o(n, t, e, i, r) {
        this.good_length = n, this.max_lazy = t, this.nice_length = e, this.max_chain = i, this.func = r;
      }
      const _y = [new $o(0, 0, 0, 0, qW), new $o(4, 4, 8, 4, oL), new $o(4, 5, 16, 8, oL), new $o(4, 6, 32, 32, oL), new $o(4, 4, 16, 16, bd), new $o(8, 16, 32, 32, bd), new $o(8, 16, 128, 128, bd), new $o(8, 32, 128, 256, bd), new $o(32, 128, 258, 1024, bd), new $o(32, 258, 258, 4096, bd)], pOt = (n) => {
        n.window_size = 2 * n.w_size, xu(n.head), n.max_lazy_match = _y[n.level].max_lazy, n.good_match = _y[n.level].good_length, n.nice_match = _y[n.level].nice_length, n.max_chain_length = _y[n.level].max_chain, n.strstart = 0, n.block_start = 0, n.lookahead = 0, n.insert = 0, n.match_length = n.prev_length = Me - 1, n.match_available = 0, n.ins_h = 0;
      };
      function vOt() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = ME, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(uOt * 2), this.dyn_dtree = new Uint16Array((2 * sOt + 1) * 2), this.bl_tree = new Uint16Array((2 * lOt + 1) * 2), xu(this.dyn_ltree), xu(this.dyn_dtree), xu(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(hOt + 1), this.heap = new Uint16Array(2 * JR + 1), xu(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * JR + 1), xu(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      const Iy = (n) => {
        if (!n) return 1;
        const t = n.state;
        return !t || t.strm !== n || t.status !== xd && t.status !== tL && t.status !== eL && t.status !== nL && t.status !== iL && t.status !== rL && t.status !== xc && t.status !== yy ? 1 : 0;
      }, HW = (n) => {
        if (Iy(n)) return Cc(n, Zo);
        n.total_in = n.total_out = 0, n.data_type = iOt;
        const t = n.state;
        return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap === 2 ? tL : t.wrap ? xd : xc, n.adler = t.wrap === 2 ? 0 : 1, t.last_flush = -2, HQt(t), mi;
      }, YW = (n) => {
        const t = HW(n);
        return t === mi && pOt(n.state), t;
      }, yOt = (n, t) => Iy(n) || n.state.wrap !== 2 ? Zo : (n.state.gzhead = t, mi), WW = (n, t, e, i, r, a) => {
        if (!n) return Zo;
        let o = 1;
        if (t === $Qt && (t = 6), i < 0 ? (o = 0, i = -i) : i > 15 && (o = 2, i -= 16), r < 1 || r > rOt || e !== ME || i < 8 || i > 15 || t < 0 || t > 9 || a < 0 || a > eOt || i === 8 && o !== 1) return Cc(n, Zo);
        i === 8 && (i = 9);
        const s = new vOt();
        return n.state = s, s.strm = n, s.status = xd, s.wrap = o, s.gzhead = null, s.w_bits = i, s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = r + 7, s.hash_size = 1 << s.hash_bits, s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + Me - 1) / Me), s.window = new Uint8Array(s.w_size * 2), s.head = new Uint16Array(s.hash_size), s.prev = new Uint16Array(s.w_size), s.lit_bufsize = 1 << r + 6, s.pending_buf_size = s.lit_bufsize * 4, s.pending_buf = new Uint8Array(s.pending_buf_size), s.sym_buf = s.lit_bufsize, s.sym_end = (s.lit_bufsize - 1) * 3, s.level = t, s.strategy = a, s.method = e, YW(n);
      }, mOt = (n, t) => WW(n, t, ME, aOt, oOt, nOt), _Ot = (n, t) => {
        if (Iy(n) || t > GW || t < 0) return n ? Cc(n, Zo) : Zo;
        const e = n.state;
        if (!n.output || n.avail_in !== 0 && !n.input || e.status === yy && t !== Ca) return Cc(n, n.avail_out === 0 ? $R : Zo);
        const i = e.last_flush;
        if (e.last_flush = t, e.pending !== 0) {
          if (jr(n), n.avail_out === 0) return e.last_flush = -1, mi;
        } else if (n.avail_in === 0 && VW(t) <= VW(i) && t !== Ca) return Cc(n, $R);
        if (e.status === yy && n.avail_in !== 0) return Cc(n, $R);
        if (e.status === xd && e.wrap === 0 && (e.status = xc), e.status === xd) {
          let r = ME + (e.w_bits - 8 << 4) << 8, a = -1;
          if (e.strategy >= TE || e.level < 2 ? a = 0 : e.level < 6 ? a = 1 : e.level === 6 ? a = 2 : a = 3, r |= a << 6, e.strstart !== 0 && (r |= cOt), r += 31 - r % 31, my(e, r), e.strstart !== 0 && (my(e, n.adler >>> 16), my(e, n.adler & 65535)), n.adler = 1, e.status = xc, jr(n), e.pending !== 0) return e.last_flush = -1, mi;
        }
        if (e.status === tL) {
          if (n.adler = 0, je(e, 31), je(e, 139), je(e, 8), e.gzhead) je(e, (e.gzhead.text ? 1 : 0) + (e.gzhead.hcrc ? 2 : 0) + (e.gzhead.extra ? 4 : 0) + (e.gzhead.name ? 8 : 0) + (e.gzhead.comment ? 16 : 0)), je(e, e.gzhead.time & 255), je(e, e.gzhead.time >> 8 & 255), je(e, e.gzhead.time >> 16 & 255), je(e, e.gzhead.time >> 24 & 255), je(e, e.level === 9 ? 2 : e.strategy >= TE || e.level < 2 ? 4 : 0), je(e, e.gzhead.os & 255), e.gzhead.extra && e.gzhead.extra.length && (je(e, e.gzhead.extra.length & 255), je(e, e.gzhead.extra.length >> 8 & 255)), e.gzhead.hcrc && (n.adler = ui(n.adler, e.pending_buf, e.pending, 0)), e.gzindex = 0, e.status = eL;
          else if (je(e, 0), je(e, 0), je(e, 0), je(e, 0), je(e, 0), je(e, e.level === 9 ? 2 : e.strategy >= TE || e.level < 2 ? 4 : 0), je(e, fOt), e.status = xc, jr(n), e.pending !== 0) return e.last_flush = -1, mi;
        }
        if (e.status === eL) {
          if (e.gzhead.extra) {
            let r = e.pending, a = (e.gzhead.extra.length & 65535) - e.gzindex;
            for (; e.pending + a > e.pending_buf_size; ) {
              let s = e.pending_buf_size - e.pending;
              if (e.pending_buf.set(e.gzhead.extra.subarray(e.gzindex, e.gzindex + s), e.pending), e.pending = e.pending_buf_size, e.gzhead.hcrc && e.pending > r && (n.adler = ui(n.adler, e.pending_buf, e.pending - r, r)), e.gzindex += s, jr(n), e.pending !== 0) return e.last_flush = -1, mi;
              r = 0, a -= s;
            }
            let o = new Uint8Array(e.gzhead.extra);
            e.pending_buf.set(o.subarray(e.gzindex, e.gzindex + a), e.pending), e.pending += a, e.gzhead.hcrc && e.pending > r && (n.adler = ui(n.adler, e.pending_buf, e.pending - r, r)), e.gzindex = 0;
          }
          e.status = nL;
        }
        if (e.status === nL) {
          if (e.gzhead.name) {
            let r = e.pending, a;
            do {
              if (e.pending === e.pending_buf_size) {
                if (e.gzhead.hcrc && e.pending > r && (n.adler = ui(n.adler, e.pending_buf, e.pending - r, r)), jr(n), e.pending !== 0) return e.last_flush = -1, mi;
                r = 0;
              }
              e.gzindex < e.gzhead.name.length ? a = e.gzhead.name.charCodeAt(e.gzindex++) & 255 : a = 0, je(e, a);
            } while (a !== 0);
            e.gzhead.hcrc && e.pending > r && (n.adler = ui(n.adler, e.pending_buf, e.pending - r, r)), e.gzindex = 0;
          }
          e.status = iL;
        }
        if (e.status === iL) {
          if (e.gzhead.comment) {
            let r = e.pending, a;
            do {
              if (e.pending === e.pending_buf_size) {
                if (e.gzhead.hcrc && e.pending > r && (n.adler = ui(n.adler, e.pending_buf, e.pending - r, r)), jr(n), e.pending !== 0) return e.last_flush = -1, mi;
                r = 0;
              }
              e.gzindex < e.gzhead.comment.length ? a = e.gzhead.comment.charCodeAt(e.gzindex++) & 255 : a = 0, je(e, a);
            } while (a !== 0);
            e.gzhead.hcrc && e.pending > r && (n.adler = ui(n.adler, e.pending_buf, e.pending - r, r));
          }
          e.status = rL;
        }
        if (e.status === rL) {
          if (e.gzhead.hcrc) {
            if (e.pending + 2 > e.pending_buf_size && (jr(n), e.pending !== 0)) return e.last_flush = -1, mi;
            je(e, n.adler & 255), je(e, n.adler >> 8 & 255), n.adler = 0;
          }
          if (e.status = xc, jr(n), e.pending !== 0) return e.last_flush = -1, mi;
        }
        if (n.avail_in !== 0 || e.lookahead !== 0 || t !== Iu && e.status !== yy) {
          let r = e.level === 0 ? qW(e, t) : e.strategy === TE ? AOt(e, t) : e.strategy === tOt ? dOt(e, t) : _y[e.level].func(e, t);
          if ((r === wc || r === Cd) && (e.status = yy), r === er || r === wc) return n.avail_out === 0 && (e.last_flush = -1), mi;
          if (r === wd && (t === XQt ? WQt(e) : t !== GW && (KR(e, 0, 0, false), t === ZQt && (xu(e.head), e.lookahead === 0 && (e.strstart = 0, e.block_start = 0, e.insert = 0))), jr(n), n.avail_out === 0)) return e.last_flush = -1, mi;
        }
        return t !== Ca ? mi : e.wrap <= 0 ? UW : (e.wrap === 2 ? (je(e, n.adler & 255), je(e, n.adler >> 8 & 255), je(e, n.adler >> 16 & 255), je(e, n.adler >> 24 & 255), je(e, n.total_in & 255), je(e, n.total_in >> 8 & 255), je(e, n.total_in >> 16 & 255), je(e, n.total_in >> 24 & 255)) : (my(e, n.adler >>> 16), my(e, n.adler & 65535)), jr(n), e.wrap > 0 && (e.wrap = -e.wrap), e.pending !== 0 ? mi : UW);
      }, IOt = (n) => {
        if (Iy(n)) return Zo;
        const t = n.state.status;
        return n.state = null, t === xc ? Cc(n, KQt) : mi;
      }, EOt = (n, t) => {
        let e = t.length;
        if (Iy(n)) return Zo;
        const i = n.state, r = i.wrap;
        if (r === 2 || r === 1 && i.status !== xd || i.lookahead) return Zo;
        if (r === 1 && (n.adler = py(n.adler, t, e, 0)), i.wrap = 0, e >= i.w_size) {
          r === 0 && (xu(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0);
          let l = new Uint8Array(i.w_size);
          l.set(t.subarray(e - i.w_size, e), 0), t = l, e = i.w_size;
        }
        const a = n.avail_in, o = n.next_in, s = n.input;
        for (n.avail_in = e, n.next_in = 0, n.input = t, Sd(i); i.lookahead >= Me; ) {
          let l = i.strstart, u = i.lookahead - (Me - 1);
          do
            i.ins_h = wu(i, i.ins_h, i.window[l + Me - 1]), i.prev[l & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = l, l++;
          while (--u);
          i.strstart = l, i.lookahead = Me - 1, Sd(i);
        }
        return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = Me - 1, i.match_available = 0, n.next_in = o, n.input = s, n.avail_in = a, i.wrap = r, mi;
      };
      var xOt = mOt, wOt = WW, COt = YW, SOt = HW, bOt = yOt, BOt = _Ot, TOt = IOt, MOt = EOt, DOt = "pako deflate (from Nodeca project)", Ey = { deflateInit: xOt, deflateInit2: wOt, deflateReset: COt, deflateResetKeep: SOt, deflateSetHeader: bOt, deflate: BOt, deflateEnd: TOt, deflateSetDictionary: MOt, deflateInfo: DOt };
      const ROt = (n, t) => Object.prototype.hasOwnProperty.call(n, t);
      var LOt = function(n) {
        const t = Array.prototype.slice.call(arguments, 1);
        for (; t.length; ) {
          const e = t.shift();
          if (e) {
            if (typeof e != "object") throw new TypeError(e + "must be non-object");
            for (const i in e) ROt(e, i) && (n[i] = e[i]);
          }
        }
        return n;
      }, POt = (n) => {
        let t = 0;
        for (let i = 0, r = n.length; i < r; i++) t += n[i].length;
        const e = new Uint8Array(t);
        for (let i = 0, r = 0, a = n.length; i < a; i++) {
          let o = n[i];
          e.set(o, r), r += o.length;
        }
        return e;
      }, DE = { assign: LOt, flattenChunks: POt };
      let XW = true;
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (n) {
        XW = false;
      }
      const xy = new Uint8Array(256);
      for (let n = 0; n < 256; n++) xy[n] = n >= 252 ? 6 : n >= 248 ? 5 : n >= 240 ? 4 : n >= 224 ? 3 : n >= 192 ? 2 : 1;
      xy[254] = xy[254] = 1;
      var NOt = (n) => {
        if (typeof TextEncoder == "function" && TextEncoder.prototype.encode) return new TextEncoder().encode(n);
        let t, e, i, r, a, o = n.length, s = 0;
        for (r = 0; r < o; r++) e = n.charCodeAt(r), (e & 64512) === 55296 && r + 1 < o && (i = n.charCodeAt(r + 1), (i & 64512) === 56320 && (e = 65536 + (e - 55296 << 10) + (i - 56320), r++)), s += e < 128 ? 1 : e < 2048 ? 2 : e < 65536 ? 3 : 4;
        for (t = new Uint8Array(s), a = 0, r = 0; a < s; r++) e = n.charCodeAt(r), (e & 64512) === 55296 && r + 1 < o && (i = n.charCodeAt(r + 1), (i & 64512) === 56320 && (e = 65536 + (e - 55296 << 10) + (i - 56320), r++)), e < 128 ? t[a++] = e : e < 2048 ? (t[a++] = 192 | e >>> 6, t[a++] = 128 | e & 63) : e < 65536 ? (t[a++] = 224 | e >>> 12, t[a++] = 128 | e >>> 6 & 63, t[a++] = 128 | e & 63) : (t[a++] = 240 | e >>> 18, t[a++] = 128 | e >>> 12 & 63, t[a++] = 128 | e >>> 6 & 63, t[a++] = 128 | e & 63);
        return t;
      };
      const kOt = (n, t) => {
        if (t < 65534 && n.subarray && XW) return String.fromCharCode.apply(null, n.length === t ? n : n.subarray(0, t));
        let e = "";
        for (let i = 0; i < t; i++) e += String.fromCharCode(n[i]);
        return e;
      };
      var FOt = (n, t) => {
        const e = t || n.length;
        if (typeof TextDecoder == "function" && TextDecoder.prototype.decode) return new TextDecoder().decode(n.subarray(0, t));
        let i, r;
        const a = new Array(e * 2);
        for (r = 0, i = 0; i < e; ) {
          let o = n[i++];
          if (o < 128) {
            a[r++] = o;
            continue;
          }
          let s = xy[o];
          if (s > 4) {
            a[r++] = 65533, i += s - 1;
            continue;
          }
          for (o &= s === 2 ? 31 : s === 3 ? 15 : 7; s > 1 && i < e; ) o = o << 6 | n[i++] & 63, s--;
          if (s > 1) {
            a[r++] = 65533;
            continue;
          }
          o < 65536 ? a[r++] = o : (o -= 65536, a[r++] = 55296 | o >> 10 & 1023, a[r++] = 56320 | o & 1023);
        }
        return kOt(a, r);
      }, QOt = (n, t) => {
        t = t || n.length, t > n.length && (t = n.length);
        let e = t - 1;
        for (; e >= 0 && (n[e] & 192) === 128; ) e--;
        return e < 0 || e === 0 ? t : e + xy[n[e]] > t ? e : t;
      }, wy = { string2buf: NOt, buf2string: FOt, utf8border: QOt };
      function OOt() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      }
      var ZW = OOt;
      const KW = Object.prototype.toString, { Z_NO_FLUSH: zOt, Z_SYNC_FLUSH: GOt, Z_FULL_FLUSH: UOt, Z_FINISH: VOt, Z_OK: RE, Z_STREAM_END: jOt, Z_DEFAULT_COMPRESSION: qOt, Z_DEFAULT_STRATEGY: HOt, Z_DEFLATED: YOt } = vy;
      function sL(n) {
        this.options = DE.assign({ level: qOt, method: YOt, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: HOt }, n || {});
        let t = this.options;
        t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new ZW(), this.strm.avail_out = 0;
        let e = Ey.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);
        if (e !== RE) throw new Error(Ed[e]);
        if (t.header && Ey.deflateSetHeader(this.strm, t.header), t.dictionary) {
          let i;
          if (typeof t.dictionary == "string" ? i = wy.string2buf(t.dictionary) : KW.call(t.dictionary) === "[object ArrayBuffer]" ? i = new Uint8Array(t.dictionary) : i = t.dictionary, e = Ey.deflateSetDictionary(this.strm, i), e !== RE) throw new Error(Ed[e]);
          this._dict_set = true;
        }
      }
      sL.prototype.push = function(n, t) {
        const e = this.strm, i = this.options.chunkSize;
        let r, a;
        if (this.ended) return false;
        for (t === ~~t ? a = t : a = t === true ? VOt : zOt, typeof n == "string" ? e.input = wy.string2buf(n) : KW.call(n) === "[object ArrayBuffer]" ? e.input = new Uint8Array(n) : e.input = n, e.next_in = 0, e.avail_in = e.input.length; ; ) {
          if (e.avail_out === 0 && (e.output = new Uint8Array(i), e.next_out = 0, e.avail_out = i), (a === GOt || a === UOt) && e.avail_out <= 6) {
            this.onData(e.output.subarray(0, e.next_out)), e.avail_out = 0;
            continue;
          }
          if (r = Ey.deflate(e, a), r === jOt) return e.next_out > 0 && this.onData(e.output.subarray(0, e.next_out)), r = Ey.deflateEnd(this.strm), this.onEnd(r), this.ended = true, r === RE;
          if (e.avail_out === 0) {
            this.onData(e.output);
            continue;
          }
          if (a > 0 && e.next_out > 0) {
            this.onData(e.output.subarray(0, e.next_out)), e.avail_out = 0;
            continue;
          }
          if (e.avail_in === 0) break;
        }
        return true;
      }, sL.prototype.onData = function(n) {
        this.chunks.push(n);
      }, sL.prototype.onEnd = function(n) {
        n === RE && (this.result = DE.flattenChunks(this.chunks)), this.chunks = [], this.err = n, this.msg = this.strm.msg;
      };
      const LE = 16209, WOt = 16191;
      var XOt = function(t, e) {
        let i, r, a, o, s, l, u, h, c, f, g, d, A, p, v, y, m, _, E, I, x, w, C, S;
        const b = t.state;
        i = t.next_in, C = t.input, r = i + (t.avail_in - 5), a = t.next_out, S = t.output, o = a - (e - t.avail_out), s = a + (t.avail_out - 257), l = b.dmax, u = b.wsize, h = b.whave, c = b.wnext, f = b.window, g = b.hold, d = b.bits, A = b.lencode, p = b.distcode, v = (1 << b.lenbits) - 1, y = (1 << b.distbits) - 1;
        t: do {
          d < 15 && (g += C[i++] << d, d += 8, g += C[i++] << d, d += 8), m = A[g & v];
          e: for (; ; ) {
            if (_ = m >>> 24, g >>>= _, d -= _, _ = m >>> 16 & 255, _ === 0) S[a++] = m & 65535;
            else if (_ & 16) {
              E = m & 65535, _ &= 15, _ && (d < _ && (g += C[i++] << d, d += 8), E += g & (1 << _) - 1, g >>>= _, d -= _), d < 15 && (g += C[i++] << d, d += 8, g += C[i++] << d, d += 8), m = p[g & y];
              n: for (; ; ) {
                if (_ = m >>> 24, g >>>= _, d -= _, _ = m >>> 16 & 255, _ & 16) {
                  if (I = m & 65535, _ &= 15, d < _ && (g += C[i++] << d, d += 8, d < _ && (g += C[i++] << d, d += 8)), I += g & (1 << _) - 1, I > l) {
                    t.msg = "invalid distance too far back", b.mode = LE;
                    break t;
                  }
                  if (g >>>= _, d -= _, _ = a - o, I > _) {
                    if (_ = I - _, _ > h && b.sane) {
                      t.msg = "invalid distance too far back", b.mode = LE;
                      break t;
                    }
                    if (x = 0, w = f, c === 0) {
                      if (x += u - _, _ < E) {
                        E -= _;
                        do
                          S[a++] = f[x++];
                        while (--_);
                        x = a - I, w = S;
                      }
                    } else if (c < _) {
                      if (x += u + c - _, _ -= c, _ < E) {
                        E -= _;
                        do
                          S[a++] = f[x++];
                        while (--_);
                        if (x = 0, c < E) {
                          _ = c, E -= _;
                          do
                            S[a++] = f[x++];
                          while (--_);
                          x = a - I, w = S;
                        }
                      }
                    } else if (x += c - _, _ < E) {
                      E -= _;
                      do
                        S[a++] = f[x++];
                      while (--_);
                      x = a - I, w = S;
                    }
                    for (; E > 2; ) S[a++] = w[x++], S[a++] = w[x++], S[a++] = w[x++], E -= 3;
                    E && (S[a++] = w[x++], E > 1 && (S[a++] = w[x++]));
                  } else {
                    x = a - I;
                    do
                      S[a++] = S[x++], S[a++] = S[x++], S[a++] = S[x++], E -= 3;
                    while (E > 2);
                    E && (S[a++] = S[x++], E > 1 && (S[a++] = S[x++]));
                  }
                } else if (_ & 64) {
                  t.msg = "invalid distance code", b.mode = LE;
                  break t;
                } else {
                  m = p[(m & 65535) + (g & (1 << _) - 1)];
                  continue n;
                }
                break;
              }
            } else if (_ & 64) if (_ & 32) {
              b.mode = WOt;
              break t;
            } else {
              t.msg = "invalid literal/length code", b.mode = LE;
              break t;
            }
            else {
              m = A[(m & 65535) + (g & (1 << _) - 1)];
              continue e;
            }
            break;
          }
        } while (i < r && a < s);
        E = d >> 3, i -= E, d -= E << 3, g &= (1 << d) - 1, t.next_in = i, t.next_out = a, t.avail_in = i < r ? 5 + (r - i) : 5 - (i - r), t.avail_out = a < s ? 257 + (s - a) : 257 - (a - s), b.hold = g, b.bits = d;
      };
      const Bd = 15, $W = 852, JW = 592, tX = 0, lL = 1, eX = 2, ZOt = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), KOt = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]), $Ot = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]), JOt = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
      var Cy = (n, t, e, i, r, a, o, s) => {
        const l = s.bits;
        let u = 0, h = 0, c = 0, f = 0, g = 0, d = 0, A = 0, p = 0, v = 0, y = 0, m, _, E, I, x, w = null, C;
        const S = new Uint16Array(Bd + 1), b = new Uint16Array(Bd + 1);
        let B = null, T, D, R;
        for (u = 0; u <= Bd; u++) S[u] = 0;
        for (h = 0; h < i; h++) S[t[e + h]]++;
        for (g = l, f = Bd; f >= 1 && S[f] === 0; f--) ;
        if (g > f && (g = f), f === 0) return r[a++] = 1 << 24 | 64 << 16 | 0, r[a++] = 1 << 24 | 64 << 16 | 0, s.bits = 1, 0;
        for (c = 1; c < f && S[c] === 0; c++) ;
        for (g < c && (g = c), p = 1, u = 1; u <= Bd; u++) if (p <<= 1, p -= S[u], p < 0) return -1;
        if (p > 0 && (n === tX || f !== 1)) return -1;
        for (b[1] = 0, u = 1; u < Bd; u++) b[u + 1] = b[u] + S[u];
        for (h = 0; h < i; h++) t[e + h] !== 0 && (o[b[t[e + h]]++] = h);
        if (n === tX ? (w = B = o, C = 20) : n === lL ? (w = ZOt, B = KOt, C = 257) : (w = $Ot, B = JOt, C = 0), y = 0, h = 0, u = c, x = a, d = g, A = 0, E = -1, v = 1 << g, I = v - 1, n === lL && v > $W || n === eX && v > JW) return 1;
        for (; ; ) {
          T = u - A, o[h] + 1 < C ? (D = 0, R = o[h]) : o[h] >= C ? (D = B[o[h] - C], R = w[o[h] - C]) : (D = 96, R = 0), m = 1 << u - A, _ = 1 << d, c = _;
          do
            _ -= m, r[x + (y >> A) + _] = T << 24 | D << 16 | R | 0;
          while (_ !== 0);
          for (m = 1 << u - 1; y & m; ) m >>= 1;
          if (m !== 0 ? (y &= m - 1, y += m) : y = 0, h++, --S[u] === 0) {
            if (u === f) break;
            u = t[e + o[h]];
          }
          if (u > g && (y & I) !== E) {
            for (A === 0 && (A = g), x += c, d = u - A, p = 1 << d; d + A < f && (p -= S[d + A], !(p <= 0)); ) d++, p <<= 1;
            if (v += 1 << d, n === lL && v > $W || n === eX && v > JW) return 1;
            E = y & I, r[E] = g << 24 | d << 16 | x - a | 0;
          }
        }
        return y !== 0 && (r[x + y] = u - A << 24 | 64 << 16 | 0), s.bits = g, 0;
      };
      const t3t = 0, nX = 1, iX = 2, { Z_FINISH: rX, Z_BLOCK: e3t, Z_TREES: PE, Z_OK: Sc, Z_STREAM_END: n3t, Z_NEED_DICT: i3t, Z_STREAM_ERROR: Sa, Z_DATA_ERROR: aX, Z_MEM_ERROR: oX, Z_BUF_ERROR: r3t, Z_DEFLATED: sX } = vy, NE = 16180, lX = 16181, uX = 16182, hX = 16183, cX = 16184, fX = 16185, gX = 16186, dX = 16187, AX = 16188, pX = 16189, kE = 16190, Zs = 16191, uL = 16192, vX = 16193, hL = 16194, yX = 16195, mX = 16196, _X = 16197, IX = 16198, FE = 16199, QE = 16200, EX = 16201, xX = 16202, wX = 16203, CX = 16204, SX = 16205, cL = 16206, bX = 16207, BX = 16208, cn = 16209, TX = 16210, MX = 16211, a3t = 852, o3t = 592, s3t = 15, DX = (n) => (n >>> 24 & 255) + (n >>> 8 & 65280) + ((n & 65280) << 8) + ((n & 255) << 24);
      function l3t() {
        this.strm = null, this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      const bc = (n) => {
        if (!n) return 1;
        const t = n.state;
        return !t || t.strm !== n || t.mode < NE || t.mode > MX ? 1 : 0;
      }, RX = (n) => {
        if (bc(n)) return Sa;
        const t = n.state;
        return n.total_in = n.total_out = t.total = 0, n.msg = "", t.wrap && (n.adler = t.wrap & 1), t.mode = NE, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(a3t), t.distcode = t.distdyn = new Int32Array(o3t), t.sane = 1, t.back = -1, Sc;
      }, LX = (n) => {
        if (bc(n)) return Sa;
        const t = n.state;
        return t.wsize = 0, t.whave = 0, t.wnext = 0, RX(n);
      }, PX = (n, t) => {
        let e;
        if (bc(n)) return Sa;
        const i = n.state;
        return t < 0 ? (e = 0, t = -t) : (e = (t >> 4) + 5, t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? Sa : (i.window !== null && i.wbits !== t && (i.window = null), i.wrap = e, i.wbits = t, LX(n));
      }, NX = (n, t) => {
        if (!n) return Sa;
        const e = new l3t();
        n.state = e, e.strm = n, e.window = null, e.mode = NE;
        const i = PX(n, t);
        return i !== Sc && (n.state = null), i;
      }, u3t = (n) => NX(n, s3t);
      let kX = true, fL, gL;
      const h3t = (n) => {
        if (kX) {
          fL = new Int32Array(512), gL = new Int32Array(32);
          let t = 0;
          for (; t < 144; ) n.lens[t++] = 8;
          for (; t < 256; ) n.lens[t++] = 9;
          for (; t < 280; ) n.lens[t++] = 7;
          for (; t < 288; ) n.lens[t++] = 8;
          for (Cy(nX, n.lens, 0, 288, fL, 0, n.work, { bits: 9 }), t = 0; t < 32; ) n.lens[t++] = 5;
          Cy(iX, n.lens, 0, 32, gL, 0, n.work, { bits: 5 }), kX = false;
        }
        n.lencode = fL, n.lenbits = 9, n.distcode = gL, n.distbits = 5;
      }, FX = (n, t, e, i) => {
        let r;
        const a = n.state;
        return a.window === null && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new Uint8Array(a.wsize)), i >= a.wsize ? (a.window.set(t.subarray(e - a.wsize, e), 0), a.wnext = 0, a.whave = a.wsize) : (r = a.wsize - a.wnext, r > i && (r = i), a.window.set(t.subarray(e - i, e - i + r), a.wnext), i -= r, i ? (a.window.set(t.subarray(e - i, e), 0), a.wnext = i, a.whave = a.wsize) : (a.wnext += r, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += r))), 0;
      }, c3t = (n, t) => {
        let e, i, r, a, o, s, l, u, h, c, f, g, d, A, p = 0, v, y, m, _, E, I, x, w;
        const C = new Uint8Array(4);
        let S, b;
        const B = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        if (bc(n) || !n.output || !n.input && n.avail_in !== 0) return Sa;
        e = n.state, e.mode === Zs && (e.mode = uL), o = n.next_out, r = n.output, l = n.avail_out, a = n.next_in, i = n.input, s = n.avail_in, u = e.hold, h = e.bits, c = s, f = l, w = Sc;
        t: for (; ; ) switch (e.mode) {
          case NE:
            if (e.wrap === 0) {
              e.mode = uL;
              break;
            }
            for (; h < 16; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            if (e.wrap & 2 && u === 35615) {
              e.wbits === 0 && (e.wbits = 15), e.check = 0, C[0] = u & 255, C[1] = u >>> 8 & 255, e.check = ui(e.check, C, 2, 0), u = 0, h = 0, e.mode = lX;
              break;
            }
            if (e.head && (e.head.done = false), !(e.wrap & 1) || (((u & 255) << 8) + (u >> 8)) % 31) {
              n.msg = "incorrect header check", e.mode = cn;
              break;
            }
            if ((u & 15) !== sX) {
              n.msg = "unknown compression method", e.mode = cn;
              break;
            }
            if (u >>>= 4, h -= 4, x = (u & 15) + 8, e.wbits === 0 && (e.wbits = x), x > 15 || x > e.wbits) {
              n.msg = "invalid window size", e.mode = cn;
              break;
            }
            e.dmax = 1 << e.wbits, e.flags = 0, n.adler = e.check = 1, e.mode = u & 512 ? pX : Zs, u = 0, h = 0;
            break;
          case lX:
            for (; h < 16; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            if (e.flags = u, (e.flags & 255) !== sX) {
              n.msg = "unknown compression method", e.mode = cn;
              break;
            }
            if (e.flags & 57344) {
              n.msg = "unknown header flags set", e.mode = cn;
              break;
            }
            e.head && (e.head.text = u >> 8 & 1), e.flags & 512 && e.wrap & 4 && (C[0] = u & 255, C[1] = u >>> 8 & 255, e.check = ui(e.check, C, 2, 0)), u = 0, h = 0, e.mode = uX;
          case uX:
            for (; h < 32; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            e.head && (e.head.time = u), e.flags & 512 && e.wrap & 4 && (C[0] = u & 255, C[1] = u >>> 8 & 255, C[2] = u >>> 16 & 255, C[3] = u >>> 24 & 255, e.check = ui(e.check, C, 4, 0)), u = 0, h = 0, e.mode = hX;
          case hX:
            for (; h < 16; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            e.head && (e.head.xflags = u & 255, e.head.os = u >> 8), e.flags & 512 && e.wrap & 4 && (C[0] = u & 255, C[1] = u >>> 8 & 255, e.check = ui(e.check, C, 2, 0)), u = 0, h = 0, e.mode = cX;
          case cX:
            if (e.flags & 1024) {
              for (; h < 16; ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              e.length = u, e.head && (e.head.extra_len = u), e.flags & 512 && e.wrap & 4 && (C[0] = u & 255, C[1] = u >>> 8 & 255, e.check = ui(e.check, C, 2, 0)), u = 0, h = 0;
            } else e.head && (e.head.extra = null);
            e.mode = fX;
          case fX:
            if (e.flags & 1024 && (g = e.length, g > s && (g = s), g && (e.head && (x = e.head.extra_len - e.length, e.head.extra || (e.head.extra = new Uint8Array(e.head.extra_len)), e.head.extra.set(i.subarray(a, a + g), x)), e.flags & 512 && e.wrap & 4 && (e.check = ui(e.check, i, g, a)), s -= g, a += g, e.length -= g), e.length)) break t;
            e.length = 0, e.mode = gX;
          case gX:
            if (e.flags & 2048) {
              if (s === 0) break t;
              g = 0;
              do
                x = i[a + g++], e.head && x && e.length < 65536 && (e.head.name += String.fromCharCode(x));
              while (x && g < s);
              if (e.flags & 512 && e.wrap & 4 && (e.check = ui(e.check, i, g, a)), s -= g, a += g, x) break t;
            } else e.head && (e.head.name = null);
            e.length = 0, e.mode = dX;
          case dX:
            if (e.flags & 4096) {
              if (s === 0) break t;
              g = 0;
              do
                x = i[a + g++], e.head && x && e.length < 65536 && (e.head.comment += String.fromCharCode(x));
              while (x && g < s);
              if (e.flags & 512 && e.wrap & 4 && (e.check = ui(e.check, i, g, a)), s -= g, a += g, x) break t;
            } else e.head && (e.head.comment = null);
            e.mode = AX;
          case AX:
            if (e.flags & 512) {
              for (; h < 16; ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              if (e.wrap & 4 && u !== (e.check & 65535)) {
                n.msg = "header crc mismatch", e.mode = cn;
                break;
              }
              u = 0, h = 0;
            }
            e.head && (e.head.hcrc = e.flags >> 9 & 1, e.head.done = true), n.adler = e.check = 0, e.mode = Zs;
            break;
          case pX:
            for (; h < 32; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            n.adler = e.check = DX(u), u = 0, h = 0, e.mode = kE;
          case kE:
            if (e.havedict === 0) return n.next_out = o, n.avail_out = l, n.next_in = a, n.avail_in = s, e.hold = u, e.bits = h, i3t;
            n.adler = e.check = 1, e.mode = Zs;
          case Zs:
            if (t === e3t || t === PE) break t;
          case uL:
            if (e.last) {
              u >>>= h & 7, h -= h & 7, e.mode = cL;
              break;
            }
            for (; h < 3; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            switch (e.last = u & 1, u >>>= 1, h -= 1, u & 3) {
              case 0:
                e.mode = vX;
                break;
              case 1:
                if (h3t(e), e.mode = FE, t === PE) {
                  u >>>= 2, h -= 2;
                  break t;
                }
                break;
              case 2:
                e.mode = mX;
                break;
              case 3:
                n.msg = "invalid block type", e.mode = cn;
            }
            u >>>= 2, h -= 2;
            break;
          case vX:
            for (u >>>= h & 7, h -= h & 7; h < 32; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            if ((u & 65535) !== (u >>> 16 ^ 65535)) {
              n.msg = "invalid stored block lengths", e.mode = cn;
              break;
            }
            if (e.length = u & 65535, u = 0, h = 0, e.mode = hL, t === PE) break t;
          case hL:
            e.mode = yX;
          case yX:
            if (g = e.length, g) {
              if (g > s && (g = s), g > l && (g = l), g === 0) break t;
              r.set(i.subarray(a, a + g), o), s -= g, a += g, l -= g, o += g, e.length -= g;
              break;
            }
            e.mode = Zs;
            break;
          case mX:
            for (; h < 14; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            if (e.nlen = (u & 31) + 257, u >>>= 5, h -= 5, e.ndist = (u & 31) + 1, u >>>= 5, h -= 5, e.ncode = (u & 15) + 4, u >>>= 4, h -= 4, e.nlen > 286 || e.ndist > 30) {
              n.msg = "too many length or distance symbols", e.mode = cn;
              break;
            }
            e.have = 0, e.mode = _X;
          case _X:
            for (; e.have < e.ncode; ) {
              for (; h < 3; ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              e.lens[B[e.have++]] = u & 7, u >>>= 3, h -= 3;
            }
            for (; e.have < 19; ) e.lens[B[e.have++]] = 0;
            if (e.lencode = e.lendyn, e.lenbits = 7, S = { bits: e.lenbits }, w = Cy(t3t, e.lens, 0, 19, e.lencode, 0, e.work, S), e.lenbits = S.bits, w) {
              n.msg = "invalid code lengths set", e.mode = cn;
              break;
            }
            e.have = 0, e.mode = IX;
          case IX:
            for (; e.have < e.nlen + e.ndist; ) {
              for (; p = e.lencode[u & (1 << e.lenbits) - 1], v = p >>> 24, y = p >>> 16 & 255, m = p & 65535, !(v <= h); ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              if (m < 16) u >>>= v, h -= v, e.lens[e.have++] = m;
              else {
                if (m === 16) {
                  for (b = v + 2; h < b; ) {
                    if (s === 0) break t;
                    s--, u += i[a++] << h, h += 8;
                  }
                  if (u >>>= v, h -= v, e.have === 0) {
                    n.msg = "invalid bit length repeat", e.mode = cn;
                    break;
                  }
                  x = e.lens[e.have - 1], g = 3 + (u & 3), u >>>= 2, h -= 2;
                } else if (m === 17) {
                  for (b = v + 3; h < b; ) {
                    if (s === 0) break t;
                    s--, u += i[a++] << h, h += 8;
                  }
                  u >>>= v, h -= v, x = 0, g = 3 + (u & 7), u >>>= 3, h -= 3;
                } else {
                  for (b = v + 7; h < b; ) {
                    if (s === 0) break t;
                    s--, u += i[a++] << h, h += 8;
                  }
                  u >>>= v, h -= v, x = 0, g = 11 + (u & 127), u >>>= 7, h -= 7;
                }
                if (e.have + g > e.nlen + e.ndist) {
                  n.msg = "invalid bit length repeat", e.mode = cn;
                  break;
                }
                for (; g--; ) e.lens[e.have++] = x;
              }
            }
            if (e.mode === cn) break;
            if (e.lens[256] === 0) {
              n.msg = "invalid code -- missing end-of-block", e.mode = cn;
              break;
            }
            if (e.lenbits = 9, S = { bits: e.lenbits }, w = Cy(nX, e.lens, 0, e.nlen, e.lencode, 0, e.work, S), e.lenbits = S.bits, w) {
              n.msg = "invalid literal/lengths set", e.mode = cn;
              break;
            }
            if (e.distbits = 6, e.distcode = e.distdyn, S = { bits: e.distbits }, w = Cy(iX, e.lens, e.nlen, e.ndist, e.distcode, 0, e.work, S), e.distbits = S.bits, w) {
              n.msg = "invalid distances set", e.mode = cn;
              break;
            }
            if (e.mode = FE, t === PE) break t;
          case FE:
            e.mode = QE;
          case QE:
            if (s >= 6 && l >= 258) {
              n.next_out = o, n.avail_out = l, n.next_in = a, n.avail_in = s, e.hold = u, e.bits = h, XOt(n, f), o = n.next_out, r = n.output, l = n.avail_out, a = n.next_in, i = n.input, s = n.avail_in, u = e.hold, h = e.bits, e.mode === Zs && (e.back = -1);
              break;
            }
            for (e.back = 0; p = e.lencode[u & (1 << e.lenbits) - 1], v = p >>> 24, y = p >>> 16 & 255, m = p & 65535, !(v <= h); ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            if (y && !(y & 240)) {
              for (_ = v, E = y, I = m; p = e.lencode[I + ((u & (1 << _ + E) - 1) >> _)], v = p >>> 24, y = p >>> 16 & 255, m = p & 65535, !(_ + v <= h); ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              u >>>= _, h -= _, e.back += _;
            }
            if (u >>>= v, h -= v, e.back += v, e.length = m, y === 0) {
              e.mode = SX;
              break;
            }
            if (y & 32) {
              e.back = -1, e.mode = Zs;
              break;
            }
            if (y & 64) {
              n.msg = "invalid literal/length code", e.mode = cn;
              break;
            }
            e.extra = y & 15, e.mode = EX;
          case EX:
            if (e.extra) {
              for (b = e.extra; h < b; ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              e.length += u & (1 << e.extra) - 1, u >>>= e.extra, h -= e.extra, e.back += e.extra;
            }
            e.was = e.length, e.mode = xX;
          case xX:
            for (; p = e.distcode[u & (1 << e.distbits) - 1], v = p >>> 24, y = p >>> 16 & 255, m = p & 65535, !(v <= h); ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            if (!(y & 240)) {
              for (_ = v, E = y, I = m; p = e.distcode[I + ((u & (1 << _ + E) - 1) >> _)], v = p >>> 24, y = p >>> 16 & 255, m = p & 65535, !(_ + v <= h); ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              u >>>= _, h -= _, e.back += _;
            }
            if (u >>>= v, h -= v, e.back += v, y & 64) {
              n.msg = "invalid distance code", e.mode = cn;
              break;
            }
            e.offset = m, e.extra = y & 15, e.mode = wX;
          case wX:
            if (e.extra) {
              for (b = e.extra; h < b; ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              e.offset += u & (1 << e.extra) - 1, u >>>= e.extra, h -= e.extra, e.back += e.extra;
            }
            if (e.offset > e.dmax) {
              n.msg = "invalid distance too far back", e.mode = cn;
              break;
            }
            e.mode = CX;
          case CX:
            if (l === 0) break t;
            if (g = f - l, e.offset > g) {
              if (g = e.offset - g, g > e.whave && e.sane) {
                n.msg = "invalid distance too far back", e.mode = cn;
                break;
              }
              g > e.wnext ? (g -= e.wnext, d = e.wsize - g) : d = e.wnext - g, g > e.length && (g = e.length), A = e.window;
            } else A = r, d = o - e.offset, g = e.length;
            g > l && (g = l), l -= g, e.length -= g;
            do
              r[o++] = A[d++];
            while (--g);
            e.length === 0 && (e.mode = QE);
            break;
          case SX:
            if (l === 0) break t;
            r[o++] = e.length, l--, e.mode = QE;
            break;
          case cL:
            if (e.wrap) {
              for (; h < 32; ) {
                if (s === 0) break t;
                s--, u |= i[a++] << h, h += 8;
              }
              if (f -= l, n.total_out += f, e.total += f, e.wrap & 4 && f && (n.adler = e.check = e.flags ? ui(e.check, r, f, o - f) : py(e.check, r, f, o - f)), f = l, e.wrap & 4 && (e.flags ? u : DX(u)) !== e.check) {
                n.msg = "incorrect data check", e.mode = cn;
                break;
              }
              u = 0, h = 0;
            }
            e.mode = bX;
          case bX:
            if (e.wrap && e.flags) {
              for (; h < 32; ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              if (e.wrap & 4 && u !== (e.total & 4294967295)) {
                n.msg = "incorrect length check", e.mode = cn;
                break;
              }
              u = 0, h = 0;
            }
            e.mode = BX;
          case BX:
            w = n3t;
            break t;
          case cn:
            w = aX;
            break t;
          case TX:
            return oX;
          case MX:
          default:
            return Sa;
        }
        return n.next_out = o, n.avail_out = l, n.next_in = a, n.avail_in = s, e.hold = u, e.bits = h, (e.wsize || f !== n.avail_out && e.mode < cn && (e.mode < cL || t !== rX)) && FX(n, n.output, n.next_out, f - n.avail_out), c -= n.avail_in, f -= n.avail_out, n.total_in += c, n.total_out += f, e.total += f, e.wrap & 4 && f && (n.adler = e.check = e.flags ? ui(e.check, r, f, n.next_out - f) : py(e.check, r, f, n.next_out - f)), n.data_type = e.bits + (e.last ? 64 : 0) + (e.mode === Zs ? 128 : 0) + (e.mode === FE || e.mode === hL ? 256 : 0), (c === 0 && f === 0 || t === rX) && w === Sc && (w = r3t), w;
      }, f3t = (n) => {
        if (bc(n)) return Sa;
        let t = n.state;
        return t.window && (t.window = null), n.state = null, Sc;
      }, g3t = (n, t) => {
        if (bc(n)) return Sa;
        const e = n.state;
        return e.wrap & 2 ? (e.head = t, t.done = false, Sc) : Sa;
      }, d3t = (n, t) => {
        const e = t.length;
        let i, r, a;
        return bc(n) || (i = n.state, i.wrap !== 0 && i.mode !== kE) ? Sa : i.mode === kE && (r = 1, r = py(r, t, e, 0), r !== i.check) ? aX : (a = FX(n, t, e, e), a ? (i.mode = TX, oX) : (i.havedict = 1, Sc));
      };
      var A3t = LX, p3t = PX, v3t = RX, y3t = u3t, m3t = NX, _3t = c3t, I3t = f3t, E3t = g3t, x3t = d3t, w3t = "pako inflate (from Nodeca project)", Ks = { inflateReset: A3t, inflateReset2: p3t, inflateResetKeep: v3t, inflateInit: y3t, inflateInit2: m3t, inflate: _3t, inflateEnd: I3t, inflateGetHeader: E3t, inflateSetDictionary: x3t, inflateInfo: w3t };
      function C3t() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      }
      var S3t = C3t;
      const QX = Object.prototype.toString, { Z_NO_FLUSH: b3t, Z_FINISH: B3t, Z_OK: Sy, Z_STREAM_END: dL, Z_NEED_DICT: AL, Z_STREAM_ERROR: T3t, Z_DATA_ERROR: OX, Z_MEM_ERROR: M3t } = vy;
      function by(n) {
        this.options = DE.assign({ chunkSize: 1024 * 64, windowBits: 15, to: "" }, n || {});
        const t = this.options;
        t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, t.windowBits === 0 && (t.windowBits = -15)), t.windowBits >= 0 && t.windowBits < 16 && !(n && n.windowBits) && (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (t.windowBits & 15 || (t.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new ZW(), this.strm.avail_out = 0;
        let e = Ks.inflateInit2(this.strm, t.windowBits);
        if (e !== Sy) throw new Error(Ed[e]);
        if (this.header = new S3t(), Ks.inflateGetHeader(this.strm, this.header), t.dictionary && (typeof t.dictionary == "string" ? t.dictionary = wy.string2buf(t.dictionary) : QX.call(t.dictionary) === "[object ArrayBuffer]" && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (e = Ks.inflateSetDictionary(this.strm, t.dictionary), e !== Sy))) throw new Error(Ed[e]);
      }
      by.prototype.push = function(n, t) {
        const e = this.strm, i = this.options.chunkSize, r = this.options.dictionary;
        let a, o, s;
        if (this.ended) return false;
        for (t === ~~t ? o = t : o = t === true ? B3t : b3t, QX.call(n) === "[object ArrayBuffer]" ? e.input = new Uint8Array(n) : e.input = n, e.next_in = 0, e.avail_in = e.input.length; ; ) {
          for (e.avail_out === 0 && (e.output = new Uint8Array(i), e.next_out = 0, e.avail_out = i), a = Ks.inflate(e, o), a === AL && r && (a = Ks.inflateSetDictionary(e, r), a === Sy ? a = Ks.inflate(e, o) : a === OX && (a = AL)); e.avail_in > 0 && a === dL && e.state.wrap > 0 && n[e.next_in] !== 0; ) Ks.inflateReset(e), a = Ks.inflate(e, o);
          switch (a) {
            case T3t:
            case OX:
            case AL:
            case M3t:
              return this.onEnd(a), this.ended = true, false;
          }
          if (s = e.avail_out, e.next_out && (e.avail_out === 0 || a === dL)) if (this.options.to === "string") {
            let l = wy.utf8border(e.output, e.next_out), u = e.next_out - l, h = wy.buf2string(e.output, l);
            e.next_out = u, e.avail_out = i - u, u && e.output.set(e.output.subarray(l, l + u), 0), this.onData(h);
          } else this.onData(e.output.length === e.next_out ? e.output : e.output.subarray(0, e.next_out));
          if (!(a === Sy && s === 0)) {
            if (a === dL) return a = Ks.inflateEnd(this.strm), this.onEnd(a), this.ended = true, true;
            if (e.avail_in === 0) break;
          }
        }
        return true;
      }, by.prototype.onData = function(n) {
        this.chunks.push(n);
      }, by.prototype.onEnd = function(n) {
        n === Sy && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = DE.flattenChunks(this.chunks)), this.chunks = [], this.err = n, this.msg = this.strm.msg;
      };
      function pL(n, t) {
        const e = new by(t);
        if (e.push(n), e.err) throw e.msg || Ed[e.err];
        return e.result;
      }
      function D3t(n, t) {
        return t = t || {}, t.raw = true, pL(n, t);
      }
      var R3t = by, L3t = pL, P3t = D3t, N3t = pL, k3t = vy, F3t = { Inflate: R3t, inflate: L3t, inflateRaw: P3t, ungzip: N3t, constants: k3t };
      const { Inflate: Bzt, inflate: Q3t, inflateRaw: Tzt, ungzip: Mzt } = F3t;
      var zX = Q3t;
      class O3t extends Vu {
        decodeBlock(t) {
          return zX(new Uint8Array(t)).buffer;
        }
      }
      const z3t = Object.freeze(Object.defineProperty({ __proto__: null, default: O3t }, Symbol.toStringTag, { value: "Module" }));
      class G3t extends Vu {
        decodeBlock(t) {
          const e = new DataView(t), i = [];
          for (let r = 0; r < t.byteLength; ++r) {
            let a = e.getInt8(r);
            if (a < 0) {
              const o = e.getUint8(r + 1);
              a = -a;
              for (let s = 0; s <= a; ++s) i.push(o);
              r += 1;
            } else {
              for (let o = 0; o <= a; ++o) i.push(e.getUint8(r + o + 1));
              r += a + 1;
            }
          }
          return new Uint8Array(i).buffer;
        }
      }
      const U3t = Object.freeze(Object.defineProperty({ __proto__: null, default: G3t }, Symbol.toStringTag, { value: "Module" }));
      var GX = { exports: {} };
      (function(n) {
        (function() {
          var t = function() {
            var a = {};
            a.defaultNoDataValue = -34027999387901484e22, a.decode = function(c, f) {
              f = f || {};
              var g = f.encodedMaskData || f.encodedMaskData === null, d = u(c, f.inputOffset || 0, g), A = f.noDataValue !== null ? f.noDataValue : a.defaultNoDataValue, p = o(d, f.pixelType || Float32Array, f.encodedMaskData, A, f.returnMask), v = { width: d.width, height: d.height, pixelData: p.resultPixels, minValue: p.minValue, maxValue: d.pixels.maxValue, noDataValue: A };
              return p.resultMask && (v.maskData = p.resultMask), f.returnEncodedMask && d.mask && (v.encodedMaskData = d.mask.bitset ? d.mask.bitset : null), f.returnFileInfo && (v.fileInfo = s(d), f.computeUsedBitDepths && (v.fileInfo.bitDepths = l(d))), v;
            };
            var o = function(c, f, g, d, A) {
              var p = 0, v = c.pixels.numBlocksX, y = c.pixels.numBlocksY, m = Math.floor(c.width / v), _ = Math.floor(c.height / y), E = 2 * c.maxZError, I = Number.MAX_VALUE, x;
              g = g || (c.mask ? c.mask.bitset : null);
              var w, C;
              w = new f(c.width * c.height), A && g && (C = new Uint8Array(c.width * c.height));
              for (var S = new Float32Array(m * _), b, B, T = 0; T <= y; T++) {
                var D = T !== y ? _ : c.height % y;
                if (D !== 0) for (var R = 0; R <= v; R++) {
                  var L = R !== v ? m : c.width % v;
                  if (L !== 0) {
                    var k = T * c.width * _ + R * m, P = c.width - L, F = c.pixels.blocks[p], Q, z, j;
                    F.encoding < 2 ? (F.encoding === 0 ? Q = F.rawData : (h(F.stuffedData, F.bitsPerPixel, F.numValidPixels, F.offset, E, S, c.pixels.maxValue), Q = S), z = 0) : F.encoding === 2 ? j = 0 : j = F.offset;
                    var $;
                    if (g) for (B = 0; B < D; B++) {
                      for (k & 7 && ($ = g[k >> 3], $ <<= k & 7), b = 0; b < L; b++) k & 7 || ($ = g[k >> 3]), $ & 128 ? (C && (C[k] = 1), x = F.encoding < 2 ? Q[z++] : j, I = I > x ? x : I, w[k++] = x) : (C && (C[k] = 0), w[k++] = d), $ <<= 1;
                      k += P;
                    }
                    else if (F.encoding < 2) for (B = 0; B < D; B++) {
                      for (b = 0; b < L; b++) x = Q[z++], I = I > x ? x : I, w[k++] = x;
                      k += P;
                    }
                    else for (I = I > j ? j : I, B = 0; B < D; B++) {
                      for (b = 0; b < L; b++) w[k++] = j;
                      k += P;
                    }
                    if (F.encoding === 1 && z !== F.numValidPixels) throw "Block and Mask do not match";
                    p++;
                  }
                }
              }
              return { resultPixels: w, resultMask: C, minValue: I };
            }, s = function(c) {
              return { fileIdentifierString: c.fileIdentifierString, fileVersion: c.fileVersion, imageType: c.imageType, height: c.height, width: c.width, maxZError: c.maxZError, eofOffset: c.eofOffset, mask: c.mask ? { numBlocksX: c.mask.numBlocksX, numBlocksY: c.mask.numBlocksY, numBytes: c.mask.numBytes, maxValue: c.mask.maxValue } : null, pixels: { numBlocksX: c.pixels.numBlocksX, numBlocksY: c.pixels.numBlocksY, numBytes: c.pixels.numBytes, maxValue: c.pixels.maxValue, noDataValue: c.noDataValue } };
            }, l = function(c) {
              for (var f = c.pixels.numBlocksX * c.pixels.numBlocksY, g = {}, d = 0; d < f; d++) {
                var A = c.pixels.blocks[d];
                A.encoding === 0 ? g.float32 = true : A.encoding === 1 ? g[A.bitsPerPixel] = true : g[0] = true;
              }
              return Object.keys(g);
            }, u = function(c, f, g) {
              var d = {}, A = new Uint8Array(c, f, 10);
              if (d.fileIdentifierString = String.fromCharCode.apply(null, A), d.fileIdentifierString.trim() !== "CntZImage") throw "Unexpected file identifier string: " + d.fileIdentifierString;
              f += 10;
              var p = new DataView(c, f, 24);
              if (d.fileVersion = p.getInt32(0, true), d.imageType = p.getInt32(4, true), d.height = p.getUint32(8, true), d.width = p.getUint32(12, true), d.maxZError = p.getFloat64(16, true), f += 24, !g) if (p = new DataView(c, f, 16), d.mask = {}, d.mask.numBlocksY = p.getUint32(0, true), d.mask.numBlocksX = p.getUint32(4, true), d.mask.numBytes = p.getUint32(8, true), d.mask.maxValue = p.getFloat32(12, true), f += 16, d.mask.numBytes > 0) {
                var v = new Uint8Array(Math.ceil(d.width * d.height / 8));
                p = new DataView(c, f, d.mask.numBytes);
                var y = p.getInt16(0, true), m = 2, _ = 0;
                do {
                  if (y > 0) for (; y--; ) v[_++] = p.getUint8(m++);
                  else {
                    var E = p.getUint8(m++);
                    for (y = -y; y--; ) v[_++] = E;
                  }
                  y = p.getInt16(m, true), m += 2;
                } while (m < d.mask.numBytes);
                if (y !== -32768 || _ < v.length) throw "Unexpected end of mask RLE encoding";
                d.mask.bitset = v, f += d.mask.numBytes;
              } else d.mask.numBytes | d.mask.numBlocksY | d.mask.maxValue || (d.mask.bitset = new Uint8Array(Math.ceil(d.width * d.height / 8)));
              p = new DataView(c, f, 16), d.pixels = {}, d.pixels.numBlocksY = p.getUint32(0, true), d.pixels.numBlocksX = p.getUint32(4, true), d.pixels.numBytes = p.getUint32(8, true), d.pixels.maxValue = p.getFloat32(12, true), f += 16;
              var I = d.pixels.numBlocksX, x = d.pixels.numBlocksY, w = I + (d.width % I > 0 ? 1 : 0), C = x + (d.height % x > 0 ? 1 : 0);
              d.pixels.blocks = new Array(w * C);
              for (var S = 0, b = 0; b < C; b++) for (var B = 0; B < w; B++) {
                var T = 0, D = c.byteLength - f;
                p = new DataView(c, f, Math.min(10, D));
                var R = {};
                d.pixels.blocks[S++] = R;
                var L = p.getUint8(0);
                if (T++, R.encoding = L & 63, R.encoding > 3) throw "Invalid block encoding (" + R.encoding + ")";
                if (R.encoding === 2) {
                  f++;
                  continue;
                }
                if (L !== 0 && L !== 2) {
                  if (L >>= 6, R.offsetType = L, L === 2) R.offset = p.getInt8(1), T++;
                  else if (L === 1) R.offset = p.getInt16(1, true), T += 2;
                  else if (L === 0) R.offset = p.getFloat32(1, true), T += 4;
                  else throw "Invalid block offset type";
                  if (R.encoding === 1) if (L = p.getUint8(T), T++, R.bitsPerPixel = L & 63, L >>= 6, R.numValidPixelsType = L, L === 2) R.numValidPixels = p.getUint8(T), T++;
                  else if (L === 1) R.numValidPixels = p.getUint16(T, true), T += 2;
                  else if (L === 0) R.numValidPixels = p.getUint32(T, true), T += 4;
                  else throw "Invalid valid pixel count type";
                }
                if (f += T, R.encoding !== 3) {
                  var k, P;
                  if (R.encoding === 0) {
                    var F = (d.pixels.numBytes - 1) / 4;
                    if (F !== Math.floor(F)) throw "uncompressed block has invalid length";
                    k = new ArrayBuffer(F * 4), P = new Uint8Array(k), P.set(new Uint8Array(c, f, F * 4));
                    var Q = new Float32Array(k);
                    R.rawData = Q, f += F * 4;
                  } else if (R.encoding === 1) {
                    var z = Math.ceil(R.numValidPixels * R.bitsPerPixel / 8), j = Math.ceil(z / 4);
                    k = new ArrayBuffer(j * 4), P = new Uint8Array(k), P.set(new Uint8Array(c, f, z)), R.stuffedData = new Uint32Array(k), f += z;
                  }
                }
              }
              return d.eofOffset = f, d;
            }, h = function(c, f, g, d, A, p, v) {
              var y = (1 << f) - 1, m = 0, _, E = 0, I, x, w = Math.ceil((v - d) / A), C = c.length * 4 - Math.ceil(f * g / 8);
              for (c[c.length - 1] <<= 8 * C, _ = 0; _ < g; _++) {
                if (E === 0 && (x = c[m++], E = 32), E >= f) I = x >>> E - f & y, E -= f;
                else {
                  var S = f - E;
                  I = (x & y) << S & y, x = c[m++], E = 32 - S, I += x >>> E;
                }
                p[_] = I < w ? d + I * A : v;
              }
              return p;
            };
            return a;
          }(), e = /* @__PURE__ */ function() {
            var a = { unstuff: function(u, h, c, f, g, d, A, p) {
              var v = (1 << c) - 1, y = 0, m, _ = 0, E, I, x, w, C = u.length * 4 - Math.ceil(c * f / 8);
              if (u[u.length - 1] <<= 8 * C, g) for (m = 0; m < f; m++) _ === 0 && (I = u[y++], _ = 32), _ >= c ? (E = I >>> _ - c & v, _ -= c) : (x = c - _, E = (I & v) << x & v, I = u[y++], _ = 32 - x, E += I >>> _), h[m] = g[E];
              else for (w = Math.ceil((p - d) / A), m = 0; m < f; m++) _ === 0 && (I = u[y++], _ = 32), _ >= c ? (E = I >>> _ - c & v, _ -= c) : (x = c - _, E = (I & v) << x & v, I = u[y++], _ = 32 - x, E += I >>> _), h[m] = E < w ? d + E * A : p;
            }, unstuffLUT: function(u, h, c, f, g, d) {
              var A = (1 << h) - 1, p = 0, v = 0, y = 0, m = 0, _ = 0, E, I = [], x = u.length * 4 - Math.ceil(h * c / 8);
              u[u.length - 1] <<= 8 * x;
              var w = Math.ceil((d - f) / g);
              for (v = 0; v < c; v++) m === 0 && (E = u[p++], m = 32), m >= h ? (_ = E >>> m - h & A, m -= h) : (y = h - m, _ = (E & A) << y & A, E = u[p++], m = 32 - y, _ += E >>> m), I[v] = _ < w ? f + _ * g : d;
              return I.unshift(f), I;
            }, unstuff2: function(u, h, c, f, g, d, A, p) {
              var v = (1 << c) - 1, y = 0, m, _ = 0, E = 0, I, x, w;
              if (g) for (m = 0; m < f; m++) _ === 0 && (x = u[y++], _ = 32, E = 0), _ >= c ? (I = x >>> E & v, _ -= c, E += c) : (w = c - _, I = x >>> E & v, x = u[y++], _ = 32 - w, I |= (x & (1 << w) - 1) << c - w, E = w), h[m] = g[I];
              else {
                var C = Math.ceil((p - d) / A);
                for (m = 0; m < f; m++) _ === 0 && (x = u[y++], _ = 32, E = 0), _ >= c ? (I = x >>> E & v, _ -= c, E += c) : (w = c - _, I = x >>> E & v, x = u[y++], _ = 32 - w, I |= (x & (1 << w) - 1) << c - w, E = w), h[m] = I < C ? d + I * A : p;
              }
              return h;
            }, unstuffLUT2: function(u, h, c, f, g, d) {
              var A = (1 << h) - 1, p = 0, v = 0, y = 0, m = 0, _ = 0, E = 0, I, x = [], w = Math.ceil((d - f) / g);
              for (v = 0; v < c; v++) m === 0 && (I = u[p++], m = 32, E = 0), m >= h ? (_ = I >>> E & A, m -= h, E += h) : (y = h - m, _ = I >>> E & A, I = u[p++], m = 32 - y, _ |= (I & (1 << y) - 1) << h - y, E = y), x[v] = _ < w ? f + _ * g : d;
              return x.unshift(f), x;
            }, originalUnstuff: function(u, h, c, f) {
              var g = (1 << c) - 1, d = 0, A, p = 0, v, y, m, _ = u.length * 4 - Math.ceil(c * f / 8);
              for (u[u.length - 1] <<= 8 * _, A = 0; A < f; A++) p === 0 && (y = u[d++], p = 32), p >= c ? (v = y >>> p - c & g, p -= c) : (m = c - p, v = (y & g) << m & g, y = u[d++], p = 32 - m, v += y >>> p), h[A] = v;
              return h;
            }, originalUnstuff2: function(u, h, c, f) {
              var g = (1 << c) - 1, d = 0, A, p = 0, v = 0, y, m, _;
              for (A = 0; A < f; A++) p === 0 && (m = u[d++], p = 32, v = 0), p >= c ? (y = m >>> v & g, p -= c, v += c) : (_ = c - p, y = m >>> v & g, m = u[d++], p = 32 - _, y |= (m & (1 << _) - 1) << c - _, v = _), h[A] = y;
              return h;
            } }, o = { HUFFMAN_LUT_BITS_MAX: 12, computeChecksumFletcher32: function(u) {
              for (var h = 65535, c = 65535, f = u.length, g = Math.floor(f / 2), d = 0; g; ) {
                var A = g >= 359 ? 359 : g;
                g -= A;
                do
                  h += u[d++] << 8, c += h += u[d++];
                while (--A);
                h = (h & 65535) + (h >>> 16), c = (c & 65535) + (c >>> 16);
              }
              return f & 1 && (c += h += u[d] << 8), h = (h & 65535) + (h >>> 16), c = (c & 65535) + (c >>> 16), (c << 16 | h) >>> 0;
            }, readHeaderInfo: function(u, h) {
              var c = h.ptr, f = new Uint8Array(u, c, 6), g = {};
              if (g.fileIdentifierString = String.fromCharCode.apply(null, f), g.fileIdentifierString.lastIndexOf("Lerc2", 0) !== 0) throw "Unexpected file identifier string (expect Lerc2 ): " + g.fileIdentifierString;
              c += 6;
              var d = new DataView(u, c, 8), A = d.getInt32(0, true);
              g.fileVersion = A, c += 4, A >= 3 && (g.checksum = d.getUint32(4, true), c += 4), d = new DataView(u, c, 12), g.height = d.getUint32(0, true), g.width = d.getUint32(4, true), c += 8, A >= 4 ? (g.numDims = d.getUint32(8, true), c += 4) : g.numDims = 1, d = new DataView(u, c, 40), g.numValidPixel = d.getUint32(0, true), g.microBlockSize = d.getInt32(4, true), g.blobSize = d.getInt32(8, true), g.imageType = d.getInt32(12, true), g.maxZError = d.getFloat64(16, true), g.zMin = d.getFloat64(24, true), g.zMax = d.getFloat64(32, true), c += 40, h.headerInfo = g, h.ptr = c;
              var p, v;
              if (A >= 3 && (v = A >= 4 ? 52 : 48, p = this.computeChecksumFletcher32(new Uint8Array(u, c - v, g.blobSize - 14)), p !== g.checksum)) throw "Checksum failed.";
              return true;
            }, checkMinMaxRanges: function(u, h) {
              var c = h.headerInfo, f = this.getDataTypeArray(c.imageType), g = c.numDims * this.getDataTypeSize(c.imageType), d = this.readSubArray(u, h.ptr, f, g), A = this.readSubArray(u, h.ptr + g, f, g);
              h.ptr += 2 * g;
              var p, v = true;
              for (p = 0; p < c.numDims; p++) if (d[p] !== A[p]) {
                v = false;
                break;
              }
              return c.minValues = d, c.maxValues = A, v;
            }, readSubArray: function(u, h, c, f) {
              var g;
              if (c === Uint8Array) g = new Uint8Array(u, h, f);
              else {
                var d = new ArrayBuffer(f), A = new Uint8Array(d);
                A.set(new Uint8Array(u, h, f)), g = new c(d);
              }
              return g;
            }, readMask: function(u, h) {
              var c = h.ptr, f = h.headerInfo, g = f.width * f.height, d = f.numValidPixel, A = new DataView(u, c, 4), p = {};
              if (p.numBytes = A.getUint32(0, true), c += 4, (d === 0 || g === d) && p.numBytes !== 0) throw "invalid mask";
              var v, y;
              if (d === 0) v = new Uint8Array(Math.ceil(g / 8)), p.bitset = v, y = new Uint8Array(g), h.pixels.resultMask = y, c += p.numBytes;
              else if (p.numBytes > 0) {
                v = new Uint8Array(Math.ceil(g / 8)), A = new DataView(u, c, p.numBytes);
                var m = A.getInt16(0, true), _ = 2, E = 0, I = 0;
                do {
                  if (m > 0) for (; m--; ) v[E++] = A.getUint8(_++);
                  else for (I = A.getUint8(_++), m = -m; m--; ) v[E++] = I;
                  m = A.getInt16(_, true), _ += 2;
                } while (_ < p.numBytes);
                if (m !== -32768 || E < v.length) throw "Unexpected end of mask RLE encoding";
                y = new Uint8Array(g);
                var x = 0, w = 0;
                for (w = 0; w < g; w++) w & 7 ? (x = v[w >> 3], x <<= w & 7) : x = v[w >> 3], x & 128 && (y[w] = 1);
                h.pixels.resultMask = y, p.bitset = v, c += p.numBytes;
              }
              return h.ptr = c, h.mask = p, true;
            }, readDataOneSweep: function(u, h, c, f) {
              var g = h.ptr, d = h.headerInfo, A = d.numDims, p = d.width * d.height, v = d.imageType, y = d.numValidPixel * o.getDataTypeSize(v) * A, m, _ = h.pixels.resultMask;
              if (c === Uint8Array) m = new Uint8Array(u, g, y);
              else {
                var E = new ArrayBuffer(y), I = new Uint8Array(E);
                I.set(new Uint8Array(u, g, y)), m = new c(E);
              }
              if (m.length === p * A) f ? h.pixels.resultPixels = o.swapDimensionOrder(m, p, A, c, true) : h.pixels.resultPixels = m;
              else {
                h.pixels.resultPixels = new c(p * A);
                var x = 0, w = 0, C = 0, S = 0;
                if (A > 1) {
                  if (f) {
                    for (w = 0; w < p; w++) if (_[w]) for (S = w, C = 0; C < A; C++, S += p) h.pixels.resultPixels[S] = m[x++];
                  } else for (w = 0; w < p; w++) if (_[w]) for (S = w * A, C = 0; C < A; C++) h.pixels.resultPixels[S + C] = m[x++];
                } else for (w = 0; w < p; w++) _[w] && (h.pixels.resultPixels[w] = m[x++]);
              }
              return g += y, h.ptr = g, true;
            }, readHuffmanTree: function(u, h) {
              var c = this.HUFFMAN_LUT_BITS_MAX, f = new DataView(u, h.ptr, 16);
              h.ptr += 16;
              var g = f.getInt32(0, true);
              if (g < 2) throw "unsupported Huffman version";
              var d = f.getInt32(4, true), A = f.getInt32(8, true), p = f.getInt32(12, true);
              if (A >= p) return false;
              var v = new Uint32Array(p - A);
              o.decodeBits(u, h, v);
              var y = [], m, _, E, I;
              for (m = A; m < p; m++) _ = m - (m < d ? 0 : d), y[_] = { first: v[m - A], second: null };
              var x = u.byteLength - h.ptr, w = Math.ceil(x / 4), C = new ArrayBuffer(w * 4), S = new Uint8Array(C);
              S.set(new Uint8Array(u, h.ptr, x));
              var b = new Uint32Array(C), B = 0, T, D = 0;
              for (T = b[0], m = A; m < p; m++) _ = m - (m < d ? 0 : d), I = y[_].first, I > 0 && (y[_].second = T << B >>> 32 - I, 32 - B >= I ? (B += I, B === 32 && (B = 0, D++, T = b[D])) : (B += I - 32, D++, T = b[D], y[_].second |= T >>> 32 - B));
              var R = 0, L = 0, k = new s();
              for (m = 0; m < y.length; m++) y[m] !== void 0 && (R = Math.max(R, y[m].first));
              R >= c ? L = c : L = R;
              var P = [], F, Q, z, j, $, G;
              for (m = A; m < p; m++) if (_ = m - (m < d ? 0 : d), I = y[_].first, I > 0) if (F = [I, _], I <= L) for (Q = y[_].second << L - I, z = 1 << L - I, E = 0; E < z; E++) P[Q | E] = F;
              else for (Q = y[_].second, G = k, j = I - 1; j >= 0; j--) $ = Q >>> j & 1, $ ? (G.right || (G.right = new s()), G = G.right) : (G.left || (G.left = new s()), G = G.left), j === 0 && !G.val && (G.val = F[1]);
              return { decodeLut: P, numBitsLUTQick: L, numBitsLUT: R, tree: k, stuffedData: b, srcPtr: D, bitPos: B };
            }, readHuffman: function(u, h, c, f) {
              var g = h.headerInfo, d = g.numDims, A = h.headerInfo.height, p = h.headerInfo.width, v = p * A, y = this.readHuffmanTree(u, h), m = y.decodeLut, _ = y.tree, E = y.stuffedData, I = y.srcPtr, x = y.bitPos, w = y.numBitsLUTQick, C = y.numBitsLUT, S = h.headerInfo.imageType === 0 ? 128 : 0, b, B, T, D = h.pixels.resultMask, R, L, k, P, F, Q, z, j = 0;
              x > 0 && (I++, x = 0);
              var $ = E[I], G = h.encodeMode === 1, tt = new c(v * d), J = tt, et;
              if (d < 2 || G) {
                for (et = 0; et < d; et++) if (d > 1 && (J = new c(tt.buffer, v * et, v), j = 0), h.headerInfo.numValidPixel === p * A) for (Q = 0, P = 0; P < A; P++) for (F = 0; F < p; F++, Q++) {
                  if (B = 0, R = $ << x >>> 32 - w, L = R, 32 - x < w && (R |= E[I + 1] >>> 64 - x - w, L = R), m[L]) B = m[L][1], x += m[L][0];
                  else for (R = $ << x >>> 32 - C, L = R, 32 - x < C && (R |= E[I + 1] >>> 64 - x - C, L = R), b = _, z = 0; z < C; z++) if (k = R >>> C - z - 1 & 1, b = k ? b.right : b.left, !(b.left || b.right)) {
                    B = b.val, x = x + z + 1;
                    break;
                  }
                  x >= 32 && (x -= 32, I++, $ = E[I]), T = B - S, G ? (F > 0 ? T += j : P > 0 ? T += J[Q - p] : T += j, T &= 255, J[Q] = T, j = T) : J[Q] = T;
                }
                else for (Q = 0, P = 0; P < A; P++) for (F = 0; F < p; F++, Q++) if (D[Q]) {
                  if (B = 0, R = $ << x >>> 32 - w, L = R, 32 - x < w && (R |= E[I + 1] >>> 64 - x - w, L = R), m[L]) B = m[L][1], x += m[L][0];
                  else for (R = $ << x >>> 32 - C, L = R, 32 - x < C && (R |= E[I + 1] >>> 64 - x - C, L = R), b = _, z = 0; z < C; z++) if (k = R >>> C - z - 1 & 1, b = k ? b.right : b.left, !(b.left || b.right)) {
                    B = b.val, x = x + z + 1;
                    break;
                  }
                  x >= 32 && (x -= 32, I++, $ = E[I]), T = B - S, G ? (F > 0 && D[Q - 1] ? T += j : P > 0 && D[Q - p] ? T += J[Q - p] : T += j, T &= 255, J[Q] = T, j = T) : J[Q] = T;
                }
              } else for (Q = 0, P = 0; P < A; P++) for (F = 0; F < p; F++) if (Q = P * p + F, !D || D[Q]) for (et = 0; et < d; et++, Q += v) {
                if (B = 0, R = $ << x >>> 32 - w, L = R, 32 - x < w && (R |= E[I + 1] >>> 64 - x - w, L = R), m[L]) B = m[L][1], x += m[L][0];
                else for (R = $ << x >>> 32 - C, L = R, 32 - x < C && (R |= E[I + 1] >>> 64 - x - C, L = R), b = _, z = 0; z < C; z++) if (k = R >>> C - z - 1 & 1, b = k ? b.right : b.left, !(b.left || b.right)) {
                  B = b.val, x = x + z + 1;
                  break;
                }
                x >= 32 && (x -= 32, I++, $ = E[I]), T = B - S, J[Q] = T;
              }
              h.ptr = h.ptr + (I + 1) * 4 + (x > 0 ? 4 : 0), h.pixels.resultPixels = tt, d > 1 && !f && (h.pixels.resultPixels = o.swapDimensionOrder(tt, v, d, c));
            }, decodeBits: function(u, h, c, f, g) {
              {
                var d = h.headerInfo, A = d.fileVersion, p = 0, v = u.byteLength - h.ptr >= 5 ? 5 : u.byteLength - h.ptr, y = new DataView(u, h.ptr, v), m = y.getUint8(0);
                p++;
                var _ = m >> 6, E = _ === 0 ? 4 : 3 - _, I = (m & 32) > 0, x = m & 31, w = 0;
                if (E === 1) w = y.getUint8(p), p++;
                else if (E === 2) w = y.getUint16(p, true), p += 2;
                else if (E === 4) w = y.getUint32(p, true), p += 4;
                else throw "Invalid valid pixel count type";
                var C = 2 * d.maxZError, S, b, B, T, D, R, L, k, P, F = d.numDims > 1 ? d.maxValues[g] : d.zMax;
                if (I) {
                  for (h.counter.lut++, k = y.getUint8(p), p++, T = Math.ceil((k - 1) * x / 8), D = Math.ceil(T / 4), b = new ArrayBuffer(D * 4), B = new Uint8Array(b), h.ptr += p, B.set(new Uint8Array(u, h.ptr, T)), L = new Uint32Array(b), h.ptr += T, P = 0; k - 1 >>> P; ) P++;
                  T = Math.ceil(w * P / 8), D = Math.ceil(T / 4), b = new ArrayBuffer(D * 4), B = new Uint8Array(b), B.set(new Uint8Array(u, h.ptr, T)), S = new Uint32Array(b), h.ptr += T, A >= 3 ? R = a.unstuffLUT2(L, x, k - 1, f, C, F) : R = a.unstuffLUT(L, x, k - 1, f, C, F), A >= 3 ? a.unstuff2(S, c, P, w, R) : a.unstuff(S, c, P, w, R);
                } else h.counter.bitstuffer++, P = x, h.ptr += p, P > 0 && (T = Math.ceil(w * P / 8), D = Math.ceil(T / 4), b = new ArrayBuffer(D * 4), B = new Uint8Array(b), B.set(new Uint8Array(u, h.ptr, T)), S = new Uint32Array(b), h.ptr += T, A >= 3 ? f == null ? a.originalUnstuff2(S, c, P, w) : a.unstuff2(S, c, P, w, false, f, C, F) : f == null ? a.originalUnstuff(S, c, P, w) : a.unstuff(S, c, P, w, false, f, C, F));
              }
            }, readTiles: function(u, h, c, f) {
              var g = h.headerInfo, d = g.width, A = g.height, p = d * A, v = g.microBlockSize, y = g.imageType, m = o.getDataTypeSize(y), _ = Math.ceil(d / v), E = Math.ceil(A / v);
              h.pixels.numBlocksY = E, h.pixels.numBlocksX = _, h.pixels.ptr = 0;
              var I = 0, x = 0, w = 0, C = 0, S = 0, b = 0, B = 0, T = 0, D = 0, R = 0, L = 0, k = 0, P = 0, F = 0, Q = 0, z = 0, j, $, G, tt, J, et, nt = new c(v * v), gt = A % v || v, H = d % v || v, W, it, kt = g.numDims, vt, St = h.pixels.resultMask, bt = h.pixels.resultPixels, Ee = g.fileVersion, rn = Ee >= 5 ? 14 : 15, Ie, fn = g.zMax, an;
              for (w = 0; w < E; w++) for (S = w !== E - 1 ? v : gt, C = 0; C < _; C++) for (b = C !== _ - 1 ? v : H, L = w * d * v + C * v, k = d - b, vt = 0; vt < kt; vt++) {
                if (kt > 1 ? (an = bt, L = w * d * v + C * v, bt = new c(h.pixels.resultPixels.buffer, p * vt * m, p), fn = g.maxValues[vt]) : an = null, B = u.byteLength - h.ptr, j = new DataView(u, h.ptr, Math.min(10, B)), $ = {}, z = 0, T = j.getUint8(0), z++, Ie = g.fileVersion >= 5 ? T & 4 : 0, D = T >> 6 & 255, R = T >> 2 & rn, R !== (C * v >> 3 & rn) || Ie && vt === 0) throw "integrity issue";
                if (et = T & 3, et > 3) throw h.ptr += z, "Invalid block encoding (" + et + ")";
                if (et === 2) {
                  if (Ie) if (St) for (I = 0; I < S; I++) for (x = 0; x < b; x++) St[L] && (bt[L] = an[L]), L++;
                  else for (I = 0; I < S; I++) for (x = 0; x < b; x++) bt[L] = an[L], L++;
                  h.counter.constant++, h.ptr += z;
                  continue;
                } else if (et === 0) {
                  if (Ie) throw "integrity issue";
                  if (h.counter.uncompressed++, h.ptr += z, P = S * b * m, F = u.byteLength - h.ptr, P = P < F ? P : F, G = new ArrayBuffer(P % m === 0 ? P : P + m - P % m), tt = new Uint8Array(G), tt.set(new Uint8Array(u, h.ptr, P)), J = new c(G), Q = 0, St) for (I = 0; I < S; I++) {
                    for (x = 0; x < b; x++) St[L] && (bt[L] = J[Q++]), L++;
                    L += k;
                  }
                  else for (I = 0; I < S; I++) {
                    for (x = 0; x < b; x++) bt[L++] = J[Q++];
                    L += k;
                  }
                  h.ptr += Q * m;
                } else if (W = o.getDataTypeUsed(Ie && y < 6 ? 4 : y, D), it = o.getOnePixel($, z, W, j), z += o.getDataTypeSize(W), et === 3) if (h.ptr += z, h.counter.constantoffset++, St) for (I = 0; I < S; I++) {
                  for (x = 0; x < b; x++) St[L] && (bt[L] = Ie ? Math.min(fn, an[L] + it) : it), L++;
                  L += k;
                }
                else for (I = 0; I < S; I++) {
                  for (x = 0; x < b; x++) bt[L] = Ie ? Math.min(fn, an[L] + it) : it, L++;
                  L += k;
                }
                else if (h.ptr += z, o.decodeBits(u, h, nt, it, vt), z = 0, Ie) if (St) for (I = 0; I < S; I++) {
                  for (x = 0; x < b; x++) St[L] && (bt[L] = nt[z++] + an[L]), L++;
                  L += k;
                }
                else for (I = 0; I < S; I++) {
                  for (x = 0; x < b; x++) bt[L] = nt[z++] + an[L], L++;
                  L += k;
                }
                else if (St) for (I = 0; I < S; I++) {
                  for (x = 0; x < b; x++) St[L] && (bt[L] = nt[z++]), L++;
                  L += k;
                }
                else for (I = 0; I < S; I++) {
                  for (x = 0; x < b; x++) bt[L++] = nt[z++];
                  L += k;
                }
              }
              kt > 1 && !f && (h.pixels.resultPixels = o.swapDimensionOrder(h.pixels.resultPixels, p, kt, c));
            }, formatFileInfo: function(u) {
              return { fileIdentifierString: u.headerInfo.fileIdentifierString, fileVersion: u.headerInfo.fileVersion, imageType: u.headerInfo.imageType, height: u.headerInfo.height, width: u.headerInfo.width, numValidPixel: u.headerInfo.numValidPixel, microBlockSize: u.headerInfo.microBlockSize, blobSize: u.headerInfo.blobSize, maxZError: u.headerInfo.maxZError, pixelType: o.getPixelType(u.headerInfo.imageType), eofOffset: u.eofOffset, mask: u.mask ? { numBytes: u.mask.numBytes } : null, pixels: { numBlocksX: u.pixels.numBlocksX, numBlocksY: u.pixels.numBlocksY, maxValue: u.headerInfo.zMax, minValue: u.headerInfo.zMin, noDataValue: u.noDataValue } };
            }, constructConstantSurface: function(u, h) {
              var c = u.headerInfo.zMax, f = u.headerInfo.zMin, g = u.headerInfo.maxValues, d = u.headerInfo.numDims, A = u.headerInfo.height * u.headerInfo.width, p = 0, v = 0, y = 0, m = u.pixels.resultMask, _ = u.pixels.resultPixels;
              if (m) if (d > 1) {
                if (h) for (p = 0; p < d; p++) for (y = p * A, c = g[p], v = 0; v < A; v++) m[v] && (_[y + v] = c);
                else for (v = 0; v < A; v++) if (m[v]) for (y = v * d, p = 0; p < d; p++) _[y + d] = g[p];
              } else for (v = 0; v < A; v++) m[v] && (_[v] = c);
              else if (d > 1 && f !== c) if (h) for (p = 0; p < d; p++) for (y = p * A, c = g[p], v = 0; v < A; v++) _[y + v] = c;
              else for (v = 0; v < A; v++) for (y = v * d, p = 0; p < d; p++) _[y + p] = g[p];
              else for (v = 0; v < A * d; v++) _[v] = c;
            }, getDataTypeArray: function(u) {
              var h;
              switch (u) {
                case 0:
                  h = Int8Array;
                  break;
                case 1:
                  h = Uint8Array;
                  break;
                case 2:
                  h = Int16Array;
                  break;
                case 3:
                  h = Uint16Array;
                  break;
                case 4:
                  h = Int32Array;
                  break;
                case 5:
                  h = Uint32Array;
                  break;
                case 6:
                  h = Float32Array;
                  break;
                case 7:
                  h = Float64Array;
                  break;
                default:
                  h = Float32Array;
              }
              return h;
            }, getPixelType: function(u) {
              var h;
              switch (u) {
                case 0:
                  h = "S8";
                  break;
                case 1:
                  h = "U8";
                  break;
                case 2:
                  h = "S16";
                  break;
                case 3:
                  h = "U16";
                  break;
                case 4:
                  h = "S32";
                  break;
                case 5:
                  h = "U32";
                  break;
                case 6:
                  h = "F32";
                  break;
                case 7:
                  h = "F64";
                  break;
                default:
                  h = "F32";
              }
              return h;
            }, isValidPixelValue: function(u, h) {
              if (h == null) return false;
              var c;
              switch (u) {
                case 0:
                  c = h >= -128 && h <= 127;
                  break;
                case 1:
                  c = h >= 0 && h <= 255;
                  break;
                case 2:
                  c = h >= -32768 && h <= 32767;
                  break;
                case 3:
                  c = h >= 0 && h <= 65536;
                  break;
                case 4:
                  c = h >= -2147483648 && h <= 2147483647;
                  break;
                case 5:
                  c = h >= 0 && h <= 4294967296;
                  break;
                case 6:
                  c = h >= -34027999387901484e22 && h <= 34027999387901484e22;
                  break;
                case 7:
                  c = h >= -17976931348623157e292 && h <= 17976931348623157e292;
                  break;
                default:
                  c = false;
              }
              return c;
            }, getDataTypeSize: function(u) {
              var h = 0;
              switch (u) {
                case 0:
                case 1:
                  h = 1;
                  break;
                case 2:
                case 3:
                  h = 2;
                  break;
                case 4:
                case 5:
                case 6:
                  h = 4;
                  break;
                case 7:
                  h = 8;
                  break;
                default:
                  h = u;
              }
              return h;
            }, getDataTypeUsed: function(u, h) {
              var c = u;
              switch (u) {
                case 2:
                case 4:
                  c = u - h;
                  break;
                case 3:
                case 5:
                  c = u - 2 * h;
                  break;
                case 6:
                  h === 0 ? c = u : h === 1 ? c = 2 : c = 1;
                  break;
                case 7:
                  h === 0 ? c = u : c = u - 2 * h + 1;
                  break;
                default:
                  c = u;
                  break;
              }
              return c;
            }, getOnePixel: function(u, h, c, f) {
              var g = 0;
              switch (c) {
                case 0:
                  g = f.getInt8(h);
                  break;
                case 1:
                  g = f.getUint8(h);
                  break;
                case 2:
                  g = f.getInt16(h, true);
                  break;
                case 3:
                  g = f.getUint16(h, true);
                  break;
                case 4:
                  g = f.getInt32(h, true);
                  break;
                case 5:
                  g = f.getUInt32(h, true);
                  break;
                case 6:
                  g = f.getFloat32(h, true);
                  break;
                case 7:
                  g = f.getFloat64(h, true);
                  break;
                default:
                  throw "the decoder does not understand this pixel type";
              }
              return g;
            }, swapDimensionOrder: function(u, h, c, f, g) {
              var d = 0, A = 0, p = 0, v = 0, y = u;
              if (c > 1) if (y = new f(h * c), g) for (d = 0; d < h; d++) for (v = d, p = 0; p < c; p++, v += h) y[v] = u[A++];
              else for (d = 0; d < h; d++) for (v = d, p = 0; p < c; p++, v += h) y[A++] = u[v];
              return y;
            } }, s = function(u, h, c) {
              this.val = u, this.left = h, this.right = c;
            }, l = { decode: function(u, h) {
              h = h || {};
              var c = h.noDataValue, f = 0, g = {};
              if (g.ptr = h.inputOffset || 0, g.pixels = {}, !!o.readHeaderInfo(u, g)) {
                var d = g.headerInfo, A = d.fileVersion, p = o.getDataTypeArray(d.imageType);
                if (A > 5) throw "unsupported lerc version 2." + A;
                o.readMask(u, g), d.numValidPixel !== d.width * d.height && !g.pixels.resultMask && (g.pixels.resultMask = h.maskData);
                var v = d.width * d.height;
                g.pixels.resultPixels = new p(v * d.numDims), g.counter = { onesweep: 0, uncompressed: 0, lut: 0, bitstuffer: 0, constant: 0, constantoffset: 0 };
                var y = !h.returnPixelInterleavedDims;
                if (d.numValidPixel !== 0) if (d.zMax === d.zMin) o.constructConstantSurface(g, y);
                else if (A >= 4 && o.checkMinMaxRanges(u, g)) o.constructConstantSurface(g, y);
                else {
                  var m = new DataView(u, g.ptr, 2), _ = m.getUint8(0);
                  if (g.ptr++, _) o.readDataOneSweep(u, g, p, y);
                  else if (A > 1 && d.imageType <= 1 && Math.abs(d.maxZError - 0.5) < 1e-5) {
                    var E = m.getUint8(1);
                    if (g.ptr++, g.encodeMode = E, E > 2 || A < 4 && E > 1) throw "Invalid Huffman flag " + E;
                    E ? o.readHuffman(u, g, p, y) : o.readTiles(u, g, p, y);
                  } else o.readTiles(u, g, p, y);
                }
                g.eofOffset = g.ptr;
                var I;
                h.inputOffset ? (I = g.headerInfo.blobSize + h.inputOffset - g.ptr, Math.abs(I) >= 1 && (g.eofOffset = h.inputOffset + g.headerInfo.blobSize)) : (I = g.headerInfo.blobSize - g.ptr, Math.abs(I) >= 1 && (g.eofOffset = g.headerInfo.blobSize));
                var x = { width: d.width, height: d.height, pixelData: g.pixels.resultPixels, minValue: d.zMin, maxValue: d.zMax, validPixelCount: d.numValidPixel, dimCount: d.numDims, dimStats: { minValues: d.minValues, maxValues: d.maxValues }, maskData: g.pixels.resultMask };
                if (g.pixels.resultMask && o.isValidPixelValue(d.imageType, c)) {
                  var w = g.pixels.resultMask;
                  for (f = 0; f < v; f++) w[f] || (x.pixelData[f] = c);
                  x.noDataValue = c;
                }
                return g.noDataValue = c, h.returnFileInfo && (x.fileInfo = o.formatFileInfo(g)), x;
              }
            }, getBandCount: function(u) {
              var h = 0, c = 0, f = {};
              for (f.ptr = 0, f.pixels = {}; c < u.byteLength - 58; ) o.readHeaderInfo(u, f), c += f.headerInfo.blobSize, h++, f.ptr = c;
              return h;
            } };
            return l;
          }(), i = function() {
            var a = new ArrayBuffer(4), o = new Uint8Array(a), s = new Uint32Array(a);
            return s[0] = 1, o[0] === 1;
          }(), r = { decode: function(a, o) {
            if (!i) throw "Big endian system is not supported.";
            o = o || {};
            var s = o.inputOffset || 0, l = new Uint8Array(a, s, 10), u = String.fromCharCode.apply(null, l), h, c;
            if (u.trim() === "CntZImage") h = t, c = 1;
            else if (u.substring(0, 5) === "Lerc2") h = e, c = 2;
            else throw "Unexpected file identifier string: " + u;
            for (var f = 0, g = a.byteLength - 10, d, A = [], p, v, y = { width: 0, height: 0, pixels: [], pixelType: o.pixelType, mask: null, statistics: [] }, m = 0; s < g; ) {
              var _ = h.decode(a, { inputOffset: s, encodedMaskData: d, maskData: v, returnMask: f === 0, returnEncodedMask: f === 0, returnFileInfo: true, returnPixelInterleavedDims: o.returnPixelInterleavedDims, pixelType: o.pixelType || null, noDataValue: o.noDataValue || null });
              s = _.fileInfo.eofOffset, v = _.maskData, f === 0 && (d = _.encodedMaskData, y.width = _.width, y.height = _.height, y.dimCount = _.dimCount || 1, y.pixelType = _.pixelType || _.fileInfo.pixelType, y.mask = v), c > 1 && (v && A.push(v), _.fileInfo.mask && _.fileInfo.mask.numBytes > 0 && m++), f++, y.pixels.push(_.pixelData), y.statistics.push({ minValue: _.minValue, maxValue: _.maxValue, noDataValue: _.noDataValue, dimStats: _.dimStats });
            }
            var E, I, x;
            if (c > 1 && m > 1) {
              for (x = y.width * y.height, y.bandMasks = A, v = new Uint8Array(x), v.set(A[0]), E = 1; E < A.length; E++) for (p = A[E], I = 0; I < x; I++) v[I] = v[I] & p[I];
              y.maskData = v;
            }
            return y;
          } };
          n.exports ? n.exports = r : this.Lerc = r;
        })();
      })(GX);
      var V3t = GX.exports;
      const j3t = UA(V3t);
      let By, $s, vL;
      const yL = { env: { emscripten_notify_memory_growth: function(n) {
        vL = new Uint8Array($s.exports.memory.buffer);
      } } };
      class q3t {
        init() {
          return By || (typeof fetch != "undefined" ? By = fetch("data:application/wasm;base64," + UX).then((t) => t.arrayBuffer()).then((t) => WebAssembly.instantiate(t, yL)).then(this._init) : By = WebAssembly.instantiate(Buffer.from(UX, "base64"), yL).then(this._init), By);
        }
        _init(t) {
          $s = t.instance, yL.env.emscripten_notify_memory_growth(0);
        }
        decode(t, e = 0) {
          if (!$s) throw new Error("ZSTDDecoder: Await .init() before decoding.");
          const i = t.byteLength, r = $s.exports.malloc(i);
          vL.set(t, r), e = e || Number($s.exports.ZSTD_findDecompressedSize(r, i));
          const a = $s.exports.malloc(e), o = $s.exports.ZSTD_decompress(a, e, r, i), s = vL.slice(a, a + o);
          return $s.exports.free(r), $s.exports.free(a), s;
        }
      }
      const UX = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", VX = new q3t();
      class H3t extends Vu {
        constructor(t) {
          super(), this.planarConfiguration = typeof t.PlanarConfiguration != "undefined" ? t.PlanarConfiguration : 1, this.samplesPerPixel = typeof t.SamplesPerPixel != "undefined" ? t.SamplesPerPixel : 1, this.addCompression = t.LercParameters[_st.AddCompression];
        }
        decodeBlock(t) {
          switch (this.addCompression) {
            case pC.None:
              break;
            case pC.Deflate:
              t = zX(new Uint8Array(t)).buffer;
              break;
            case pC.Zstandard:
              t = VX.decode(new Uint8Array(t)).buffer;
              break;
            default:
              throw new Error(`Unsupported LERC additional compression method identifier: ${this.addCompression}`);
          }
          return j3t.decode(t, { returnPixelInterleavedDims: this.planarConfiguration === 1 }).pixels[0].buffer;
        }
      }
      const Y3t = Object.freeze(Object.defineProperty({ __proto__: null, default: H3t, zstd: VX }, Symbol.toStringTag, { value: "Module" }));
      class W3t extends Vu {
        constructor() {
          if (super(), typeof createImageBitmap == "undefined") throw new Error("Cannot decode WebImage as `createImageBitmap` is not available");
          if (typeof document == "undefined" && typeof OffscreenCanvas == "undefined") throw new Error("Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available");
        }
        decode(t, e) {
          return Rt(this, null, function* () {
            const i = new Blob([e]), r = yield createImageBitmap(i);
            let a;
            typeof document != "undefined" ? (a = document.createElement("canvas"), a.width = r.width, a.height = r.height) : a = new OffscreenCanvas(r.width, r.height);
            const o = a.getContext("2d");
            return o.drawImage(r, 0, 0), o.getImageData(0, 0, r.width, r.height).data.buffer;
          });
        }
      }
      const X3t = Object.freeze(Object.defineProperty({ __proto__: null, default: W3t }, Symbol.toStringTag, { value: "Module" })), Z3t = Worker;
      function K3t() {
        const n = 'function A(A,e,t,i,r,I,g){try{var n=A[I](g),a=n.value}catch(A){return void t(A)}n.done?e(a):Promise.resolve(a).then(i,r)}function e(e){return function(){var t=this,i=arguments;return new Promise((function(r,I){var g=e.apply(t,i);function n(e){A(g,r,I,n,a,"next",e)}function a(e){A(g,r,I,n,a,"throw",e)}n(void 0)}))}}function t(A){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(A){return typeof A}:function(A){return A&&"function"==typeof Symbol&&A.constructor===Symbol&&A!==Symbol.prototype?"symbol":typeof A},t(A)}var i={exports:{}};!function(A){var e=function(A){var e,i=Object.prototype,r=i.hasOwnProperty,I="function"==typeof Symbol?Symbol:{},g=I.iterator||"@@iterator",n=I.asyncIterator||"@@asyncIterator",a=I.toStringTag||"@@toStringTag";function o(A,e,t){return Object.defineProperty(A,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),A[e]}try{o({},"")}catch(A){o=function(A,e,t){return A[e]=t}}function B(A,e,t,i){var r=e&&e.prototype instanceof h?e:h,I=Object.create(r.prototype),g=new S(i||[]);return I._invoke=function(A,e,t){var i=Q;return function(r,I){if(i===s)throw new Error("Generator is already running");if(i===f){if("throw"===r)throw I;return R()}for(t.method=r,t.arg=I;;){var g=t.delegate;if(g){var n=m(g,t);if(n){if(n===c)continue;return n}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if(i===Q)throw i=f,t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);i=s;var a=C(A,e,t);if("normal"===a.type){if(i=t.done?f:E,a.arg===c)continue;return{value:a.arg,done:t.done}}"throw"===a.type&&(i=f,t.method="throw",t.arg=a.arg)}}}(A,t,g),I}function C(A,e,t){try{return{type:"normal",arg:A.call(e,t)}}catch(A){return{type:"throw",arg:A}}}A.wrap=B;var Q="suspendedStart",E="suspendedYield",s="executing",f="completed",c={};function h(){}function l(){}function u(){}var w={};o(w,g,(function(){return this}));var d=Object.getPrototypeOf,D=d&&d(d(v([])));D&&D!==i&&r.call(D,g)&&(w=D);var y=u.prototype=h.prototype=Object.create(w);function k(A){["next","throw","return"].forEach((function(e){o(A,e,(function(A){return this._invoke(e,A)}))}))}function p(A,e){function i(I,g,n,a){var o=C(A[I],A,g);if("throw"!==o.type){var B=o.arg,Q=B.value;return Q&&"object"===t(Q)&&r.call(Q,"__await")?e.resolve(Q.__await).then((function(A){i("next",A,n,a)}),(function(A){i("throw",A,n,a)})):e.resolve(Q).then((function(A){B.value=A,n(B)}),(function(A){return i("throw",A,n,a)}))}a(o.arg)}var I;this._invoke=function(A,t){function r(){return new e((function(e,r){i(A,t,e,r)}))}return I=I?I.then(r,r):r()}}function m(A,t){var i=A.iterator[t.method];if(i===e){if(t.delegate=null,"throw"===t.method){if(A.iterator.return&&(t.method="return",t.arg=e,m(A,t),"throw"===t.method))return c;t.method="throw",t.arg=new TypeError("The iterator does not provide a \'throw\' method")}return c}var r=C(i,A.iterator,t.arg);if("throw"===r.type)return t.method="throw",t.arg=r.arg,t.delegate=null,c;var I=r.arg;return I?I.done?(t[A.resultName]=I.value,t.next=A.nextLoc,"return"!==t.method&&(t.method="next",t.arg=e),t.delegate=null,c):I:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,c)}function G(A){var e={tryLoc:A[0]};1 in A&&(e.catchLoc=A[1]),2 in A&&(e.finallyLoc=A[2],e.afterLoc=A[3]),this.tryEntries.push(e)}function F(A){var e=A.completion||{};e.type="normal",delete e.arg,A.completion=e}function S(A){this.tryEntries=[{tryLoc:"root"}],A.forEach(G,this),this.reset(!0)}function v(A){if(A){var t=A[g];if(t)return t.call(A);if("function"==typeof A.next)return A;if(!isNaN(A.length)){var i=-1,I=function t(){for(;++i<A.length;)if(r.call(A,i))return t.value=A[i],t.done=!1,t;return t.value=e,t.done=!0,t};return I.next=I}}return{next:R}}function R(){return{value:e,done:!0}}return l.prototype=u,o(y,"constructor",u),o(u,"constructor",l),l.displayName=o(u,a,"GeneratorFunction"),A.isGeneratorFunction=function(A){var e="function"==typeof A&&A.constructor;return!!e&&(e===l||"GeneratorFunction"===(e.displayName||e.name))},A.mark=function(A){return Object.setPrototypeOf?Object.setPrototypeOf(A,u):(A.__proto__=u,o(A,a,"GeneratorFunction")),A.prototype=Object.create(y),A},A.awrap=function(A){return{__await:A}},k(p.prototype),o(p.prototype,n,(function(){return this})),A.AsyncIterator=p,A.async=function(e,t,i,r,I){void 0===I&&(I=Promise);var g=new p(B(e,t,i,r),I);return A.isGeneratorFunction(t)?g:g.next().then((function(A){return A.done?A.value:g.next()}))},k(y),o(y,a,"Generator"),o(y,g,(function(){return this})),o(y,"toString",(function(){return"[object Generator]"})),A.keys=function(A){var e=[];for(var t in A)e.push(t);return e.reverse(),function t(){for(;e.length;){var i=e.pop();if(i in A)return t.value=i,t.done=!1,t}return t.done=!0,t}},A.values=v,S.prototype={constructor:S,reset:function(A){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(F),!A)for(var t in this)"t"===t.charAt(0)&&r.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=e)},stop:function(){this.done=!0;var A=this.tryEntries[0].completion;if("throw"===A.type)throw A.arg;return this.rval},dispatchException:function(A){if(this.done)throw A;var t=this;function i(i,r){return n.type="throw",n.arg=A,t.next=i,r&&(t.method="next",t.arg=e),!!r}for(var I=this.tryEntries.length-1;I>=0;--I){var g=this.tryEntries[I],n=g.completion;if("root"===g.tryLoc)return i("end");if(g.tryLoc<=this.prev){var a=r.call(g,"catchLoc"),o=r.call(g,"finallyLoc");if(a&&o){if(this.prev<g.catchLoc)return i(g.catchLoc,!0);if(this.prev<g.finallyLoc)return i(g.finallyLoc)}else if(a){if(this.prev<g.catchLoc)return i(g.catchLoc,!0)}else{if(!o)throw new Error("try statement without catch or finally");if(this.prev<g.finallyLoc)return i(g.finallyLoc)}}}},abrupt:function(A,e){for(var t=this.tryEntries.length-1;t>=0;--t){var i=this.tryEntries[t];if(i.tryLoc<=this.prev&&r.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var I=i;break}}I&&("break"===A||"continue"===A)&&I.tryLoc<=e&&e<=I.finallyLoc&&(I=null);var g=I?I.completion:{};return g.type=A,g.arg=e,I?(this.method="next",this.next=I.finallyLoc,c):this.complete(g)},complete:function(A,e){if("throw"===A.type)throw A.arg;return"break"===A.type||"continue"===A.type?this.next=A.arg:"return"===A.type?(this.rval=this.arg=A.arg,this.method="return",this.next="end"):"normal"===A.type&&e&&(this.next=e),c},finish:function(A){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===A)return this.complete(t.completion,t.afterLoc),F(t),c}},catch:function(A){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===A){var i=t.completion;if("throw"===i.type){var r=i.arg;F(t)}return r}}throw new Error("illegal catch attempt")},delegateYield:function(A,t,i){return this.delegate={iterator:v(A),resultName:t,nextLoc:i},"next"===this.method&&(this.arg=e),c}},A}(A.exports);try{regeneratorRuntime=e}catch(A){"object"===("undefined"==typeof globalThis?"undefined":t(globalThis))?globalThis.regeneratorRuntime=e:Function("r","regeneratorRuntime = r")(e)}}(i);var r=i.exports,I=new Map;function g(A,e){Array.isArray(A)||(A=[A]),A.forEach((function(A){return I.set(A,e)}))}function n(A){return a.apply(this,arguments)}function a(){return(a=e(r.mark((function A(e){var t,i;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:if(t=I.get(e.Compression)){A.next=3;break}throw new Error("Unknown compression method identifier: ".concat(e.Compression));case 3:return A.next=5,t();case 5:return i=A.sent,A.abrupt("return",new i(e));case 7:case"end":return A.stop()}}),A)})))).apply(this,arguments)}g([void 0,1],(function(){return Promise.resolve().then((function(){return y})).then((function(A){return A.default}))})),g(5,(function(){return Promise.resolve().then((function(){return F})).then((function(A){return A.default}))})),g(6,(function(){throw new Error("old style JPEG compression is not supported.")})),g(7,(function(){return Promise.resolve().then((function(){return N})).then((function(A){return A.default}))})),g([8,32946],(function(){return Promise.resolve().then((function(){return OA})).then((function(A){return A.default}))})),g(32773,(function(){return Promise.resolve().then((function(){return _A})).then((function(A){return A.default}))})),g(34887,(function(){return Promise.resolve().then((function(){return le})).then(function(){var A=e(r.mark((function A(e){return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return A.next=2,e.zstd.init();case 2:return A.abrupt("return",e);case 3:case"end":return A.stop()}}),A)})));return function(e){return A.apply(this,arguments)}}()).then((function(A){return A.default}))})),g(50001,(function(){return Promise.resolve().then((function(){return de})).then((function(A){return A.default}))}));var o=globalThis;function B(A,e){if(!(A instanceof e))throw new TypeError("Cannot call a class as a function")}function C(A,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(A,i.key,i)}}function Q(A,e,t){return e&&C(A.prototype,e),t&&C(A,t),A}function E(A,e){return E=Object.setPrototypeOf||function(A,e){return A.__proto__=e,A},E(A,e)}function s(A,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");A.prototype=Object.create(e&&e.prototype,{constructor:{value:A,writable:!0,configurable:!0}}),e&&E(A,e)}function f(A,e){if(e&&("object"===t(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(A){if(void 0===A)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return A}(A)}function c(A){return c=Object.setPrototypeOf?Object.getPrototypeOf:function(A){return A.__proto__||Object.getPrototypeOf(A)},c(A)}function h(A,e){var t=A.length-e,i=0;do{for(var r=e;r>0;r--)A[i+e]+=A[i],i++;t-=e}while(t>0)}function l(A,e,t){for(var i=0,r=A.length,I=r/t;r>e;){for(var g=e;g>0;--g)A[i+e]+=A[i],++i;r-=e}for(var n=A.slice(),a=0;a<I;++a)for(var o=0;o<t;++o)A[t*a+o]=n[(t-o-1)*I+a]}function u(A,e,t,i,r,I){if(!e||1===e)return A;for(var g=0;g<r.length;++g){if(r[g]%8!=0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(r[g]!==r[0])throw new Error("When decoding with predictor, all samples must have the same size.")}for(var n=r[0]/8,a=2===I?1:r.length,o=0;o<i&&!(o*a*t*n>=A.byteLength);++o){var B=void 0;if(2===e){switch(r[0]){case 8:B=new Uint8Array(A,o*a*t*n,a*t*n);break;case 16:B=new Uint16Array(A,o*a*t*n,a*t*n/2);break;case 32:B=new Uint32Array(A,o*a*t*n,a*t*n/4);break;default:throw new Error("Predictor 2 not allowed with ".concat(r[0]," bits per sample."))}h(B,a)}else 3===e&&l(B=new Uint8Array(A,o*a*t*n,a*t*n),a,n)}return A}o.addEventListener("message",function(){var A=e(r.mark((function A(e){var t,i,I,g,a,B;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return t=e.data,i=t.id,I=t.fileDirectory,g=t.buffer,A.next=3,n(I);case 3:return a=A.sent,A.next=6,a.decode(I,g);case 6:B=A.sent,o.postMessage({decoded:B,id:i},[B]);case 8:case"end":return A.stop()}}),A)})));return function(e){return A.apply(this,arguments)}}());var w=function(){function A(){B(this,A)}var t;return Q(A,[{key:"decode",value:(t=e(r.mark((function A(e,t){var i,I,g,n,a;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return A.next=2,this.decodeBlock(t);case 2:if(i=A.sent,1===(I=e.Predictor||1)){A.next=9;break}return g=!e.StripOffsets,n=g?e.TileWidth:e.ImageWidth,a=g?e.TileLength:e.RowsPerStrip||e.ImageLength,A.abrupt("return",u(i,I,n,a,e.BitsPerSample,e.PlanarConfiguration));case 9:return A.abrupt("return",i);case 10:case"end":return A.stop()}}),A,this)}))),function(A,e){return t.apply(this,arguments)})}]),A}();function d(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var D=function(A){s(t,w);var e=d(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:"decodeBlock",value:function(A){return A}}]),t}(),y=Object.freeze({__proto__:null,default:D});function k(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}function p(A,e){for(var t=e.length-1;t>=0;t--)A.push(e[t]);return A}function m(A){for(var e=new Uint16Array(4093),t=new Uint8Array(4093),i=0;i<=257;i++)e[i]=4096,t[i]=i;var r=258,I=9,g=0;function n(){r=258,I=9}function a(A){var e=function(A,e,t){var i=e%8,r=Math.floor(e/8),I=8-i,g=e+t-8*(r+1),n=8*(r+2)-(e+t),a=8*(r+2)-e;if(n=Math.max(0,n),r>=A.length)return console.warn("ran off the end of the buffer before finding EOI_CODE (end on input code)"),257;var o=A[r]&Math.pow(2,8-i)-1,B=o<<=t-I;if(r+1<A.length){var C=A[r+1]>>>n;B+=C<<=Math.max(0,t-a)}if(g>8&&r+2<A.length){var Q=8*(r+3)-(e+t);B+=A[r+2]>>>Q}return B}(A,g,I);return g+=I,e}function o(A,i){return t[r]=i,e[r]=A,++r-1}function B(A){for(var i=[],r=A;4096!==r;r=e[r])i.push(t[r]);return i}var C=[];n();for(var Q,E=new Uint8Array(A),s=a(E);257!==s;){if(256===s){for(n(),s=a(E);256===s;)s=a(E);if(257===s)break;if(s>256)throw new Error("corrupted code at scanline ".concat(s));p(C,B(s)),Q=s}else if(s<r){var f=B(s);p(C,f),o(Q,f[f.length-1]),Q=s}else{var c=B(Q);if(!c)throw new Error("Bogus entry. Not in dictionary, ".concat(Q," / ").concat(r,", position: ").concat(g));p(C,c),C.push(c[c.length-1]),o(Q,c[c.length-1]),Q=s}r+1>=Math.pow(2,I)&&(12===I?Q=void 0:I++),s=a(E)}return new Uint8Array(C)}var G=function(A){s(t,w);var e=k(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:"decodeBlock",value:function(A){return m(A).buffer}}]),t}(),F=Object.freeze({__proto__:null,default:G});function S(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var v=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]);function R(A,e){for(var t=0,i=[],r=16;r>0&&!A[r-1];)--r;i.push({children:[],index:0});for(var I,g=i[0],n=0;n<r;n++){for(var a=0;a<A[n];a++){for((g=i.pop()).children[g.index]=e[t];g.index>0;)g=i.pop();for(g.index++,i.push(g);i.length<=n;)i.push(I={children:[],index:0}),g.children[g.index]=I.children,g=I;t++}n+1<r&&(i.push(I={children:[],index:0}),g.children[g.index]=I.children,g=I)}return i[0].children}function U(A,e,i,r,I,g,n,a,o){var B=i.mcusPerLine,C=i.progressive,Q=e,E=e,s=0,f=0;function c(){if(f>0)return f--,s>>f&1;if(255===(s=A[E++])){var e=A[E++];if(e)throw new Error("unexpected marker: ".concat((s<<8|e).toString(16)))}return f=7,s>>>7}function h(A){for(var e,i=A;null!==(e=c());){if("number"==typeof(i=i[e]))return i;if("object"!==t(i))throw new Error("invalid huffman sequence")}return null}function l(A){for(var e=A,t=0;e>0;){var i=c();if(null===i)return;t=t<<1|i,--e}return t}function u(A){var e=l(A);return e>=1<<A-1?e:e+(-1<<A)+1}var w=0;var d,D=0;function y(A,e,t,i,r){var I=t%B,g=(t/B|0)*A.v+i,n=I*A.h+r;e(A,A.blocks[g][n])}function k(A,e,t){var i=t/A.blocksPerLine|0,r=t%A.blocksPerLine;e(A,A.blocks[i][r])}var p,m,G,F,S,R,U=r.length;R=C?0===g?0===a?function(A,e){var t=h(A.huffmanTableDC),i=0===t?0:u(t)<<o;A.pred+=i,e[0]=A.pred}:function(A,e){e[0]|=c()<<o}:0===a?function(A,e){if(w>0)w--;else for(var t=g,i=n;t<=i;){var r=h(A.huffmanTableAC),I=15&r,a=r>>4;if(0===I){if(a<15){w=l(a)+(1<<a)-1;break}t+=16}else e[v[t+=a]]=u(I)*(1<<o),t++}}:function(A,e){for(var t=g,i=n,r=0;t<=i;){var I=v[t],a=e[I]<0?-1:1;switch(D){case 0:var B=h(A.huffmanTableAC),C=15&B;if(r=B>>4,0===C)r<15?(w=l(r)+(1<<r),D=4):(r=16,D=1);else{if(1!==C)throw new Error("invalid ACn encoding");d=u(C),D=r?2:3}continue;case 1:case 2:e[I]?e[I]+=(c()<<o)*a:0==--r&&(D=2===D?3:0);break;case 3:e[I]?e[I]+=(c()<<o)*a:(e[I]=d<<o,D=0);break;case 4:e[I]&&(e[I]+=(c()<<o)*a)}t++}4===D&&0==--w&&(D=0)}:function(A,e){var t=h(A.huffmanTableDC),i=0===t?0:u(t);A.pred+=i,e[0]=A.pred;for(var r=1;r<64;){var I=h(A.huffmanTableAC),g=15&I,n=I>>4;if(0===g){if(n<15)break;r+=16}else e[v[r+=n]]=u(g),r++}};var L,b,M=0;b=1===U?r[0].blocksPerLine*r[0].blocksPerColumn:B*i.mcusPerColumn;for(var N=I||b;M<b;){for(m=0;m<U;m++)r[m].pred=0;if(w=0,1===U)for(p=r[0],S=0;S<N;S++)k(p,R,M),M++;else for(S=0;S<N;S++){for(m=0;m<U;m++){var x=p=r[m],J=x.h,q=x.v;for(G=0;G<q;G++)for(F=0;F<J;F++)y(p,R,M,G,F)}if(++M===b)break}if(f=0,(L=A[E]<<8|A[E+1])<65280)throw new Error("marker was not found");if(!(L>=65488&&L<=65495))break;E+=2}return E-Q}function L(A,e){var t=[],i=e.blocksPerLine,r=e.blocksPerColumn,I=i<<3,g=new Int32Array(64),n=new Uint8Array(64);function a(A,t,i){var r,I,g,n,a,o,B,C,Q,E,s=e.quantizationTable,f=i;for(E=0;E<64;E++)f[E]=A[E]*s[E];for(E=0;E<8;++E){var c=8*E;0!==f[1+c]||0!==f[2+c]||0!==f[3+c]||0!==f[4+c]||0!==f[5+c]||0!==f[6+c]||0!==f[7+c]?(r=5793*f[0+c]+128>>8,I=5793*f[4+c]+128>>8,g=f[2+c],n=f[6+c],a=2896*(f[1+c]-f[7+c])+128>>8,C=2896*(f[1+c]+f[7+c])+128>>8,o=f[3+c]<<4,Q=r-I+1>>1,r=r+I+1>>1,I=Q,Q=3784*g+1567*n+128>>8,g=1567*g-3784*n+128>>8,n=Q,Q=a-(B=f[5+c]<<4)+1>>1,a=a+B+1>>1,B=Q,Q=C+o+1>>1,o=C-o+1>>1,C=Q,Q=r-n+1>>1,r=r+n+1>>1,n=Q,Q=I-g+1>>1,I=I+g+1>>1,g=Q,Q=2276*a+3406*C+2048>>12,a=3406*a-2276*C+2048>>12,C=Q,Q=799*o+4017*B+2048>>12,o=4017*o-799*B+2048>>12,B=Q,f[0+c]=r+C,f[7+c]=r-C,f[1+c]=I+B,f[6+c]=I-B,f[2+c]=g+o,f[5+c]=g-o,f[3+c]=n+a,f[4+c]=n-a):(Q=5793*f[0+c]+512>>10,f[0+c]=Q,f[1+c]=Q,f[2+c]=Q,f[3+c]=Q,f[4+c]=Q,f[5+c]=Q,f[6+c]=Q,f[7+c]=Q)}for(E=0;E<8;++E){var h=E;0!==f[8+h]||0!==f[16+h]||0!==f[24+h]||0!==f[32+h]||0!==f[40+h]||0!==f[48+h]||0!==f[56+h]?(r=5793*f[0+h]+2048>>12,I=5793*f[32+h]+2048>>12,g=f[16+h],n=f[48+h],a=2896*(f[8+h]-f[56+h])+2048>>12,C=2896*(f[8+h]+f[56+h])+2048>>12,o=f[24+h],Q=r-I+1>>1,r=r+I+1>>1,I=Q,Q=3784*g+1567*n+2048>>12,g=1567*g-3784*n+2048>>12,n=Q,Q=a-(B=f[40+h])+1>>1,a=a+B+1>>1,B=Q,Q=C+o+1>>1,o=C-o+1>>1,C=Q,Q=r-n+1>>1,r=r+n+1>>1,n=Q,Q=I-g+1>>1,I=I+g+1>>1,g=Q,Q=2276*a+3406*C+2048>>12,a=3406*a-2276*C+2048>>12,C=Q,Q=799*o+4017*B+2048>>12,o=4017*o-799*B+2048>>12,B=Q,f[0+h]=r+C,f[56+h]=r-C,f[8+h]=I+B,f[48+h]=I-B,f[16+h]=g+o,f[40+h]=g-o,f[24+h]=n+a,f[32+h]=n-a):(Q=5793*i[E+0]+8192>>14,f[0+h]=Q,f[8+h]=Q,f[16+h]=Q,f[24+h]=Q,f[32+h]=Q,f[40+h]=Q,f[48+h]=Q,f[56+h]=Q)}for(E=0;E<64;++E){var l=128+(f[E]+8>>4);t[E]=l<0?0:l>255?255:l}}for(var o=0;o<r;o++){for(var B=o<<3,C=0;C<8;C++)t.push(new Uint8Array(I));for(var Q=0;Q<i;Q++){a(e.blocks[o][Q],n,g);for(var E=0,s=Q<<3,f=0;f<8;f++)for(var c=t[B+f],h=0;h<8;h++)c[s+h]=n[E++]}}return t}var b=function(){function A(){B(this,A),this.jfif=null,this.adobe=null,this.quantizationTables=[],this.huffmanTablesAC=[],this.huffmanTablesDC=[],this.resetFrames()}return Q(A,[{key:"resetFrames",value:function(){this.frames=[]}},{key:"parse",value:function(A){var e=0;function t(){var t=A[e]<<8|A[e+1];return e+=2,t}function i(A){var e,t,i=0,r=0;for(t in A.components)A.components.hasOwnProperty(t)&&(i<(e=A.components[t]).h&&(i=e.h),r<e.v&&(r=e.v));var I=Math.ceil(A.samplesPerLine/8/i),g=Math.ceil(A.scanLines/8/r);for(t in A.components)if(A.components.hasOwnProperty(t)){e=A.components[t];for(var n=Math.ceil(Math.ceil(A.samplesPerLine/8)*e.h/i),a=Math.ceil(Math.ceil(A.scanLines/8)*e.v/r),o=I*e.h,B=g*e.v,C=[],Q=0;Q<B;Q++){for(var E=[],s=0;s<o;s++)E.push(new Int32Array(64));C.push(E)}e.blocksPerLine=n,e.blocksPerColumn=a,e.blocks=C}A.maxH=i,A.maxV=r,A.mcusPerLine=I,A.mcusPerColumn=g}var r,I,g=t();if(65496!==g)throw new Error("SOI not found");for(g=t();65497!==g;){switch(g){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var n=(r=void 0,I=void 0,r=t(),I=A.subarray(e,e+r-2),e+=I.length,I);65504===g&&74===n[0]&&70===n[1]&&73===n[2]&&70===n[3]&&0===n[4]&&(this.jfif={version:{major:n[5],minor:n[6]},densityUnits:n[7],xDensity:n[8]<<8|n[9],yDensity:n[10]<<8|n[11],thumbWidth:n[12],thumbHeight:n[13],thumbData:n.subarray(14,14+3*n[12]*n[13])}),65518===g&&65===n[0]&&100===n[1]&&111===n[2]&&98===n[3]&&101===n[4]&&0===n[5]&&(this.adobe={version:n[6],flags0:n[7]<<8|n[8],flags1:n[9]<<8|n[10],transformCode:n[11]});break;case 65499:for(var a=t()+e-2;e<a;){var o=A[e++],B=new Int32Array(64);if(o>>4==0)for(var C=0;C<64;C++){B[v[C]]=A[e++]}else{if(o>>4!=1)throw new Error("DQT: invalid table spec");for(var Q=0;Q<64;Q++){B[v[Q]]=t()}}this.quantizationTables[15&o]=B}break;case 65472:case 65473:case 65474:t();for(var E={extended:65473===g,progressive:65474===g,precision:A[e++],scanLines:t(),samplesPerLine:t(),components:{},componentsOrder:[]},s=A[e++],f=void 0,c=0;c<s;c++){f=A[e];var h=A[e+1]>>4,l=15&A[e+1],u=A[e+2];E.componentsOrder.push(f),E.components[f]={h:h,v:l,quantizationIdx:u},e+=3}i(E),this.frames.push(E);break;case 65476:for(var w=t(),d=2;d<w;){for(var D=A[e++],y=new Uint8Array(16),k=0,p=0;p<16;p++,e++)y[p]=A[e],k+=y[p];for(var m=new Uint8Array(k),G=0;G<k;G++,e++)m[G]=A[e];d+=17+k,D>>4==0?this.huffmanTablesDC[15&D]=R(y,m):this.huffmanTablesAC[15&D]=R(y,m)}break;case 65501:t(),this.resetInterval=t();break;case 65498:t();for(var F=A[e++],S=[],L=this.frames[0],b=0;b<F;b++){var M=L.components[A[e++]],N=A[e++];M.huffmanTableDC=this.huffmanTablesDC[N>>4],M.huffmanTableAC=this.huffmanTablesAC[15&N],S.push(M)}var x=A[e++],J=A[e++],q=A[e++],Y=U(A,e,L,S,this.resetInterval,x,J,q>>4,15&q);e+=Y;break;case 65535:255!==A[e]&&e--;break;default:if(255===A[e-3]&&A[e-2]>=192&&A[e-2]<=254){e-=3;break}throw new Error("unknown JPEG marker ".concat(g.toString(16)))}g=t()}}},{key:"getResult",value:function(){var A=this.frames;if(0===this.frames.length)throw new Error("no frames were decoded");this.frames.length>1&&console.warn("more than one frame is not supported");for(var e=0;e<this.frames.length;e++)for(var t=this.frames[e].components,i=0,r=Object.keys(t);i<r.length;i++){var I=r[i];t[I].quantizationTable=this.quantizationTables[t[I].quantizationIdx],delete t[I].quantizationIdx}for(var g=A[0],n=g.components,a=g.componentsOrder,o=[],B=g.samplesPerLine,C=g.scanLines,Q=0;Q<a.length;Q++){var E=n[a[Q]];o.push({lines:L(0,E),scaleX:E.h/g.maxH,scaleY:E.v/g.maxV})}for(var s=new Uint8Array(B*C*o.length),f=0,c=0;c<C;++c)for(var h=0;h<B;++h)for(var l=0;l<o.length;++l){var u=o[l];s[f]=u.lines[0|c*u.scaleY][0|h*u.scaleX],++f}return s}}]),A}(),M=function(A){s(t,w);var e=S(t);function t(A){var i;return B(this,t),(i=e.call(this)).reader=new b,A.JPEGTables&&i.reader.parse(A.JPEGTables),i}return Q(t,[{key:"decodeBlock",value:function(A){return this.reader.resetFrames(),this.reader.parse(new Uint8Array(A)),this.reader.getResult().buffer}}]),t}(),N=Object.freeze({__proto__:null,default:M});function x(A){for(var e=A.length;--e>=0;)A[e]=0}x(new Array(576)),x(new Array(60)),x(new Array(512)),x(new Array(256)),x(new Array(29)),x(new Array(30));var J=function(A,e,t,i){for(var r=65535&A|0,I=A>>>16&65535|0,g=0;0!==t;){t-=g=t>2e3?2e3:t;do{I=I+(r=r+e[i++]|0)|0}while(--g);r%=65521,I%=65521}return r|I<<16|0},q=new Uint32Array(function(){for(var A,e=[],t=0;t<256;t++){A=t;for(var i=0;i<8;i++)A=1&A?3988292384^A>>>1:A>>>1;e[t]=A}return e}()),Y=function(A,e,t,i){var r=q,I=i+t;A^=-1;for(var g=i;g<I;g++)A=A>>>8^r[255&(A^e[g])];return-1^A},K={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},H={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},O=function(A,e){return Object.prototype.hasOwnProperty.call(A,e)},P=function(A){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var i=e.shift();if(i){if("object"!==t(i))throw new TypeError(i+"must be non-object");for(var r in i)O(i,r)&&(A[r]=i[r])}}return A},T=function(A){for(var e=0,t=0,i=A.length;t<i;t++)e+=A[t].length;for(var r=new Uint8Array(e),I=0,g=0,n=A.length;I<n;I++){var a=A[I];r.set(a,g),g+=a.length}return r},V=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(A){V=!1}for(var _=new Uint8Array(256),X=0;X<256;X++)_[X]=X>=252?6:X>=248?5:X>=240?4:X>=224?3:X>=192?2:1;_[254]=_[254]=1;var Z=function(A){if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(A);var e,t,i,r,I,g=A.length,n=0;for(r=0;r<g;r++)55296==(64512&(t=A.charCodeAt(r)))&&r+1<g&&56320==(64512&(i=A.charCodeAt(r+1)))&&(t=65536+(t-55296<<10)+(i-56320),r++),n+=t<128?1:t<2048?2:t<65536?3:4;for(e=new Uint8Array(n),I=0,r=0;I<n;r++)55296==(64512&(t=A.charCodeAt(r)))&&r+1<g&&56320==(64512&(i=A.charCodeAt(r+1)))&&(t=65536+(t-55296<<10)+(i-56320),r++),t<128?e[I++]=t:t<2048?(e[I++]=192|t>>>6,e[I++]=128|63&t):t<65536?(e[I++]=224|t>>>12,e[I++]=128|t>>>6&63,e[I++]=128|63&t):(e[I++]=240|t>>>18,e[I++]=128|t>>>12&63,e[I++]=128|t>>>6&63,e[I++]=128|63&t);return e},j=function(A,e){var t,i,r=e||A.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(A.subarray(0,e));var I=new Array(2*r);for(i=0,t=0;t<r;){var g=A[t++];if(g<128)I[i++]=g;else{var n=_[g];if(n>4)I[i++]=65533,t+=n-1;else{for(g&=2===n?31:3===n?15:7;n>1&&t<r;)g=g<<6|63&A[t++],n--;n>1?I[i++]=65533:g<65536?I[i++]=g:(g-=65536,I[i++]=55296|g>>10&1023,I[i++]=56320|1023&g)}}}return function(A,e){if(e<65534&&A.subarray&&V)return String.fromCharCode.apply(null,A.length===e?A:A.subarray(0,e));for(var t="",i=0;i<e;i++)t+=String.fromCharCode(A[i]);return t}(I,i)},W=function(A,e){(e=e||A.length)>A.length&&(e=A.length);for(var t=e-1;t>=0&&128==(192&A[t]);)t--;return t<0||0===t?e:t+_[A[t]]>e?t:e};var z=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},$=function(A,e){var t,i,r,I,g,n,a,o,B,C,Q,E,s,f,c,h,l,u,w,d,D,y,k,p,m=A.state;t=A.next_in,k=A.input,i=t+(A.avail_in-5),r=A.next_out,p=A.output,I=r-(e-A.avail_out),g=r+(A.avail_out-257),n=m.dmax,a=m.wsize,o=m.whave,B=m.wnext,C=m.window,Q=m.hold,E=m.bits,s=m.lencode,f=m.distcode,c=(1<<m.lenbits)-1,h=(1<<m.distbits)-1;A:do{E<15&&(Q+=k[t++]<<E,E+=8,Q+=k[t++]<<E,E+=8),l=s[Q&c];e:for(;;){if(Q>>>=u=l>>>24,E-=u,0===(u=l>>>16&255))p[r++]=65535&l;else{if(!(16&u)){if(0==(64&u)){l=s[(65535&l)+(Q&(1<<u)-1)];continue e}if(32&u){m.mode=12;break A}A.msg="invalid literal/length code",m.mode=30;break A}w=65535&l,(u&=15)&&(E<u&&(Q+=k[t++]<<E,E+=8),w+=Q&(1<<u)-1,Q>>>=u,E-=u),E<15&&(Q+=k[t++]<<E,E+=8,Q+=k[t++]<<E,E+=8),l=f[Q&h];t:for(;;){if(Q>>>=u=l>>>24,E-=u,!(16&(u=l>>>16&255))){if(0==(64&u)){l=f[(65535&l)+(Q&(1<<u)-1)];continue t}A.msg="invalid distance code",m.mode=30;break A}if(d=65535&l,E<(u&=15)&&(Q+=k[t++]<<E,(E+=8)<u&&(Q+=k[t++]<<E,E+=8)),(d+=Q&(1<<u)-1)>n){A.msg="invalid distance too far back",m.mode=30;break A}if(Q>>>=u,E-=u,d>(u=r-I)){if((u=d-u)>o&&m.sane){A.msg="invalid distance too far back",m.mode=30;break A}if(D=0,y=C,0===B){if(D+=a-u,u<w){w-=u;do{p[r++]=C[D++]}while(--u);D=r-d,y=p}}else if(B<u){if(D+=a+B-u,(u-=B)<w){w-=u;do{p[r++]=C[D++]}while(--u);if(D=0,B<w){w-=u=B;do{p[r++]=C[D++]}while(--u);D=r-d,y=p}}}else if(D+=B-u,u<w){w-=u;do{p[r++]=C[D++]}while(--u);D=r-d,y=p}for(;w>2;)p[r++]=y[D++],p[r++]=y[D++],p[r++]=y[D++],w-=3;w&&(p[r++]=y[D++],w>1&&(p[r++]=y[D++]))}else{D=r-d;do{p[r++]=p[D++],p[r++]=p[D++],p[r++]=p[D++],w-=3}while(w>2);w&&(p[r++]=p[D++],w>1&&(p[r++]=p[D++]))}break}}break}}while(t<i&&r<g);t-=w=E>>3,Q&=(1<<(E-=w<<3))-1,A.next_in=t,A.next_out=r,A.avail_in=t<i?i-t+5:5-(t-i),A.avail_out=r<g?g-r+257:257-(r-g),m.hold=Q,m.bits=E},AA=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),eA=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),tA=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),iA=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),rA=function(A,e,t,i,r,I,g,n){var a,o,B,C,Q,E,s,f,c,h=n.bits,l=0,u=0,w=0,d=0,D=0,y=0,k=0,p=0,m=0,G=0,F=null,S=0,v=new Uint16Array(16),R=new Uint16Array(16),U=null,L=0;for(l=0;l<=15;l++)v[l]=0;for(u=0;u<i;u++)v[e[t+u]]++;for(D=h,d=15;d>=1&&0===v[d];d--);if(D>d&&(D=d),0===d)return r[I++]=20971520,r[I++]=20971520,n.bits=1,0;for(w=1;w<d&&0===v[w];w++);for(D<w&&(D=w),p=1,l=1;l<=15;l++)if(p<<=1,(p-=v[l])<0)return-1;if(p>0&&(0===A||1!==d))return-1;for(R[1]=0,l=1;l<15;l++)R[l+1]=R[l]+v[l];for(u=0;u<i;u++)0!==e[t+u]&&(g[R[e[t+u]]++]=u);if(0===A?(F=U=g,E=19):1===A?(F=AA,S-=257,U=eA,L-=257,E=256):(F=tA,U=iA,E=-1),G=0,u=0,l=w,Q=I,y=D,k=0,B=-1,C=(m=1<<D)-1,1===A&&m>852||2===A&&m>592)return 1;for(;;){s=l-k,g[u]<E?(f=0,c=g[u]):g[u]>E?(f=U[L+g[u]],c=F[S+g[u]]):(f=96,c=0),a=1<<l-k,w=o=1<<y;do{r[Q+(G>>k)+(o-=a)]=s<<24|f<<16|c|0}while(0!==o);for(a=1<<l-1;G&a;)a>>=1;if(0!==a?(G&=a-1,G+=a):G=0,u++,0==--v[l]){if(l===d)break;l=e[t+g[u]]}if(l>D&&(G&C)!==B){for(0===k&&(k=D),Q+=w,p=1<<(y=l-k);y+k<d&&!((p-=v[y+k])<=0);)y++,p<<=1;if(m+=1<<y,1===A&&m>852||2===A&&m>592)return 1;r[B=G&C]=D<<24|y<<16|Q-I|0}}return 0!==G&&(r[Q+G]=l-k<<24|64<<16|0),n.bits=D,0},IA=H.Z_FINISH,gA=H.Z_BLOCK,nA=H.Z_TREES,aA=H.Z_OK,oA=H.Z_STREAM_END,BA=H.Z_NEED_DICT,CA=H.Z_STREAM_ERROR,QA=H.Z_DATA_ERROR,EA=H.Z_MEM_ERROR,sA=H.Z_BUF_ERROR,fA=H.Z_DEFLATED,cA=function(A){return(A>>>24&255)+(A>>>8&65280)+((65280&A)<<8)+((255&A)<<24)};function hA(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}var lA,uA,wA=function(A){if(!A||!A.state)return CA;var e=A.state;return A.total_in=A.total_out=e.total=0,A.msg="",e.wrap&&(A.adler=1&e.wrap),e.mode=1,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new Int32Array(852),e.distcode=e.distdyn=new Int32Array(592),e.sane=1,e.back=-1,aA},dA=function(A){if(!A||!A.state)return CA;var e=A.state;return e.wsize=0,e.whave=0,e.wnext=0,wA(A)},DA=function(A,e){var t;if(!A||!A.state)return CA;var i=A.state;return e<0?(t=0,e=-e):(t=1+(e>>4),e<48&&(e&=15)),e&&(e<8||e>15)?CA:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=t,i.wbits=e,dA(A))},yA=function(A,e){if(!A)return CA;var t=new hA;A.state=t,t.window=null;var i=DA(A,e);return i!==aA&&(A.state=null),i},kA=!0,pA=function(A){if(kA){lA=new Int32Array(512),uA=new Int32Array(32);for(var e=0;e<144;)A.lens[e++]=8;for(;e<256;)A.lens[e++]=9;for(;e<280;)A.lens[e++]=7;for(;e<288;)A.lens[e++]=8;for(rA(1,A.lens,0,288,lA,0,A.work,{bits:9}),e=0;e<32;)A.lens[e++]=5;rA(2,A.lens,0,32,uA,0,A.work,{bits:5}),kA=!1}A.lencode=lA,A.lenbits=9,A.distcode=uA,A.distbits=5},mA=function(A,e,t,i){var r,I=A.state;return null===I.window&&(I.wsize=1<<I.wbits,I.wnext=0,I.whave=0,I.window=new Uint8Array(I.wsize)),i>=I.wsize?(I.window.set(e.subarray(t-I.wsize,t),0),I.wnext=0,I.whave=I.wsize):((r=I.wsize-I.wnext)>i&&(r=i),I.window.set(e.subarray(t-i,t-i+r),I.wnext),(i-=r)?(I.window.set(e.subarray(t-i,t),0),I.wnext=i,I.whave=I.wsize):(I.wnext+=r,I.wnext===I.wsize&&(I.wnext=0),I.whave<I.wsize&&(I.whave+=r))),0},GA={inflateReset:dA,inflateReset2:DA,inflateResetKeep:wA,inflateInit:function(A){return yA(A,15)},inflateInit2:yA,inflate:function(A,e){var t,i,r,I,g,n,a,o,B,C,Q,E,s,f,c,h,l,u,w,d,D,y,k,p,m=0,G=new Uint8Array(4),F=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!A||!A.state||!A.output||!A.input&&0!==A.avail_in)return CA;12===(t=A.state).mode&&(t.mode=13),g=A.next_out,r=A.output,a=A.avail_out,I=A.next_in,i=A.input,n=A.avail_in,o=t.hold,B=t.bits,C=n,Q=a,y=aA;A:for(;;)switch(t.mode){case 1:if(0===t.wrap){t.mode=13;break}for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(2&t.wrap&&35615===o){t.check=0,G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0),o=0,B=0,t.mode=2;break}if(t.flags=0,t.head&&(t.head.done=!1),!(1&t.wrap)||(((255&o)<<8)+(o>>8))%31){A.msg="incorrect header check",t.mode=30;break}if((15&o)!==fA){A.msg="unknown compression method",t.mode=30;break}if(B-=4,D=8+(15&(o>>>=4)),0===t.wbits)t.wbits=D;else if(D>t.wbits){A.msg="invalid window size",t.mode=30;break}t.dmax=1<<t.wbits,A.adler=t.check=1,t.mode=512&o?10:12,o=0,B=0;break;case 2:for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(t.flags=o,(255&t.flags)!==fA){A.msg="unknown compression method",t.mode=30;break}if(57344&t.flags){A.msg="unknown header flags set",t.mode=30;break}t.head&&(t.head.text=o>>8&1),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0)),o=0,B=0,t.mode=3;case 3:for(;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.head&&(t.head.time=o),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,G[2]=o>>>16&255,G[3]=o>>>24&255,t.check=Y(t.check,G,4,0)),o=0,B=0,t.mode=4;case 4:for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.head&&(t.head.xflags=255&o,t.head.os=o>>8),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0)),o=0,B=0,t.mode=5;case 5:if(1024&t.flags){for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.length=o,t.head&&(t.head.extra_len=o),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0)),o=0,B=0}else t.head&&(t.head.extra=null);t.mode=6;case 6:if(1024&t.flags&&((E=t.length)>n&&(E=n),E&&(t.head&&(D=t.head.extra_len-t.length,t.head.extra||(t.head.extra=new Uint8Array(t.head.extra_len)),t.head.extra.set(i.subarray(I,I+E),D)),512&t.flags&&(t.check=Y(t.check,i,E,I)),n-=E,I+=E,t.length-=E),t.length))break A;t.length=0,t.mode=7;case 7:if(2048&t.flags){if(0===n)break A;E=0;do{D=i[I+E++],t.head&&D&&t.length<65536&&(t.head.name+=String.fromCharCode(D))}while(D&&E<n);if(512&t.flags&&(t.check=Y(t.check,i,E,I)),n-=E,I+=E,D)break A}else t.head&&(t.head.name=null);t.length=0,t.mode=8;case 8:if(4096&t.flags){if(0===n)break A;E=0;do{D=i[I+E++],t.head&&D&&t.length<65536&&(t.head.comment+=String.fromCharCode(D))}while(D&&E<n);if(512&t.flags&&(t.check=Y(t.check,i,E,I)),n-=E,I+=E,D)break A}else t.head&&(t.head.comment=null);t.mode=9;case 9:if(512&t.flags){for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(o!==(65535&t.check)){A.msg="header crc mismatch",t.mode=30;break}o=0,B=0}t.head&&(t.head.hcrc=t.flags>>9&1,t.head.done=!0),A.adler=t.check=0,t.mode=12;break;case 10:for(;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}A.adler=t.check=cA(o),o=0,B=0,t.mode=11;case 11:if(0===t.havedict)return A.next_out=g,A.avail_out=a,A.next_in=I,A.avail_in=n,t.hold=o,t.bits=B,BA;A.adler=t.check=1,t.mode=12;case 12:if(e===gA||e===nA)break A;case 13:if(t.last){o>>>=7&B,B-=7&B,t.mode=27;break}for(;B<3;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}switch(t.last=1&o,B-=1,3&(o>>>=1)){case 0:t.mode=14;break;case 1:if(pA(t),t.mode=20,e===nA){o>>>=2,B-=2;break A}break;case 2:t.mode=17;break;case 3:A.msg="invalid block type",t.mode=30}o>>>=2,B-=2;break;case 14:for(o>>>=7&B,B-=7&B;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if((65535&o)!=(o>>>16^65535)){A.msg="invalid stored block lengths",t.mode=30;break}if(t.length=65535&o,o=0,B=0,t.mode=15,e===nA)break A;case 15:t.mode=16;case 16:if(E=t.length){if(E>n&&(E=n),E>a&&(E=a),0===E)break A;r.set(i.subarray(I,I+E),g),n-=E,I+=E,a-=E,g+=E,t.length-=E;break}t.mode=12;break;case 17:for(;B<14;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(t.nlen=257+(31&o),o>>>=5,B-=5,t.ndist=1+(31&o),o>>>=5,B-=5,t.ncode=4+(15&o),o>>>=4,B-=4,t.nlen>286||t.ndist>30){A.msg="too many length or distance symbols",t.mode=30;break}t.have=0,t.mode=18;case 18:for(;t.have<t.ncode;){for(;B<3;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.lens[F[t.have++]]=7&o,o>>>=3,B-=3}for(;t.have<19;)t.lens[F[t.have++]]=0;if(t.lencode=t.lendyn,t.lenbits=7,k={bits:t.lenbits},y=rA(0,t.lens,0,19,t.lencode,0,t.work,k),t.lenbits=k.bits,y){A.msg="invalid code lengths set",t.mode=30;break}t.have=0,t.mode=19;case 19:for(;t.have<t.nlen+t.ndist;){for(;h=(m=t.lencode[o&(1<<t.lenbits)-1])>>>16&255,l=65535&m,!((c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(l<16)o>>>=c,B-=c,t.lens[t.have++]=l;else{if(16===l){for(p=c+2;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(o>>>=c,B-=c,0===t.have){A.msg="invalid bit length repeat",t.mode=30;break}D=t.lens[t.have-1],E=3+(3&o),o>>>=2,B-=2}else if(17===l){for(p=c+3;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}B-=c,D=0,E=3+(7&(o>>>=c)),o>>>=3,B-=3}else{for(p=c+7;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}B-=c,D=0,E=11+(127&(o>>>=c)),o>>>=7,B-=7}if(t.have+E>t.nlen+t.ndist){A.msg="invalid bit length repeat",t.mode=30;break}for(;E--;)t.lens[t.have++]=D}}if(30===t.mode)break;if(0===t.lens[256]){A.msg="invalid code -- missing end-of-block",t.mode=30;break}if(t.lenbits=9,k={bits:t.lenbits},y=rA(1,t.lens,0,t.nlen,t.lencode,0,t.work,k),t.lenbits=k.bits,y){A.msg="invalid literal/lengths set",t.mode=30;break}if(t.distbits=6,t.distcode=t.distdyn,k={bits:t.distbits},y=rA(2,t.lens,t.nlen,t.ndist,t.distcode,0,t.work,k),t.distbits=k.bits,y){A.msg="invalid distances set",t.mode=30;break}if(t.mode=20,e===nA)break A;case 20:t.mode=21;case 21:if(n>=6&&a>=258){A.next_out=g,A.avail_out=a,A.next_in=I,A.avail_in=n,t.hold=o,t.bits=B,$(A,Q),g=A.next_out,r=A.output,a=A.avail_out,I=A.next_in,i=A.input,n=A.avail_in,o=t.hold,B=t.bits,12===t.mode&&(t.back=-1);break}for(t.back=0;h=(m=t.lencode[o&(1<<t.lenbits)-1])>>>16&255,l=65535&m,!((c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(h&&0==(240&h)){for(u=c,w=h,d=l;h=(m=t.lencode[d+((o&(1<<u+w)-1)>>u)])>>>16&255,l=65535&m,!(u+(c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}o>>>=u,B-=u,t.back+=u}if(o>>>=c,B-=c,t.back+=c,t.length=l,0===h){t.mode=26;break}if(32&h){t.back=-1,t.mode=12;break}if(64&h){A.msg="invalid literal/length code",t.mode=30;break}t.extra=15&h,t.mode=22;case 22:if(t.extra){for(p=t.extra;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.length+=o&(1<<t.extra)-1,o>>>=t.extra,B-=t.extra,t.back+=t.extra}t.was=t.length,t.mode=23;case 23:for(;h=(m=t.distcode[o&(1<<t.distbits)-1])>>>16&255,l=65535&m,!((c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(0==(240&h)){for(u=c,w=h,d=l;h=(m=t.distcode[d+((o&(1<<u+w)-1)>>u)])>>>16&255,l=65535&m,!(u+(c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}o>>>=u,B-=u,t.back+=u}if(o>>>=c,B-=c,t.back+=c,64&h){A.msg="invalid distance code",t.mode=30;break}t.offset=l,t.extra=15&h,t.mode=24;case 24:if(t.extra){for(p=t.extra;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.offset+=o&(1<<t.extra)-1,o>>>=t.extra,B-=t.extra,t.back+=t.extra}if(t.offset>t.dmax){A.msg="invalid distance too far back",t.mode=30;break}t.mode=25;case 25:if(0===a)break A;if(E=Q-a,t.offset>E){if((E=t.offset-E)>t.whave&&t.sane){A.msg="invalid distance too far back",t.mode=30;break}E>t.wnext?(E-=t.wnext,s=t.wsize-E):s=t.wnext-E,E>t.length&&(E=t.length),f=t.window}else f=r,s=g-t.offset,E=t.length;E>a&&(E=a),a-=E,t.length-=E;do{r[g++]=f[s++]}while(--E);0===t.length&&(t.mode=21);break;case 26:if(0===a)break A;r[g++]=t.length,a--,t.mode=21;break;case 27:if(t.wrap){for(;B<32;){if(0===n)break A;n--,o|=i[I++]<<B,B+=8}if(Q-=a,A.total_out+=Q,t.total+=Q,Q&&(A.adler=t.check=t.flags?Y(t.check,r,Q,g-Q):J(t.check,r,Q,g-Q)),Q=a,(t.flags?o:cA(o))!==t.check){A.msg="incorrect data check",t.mode=30;break}o=0,B=0}t.mode=28;case 28:if(t.wrap&&t.flags){for(;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(o!==(4294967295&t.total)){A.msg="incorrect length check",t.mode=30;break}o=0,B=0}t.mode=29;case 29:y=oA;break A;case 30:y=QA;break A;case 31:return EA;default:return CA}return A.next_out=g,A.avail_out=a,A.next_in=I,A.avail_in=n,t.hold=o,t.bits=B,(t.wsize||Q!==A.avail_out&&t.mode<30&&(t.mode<27||e!==IA))&&mA(A,A.output,A.next_out,Q-A.avail_out),C-=A.avail_in,Q-=A.avail_out,A.total_in+=C,A.total_out+=Q,t.total+=Q,t.wrap&&Q&&(A.adler=t.check=t.flags?Y(t.check,r,Q,A.next_out-Q):J(t.check,r,Q,A.next_out-Q)),A.data_type=t.bits+(t.last?64:0)+(12===t.mode?128:0)+(20===t.mode||15===t.mode?256:0),(0===C&&0===Q||e===IA)&&y===aA&&(y=sA),y},inflateEnd:function(A){if(!A||!A.state)return CA;var e=A.state;return e.window&&(e.window=null),A.state=null,aA},inflateGetHeader:function(A,e){if(!A||!A.state)return CA;var t=A.state;return 0==(2&t.wrap)?CA:(t.head=e,e.done=!1,aA)},inflateSetDictionary:function(A,e){var t,i=e.length;return A&&A.state?0!==(t=A.state).wrap&&11!==t.mode?CA:11===t.mode&&J(1,e,i,0)!==t.check?QA:mA(A,e,i,i)?(t.mode=31,EA):(t.havedict=1,aA):CA},inflateInfo:"pako inflate (from Nodeca project)"};var FA=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},SA=Object.prototype.toString,vA=H.Z_NO_FLUSH,RA=H.Z_FINISH,UA=H.Z_OK,LA=H.Z_STREAM_END,bA=H.Z_NEED_DICT,MA=H.Z_STREAM_ERROR,NA=H.Z_DATA_ERROR,xA=H.Z_MEM_ERROR;function JA(A){this.options=P({chunkSize:65536,windowBits:15,to:""},A||{});var e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||A&&A.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new z,this.strm.avail_out=0;var t=GA.inflateInit2(this.strm,e.windowBits);if(t!==UA)throw new Error(K[t]);if(this.header=new FA,GA.inflateGetHeader(this.strm,this.header),e.dictionary&&("string"==typeof e.dictionary?e.dictionary=Z(e.dictionary):"[object ArrayBuffer]"===SA.call(e.dictionary)&&(e.dictionary=new Uint8Array(e.dictionary)),e.raw&&(t=GA.inflateSetDictionary(this.strm,e.dictionary))!==UA))throw new Error(K[t])}function qA(A,e){var t=new JA(e);if(t.push(A),t.err)throw t.msg||K[t.err];return t.result}JA.prototype.push=function(A,e){var t,i,r,I=this.strm,g=this.options.chunkSize,n=this.options.dictionary;if(this.ended)return!1;for(i=e===~~e?e:!0===e?RA:vA,"[object ArrayBuffer]"===SA.call(A)?I.input=new Uint8Array(A):I.input=A,I.next_in=0,I.avail_in=I.input.length;;){for(0===I.avail_out&&(I.output=new Uint8Array(g),I.next_out=0,I.avail_out=g),(t=GA.inflate(I,i))===bA&&n&&((t=GA.inflateSetDictionary(I,n))===UA?t=GA.inflate(I,i):t===NA&&(t=bA));I.avail_in>0&&t===LA&&I.state.wrap>0&&0!==A[I.next_in];)GA.inflateReset(I),t=GA.inflate(I,i);switch(t){case MA:case NA:case bA:case xA:return this.onEnd(t),this.ended=!0,!1}if(r=I.avail_out,I.next_out&&(0===I.avail_out||t===LA))if("string"===this.options.to){var a=W(I.output,I.next_out),o=I.next_out-a,B=j(I.output,a);I.next_out=o,I.avail_out=g-o,o&&I.output.set(I.output.subarray(a,a+o),0),this.onData(B)}else this.onData(I.output.length===I.next_out?I.output:I.output.subarray(0,I.next_out));if(t!==UA||0!==r){if(t===LA)return t=GA.inflateEnd(this.strm),this.onEnd(t),this.ended=!0,!0;if(0===I.avail_in)break}}return!0},JA.prototype.onData=function(A){this.chunks.push(A)},JA.prototype.onEnd=function(A){A===UA&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=T(this.chunks)),this.chunks=[],this.err=A,this.msg=this.strm.msg};var YA={Inflate:JA,inflate:qA,inflateRaw:function(A,e){return(e=e||{}).raw=!0,qA(A,e)},ungzip:qA,constants:H}.inflate;function KA(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var HA=function(A){s(t,w);var e=KA(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:"decodeBlock",value:function(A){return YA(new Uint8Array(A)).buffer}}]),t}(),OA=Object.freeze({__proto__:null,default:HA});function PA(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var TA,VA=function(A){s(t,w);var e=PA(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:"decodeBlock",value:function(A){for(var e=new DataView(A),t=[],i=0;i<A.byteLength;++i){var r=e.getInt8(i);if(r<0){var I=e.getUint8(i+1);r=-r;for(var g=0;g<=r;++g)t.push(I);i+=1}else{for(var n=0;n<=r;++n)t.push(e.getUint8(i+n+1));i+=r+1}}return new Uint8Array(t).buffer}}]),t}(),_A=Object.freeze({__proto__:null,default:VA}),XA={exports:{}};TA=XA,\n/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\nfunction(){var A,e,t,i,r,I,g,n,a,o,B,C,Q,E,s,f,c=(A={defaultNoDataValue:-34027999387901484e22,decode:function(I,g){var n=(g=g||{}).encodedMaskData||null===g.encodedMaskData,a=r(I,g.inputOffset||0,n),o=null!==g.noDataValue?g.noDataValue:A.defaultNoDataValue,B=e(a,g.pixelType||Float32Array,g.encodedMaskData,o,g.returnMask),C={width:a.width,height:a.height,pixelData:B.resultPixels,minValue:B.minValue,maxValue:a.pixels.maxValue,noDataValue:o};return B.resultMask&&(C.maskData=B.resultMask),g.returnEncodedMask&&a.mask&&(C.encodedMaskData=a.mask.bitset?a.mask.bitset:null),g.returnFileInfo&&(C.fileInfo=t(a),g.computeUsedBitDepths&&(C.fileInfo.bitDepths=i(a))),C}},e=function(A,e,t,i,r){var g,n,a,o=0,B=A.pixels.numBlocksX,C=A.pixels.numBlocksY,Q=Math.floor(A.width/B),E=Math.floor(A.height/C),s=2*A.maxZError,f=Number.MAX_VALUE;t=t||(A.mask?A.mask.bitset:null),n=new e(A.width*A.height),r&&t&&(a=new Uint8Array(A.width*A.height));for(var c,h,l=new Float32Array(Q*E),u=0;u<=C;u++){var w=u!==C?E:A.height%C;if(0!==w)for(var d=0;d<=B;d++){var D=d!==B?Q:A.width%B;if(0!==D){var y,k,p,m,G=u*A.width*E+d*Q,F=A.width-D,S=A.pixels.blocks[o];if(S.encoding<2?(0===S.encoding?y=S.rawData:(I(S.stuffedData,S.bitsPerPixel,S.numValidPixels,S.offset,s,l,A.pixels.maxValue),y=l),k=0):p=2===S.encoding?0:S.offset,t)for(h=0;h<w;h++){for(7&G&&(m=t[G>>3],m<<=7&G),c=0;c<D;c++)7&G||(m=t[G>>3]),128&m?(a&&(a[G]=1),f=f>(g=S.encoding<2?y[k++]:p)?g:f,n[G++]=g):(a&&(a[G]=0),n[G++]=i),m<<=1;G+=F}else if(S.encoding<2)for(h=0;h<w;h++){for(c=0;c<D;c++)f=f>(g=y[k++])?g:f,n[G++]=g;G+=F}else for(f=f>p?p:f,h=0;h<w;h++){for(c=0;c<D;c++)n[G++]=p;G+=F}if(1===S.encoding&&k!==S.numValidPixels)throw"Block and Mask do not match";o++}}}return{resultPixels:n,resultMask:a,minValue:f}},t=function(A){return{fileIdentifierString:A.fileIdentifierString,fileVersion:A.fileVersion,imageType:A.imageType,height:A.height,width:A.width,maxZError:A.maxZError,eofOffset:A.eofOffset,mask:A.mask?{numBlocksX:A.mask.numBlocksX,numBlocksY:A.mask.numBlocksY,numBytes:A.mask.numBytes,maxValue:A.mask.maxValue}:null,pixels:{numBlocksX:A.pixels.numBlocksX,numBlocksY:A.pixels.numBlocksY,numBytes:A.pixels.numBytes,maxValue:A.pixels.maxValue,noDataValue:A.noDataValue}}},i=function(A){for(var e=A.pixels.numBlocksX*A.pixels.numBlocksY,t={},i=0;i<e;i++){var r=A.pixels.blocks[i];0===r.encoding?t.float32=!0:1===r.encoding?t[r.bitsPerPixel]=!0:t[0]=!0}return Object.keys(t)},r=function(A,e,t){var i={},r=new Uint8Array(A,e,10);if(i.fileIdentifierString=String.fromCharCode.apply(null,r),"CntZImage"!==i.fileIdentifierString.trim())throw"Unexpected file identifier string: "+i.fileIdentifierString;e+=10;var I=new DataView(A,e,24);if(i.fileVersion=I.getInt32(0,!0),i.imageType=I.getInt32(4,!0),i.height=I.getUint32(8,!0),i.width=I.getUint32(12,!0),i.maxZError=I.getFloat64(16,!0),e+=24,!t)if(I=new DataView(A,e,16),i.mask={},i.mask.numBlocksY=I.getUint32(0,!0),i.mask.numBlocksX=I.getUint32(4,!0),i.mask.numBytes=I.getUint32(8,!0),i.mask.maxValue=I.getFloat32(12,!0),e+=16,i.mask.numBytes>0){var g=new Uint8Array(Math.ceil(i.width*i.height/8)),n=(I=new DataView(A,e,i.mask.numBytes)).getInt16(0,!0),a=2,o=0;do{if(n>0)for(;n--;)g[o++]=I.getUint8(a++);else{var B=I.getUint8(a++);for(n=-n;n--;)g[o++]=B}n=I.getInt16(a,!0),a+=2}while(a<i.mask.numBytes);if(-32768!==n||o<g.length)throw"Unexpected end of mask RLE encoding";i.mask.bitset=g,e+=i.mask.numBytes}else 0==(i.mask.numBytes|i.mask.numBlocksY|i.mask.maxValue)&&(i.mask.bitset=new Uint8Array(Math.ceil(i.width*i.height/8)));I=new DataView(A,e,16),i.pixels={},i.pixels.numBlocksY=I.getUint32(0,!0),i.pixels.numBlocksX=I.getUint32(4,!0),i.pixels.numBytes=I.getUint32(8,!0),i.pixels.maxValue=I.getFloat32(12,!0),e+=16;var C=i.pixels.numBlocksX,Q=i.pixels.numBlocksY,E=C+(i.width%C>0?1:0),s=Q+(i.height%Q>0?1:0);i.pixels.blocks=new Array(E*s);for(var f=0,c=0;c<s;c++)for(var h=0;h<E;h++){var l=0,u=A.byteLength-e;I=new DataView(A,e,Math.min(10,u));var w={};i.pixels.blocks[f++]=w;var d=I.getUint8(0);if(l++,w.encoding=63&d,w.encoding>3)throw"Invalid block encoding ("+w.encoding+")";if(2!==w.encoding){if(0!==d&&2!==d){if(d>>=6,w.offsetType=d,2===d)w.offset=I.getInt8(1),l++;else if(1===d)w.offset=I.getInt16(1,!0),l+=2;else{if(0!==d)throw"Invalid block offset type";w.offset=I.getFloat32(1,!0),l+=4}if(1===w.encoding)if(d=I.getUint8(l),l++,w.bitsPerPixel=63&d,d>>=6,w.numValidPixelsType=d,2===d)w.numValidPixels=I.getUint8(l),l++;else if(1===d)w.numValidPixels=I.getUint16(l,!0),l+=2;else{if(0!==d)throw"Invalid valid pixel count type";w.numValidPixels=I.getUint32(l,!0),l+=4}}var D;if(e+=l,3!==w.encoding)if(0===w.encoding){var y=(i.pixels.numBytes-1)/4;if(y!==Math.floor(y))throw"uncompressed block has invalid length";D=new ArrayBuffer(4*y),new Uint8Array(D).set(new Uint8Array(A,e,4*y));var k=new Float32Array(D);w.rawData=k,e+=4*y}else if(1===w.encoding){var p=Math.ceil(w.numValidPixels*w.bitsPerPixel/8),m=Math.ceil(p/4);D=new ArrayBuffer(4*m),new Uint8Array(D).set(new Uint8Array(A,e,p)),w.stuffedData=new Uint32Array(D),e+=p}}else e++}return i.eofOffset=e,i},I=function(A,e,t,i,r,I,g){var n,a,o,B=(1<<e)-1,C=0,Q=0,E=Math.ceil((g-i)/r),s=4*A.length-Math.ceil(e*t/8);for(A[A.length-1]<<=8*s,n=0;n<t;n++){if(0===Q&&(o=A[C++],Q=32),Q>=e)a=o>>>Q-e&B,Q-=e;else{var f=e-Q;a=(o&B)<<f&B,a+=(o=A[C++])>>>(Q=32-f)}I[n]=a<E?i+a*r:g}return I},A),h=(g=function(A,e,t,i,r,I,g,n){var a,o,B,C,Q,E=(1<<t)-1,s=0,f=0,c=4*A.length-Math.ceil(t*i/8);if(A[A.length-1]<<=8*c,r)for(a=0;a<i;a++)0===f&&(B=A[s++],f=32),f>=t?(o=B>>>f-t&E,f-=t):(o=(B&E)<<(C=t-f)&E,o+=(B=A[s++])>>>(f=32-C)),e[a]=r[o];else for(Q=Math.ceil((n-I)/g),a=0;a<i;a++)0===f&&(B=A[s++],f=32),f>=t?(o=B>>>f-t&E,f-=t):(o=(B&E)<<(C=t-f)&E,o+=(B=A[s++])>>>(f=32-C)),e[a]=o<Q?I+o*g:n},n=function(A,e,t,i,r,I){var g,n=(1<<e)-1,a=0,o=0,B=0,C=0,Q=0,E=[],s=4*A.length-Math.ceil(e*t/8);A[A.length-1]<<=8*s;var f=Math.ceil((I-i)/r);for(o=0;o<t;o++)0===C&&(g=A[a++],C=32),C>=e?(Q=g>>>C-e&n,C-=e):(Q=(g&n)<<(B=e-C)&n,Q+=(g=A[a++])>>>(C=32-B)),E[o]=Q<f?i+Q*r:I;return E.unshift(i),E},a=function(A,e,t,i,r,I,g,n){var a,o,B,C,Q=(1<<t)-1,E=0,s=0,f=0;if(r)for(a=0;a<i;a++)0===s&&(B=A[E++],s=32,f=0),s>=t?(o=B>>>f&Q,s-=t,f+=t):(o=B>>>f&Q,s=32-(C=t-s),o|=((B=A[E++])&(1<<C)-1)<<t-C,f=C),e[a]=r[o];else{var c=Math.ceil((n-I)/g);for(a=0;a<i;a++)0===s&&(B=A[E++],s=32,f=0),s>=t?(o=B>>>f&Q,s-=t,f+=t):(o=B>>>f&Q,s=32-(C=t-s),o|=((B=A[E++])&(1<<C)-1)<<t-C,f=C),e[a]=o<c?I+o*g:n}return e},o=function(A,e,t,i,r,I){var g,n=(1<<e)-1,a=0,o=0,B=0,C=0,Q=0,E=0,s=[],f=Math.ceil((I-i)/r);for(o=0;o<t;o++)0===C&&(g=A[a++],C=32,E=0),C>=e?(Q=g>>>E&n,C-=e,E+=e):(Q=g>>>E&n,C=32-(B=e-C),Q|=((g=A[a++])&(1<<B)-1)<<e-B,E=B),s[o]=Q<f?i+Q*r:I;return s.unshift(i),s},B=function(A,e,t,i){var r,I,g,n,a=(1<<t)-1,o=0,B=0,C=4*A.length-Math.ceil(t*i/8);for(A[A.length-1]<<=8*C,r=0;r<i;r++)0===B&&(g=A[o++],B=32),B>=t?(I=g>>>B-t&a,B-=t):(I=(g&a)<<(n=t-B)&a,I+=(g=A[o++])>>>(B=32-n)),e[r]=I;return e},C=function(A,e,t,i){var r,I,g,n,a=(1<<t)-1,o=0,B=0,C=0;for(r=0;r<i;r++)0===B&&(g=A[o++],B=32,C=0),B>=t?(I=g>>>C&a,B-=t,C+=t):(I=g>>>C&a,B=32-(n=t-B),I|=((g=A[o++])&(1<<n)-1)<<t-n,C=n),e[r]=I;return e},Q={HUFFMAN_LUT_BITS_MAX:12,computeChecksumFletcher32:function(A){for(var e=65535,t=65535,i=A.length,r=Math.floor(i/2),I=0;r;){var g=r>=359?359:r;r-=g;do{e+=A[I++]<<8,t+=e+=A[I++]}while(--g);e=(65535&e)+(e>>>16),t=(65535&t)+(t>>>16)}return 1&i&&(t+=e+=A[I]<<8),((t=(65535&t)+(t>>>16))<<16|(e=(65535&e)+(e>>>16)))>>>0},readHeaderInfo:function(A,e){var t=e.ptr,i=new Uint8Array(A,t,6),r={};if(r.fileIdentifierString=String.fromCharCode.apply(null,i),0!==r.fileIdentifierString.lastIndexOf("Lerc2",0))throw"Unexpected file identifier string (expect Lerc2 ): "+r.fileIdentifierString;t+=6;var I,g=new DataView(A,t,8),n=g.getInt32(0,!0);if(r.fileVersion=n,t+=4,n>=3&&(r.checksum=g.getUint32(4,!0),t+=4),g=new DataView(A,t,12),r.height=g.getUint32(0,!0),r.width=g.getUint32(4,!0),t+=8,n>=4?(r.numDims=g.getUint32(8,!0),t+=4):r.numDims=1,g=new DataView(A,t,40),r.numValidPixel=g.getUint32(0,!0),r.microBlockSize=g.getInt32(4,!0),r.blobSize=g.getInt32(8,!0),r.imageType=g.getInt32(12,!0),r.maxZError=g.getFloat64(16,!0),r.zMin=g.getFloat64(24,!0),r.zMax=g.getFloat64(32,!0),t+=40,e.headerInfo=r,e.ptr=t,n>=3&&(I=n>=4?52:48,this.computeChecksumFletcher32(new Uint8Array(A,t-I,r.blobSize-14))!==r.checksum))throw"Checksum failed.";return!0},checkMinMaxRanges:function(A,e){var t=e.headerInfo,i=this.getDataTypeArray(t.imageType),r=t.numDims*this.getDataTypeSize(t.imageType),I=this.readSubArray(A,e.ptr,i,r),g=this.readSubArray(A,e.ptr+r,i,r);e.ptr+=2*r;var n,a=!0;for(n=0;n<t.numDims;n++)if(I[n]!==g[n]){a=!1;break}return t.minValues=I,t.maxValues=g,a},readSubArray:function(A,e,t,i){var r;if(t===Uint8Array)r=new Uint8Array(A,e,i);else{var I=new ArrayBuffer(i);new Uint8Array(I).set(new Uint8Array(A,e,i)),r=new t(I)}return r},readMask:function(A,e){var t,i,r=e.ptr,I=e.headerInfo,g=I.width*I.height,n=I.numValidPixel,a=new DataView(A,r,4),o={};if(o.numBytes=a.getUint32(0,!0),r+=4,(0===n||g===n)&&0!==o.numBytes)throw"invalid mask";if(0===n)t=new Uint8Array(Math.ceil(g/8)),o.bitset=t,i=new Uint8Array(g),e.pixels.resultMask=i,r+=o.numBytes;else if(o.numBytes>0){t=new Uint8Array(Math.ceil(g/8));var B=(a=new DataView(A,r,o.numBytes)).getInt16(0,!0),C=2,Q=0,E=0;do{if(B>0)for(;B--;)t[Q++]=a.getUint8(C++);else for(E=a.getUint8(C++),B=-B;B--;)t[Q++]=E;B=a.getInt16(C,!0),C+=2}while(C<o.numBytes);if(-32768!==B||Q<t.length)throw"Unexpected end of mask RLE encoding";i=new Uint8Array(g);var s=0,f=0;for(f=0;f<g;f++)7&f?(s=t[f>>3],s<<=7&f):s=t[f>>3],128&s&&(i[f]=1);e.pixels.resultMask=i,o.bitset=t,r+=o.numBytes}return e.ptr=r,e.mask=o,!0},readDataOneSweep:function(A,e,t,i){var r,I=e.ptr,g=e.headerInfo,n=g.numDims,a=g.width*g.height,o=g.imageType,B=g.numValidPixel*Q.getDataTypeSize(o)*n,C=e.pixels.resultMask;if(t===Uint8Array)r=new Uint8Array(A,I,B);else{var E=new ArrayBuffer(B);new Uint8Array(E).set(new Uint8Array(A,I,B)),r=new t(E)}if(r.length===a*n)e.pixels.resultPixels=i?Q.swapDimensionOrder(r,a,n,t,!0):r;else{e.pixels.resultPixels=new t(a*n);var s=0,f=0,c=0,h=0;if(n>1){if(i){for(f=0;f<a;f++)if(C[f])for(h=f,c=0;c<n;c++,h+=a)e.pixels.resultPixels[h]=r[s++]}else for(f=0;f<a;f++)if(C[f])for(h=f*n,c=0;c<n;c++)e.pixels.resultPixels[h+c]=r[s++]}else for(f=0;f<a;f++)C[f]&&(e.pixels.resultPixels[f]=r[s++])}return I+=B,e.ptr=I,!0},readHuffmanTree:function(A,e){var t=this.HUFFMAN_LUT_BITS_MAX,i=new DataView(A,e.ptr,16);if(e.ptr+=16,i.getInt32(0,!0)<2)throw"unsupported Huffman version";var r=i.getInt32(4,!0),I=i.getInt32(8,!0),g=i.getInt32(12,!0);if(I>=g)return!1;var n=new Uint32Array(g-I);Q.decodeBits(A,e,n);var a,o,B,C,s=[];for(a=I;a<g;a++)s[o=a-(a<r?0:r)]={first:n[a-I],second:null};var f=A.byteLength-e.ptr,c=Math.ceil(f/4),h=new ArrayBuffer(4*c);new Uint8Array(h).set(new Uint8Array(A,e.ptr,f));var l,u=new Uint32Array(h),w=0,d=0;for(l=u[0],a=I;a<g;a++)(C=s[o=a-(a<r?0:r)].first)>0&&(s[o].second=l<<w>>>32-C,32-w>=C?32===(w+=C)&&(w=0,l=u[++d]):(w+=C-32,l=u[++d],s[o].second|=l>>>32-w));var D=0,y=0,k=new E;for(a=0;a<s.length;a++)void 0!==s[a]&&(D=Math.max(D,s[a].first));y=D>=t?t:D;var p,m,G,F,S,v=[];for(a=I;a<g;a++)if((C=s[o=a-(a<r?0:r)].first)>0)if(p=[C,o],C<=y)for(m=s[o].second<<y-C,G=1<<y-C,B=0;B<G;B++)v[m|B]=p;else for(m=s[o].second,S=k,F=C-1;F>=0;F--)m>>>F&1?(S.right||(S.right=new E),S=S.right):(S.left||(S.left=new E),S=S.left),0!==F||S.val||(S.val=p[1]);return{decodeLut:v,numBitsLUTQick:y,numBitsLUT:D,tree:k,stuffedData:u,srcPtr:d,bitPos:w}},readHuffman:function(A,e,t,i){var r,I,g,n,a,o,B,C,E,s=e.headerInfo.numDims,f=e.headerInfo.height,c=e.headerInfo.width,h=c*f,l=this.readHuffmanTree(A,e),u=l.decodeLut,w=l.tree,d=l.stuffedData,D=l.srcPtr,y=l.bitPos,k=l.numBitsLUTQick,p=l.numBitsLUT,m=0===e.headerInfo.imageType?128:0,G=e.pixels.resultMask,F=0;y>0&&(D++,y=0);var S,v=d[D],R=1===e.encodeMode,U=new t(h*s),L=U;if(s<2||R){for(S=0;S<s;S++)if(s>1&&(L=new t(U.buffer,h*S,h),F=0),e.headerInfo.numValidPixel===c*f)for(C=0,o=0;o<f;o++)for(B=0;B<c;B++,C++){if(I=0,a=n=v<<y>>>32-k,32-y<k&&(a=n|=d[D+1]>>>64-y-k),u[a])I=u[a][1],y+=u[a][0];else for(a=n=v<<y>>>32-p,32-y<p&&(a=n|=d[D+1]>>>64-y-p),r=w,E=0;E<p;E++)if(!(r=n>>>p-E-1&1?r.right:r.left).left&&!r.right){I=r.val,y=y+E+1;break}y>=32&&(y-=32,v=d[++D]),g=I-m,R?(g+=B>0?F:o>0?L[C-c]:F,g&=255,L[C]=g,F=g):L[C]=g}else for(C=0,o=0;o<f;o++)for(B=0;B<c;B++,C++)if(G[C]){if(I=0,a=n=v<<y>>>32-k,32-y<k&&(a=n|=d[D+1]>>>64-y-k),u[a])I=u[a][1],y+=u[a][0];else for(a=n=v<<y>>>32-p,32-y<p&&(a=n|=d[D+1]>>>64-y-p),r=w,E=0;E<p;E++)if(!(r=n>>>p-E-1&1?r.right:r.left).left&&!r.right){I=r.val,y=y+E+1;break}y>=32&&(y-=32,v=d[++D]),g=I-m,R?(B>0&&G[C-1]?g+=F:o>0&&G[C-c]?g+=L[C-c]:g+=F,g&=255,L[C]=g,F=g):L[C]=g}}else for(C=0,o=0;o<f;o++)for(B=0;B<c;B++)if(C=o*c+B,!G||G[C])for(S=0;S<s;S++,C+=h){if(I=0,a=n=v<<y>>>32-k,32-y<k&&(a=n|=d[D+1]>>>64-y-k),u[a])I=u[a][1],y+=u[a][0];else for(a=n=v<<y>>>32-p,32-y<p&&(a=n|=d[D+1]>>>64-y-p),r=w,E=0;E<p;E++)if(!(r=n>>>p-E-1&1?r.right:r.left).left&&!r.right){I=r.val,y=y+E+1;break}y>=32&&(y-=32,v=d[++D]),g=I-m,L[C]=g}e.ptr=e.ptr+4*(D+1)+(y>0?4:0),e.pixels.resultPixels=U,s>1&&!i&&(e.pixels.resultPixels=Q.swapDimensionOrder(U,h,s,t))},decodeBits:function(A,e,t,i,r){var I=e.headerInfo,Q=I.fileVersion,E=0,s=A.byteLength-e.ptr>=5?5:A.byteLength-e.ptr,f=new DataView(A,e.ptr,s),c=f.getUint8(0);E++;var h=c>>6,l=0===h?4:3-h,u=(32&c)>0,w=31&c,d=0;if(1===l)d=f.getUint8(E),E++;else if(2===l)d=f.getUint16(E,!0),E+=2;else{if(4!==l)throw"Invalid valid pixel count type";d=f.getUint32(E,!0),E+=4}var D,y,k,p,m,G,F,S,v,R=2*I.maxZError,U=I.numDims>1?I.maxValues[r]:I.zMax;if(u){for(e.counter.lut++,S=f.getUint8(E),E++,p=Math.ceil((S-1)*w/8),m=Math.ceil(p/4),y=new ArrayBuffer(4*m),k=new Uint8Array(y),e.ptr+=E,k.set(new Uint8Array(A,e.ptr,p)),F=new Uint32Array(y),e.ptr+=p,v=0;S-1>>>v;)v++;p=Math.ceil(d*v/8),m=Math.ceil(p/4),y=new ArrayBuffer(4*m),(k=new Uint8Array(y)).set(new Uint8Array(A,e.ptr,p)),D=new Uint32Array(y),e.ptr+=p,G=Q>=3?o(F,w,S-1,i,R,U):n(F,w,S-1,i,R,U),Q>=3?a(D,t,v,d,G):g(D,t,v,d,G)}else e.counter.bitstuffer++,v=w,e.ptr+=E,v>0&&(p=Math.ceil(d*v/8),m=Math.ceil(p/4),y=new ArrayBuffer(4*m),(k=new Uint8Array(y)).set(new Uint8Array(A,e.ptr,p)),D=new Uint32Array(y),e.ptr+=p,Q>=3?null==i?C(D,t,v,d):a(D,t,v,d,!1,i,R,U):null==i?B(D,t,v,d):g(D,t,v,d,!1,i,R,U))},readTiles:function(A,e,t,i){var r=e.headerInfo,I=r.width,g=r.height,n=I*g,a=r.microBlockSize,o=r.imageType,B=Q.getDataTypeSize(o),C=Math.ceil(I/a),E=Math.ceil(g/a);e.pixels.numBlocksY=E,e.pixels.numBlocksX=C,e.pixels.ptr=0;var s,f,c,h,l,u,w,d,D,y,k=0,p=0,m=0,G=0,F=0,S=0,v=0,R=0,U=0,L=0,b=0,M=0,N=0,x=0,J=0,q=new t(a*a),Y=g%a||a,K=I%a||a,H=r.numDims,O=e.pixels.resultMask,P=e.pixels.resultPixels,T=r.fileVersion>=5?14:15,V=r.zMax;for(m=0;m<E;m++)for(F=m!==E-1?a:Y,G=0;G<C;G++)for(L=m*I*a+G*a,b=I-(S=G!==C-1?a:K),d=0;d<H;d++){if(H>1?(y=P,L=m*I*a+G*a,P=new t(e.pixels.resultPixels.buffer,n*d*B,n),V=r.maxValues[d]):y=null,v=A.byteLength-e.ptr,f={},J=0,R=(s=new DataView(A,e.ptr,Math.min(10,v))).getUint8(0),J++,D=r.fileVersion>=5?4&R:0,U=R>>6&255,(R>>2&T)!=(G*a>>3&T))throw"integrity issue";if(D&&0===d)throw"integrity issue";if((l=3&R)>3)throw e.ptr+=J,"Invalid block encoding ("+l+")";if(2!==l)if(0===l){if(D)throw"integrity issue";if(e.counter.uncompressed++,e.ptr+=J,M=(M=F*S*B)<(N=A.byteLength-e.ptr)?M:N,c=new ArrayBuffer(M%B==0?M:M+B-M%B),new Uint8Array(c).set(new Uint8Array(A,e.ptr,M)),h=new t(c),x=0,O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=h[x++]),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L++]=h[x++];L+=b}e.ptr+=x*B}else if(u=Q.getDataTypeUsed(D&&o<6?4:o,U),w=Q.getOnePixel(f,J,u,s),J+=Q.getDataTypeSize(u),3===l)if(e.ptr+=J,e.counter.constantoffset++,O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=D?Math.min(V,y[L]+w):w),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L]=D?Math.min(V,y[L]+w):w,L++;L+=b}else if(e.ptr+=J,Q.decodeBits(A,e,q,w,d),J=0,D)if(O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=q[J++]+y[L]),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L]=q[J++]+y[L],L++;L+=b}else if(O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=q[J++]),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L++]=q[J++];L+=b}else{if(D)if(O)for(k=0;k<F;k++)for(p=0;p<S;p++)O[L]&&(P[L]=y[L]),L++;else for(k=0;k<F;k++)for(p=0;p<S;p++)P[L]=y[L],L++;e.counter.constant++,e.ptr+=J}}H>1&&!i&&(e.pixels.resultPixels=Q.swapDimensionOrder(e.pixels.resultPixels,n,H,t))},formatFileInfo:function(A){return{fileIdentifierString:A.headerInfo.fileIdentifierString,fileVersion:A.headerInfo.fileVersion,imageType:A.headerInfo.imageType,height:A.headerInfo.height,width:A.headerInfo.width,numValidPixel:A.headerInfo.numValidPixel,microBlockSize:A.headerInfo.microBlockSize,blobSize:A.headerInfo.blobSize,maxZError:A.headerInfo.maxZError,pixelType:Q.getPixelType(A.headerInfo.imageType),eofOffset:A.eofOffset,mask:A.mask?{numBytes:A.mask.numBytes}:null,pixels:{numBlocksX:A.pixels.numBlocksX,numBlocksY:A.pixels.numBlocksY,maxValue:A.headerInfo.zMax,minValue:A.headerInfo.zMin,noDataValue:A.noDataValue}}},constructConstantSurface:function(A,e){var t=A.headerInfo.zMax,i=A.headerInfo.zMin,r=A.headerInfo.maxValues,I=A.headerInfo.numDims,g=A.headerInfo.height*A.headerInfo.width,n=0,a=0,o=0,B=A.pixels.resultMask,C=A.pixels.resultPixels;if(B)if(I>1){if(e)for(n=0;n<I;n++)for(o=n*g,t=r[n],a=0;a<g;a++)B[a]&&(C[o+a]=t);else for(a=0;a<g;a++)if(B[a])for(o=a*I,n=0;n<I;n++)C[o+I]=r[n]}else for(a=0;a<g;a++)B[a]&&(C[a]=t);else if(I>1&&i!==t)if(e)for(n=0;n<I;n++)for(o=n*g,t=r[n],a=0;a<g;a++)C[o+a]=t;else for(a=0;a<g;a++)for(o=a*I,n=0;n<I;n++)C[o+n]=r[n];else for(a=0;a<g*I;a++)C[a]=t},getDataTypeArray:function(A){var e;switch(A){case 0:e=Int8Array;break;case 1:e=Uint8Array;break;case 2:e=Int16Array;break;case 3:e=Uint16Array;break;case 4:e=Int32Array;break;case 5:e=Uint32Array;break;case 6:default:e=Float32Array;break;case 7:e=Float64Array}return e},getPixelType:function(A){var e;switch(A){case 0:e="S8";break;case 1:e="U8";break;case 2:e="S16";break;case 3:e="U16";break;case 4:e="S32";break;case 5:e="U32";break;case 6:default:e="F32";break;case 7:e="F64"}return e},isValidPixelValue:function(A,e){if(null==e)return!1;var t;switch(A){case 0:t=e>=-128&&e<=127;break;case 1:t=e>=0&&e<=255;break;case 2:t=e>=-32768&&e<=32767;break;case 3:t=e>=0&&e<=65536;break;case 4:t=e>=-2147483648&&e<=2147483647;break;case 5:t=e>=0&&e<=4294967296;break;case 6:t=e>=-34027999387901484e22&&e<=34027999387901484e22;break;case 7:t=e>=-17976931348623157e292&&e<=17976931348623157e292;break;default:t=!1}return t},getDataTypeSize:function(A){var e=0;switch(A){case 0:case 1:e=1;break;case 2:case 3:e=2;break;case 4:case 5:case 6:e=4;break;case 7:e=8;break;default:e=A}return e},getDataTypeUsed:function(A,e){var t=A;switch(A){case 2:case 4:t=A-e;break;case 3:case 5:t=A-2*e;break;case 6:t=0===e?A:1===e?2:1;break;case 7:t=0===e?A:A-2*e+1;break;default:t=A}return t},getOnePixel:function(A,e,t,i){var r=0;switch(t){case 0:r=i.getInt8(e);break;case 1:r=i.getUint8(e);break;case 2:r=i.getInt16(e,!0);break;case 3:r=i.getUint16(e,!0);break;case 4:r=i.getInt32(e,!0);break;case 5:r=i.getUInt32(e,!0);break;case 6:r=i.getFloat32(e,!0);break;case 7:r=i.getFloat64(e,!0);break;default:throw"the decoder does not understand this pixel type"}return r},swapDimensionOrder:function(A,e,t,i,r){var I=0,g=0,n=0,a=0,o=A;if(t>1)if(o=new i(e*t),r)for(I=0;I<e;I++)for(a=I,n=0;n<t;n++,a+=e)o[a]=A[g++];else for(I=0;I<e;I++)for(a=I,n=0;n<t;n++,a+=e)o[g++]=A[a];return o}},E=function(A,e,t){this.val=A,this.left=e,this.right=t},{decode:function(A,e){var t=(e=e||{}).noDataValue,i=0,r={};r.ptr=e.inputOffset||0,r.pixels={},Q.readHeaderInfo(A,r);var I=r.headerInfo,g=I.fileVersion,n=Q.getDataTypeArray(I.imageType);if(g>5)throw"unsupported lerc version 2."+g;Q.readMask(A,r),I.numValidPixel===I.width*I.height||r.pixels.resultMask||(r.pixels.resultMask=e.maskData);var a=I.width*I.height;r.pixels.resultPixels=new n(a*I.numDims),r.counter={onesweep:0,uncompressed:0,lut:0,bitstuffer:0,constant:0,constantoffset:0};var o,B=!e.returnPixelInterleavedDims;if(0!==I.numValidPixel)if(I.zMax===I.zMin)Q.constructConstantSurface(r,B);else if(g>=4&&Q.checkMinMaxRanges(A,r))Q.constructConstantSurface(r,B);else{var C=new DataView(A,r.ptr,2),E=C.getUint8(0);if(r.ptr++,E)Q.readDataOneSweep(A,r,n,B);else if(g>1&&I.imageType<=1&&Math.abs(I.maxZError-.5)<1e-5){var s=C.getUint8(1);if(r.ptr++,r.encodeMode=s,s>2||g<4&&s>1)throw"Invalid Huffman flag "+s;s?Q.readHuffman(A,r,n,B):Q.readTiles(A,r,n,B)}else Q.readTiles(A,r,n,B)}r.eofOffset=r.ptr,e.inputOffset?(o=r.headerInfo.blobSize+e.inputOffset-r.ptr,Math.abs(o)>=1&&(r.eofOffset=e.inputOffset+r.headerInfo.blobSize)):(o=r.headerInfo.blobSize-r.ptr,Math.abs(o)>=1&&(r.eofOffset=r.headerInfo.blobSize));var f={width:I.width,height:I.height,pixelData:r.pixels.resultPixels,minValue:I.zMin,maxValue:I.zMax,validPixelCount:I.numValidPixel,dimCount:I.numDims,dimStats:{minValues:I.minValues,maxValues:I.maxValues},maskData:r.pixels.resultMask};if(r.pixels.resultMask&&Q.isValidPixelValue(I.imageType,t)){var c=r.pixels.resultMask;for(i=0;i<a;i++)c[i]||(f.pixelData[i]=t);f.noDataValue=t}return r.noDataValue=t,e.returnFileInfo&&(f.fileInfo=Q.formatFileInfo(r)),f},getBandCount:function(A){for(var e=0,t=0,i={ptr:0,pixels:{}};t<A.byteLength-58;)Q.readHeaderInfo(A,i),t+=i.headerInfo.blobSize,e++,i.ptr=t;return e}}),l=(s=new ArrayBuffer(4),f=new Uint8Array(s),new Uint32Array(s)[0]=1,1===f[0]),u={decode:function(A,e){if(!l)throw"Big endian system is not supported.";var t,i,r=(e=e||{}).inputOffset||0,I=new Uint8Array(A,r,10),g=String.fromCharCode.apply(null,I);if("CntZImage"===g.trim())t=c,i=1;else{if("Lerc2"!==g.substring(0,5))throw"Unexpected file identifier string: "+g;t=h,i=2}for(var n,a,o,B,C,Q,E=0,s=A.byteLength-10,f=[],u={width:0,height:0,pixels:[],pixelType:e.pixelType,mask:null,statistics:[]},w=0;r<s;){var d=t.decode(A,{inputOffset:r,encodedMaskData:n,maskData:o,returnMask:0===E,returnEncodedMask:0===E,returnFileInfo:!0,returnPixelInterleavedDims:e.returnPixelInterleavedDims,pixelType:e.pixelType||null,noDataValue:e.noDataValue||null});r=d.fileInfo.eofOffset,o=d.maskData,0===E&&(n=d.encodedMaskData,u.width=d.width,u.height=d.height,u.dimCount=d.dimCount||1,u.pixelType=d.pixelType||d.fileInfo.pixelType,u.mask=o),i>1&&(o&&f.push(o),d.fileInfo.mask&&d.fileInfo.mask.numBytes>0&&w++),E++,u.pixels.push(d.pixelData),u.statistics.push({minValue:d.minValue,maxValue:d.maxValue,noDataValue:d.noDataValue,dimStats:d.dimStats})}if(i>1&&w>1){for(Q=u.width*u.height,u.bandMasks=f,(o=new Uint8Array(Q)).set(f[0]),B=1;B<f.length;B++)for(a=f[B],C=0;C<Q;C++)o[C]=o[C]&a[C];u.maskData=o}return u}};TA.exports?TA.exports=u:this.Lerc=u}();var ZA,jA,WA,zA=XA.exports,$A={env:{emscripten_notify_memory_growth:function(A){WA=new Uint8Array(jA.exports.memory.buffer)}}},Ae=function(){function A(){B(this,A)}return Q(A,[{key:"init",value:function(){return ZA||(ZA="undefined"!=typeof fetch?fetch("data:application/wasm;base64,"+ee).then((function(A){return A.arrayBuffer()})).then((function(A){return WebAssembly.instantiate(A,$A)})).then(this._init):WebAssembly.instantiate(Buffer.from(ee,"base64"),$A).then(this._init))}},{key:"_init",value:function(A){jA=A.instance,$A.env.emscripten_notify_memory_growth(0)}},{key:"decode",value:function(A){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!jA)throw new Error("ZSTDDecoder: Await .init() before decoding.");var t=A.byteLength,i=jA.exports.malloc(t);WA.set(A,i),e=e||Number(jA.exports.ZSTD_findDecompressedSize(i,t));var r=jA.exports.malloc(e),I=jA.exports.ZSTD_decompress(r,e,i,t),g=WA.slice(r,r+I);return jA.exports.free(i),jA.exports.free(r),g}}]),A}(),ee="AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ",te={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop",33550:"ModelPixelScale",33922:"ModelTiepoint",34264:"ModelTransformation",34735:"GeoKeyDirectory",34736:"GeoDoubleParams",34737:"GeoAsciiParams",50674:"LercParameters"},ie={};for(var re in te)te.hasOwnProperty(re)&&(ie[te[re]]=parseInt(re,10));ie.BitsPerSample,ie.ExtraSamples,ie.SampleFormat,ie.StripByteCounts,ie.StripOffsets,ie.StripRowCounts,ie.TileByteCounts,ie.TileOffsets,ie.SubIFDs;var Ie={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE",13:"IFD",16:"LONG8",17:"SLONG8",18:"IFD8"},ge={};for(var ne in Ie)Ie.hasOwnProperty(ne)&&(ge[Ie[ne]]=parseInt(ne,10));var ae=1,oe=0,Be=1,Ce=2,Qe={1024:"GTModelTypeGeoKey",1025:"GTRasterTypeGeoKey",1026:"GTCitationGeoKey",2048:"GeographicTypeGeoKey",2049:"GeogCitationGeoKey",2050:"GeogGeodeticDatumGeoKey",2051:"GeogPrimeMeridianGeoKey",2052:"GeogLinearUnitsGeoKey",2053:"GeogLinearUnitSizeGeoKey",2054:"GeogAngularUnitsGeoKey",2055:"GeogAngularUnitSizeGeoKey",2056:"GeogEllipsoidGeoKey",2057:"GeogSemiMajorAxisGeoKey",2058:"GeogSemiMinorAxisGeoKey",2059:"GeogInvFlatteningGeoKey",2060:"GeogAzimuthUnitsGeoKey",2061:"GeogPrimeMeridianLongGeoKey",2062:"GeogTOWGS84GeoKey",3072:"ProjectedCSTypeGeoKey",3073:"PCSCitationGeoKey",3074:"ProjectionGeoKey",3075:"ProjCoordTransGeoKey",3076:"ProjLinearUnitsGeoKey",3077:"ProjLinearUnitSizeGeoKey",3078:"ProjStdParallel1GeoKey",3079:"ProjStdParallel2GeoKey",3080:"ProjNatOriginLongGeoKey",3081:"ProjNatOriginLatGeoKey",3082:"ProjFalseEastingGeoKey",3083:"ProjFalseNorthingGeoKey",3084:"ProjFalseOriginLongGeoKey",3085:"ProjFalseOriginLatGeoKey",3086:"ProjFalseOriginEastingGeoKey",3087:"ProjFalseOriginNorthingGeoKey",3088:"ProjCenterLongGeoKey",3089:"ProjCenterLatGeoKey",3090:"ProjCenterEastingGeoKey",3091:"ProjCenterNorthingGeoKey",3092:"ProjScaleAtNatOriginGeoKey",3093:"ProjScaleAtCenterGeoKey",3094:"ProjAzimuthAngleGeoKey",3095:"ProjStraightVertPoleLongGeoKey",3096:"ProjRectifiedGridAngleGeoKey",4096:"VerticalCSTypeGeoKey",4097:"VerticalCitationGeoKey",4098:"VerticalDatumGeoKey",4099:"VerticalUnitsGeoKey"},Ee={};for(var se in Qe)Qe.hasOwnProperty(se)&&(Ee[Qe[se]]=parseInt(se,10));function fe(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var ce=new Ae,he=function(A){s(t,w);var e=fe(t);function t(A){var i;return B(this,t),(i=e.call(this)).planarConfiguration=void 0!==A.PlanarConfiguration?A.PlanarConfiguration:1,i.samplesPerPixel=void 0!==A.SamplesPerPixel?A.SamplesPerPixel:1,i.addCompression=A.LercParameters[ae],i}return Q(t,[{key:"decodeBlock",value:function(A){switch(this.addCompression){case oe:break;case Be:A=YA(new Uint8Array(A)).buffer;break;case Ce:A=ce.decode(new Uint8Array(A)).buffer;break;default:throw new Error("Unsupported LERC additional compression method identifier: ".concat(this.addCompression))}return zA.decode(A,{returnPixelInterleavedDims:1===this.planarConfiguration}).pixels[0].buffer}}]),t}(),le=Object.freeze({__proto__:null,zstd:ce,default:he});function ue(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var we=function(A){s(I,w);var t,i=ue(I);function I(){var A;if(B(this,I),A=i.call(this),"undefined"==typeof createImageBitmap)throw new Error("Cannot decode WebImage as `createImageBitmap` is not available");if("undefined"==typeof document&&"undefined"==typeof OffscreenCanvas)throw new Error("Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available");return A}return Q(I,[{key:"decode",value:(t=e(r.mark((function A(e,t){var i,I,g,n;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return i=new Blob([t]),A.next=3,createImageBitmap(i);case 3:return I=A.sent,"undefined"!=typeof document?((g=document.createElement("canvas")).width=I.width,g.height=I.height):g=new OffscreenCanvas(I.width,I.height),(n=g.getContext("2d")).drawImage(I,0,0),A.abrupt("return",n.getImageData(0,0,I.width,I.height).data.buffer);case 8:case"end":return A.stop()}}),A)}))),function(A,e){return t.apply(this,arguments)})}]),I}(),de=Object.freeze({__proto__:null,default:we});';
        return new Z3t(typeof Buffer != "undefined" ? "data:application/javascript;base64," + Buffer.from(n, "binary").toString("base64") : URL.createObjectURL(new Blob([n], { type: "application/javascript" })));
      }
      const $3t = Object.freeze(Object.defineProperty({ __proto__: null, create: K3t }, Symbol.toStringTag, { value: "Module" }));
      wt.Circle = AA, wt.Geometry = Yy, wt.GeometryCollection = yn, wt.LineString = be, wt.LinearRing = ao, wt.MultiLineString = ri, wt.MultiPoint = sr, wt.MultiPolygon = Ci, wt.OlCluster = BS, wt.OlConfig = FR, wt.OlDraw = DS, wt.OlEcharts = kR, wt.OlFeature = Ku, wt.OlHeatmap = IS, wt.OlImage = DC, wt.OlMap = Pw, wt.OlMeasure = RS, wt.OlOverlay = TS, wt.OlOverview = MS, wt.OlPath = NS, wt.OlRoute = lb, wt.OlTiff = ES, wt.OlTile = MC, wt.OlVector = qm, wt.OlWfs = mS, wt.OlWind = yS, wt.OlWms = _S, wt.Point = Oe, wt.Polygon = Sn, wt.SimpleGeometry = Ra, wt.configProviderContextKey = aQt, wt.createStyleFunction = BL, wt.default = oQt, wt.defaultOlMapConfig = mE, wt.enumTile = pW, wt.makeInstaller = AW, wt.utils = Qat, Object.defineProperties(wt, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    });
  }
});
export default require_v3_ol_map_umd();
/*! Bundled license information:

v3-ol-map/lib/v3-ol-map.umd.js:
  (*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
  
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
  
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** *)
  (*!
  * ZRender, a high performance 2d drawing library.
  *
  * Copyright (c) 2013, Baidu Inc.
  * All rights reserved.
  *
  * LICENSE
  * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
  *)
  (*!
  * author: sakitam-fdd <smilefdd@gmail.com> 
  * ol-echarts v4.0.1
  * build-time: 2024-5-30 0:2
  * LICENSE: MIT
  * (c) 2017-2024 https://sakitam-fdd.github.io/ol3Echarts
  *)
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
  (* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve *)
*/
//# sourceMappingURL=v3-ol-map.js.map
