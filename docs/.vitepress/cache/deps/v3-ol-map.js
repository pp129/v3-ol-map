import {
  init_vue_runtime_esm_bundler,
  vue_runtime_esm_bundler_exports
} from "./chunk-UO6EIPBV.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-MZRSZR5A.js";

// node_modules/.pnpm/v3-ol-map@0.0.35_echarts@5.5.1/node_modules/v3-ol-map/lib/v3-ol-map.umd.js
var require_v3_ol_map_umd = __commonJS({
  "node_modules/.pnpm/v3-ol-map@0.0.35_echarts@5.5.1/node_modules/v3-ol-map/lib/v3-ol-map.umd.js"(exports, module) {
    (function(_t, P) {
      typeof exports == "object" && typeof module != "undefined" ? P(exports, (init_vue_runtime_esm_bundler(), __toCommonJS(vue_runtime_esm_bundler_exports))) : typeof define == "function" && define.amd ? define(["exports", "vue"], P) : (_t = typeof globalThis != "undefined" ? globalThis : _t || self, P(_t["v3-ol-map"] = {}, _t.Vue));
    })(exports, function(_t, P) {
      "use strict";
      var F5t = Object.defineProperty, k5t = Object.defineProperties;
      var O5t = Object.getOwnPropertyDescriptors;
      var yx = Object.getOwnPropertySymbols;
      var CZ = Object.prototype.hasOwnProperty, SZ = Object.prototype.propertyIsEnumerable;
      var jn = Math.pow, MP = (_t2, P10, Te2) => P10 in _t2 ? F5t(_t2, P10, { enumerable: true, configurable: true, writable: true, value: Te2 }) : _t2[P10] = Te2, rt = (_t2, P10) => {
        for (var Te2 in P10 || (P10 = {})) CZ.call(P10, Te2) && MP(_t2, Te2, P10[Te2]);
        if (yx) for (var Te2 of yx(P10)) SZ.call(P10, Te2) && MP(_t2, Te2, P10[Te2]);
        return _t2;
      }, Qt = (_t2, P10) => k5t(_t2, O5t(P10));
      var om = (_t2, P10) => {
        var Te2 = {};
        for (var Dr2 in _t2) CZ.call(_t2, Dr2) && P10.indexOf(Dr2) < 0 && (Te2[Dr2] = _t2[Dr2]);
        if (_t2 != null && yx) for (var Dr2 of yx(_t2)) P10.indexOf(Dr2) < 0 && SZ.call(_t2, Dr2) && (Te2[Dr2] = _t2[Dr2]);
        return Te2;
      };
      var Jt = (_t2, P10, Te2) => MP(_t2, typeof P10 != "symbol" ? P10 + "" : P10, Te2);
      var Tt = (_t2, P10, Te2) => new Promise((Dr2, uo2) => {
        var Nu2 = (ho2) => {
          try {
            Rr2(Te2.next(ho2));
          } catch (pl2) {
            uo2(pl2);
          }
        }, mx2 = (ho2) => {
          try {
            Rr2(Te2.throw(ho2));
          } catch (pl2) {
            uo2(pl2);
          }
        }, Rr2 = (ho2) => ho2.done ? Dr2(ho2.value) : Promise.resolve(ho2.value).then(Nu2, mx2);
        Rr2((Te2 = Te2.apply(_t2, P10)).next());
      });
      class Te {
        constructor(t) {
          this.propagationStopped, this.defaultPrevented, this.type = t, this.target = null;
        }
        preventDefault() {
          this.defaultPrevented = true;
        }
        stopPropagation() {
          this.propagationStopped = true;
        }
      }
      function Dr(n) {
        n.stopPropagation();
      }
      const uo = { PROPERTYCHANGE: "propertychange" };
      class Nu {
        constructor() {
          this.disposed = false;
        }
        dispose() {
          this.disposed || (this.disposed = true, this.disposeInternal());
        }
        disposeInternal() {
        }
      }
      function mx(n, t, e) {
        let i, r;
        e = e || Rr;
        let a = 0, o = n.length, s = false;
        for (; a < o; ) i = a + (o - a >> 1), r = +e(n[i], t), r < 0 ? a = i + 1 : (o = i, s = !r);
        return s ? a : ~a;
      }
      function Rr(n, t) {
        return n > t ? 1 : n < t ? -1 : 0;
      }
      function ho(n, t) {
        return n < t ? 1 : n > t ? -1 : 0;
      }
      function pl(n, t, e) {
        if (n[0] <= t) return 0;
        const i = n.length;
        if (t <= n[i - 1]) return i - 1;
        if (typeof e == "function") {
          for (let r = 1; r < i; ++r) {
            const a = n[r];
            if (a === t) return r;
            if (a < t) return e(t, n[r - 1], a) > 0 ? r - 1 : r;
          }
          return i - 1;
        }
        if (e > 0) {
          for (let r = 1; r < i; ++r) if (n[r] < t) return r - 1;
          return i - 1;
        }
        if (e < 0) {
          for (let r = 1; r < i; ++r) if (n[r] <= t) return r;
          return i - 1;
        }
        for (let r = 1; r < i; ++r) {
          if (n[r] == t) return r;
          if (n[r] < t) return n[r - 1] - t < t - n[r] ? r - 1 : r;
        }
        return i - 1;
      }
      function BZ(n, t, e) {
        for (; t < e; ) {
          const i = n[t];
          n[t] = n[e], n[e] = i, ++t, --e;
        }
      }
      function Le(n, t) {
        const e = Array.isArray(t) ? t : [t], i = e.length;
        for (let r = 0; r < i; r++) n[n.length] = e[r];
      }
      function co(n, t) {
        const e = n.length;
        if (e !== t.length) return false;
        for (let i = 0; i < e; i++) if (n[i] !== t[i]) return false;
        return true;
      }
      function MZ(n, t, e) {
        const i = t || Rr;
        return n.every(function(r, a) {
          if (a === 0) return true;
          const o = i(n[a - 1], r);
          return !(o > 0 || o === 0);
        });
      }
      function Fu() {
        return true;
      }
      function ku() {
        return false;
      }
      function Vc() {
      }
      function RP(n) {
        let t, e, i;
        return function() {
          const r = Array.prototype.slice.call(arguments);
          return (!e || this !== i || !co(r, e)) && (i = this, e = r, t = n.apply(this, arguments)), t;
        };
      }
      function _x(n) {
        function t() {
          let e;
          try {
            e = n();
          } catch (i) {
            return Promise.reject(i);
          }
          return e instanceof Promise ? e : Promise.resolve(e);
        }
        return t();
      }
      function jc(n) {
        for (const t in n) delete n[t];
      }
      function vl(n) {
        let t;
        for (t in n) return false;
        return !t;
      }
      class qc extends Nu {
        constructor(t) {
          super(), this.eventTarget_ = t, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
        }
        addEventListener(t, e) {
          if (!t || !e) return;
          const i = this.listeners_ || (this.listeners_ = {}), r = i[t] || (i[t] = []);
          r.includes(e) || r.push(e);
        }
        dispatchEvent(t) {
          const e = typeof t == "string", i = e ? t : t.type, r = this.listeners_ && this.listeners_[i];
          if (!r) return;
          const a = e ? new Te(t) : t;
          a.target || (a.target = this.eventTarget_ || this);
          const o = this.dispatching_ || (this.dispatching_ = {}), s = this.pendingRemovals_ || (this.pendingRemovals_ = {});
          i in o || (o[i] = 0, s[i] = 0), ++o[i];
          let l;
          for (let u = 0, h = r.length; u < h; ++u) if ("handleEvent" in r[u] ? l = r[u].handleEvent(a) : l = r[u].call(this, a), l === false || a.propagationStopped) {
            l = false;
            break;
          }
          if (--o[i] === 0) {
            let u = s[i];
            for (delete s[i]; u--; ) this.removeEventListener(i, Vc);
            delete o[i];
          }
          return l;
        }
        disposeInternal() {
          this.listeners_ && jc(this.listeners_);
        }
        getListeners(t) {
          return this.listeners_ && this.listeners_[t] || void 0;
        }
        hasListener(t) {
          return this.listeners_ ? t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0 : false;
        }
        removeEventListener(t, e) {
          if (!this.listeners_) return;
          const i = this.listeners_[t];
          if (!i) return;
          const r = i.indexOf(e);
          r !== -1 && (this.pendingRemovals_ && t in this.pendingRemovals_ ? (i[r] = Vc, ++this.pendingRemovals_[t]) : (i.splice(r, 1), i.length === 0 && delete this.listeners_[t]));
        }
      }
      const Rt = { CHANGE: "change", ERROR: "error", BLUR: "blur", CLEAR: "clear", CONTEXTMENU: "contextmenu", CLICK: "click", DBLCLICK: "dblclick", DRAGENTER: "dragenter", DRAGOVER: "dragover", DROP: "drop", FOCUS: "focus", KEYDOWN: "keydown", KEYPRESS: "keypress", LOAD: "load", RESIZE: "resize", TOUCHMOVE: "touchmove", WHEEL: "wheel" };
      function Ut(n, t, e, i, r) {
        if (r) {
          const o = e;
          e = function() {
            n.removeEventListener(t, e), o.apply(i != null ? i : this, arguments);
          };
        } else i && i !== n && (e = e.bind(i));
        const a = { target: n, type: t, listener: e };
        return n.addEventListener(t, e), a;
      }
      function Kd(n, t, e, i) {
        return Ut(n, t, e, i, true);
      }
      function we(n) {
        n && n.target && (n.target.removeEventListener(n.type, n.listener), jc(n));
      }
      class Jd extends qc {
        constructor() {
          super(), this.on = this.onInternal, this.once = this.onceInternal, this.un = this.unInternal, this.revision_ = 0;
        }
        changed() {
          ++this.revision_, this.dispatchEvent(Rt.CHANGE);
        }
        getRevision() {
          return this.revision_;
        }
        onInternal(t, e) {
          if (Array.isArray(t)) {
            const i = t.length, r = new Array(i);
            for (let a = 0; a < i; ++a) r[a] = Ut(this, t[a], e);
            return r;
          }
          return Ut(this, t, e);
        }
        onceInternal(t, e) {
          let i;
          if (Array.isArray(t)) {
            const r = t.length;
            i = new Array(r);
            for (let a = 0; a < r; ++a) i[a] = Kd(this, t[a], e);
          } else i = Kd(this, t, e);
          return e.ol_key = i, i;
        }
        unInternal(t, e) {
          const i = e.ol_key;
          if (i) yl(i);
          else if (Array.isArray(t)) for (let r = 0, a = t.length; r < a; ++r) this.removeEventListener(t[r], e);
          else this.removeEventListener(t, e);
        }
      }
      Jd.prototype.on, Jd.prototype.once, Jd.prototype.un;
      function yl(n) {
        if (Array.isArray(n)) for (let t = 0, e = n.length; t < e; ++t) we(n[t]);
        else we(n);
      }
      function zt() {
        throw new Error("Unimplemented abstract method.");
      }
      let DZ = 0;
      function xt(n) {
        return n.ol_uid || (n.ol_uid = String(++DZ));
      }
      const RZ = "10.3.1";
      class LP extends Te {
        constructor(t, e, i) {
          super(t), this.key = e, this.oldValue = i;
        }
      }
      class Kr extends Jd {
        constructor(t) {
          super(), this.on, this.once, this.un, xt(this), this.values_ = null, t !== void 0 && this.setProperties(t);
        }
        get(t) {
          let e;
          return this.values_ && this.values_.hasOwnProperty(t) && (e = this.values_[t]), e;
        }
        getKeys() {
          return this.values_ && Object.keys(this.values_) || [];
        }
        getProperties() {
          return this.values_ && Object.assign({}, this.values_) || {};
        }
        getPropertiesInternal() {
          return this.values_;
        }
        hasProperties() {
          return !!this.values_;
        }
        notify(t, e) {
          let i;
          i = `change:${t}`, this.hasListener(i) && this.dispatchEvent(new LP(i, t, e)), i = uo.PROPERTYCHANGE, this.hasListener(i) && this.dispatchEvent(new LP(i, t, e));
        }
        addChangeListener(t, e) {
          this.addEventListener(`change:${t}`, e);
        }
        removeChangeListener(t, e) {
          this.removeEventListener(`change:${t}`, e);
        }
        set(t, e, i) {
          const r = this.values_ || (this.values_ = {});
          if (i) r[t] = e;
          else {
            const a = r[t];
            r[t] = e, a !== e && this.notify(t, a);
          }
        }
        setProperties(t, e) {
          for (const i in t) this.set(i, t[i], e);
        }
        applyProperties(t) {
          t.values_ && Object.assign(this.values_ || (this.values_ = {}), t.values_);
        }
        unset(t, e) {
          if (this.values_ && t in this.values_) {
            const i = this.values_[t];
            delete this.values_[t], vl(this.values_) && (this.values_ = null), e || this.notify(t, i);
          }
        }
      }
      const ii = { ADD: "add", REMOVE: "remove" }, PP = { LENGTH: "length" };
      class sm extends Te {
        constructor(t, e, i) {
          super(t), this.element = e, this.index = i;
        }
      }
      class lr extends Kr {
        constructor(t, e) {
          if (super(), this.on, this.once, this.un, e = e || {}, this.unique_ = !!e.unique, this.array_ = t || [], this.unique_) for (let i = 0, r = this.array_.length; i < r; ++i) this.assertUnique_(this.array_[i], i);
          this.updateLength_();
        }
        clear() {
          for (; this.getLength() > 0; ) this.pop();
        }
        extend(t) {
          for (let e = 0, i = t.length; e < i; ++e) this.push(t[e]);
          return this;
        }
        forEach(t) {
          const e = this.array_;
          for (let i = 0, r = e.length; i < r; ++i) t(e[i], i, e);
        }
        getArray() {
          return this.array_;
        }
        item(t) {
          return this.array_[t];
        }
        getLength() {
          return this.get(PP.LENGTH);
        }
        insertAt(t, e) {
          if (t < 0 || t > this.getLength()) throw new Error("Index out of bounds: " + t);
          this.unique_ && this.assertUnique_(e), this.array_.splice(t, 0, e), this.updateLength_(), this.dispatchEvent(new sm(ii.ADD, e, t));
        }
        pop() {
          return this.removeAt(this.getLength() - 1);
        }
        push(t) {
          this.unique_ && this.assertUnique_(t);
          const e = this.getLength();
          return this.insertAt(e, t), this.getLength();
        }
        remove(t) {
          const e = this.array_;
          for (let i = 0, r = e.length; i < r; ++i) if (e[i] === t) return this.removeAt(i);
        }
        removeAt(t) {
          if (t < 0 || t >= this.getLength()) return;
          const e = this.array_[t];
          return this.array_.splice(t, 1), this.updateLength_(), this.dispatchEvent(new sm(ii.REMOVE, e, t)), e;
        }
        setAt(t, e) {
          const i = this.getLength();
          if (t >= i) {
            this.insertAt(t, e);
            return;
          }
          if (t < 0) throw new Error("Index out of bounds: " + t);
          this.unique_ && this.assertUnique_(e, t);
          const r = this.array_[t];
          this.array_[t] = e, this.dispatchEvent(new sm(ii.REMOVE, r, t)), this.dispatchEvent(new sm(ii.ADD, e, t));
        }
        updateLength_() {
          this.set(PP.LENGTH, this.array_.length);
        }
        assertUnique_(t, e) {
          for (let i = 0, r = this.array_.length; i < r; ++i) if (this.array_[i] === t && i !== e) throw new Error("Duplicate item added to a unique collection");
        }
      }
      function ue(n, t) {
        if (!n) throw new Error(t);
      }
      class Ce extends Kr {
        constructor(t) {
          if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), t) if (typeof t.getSimplifiedGeometry == "function") {
            const e = t;
            this.setGeometry(e);
          } else {
            const e = t;
            this.setProperties(e);
          }
        }
        clone() {
          const t = new Ce(this.hasProperties() ? this.getProperties() : null);
          t.setGeometryName(this.getGeometryName());
          const e = this.getGeometry();
          e && t.setGeometry(e.clone());
          const i = this.getStyle();
          return i && t.setStyle(i), t;
        }
        getGeometry() {
          return this.get(this.geometryName_);
        }
        getId() {
          return this.id_;
        }
        getGeometryName() {
          return this.geometryName_;
        }
        getStyle() {
          return this.style_;
        }
        getStyleFunction() {
          return this.styleFunction_;
        }
        handleGeometryChange_() {
          this.changed();
        }
        handleGeometryChanged_() {
          this.geometryChangeKey_ && (we(this.geometryChangeKey_), this.geometryChangeKey_ = null);
          const t = this.getGeometry();
          t && (this.geometryChangeKey_ = Ut(t, Rt.CHANGE, this.handleGeometryChange_, this)), this.changed();
        }
        setGeometry(t) {
          this.set(this.geometryName_, t);
        }
        setStyle(t) {
          this.style_ = t, this.styleFunction_ = t ? NP(t) : void 0, this.changed();
        }
        setId(t) {
          this.id_ = t, this.changed();
        }
        setGeometryName(t) {
          this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = t, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
        }
      }
      function NP(n) {
        if (typeof n == "function") return n;
        let t;
        return Array.isArray(n) ? t = n : (ue(typeof n.getZIndex == "function", "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"), t = [n]), function() {
          return t;
        };
      }
      const Ex = new Array(6);
      function an() {
        return [1, 0, 0, 1, 0, 0];
      }
      function LZ(n) {
        return lm(n, 1, 0, 0, 1, 0, 0);
      }
      function Ou(n, t) {
        const e = n[0], i = n[1], r = n[2], a = n[3], o = n[4], s = n[5], l = t[0], u = t[1], h = t[2], c = t[3], f = t[4], g = t[5];
        return n[0] = e * l + r * u, n[1] = i * l + a * u, n[2] = e * h + r * c, n[3] = i * h + a * c, n[4] = e * f + r * g + o, n[5] = i * f + a * g + s, n;
      }
      function lm(n, t, e, i, r, a, o) {
        return n[0] = t, n[1] = e, n[2] = i, n[3] = r, n[4] = a, n[5] = o, n;
      }
      function FP(n, t) {
        return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n;
      }
      function nn(n, t) {
        const e = t[0], i = t[1];
        return t[0] = n[0] * e + n[2] * i + n[4], t[1] = n[1] * e + n[3] * i + n[5], t;
      }
      function PZ(n, t) {
        const e = Math.cos(t), i = Math.sin(t);
        return Ou(n, lm(Ex, e, i, -i, e, 0, 0));
      }
      function kP(n, t, e) {
        return Ou(n, lm(Ex, t, 0, 0, e, 0, 0));
      }
      function Ix(n, t, e) {
        return Ou(n, lm(Ex, 1, 0, 0, 1, t, e));
      }
      function Lr(n, t, e, i, r, a, o, s) {
        const l = Math.sin(a), u = Math.cos(a);
        return n[0] = i * u, n[1] = r * l, n[2] = -i * l, n[3] = r * u, n[4] = o * i * u - s * i * l + t, n[5] = o * r * l + s * r * u + e, n;
      }
      function ml(n, t) {
        const e = NZ(t);
        ue(e !== 0, "Transformation matrix cannot be inverted");
        const i = t[0], r = t[1], a = t[2], o = t[3], s = t[4], l = t[5];
        return n[0] = o / e, n[1] = -r / e, n[2] = -a / e, n[3] = i / e, n[4] = (a * l - o * s) / e, n[5] = -(i * l - r * s) / e, n;
      }
      function NZ(n) {
        return n[0] * n[3] - n[1] * n[2];
      }
      const OP = [1e6, 1e6, 1e6, 1e6, 2, 2];
      function QP(n) {
        return "matrix(" + n.map((e, i) => Math.round(e * OP[i]) / OP[i]).join(", ") + ")";
      }
      const ri = { UNKNOWN: 0, INTERSECTING: 1, ABOVE: 2, RIGHT: 4, BELOW: 8, LEFT: 16 };
      function Mn(n) {
        const t = ai();
        for (let e = 0, i = n.length; e < i; ++e) tA(t, n[e]);
        return t;
      }
      function FZ(n, t, e) {
        const i = Math.min.apply(null, n), r = Math.min.apply(null, t), a = Math.max.apply(null, n), o = Math.max.apply(null, t);
        return ta(i, r, a, o, e);
      }
      function fo(n, t, e) {
        return e ? (e[0] = n[0] - t, e[1] = n[1] - t, e[2] = n[2] + t, e[3] = n[3] + t, e) : [n[0] - t, n[1] - t, n[2] + t, n[3] + t];
      }
      function zP(n, t) {
        return t ? (t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t) : n.slice();
      }
      function Qu(n, t, e) {
        let i, r;
        return t < n[0] ? i = n[0] - t : n[2] < t ? i = t - n[2] : i = 0, e < n[1] ? r = n[1] - e : n[3] < e ? r = e - n[3] : r = 0, i * i + r * r;
      }
      function Jr(n, t) {
        return xx(n, t[0], t[1]);
      }
      function Pr(n, t) {
        return n[0] <= t[0] && t[2] <= n[2] && n[1] <= t[1] && t[3] <= n[3];
      }
      function xx(n, t, e) {
        return n[0] <= t && t <= n[2] && n[1] <= e && e <= n[3];
      }
      function Cx(n, t) {
        const e = n[0], i = n[1], r = n[2], a = n[3], o = t[0], s = t[1];
        let l = ri.UNKNOWN;
        return o < e ? l = l | ri.LEFT : o > r && (l = l | ri.RIGHT), s < i ? l = l | ri.BELOW : s > a && (l = l | ri.ABOVE), l === ri.UNKNOWN && (l = ri.INTERSECTING), l;
      }
      function ai() {
        return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      }
      function ta(n, t, e, i, r) {
        return r ? (r[0] = n, r[1] = t, r[2] = e, r[3] = i, r) : [n, t, e, i];
      }
      function Hc(n) {
        return ta(1 / 0, 1 / 0, -1 / 0, -1 / 0, n);
      }
      function Yc(n, t) {
        const e = n[0], i = n[1];
        return ta(e, i, e, i, t);
      }
      function Sx(n, t, e, i, r) {
        const a = Hc(r);
        return GP(a, n, t, e, i);
      }
      function As(n, t) {
        return n[0] == t[0] && n[2] == t[2] && n[1] == t[1] && n[3] == t[3];
      }
      function bx(n, t) {
        return t[0] < n[0] && (n[0] = t[0]), t[2] > n[2] && (n[2] = t[2]), t[1] < n[1] && (n[1] = t[1]), t[3] > n[3] && (n[3] = t[3]), n;
      }
      function tA(n, t) {
        t[0] < n[0] && (n[0] = t[0]), t[0] > n[2] && (n[2] = t[0]), t[1] < n[1] && (n[1] = t[1]), t[1] > n[3] && (n[3] = t[1]);
      }
      function GP(n, t, e, i, r) {
        for (; e < i; e += r) kZ(n, t[e], t[e + 1]);
        return n;
      }
      function kZ(n, t, e) {
        n[0] = Math.min(n[0], t), n[1] = Math.min(n[1], e), n[2] = Math.max(n[2], t), n[3] = Math.max(n[3], e);
      }
      function Tx(n, t) {
        let e;
        return e = t(Wc(n)), e || (e = t(Xc(n)), e) || (e = t(_l(n)), e) || (e = t(ur(n)), e) ? e : false;
      }
      function eA(n) {
        let t = 0;
        return ps(n) || (t = he(n) * dn(n)), t;
      }
      function Wc(n) {
        return [n[0], n[1]];
      }
      function Xc(n) {
        return [n[2], n[1]];
      }
      function Nr(n) {
        return [(n[0] + n[2]) / 2, (n[1] + n[3]) / 2];
      }
      function OZ(n, t) {
        let e;
        if (t === "bottom-left") e = Wc(n);
        else if (t === "bottom-right") e = Xc(n);
        else if (t === "top-left") e = ur(n);
        else if (t === "top-right") e = _l(n);
        else throw new Error("Invalid corner");
        return e;
      }
      function nA(n, t, e, i, r) {
        const [a, o, s, l, u, h, c, f] = QZ(n, t, e, i);
        return ta(Math.min(a, s, u, c), Math.min(o, l, h, f), Math.max(a, s, u, c), Math.max(o, l, h, f), r);
      }
      function QZ(n, t, e, i) {
        const r = t * i[0] / 2, a = t * i[1] / 2, o = Math.cos(e), s = Math.sin(e), l = r * o, u = r * s, h = a * o, c = a * s, f = n[0], g = n[1];
        return [f - l + c, g - u - h, f - l - c, g - u + h, f + l - c, g + u + h, f + l + c, g + u - h, f - l + c, g - u - h];
      }
      function dn(n) {
        return n[3] - n[1];
      }
      function oi(n, t, e) {
        const i = e || ai();
        return Ai(n, t) ? (n[0] > t[0] ? i[0] = n[0] : i[0] = t[0], n[1] > t[1] ? i[1] = n[1] : i[1] = t[1], n[2] < t[2] ? i[2] = n[2] : i[2] = t[2], n[3] < t[3] ? i[3] = n[3] : i[3] = t[3]) : Hc(i), i;
      }
      function ur(n) {
        return [n[0], n[3]];
      }
      function _l(n) {
        return [n[2], n[3]];
      }
      function he(n) {
        return n[2] - n[0];
      }
      function Ai(n, t) {
        return n[0] <= t[2] && n[2] >= t[0] && n[1] <= t[3] && n[3] >= t[1];
      }
      function ps(n) {
        return n[2] < n[0] || n[3] < n[1];
      }
      function zZ(n, t) {
        return t ? (t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t) : n;
      }
      function GZ(n, t) {
        const e = (n[2] - n[0]) / 2 * (t - 1), i = (n[3] - n[1]) / 2 * (t - 1);
        n[0] -= e, n[2] += e, n[1] -= i, n[3] += i;
      }
      function UZ(n, t, e) {
        let i = false;
        const r = Cx(n, t), a = Cx(n, e);
        if (r === ri.INTERSECTING || a === ri.INTERSECTING) i = true;
        else {
          const o = n[0], s = n[1], l = n[2], u = n[3], h = t[0], c = t[1], f = e[0], g = e[1], d = (g - c) / (f - h);
          let A, p;
          a & ri.ABOVE && !(r & ri.ABOVE) && (A = f - (g - u) / d, i = A >= o && A <= l), !i && a & ri.RIGHT && !(r & ri.RIGHT) && (p = g - (f - l) * d, i = p >= s && p <= u), !i && a & ri.BELOW && !(r & ri.BELOW) && (A = f - (g - s) / d, i = A >= o && A <= l), !i && a & ri.LEFT && !(r & ri.LEFT) && (p = g - (f - o) * d, i = p >= s && p <= u);
        }
        return i;
      }
      function UP(n, t, e, i) {
        if (ps(n)) return Hc(e);
        let r = [];
        r = [n[0], n[1], n[2], n[1], n[2], n[3], n[0], n[3]], t(r, r, 2);
        const a = [], o = [];
        for (let s = 0, l = r.length; s < l; s += 2) a.push(r[s]), o.push(r[s + 1]);
        return FZ(a, o, e);
      }
      function VP(n, t) {
        const e = t.getExtent(), i = Nr(n);
        if (t.canWrapX() && (i[0] < e[0] || i[0] >= e[2])) {
          const r = he(e), o = Math.floor((i[0] - e[0]) / r) * r;
          n[0] -= o, n[2] -= o;
        }
        return n;
      }
      function Bx(n, t, e) {
        if (t.canWrapX()) {
          const i = t.getExtent();
          if (!isFinite(n[0]) || !isFinite(n[2])) return [[i[0], n[1], i[2], n[3]]];
          VP(n, t);
          const r = he(i);
          if (he(n) > r && !e) return [[i[0], n[1], i[2], n[3]]];
          if (n[0] < i[0]) return [[n[0] + r, n[1], i[2], n[3]], [i[0], n[1], n[2], n[3]]];
          if (n[2] > i[2]) return [[n[0], n[1], i[2], n[3]], [i[0], n[1], n[2] - r, n[3]]];
        }
        return [n];
      }
      const VZ = { 9001: "m", 9002: "ft", 9003: "us-ft", 9101: "radians", 9102: "degrees" };
      function jP(n) {
        return VZ[n];
      }
      const $c = { radians: 6370997 / (2 * Math.PI), degrees: 2 * Math.PI * 6370997 / 360, ft: 0.3048, m: 1, "us-ft": 1200 / 3937 };
      let Oi = class {
        constructor(t) {
          this.code_ = t.code, this.units_ = t.units, this.extent_ = t.extent !== void 0 ? t.extent : null, this.worldExtent_ = t.worldExtent !== void 0 ? t.worldExtent : null, this.axisOrientation_ = t.axisOrientation !== void 0 ? t.axisOrientation : "enu", this.global_ = t.global !== void 0 ? t.global : false, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = t.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = t.metersPerUnit;
        }
        canWrapX() {
          return this.canWrapX_;
        }
        getCode() {
          return this.code_;
        }
        getExtent() {
          return this.extent_;
        }
        getUnits() {
          return this.units_;
        }
        getMetersPerUnit() {
          return this.metersPerUnit_ || $c[this.units_];
        }
        getWorldExtent() {
          return this.worldExtent_;
        }
        getAxisOrientation() {
          return this.axisOrientation_;
        }
        isGlobal() {
          return this.global_;
        }
        setGlobal(t) {
          this.global_ = t, this.canWrapX_ = !!(t && this.extent_);
        }
        getDefaultTileGrid() {
          return this.defaultTileGrid_;
        }
        setDefaultTileGrid(t) {
          this.defaultTileGrid_ = t;
        }
        setExtent(t) {
          this.extent_ = t, this.canWrapX_ = !!(this.global_ && t);
        }
        setWorldExtent(t) {
          this.worldExtent_ = t;
        }
        setGetPointResolution(t) {
          this.getPointResolutionFunc_ = t;
        }
        getPointResolutionFunc() {
          return this.getPointResolutionFunc_;
        }
      };
      const iA = 6378137, Zc = Math.PI * iA, jZ = [-Zc, -Zc, Zc, Zc], qZ = [-180, -85, 180, 85], um = iA * Math.log(Math.tan(Math.PI / 2));
      class Kc extends Oi {
        constructor(t) {
          super({ code: t, units: "m", extent: jZ, global: true, worldExtent: qZ, getPointResolution: function(e, i) {
            return e / Math.cosh(i[1] / iA);
          } });
        }
      }
      const hm = [new Kc("EPSG:3857"), new Kc("EPSG:102100"), new Kc("EPSG:102113"), new Kc("EPSG:900913"), new Kc("http://www.opengis.net/def/crs/EPSG/0/3857"), new Kc("http://www.opengis.net/gml/srs/epsg.xml#3857")];
      function HZ(n, t, e, i) {
        const r = n.length;
        e = e > 1 ? e : 2, i = i != null ? i : e, t === void 0 && (e > 2 ? t = n.slice() : t = new Array(r));
        for (let a = 0; a < r; a += i) {
          t[a] = Zc * n[a] / 180;
          let o = iA * Math.log(Math.tan(Math.PI * (+n[a + 1] + 90) / 360));
          o > um ? o = um : o < -um && (o = -um), t[a + 1] = o;
        }
        return t;
      }
      function YZ(n, t, e, i) {
        const r = n.length;
        e = e > 1 ? e : 2, i = i != null ? i : e, t === void 0 && (e > 2 ? t = n.slice() : t = new Array(r));
        for (let a = 0; a < r; a += i) t[a] = 180 * n[a] / Zc, t[a + 1] = 360 * Math.atan(Math.exp(n[a + 1] / iA)) / Math.PI - 90;
        return t;
      }
      const WZ = 6378137, qP = [-180, -90, 180, 90], XZ = Math.PI * WZ / 180;
      class zu extends Oi {
        constructor(t, e) {
          super({ code: t, units: "degrees", extent: qP, axisOrientation: e, global: true, metersPerUnit: XZ, worldExtent: qP });
        }
      }
      const cm = [new zu("CRS:84"), new zu("EPSG:4326", "neu"), new zu("urn:ogc:def:crs:OGC:1.3:CRS84"), new zu("urn:ogc:def:crs:OGC:2:84"), new zu("http://www.opengis.net/def/crs/OGC/1.3/CRS84"), new zu("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"), new zu("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")];
      let Mx = {};
      function fm(n) {
        return Mx[n] || Mx[n.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
      }
      function $Z(n, t) {
        Mx[n] = t;
      }
      let Jc = {};
      function Gu(n, t, e) {
        const i = n.getCode(), r = t.getCode();
        i in Jc || (Jc[i] = {}), Jc[i][r] = e;
      }
      function gm(n, t) {
        return n in Jc && t in Jc[n] ? Jc[n][t] : null;
      }
      function Ze(n, t, e) {
        return Math.min(Math.max(n, t), e);
      }
      function ZZ(n, t, e, i, r, a) {
        const o = r - e, s = a - i;
        if (o !== 0 || s !== 0) {
          const l = ((n - e) * o + (t - i) * s) / (o * o + s * s);
          l > 1 ? (e = r, i = a) : l > 0 && (e += o * l, i += s * l);
        }
        return vs(n, t, e, i);
      }
      function vs(n, t, e, i) {
        const r = e - n, a = i - t;
        return r * r + a * a;
      }
      function KZ(n) {
        const t = n.length;
        for (let i = 0; i < t; i++) {
          let r = i, a = Math.abs(n[i][i]);
          for (let s = i + 1; s < t; s++) {
            const l = Math.abs(n[s][i]);
            l > a && (a = l, r = s);
          }
          if (a === 0) return null;
          const o = n[r];
          n[r] = n[i], n[i] = o;
          for (let s = i + 1; s < t; s++) {
            const l = -n[s][i] / n[i][i];
            for (let u = i; u < t + 1; u++) i == u ? n[s][u] = 0 : n[s][u] += l * n[i][u];
          }
        }
        const e = new Array(t);
        for (let i = t - 1; i >= 0; i--) {
          e[i] = n[i][t] / n[i][i];
          for (let r = i - 1; r >= 0; r--) n[r][t] -= n[r][i] * e[i];
        }
        return e;
      }
      function HP(n) {
        return n * 180 / Math.PI;
      }
      function ea(n) {
        return n * Math.PI / 180;
      }
      function ys(n, t) {
        const e = n % t;
        return e * t < 0 ? e + t : e;
      }
      function Fr(n, t, e) {
        return n + e * (t - n);
      }
      function rA(n, t) {
        const e = Math.pow(10, t);
        return Math.round(n * e) / e;
      }
      function YP(n, t) {
        return Math.round(rA(n, t));
      }
      function tf(n, t) {
        return Math.floor(rA(n, t));
      }
      function El(n, t) {
        return Math.ceil(rA(n, t));
      }
      function Dx(n, t, e) {
        if (n >= t && n < e) return n;
        const i = e - t;
        return ((n - t) % i + i) % i + t;
      }
      function aA(n, t, e) {
        const i = e !== void 0 ? n.toFixed(e) : "" + n;
        let r = i.indexOf(".");
        return r = r === -1 ? i.length : r, r > t ? i : new Array(1 + t - r).join("0") + i;
      }
      function dm(n, t) {
        const e = ("" + n).split("."), i = ("" + t).split(".");
        for (let r = 0; r < Math.max(e.length, i.length); r++) {
          const a = parseInt(e[r] || "0", 10), o = parseInt(i[r] || "0", 10);
          if (a > o) return 1;
          if (o > a) return -1;
        }
        return 0;
      }
      function WP(n, t) {
        return n[0] += +t[0], n[1] += +t[1], n;
      }
      function JZ(n, t) {
        const e = t.getRadius(), i = t.getCenter(), r = i[0], a = i[1], o = n[0], s = n[1];
        let l = o - r;
        const u = s - a;
        l === 0 && u === 0 && (l = 1);
        const h = Math.sqrt(l * l + u * u), c = r + e * l / h, f = a + e * u / h;
        return [c, f];
      }
      function Rx(n, t) {
        const e = n[0], i = n[1], r = t[0], a = t[1], o = r[0], s = r[1], l = a[0], u = a[1], h = l - o, c = u - s, f = h === 0 && c === 0 ? 0 : (h * (e - o) + c * (i - s)) / (h * h + c * c || 0);
        let g, d;
        return f <= 0 ? (g = o, d = s) : f >= 1 ? (g = l, d = u) : (g = o + f * h, d = s + f * c), [g, d];
      }
      function tK(n) {
        return function(t) {
          return iK(t, n);
        };
      }
      function eK(n, t, e) {
        return n ? t.replace("{x}", n[0].toFixed(e)).replace("{y}", n[1].toFixed(e)) : "";
      }
      function Qi(n, t) {
        let e = true;
        for (let i = n.length - 1; i >= 0; --i) if (n[i] != t[i]) {
          e = false;
          break;
        }
        return e;
      }
      function Lx(n, t) {
        const e = Math.cos(t), i = Math.sin(t), r = n[0] * e - n[1] * i, a = n[1] * e + n[0] * i;
        return n[0] = r, n[1] = a, n;
      }
      function XP(n, t) {
        return n[0] *= t, n[1] *= t, n;
      }
      function go(n, t) {
        const e = n[0] - t[0], i = n[1] - t[1];
        return e * e + i * i;
      }
      function Am(n, t) {
        return Math.sqrt(go(n, t));
      }
      function nK(n, t) {
        return go(n, Rx(n, t));
      }
      function iK(n, t) {
        return eK(n, "{x}, {y}", t);
      }
      function Px(n, t) {
        if (t.canWrapX()) {
          const e = he(t.getExtent()), i = $P(n, t, e);
          i && (n[0] -= i * e);
        }
        return n;
      }
      function $P(n, t, e) {
        const i = t.getExtent();
        let r = 0;
        return t.canWrapX() && (n[0] < i[0] || n[0] > i[2]) && (e = e || he(i), r = Math.floor((n[0] - i[0]) / e)), r;
      }
      const Nx = 63710088e-1;
      function Fx(n, t, e) {
        e = e || Nx;
        const i = ea(n[1]), r = ea(t[1]), a = (r - i) / 2, o = ea(t[0] - n[0]) / 2, s = Math.sin(a) * Math.sin(a) + Math.sin(o) * Math.sin(o) * Math.cos(i) * Math.cos(r);
        return 2 * e * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s));
      }
      function kx(n, t) {
        let e = 0;
        for (let i = 0, r = n.length; i < r - 1; ++i) e += Fx(n[i], n[i + 1], t);
        return e;
      }
      function ZP(n, t) {
        t = t || {};
        const e = t.radius || Nx, i = t.projection || "EPSG:3857", r = n.getType();
        r !== "GeometryCollection" && (n = n.clone().transform(i, "EPSG:4326"));
        let a = 0, o, s, l, u, h, c;
        switch (r) {
          case "Point":
          case "MultiPoint":
            break;
          case "LineString":
          case "LinearRing": {
            o = n.getCoordinates(), a = kx(o, e);
            break;
          }
          case "MultiLineString":
          case "Polygon": {
            for (o = n.getCoordinates(), l = 0, u = o.length; l < u; ++l) a += kx(o[l], e);
            break;
          }
          case "MultiPolygon": {
            for (o = n.getCoordinates(), l = 0, u = o.length; l < u; ++l) for (s = o[l], h = 0, c = s.length; h < c; ++h) a += kx(s[h], e);
            break;
          }
          case "GeometryCollection": {
            const f = n.getGeometries();
            for (l = 0, u = f.length; l < u; ++l) a += ZP(f[l], t);
            break;
          }
          default:
            throw new Error("Unsupported geometry type: " + r);
        }
        return a;
      }
      function pm(n, t) {
        let e = 0;
        const i = n.length;
        let r = n[i - 1][0], a = n[i - 1][1];
        for (let o = 0; o < i; o++) {
          const s = n[o][0], l = n[o][1];
          e += ea(s - r) * (2 + Math.sin(ea(a)) + Math.sin(ea(l))), r = s, a = l;
        }
        return e * t * t / 2;
      }
      function KP(n, t) {
        t = t || {};
        const e = t.radius || Nx, i = t.projection || "EPSG:3857", r = n.getType();
        r !== "GeometryCollection" && (n = n.clone().transform(i, "EPSG:4326"));
        let a = 0, o, s, l, u, h, c;
        switch (r) {
          case "Point":
          case "MultiPoint":
          case "LineString":
          case "MultiLineString":
          case "LinearRing":
            break;
          case "Polygon": {
            for (o = n.getCoordinates(), a = Math.abs(pm(o[0], e)), l = 1, u = o.length; l < u; ++l) a -= Math.abs(pm(o[l], e));
            break;
          }
          case "MultiPolygon": {
            for (o = n.getCoordinates(), l = 0, u = o.length; l < u; ++l) for (s = o[l], a += Math.abs(pm(s[0], e)), h = 1, c = s.length; h < c; ++h) a -= Math.abs(pm(s[h], e));
            break;
          }
          case "GeometryCollection": {
            const f = n.getGeometries();
            for (l = 0, u = f.length; l < u; ++l) a += KP(f[l], t);
            break;
          }
          default:
            throw new Error("Unsupported geometry type: " + r);
        }
        return a;
      }
      const vm = 0.9996, na = 669438e-8, ym = na * na, mm = ym * na, Uu = na / (1 - na), JP = Math.sqrt(1 - na), ef = (1 - JP) / (1 + JP), tN = ef * ef, Ox = tN * ef, Qx = Ox * ef, eN = Qx * ef, nN = 1 - na / 4 - 3 * ym / 64 - 5 * mm / 256, rK = 3 * na / 8 + 3 * ym / 32 + 45 * mm / 1024, aK = 15 * ym / 256 + 45 * mm / 1024, oK = 35 * mm / 3072, sK = 3 / 2 * ef - 27 / 32 * Ox + 269 / 512 * eN, lK = 21 / 16 * tN - 55 / 32 * Qx, uK = 151 / 96 * Ox - 417 / 128 * eN, hK = 1097 / 512 * Qx, _m = 6378137;
      function cK(n, t, e) {
        const i = n - 5e5, o = (e.north ? t : t - 1e7) / vm / (_m * nN), s = o + sK * Math.sin(2 * o) + lK * Math.sin(4 * o) + uK * Math.sin(6 * o) + hK * Math.sin(8 * o), l = Math.sin(s), u = l * l, h = Math.cos(s), c = l / h, f = c * c, g = f * f, d = 1 - na * u, A = Math.sqrt(1 - na * u), p = _m / A, v = (1 - na) / d, y = Uu * jn(h, 2), m = y * y, _ = i / (p * vm), I = _ * _, E = I * _, x = E * _, w = x * _, C = w * _, S = s - c / v * (I / 2 - x / 24 * (5 + 3 * f + 10 * y - 4 * m - 9 * Uu)) + C / 720 * (61 + 90 * f + 298 * y + 45 * g - 252 * Uu - 3 * m);
        let b = (_ - E / 6 * (1 + 2 * f + y) + w / 120 * (5 - 2 * y + 28 * f - 3 * m + 8 * Uu + 24 * g)) / h;
        return b = Dx(b + ea(aN(e.number)), -Math.PI, Math.PI), [HP(b), HP(S)];
      }
      const iN = -80, rN = 84, fK = -180, gK = 180;
      function dK(n, t, e) {
        n = Dx(n, fK, gK), t < iN ? t = iN : t > rN && (t = rN);
        const i = ea(t), r = Math.sin(i), a = Math.cos(i), o = r / a, s = o * o, l = s * s, u = ea(n), h = aN(e.number), c = ea(h), f = _m / Math.sqrt(1 - na * jn(r, 2)), g = Uu * jn(a, 2), d = a * Dx(u - c, -Math.PI, Math.PI), A = d * d, p = A * d, v = p * d, y = v * d, m = y * d, _ = _m * (nN * i - rK * Math.sin(2 * i) + aK * Math.sin(4 * i) - oK * Math.sin(6 * i)), I = vm * f * (d + p / 6 * (1 - s + g) + y / 120 * (5 - 18 * s + l + 72 * g - 58 * Uu)) + 5e5;
        let E = vm * (_ + f * o * (A / 2 + v / 24 * (5 - s + 9 * g + 4 * jn(g, 2)) + m / 720 * (61 - 58 * s + l + 600 * g - 330 * Uu)));
        return e.north || (E += 1e7), [I, E];
      }
      function aN(n) {
        return (n - 1) * 6 - 180 + 3;
      }
      const AK = [/^EPSG:(\d+)$/, /^urn:ogc:def:crs:EPSG::(\d+)$/, /^http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/0\/(\d+)$/];
      function oN(n) {
        let t = 0;
        for (const r of AK) {
          const a = n.match(r);
          if (a) {
            t = parseInt(a[1]);
            break;
          }
        }
        if (!t) return null;
        let e = 0, i = false;
        return t > 32700 && t < 32761 ? e = t - 32700 : t > 32600 && t < 32661 && (i = true, e = t - 32600), e ? { number: e, north: i } : null;
      }
      function sN(n, t) {
        return function(e, i, r, a) {
          const o = e.length;
          r = r > 1 ? r : 2, a = a != null ? a : r, i || (r > 2 ? i = e.slice() : i = new Array(o));
          for (let s = 0; s < o; s += a) {
            const l = e[s], u = e[s + 1], h = n(l, u, t);
            i[s] = h[0], i[s + 1] = h[1];
          }
          return i;
        };
      }
      function pK(n) {
        return oN(n) ? new Oi({ code: n, units: "m" }) : null;
      }
      function vK(n) {
        const t = oN(n.getCode());
        return t ? { forward: sN(dK, t), inverse: sN(cK, t) } : null;
      }
      function lN(...n) {
      }
      function uN(...n) {
      }
      const yK = [vK], mK = [pK];
      let zx = true;
      function hN(n) {
        zx = false;
      }
      function Gx(n, t) {
        if (t !== void 0) {
          for (let e = 0, i = n.length; e < i; ++e) t[e] = n[e];
          t = t;
        } else t = n.slice();
        return t;
      }
      function _K(n, t) {
        if (t !== void 0 && n !== t) {
          for (let e = 0, i = n.length; e < i; ++e) t[e] = n[e];
          n = t;
        }
        return n;
      }
      function nf(n) {
        $Z(n.getCode(), n), Gu(n, n, Gx);
      }
      function EK(n) {
        n.forEach(nf);
      }
      function qt(n) {
        if (typeof n != "string") return n;
        const t = fm(n);
        if (t) return t;
        for (const e of mK) {
          const i = e(n);
          if (i) return i;
        }
        return null;
      }
      function Em(n, t, e, i) {
        n = qt(n);
        let r;
        const a = n.getPointResolutionFunc();
        if (a) {
          if (r = a(t, e), i && i !== n.getUnits()) {
            const o = n.getMetersPerUnit();
            o && (r = r * o / $c[i]);
          }
        } else {
          const o = n.getUnits();
          if (o == "degrees" && !i || i == "degrees") r = t;
          else {
            const s = xm(n, qt("EPSG:4326"));
            if (!s && o !== "degrees") r = t * n.getMetersPerUnit();
            else {
              let u = [e[0] - t / 2, e[1], e[0] + t / 2, e[1], e[0], e[1] - t / 2, e[0], e[1] + t / 2];
              u = s(u, u, 2);
              const h = Fx(u.slice(0, 2), u.slice(2, 4)), c = Fx(u.slice(4, 6), u.slice(6, 8));
              r = (h + c) / 2;
            }
            const l = i ? $c[i] : n.getMetersPerUnit();
            l !== void 0 && (r /= l);
          }
        }
        return r;
      }
      function oA(n) {
        EK(n), n.forEach(function(t) {
          n.forEach(function(e) {
            t !== e && Gu(t, e, Gx);
          });
        });
      }
      function Vu(n, t, e, i) {
        n.forEach(function(r) {
          t.forEach(function(a) {
            Gu(r, a, e), Gu(a, r, i);
          });
        });
      }
      function Ux(n, t) {
        return n ? typeof n == "string" ? qt(n) : n : qt(t);
      }
      function Im(n) {
        return function(t, e, i, r) {
          const a = t.length;
          i = i !== void 0 ? i : 2, r = r != null ? r : i, e = e !== void 0 ? e : new Array(a);
          for (let o = 0; o < a; o += r) {
            const s = n(t.slice(o, o + i)), l = s.length;
            for (let u = 0, h = r; u < h; ++u) e[o + u] = u >= l ? t[o + u] : s[u];
          }
          return e;
        };
      }
      function ju(n, t, e, i) {
        const r = qt(n), a = qt(t);
        Gu(r, a, Im(e)), Gu(a, r, Im(i));
      }
      function cN(n, t) {
        return hN(), po(n, "EPSG:4326", t !== void 0 ? t : "EPSG:3857");
      }
      function fN(n, t) {
        const e = po(n, t !== void 0 ? t : "EPSG:3857", "EPSG:4326"), i = e[0];
        return (i < -180 || i > 180) && (e[0] = ys(i + 180, 360) - 180), e;
      }
      function Ao(n, t) {
        if (n === t) return true;
        const e = n.getUnits() === t.getUnits();
        return (n.getCode() === t.getCode() || xm(n, t) === Gx) && e;
      }
      function xm(n, t) {
        const e = n.getCode(), i = t.getCode();
        let r = gm(e, i);
        if (r) return r;
        let a = null, o = null;
        for (const l of yK) a || (a = l(n)), o || (o = l(t));
        if (!a && !o) return null;
        const s = "EPSG:4326";
        if (o) if (a) r = Vx(a.inverse, o.forward);
        else {
          const l = gm(e, s);
          l && (r = Vx(l, o.forward));
        }
        else {
          const l = gm(s, i);
          l && (r = Vx(a.inverse, l));
        }
        return r && (nf(n), nf(t), Gu(n, t, r)), r;
      }
      function Vx(n, t) {
        return function(e, i, r, a) {
          return i = n(e, i, r, a), t(i, i, r, a);
        };
      }
      function rf(n, t) {
        const e = qt(n), i = qt(t);
        return xm(e, i);
      }
      function po(n, t, e) {
        const i = rf(t, e);
        if (!i) {
          const r = qt(t).getCode(), a = qt(e).getCode();
          throw new Error(`No transform available between ${r} and ${a}`);
        }
        return i(n, void 0, n.length);
      }
      function IK(n, t, e, i) {
        const r = rf(t, e);
        return UP(n, r, void 0);
      }
      function vo(n, t) {
        return n;
      }
      function ke(n, t) {
        return zx && !Qi(n, [0, 0]) && n[0] >= -180 && n[0] <= 180 && n[1] >= -90 && n[1] <= 90 && (zx = false, lN("Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.")), n;
      }
      function sA(n, t) {
        return n;
      }
      function zi(n, t) {
        return n;
      }
      function gN(n, t, e) {
        return function(i) {
          let r, a;
          if (n.canWrapX()) {
            const o = n.getExtent(), s = he(o);
            i = i.slice(0), a = $P(i, n, s), a && (i[0] = i[0] - a * s), i[0] = Ze(i[0], o[0], o[2]), i[1] = Ze(i[1], o[1], o[3]), r = e(i);
          } else r = e(i);
          return a && t.canWrapX() && (r[0] += a * he(t.getExtent())), r;
        };
      }
      function xK() {
        oA(hm), oA(cm), Vu(cm, hm, HZ, YZ);
      }
      xK();
      function yo(n, t, e, i, r, a, o) {
        a = a || [], o = o || 2;
        let s = 0;
        for (let l = t; l < e; l += i) {
          const u = n[l], h = n[l + 1];
          a[s++] = r[0] * u + r[2] * h + r[4], a[s++] = r[1] * u + r[3] * h + r[5];
          for (let c = 2; c < o; c++) a[s++] = n[l + c];
        }
        return a && a.length != s && (a.length = s), a;
      }
      function jx(n, t, e, i, r, a, o) {
        o = o || [];
        const s = Math.cos(r), l = Math.sin(r), u = a[0], h = a[1];
        let c = 0;
        for (let f = t; f < e; f += i) {
          const g = n[f] - u, d = n[f + 1] - h;
          o[c++] = u + g * s - d * l, o[c++] = h + g * l + d * s;
          for (let A = f + 2; A < f + i; ++A) o[c++] = n[A];
        }
        return o && o.length != c && (o.length = c), o;
      }
      function wK(n, t, e, i, r, a, o, s) {
        s = s || [];
        const l = o[0], u = o[1];
        let h = 0;
        for (let c = t; c < e; c += i) {
          const f = n[c] - l, g = n[c + 1] - u;
          s[h++] = l + r * f, s[h++] = u + a * g;
          for (let d = c + 2; d < c + i; ++d) s[h++] = n[d];
        }
        return s && s.length != h && (s.length = h), s;
      }
      function CK(n, t, e, i, r, a, o) {
        o = o || [];
        let s = 0;
        for (let l = t; l < e; l += i) {
          o[s++] = n[l] + r, o[s++] = n[l + 1] + a;
          for (let u = l + 2; u < l + i; ++u) o[s++] = n[u];
        }
        return o && o.length != s && (o.length = s), o;
      }
      const dN = an();
      class wm extends Kr {
        constructor() {
          super(), this.extent_ = ai(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = RP((t, e, i) => {
            if (!i) return this.getSimplifiedGeometry(e);
            const r = this.clone();
            return r.applyTransform(i), r.getSimplifiedGeometry(e);
          });
        }
        simplifyTransformed(t, e) {
          return this.simplifyTransformedInternal(this.getRevision(), t, e);
        }
        clone() {
          return zt();
        }
        closestPointXY(t, e, i, r) {
          return zt();
        }
        containsXY(t, e) {
          const i = this.getClosestPoint([t, e]);
          return i[0] === t && i[1] === e;
        }
        getClosestPoint(t, e) {
          return e = e || [NaN, NaN], this.closestPointXY(t[0], t[1], e, 1 / 0), e;
        }
        intersectsCoordinate(t) {
          return this.containsXY(t[0], t[1]);
        }
        computeExtent(t) {
          return zt();
        }
        getExtent(t) {
          if (this.extentRevision_ != this.getRevision()) {
            const e = this.computeExtent(this.extent_);
            (isNaN(e[0]) || isNaN(e[1])) && Hc(e), this.extentRevision_ = this.getRevision();
          }
          return zZ(this.extent_, t);
        }
        rotate(t, e) {
          zt();
        }
        scale(t, e, i) {
          zt();
        }
        simplify(t) {
          return this.getSimplifiedGeometry(t * t);
        }
        getSimplifiedGeometry(t) {
          return zt();
        }
        getType() {
          return zt();
        }
        applyTransform(t) {
          zt();
        }
        intersectsExtent(t) {
          return zt();
        }
        translate(t, e) {
          zt();
        }
        transform(t, e) {
          const i = qt(t), r = i.getUnits() == "tile-pixels" ? function(a, o, s) {
            const l = i.getExtent(), u = i.getWorldExtent(), h = dn(u) / dn(l);
            Lr(dN, u[0], u[3], h, -h, 0, 0, 0);
            const c = yo(a, 0, a.length, s, dN, o), f = rf(i, e);
            return f ? f(c, c, s) : c;
          } : rf(i, e);
          return this.applyTransform(r), this;
        }
      }
      class Oa extends wm {
        constructor() {
          super(), this.layout = "XY", this.stride = 2, this.flatCoordinates;
        }
        computeExtent(t) {
          return Sx(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t);
        }
        getCoordinates() {
          return zt();
        }
        getFirstCoordinate() {
          return this.flatCoordinates.slice(0, this.stride);
        }
        getFlatCoordinates() {
          return this.flatCoordinates;
        }
        getLastCoordinate() {
          return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
        }
        getLayout() {
          return this.layout;
        }
        getSimplifiedGeometry(t) {
          if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t <= this.simplifiedGeometryMaxMinSquaredTolerance) return this;
          const e = this.getSimplifiedGeometryInternal(t);
          return e.getFlatCoordinates().length < this.flatCoordinates.length ? e : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
        }
        getSimplifiedGeometryInternal(t) {
          return this;
        }
        getStride() {
          return this.stride;
        }
        setFlatCoordinates(t, e) {
          this.stride = lA(t), this.layout = t, this.flatCoordinates = e;
        }
        setCoordinates(t, e) {
          zt();
        }
        setLayout(t, e, i) {
          let r;
          if (t) r = lA(t);
          else {
            for (let a = 0; a < i; ++a) {
              if (e.length === 0) {
                this.layout = "XY", this.stride = 2;
                return;
              }
              e = e[0];
            }
            r = e.length, t = qu(r);
          }
          this.layout = t, this.stride = r;
        }
        applyTransform(t) {
          this.flatCoordinates && (t(this.flatCoordinates, this.flatCoordinates, this.layout.startsWith("XYZ") ? 3 : 2, this.stride), this.changed());
        }
        rotate(t, e) {
          const i = this.getFlatCoordinates();
          if (i) {
            const r = this.getStride();
            jx(i, 0, i.length, r, t, e, i), this.changed();
          }
        }
        scale(t, e, i) {
          e === void 0 && (e = t), i || (i = Nr(this.getExtent()));
          const r = this.getFlatCoordinates();
          if (r) {
            const a = this.getStride();
            wK(r, 0, r.length, a, t, e, i, r), this.changed();
          }
        }
        translate(t, e) {
          const i = this.getFlatCoordinates();
          if (i) {
            const r = this.getStride();
            CK(i, 0, i.length, r, t, e, i), this.changed();
          }
        }
      }
      function qu(n) {
        let t;
        return n == 2 ? t = "XY" : n == 3 ? t = "XYZ" : n == 4 && (t = "XYZM"), t;
      }
      function lA(n) {
        let t;
        return n == "XY" ? t = 2 : n == "XYZ" || n == "XYM" ? t = 3 : n == "XYZM" && (t = 4), t;
      }
      function SK(n, t, e) {
        const i = n.getFlatCoordinates();
        if (!i) return null;
        const r = n.getStride();
        return yo(i, 0, i.length, r, t, e);
      }
      function AN(n, t, e, i, r, a, o) {
        const s = n[t], l = n[t + 1], u = n[e] - s, h = n[e + 1] - l;
        let c;
        if (u === 0 && h === 0) c = t;
        else {
          const f = ((r - s) * u + (a - l) * h) / (u * u + h * h);
          if (f > 1) c = e;
          else if (f > 0) {
            for (let g = 0; g < i; ++g) o[g] = Fr(n[t + g], n[e + g], f);
            o.length = i;
            return;
          } else c = t;
        }
        for (let f = 0; f < i; ++f) o[f] = n[c + f];
        o.length = i;
      }
      function qx(n, t, e, i, r) {
        let a = n[t], o = n[t + 1];
        for (t += i; t < e; t += i) {
          const s = n[t], l = n[t + 1], u = vs(a, o, s, l);
          u > r && (r = u), a = s, o = l;
        }
        return r;
      }
      function Hx(n, t, e, i, r) {
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a];
          r = qx(n, t, s, i, r), t = s;
        }
        return r;
      }
      function bK(n, t, e, i, r) {
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a];
          r = Hx(n, t, s, i, r), t = s[s.length - 1];
        }
        return r;
      }
      function Yx(n, t, e, i, r, a, o, s, l, u, h) {
        if (t == e) return u;
        let c, f;
        if (r === 0) {
          if (f = vs(o, s, n[t], n[t + 1]), f < u) {
            for (c = 0; c < i; ++c) l[c] = n[t + c];
            return l.length = i, f;
          }
          return u;
        }
        h = h || [NaN, NaN];
        let g = t + i;
        for (; g < e; ) if (AN(n, g - i, g, i, o, s, h), f = vs(o, s, h[0], h[1]), f < u) {
          for (u = f, c = 0; c < i; ++c) l[c] = h[c];
          l.length = i, g += i;
        } else g += i * Math.max((Math.sqrt(f) - Math.sqrt(u)) / r | 0, 1);
        if (a && (AN(n, e - i, t, i, o, s, h), f = vs(o, s, h[0], h[1]), f < u)) {
          for (u = f, c = 0; c < i; ++c) l[c] = h[c];
          l.length = i;
        }
        return u;
      }
      function Wx(n, t, e, i, r, a, o, s, l, u, h) {
        h = h || [NaN, NaN];
        for (let c = 0, f = e.length; c < f; ++c) {
          const g = e[c];
          u = Yx(n, t, g, i, r, a, o, s, l, u, h), t = g;
        }
        return u;
      }
      function TK(n, t, e, i, r, a, o, s, l, u, h) {
        h = h || [NaN, NaN];
        for (let c = 0, f = e.length; c < f; ++c) {
          const g = e[c];
          u = Wx(n, t, g, i, r, a, o, s, l, u, h), t = g[g.length - 1];
        }
        return u;
      }
      function pN(n, t, e, i) {
        for (let r = 0, a = e.length; r < a; ++r) n[t++] = e[r];
        return t;
      }
      function uA(n, t, e, i) {
        for (let r = 0, a = e.length; r < a; ++r) {
          const o = e[r];
          for (let s = 0; s < i; ++s) n[t++] = o[s];
        }
        return t;
      }
      function hA(n, t, e, i, r) {
        r = r || [];
        let a = 0;
        for (let o = 0, s = e.length; o < s; ++o) {
          const l = uA(n, t, e[o], i);
          r[a++] = l, t = l;
        }
        return r.length = a, r;
      }
      function vN(n, t, e, i, r) {
        r = r || [];
        let a = 0;
        for (let o = 0, s = e.length; o < s; ++o) {
          const l = hA(n, t, e[o], i, r[a]);
          l.length === 0 && (l[0] = t), r[a++] = l, t = l[l.length - 1];
        }
        return r.length = a, r;
      }
      function Cm(n, t, e, i, r, a, o) {
        const s = (e - t) / i;
        if (s < 3) {
          for (; t < e; t += i) a[o++] = n[t], a[o++] = n[t + 1];
          return o;
        }
        const l = new Array(s);
        l[0] = 1, l[s - 1] = 1;
        const u = [t, e - i];
        let h = 0;
        for (; u.length > 0; ) {
          const c = u.pop(), f = u.pop();
          let g = 0;
          const d = n[f], A = n[f + 1], p = n[c], v = n[c + 1];
          for (let y = f + i; y < c; y += i) {
            const m = n[y], _ = n[y + 1], I = ZZ(m, _, d, A, p, v);
            I > g && (h = y, g = I);
          }
          g > r && (l[(h - t) / i] = 1, f + i < h && u.push(f, h), h + i < c && u.push(h, c));
        }
        for (let c = 0; c < s; ++c) l[c] && (a[o++] = n[t + c * i], a[o++] = n[t + c * i + 1]);
        return o;
      }
      function yN(n, t, e, i, r, a, o, s) {
        for (let l = 0, u = e.length; l < u; ++l) {
          const h = e[l];
          o = Cm(n, t, h, i, r, a, o), s.push(o), t = h;
        }
        return o;
      }
      function Hu(n, t) {
        return t * Math.round(n / t);
      }
      function BK(n, t, e, i, r, a, o) {
        if (t == e) return o;
        let s = Hu(n[t], r), l = Hu(n[t + 1], r);
        t += i, a[o++] = s, a[o++] = l;
        let u, h;
        do
          if (u = Hu(n[t], r), h = Hu(n[t + 1], r), t += i, t == e) return a[o++] = u, a[o++] = h, o;
        while (u == s && h == l);
        for (; t < e; ) {
          const c = Hu(n[t], r), f = Hu(n[t + 1], r);
          if (t += i, c == u && f == h) continue;
          const g = u - s, d = h - l, A = c - s, p = f - l;
          if (g * p == d * A && (g < 0 && A < g || g == A || g > 0 && A > g) && (d < 0 && p < d || d == p || d > 0 && p > d)) {
            u = c, h = f;
            continue;
          }
          a[o++] = u, a[o++] = h, s = u, l = h, u = c, h = f;
        }
        return a[o++] = u, a[o++] = h, o;
      }
      function Xx(n, t, e, i, r, a, o, s) {
        for (let l = 0, u = e.length; l < u; ++l) {
          const h = e[l];
          o = BK(n, t, h, i, r, a, o), s.push(o), t = h;
        }
        return o;
      }
      function MK(n, t, e, i, r, a, o, s) {
        for (let l = 0, u = e.length; l < u; ++l) {
          const h = e[l], c = [];
          o = Xx(n, t, h, i, r, a, o, c), s.push(c), t = h[h.length - 1];
        }
        return o;
      }
      function ms(n, t, e, i, r) {
        r = r !== void 0 ? r : [];
        let a = 0;
        for (let o = t; o < e; o += i) r[a++] = n.slice(o, o + i);
        return r.length = a, r;
      }
      function cA(n, t, e, i, r) {
        r = r !== void 0 ? r : [];
        let a = 0;
        for (let o = 0, s = e.length; o < s; ++o) {
          const l = e[o];
          r[a++] = ms(n, t, l, i, r[a]), t = l;
        }
        return r.length = a, r;
      }
      function $x(n, t, e, i, r) {
        r = r !== void 0 ? r : [];
        let a = 0;
        for (let o = 0, s = e.length; o < s; ++o) {
          const l = e[o];
          r[a++] = l.length === 1 && l[0] === t ? [] : cA(n, t, l, i, r[a]), t = l[l.length - 1];
        }
        return r.length = a, r;
      }
      function mN(n, t, e, i) {
        let r = 0;
        const a = n[e - i], o = n[e - i + 1];
        let s = 0, l = 0;
        for (; t < e; t += i) {
          const u = n[t] - a, h = n[t + 1] - o;
          r += l * u - s * h, s = u, l = h;
        }
        return r / 2;
      }
      function _N(n, t, e, i) {
        let r = 0;
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a];
          r += mN(n, t, s, i), t = s;
        }
        return r;
      }
      function DK(n, t, e, i) {
        let r = 0;
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a];
          r += _N(n, t, s, i), t = s[s.length - 1];
        }
        return r;
      }
      class mo extends Oa {
        constructor(t, e) {
          super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, e !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(e, t) : this.setCoordinates(t, e);
        }
        clone() {
          return new mo(this.flatCoordinates.slice(), this.layout);
        }
        closestPointXY(t, e, i, r) {
          return r < Qu(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(qx(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Yx(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, t, e, i, r));
        }
        getArea() {
          return mN(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        }
        getCoordinates() {
          return ms(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        }
        getSimplifiedGeometryInternal(t) {
          const e = [];
          return e.length = Cm(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, 0), new mo(e, "XY");
        }
        getType() {
          return "LinearRing";
        }
        intersectsExtent(t) {
          return false;
        }
        setCoordinates(t, e) {
          this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = uA(this.flatCoordinates, 0, t, this.stride), this.changed();
        }
      }
      let Ge = class bZ extends Oa {
        constructor(t, e) {
          super(), this.setCoordinates(t, e);
        }
        clone() {
          const t = new bZ(this.flatCoordinates.slice(), this.layout);
          return t.applyProperties(this), t;
        }
        closestPointXY(t, e, i, r) {
          const a = this.flatCoordinates, o = vs(t, e, a[0], a[1]);
          if (o < r) {
            const s = this.stride;
            for (let l = 0; l < s; ++l) i[l] = a[l];
            return i.length = s, o;
          }
          return r;
        }
        getCoordinates() {
          return this.flatCoordinates.slice();
        }
        computeExtent(t) {
          return Yc(this.flatCoordinates, t);
        }
        getType() {
          return "Point";
        }
        intersectsExtent(t) {
          return xx(t, this.flatCoordinates[0], this.flatCoordinates[1]);
        }
        setCoordinates(t, e) {
          this.setLayout(e, t, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = pN(this.flatCoordinates, 0, t, this.stride), this.changed();
        }
      };
      function RK(n, t, e, i, r) {
        return !Tx(r, function(o) {
          return !Yu(n, t, e, i, o[0], o[1]);
        });
      }
      function Yu(n, t, e, i, r, a) {
        let o = 0, s = n[e - i], l = n[e - i + 1];
        for (; t < e; t += i) {
          const u = n[t], h = n[t + 1];
          l <= a ? h > a && (u - s) * (a - l) - (r - s) * (h - l) > 0 && o++ : h <= a && (u - s) * (a - l) - (r - s) * (h - l) < 0 && o--, s = u, l = h;
        }
        return o !== 0;
      }
      function Zx(n, t, e, i, r, a) {
        if (e.length === 0 || !Yu(n, t, e[0], i, r, a)) return false;
        for (let o = 1, s = e.length; o < s; ++o) if (Yu(n, e[o - 1], e[o], i, r, a)) return false;
        return true;
      }
      function LK(n, t, e, i, r, a) {
        if (e.length === 0) return false;
        for (let o = 0, s = e.length; o < s; ++o) {
          const l = e[o];
          if (Zx(n, t, l, i, r, a)) return true;
          t = l[l.length - 1];
        }
        return false;
      }
      function Kx(n, t, e, i, r, a, o) {
        let s, l, u, h, c, f, g;
        const d = r[a + 1], A = [];
        for (let y = 0, m = e.length; y < m; ++y) {
          const _ = e[y];
          for (h = n[_ - i], f = n[_ - i + 1], s = t; s < _; s += i) c = n[s], g = n[s + 1], (d <= f && g <= d || f <= d && d <= g) && (u = (d - f) / (g - f) * (c - h) + h, A.push(u)), h = c, f = g;
        }
        let p = NaN, v = -1 / 0;
        for (A.sort(Rr), h = A[0], s = 1, l = A.length; s < l; ++s) {
          c = A[s];
          const y = Math.abs(c - h);
          y > v && (u = (h + c) / 2, Zx(n, t, e, i, u, d) && (p = u, v = y)), h = c;
        }
        return isNaN(p) && (p = r[a]), o ? (o.push(p, d, v), o) : [p, d, v];
      }
      function EN(n, t, e, i, r) {
        let a = [];
        for (let o = 0, s = e.length; o < s; ++o) {
          const l = e[o];
          a = Kx(n, t, l, i, r, 2 * o, a), t = l[l.length - 1];
        }
        return a;
      }
      function IN(n, t, e, i, r) {
        let a;
        for (t += i; t < e; t += i) if (a = r(n.slice(t - i, t), n.slice(t, t + i)), a) return a;
        return false;
      }
      function Sm(n, t, e, i, r) {
        const a = GP(ai(), n, t, e, i);
        return Ai(r, a) ? Pr(r, a) || a[0] >= r[0] && a[2] <= r[2] || a[1] >= r[1] && a[3] <= r[3] ? true : IN(n, t, e, i, function(o, s) {
          return UZ(r, o, s);
        }) : false;
      }
      function PK(n, t, e, i, r) {
        for (let a = 0, o = e.length; a < o; ++a) {
          if (Sm(n, t, e[a], i, r)) return true;
          t = e[a];
        }
        return false;
      }
      function xN(n, t, e, i, r) {
        return !!(Sm(n, t, e, i, r) || Yu(n, t, e, i, r[0], r[1]) || Yu(n, t, e, i, r[0], r[3]) || Yu(n, t, e, i, r[2], r[1]) || Yu(n, t, e, i, r[2], r[3]));
      }
      function wN(n, t, e, i, r) {
        if (!xN(n, t, e[0], i, r)) return false;
        if (e.length === 1) return true;
        for (let a = 1, o = e.length; a < o; ++a) if (RK(n, e[a - 1], e[a], i, r) && !Sm(n, e[a - 1], e[a], i, r)) return false;
        return true;
      }
      function NK(n, t, e, i, r) {
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a];
          if (wN(n, t, s, i, r)) return true;
          t = s[s.length - 1];
        }
        return false;
      }
      function FK(n, t, e, i) {
        for (; t < e - i; ) {
          for (let r = 0; r < i; ++r) {
            const a = n[t + r];
            n[t + r] = n[e - i + r], n[e - i + r] = a;
          }
          t += i, e -= i;
        }
      }
      function bm(n, t, e, i) {
        let r = 0, a = n[e - i], o = n[e - i + 1];
        for (; t < e; t += i) {
          const s = n[t], l = n[t + 1];
          r += (s - a) * (l + o), a = s, o = l;
        }
        return r === 0 ? void 0 : r > 0;
      }
      function Jx(n, t, e, i, r) {
        r = r !== void 0 ? r : false;
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a], l = bm(n, t, s, i);
          if (a === 0) {
            if (r && l || !r && !l) return false;
          } else if (r && !l || !r && l) return false;
          t = s;
        }
        return true;
      }
      function CN(n, t, e, i, r) {
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a];
          if (!Jx(n, t, s, i, r)) return false;
          s.length && (t = s[s.length - 1]);
        }
        return true;
      }
      function Tm(n, t, e, i, r) {
        r = r !== void 0 ? r : false;
        for (let a = 0, o = e.length; a < o; ++a) {
          const s = e[a], l = bm(n, t, s, i);
          (a === 0 ? r && l || !r && !l : r && !l || !r && l) && FK(n, t, s, i), t = s;
        }
        return t;
      }
      function tw(n, t, e, i, r) {
        for (let a = 0, o = e.length; a < o; ++a) t = Tm(n, t, e[a], i, r);
        return t;
      }
      function ew(n, t) {
        const e = [];
        let i = 0, r = 0, a;
        for (let o = 0, s = t.length; o < s; ++o) {
          const l = t[o], u = bm(n, i, l, 2);
          if (a === void 0 && (a = u), u === a) e.push(t.slice(r, o + 1));
          else {
            if (e.length === 0) continue;
            e[e.length - 1].push(t[r]);
          }
          r = o + 1, i = l;
        }
        return e;
      }
      let Dn = class DP extends Oa {
        constructor(t, e, i) {
          super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, e !== void 0 && i ? (this.setFlatCoordinates(e, t), this.ends_ = i) : this.setCoordinates(t, e);
        }
        appendLinearRing(t) {
          this.flatCoordinates ? Le(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
        }
        clone() {
          const t = new DP(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
          return t.applyProperties(this), t;
        }
        closestPointXY(t, e, i, r) {
          return r < Qu(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(Hx(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Wx(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, t, e, i, r));
        }
        containsXY(t, e) {
          return Zx(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, e);
        }
        getArea() {
          return _N(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
        }
        getCoordinates(t) {
          let e;
          return t !== void 0 ? (e = this.getOrientedFlatCoordinates().slice(), Tm(e, 0, this.ends_, this.stride, t)) : e = this.flatCoordinates, cA(e, 0, this.ends_, this.stride);
        }
        getEnds() {
          return this.ends_;
        }
        getFlatInteriorPoint() {
          if (this.flatInteriorPointRevision_ != this.getRevision()) {
            const t = Nr(this.getExtent());
            this.flatInteriorPoint_ = Kx(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, 0), this.flatInteriorPointRevision_ = this.getRevision();
          }
          return this.flatInteriorPoint_;
        }
        getInteriorPoint() {
          return new Ge(this.getFlatInteriorPoint(), "XYM");
        }
        getLinearRingCount() {
          return this.ends_.length;
        }
        getLinearRing(t) {
          return t < 0 || this.ends_.length <= t ? null : new mo(this.flatCoordinates.slice(t === 0 ? 0 : this.ends_[t - 1], this.ends_[t]), this.layout);
        }
        getLinearRings() {
          const t = this.layout, e = this.flatCoordinates, i = this.ends_, r = [];
          let a = 0;
          for (let o = 0, s = i.length; o < s; ++o) {
            const l = i[o], u = new mo(e.slice(a, l), t);
            r.push(u), a = l;
          }
          return r;
        }
        getOrientedFlatCoordinates() {
          if (this.orientedRevision_ != this.getRevision()) {
            const t = this.flatCoordinates;
            Jx(t, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = Tm(this.orientedFlatCoordinates_, 0, this.ends_, this.stride)), this.orientedRevision_ = this.getRevision();
          }
          return this.orientedFlatCoordinates_;
        }
        getSimplifiedGeometryInternal(t) {
          const e = [], i = [];
          return e.length = Xx(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(t), e, 0, i), new DP(e, "XY", i);
        }
        getType() {
          return "Polygon";
        }
        intersectsExtent(t) {
          return wN(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t);
        }
        setCoordinates(t, e) {
          this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
          const i = hA(this.flatCoordinates, 0, t, this.stride, this.ends_);
          this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1], this.changed();
        }
      };
      function nw(n) {
        if (ps(n)) throw new Error("Cannot create polygon from empty extent");
        const t = n[0], e = n[1], i = n[2], r = n[3], a = [t, e, t, r, i, r, i, e, t, e];
        return new Dn(a, "XY", [a.length]);
      }
      function SN(n, t, e) {
        t = t || 32;
        const i = n.getStride(), r = n.getLayout(), a = n.getCenter(), o = i * (t + 1), s = new Array(o);
        for (let h = 0; h < o; h += i) {
          s[h] = 0, s[h + 1] = 0;
          for (let c = 2; c < i; c++) s[h + c] = a[c];
        }
        const l = [s.length], u = new Dn(s, r, l);
        return bN(u, a, n.getRadius(), e), u;
      }
      function bN(n, t, e, i) {
        const r = n.getFlatCoordinates(), a = n.getStride(), o = r.length / a - 1, s = i || 0;
        for (let l = 0; l <= o; ++l) {
          const u = l * a, h = s + ys(l, o) * 2 * Math.PI / o;
          r[u] = t[0] + e * Math.cos(h), r[u + 1] = t[1] + e * Math.sin(h);
        }
        n.changed();
      }
      const si = { PRERENDER: "prerender", POSTRENDER: "postrender", PRECOMPOSE: "precompose", POSTCOMPOSE: "postcompose", RENDERCOMPLETE: "rendercomplete" }, Mt = { IDLE: 0, LOADING: 1, LOADED: 2, ERROR: 3, EMPTY: 4 }, fA = { name: "rgb", min: [0, 0, 0], max: [255, 255, 255], channel: ["red", "green", "blue"], alias: ["RGB"] };
      var pi = { name: "xyz", min: [0, 0, 0], channel: ["X", "Y", "Z"], alias: ["XYZ", "ciexyz", "cie1931"] };
      pi.whitepoint = { 2: { A: [109.85, 100, 35.585], C: [98.074, 100, 118.232], D50: [96.422, 100, 82.521], D55: [95.682, 100, 92.149], D65: [95.045592705167, 100, 108.9057750759878], D75: [94.972, 100, 122.638], F2: [99.187, 100, 67.395], F7: [95.044, 100, 108.755], F11: [100.966, 100, 64.37], E: [100, 100, 100] }, 10: { A: [111.144, 100, 35.2], C: [97.285, 100, 116.145], D50: [96.72, 100, 81.427], D55: [95.799, 100, 90.926], D65: [94.811, 100, 107.304], D75: [94.416, 100, 120.641], F2: [103.28, 100, 69.026], F7: [95.792, 100, 107.687], F11: [103.866, 100, 65.627], E: [100, 100, 100] } }, pi.max = pi.whitepoint[2].D65, pi.rgb = function(n, t) {
        t = t || pi.whitepoint[2].E;
        var e = n[0] / t[0], i = n[1] / t[1], r = n[2] / t[2], a, o, s;
        return a = e * 3.240969941904521 + i * -1.537383177570093 + r * -0.498610760293, o = e * -0.96924363628087 + i * 1.87596750150772 + r * 0.041555057407175, s = e * 0.055630079696993 + i * -0.20397695888897 + r * 1.056971514242878, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a = a * 12.92, o = o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o = o * 12.92, s = s > 31308e-7 ? 1.055 * Math.pow(s, 1 / 2.4) - 0.055 : s = s * 12.92, a = Math.min(Math.max(0, a), 1), o = Math.min(Math.max(0, o), 1), s = Math.min(Math.max(0, s), 1), [a * 255, o * 255, s * 255];
      }, fA.xyz = function(n, t) {
        var e = n[0] / 255, i = n[1] / 255, r = n[2] / 255;
        e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92, i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92, r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        var a = e * 0.41239079926595 + i * 0.35758433938387 + r * 0.18048078840183, o = e * 0.21263900587151 + i * 0.71516867876775 + r * 0.072192315360733, s = e * 0.019330818715591 + i * 0.11919477979462 + r * 0.95053215224966;
        return t = t || pi.whitepoint[2].E, [a * t[0], o * t[1], s * t[2]];
      };
      const iw = { name: "luv", min: [0, -134, -140], max: [100, 224, 122], channel: ["lightness", "u", "v"], alias: ["LUV", "cieluv", "cie1976"], xyz: function(n, t, e) {
        var i, r, a, o, s, l, u, h, c, f, g, d, A;
        if (a = n[0], o = n[1], s = n[2], a === 0) return [0, 0, 0];
        var p = 0.0011070564598794539;
        return t = t || "D65", e = e || 2, c = pi.whitepoint[e][t][0], f = pi.whitepoint[e][t][1], g = pi.whitepoint[e][t][2], d = 4 * c / (c + 15 * f + 3 * g), A = 9 * f / (c + 15 * f + 3 * g), i = o / (13 * a) + d || 0, r = s / (13 * a) + A || 0, u = a > 8 ? f * Math.pow((a + 16) / 116, 3) : f * a * p, l = u * 9 * i / (4 * r) || 0, h = u * (12 - 3 * i - 20 * r) / (4 * r) || 0, [l, u, h];
      } };
      pi.luv = function(n, t, e) {
        var i, r, a, o, s, l, u, h, c, f, g, d, A, p = 0.008856451679035631, v = 903.2962962962961;
        t = t || "D65", e = e || 2, c = pi.whitepoint[e][t][0], f = pi.whitepoint[e][t][1], g = pi.whitepoint[e][t][2], d = 4 * c / (c + 15 * f + 3 * g), A = 9 * f / (c + 15 * f + 3 * g), l = n[0], u = n[1], h = n[2], i = 4 * l / (l + 15 * u + 3 * h) || 0, r = 9 * u / (l + 15 * u + 3 * h) || 0;
        var y = u / f;
        return a = y <= p ? v * y : 116 * Math.pow(y, 1 / 3) - 16, o = 13 * a * (i - d), s = 13 * a * (r - A), [a, o, s];
      };
      var TN = { name: "lchuv", channel: ["lightness", "chroma", "hue"], alias: ["LCHuv", "cielchuv"], min: [0, 0, 0], max: [100, 100, 360], luv: function(n) {
        var t = n[0], e = n[1], i = n[2], r, a, o;
        return o = i / 360 * 2 * Math.PI, r = e * Math.cos(o), a = e * Math.sin(o), [t, r, a];
      }, xyz: function(n) {
        return iw.xyz(TN.luv(n));
      } };
      iw.lchuv = function(n) {
        var t = n[0], e = n[1], i = n[2], r = Math.sqrt(e * e + i * i), a = Math.atan2(i, e), o = a * 360 / 2 / Math.PI;
        return o < 0 && (o += 360), [t, r, o];
      }, pi.lchuv = function(n) {
        return iw.lchuv(pi.luv(n));
      };
      const BN = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      var MN = { red: 0, orange: 60, yellow: 120, green: 180, blue: 240, purple: 300 };
      function kK(n) {
        var h, c;
        var t, e = [], i = 1, r;
        if (typeof n == "number") return { space: "rgb", values: [n >>> 16, (n & 65280) >>> 8, n & 255], alpha: 1 };
        if (typeof n == "number") return { space: "rgb", values: [n >>> 16, (n & 65280) >>> 8, n & 255], alpha: 1 };
        if (n = String(n).toLowerCase(), BN[n]) e = BN[n].slice(), r = "rgb";
        else if (n === "transparent") i = 0, r = "rgb", e = [0, 0, 0];
        else if (n[0] === "#") {
          var a = n.slice(1), o = a.length, s = o <= 4;
          i = 1, s ? (e = [parseInt(a[0] + a[0], 16), parseInt(a[1] + a[1], 16), parseInt(a[2] + a[2], 16)], o === 4 && (i = parseInt(a[3] + a[3], 16) / 255)) : (e = [parseInt(a[0] + a[1], 16), parseInt(a[2] + a[3], 16), parseInt(a[4] + a[5], 16)], o === 8 && (i = parseInt(a[6] + a[7], 16) / 255)), e[0] || (e[0] = 0), e[1] || (e[1] = 0), e[2] || (e[2] = 0), r = "rgb";
        } else if (t = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(n)) {
          var l = t[1];
          r = l.replace(/a$/, "");
          var u = r === "cmyk" ? 4 : r === "gray" ? 1 : 3;
          e = t[2].trim().split(/\s*[,\/]\s*|\s+/), r === "color" && (r = e.shift()), e = e.map(function(f, g) {
            if (f[f.length - 1] === "%") return f = parseFloat(f) / 100, g === 3 ? f : r === "rgb" ? f * 255 : r[0] === "h" || r[0] === "l" && !g ? f * 100 : r === "lab" ? f * 125 : r === "lch" ? g < 2 ? f * 150 : f * 360 : r[0] === "o" && !g ? f : r === "oklab" ? f * 0.4 : r === "oklch" ? g < 2 ? f * 0.4 : f * 360 : f;
            if (r[g] === "h" || g === 2 && r[r.length - 1] === "h") {
              if (MN[f] !== void 0) return MN[f];
              if (f.endsWith("deg")) return parseFloat(f);
              if (f.endsWith("turn")) return parseFloat(f) * 360;
              if (f.endsWith("grad")) return parseFloat(f) * 360 / 400;
              if (f.endsWith("rad")) return parseFloat(f) * 180 / Math.PI;
            }
            return f === "none" ? 0 : parseFloat(f);
          }), i = e.length > u ? e.pop() : 1;
        } else /[0-9](?:\s|\/|,)/.test(n) && (e = n.match(/([0-9]+)/g).map(function(f) {
          return parseFloat(f);
        }), r = ((c = (h = n.match(/([a-z])/ig)) == null ? void 0 : h.join("")) == null ? void 0 : c.toLowerCase()) || "rgb");
        return { space: r, values: e, alpha: i };
      }
      const rw = { name: "hsl", min: [0, 0, 0], max: [360, 100, 100], channel: ["hue", "saturation", "lightness"], alias: ["HSL"], rgb: function(n) {
        var t = n[0] / 360, e = n[1] / 100, i = n[2] / 100, r, a, o, s, l, u = 0;
        if (e === 0) return l = i * 255, [l, l, l];
        for (a = i < 0.5 ? i * (1 + e) : i + e - i * e, r = 2 * i - a, s = [0, 0, 0]; u < 3; ) o = t + 1 / 3 * -(u - 1), o < 0 ? o++ : o > 1 && o--, l = 6 * o < 1 ? r + (a - r) * 6 * o : 2 * o < 1 ? a : 3 * o < 2 ? r + (a - r) * (2 / 3 - o) * 6 : r, s[u++] = l * 255;
        return s;
      } };
      fA.hsl = function(n) {
        var t = n[0] / 255, e = n[1] / 255, i = n[2] / 255, r = Math.min(t, e, i), a = Math.max(t, e, i), o = a - r, s, l, u;
        return a === r ? s = 0 : t === a ? s = (e - i) / o : e === a ? s = 2 + (i - t) / o : i === a && (s = 4 + (t - e) / o), s = Math.min(s * 60, 360), s < 0 && (s += 360), u = (r + a) / 2, a === r ? l = 0 : u <= 0.5 ? l = o / (a + r) : l = o / (2 - a - r), [s, l * 100, u * 100];
      };
      function OK(n) {
        Array.isArray(n) && n.raw && (n = String.raw(...arguments)), n instanceof Number && (n = +n);
        var t, e = kK(n);
        if (!e.space) return [];
        const i = e.space[0] === "h" ? rw.min : fA.min, r = e.space[0] === "h" ? rw.max : fA.max;
        return t = Array(3), t[0] = Math.min(Math.max(e.values[0], i[0]), r[0]), t[1] = Math.min(Math.max(e.values[1], i[1]), r[1]), t[2] = Math.min(Math.max(e.values[2], i[2]), r[2]), e.space[0] === "h" && (t = rw.rgb(t)), t.push(Math.min(Math.max(e.alpha, 0), 1)), t;
      }
      const aw = [NaN, NaN, NaN, 0];
      function QK(n) {
        return typeof n == "string" ? n : lw(n);
      }
      const zK = 1024, gA = {};
      let ow = 0;
      function GK(n) {
        if (n.length === 4) return n;
        const t = n.slice();
        return t[3] = 1, t;
      }
      function DN(n) {
        const t = pi.lchuv(fA.xyz(n));
        return t[3] = n[3], t;
      }
      function UK(n) {
        const t = pi.rgb(TN.xyz(n));
        return t[3] = n[3], t;
      }
      function sw(n) {
        if (n === "none") return aw;
        if (gA.hasOwnProperty(n)) return gA[n];
        if (ow >= zK) {
          let e = 0;
          for (const i in gA) e++ & 3 || (delete gA[i], --ow);
        }
        const t = OK(n);
        if (t.length !== 4) throw new Error('failed to parse "' + n + '" as color');
        for (const e of t) if (isNaN(e)) throw new Error('failed to parse "' + n + '" as color');
        return RN(t), gA[n] = t, ++ow, t;
      }
      function ia(n) {
        return Array.isArray(n) ? n : sw(n);
      }
      function RN(n) {
        return n[0] = Ze(n[0] + 0.5 | 0, 0, 255), n[1] = Ze(n[1] + 0.5 | 0, 0, 255), n[2] = Ze(n[2] + 0.5 | 0, 0, 255), n[3] = Ze(n[3], 0, 1), n;
      }
      function lw(n) {
        let t = n[0];
        t != (t | 0) && (t = t + 0.5 | 0);
        let e = n[1];
        e != (e | 0) && (e = e + 0.5 | 0);
        let i = n[2];
        i != (i | 0) && (i = i + 0.5 | 0);
        const r = n[3] === void 0 ? 1 : Math.round(n[3] * 1e3) / 1e3;
        return "rgba(" + t + "," + e + "," + i + "," + r + ")";
      }
      const Il = typeof navigator != "undefined" && typeof navigator.userAgent != "undefined" ? navigator.userAgent.toLowerCase() : "", VK = Il.includes("firefox"), jK = Il.includes("safari") && !Il.includes("chrom") && (Il.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(Il)), qK = Il.includes("webkit") && !Il.includes("edge"), LN = Il.includes("macintosh"), PN = typeof devicePixelRatio != "undefined" ? devicePixelRatio : 1, uw = typeof WorkerGlobalScope != "undefined" && typeof OffscreenCanvas != "undefined" && self instanceof WorkerGlobalScope, hw = typeof Image != "undefined" && Image.prototype.decode, HK = typeof createImageBitmap == "function", NN = function() {
        let n = false;
        try {
          const t = Object.defineProperty({}, "passive", { get: function() {
            n = true;
          } });
          window.addEventListener("_", null, t), window.removeEventListener("_", null, t);
        } catch (t) {
        }
        return n;
      }();
      function In(n, t, e, i) {
        let r;
        return e && e.length ? r = e.shift() : uw ? r = new OffscreenCanvas(n || 300, t || 300) : r = document.createElement("canvas"), n && (r.width = n), t && (r.height = t), r.getContext("2d", i);
      }
      let cw;
      function Bm() {
        return cw || (cw = In(1, 1)), cw;
      }
      function Mm(n) {
        const t = n.canvas;
        t.width = 1, t.height = 1, n.clearRect(0, 0, 1, 1);
      }
      function YK(n) {
        let t = n.offsetWidth;
        const e = getComputedStyle(n);
        return t += parseInt(e.marginLeft, 10) + parseInt(e.marginRight, 10), t;
      }
      function WK(n) {
        let t = n.offsetHeight;
        const e = getComputedStyle(n);
        return t += parseInt(e.marginTop, 10) + parseInt(e.marginBottom, 10), t;
      }
      function af(n, t) {
        const e = t.parentNode;
        e && e.replaceChild(n, t);
      }
      function FN(n) {
        for (; n.lastChild; ) n.lastChild.remove();
      }
      function XK(n, t) {
        const e = n.childNodes;
        for (let i = 0; ; ++i) {
          const r = e[i], a = t[i];
          if (!r && !a) break;
          if (r !== a) {
            if (!r) {
              n.appendChild(a);
              continue;
            }
            if (!a) {
              n.removeChild(r), --i;
              continue;
            }
            n.insertBefore(a, r);
          }
        }
      }
      class kN extends qc {
        constructor(t, e, i, r) {
          super(), this.extent = t, this.pixelRatio_ = i, this.resolution = e, this.state = typeof r == "function" ? Mt.IDLE : r, this.image_ = null, this.loader = typeof r == "function" ? r : null;
        }
        changed() {
          this.dispatchEvent(Rt.CHANGE);
        }
        getExtent() {
          return this.extent;
        }
        getImage() {
          return this.image_;
        }
        getPixelRatio() {
          return this.pixelRatio_;
        }
        getResolution() {
          return this.resolution;
        }
        getState() {
          return this.state;
        }
        load() {
          if (this.state == Mt.IDLE && this.loader) {
            this.state = Mt.LOADING, this.changed();
            const t = this.getResolution(), e = Array.isArray(t) ? t[0] : t;
            _x(() => this.loader(this.getExtent(), e, this.getPixelRatio())).then((i) => {
              "image" in i && (this.image_ = i.image), "extent" in i && (this.extent = i.extent), "resolution" in i && (this.resolution = i.resolution), "pixelRatio" in i && (this.pixelRatio_ = i.pixelRatio), (i instanceof HTMLImageElement || i instanceof ImageBitmap || i instanceof HTMLCanvasElement || i instanceof HTMLVideoElement) && (this.image_ = i), this.state = Mt.LOADED;
            }).catch((i) => {
              this.state = Mt.ERROR;
            }).finally(() => this.changed());
          }
        }
        setImage(t) {
          this.image_ = t;
        }
        setResolution(t) {
          this.resolution = t;
        }
      }
      function $K(n, t, e) {
        const i = n;
        let r = true, a = false, o = false;
        const s = [Kd(i, Rt.LOAD, function() {
          o = true, a || t();
        })];
        return i.src && hw ? (a = true, i.decode().then(function() {
          r && t();
        }).catch(function(l) {
          r && (o ? t() : e());
        })) : s.push(Kd(i, Rt.ERROR, e)), function() {
          r = false, s.forEach(we);
        };
      }
      function ZK(n, t) {
        return new Promise((e, i) => {
          function r() {
            o(), e(n);
          }
          function a() {
            o(), i(new Error("Image load error"));
          }
          function o() {
            n.removeEventListener("load", r), n.removeEventListener("error", a);
          }
          n.addEventListener("load", r), n.addEventListener("error", a);
        });
      }
      function ON(n, t) {
        return t && (n.src = t), n.src && hw ? new Promise((e, i) => n.decode().then(() => e(n)).catch((r) => n.complete && n.width ? e(n) : i(r))) : ZK(n);
      }
      function QN(n, t) {
        return t && (n.src = t), n.src && hw && HK ? n.decode().then(() => createImageBitmap(n)).catch((e) => {
          if (n.complete && n.width) return n;
          throw e;
        }) : ON(n);
      }
      class KK {
        constructor() {
          this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 1024;
        }
        clear() {
          this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0;
        }
        canExpireCache() {
          return this.cacheSize_ > this.maxCacheSize_;
        }
        expire() {
          if (this.canExpireCache()) {
            let t = 0;
            for (const e in this.cache_) {
              const i = this.cache_[e];
              !(t++ & 3) && !i.hasListener() && (delete this.cache_[e], delete this.patternCache_[e], --this.cacheSize_);
            }
          }
        }
        get(t, e, i) {
          const r = fw(t, e, i);
          return r in this.cache_ ? this.cache_[r] : null;
        }
        getPattern(t, e, i) {
          const r = fw(t, e, i);
          return r in this.patternCache_ ? this.patternCache_[r] : null;
        }
        set(t, e, i, r, a) {
          const o = fw(t, e, i), s = o in this.cache_;
          this.cache_[o] = r, a && (r.getImageState() === Mt.IDLE && r.load(), r.getImageState() === Mt.LOADING ? r.ready().then(() => {
            this.patternCache_[o] = Bm().createPattern(r.getImage(1), "repeat");
          }) : this.patternCache_[o] = Bm().createPattern(r.getImage(1), "repeat")), s || ++this.cacheSize_;
        }
        setSize(t) {
          this.maxCacheSize_ = t, this.expire();
        }
      }
      function fw(n, t, e) {
        const i = e ? ia(e) : "null";
        return t + ":" + n + ":" + i;
      }
      const ra = new KK();
      let dA = null;
      class zN extends qc {
        constructor(t, e, i, r, a) {
          super(), this.hitDetectionImage_ = null, this.image_ = t, this.crossOrigin_ = i, this.canvas_ = {}, this.color_ = a, this.imageState_ = r === void 0 ? Mt.IDLE : r, this.size_ = t && t.width && t.height ? [t.width, t.height] : null, this.src_ = e, this.tainted_, this.ready_ = null;
        }
        initializeImage_() {
          this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
        }
        isTainted_() {
          if (this.tainted_ === void 0 && this.imageState_ === Mt.LOADED) {
            dA || (dA = In(1, 1, void 0, { willReadFrequently: true })), dA.drawImage(this.image_, 0, 0);
            try {
              dA.getImageData(0, 0, 1, 1), this.tainted_ = false;
            } catch (t) {
              dA = null, this.tainted_ = true;
            }
          }
          return this.tainted_ === true;
        }
        dispatchChangeEvent_() {
          this.dispatchEvent(Rt.CHANGE);
        }
        handleImageError_() {
          this.imageState_ = Mt.ERROR, this.dispatchChangeEvent_();
        }
        handleImageLoad_() {
          this.imageState_ = Mt.LOADED, this.size_ = [this.image_.width, this.image_.height], this.dispatchChangeEvent_();
        }
        getImage(t) {
          return this.image_ || this.initializeImage_(), this.replaceColor_(t), this.canvas_[t] ? this.canvas_[t] : this.image_;
        }
        getPixelRatio(t) {
          return this.replaceColor_(t), this.canvas_[t] ? t : 1;
        }
        getImageState() {
          return this.imageState_;
        }
        getHitDetectionImage() {
          if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_) if (this.isTainted_()) {
            const t = this.size_[0], e = this.size_[1], i = In(t, e);
            i.fillRect(0, 0, t, e), this.hitDetectionImage_ = i.canvas;
          } else this.hitDetectionImage_ = this.image_;
          return this.hitDetectionImage_;
        }
        getSize() {
          return this.size_;
        }
        getSrc() {
          return this.src_;
        }
        load() {
          if (this.imageState_ === Mt.IDLE) {
            this.image_ || this.initializeImage_(), this.imageState_ = Mt.LOADING;
            try {
              this.src_ !== void 0 && (this.image_.src = this.src_);
            } catch (t) {
              this.handleImageError_();
            }
            this.image_ instanceof HTMLImageElement && ON(this.image_, this.src_).then((t) => {
              this.image_ = t, this.handleImageLoad_();
            }).catch(this.handleImageError_.bind(this));
          }
        }
        replaceColor_(t) {
          if (!this.color_ || this.canvas_[t] || this.imageState_ !== Mt.LOADED) return;
          const e = this.image_, i = In(Math.ceil(e.width * t), Math.ceil(e.height * t)), r = i.canvas;
          i.scale(t, t), i.drawImage(e, 0, 0), i.globalCompositeOperation = "multiply", i.fillStyle = QK(this.color_), i.fillRect(0, 0, r.width / t, r.height / t), i.globalCompositeOperation = "destination-in", i.drawImage(e, 0, 0), this.canvas_[t] = r;
        }
        ready() {
          return this.ready_ || (this.ready_ = new Promise((t) => {
            if (this.imageState_ === Mt.LOADED || this.imageState_ === Mt.ERROR) t();
            else {
              const e = () => {
                (this.imageState_ === Mt.LOADED || this.imageState_ === Mt.ERROR) && (this.removeEventListener(Rt.CHANGE, e), t());
              };
              this.addEventListener(Rt.CHANGE, e);
            }
          })), this.ready_;
        }
      }
      function gw(n, t, e, i, r, a) {
        let o = t === void 0 ? void 0 : ra.get(t, e, r);
        return o || (o = new zN(n, n && "src" in n ? n.src || void 0 : t, e, i, r), ra.set(t, e, r, o, a)), a && o && !ra.getPattern(t, e, r) && ra.set(t, e, r, o, a), o;
      }
      class me {
        constructor(t) {
          t = t || {}, this.patternImage_ = null, this.color_ = null, t.color !== void 0 && this.setColor(t.color);
        }
        clone() {
          const t = this.getColor();
          return new me({ color: Array.isArray(t) ? t.slice() : t || void 0 });
        }
        getColor() {
          return this.color_;
        }
        setColor(t) {
          if (t !== null && typeof t == "object" && "src" in t) {
            const e = gw(null, t.src, "anonymous", void 0, t.offset ? null : t.color ? t.color : null, !(t.offset && t.size));
            e.ready().then(() => {
              this.patternImage_ = null;
            }), e.getImageState() === Mt.IDLE && e.load(), e.getImageState() === Mt.LOADING && (this.patternImage_ = e);
          }
          this.color_ = t;
        }
        getKey() {
          const t = this.getColor();
          return t ? t instanceof CanvasPattern || t instanceof CanvasGradient ? xt(t) : typeof t == "object" && "src" in t ? t.src + ":" + t.offset : ia(t).toString() : "";
        }
        loading() {
          return !!this.patternImage_;
        }
        ready() {
          return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
        }
      }
      function Dm(n, t, e, i, r, a, o) {
        let s, l;
        const u = (e - t) / i;
        if (u === 1) s = t;
        else if (u === 2) s = t, l = r;
        else if (u !== 0) {
          let h = n[t], c = n[t + 1], f = 0;
          const g = [0];
          for (let p = t + i; p < e; p += i) {
            const v = n[p], y = n[p + 1];
            f += Math.sqrt((v - h) * (v - h) + (y - c) * (y - c)), g.push(f), h = v, c = y;
          }
          const d = r * f, A = mx(g, d);
          A < 0 ? (l = (d - g[-A - 2]) / (g[-A - 1] - g[-A - 2]), s = t + (-A - 2) * i) : s = t + A * i;
        }
        o = o > 1 ? o : 2, a = a || new Array(o);
        for (let h = 0; h < o; ++h) a[h] = s === void 0 ? NaN : l === void 0 ? n[s + h] : Fr(n[s + h], n[s + i + h], l);
        return a;
      }
      function dw(n, t, e, i, r, a) {
        if (e == t) return null;
        let o;
        if (r < n[t + i - 1]) return a ? (o = n.slice(t, t + i), o[i - 1] = r, o) : null;
        if (n[e - 1] < r) return a ? (o = n.slice(e - i, e), o[i - 1] = r, o) : null;
        if (r == n[t + i - 1]) return n.slice(t, t + i);
        let s = t / i, l = e / i;
        for (; s < l; ) {
          const f = s + l >> 1;
          r < n[(f + 1) * i - 1] ? l = f : s = f + 1;
        }
        const u = n[s * i - 1];
        if (r == u) return n.slice((s - 1) * i, (s - 1) * i + i);
        const h = n[(s + 1) * i - 1], c = (r - u) / (h - u);
        o = [];
        for (let f = 0; f < i - 1; ++f) o.push(Fr(n[(s - 1) * i + f], n[s * i + f], c));
        return o.push(r), o;
      }
      function JK(n, t, e, i, r, a, o) {
        if (o) return dw(n, t, e[e.length - 1], i, r, a);
        let s;
        if (r < n[i - 1]) return a ? (s = n.slice(0, i), s[i - 1] = r, s) : null;
        if (n[n.length - 1] < r) return a ? (s = n.slice(n.length - i), s[i - 1] = r, s) : null;
        for (let l = 0, u = e.length; l < u; ++l) {
          const h = e[l];
          if (t != h) {
            if (r < n[t + i - 1]) return null;
            if (r <= n[h - 1]) return dw(n, t, h, i, r, false);
            t = h;
          }
        }
        return null;
      }
      function GN(n, t, e, i) {
        let r = n[t], a = n[t + 1], o = 0;
        for (let s = t + i; s < e; s += i) {
          const l = n[s], u = n[s + 1];
          o += Math.sqrt((l - r) * (l - r) + (u - a) * (u - a)), r = l, a = u;
        }
        return o;
      }
      class Be extends Oa {
        constructor(t, e) {
          super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, e !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(e, t) : this.setCoordinates(t, e);
        }
        appendCoordinate(t) {
          Le(this.flatCoordinates, t), this.changed();
        }
        clone() {
          const t = new Be(this.flatCoordinates.slice(), this.layout);
          return t.applyProperties(this), t;
        }
        closestPointXY(t, e, i, r) {
          return r < Qu(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(qx(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Yx(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, t, e, i, r));
        }
        forEachSegment(t) {
          return IN(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t);
        }
        getCoordinateAtM(t, e) {
          return this.layout != "XYM" && this.layout != "XYZM" ? null : (e = e !== void 0 ? e : false, dw(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e));
        }
        getCoordinates() {
          return ms(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        }
        getCoordinateAt(t, e) {
          return Dm(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, this.stride);
        }
        getLength() {
          return GN(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        }
        getFlatMidpoint() {
          var t;
          return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(0.5, (t = this.flatMidpoint_) != null ? t : void 0), this.flatMidpointRevision_ = this.getRevision()), this.flatMidpoint_;
        }
        getSimplifiedGeometryInternal(t) {
          const e = [];
          return e.length = Cm(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, 0), new Be(e, "XY");
        }
        getType() {
          return "LineString";
        }
        intersectsExtent(t) {
          return Sm(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t);
        }
        setCoordinates(t, e) {
          this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = uA(this.flatCoordinates, 0, t, this.stride), this.changed();
        }
      }
      class Ke {
        constructor(t) {
          t = t || {}, this.color_ = t.color !== void 0 ? t.color : null, this.lineCap_ = t.lineCap, this.lineDash_ = t.lineDash !== void 0 ? t.lineDash : null, this.lineDashOffset_ = t.lineDashOffset, this.lineJoin_ = t.lineJoin, this.miterLimit_ = t.miterLimit, this.width_ = t.width;
        }
        clone() {
          const t = this.getColor();
          return new Ke({ color: Array.isArray(t) ? t.slice() : t || void 0, lineCap: this.getLineCap(), lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0, lineDashOffset: this.getLineDashOffset(), lineJoin: this.getLineJoin(), miterLimit: this.getMiterLimit(), width: this.getWidth() });
        }
        getColor() {
          return this.color_;
        }
        getLineCap() {
          return this.lineCap_;
        }
        getLineDash() {
          return this.lineDash_;
        }
        getLineDashOffset() {
          return this.lineDashOffset_;
        }
        getLineJoin() {
          return this.lineJoin_;
        }
        getMiterLimit() {
          return this.miterLimit_;
        }
        getWidth() {
          return this.width_;
        }
        setColor(t) {
          this.color_ = t;
        }
        setLineCap(t) {
          this.lineCap_ = t;
        }
        setLineDash(t) {
          this.lineDash_ = t;
        }
        setLineDashOffset(t) {
          this.lineDashOffset_ = t;
        }
        setLineJoin(t) {
          this.lineJoin_ = t;
        }
        setMiterLimit(t) {
          this.miterLimit_ = t;
        }
        setWidth(t) {
          this.width_ = t;
        }
      }
      function UN(n) {
        return n[0] > 0 && n[1] > 0;
      }
      function tJ(n, t, e) {
        return e === void 0 && (e = [0, 0]), e[0] = n[0] * t + 0.5 | 0, e[1] = n[1] * t + 0.5 | 0, e;
      }
      function Rn(n, t) {
        return Array.isArray(n) ? n : (t === void 0 ? t = [n, n] : (t[0] = n, t[1] = n), t);
      }
      class Rm {
        constructor(t) {
          this.opacity_ = t.opacity, this.rotateWithView_ = t.rotateWithView, this.rotation_ = t.rotation, this.scale_ = t.scale, this.scaleArray_ = Rn(t.scale), this.displacement_ = t.displacement, this.declutterMode_ = t.declutterMode;
        }
        clone() {
          const t = this.getScale();
          return new Rm({ opacity: this.getOpacity(), scale: Array.isArray(t) ? t.slice() : t, rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() });
        }
        getOpacity() {
          return this.opacity_;
        }
        getRotateWithView() {
          return this.rotateWithView_;
        }
        getRotation() {
          return this.rotation_;
        }
        getScale() {
          return this.scale_;
        }
        getScaleArray() {
          return this.scaleArray_;
        }
        getDisplacement() {
          return this.displacement_;
        }
        getDeclutterMode() {
          return this.declutterMode_;
        }
        getAnchor() {
          return zt();
        }
        getImage(t) {
          return zt();
        }
        getHitDetectionImage() {
          return zt();
        }
        getPixelRatio(t) {
          return 1;
        }
        getImageState() {
          return zt();
        }
        getImageSize() {
          return zt();
        }
        getOrigin() {
          return zt();
        }
        getSize() {
          return zt();
        }
        setDisplacement(t) {
          this.displacement_ = t;
        }
        setOpacity(t) {
          this.opacity_ = t;
        }
        setRotateWithView(t) {
          this.rotateWithView_ = t;
        }
        setRotation(t) {
          this.rotation_ = t;
        }
        setScale(t) {
          this.scale_ = t, this.scaleArray_ = Rn(t);
        }
        listenImageChange(t) {
          zt();
        }
        load() {
          zt();
        }
        unlistenImageChange(t) {
          zt();
        }
        ready() {
          return Promise.resolve();
        }
      }
      function _o(n) {
        return n ? Array.isArray(n) ? lw(n) : typeof n == "object" && "src" in n ? eJ(n) : n : null;
      }
      function eJ(n) {
        if (!n.offset || !n.size) return ra.getPattern(n.src, "anonymous", n.color);
        const t = n.src + ":" + n.offset, e = ra.getPattern(t, void 0, n.color);
        if (e) return e;
        const i = ra.get(n.src, "anonymous", null);
        if (i.getImageState() !== Mt.LOADED) return null;
        const r = In(n.size[0], n.size[1]);
        return r.drawImage(i.getImage(1), n.offset[0], n.offset[1], n.size[0], n.size[1], 0, 0, n.size[0], n.size[1]), gw(r.canvas, t, void 0, Mt.LOADED, n.color, true), ra.getPattern(t, void 0, n.color);
      }
      const Lm = "ol-hidden", nJ = "ol-selectable", _s = "ol-unselectable", VN = "ol-unsupported", of = "ol-control", Pm = "ol-collapsed", iJ = new RegExp(["^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)", "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?", "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))", "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))", `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`].join(""), "i"), jN = ["style", "variant", "weight", "size", "lineHeight", "family"], qN = function(n) {
        const t = n.match(iJ);
        if (!t) return null;
        const e = { lineHeight: "normal", size: "1.2em", style: "normal", weight: "normal", variant: "normal" };
        for (let i = 0, r = jN.length; i < r; ++i) {
          const a = t[i + 1];
          a !== void 0 && (e[jN[i]] = a);
        }
        return e.families = e.family.split(/,\s?/), e;
      }, HN = "10px sans-serif", hr = "#000", sf = "round", Es = [], Is = 0, lf = "round", AA = 10, pA = "#000", vA = "center", Nm = "middle", Wu = [0, 0, 0, 0], yA = 1, xs = new Kr();
      let uf = null, Aw;
      const pw = {}, rJ = function() {
        const t = "32px ", e = ["monospace", "serif"], i = e.length, r = "wmytzilWMYTZIL@#/&?$%10";
        let a, o;
        function s(u, h, c) {
          let f = true;
          for (let g = 0; g < i; ++g) {
            const d = e[g];
            if (o = Fm(u + " " + h + " " + t + d, r), c != d) {
              const A = Fm(u + " " + h + " " + t + c + "," + d, r);
              f = f && A != o;
            }
          }
          return !!f;
        }
        function l() {
          let u = true;
          const h = xs.getKeys();
          for (let c = 0, f = h.length; c < f; ++c) {
            const g = h[c];
            if (xs.get(g) < 100) {
              const [d, A, p] = g.split(`
`);
              s(d, A, p) ? (jc(pw), uf = null, Aw = void 0, xs.set(g, 100)) : (xs.set(g, xs.get(g) + 1, true), u = false);
            }
          }
          u && (clearInterval(a), a = void 0);
        }
        return function(u) {
          const h = qN(u);
          if (!h) return;
          const c = h.families;
          for (let f = 0, g = c.length; f < g; ++f) {
            const d = c[f], A = h.style + `
` + h.weight + `
` + d;
            xs.get(A) === void 0 && (xs.set(A, 100, true), s(h.style, h.weight, d) || (xs.set(A, 0, true), a === void 0 && (a = setInterval(l, 32))));
          }
        };
      }(), aJ = /* @__PURE__ */ function() {
        let n;
        return function(t) {
          let e = pw[t];
          if (e == null) {
            if (uw) {
              const i = qN(t), r = YN(t, "g");
              e = (isNaN(Number(i.lineHeight)) ? 1.2 : Number(i.lineHeight)) * (r.actualBoundingBoxAscent + r.actualBoundingBoxDescent);
            } else n || (n = document.createElement("div"), n.innerHTML = "M", n.style.minHeight = "0", n.style.maxHeight = "none", n.style.height = "auto", n.style.padding = "0", n.style.border = "none", n.style.position = "absolute", n.style.display = "block", n.style.left = "-99999px"), n.style.font = t, document.body.appendChild(n), e = n.offsetHeight, document.body.removeChild(n);
            pw[t] = e;
          }
          return e;
        };
      }();
      function YN(n, t) {
        return uf || (uf = In(1, 1)), n != Aw && (uf.font = n, Aw = uf.font), uf.measureText(t);
      }
      function Fm(n, t) {
        return YN(n, t).width;
      }
      function WN(n, t, e) {
        if (t in e) return e[t];
        const i = t.split(`
`).reduce((r, a) => Math.max(r, Fm(n, a)), 0);
        return e[t] = i, i;
      }
      function oJ(n, t) {
        const e = [], i = [], r = [];
        let a = 0, o = 0, s = 0, l = 0;
        for (let u = 0, h = t.length; u <= h; u += 2) {
          const c = t[u];
          if (c === `
` || u === h) {
            a = Math.max(a, o), r.push(o), o = 0, s += l, l = 0;
            continue;
          }
          const f = t[u + 1] || n.font, g = Fm(f, c);
          e.push(g), o += g;
          const d = aJ(f);
          i.push(d), l = Math.max(l, d);
        }
        return { width: a, height: s, widths: e, heights: i, lineWidths: r };
      }
      function sJ(n, t, e, i, r, a, o, s, l, u, h) {
        n.save(), e !== 1 && (n.globalAlpha === void 0 ? n.globalAlpha = (c) => c.globalAlpha *= e : n.globalAlpha *= e), t && n.transform.apply(n, t), i.contextInstructions ? (n.translate(l, u), n.scale(h[0], h[1]), lJ(i, n)) : h[0] < 0 || h[1] < 0 ? (n.translate(l, u), n.scale(h[0], h[1]), n.drawImage(i, r, a, o, s, 0, 0, o, s)) : n.drawImage(i, r, a, o, s, l, u, o * h[0], s * h[1]), n.restore();
      }
      function lJ(n, t) {
        const e = n.contextInstructions;
        for (let i = 0, r = e.length; i < r; i += 2) Array.isArray(e[i + 1]) ? t[e[i]].apply(t, e[i + 1]) : t[e[i]] = e[i + 1];
      }
      class Xu extends Rm {
        constructor(t) {
          super({ opacity: 1, rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : false, rotation: t.rotation !== void 0 ? t.rotation : 0, scale: t.scale !== void 0 ? t.scale : 1, displacement: t.displacement !== void 0 ? t.displacement : [0, 0], declutterMode: t.declutterMode }), this.hitDetectionCanvas_ = null, this.fill_ = t.fill !== void 0 ? t.fill : null, this.origin_ = [0, 0], this.points_ = t.points, this.radius = t.radius, this.radius2_ = t.radius2, this.angle_ = t.angle !== void 0 ? t.angle : 0, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.size_, this.renderOptions_, this.imageState_ = this.fill_ && this.fill_.loading() ? Mt.LOADING : Mt.LOADED, this.imageState_ === Mt.LOADING && this.ready().then(() => this.imageState_ = Mt.LOADED), this.render();
        }
        clone() {
          const t = this.getScale(), e = new Xu({ fill: this.getFill() ? this.getFill().clone() : void 0, points: this.getPoints(), radius: this.getRadius(), radius2: this.getRadius2(), angle: this.getAngle(), stroke: this.getStroke() ? this.getStroke().clone() : void 0, rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), scale: Array.isArray(t) ? t.slice() : t, displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() });
          return e.setOpacity(this.getOpacity()), e;
        }
        getAnchor() {
          const t = this.size_, e = this.getDisplacement(), i = this.getScaleArray();
          return [t[0] / 2 - e[0] / i[0], t[1] / 2 + e[1] / i[1]];
        }
        getAngle() {
          return this.angle_;
        }
        getFill() {
          return this.fill_;
        }
        setFill(t) {
          this.fill_ = t, this.render();
        }
        getHitDetectionImage() {
          return this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(this.renderOptions_)), this.hitDetectionCanvas_;
        }
        getImage(t) {
          var a, o;
          const e = (a = this.fill_) == null ? void 0 : a.getKey(), i = `${t},${this.angle_},${this.radius},${this.radius2_},${this.points_},${e}` + Object.values(this.renderOptions_).join(",");
          let r = (o = ra.get(i, null, null)) == null ? void 0 : o.getImage(1);
          if (!r) {
            const s = this.renderOptions_, l = Math.ceil(s.size * t), u = In(l, l);
            this.draw_(s, u, t), r = u.canvas, ra.set(i, null, null, new zN(r, void 0, null, Mt.LOADED, null));
          }
          return r;
        }
        getPixelRatio(t) {
          return t;
        }
        getImageSize() {
          return this.size_;
        }
        getImageState() {
          return this.imageState_;
        }
        getOrigin() {
          return this.origin_;
        }
        getPoints() {
          return this.points_;
        }
        getRadius() {
          return this.radius;
        }
        getRadius2() {
          return this.radius2_;
        }
        getSize() {
          return this.size_;
        }
        getStroke() {
          return this.stroke_;
        }
        setStroke(t) {
          this.stroke_ = t, this.render();
        }
        listenImageChange(t) {
        }
        load() {
        }
        unlistenImageChange(t) {
        }
        calculateLineJoinSize_(t, e, i) {
          if (e === 0 || this.points_ === 1 / 0 || t !== "bevel" && t !== "miter") return e;
          let r = this.radius, a = this.radius2_ === void 0 ? r : this.radius2_;
          if (r < a) {
            const E = r;
            r = a, a = E;
          }
          const o = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, s = 2 * Math.PI / o, l = a * Math.sin(s), u = Math.sqrt(a * a - l * l), h = r - u, c = Math.sqrt(l * l + h * h), f = c / l;
          if (t === "miter" && f <= i) return f * e;
          const g = e / 2 / f, d = e / 2 * (h / c), p = Math.sqrt((r + g) * (r + g) + d * d) - r;
          if (this.radius2_ === void 0 || t === "bevel") return p * 2;
          const v = r * Math.sin(s), y = Math.sqrt(r * r - v * v), m = a - y, I = Math.sqrt(v * v + m * m) / v;
          if (I <= i) {
            const E = I * e / 2 - a - r;
            return 2 * Math.max(p, E);
          }
          return p * 2;
        }
        createRenderOptions() {
          var c, f, g, d, A, p;
          let t = sf, e = lf, i = 0, r = null, a = 0, o, s = 0;
          this.stroke_ && (o = _o((c = this.stroke_.getColor()) != null ? c : pA), s = (f = this.stroke_.getWidth()) != null ? f : yA, r = this.stroke_.getLineDash(), a = (g = this.stroke_.getLineDashOffset()) != null ? g : 0, e = (d = this.stroke_.getLineJoin()) != null ? d : lf, t = (A = this.stroke_.getLineCap()) != null ? A : sf, i = (p = this.stroke_.getMiterLimit()) != null ? p : AA);
          const l = this.calculateLineJoinSize_(e, s, i), u = Math.max(this.radius, this.radius2_ || 0), h = Math.ceil(2 * u + l);
          return { strokeStyle: o, strokeWidth: s, size: h, lineCap: t, lineDash: r, lineDashOffset: a, lineJoin: e, miterLimit: i };
        }
        render() {
          this.renderOptions_ = this.createRenderOptions();
          const t = this.renderOptions_.size;
          this.hitDetectionCanvas_ = null, this.size_ = [t, t];
        }
        draw_(t, e, i) {
          if (e.scale(i, i), e.translate(t.size / 2, t.size / 2), this.createPath_(e), this.fill_) {
            let r = this.fill_.getColor();
            r === null && (r = hr), e.fillStyle = _o(r), e.fill();
          }
          t.strokeStyle && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineCap = t.lineCap, e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke());
        }
        createHitDetectionCanvas_(t) {
          let e;
          if (this.fill_) {
            let i = this.fill_.getColor(), r = 0;
            typeof i == "string" && (i = ia(i)), i === null ? r = 1 : Array.isArray(i) && (r = i.length === 4 ? i[3] : 1), r === 0 && (e = In(t.size, t.size), this.drawHitDetectionCanvas_(t, e));
          }
          return e ? e.canvas : this.getImage(1);
        }
        createPath_(t) {
          let e = this.points_;
          const i = this.radius;
          if (e === 1 / 0) t.arc(0, 0, i, 0, 2 * Math.PI);
          else {
            const r = this.radius2_ === void 0 ? i : this.radius2_;
            this.radius2_ !== void 0 && (e *= 2);
            const a = this.angle_ - Math.PI / 2, o = 2 * Math.PI / e;
            for (let s = 0; s < e; s++) {
              const l = a + s * o, u = s % 2 === 0 ? i : r;
              t.lineTo(u * Math.cos(l), u * Math.sin(l));
            }
            t.closePath();
          }
        }
        drawHitDetectionCanvas_(t, e) {
          e.translate(t.size / 2, t.size / 2), this.createPath_(e), e.fillStyle = hr, e.fill(), t.strokeStyle && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke());
        }
        ready() {
          return this.fill_ ? this.fill_.ready() : Promise.resolve();
        }
      }
      class kr extends Xu {
        constructor(t) {
          t = t || { radius: 5 }, super({ points: 1 / 0, fill: t.fill, radius: t.radius, stroke: t.stroke, scale: t.scale !== void 0 ? t.scale : 1, rotation: t.rotation !== void 0 ? t.rotation : 0, rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : false, displacement: t.displacement !== void 0 ? t.displacement : [0, 0], declutterMode: t.declutterMode });
        }
        clone() {
          const t = this.getScale(), e = new kr({ fill: this.getFill() ? this.getFill().clone() : void 0, stroke: this.getStroke() ? this.getStroke().clone() : void 0, radius: this.getRadius(), scale: Array.isArray(t) ? t.slice() : t, rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() });
          return e.setOpacity(this.getOpacity()), e;
        }
        setRadius(t) {
          this.radius = t, this.render();
        }
      }
      class pe {
        constructor(t) {
          t = t || {}, this.geometry_ = null, this.geometryFunction_ = ZN, t.geometry !== void 0 && this.setGeometry(t.geometry), this.fill_ = t.fill !== void 0 ? t.fill : null, this.image_ = t.image !== void 0 ? t.image : null, this.renderer_ = t.renderer !== void 0 ? t.renderer : null, this.hitDetectionRenderer_ = t.hitDetectionRenderer !== void 0 ? t.hitDetectionRenderer : null, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.text_ = t.text !== void 0 ? t.text : null, this.zIndex_ = t.zIndex;
        }
        clone() {
          var e;
          let t = this.getGeometry();
          return t && typeof t == "object" && (t = t.clone()), new pe({ geometry: t != null ? t : void 0, fill: this.getFill() ? this.getFill().clone() : void 0, image: this.getImage() ? this.getImage().clone() : void 0, renderer: (e = this.getRenderer()) != null ? e : void 0, stroke: this.getStroke() ? this.getStroke().clone() : void 0, text: this.getText() ? this.getText().clone() : void 0, zIndex: this.getZIndex() });
        }
        getRenderer() {
          return this.renderer_;
        }
        setRenderer(t) {
          this.renderer_ = t;
        }
        setHitDetectionRenderer(t) {
          this.hitDetectionRenderer_ = t;
        }
        getHitDetectionRenderer() {
          return this.hitDetectionRenderer_;
        }
        getGeometry() {
          return this.geometry_;
        }
        getGeometryFunction() {
          return this.geometryFunction_;
        }
        getFill() {
          return this.fill_;
        }
        setFill(t) {
          this.fill_ = t;
        }
        getImage() {
          return this.image_;
        }
        setImage(t) {
          this.image_ = t;
        }
        getStroke() {
          return this.stroke_;
        }
        setStroke(t) {
          this.stroke_ = t;
        }
        getText() {
          return this.text_;
        }
        setText(t) {
          this.text_ = t;
        }
        getZIndex() {
          return this.zIndex_;
        }
        setGeometry(t) {
          typeof t == "function" ? this.geometryFunction_ = t : typeof t == "string" ? this.geometryFunction_ = function(e) {
            return e.get(t);
          } : t ? t !== void 0 && (this.geometryFunction_ = function() {
            return t;
          }) : this.geometryFunction_ = ZN, this.geometry_ = t;
        }
        setZIndex(t) {
          this.zIndex_ = t;
        }
      }
      function uJ(n) {
        let t;
        if (typeof n == "function") t = n;
        else {
          let e;
          Array.isArray(n) ? e = n : (ue(typeof n.getZIndex == "function", "Expected an `Style` or an array of `Style`"), e = [n]), t = function() {
            return e;
          };
        }
        return t;
      }
      let vw = null;
      function XN(n, t) {
        if (!vw) {
          const e = new me({ color: "rgba(255,255,255,0.4)" }), i = new Ke({ color: "#3399CC", width: 1.25 });
          vw = [new pe({ image: new kr({ fill: e, stroke: i, radius: 5 }), fill: e, stroke: i })];
        }
        return vw;
      }
      function $N() {
        const n = {}, t = [255, 255, 255, 1], e = [0, 153, 255, 1], i = 3;
        return n.Polygon = [new pe({ fill: new me({ color: [255, 255, 255, 0.5] }) })], n.MultiPolygon = n.Polygon, n.LineString = [new pe({ stroke: new Ke({ color: t, width: i + 2 }) }), new pe({ stroke: new Ke({ color: e, width: i }) })], n.MultiLineString = n.LineString, n.Circle = n.Polygon.concat(n.LineString), n.Point = [new pe({ image: new kr({ radius: i * 2, fill: new me({ color: e }), stroke: new Ke({ color: t, width: i / 2 }) }), zIndex: 1 / 0 })], n.MultiPoint = n.Point, n.GeometryCollection = n.Polygon.concat(n.LineString, n.Point), n;
      }
      function ZN(n) {
        return n.getGeometry();
      }
      const hJ = "#333";
      class Si {
        constructor(t) {
          t = t || {}, this.font_ = t.font, this.rotation_ = t.rotation, this.rotateWithView_ = t.rotateWithView, this.keepUpright_ = t.keepUpright, this.scale_ = t.scale, this.scaleArray_ = Rn(t.scale !== void 0 ? t.scale : 1), this.text_ = t.text, this.textAlign_ = t.textAlign, this.justify_ = t.justify, this.repeat_ = t.repeat, this.textBaseline_ = t.textBaseline, this.fill_ = t.fill !== void 0 ? t.fill : new me({ color: hJ }), this.maxAngle_ = t.maxAngle !== void 0 ? t.maxAngle : Math.PI / 4, this.placement_ = t.placement !== void 0 ? t.placement : "point", this.overflow_ = !!t.overflow, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.offsetX_ = t.offsetX !== void 0 ? t.offsetX : 0, this.offsetY_ = t.offsetY !== void 0 ? t.offsetY : 0, this.backgroundFill_ = t.backgroundFill ? t.backgroundFill : null, this.backgroundStroke_ = t.backgroundStroke ? t.backgroundStroke : null, this.padding_ = t.padding === void 0 ? null : t.padding, this.declutterMode_ = t.declutterMode;
        }
        clone() {
          const t = this.getScale();
          return new Si({ font: this.getFont(), placement: this.getPlacement(), repeat: this.getRepeat(), maxAngle: this.getMaxAngle(), overflow: this.getOverflow(), rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), keepUpright: this.getKeepUpright(), scale: Array.isArray(t) ? t.slice() : t, text: this.getText(), textAlign: this.getTextAlign(), justify: this.getJustify(), textBaseline: this.getTextBaseline(), fill: this.getFill() ? this.getFill().clone() : void 0, stroke: this.getStroke() ? this.getStroke().clone() : void 0, offsetX: this.getOffsetX(), offsetY: this.getOffsetY(), backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0, backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0, padding: this.getPadding() || void 0, declutterMode: this.getDeclutterMode() });
        }
        getOverflow() {
          return this.overflow_;
        }
        getFont() {
          return this.font_;
        }
        getMaxAngle() {
          return this.maxAngle_;
        }
        getPlacement() {
          return this.placement_;
        }
        getRepeat() {
          return this.repeat_;
        }
        getOffsetX() {
          return this.offsetX_;
        }
        getOffsetY() {
          return this.offsetY_;
        }
        getFill() {
          return this.fill_;
        }
        getRotateWithView() {
          return this.rotateWithView_;
        }
        getKeepUpright() {
          return this.keepUpright_;
        }
        getRotation() {
          return this.rotation_;
        }
        getScale() {
          return this.scale_;
        }
        getScaleArray() {
          return this.scaleArray_;
        }
        getStroke() {
          return this.stroke_;
        }
        getText() {
          return this.text_;
        }
        getTextAlign() {
          return this.textAlign_;
        }
        getJustify() {
          return this.justify_;
        }
        getTextBaseline() {
          return this.textBaseline_;
        }
        getBackgroundFill() {
          return this.backgroundFill_;
        }
        getBackgroundStroke() {
          return this.backgroundStroke_;
        }
        getPadding() {
          return this.padding_;
        }
        getDeclutterMode() {
          return this.declutterMode_;
        }
        setOverflow(t) {
          this.overflow_ = t;
        }
        setFont(t) {
          this.font_ = t;
        }
        setMaxAngle(t) {
          this.maxAngle_ = t;
        }
        setOffsetX(t) {
          this.offsetX_ = t;
        }
        setOffsetY(t) {
          this.offsetY_ = t;
        }
        setPlacement(t) {
          this.placement_ = t;
        }
        setRepeat(t) {
          this.repeat_ = t;
        }
        setRotateWithView(t) {
          this.rotateWithView_ = t;
        }
        setKeepUpright(t) {
          this.keepUpright_ = t;
        }
        setFill(t) {
          this.fill_ = t;
        }
        setRotation(t) {
          this.rotation_ = t;
        }
        setScale(t) {
          this.scale_ = t, this.scaleArray_ = Rn(t !== void 0 ? t : 1);
        }
        setStroke(t) {
          this.stroke_ = t;
        }
        setText(t) {
          this.text_ = t;
        }
        setTextAlign(t) {
          this.textAlign_ = t;
        }
        setJustify(t) {
          this.justify_ = t;
        }
        setTextBaseline(t) {
          this.textBaseline_ = t;
        }
        setBackgroundFill(t) {
          this.backgroundFill_ = t;
        }
        setBackgroundStroke(t) {
          this.backgroundStroke_ = t;
        }
        setPadding(t) {
          this.padding_ = t;
        }
      }
      const Oe = { OPACITY: "opacity", VISIBLE: "visible", EXTENT: "extent", Z_INDEX: "zIndex", MAX_RESOLUTION: "maxResolution", MIN_RESOLUTION: "minResolution", MAX_ZOOM: "maxZoom", MIN_ZOOM: "minZoom", SOURCE: "source", MAP: "map" };
      class KN extends Kr {
        constructor(t) {
          super(), this.on, this.once, this.un, this.background_ = t.background;
          const e = Object.assign({}, t);
          typeof t.properties == "object" && (delete e.properties, Object.assign(e, t.properties)), e[Oe.OPACITY] = t.opacity !== void 0 ? t.opacity : 1, ue(typeof e[Oe.OPACITY] == "number", "Layer opacity must be a number"), e[Oe.VISIBLE] = t.visible !== void 0 ? t.visible : true, e[Oe.Z_INDEX] = t.zIndex, e[Oe.MAX_RESOLUTION] = t.maxResolution !== void 0 ? t.maxResolution : 1 / 0, e[Oe.MIN_RESOLUTION] = t.minResolution !== void 0 ? t.minResolution : 0, e[Oe.MIN_ZOOM] = t.minZoom !== void 0 ? t.minZoom : -1 / 0, e[Oe.MAX_ZOOM] = t.maxZoom !== void 0 ? t.maxZoom : 1 / 0, this.className_ = e.className !== void 0 ? e.className : "ol-layer", delete e.className, this.setProperties(e), this.state_ = null;
        }
        getBackground() {
          return this.background_;
        }
        getClassName() {
          return this.className_;
        }
        getLayerState(t) {
          const e = this.state_ || { layer: this, managed: t === void 0 ? true : t }, i = this.getZIndex();
          return e.opacity = Ze(Math.round(this.getOpacity() * 100) / 100, 0, 1), e.visible = this.getVisible(), e.extent = this.getExtent(), e.zIndex = i === void 0 && !e.managed ? 1 / 0 : i, e.maxResolution = this.getMaxResolution(), e.minResolution = Math.max(this.getMinResolution(), 0), e.minZoom = this.getMinZoom(), e.maxZoom = this.getMaxZoom(), this.state_ = e, e;
        }
        getLayersArray(t) {
          return zt();
        }
        getLayerStatesArray(t) {
          return zt();
        }
        getExtent() {
          return this.get(Oe.EXTENT);
        }
        getMaxResolution() {
          return this.get(Oe.MAX_RESOLUTION);
        }
        getMinResolution() {
          return this.get(Oe.MIN_RESOLUTION);
        }
        getMinZoom() {
          return this.get(Oe.MIN_ZOOM);
        }
        getMaxZoom() {
          return this.get(Oe.MAX_ZOOM);
        }
        getOpacity() {
          return this.get(Oe.OPACITY);
        }
        getSourceState() {
          return zt();
        }
        getVisible() {
          return this.get(Oe.VISIBLE);
        }
        getZIndex() {
          return this.get(Oe.Z_INDEX);
        }
        setBackground(t) {
          this.background_ = t, this.changed();
        }
        setExtent(t) {
          this.set(Oe.EXTENT, t);
        }
        setMaxResolution(t) {
          this.set(Oe.MAX_RESOLUTION, t);
        }
        setMinResolution(t) {
          this.set(Oe.MIN_RESOLUTION, t);
        }
        setMaxZoom(t) {
          this.set(Oe.MAX_ZOOM, t);
        }
        setMinZoom(t) {
          this.set(Oe.MIN_ZOOM, t);
        }
        setOpacity(t) {
          ue(typeof t == "number", "Layer opacity must be a number"), this.set(Oe.OPACITY, t);
        }
        setVisible(t) {
          this.set(Oe.VISIBLE, t);
        }
        setZIndex(t) {
          this.set(Oe.Z_INDEX, t);
        }
        disposeInternal() {
          this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
        }
      }
      const xn = { ANIMATING: 0, INTERACTING: 1 }, Or = { CENTER: "center", RESOLUTION: "resolution", ROTATION: "rotation" }, cJ = 42, yw = 256;
      function JN(n, t, e) {
        return function(i, r, a, o, s) {
          if (!i) return;
          if (!r && !t) return i;
          const l = t ? 0 : a[0] * r, u = t ? 0 : a[1] * r, h = s ? s[0] : 0, c = s ? s[1] : 0;
          let f = n[0] + l / 2 + h, g = n[2] - l / 2 + h, d = n[1] + u / 2 + c, A = n[3] - u / 2 + c;
          f > g && (f = (g + f) / 2, g = f), d > A && (d = (A + d) / 2, A = d);
          let p = Ze(i[0], f, g), v = Ze(i[1], d, A);
          if (o && e && r) {
            const y = 30 * r;
            p += -y * Math.log(1 + Math.max(0, f - i[0]) / y) + y * Math.log(1 + Math.max(0, i[0] - g) / y), v += -y * Math.log(1 + Math.max(0, d - i[1]) / y) + y * Math.log(1 + Math.max(0, i[1] - A) / y);
          }
          return [p, v];
        };
      }
      function fJ(n) {
        return n;
      }
      function mw(n, t, e, i) {
        const r = he(t) / e[0], a = dn(t) / e[1];
        return i ? Math.min(n, Math.max(r, a)) : Math.min(n, Math.min(r, a));
      }
      function _w(n, t, e) {
        let i = Math.min(n, t);
        const r = 50;
        return i *= Math.log(1 + r * Math.max(0, n / t - 1)) / r + 1, e && (i = Math.max(i, e), i /= Math.log(1 + r * Math.max(0, e / n - 1)) / r + 1), Ze(i, e / 2, t * 2);
      }
      function gJ(n, t, e, i) {
        return t = t !== void 0 ? t : true, function(r, a, o, s) {
          if (r !== void 0) {
            const l = n[0], u = n[n.length - 1], h = e ? mw(l, e, o, i) : l;
            if (s) return t ? _w(r, h, u) : Ze(r, u, h);
            const c = Math.min(h, r), f = Math.floor(pl(n, c, a));
            return n[f] > h && f < n.length - 1 ? n[f + 1] : n[f];
          }
        };
      }
      function dJ(n, t, e, i, r, a) {
        return i = i !== void 0 ? i : true, e = e !== void 0 ? e : 0, function(o, s, l, u) {
          if (o !== void 0) {
            const h = r ? mw(t, r, l, a) : t;
            if (u) return i ? _w(o, h, e) : Ze(o, e, h);
            const c = 1e-9, f = Math.ceil(Math.log(t / h) / Math.log(n) - c), g = -s * (0.5 - c) + 0.5, d = Math.min(h, o), A = Math.floor(Math.log(t / d) / Math.log(n) + g), p = Math.max(f, A), v = t / Math.pow(n, p);
            return Ze(v, e, h);
          }
        };
      }
      function tF(n, t, e, i, r) {
        return e = e !== void 0 ? e : true, function(a, o, s, l) {
          if (a !== void 0) {
            const u = i ? mw(n, i, s, r) : n;
            return !e || !l ? Ze(a, t, u) : _w(a, u, t);
          }
        };
      }
      function Ew(n) {
        if (n !== void 0) return 0;
      }
      function eF(n) {
        if (n !== void 0) return n;
      }
      function AJ(n) {
        const t = 2 * Math.PI / n;
        return function(e, i) {
          if (i) return e;
          if (e !== void 0) return e = Math.floor(e / t + 0.5) * t, e;
        };
      }
      function pJ(n) {
        const t = ea(5);
        return function(e, i) {
          return i || e === void 0 ? e : Math.abs(e) <= t ? 0 : e;
        };
      }
      function nF(n) {
        return Math.pow(n, 3);
      }
      function $u(n) {
        return 1 - nF(1 - n);
      }
      function vJ(n) {
        return 3 * n * n - 2 * n * n * n;
      }
      function yJ(n) {
        return n;
      }
      const Iw = 0;
      let Qa = class extends Kr {
        constructor(t) {
          super(), this.on, this.once, this.un, t = Object.assign({}, t), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = Ux(t.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, t.projection && hN(), t.center && (t.center = ke(t.center, this.projection_)), t.extent && (t.extent = zi(t.extent, this.projection_)), this.applyOptions_(t);
        }
        applyOptions_(t) {
          const e = Object.assign({}, t);
          for (const s in Or) delete e[s];
          this.setProperties(e, true);
          const i = _J(t);
          this.maxResolution_ = i.maxResolution, this.minResolution_ = i.minResolution, this.zoomFactor_ = i.zoomFactor, this.resolutions_ = t.resolutions, this.padding_ = t.padding, this.minZoom_ = i.minZoom;
          const r = mJ(t), a = i.constraint, o = EJ(t);
          this.constraints_ = { center: r, resolution: a, rotation: o }, this.setRotation(t.rotation !== void 0 ? t.rotation : 0), this.setCenterInternal(t.center !== void 0 ? t.center : null), t.resolution !== void 0 ? this.setResolution(t.resolution) : t.zoom !== void 0 && this.setZoom(t.zoom);
        }
        get padding() {
          return this.padding_;
        }
        set padding(t) {
          let e = this.padding_;
          this.padding_ = t;
          const i = this.getCenterInternal();
          if (i) {
            const r = t || [0, 0, 0, 0];
            e = e || [0, 0, 0, 0];
            const a = this.getResolution(), o = a / 2 * (r[3] - e[3] + e[1] - r[1]), s = a / 2 * (r[0] - e[0] + e[2] - r[2]);
            this.setCenterInternal([i[0] + o, i[1] - s]);
          }
        }
        getUpdatedOptions_(t) {
          const e = this.getProperties();
          return e.resolution !== void 0 ? e.resolution = this.getResolution() : e.zoom = this.getZoom(), e.center = this.getCenterInternal(), e.rotation = this.getRotation(), Object.assign({}, e, t);
        }
        animate(t) {
          this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
          const e = new Array(arguments.length);
          for (let i = 0; i < e.length; ++i) {
            let r = arguments[i];
            r.center && (r = Object.assign({}, r), r.center = ke(r.center, this.getProjection())), r.anchor && (r = Object.assign({}, r), r.anchor = ke(r.anchor, this.getProjection())), e[i] = r;
          }
          this.animateInternal.apply(this, e);
        }
        animateInternal(t) {
          let e = arguments.length, i;
          e > 1 && typeof arguments[e - 1] == "function" && (i = arguments[e - 1], --e);
          let r = 0;
          for (; r < e && !this.isDef(); ++r) {
            const h = arguments[r];
            h.center && this.setCenterInternal(h.center), h.zoom !== void 0 ? this.setZoom(h.zoom) : h.resolution && this.setResolution(h.resolution), h.rotation !== void 0 && this.setRotation(h.rotation);
          }
          if (r === e) {
            i && km(i, true);
            return;
          }
          let a = Date.now(), o = this.targetCenter_.slice(), s = this.targetResolution_, l = this.targetRotation_;
          const u = [];
          for (; r < e; ++r) {
            const h = arguments[r], c = { start: a, complete: false, anchor: h.anchor, duration: h.duration !== void 0 ? h.duration : 1e3, easing: h.easing || vJ, callback: i };
            if (h.center && (c.sourceCenter = o, c.targetCenter = h.center.slice(), o = c.targetCenter), h.zoom !== void 0 ? (c.sourceResolution = s, c.targetResolution = this.getResolutionForZoom(h.zoom), s = c.targetResolution) : h.resolution && (c.sourceResolution = s, c.targetResolution = h.resolution, s = c.targetResolution), h.rotation !== void 0) {
              c.sourceRotation = l;
              const f = ys(h.rotation - l + Math.PI, 2 * Math.PI) - Math.PI;
              c.targetRotation = l + f, l = c.targetRotation;
            }
            IJ(c) ? c.complete = true : a += c.duration, u.push(c);
          }
          this.animations_.push(u), this.setHint(xn.ANIMATING, 1), this.updateAnimations_();
        }
        getAnimating() {
          return this.hints_[xn.ANIMATING] > 0;
        }
        getInteracting() {
          return this.hints_[xn.INTERACTING] > 0;
        }
        cancelAnimations() {
          this.setHint(xn.ANIMATING, -this.hints_[xn.ANIMATING]);
          let t;
          for (let e = 0, i = this.animations_.length; e < i; ++e) {
            const r = this.animations_[e];
            if (r[0].callback && km(r[0].callback, false), !t) for (let a = 0, o = r.length; a < o; ++a) {
              const s = r[a];
              if (!s.complete) {
                t = s.anchor;
                break;
              }
            }
          }
          this.animations_.length = 0, this.cancelAnchor_ = t, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        }
        updateAnimations_() {
          if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating()) return;
          const t = Date.now();
          let e = false;
          for (let i = this.animations_.length - 1; i >= 0; --i) {
            const r = this.animations_[i];
            let a = true;
            for (let o = 0, s = r.length; o < s; ++o) {
              const l = r[o];
              if (l.complete) continue;
              const u = t - l.start;
              let h = l.duration > 0 ? u / l.duration : 1;
              h >= 1 ? (l.complete = true, h = 1) : a = false;
              const c = l.easing(h);
              if (l.sourceCenter) {
                const f = l.sourceCenter[0], g = l.sourceCenter[1], d = l.targetCenter[0], A = l.targetCenter[1];
                this.nextCenter_ = l.targetCenter;
                const p = f + c * (d - f), v = g + c * (A - g);
                this.targetCenter_ = [p, v];
              }
              if (l.sourceResolution && l.targetResolution) {
                const f = c === 1 ? l.targetResolution : l.sourceResolution + c * (l.targetResolution - l.sourceResolution);
                if (l.anchor) {
                  const g = this.getViewportSize_(this.getRotation()), d = this.constraints_.resolution(f, 0, g, true);
                  this.targetCenter_ = this.calculateCenterZoom(d, l.anchor);
                }
                this.nextResolution_ = l.targetResolution, this.targetResolution_ = f, this.applyTargetState_(true);
              }
              if (l.sourceRotation !== void 0 && l.targetRotation !== void 0) {
                const f = c === 1 ? ys(l.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : l.sourceRotation + c * (l.targetRotation - l.sourceRotation);
                if (l.anchor) {
                  const g = this.constraints_.rotation(f, true);
                  this.targetCenter_ = this.calculateCenterRotate(g, l.anchor);
                }
                this.nextRotation_ = l.targetRotation, this.targetRotation_ = f;
              }
              if (this.applyTargetState_(true), e = true, !l.complete) break;
            }
            if (a) {
              this.animations_[i] = null, this.setHint(xn.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
              const o = r[0].callback;
              o && km(o, true);
            }
          }
          this.animations_ = this.animations_.filter(Boolean), e && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this)));
        }
        calculateCenterRotate(t, e) {
          let i;
          const r = this.getCenterInternal();
          return r !== void 0 && (i = [r[0] - e[0], r[1] - e[1]], Lx(i, t - this.getRotation()), WP(i, e)), i;
        }
        calculateCenterZoom(t, e) {
          let i;
          const r = this.getCenterInternal(), a = this.getResolution();
          if (r !== void 0 && a !== void 0) {
            const o = e[0] - t * (e[0] - r[0]) / a, s = e[1] - t * (e[1] - r[1]) / a;
            i = [o, s];
          }
          return i;
        }
        getViewportSize_(t) {
          const e = this.viewportSize_;
          if (t) {
            const i = e[0], r = e[1];
            return [Math.abs(i * Math.cos(t)) + Math.abs(r * Math.sin(t)), Math.abs(i * Math.sin(t)) + Math.abs(r * Math.cos(t))];
          }
          return e;
        }
        setViewportSize(t) {
          this.viewportSize_ = Array.isArray(t) ? t.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
        }
        getCenter() {
          const t = this.getCenterInternal();
          return t && vo(t, this.getProjection());
        }
        getCenterInternal() {
          return this.get(Or.CENTER);
        }
        getConstraints() {
          return this.constraints_;
        }
        getConstrainResolution() {
          return this.get("constrainResolution");
        }
        getHints(t) {
          return t !== void 0 ? (t[0] = this.hints_[0], t[1] = this.hints_[1], t) : this.hints_.slice();
        }
        calculateExtent(t) {
          const e = this.calculateExtentInternal(t);
          return sA(e, this.getProjection());
        }
        calculateExtentInternal(t) {
          t = t || this.getViewportSizeMinusPadding_();
          const e = this.getCenterInternal();
          ue(e, "The view center is not defined");
          const i = this.getResolution();
          ue(i !== void 0, "The view resolution is not defined");
          const r = this.getRotation();
          return ue(r !== void 0, "The view rotation is not defined"), nA(e, i, r, t);
        }
        getMaxResolution() {
          return this.maxResolution_;
        }
        getMinResolution() {
          return this.minResolution_;
        }
        getMaxZoom() {
          return this.getZoomForResolution(this.minResolution_);
        }
        setMaxZoom(t) {
          this.applyOptions_(this.getUpdatedOptions_({ maxZoom: t }));
        }
        getMinZoom() {
          return this.getZoomForResolution(this.maxResolution_);
        }
        setMinZoom(t) {
          this.applyOptions_(this.getUpdatedOptions_({ minZoom: t }));
        }
        setConstrainResolution(t) {
          this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: t }));
        }
        getProjection() {
          return this.projection_;
        }
        getResolution() {
          return this.get(Or.RESOLUTION);
        }
        getResolutions() {
          return this.resolutions_;
        }
        getResolutionForExtent(t, e) {
          return this.getResolutionForExtentInternal(zi(t, this.getProjection()), e);
        }
        getResolutionForExtentInternal(t, e) {
          e = e || this.getViewportSizeMinusPadding_();
          const i = he(t) / e[0], r = dn(t) / e[1];
          return Math.max(i, r);
        }
        getResolutionForValueFunction(t) {
          t = t || 2;
          const e = this.getConstrainedResolution(this.maxResolution_), i = this.minResolution_, r = Math.log(e / i) / Math.log(t);
          return function(a) {
            return e / Math.pow(t, a * r);
          };
        }
        getRotation() {
          return this.get(Or.ROTATION);
        }
        getValueForResolutionFunction(t) {
          const e = Math.log(t || 2), i = this.getConstrainedResolution(this.maxResolution_), r = this.minResolution_, a = Math.log(i / r) / e;
          return function(o) {
            return Math.log(i / o) / e / a;
          };
        }
        getViewportSizeMinusPadding_(t) {
          let e = this.getViewportSize_(t);
          const i = this.padding_;
          return i && (e = [e[0] - i[1] - i[3], e[1] - i[0] - i[2]]), e;
        }
        getState() {
          const t = this.getProjection(), e = this.getResolution(), i = this.getRotation();
          let r = this.getCenterInternal();
          const a = this.padding_;
          if (a) {
            const o = this.getViewportSizeMinusPadding_();
            r = xw(r, this.getViewportSize_(), [o[0] / 2 + a[3], o[1] / 2 + a[0]], e, i);
          }
          return { center: r.slice(0), projection: t !== void 0 ? t : null, resolution: e, nextCenter: this.nextCenter_, nextResolution: this.nextResolution_, nextRotation: this.nextRotation_, rotation: i, zoom: this.getZoom() };
        }
        getViewStateAndExtent() {
          return { viewState: this.getState(), extent: this.calculateExtent() };
        }
        getZoom() {
          let t;
          const e = this.getResolution();
          return e !== void 0 && (t = this.getZoomForResolution(e)), t;
        }
        getZoomForResolution(t) {
          let e = this.minZoom_ || 0, i, r;
          if (this.resolutions_) {
            const a = pl(this.resolutions_, t, 1);
            e = a, i = this.resolutions_[a], a == this.resolutions_.length - 1 ? r = 2 : r = i / this.resolutions_[a + 1];
          } else i = this.maxResolution_, r = this.zoomFactor_;
          return e + Math.log(i / t) / Math.log(r);
        }
        getResolutionForZoom(t) {
          var e;
          if ((e = this.resolutions_) != null && e.length) {
            if (this.resolutions_.length === 1) return this.resolutions_[0];
            const i = Ze(Math.floor(t), 0, this.resolutions_.length - 2), r = this.resolutions_[i] / this.resolutions_[i + 1];
            return this.resolutions_[i] / Math.pow(r, Ze(t - i, 0, 1));
          }
          return this.maxResolution_ / Math.pow(this.zoomFactor_, t - this.minZoom_);
        }
        fit(t, e) {
          let i;
          if (ue(Array.isArray(t) || typeof t.getSimplifiedGeometry == "function", "Invalid extent or geometry provided as `geometry`"), Array.isArray(t)) {
            ue(!ps(t), "Cannot fit empty extent provided as `geometry`");
            const r = zi(t, this.getProjection());
            i = nw(r);
          } else if (t.getType() === "Circle") {
            const r = zi(t.getExtent(), this.getProjection());
            i = nw(r), i.rotate(this.getRotation(), Nr(r));
          } else i = t;
          this.fitInternal(i, e);
        }
        rotatedExtentForGeometry(t) {
          const e = this.getRotation(), i = Math.cos(e), r = Math.sin(-e), a = t.getFlatCoordinates(), o = t.getStride();
          let s = 1 / 0, l = 1 / 0, u = -1 / 0, h = -1 / 0;
          for (let c = 0, f = a.length; c < f; c += o) {
            const g = a[c] * i - a[c + 1] * r, d = a[c] * r + a[c + 1] * i;
            s = Math.min(s, g), l = Math.min(l, d), u = Math.max(u, g), h = Math.max(h, d);
          }
          return [s, l, u, h];
        }
        fitInternal(t, e) {
          e = e || {};
          let i = e.size;
          i || (i = this.getViewportSizeMinusPadding_());
          const r = e.padding !== void 0 ? e.padding : [0, 0, 0, 0], a = e.nearest !== void 0 ? e.nearest : false;
          let o;
          e.minResolution !== void 0 ? o = e.minResolution : e.maxZoom !== void 0 ? o = this.getResolutionForZoom(e.maxZoom) : o = 0;
          const s = this.rotatedExtentForGeometry(t);
          let l = this.getResolutionForExtentInternal(s, [i[0] - r[1] - r[3], i[1] - r[0] - r[2]]);
          l = isNaN(l) ? o : Math.max(l, o), l = this.getConstrainedResolution(l, a ? 0 : 1);
          const u = this.getRotation(), h = Math.sin(u), c = Math.cos(u), f = Nr(s);
          f[0] += (r[1] - r[3]) / 2 * l, f[1] += (r[0] - r[2]) / 2 * l;
          const g = f[0] * c - f[1] * h, d = f[1] * c + f[0] * h, A = this.getConstrainedCenter([g, d], l), p = e.callback ? e.callback : Vc;
          e.duration !== void 0 ? this.animateInternal({ resolution: l, center: A, duration: e.duration, easing: e.easing }, p) : (this.targetResolution_ = l, this.targetCenter_ = A, this.applyTargetState_(false, true), km(p, true));
        }
        centerOn(t, e, i) {
          this.centerOnInternal(ke(t, this.getProjection()), e, i);
        }
        centerOnInternal(t, e, i) {
          this.setCenterInternal(xw(t, e, i, this.getResolution(), this.getRotation()));
        }
        calculateCenterShift(t, e, i, r) {
          let a;
          const o = this.padding_;
          if (o && t) {
            const s = this.getViewportSizeMinusPadding_(-i), l = xw(t, r, [s[0] / 2 + o[3], s[1] / 2 + o[0]], e, i);
            a = [t[0] - l[0], t[1] - l[1]];
          }
          return a;
        }
        isDef() {
          return !!this.getCenterInternal() && this.getResolution() !== void 0;
        }
        adjustCenter(t) {
          const e = vo(this.targetCenter_, this.getProjection());
          this.setCenter([e[0] + t[0], e[1] + t[1]]);
        }
        adjustCenterInternal(t) {
          const e = this.targetCenter_;
          this.setCenterInternal([e[0] + t[0], e[1] + t[1]]);
        }
        adjustResolution(t, e) {
          e = e && ke(e, this.getProjection()), this.adjustResolutionInternal(t, e);
        }
        adjustResolutionInternal(t, e) {
          const i = this.getAnimating() || this.getInteracting(), r = this.getViewportSize_(this.getRotation()), a = this.constraints_.resolution(this.targetResolution_ * t, 0, r, i);
          e && (this.targetCenter_ = this.calculateCenterZoom(a, e)), this.targetResolution_ *= t, this.applyTargetState_();
        }
        adjustZoom(t, e) {
          this.adjustResolution(Math.pow(this.zoomFactor_, -t), e);
        }
        adjustRotation(t, e) {
          e && (e = ke(e, this.getProjection())), this.adjustRotationInternal(t, e);
        }
        adjustRotationInternal(t, e) {
          const i = this.getAnimating() || this.getInteracting(), r = this.constraints_.rotation(this.targetRotation_ + t, i);
          e && (this.targetCenter_ = this.calculateCenterRotate(r, e)), this.targetRotation_ += t, this.applyTargetState_();
        }
        setCenter(t) {
          this.setCenterInternal(t && ke(t, this.getProjection()));
        }
        setCenterInternal(t) {
          this.targetCenter_ = t, this.applyTargetState_();
        }
        setHint(t, e) {
          return this.hints_[t] += e, this.changed(), this.hints_[t];
        }
        setResolution(t) {
          this.targetResolution_ = t, this.applyTargetState_();
        }
        setRotation(t) {
          this.targetRotation_ = t, this.applyTargetState_();
        }
        setZoom(t) {
          this.setResolution(this.getResolutionForZoom(t));
        }
        applyTargetState_(t, e) {
          const i = this.getAnimating() || this.getInteracting() || e, r = this.constraints_.rotation(this.targetRotation_, i), a = this.getViewportSize_(r), o = this.constraints_.resolution(this.targetResolution_, 0, a, i), s = this.constraints_.center(this.targetCenter_, o, a, i, this.calculateCenterShift(this.targetCenter_, o, r, a));
          this.get(Or.ROTATION) !== r && this.set(Or.ROTATION, r), this.get(Or.RESOLUTION) !== o && (this.set(Or.RESOLUTION, o), this.set("zoom", this.getZoom(), true)), (!s || !this.get(Or.CENTER) || !Qi(this.get(Or.CENTER), s)) && this.set(Or.CENTER, s), this.getAnimating() && !t && this.cancelAnimations(), this.cancelAnchor_ = void 0;
        }
        resolveConstraints(t, e, i) {
          t = t !== void 0 ? t : 200;
          const r = e || 0, a = this.constraints_.rotation(this.targetRotation_), o = this.getViewportSize_(a), s = this.constraints_.resolution(this.targetResolution_, r, o), l = this.constraints_.center(this.targetCenter_, s, o, false, this.calculateCenterShift(this.targetCenter_, s, a, o));
          if (t === 0 && !this.cancelAnchor_) {
            this.targetResolution_ = s, this.targetRotation_ = a, this.targetCenter_ = l, this.applyTargetState_();
            return;
          }
          i = i || (t === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== s || this.getRotation() !== a || !this.getCenterInternal() || !Qi(this.getCenterInternal(), l)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({ rotation: a, center: l, resolution: s, duration: t, easing: $u, anchor: i }));
        }
        beginInteraction() {
          this.resolveConstraints(0), this.setHint(xn.INTERACTING, 1);
        }
        endInteraction(t, e, i) {
          i = i && ke(i, this.getProjection()), this.endInteractionInternal(t, e, i);
        }
        endInteractionInternal(t, e, i) {
          this.getInteracting() && (this.setHint(xn.INTERACTING, -1), this.resolveConstraints(t, e, i));
        }
        getConstrainedCenter(t, e) {
          const i = this.getViewportSize_(this.getRotation());
          return this.constraints_.center(t, e || this.getResolution(), i);
        }
        getConstrainedZoom(t, e) {
          const i = this.getResolutionForZoom(t);
          return this.getZoomForResolution(this.getConstrainedResolution(i, e));
        }
        getConstrainedResolution(t, e) {
          e = e || 0;
          const i = this.getViewportSize_(this.getRotation());
          return this.constraints_.resolution(t, e, i);
        }
      };
      function km(n, t) {
        setTimeout(function() {
          n(t);
        }, 0);
      }
      function mJ(n) {
        if (n.extent !== void 0) {
          const e = n.smoothExtentConstraint !== void 0 ? n.smoothExtentConstraint : true;
          return JN(n.extent, n.constrainOnlyCenter, e);
        }
        const t = Ux(n.projection, "EPSG:3857");
        if (n.multiWorld !== true && t.isGlobal()) {
          const e = t.getExtent().slice();
          return e[0] = -1 / 0, e[2] = 1 / 0, JN(e, false, false);
        }
        return fJ;
      }
      function _J(n) {
        let t, e, i, o = n.minZoom !== void 0 ? n.minZoom : Iw, s = n.maxZoom !== void 0 ? n.maxZoom : 28;
        const l = n.zoomFactor !== void 0 ? n.zoomFactor : 2, u = n.multiWorld !== void 0 ? n.multiWorld : false, h = n.smoothResolutionConstraint !== void 0 ? n.smoothResolutionConstraint : true, c = n.showFullExtent !== void 0 ? n.showFullExtent : false, f = Ux(n.projection, "EPSG:3857"), g = f.getExtent();
        let d = n.constrainOnlyCenter, A = n.extent;
        if (!u && !A && f.isGlobal() && (d = false, A = g), n.resolutions !== void 0) {
          const p = n.resolutions;
          e = p[o], i = p[s] !== void 0 ? p[s] : p[p.length - 1], n.constrainResolution ? t = gJ(p, h, !d && A, c) : t = tF(e, i, h, !d && A, c);
        } else {
          const v = (g ? Math.max(he(g), dn(g)) : 360 * $c.degrees / f.getMetersPerUnit()) / yw / Math.pow(2, Iw), y = v / Math.pow(2, 28 - Iw);
          e = n.maxResolution, e !== void 0 ? o = 0 : e = v / Math.pow(l, o), i = n.minResolution, i === void 0 && (n.maxZoom !== void 0 ? n.maxResolution !== void 0 ? i = e / Math.pow(l, s) : i = v / Math.pow(l, s) : i = y), s = o + Math.floor(Math.log(e / i) / Math.log(l)), i = e / Math.pow(l, s - o), n.constrainResolution ? t = dJ(l, e, i, h, !d && A, c) : t = tF(e, i, h, !d && A, c);
        }
        return { constraint: t, maxResolution: e, minResolution: i, minZoom: o, zoomFactor: l };
      }
      function EJ(n) {
        if (n.enableRotation !== void 0 ? n.enableRotation : true) {
          const e = n.constrainRotation;
          return e === void 0 || e === true ? pJ() : e === false ? eF : typeof e == "number" ? AJ(e) : eF;
        }
        return Ew;
      }
      function IJ(n) {
        return !(n.sourceCenter && n.targetCenter && !Qi(n.sourceCenter, n.targetCenter) || n.sourceResolution !== n.targetResolution || n.sourceRotation !== n.targetRotation);
      }
      function xw(n, t, e, i, r) {
        const a = Math.cos(-r);
        let o = Math.sin(-r), s = n[0] * a - n[1] * o, l = n[1] * a + n[0] * o;
        s += (t[0] / 2 - e[0]) * i, l += (e[1] - t[1] / 2) * i, o = -o;
        const u = s * a - l * o, h = l * a + s * o;
        return [u, h];
      }
      let Zu = class extends KN {
        constructor(t) {
          const e = Object.assign({}, t);
          delete e.source, super(e), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = false, this.rendered = false, t.render && (this.render = t.render), t.map && this.setMap(t.map), this.addChangeListener(Oe.SOURCE, this.handleSourcePropertyChange_);
          const i = t.source ? t.source : null;
          this.setSource(i);
        }
        getLayersArray(t) {
          return t = t || [], t.push(this), t;
        }
        getLayerStatesArray(t) {
          return t = t || [], t.push(this.getLayerState()), t;
        }
        getSource() {
          return this.get(Oe.SOURCE) || null;
        }
        getRenderSource() {
          return this.getSource();
        }
        getSourceState() {
          const t = this.getSource();
          return t ? t.getState() : "undefined";
        }
        handleSourceChange_() {
          this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = true, this.dispatchEvent("sourceready"));
        }
        handleSourcePropertyChange_() {
          this.sourceChangeKey_ && (we(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = false;
          const t = this.getSource();
          t && (this.sourceChangeKey_ = Ut(t, Rt.CHANGE, this.handleSourceChange_, this), t.getState() === "ready" && (this.sourceReady_ = true, setTimeout(() => {
            this.dispatchEvent("sourceready");
          }, 0))), this.changed();
        }
        getFeatures(t) {
          return this.renderer_ ? this.renderer_.getFeatures(t) : Promise.resolve([]);
        }
        getData(t) {
          return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(t);
        }
        isVisible(t) {
          let e;
          const i = this.getMapInternal();
          !t && i && (t = i.getView()), t instanceof Qa ? e = { viewState: t.getState(), extent: t.calculateExtent() } : e = t, !e.layerStatesArray && i && (e.layerStatesArray = i.getLayerGroup().getLayerStatesArray());
          let r;
          if (e.layerStatesArray) {
            if (r = e.layerStatesArray.find((o) => o.layer === this), !r) return false;
          } else r = this.getLayerState();
          const a = this.getExtent();
          return ww(r, e.viewState) && (!a || Ai(a, e.extent));
        }
        getAttributions(t) {
          var a;
          if (!this.isVisible(t)) return [];
          const e = (a = this.getSource()) == null ? void 0 : a.getAttributions();
          if (!e) return [];
          const i = t instanceof Qa ? t.getViewStateAndExtent() : t;
          let r = e(i);
          return Array.isArray(r) || (r = [r]), r;
        }
        render(t, e) {
          const i = this.getRenderer();
          return i.prepareFrame(t) ? (this.rendered = true, i.renderFrame(t, e)) : null;
        }
        unrender() {
          this.rendered = false;
        }
        getDeclutter() {
        }
        renderDeclutter(t, e) {
        }
        renderDeferred(t) {
          const e = this.getRenderer();
          e && e.renderDeferred(t);
        }
        setMapInternal(t) {
          t || this.unrender(), this.set(Oe.MAP, t);
        }
        getMapInternal() {
          return this.get(Oe.MAP);
        }
        setMap(t) {
          this.mapPrecomposeKey_ && (we(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), t || this.changed(), this.mapRenderKey_ && (we(this.mapRenderKey_), this.mapRenderKey_ = null), t && (this.mapPrecomposeKey_ = Ut(t, si.PRECOMPOSE, this.handlePrecompose_, this), this.mapRenderKey_ = Ut(this, Rt.CHANGE, t.render, t), this.changed());
        }
        handlePrecompose_(t) {
          const e = t.frameState.layerStatesArray, i = this.getLayerState(false);
          ue(!e.some((r) => r.layer === i.layer), "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."), e.push(i);
        }
        setSource(t) {
          this.set(Oe.SOURCE, t);
        }
        getRenderer() {
          return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
        }
        hasRenderer() {
          return !!this.renderer_;
        }
        createRenderer() {
          return null;
        }
        clearRenderer() {
          this.renderer_ && (this.renderer_.dispose(), delete this.renderer_);
        }
        disposeInternal() {
          this.clearRenderer(), this.setSource(null), super.disposeInternal();
        }
      };
      function ww(n, t) {
        if (!n.visible) return false;
        const e = t.resolution;
        if (e < n.minResolution || e >= n.maxResolution) return false;
        const i = t.zoom;
        return i > n.minZoom && i <= n.maxZoom;
      }
      function iF(n, t, e = 0, i = n.length - 1, r = xJ) {
        for (; i > e; ) {
          if (i - e > 600) {
            const l = i - e + 1, u = t - e + 1, h = Math.log(l), c = 0.5 * Math.exp(2 * h / 3), f = 0.5 * Math.sqrt(h * c * (l - c) / l) * (u - l / 2 < 0 ? -1 : 1), g = Math.max(e, Math.floor(t - u * c / l + f)), d = Math.min(i, Math.floor(t + (l - u) * c / l + f));
            iF(n, t, g, d, r);
          }
          const a = n[t];
          let o = e, s = i;
          for (mA(n, e, t), r(n[i], a) > 0 && mA(n, e, i); o < s; ) {
            for (mA(n, o, s), o++, s--; r(n[o], a) < 0; ) o++;
            for (; r(n[s], a) > 0; ) s--;
          }
          r(n[e], a) === 0 ? mA(n, e, s) : (s++, mA(n, s, i)), s <= t && (e = s + 1), t <= s && (i = s - 1);
        }
      }
      function mA(n, t, e) {
        const i = n[t];
        n[t] = n[e], n[e] = i;
      }
      function xJ(n, t) {
        return n < t ? -1 : n > t ? 1 : 0;
      }
      let rF = class {
        constructor(t = 9) {
          this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
        }
        all() {
          return this._all(this.data, []);
        }
        search(t) {
          let e = this.data;
          const i = [];
          if (!Qm(t, e)) return i;
          const r = this.toBBox, a = [];
          for (; e; ) {
            for (let o = 0; o < e.children.length; o++) {
              const s = e.children[o], l = e.leaf ? r(s) : s;
              Qm(t, l) && (e.leaf ? i.push(s) : Sw(t, l) ? this._all(s, i) : a.push(s));
            }
            e = a.pop();
          }
          return i;
        }
        collides(t) {
          let e = this.data;
          if (!Qm(t, e)) return false;
          const i = [];
          for (; e; ) {
            for (let r = 0; r < e.children.length; r++) {
              const a = e.children[r], o = e.leaf ? this.toBBox(a) : a;
              if (Qm(t, o)) {
                if (e.leaf || Sw(t, o)) return true;
                i.push(a);
              }
            }
            e = i.pop();
          }
          return false;
        }
        load(t) {
          if (!(t && t.length)) return this;
          if (t.length < this._minEntries) {
            for (let i = 0; i < t.length; i++) this.insert(t[i]);
            return this;
          }
          let e = this._build(t.slice(), 0, t.length - 1, 0);
          if (!this.data.children.length) this.data = e;
          else if (this.data.height === e.height) this._splitRoot(this.data, e);
          else {
            if (this.data.height < e.height) {
              const i = this.data;
              this.data = e, e = i;
            }
            this._insert(e, this.data.height - e.height - 1, true);
          }
          return this;
        }
        insert(t) {
          return t && this._insert(t, this.data.height - 1), this;
        }
        clear() {
          return this.data = cf([]), this;
        }
        remove(t, e) {
          if (!t) return this;
          let i = this.data;
          const r = this.toBBox(t), a = [], o = [];
          let s, l, u;
          for (; i || a.length; ) {
            if (i || (i = a.pop(), l = a[a.length - 1], s = o.pop(), u = true), i.leaf) {
              const h = wJ(t, i.children, e);
              if (h !== -1) return i.children.splice(h, 1), a.push(i), this._condense(a), this;
            }
            !u && !i.leaf && Sw(i, r) ? (a.push(i), o.push(s), s = 0, l = i, i = i.children[0]) : l ? (s++, i = l.children[s], u = false) : i = null;
          }
          return this;
        }
        toBBox(t) {
          return t;
        }
        compareMinX(t, e) {
          return t.minX - e.minX;
        }
        compareMinY(t, e) {
          return t.minY - e.minY;
        }
        toJSON() {
          return this.data;
        }
        fromJSON(t) {
          return this.data = t, this;
        }
        _all(t, e) {
          const i = [];
          for (; t; ) t.leaf ? e.push(...t.children) : i.push(...t.children), t = i.pop();
          return e;
        }
        _build(t, e, i, r) {
          const a = i - e + 1;
          let o = this._maxEntries, s;
          if (a <= o) return s = cf(t.slice(e, i + 1)), hf(s, this.toBBox), s;
          r || (r = Math.ceil(Math.log(a) / Math.log(o)), o = Math.ceil(a / Math.pow(o, r - 1))), s = cf([]), s.leaf = false, s.height = r;
          const l = Math.ceil(a / o), u = l * Math.ceil(Math.sqrt(o));
          aF(t, e, i, u, this.compareMinX);
          for (let h = e; h <= i; h += u) {
            const c = Math.min(h + u - 1, i);
            aF(t, h, c, l, this.compareMinY);
            for (let f = h; f <= c; f += l) {
              const g = Math.min(f + l - 1, c);
              s.children.push(this._build(t, f, g, r - 1));
            }
          }
          return hf(s, this.toBBox), s;
        }
        _chooseSubtree(t, e, i, r) {
          for (; r.push(e), !(e.leaf || r.length - 1 === i); ) {
            let a = 1 / 0, o = 1 / 0, s;
            for (let l = 0; l < e.children.length; l++) {
              const u = e.children[l], h = Cw(u), c = bJ(t, u) - h;
              c < o ? (o = c, a = h < a ? h : a, s = u) : c === o && h < a && (a = h, s = u);
            }
            e = s || e.children[0];
          }
          return e;
        }
        _insert(t, e, i) {
          const r = i ? t : this.toBBox(t), a = [], o = this._chooseSubtree(r, this.data, e, a);
          for (o.children.push(t), EA(o, r); e >= 0 && a[e].children.length > this._maxEntries; ) this._split(a, e), e--;
          this._adjustParentBBoxes(r, a, e);
        }
        _split(t, e) {
          const i = t[e], r = i.children.length, a = this._minEntries;
          this._chooseSplitAxis(i, a, r);
          const o = this._chooseSplitIndex(i, a, r), s = cf(i.children.splice(o, i.children.length - o));
          s.height = i.height, s.leaf = i.leaf, hf(i, this.toBBox), hf(s, this.toBBox), e ? t[e - 1].children.push(s) : this._splitRoot(i, s);
        }
        _splitRoot(t, e) {
          this.data = cf([t, e]), this.data.height = t.height + 1, this.data.leaf = false, hf(this.data, this.toBBox);
        }
        _chooseSplitIndex(t, e, i) {
          let r, a = 1 / 0, o = 1 / 0;
          for (let s = e; s <= i - e; s++) {
            const l = _A(t, 0, s, this.toBBox), u = _A(t, s, i, this.toBBox), h = TJ(l, u), c = Cw(l) + Cw(u);
            h < a ? (a = h, r = s, o = c < o ? c : o) : h === a && c < o && (o = c, r = s);
          }
          return r || i - e;
        }
        _chooseSplitAxis(t, e, i) {
          const r = t.leaf ? this.compareMinX : CJ, a = t.leaf ? this.compareMinY : SJ, o = this._allDistMargin(t, e, i, r), s = this._allDistMargin(t, e, i, a);
          o < s && t.children.sort(r);
        }
        _allDistMargin(t, e, i, r) {
          t.children.sort(r);
          const a = this.toBBox, o = _A(t, 0, e, a), s = _A(t, i - e, i, a);
          let l = Om(o) + Om(s);
          for (let u = e; u < i - e; u++) {
            const h = t.children[u];
            EA(o, t.leaf ? a(h) : h), l += Om(o);
          }
          for (let u = i - e - 1; u >= e; u--) {
            const h = t.children[u];
            EA(s, t.leaf ? a(h) : h), l += Om(s);
          }
          return l;
        }
        _adjustParentBBoxes(t, e, i) {
          for (let r = i; r >= 0; r--) EA(e[r], t);
        }
        _condense(t) {
          for (let e = t.length - 1, i; e >= 0; e--) t[e].children.length === 0 ? e > 0 ? (i = t[e - 1].children, i.splice(i.indexOf(t[e]), 1)) : this.clear() : hf(t[e], this.toBBox);
        }
      };
      function wJ(n, t, e) {
        if (!e) return t.indexOf(n);
        for (let i = 0; i < t.length; i++) if (e(n, t[i])) return i;
        return -1;
      }
      function hf(n, t) {
        _A(n, 0, n.children.length, t, n);
      }
      function _A(n, t, e, i, r) {
        r || (r = cf(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0;
        for (let a = t; a < e; a++) {
          const o = n.children[a];
          EA(r, n.leaf ? i(o) : o);
        }
        return r;
      }
      function EA(n, t) {
        return n.minX = Math.min(n.minX, t.minX), n.minY = Math.min(n.minY, t.minY), n.maxX = Math.max(n.maxX, t.maxX), n.maxY = Math.max(n.maxY, t.maxY), n;
      }
      function CJ(n, t) {
        return n.minX - t.minX;
      }
      function SJ(n, t) {
        return n.minY - t.minY;
      }
      function Cw(n) {
        return (n.maxX - n.minX) * (n.maxY - n.minY);
      }
      function Om(n) {
        return n.maxX - n.minX + (n.maxY - n.minY);
      }
      function bJ(n, t) {
        return (Math.max(t.maxX, n.maxX) - Math.min(t.minX, n.minX)) * (Math.max(t.maxY, n.maxY) - Math.min(t.minY, n.minY));
      }
      function TJ(n, t) {
        const e = Math.max(n.minX, t.minX), i = Math.max(n.minY, t.minY), r = Math.min(n.maxX, t.maxX), a = Math.min(n.maxY, t.maxY);
        return Math.max(0, r - e) * Math.max(0, a - i);
      }
      function Sw(n, t) {
        return n.minX <= t.minX && n.minY <= t.minY && t.maxX <= n.maxX && t.maxY <= n.maxY;
      }
      function Qm(n, t) {
        return t.minX <= n.maxX && t.minY <= n.maxY && t.maxX >= n.minX && t.maxY >= n.minY;
      }
      function cf(n) {
        return { children: n, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
      }
      function aF(n, t, e, i, r) {
        const a = [t, e];
        for (; a.length; ) {
          if (e = a.pop(), t = a.pop(), e - t <= i) continue;
          const o = t + Math.ceil((e - t) / i / 2) * i;
          iF(n, o, t, e, r), a.push(t, o, o, e);
        }
      }
      function oF(n, t, e, i) {
        return e !== void 0 && i !== void 0 ? [e / n, i / t] : e !== void 0 ? e / n : i !== void 0 ? i / t : 1;
      }
      class Qr extends Rm {
        constructor(t) {
          t = t || {};
          const e = t.opacity !== void 0 ? t.opacity : 1, i = t.rotation !== void 0 ? t.rotation : 0, r = t.scale !== void 0 ? t.scale : 1, a = t.rotateWithView !== void 0 ? t.rotateWithView : false;
          super({ opacity: e, rotation: i, scale: r, displacement: t.displacement !== void 0 ? t.displacement : [0, 0], rotateWithView: a, declutterMode: t.declutterMode }), this.anchor_ = t.anchor !== void 0 ? t.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = t.anchorOrigin !== void 0 ? t.anchorOrigin : "top-left", this.anchorXUnits_ = t.anchorXUnits !== void 0 ? t.anchorXUnits : "fraction", this.anchorYUnits_ = t.anchorYUnits !== void 0 ? t.anchorYUnits : "fraction", this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : null;
          const o = t.img !== void 0 ? t.img : null;
          let s = t.src;
          ue(!(s !== void 0 && o), "`image` and `src` cannot be provided at the same time"), (s === void 0 || s.length === 0) && o && (s = o.src || xt(o)), ue(s !== void 0 && s.length > 0, "A defined and non-empty `src` or `image` must be provided"), ue(!((t.width !== void 0 || t.height !== void 0) && t.scale !== void 0), "`width` or `height` cannot be provided together with `scale`");
          let l;
          if (t.src !== void 0 ? l = Mt.IDLE : o !== void 0 && ("complete" in o ? o.complete ? l = o.src ? Mt.LOADED : Mt.IDLE : l = Mt.LOADING : l = Mt.LOADED), this.color_ = t.color !== void 0 ? ia(t.color) : null, this.iconImage_ = gw(o, s, this.crossOrigin_, l, this.color_), this.offset_ = t.offset !== void 0 ? t.offset : [0, 0], this.offsetOrigin_ = t.offsetOrigin !== void 0 ? t.offsetOrigin : "top-left", this.origin_ = null, this.size_ = t.size !== void 0 ? t.size : null, this.initialOptions_, t.width !== void 0 || t.height !== void 0) {
            let u, h;
            if (t.size) [u, h] = t.size;
            else {
              const c = this.getImage(1);
              if (c.width && c.height) u = c.width, h = c.height;
              else if (c instanceof HTMLImageElement) {
                this.initialOptions_ = t;
                const f = () => {
                  if (this.unlistenImageChange(f), !this.initialOptions_) return;
                  const g = this.iconImage_.getSize();
                  this.setScale(oF(g[0], g[1], t.width, t.height));
                };
                this.listenImageChange(f);
                return;
              }
            }
            u !== void 0 && this.setScale(oF(u, h, t.width, t.height));
          }
        }
        clone() {
          let t, e, i;
          return this.initialOptions_ ? (e = this.initialOptions_.width, i = this.initialOptions_.height) : (t = this.getScale(), t = Array.isArray(t) ? t.slice() : t), new Qr({ anchor: this.anchor_.slice(), anchorOrigin: this.anchorOrigin_, anchorXUnits: this.anchorXUnits_, anchorYUnits: this.anchorYUnits_, color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0, crossOrigin: this.crossOrigin_, offset: this.offset_.slice(), offsetOrigin: this.offsetOrigin_, opacity: this.getOpacity(), rotateWithView: this.getRotateWithView(), rotation: this.getRotation(), scale: t, width: e, height: i, size: this.size_ !== null ? this.size_.slice() : void 0, src: this.getSrc(), displacement: this.getDisplacement().slice(), declutterMode: this.getDeclutterMode() });
        }
        getAnchor() {
          let t = this.normalizedAnchor_;
          if (!t) {
            t = this.anchor_;
            const r = this.getSize();
            if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
              if (!r) return null;
              t = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (t[0] *= r[0]), this.anchorYUnits_ == "fraction" && (t[1] *= r[1]);
            }
            if (this.anchorOrigin_ != "top-left") {
              if (!r) return null;
              t === this.anchor_ && (t = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (t[0] = -t[0] + r[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (t[1] = -t[1] + r[1]);
            }
            this.normalizedAnchor_ = t;
          }
          const e = this.getDisplacement(), i = this.getScaleArray();
          return [t[0] - e[0] / i[0], t[1] + e[1] / i[1]];
        }
        setAnchor(t) {
          this.anchor_ = t, this.normalizedAnchor_ = null;
        }
        getColor() {
          return this.color_;
        }
        getImage(t) {
          return this.iconImage_.getImage(t);
        }
        getPixelRatio(t) {
          return this.iconImage_.getPixelRatio(t);
        }
        getImageSize() {
          return this.iconImage_.getSize();
        }
        getImageState() {
          return this.iconImage_.getImageState();
        }
        getHitDetectionImage() {
          return this.iconImage_.getHitDetectionImage();
        }
        getOrigin() {
          if (this.origin_) return this.origin_;
          let t = this.offset_;
          if (this.offsetOrigin_ != "top-left") {
            const e = this.getSize(), i = this.iconImage_.getSize();
            if (!e || !i) return null;
            t = t.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (t[0] = i[0] - e[0] - t[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (t[1] = i[1] - e[1] - t[1]);
          }
          return this.origin_ = t, this.origin_;
        }
        getSrc() {
          return this.iconImage_.getSrc();
        }
        getSize() {
          return this.size_ ? this.size_ : this.iconImage_.getSize();
        }
        getWidth() {
          const t = this.getScaleArray();
          if (this.size_) return this.size_[0] * t[0];
          if (this.iconImage_.getImageState() == Mt.LOADED) return this.iconImage_.getSize()[0] * t[0];
        }
        getHeight() {
          const t = this.getScaleArray();
          if (this.size_) return this.size_[1] * t[1];
          if (this.iconImage_.getImageState() == Mt.LOADED) return this.iconImage_.getSize()[1] * t[1];
        }
        setScale(t) {
          delete this.initialOptions_, super.setScale(t);
        }
        listenImageChange(t) {
          this.iconImage_.addEventListener(Rt.CHANGE, t);
        }
        load() {
          this.iconImage_.load();
        }
        unlistenImageChange(t) {
          this.iconImage_.removeEventListener(Rt.CHANGE, t);
        }
        ready() {
          return this.iconImage_.ready();
        }
      }
      let Ku = 0;
      const vi = 1 << Ku++, Bt = 1 << Ku++, Wn = 1 << Ku++, hn = 1 << Ku++, Gi = 1 << Ku++, za = 1 << Ku++, zm = Math.pow(2, Ku) - 1, bw = { [vi]: "boolean", [Bt]: "number", [Wn]: "string", [hn]: "color", [Gi]: "number[]", [za]: "size" }, BJ = Object.keys(bw).map(Number).sort(Rr);
      function MJ(n) {
        return n in bw;
      }
      function ff(n) {
        const t = [];
        for (const e of BJ) IA(n, e) && t.push(bw[e]);
        return t.length === 0 ? "untyped" : t.length < 3 ? t.join(" or ") : t.slice(0, -1).join(", ") + ", or " + t[t.length - 1];
      }
      function IA(n, t) {
        return (n & t) === t;
      }
      function xl(n, t) {
        return n === t;
      }
      class Xn {
        constructor(t, e) {
          if (!MJ(t)) throw new Error(`literal expressions must have a specific type, got ${ff(t)}`);
          this.type = t, this.value = e;
        }
      }
      class sF {
        constructor(t, e, ...i) {
          this.type = t, this.operator = e, this.args = i;
        }
      }
      function Tw() {
        return { variables: /* @__PURE__ */ new Set(), properties: /* @__PURE__ */ new Set(), featureId: false, geometryType: false };
      }
      function li(n, t, e) {
        switch (typeof n) {
          case "boolean": {
            if (xl(t, Wn)) return new Xn(Wn, n ? "true" : "false");
            if (!IA(t, vi)) throw new Error(`got a boolean, but expected ${ff(t)}`);
            return new Xn(vi, n);
          }
          case "number": {
            if (xl(t, za)) return new Xn(za, Rn(n));
            if (xl(t, vi)) return new Xn(vi, !!n);
            if (xl(t, Wn)) return new Xn(Wn, n.toString());
            if (!IA(t, Bt)) throw new Error(`got a number, but expected ${ff(t)}`);
            return new Xn(Bt, n);
          }
          case "string": {
            if (xl(t, hn)) return new Xn(hn, sw(n));
            if (xl(t, vi)) return new Xn(vi, !!n);
            if (!IA(t, Wn)) throw new Error(`got a string, but expected ${ff(t)}`);
            return new Xn(Wn, n);
          }
        }
        if (!Array.isArray(n)) throw new Error("expression must be an array or a primitive value");
        if (n.length === 0) throw new Error("empty expression");
        if (typeof n[0] == "string") return GJ(n, t, e);
        for (const i of n) if (typeof i != "number") throw new Error("expected an array of numbers");
        if (xl(t, za)) {
          if (n.length !== 2) throw new Error(`expected an array of two values for a size, got ${n.length}`);
          return new Xn(za, n);
        }
        if (xl(t, hn)) {
          if (n.length === 3) return new Xn(hn, [...n, 1]);
          if (n.length === 4) return new Xn(hn, n);
          throw new Error(`expected an array of 3 or 4 values for a color, got ${n.length}`);
        }
        if (!IA(t, Gi)) throw new Error(`got an array of numbers, but expected ${ff(t)}`);
        return new Xn(Gi, n);
      }
      const H = { Get: "get", Var: "var", Concat: "concat", GeometryType: "geometry-type", LineMetric: "line-metric", Any: "any", All: "all", Not: "!", Resolution: "resolution", Zoom: "zoom", Time: "time", Equal: "==", NotEqual: "!=", GreaterThan: ">", GreaterThanOrEqualTo: ">=", LessThan: "<", LessThanOrEqualTo: "<=", Multiply: "*", Divide: "/", Add: "+", Subtract: "-", Clamp: "clamp", Mod: "%", Pow: "^", Abs: "abs", Floor: "floor", Ceil: "ceil", Round: "round", Sin: "sin", Cos: "cos", Atan: "atan", Sqrt: "sqrt", Match: "match", Between: "between", Interpolate: "interpolate", Coalesce: "coalesce", Case: "case", In: "in", Number: "number", String: "string", Array: "array", Color: "color", Id: "id", Band: "band", Palette: "palette", ToString: "to-string", Has: "has" }, DJ = { [H.Get]: ie(ge(1, 1 / 0), lF), [H.Var]: ie(ge(1, 1), RJ), [H.Has]: ie(ge(1, 1 / 0), lF), [H.Id]: ie(LJ, gf), [H.Concat]: ie(ge(2, 1 / 0), Ue(Wn)), [H.GeometryType]: ie(PJ, gf), [H.LineMetric]: ie(gf), [H.Resolution]: ie(gf), [H.Zoom]: ie(gf), [H.Time]: ie(gf), [H.Any]: ie(ge(2, 1 / 0), Ue(vi)), [H.All]: ie(ge(2, 1 / 0), Ue(vi)), [H.Not]: ie(ge(1, 1), Ue(vi)), [H.Equal]: ie(ge(2, 2), Ue(zm)), [H.NotEqual]: ie(ge(2, 2), Ue(zm)), [H.GreaterThan]: ie(ge(2, 2), Ue(Bt)), [H.GreaterThanOrEqualTo]: ie(ge(2, 2), Ue(Bt)), [H.LessThan]: ie(ge(2, 2), Ue(Bt)), [H.LessThanOrEqualTo]: ie(ge(2, 2), Ue(Bt)), [H.Multiply]: ie(ge(2, 1 / 0), uF), [H.Coalesce]: ie(ge(2, 1 / 0), uF), [H.Divide]: ie(ge(2, 2), Ue(Bt)), [H.Add]: ie(ge(2, 1 / 0), Ue(Bt)), [H.Subtract]: ie(ge(2, 2), Ue(Bt)), [H.Clamp]: ie(ge(3, 3), Ue(Bt)), [H.Mod]: ie(ge(2, 2), Ue(Bt)), [H.Pow]: ie(ge(2, 2), Ue(Bt)), [H.Abs]: ie(ge(1, 1), Ue(Bt)), [H.Floor]: ie(ge(1, 1), Ue(Bt)), [H.Ceil]: ie(ge(1, 1), Ue(Bt)), [H.Round]: ie(ge(1, 1), Ue(Bt)), [H.Sin]: ie(ge(1, 1), Ue(Bt)), [H.Cos]: ie(ge(1, 1), Ue(Bt)), [H.Atan]: ie(ge(1, 2), Ue(Bt)), [H.Sqrt]: ie(ge(1, 1), Ue(Bt)), [H.Match]: ie(ge(4, 1 / 0), hF, FJ), [H.Between]: ie(ge(3, 3), Ue(Bt)), [H.Interpolate]: ie(ge(6, 1 / 0), hF, kJ), [H.Case]: ie(ge(3, 1 / 0), NJ, OJ), [H.In]: ie(ge(2, 2), QJ), [H.Number]: ie(ge(1, 1 / 0), Ue(zm)), [H.String]: ie(ge(1, 1 / 0), Ue(zm)), [H.Array]: ie(ge(1, 1 / 0), Ue(Bt)), [H.Color]: ie(ge(1, 4), Ue(Bt)), [H.Band]: ie(ge(1, 3), Ue(Bt)), [H.Palette]: ie(ge(2, 2), zJ), [H.ToString]: ie(ge(1, 1), Ue(vi | Bt | Wn | hn)) };
      function lF(n, t, e) {
        const i = n.length - 1, r = new Array(i);
        for (let a = 0; a < i; ++a) {
          const o = n[a + 1];
          switch (typeof o) {
            case "number": {
              r[a] = new Xn(Bt, o);
              break;
            }
            case "string": {
              r[a] = new Xn(Wn, o);
              break;
            }
            default:
              throw new Error(`expected a string key or numeric array index for a get operation, got ${o}`);
          }
          a === 0 && e.properties.add(String(o));
        }
        return r;
      }
      function RJ(n, t, e) {
        const i = n[1];
        if (typeof i != "string") throw new Error("expected a string argument for var operation");
        return e.variables.add(i), [new Xn(Wn, i)];
      }
      function LJ(n, t, e) {
        e.featureId = true;
      }
      function PJ(n, t, e) {
        e.geometryType = true;
      }
      function gf(n, t, e) {
        const i = n[0];
        if (n.length !== 1) throw new Error(`expected no arguments for ${i} operation`);
        return [];
      }
      function ge(n, t) {
        return function(e, i, r) {
          const a = e[0], o = e.length - 1;
          if (n === t) {
            if (o !== n) {
              const s = n === 1 ? "" : "s";
              throw new Error(`expected ${n} argument${s} for ${a}, got ${o}`);
            }
          } else if (o < n || o > t) {
            const s = t === 1 / 0 ? `${n} or more` : `${n} to ${t}`;
            throw new Error(`expected ${s} arguments for ${a}, got ${o}`);
          }
        };
      }
      function uF(n, t, e) {
        const i = n.length - 1, r = new Array(i);
        for (let a = 0; a < i; ++a) {
          const o = li(n[a + 1], t, e);
          r[a] = o;
        }
        return r;
      }
      function Ue(n) {
        return function(t, e, i) {
          const r = t.length - 1, a = new Array(r);
          for (let o = 0; o < r; ++o) {
            const s = li(t[o + 1], n, i);
            a[o] = s;
          }
          return a;
        };
      }
      function NJ(n, t, e) {
        const i = n[0], r = n.length - 1;
        if (r % 2 === 0) throw new Error(`expected an odd number of arguments for ${i}, got ${r} instead`);
      }
      function hF(n, t, e) {
        const i = n[0], r = n.length - 1;
        if (r % 2 === 1) throw new Error(`expected an even number of arguments for operation ${i}, got ${r} instead`);
      }
      function FJ(n, t, e) {
        const i = n.length - 1, r = Wn | Bt | vi, a = li(n[1], r, e), o = li(n[n.length - 1], t, e), s = new Array(i - 2);
        for (let l = 0; l < i - 2; l += 2) {
          try {
            const u = li(n[l + 2], a.type, e);
            s[l] = u;
          } catch (u) {
            throw new Error(`failed to parse argument ${l + 1} of match expression: ${u.message}`);
          }
          try {
            const u = li(n[l + 3], o.type, e);
            s[l + 1] = u;
          } catch (u) {
            throw new Error(`failed to parse argument ${l + 2} of match expression: ${u.message}`);
          }
        }
        return [a, ...s, o];
      }
      function kJ(n, t, e) {
        const i = n[1];
        let r;
        switch (i[0]) {
          case "linear":
            r = 1;
            break;
          case "exponential":
            const l = i[1];
            if (typeof l != "number" || l <= 0) throw new Error(`expected a number base for exponential interpolation, got ${JSON.stringify(l)} instead`);
            r = l;
            break;
          default:
            throw new Error(`invalid interpolation type: ${JSON.stringify(i)}`);
        }
        const a = new Xn(Bt, r);
        let o;
        try {
          o = li(n[2], Bt, e);
        } catch (l) {
          throw new Error(`failed to parse argument 1 in interpolate expression: ${l.message}`);
        }
        const s = new Array(n.length - 3);
        for (let l = 0; l < s.length; l += 2) {
          try {
            const u = li(n[l + 3], Bt, e);
            s[l] = u;
          } catch (u) {
            throw new Error(`failed to parse argument ${l + 2} for interpolate expression: ${u.message}`);
          }
          try {
            const u = li(n[l + 4], t, e);
            s[l + 1] = u;
          } catch (u) {
            throw new Error(`failed to parse argument ${l + 3} for interpolate expression: ${u.message}`);
          }
        }
        return [a, o, ...s];
      }
      function OJ(n, t, e) {
        const i = li(n[n.length - 1], t, e), r = new Array(n.length - 1);
        for (let a = 0; a < r.length - 1; a += 2) {
          try {
            const o = li(n[a + 1], vi, e);
            r[a] = o;
          } catch (o) {
            throw new Error(`failed to parse argument ${a} of case expression: ${o.message}`);
          }
          try {
            const o = li(n[a + 2], i.type, e);
            r[a + 1] = o;
          } catch (o) {
            throw new Error(`failed to parse argument ${a + 1} of case expression: ${o.message}`);
          }
        }
        return r[r.length - 1] = i, r;
      }
      function QJ(n, t, e) {
        let i = n[2];
        if (!Array.isArray(i)) throw new Error('the second argument for the "in" operator must be an array');
        let r;
        if (typeof i[0] == "string") {
          if (i[0] !== "literal") throw new Error('for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions');
          if (!Array.isArray(i[1])) throw new Error('failed to parse "in" expression: the literal operator must be followed by an array');
          i = i[1], r = Wn;
        } else r = Bt;
        const a = new Array(i.length);
        for (let s = 0; s < a.length; s++) try {
          const l = li(i[s], r, e);
          a[s] = l;
        } catch (l) {
          throw new Error(`failed to parse haystack item ${s} for "in" expression: ${l.message}`);
        }
        return [li(n[1], r, e), ...a];
      }
      function zJ(n, t, e) {
        let i;
        try {
          i = li(n[1], Bt, e);
        } catch (o) {
          throw new Error(`failed to parse first argument in palette expression: ${o.message}`);
        }
        const r = n[2];
        if (!Array.isArray(r)) throw new Error("the second argument of palette must be an array");
        const a = new Array(r.length);
        for (let o = 0; o < a.length; o++) {
          let s;
          try {
            s = li(r[o], hn, e);
          } catch (l) {
            throw new Error(`failed to parse color at index ${o} in palette expression: ${l.message}`);
          }
          if (!(s instanceof Xn)) throw new Error(`the palette color at index ${o} must be a literal value`);
          a[o] = s;
        }
        return [i, ...a];
      }
      function ie(...n) {
        return function(t, e, i) {
          const r = t[0];
          let a;
          for (let o = 0; o < n.length; o++) {
            const s = n[o](t, e, i);
            if (o == n.length - 1) {
              if (!s) throw new Error("expected last argument validator to return the parsed args");
              a = s;
            }
          }
          return new sF(e, r, ...a);
        };
      }
      function GJ(n, t, e) {
        const i = n[0], r = DJ[i];
        if (!r) throw new Error(`unknown operator: ${i}`);
        return r(n, t, e);
      }
      function Bw(n) {
        if (!n) return "";
        const t = n.getType();
        switch (t) {
          case "Point":
          case "LineString":
          case "Polygon":
            return t;
          case "MultiPoint":
          case "MultiLineString":
          case "MultiPolygon":
            return t.substring(5);
          case "Circle":
            return "Polygon";
          case "GeometryCollection":
            return Bw(n.getGeometries()[0]);
          default:
            return "";
        }
      }
      function cF() {
        return { variables: {}, properties: {}, resolution: NaN, featureId: null, geometryType: "" };
      }
      function ws(n, t, e) {
        const i = li(n, t, e);
        return Ga(i);
      }
      function Ga(n, t) {
        if (n instanceof Xn) {
          if (n.type === hn && typeof n.value == "string") {
            const i = sw(n.value);
            return function() {
              return i;
            };
          }
          return function() {
            return n.value;
          };
        }
        const e = n.operator;
        switch (e) {
          case H.Number:
          case H.String:
          case H.Coalesce:
            return UJ(n);
          case H.Get:
          case H.Var:
          case H.Has:
            return VJ(n);
          case H.Id:
            return (i) => i.featureId;
          case H.GeometryType:
            return (i) => i.geometryType;
          case H.Concat: {
            const i = n.args.map((r) => Ga(r));
            return (r) => "".concat(...i.map((a) => a(r).toString()));
          }
          case H.Resolution:
            return (i) => i.resolution;
          case H.Any:
          case H.All:
          case H.Between:
          case H.In:
          case H.Not:
            return qJ(n);
          case H.Equal:
          case H.NotEqual:
          case H.LessThan:
          case H.LessThanOrEqualTo:
          case H.GreaterThan:
          case H.GreaterThanOrEqualTo:
            return jJ(n);
          case H.Multiply:
          case H.Divide:
          case H.Add:
          case H.Subtract:
          case H.Clamp:
          case H.Mod:
          case H.Pow:
          case H.Abs:
          case H.Floor:
          case H.Ceil:
          case H.Round:
          case H.Sin:
          case H.Cos:
          case H.Atan:
          case H.Sqrt:
            return HJ(n);
          case H.Case:
            return YJ(n);
          case H.Match:
            return WJ(n);
          case H.Interpolate:
            return XJ(n);
          case H.ToString:
            return $J(n);
          default:
            throw new Error(`Unsupported operator ${e}`);
        }
      }
      function UJ(n, t) {
        const e = n.operator, i = n.args.length, r = new Array(i);
        for (let a = 0; a < i; ++a) r[a] = Ga(n.args[a]);
        switch (e) {
          case H.Coalesce:
            return (a) => {
              for (let o = 0; o < i; ++o) {
                const s = r[o](a);
                if (typeof s != "undefined" && s !== null) return s;
              }
              throw new Error("Expected one of the values to be non-null");
            };
          case H.Number:
          case H.String:
            return (a) => {
              for (let o = 0; o < i; ++o) {
                const s = r[o](a);
                if (typeof s === e) return s;
              }
              throw new Error(`Expected one of the values to be a ${e}`);
            };
          default:
            throw new Error(`Unsupported assertion operator ${e}`);
        }
      }
      function VJ(n, t) {
        const i = n.args[0].value;
        switch (n.operator) {
          case H.Get:
            return (r) => {
              const a = n.args;
              let o = r.properties[i];
              for (let s = 1, l = a.length; s < l; ++s) {
                const h = a[s].value;
                o = o[h];
              }
              return o;
            };
          case H.Var:
            return (r) => r.variables[i];
          case H.Has:
            return (r) => {
              const a = n.args;
              if (!(i in r.properties)) return false;
              let o = r.properties[i];
              for (let s = 1, l = a.length; s < l; ++s) {
                const h = a[s].value;
                if (!o || !Object.hasOwn(o, h)) return false;
                o = o[h];
              }
              return true;
            };
          default:
            throw new Error(`Unsupported accessor operator ${n.operator}`);
        }
      }
      function jJ(n, t) {
        const e = n.operator, i = Ga(n.args[0]), r = Ga(n.args[1]);
        switch (e) {
          case H.Equal:
            return (a) => i(a) === r(a);
          case H.NotEqual:
            return (a) => i(a) !== r(a);
          case H.LessThan:
            return (a) => i(a) < r(a);
          case H.LessThanOrEqualTo:
            return (a) => i(a) <= r(a);
          case H.GreaterThan:
            return (a) => i(a) > r(a);
          case H.GreaterThanOrEqualTo:
            return (a) => i(a) >= r(a);
          default:
            throw new Error(`Unsupported comparison operator ${e}`);
        }
      }
      function qJ(n, t) {
        const e = n.operator, i = n.args.length, r = new Array(i);
        for (let a = 0; a < i; ++a) r[a] = Ga(n.args[a]);
        switch (e) {
          case H.Any:
            return (a) => {
              for (let o = 0; o < i; ++o) if (r[o](a)) return true;
              return false;
            };
          case H.All:
            return (a) => {
              for (let o = 0; o < i; ++o) if (!r[o](a)) return false;
              return true;
            };
          case H.Between:
            return (a) => {
              const o = r[0](a), s = r[1](a), l = r[2](a);
              return o >= s && o <= l;
            };
          case H.In:
            return (a) => {
              const o = r[0](a);
              for (let s = 1; s < i; ++s) if (o === r[s](a)) return true;
              return false;
            };
          case H.Not:
            return (a) => !r[0](a);
          default:
            throw new Error(`Unsupported logical operator ${e}`);
        }
      }
      function HJ(n, t) {
        const e = n.operator, i = n.args.length, r = new Array(i);
        for (let a = 0; a < i; ++a) r[a] = Ga(n.args[a]);
        switch (e) {
          case H.Multiply:
            return (a) => {
              let o = 1;
              for (let s = 0; s < i; ++s) o *= r[s](a);
              return o;
            };
          case H.Divide:
            return (a) => r[0](a) / r[1](a);
          case H.Add:
            return (a) => {
              let o = 0;
              for (let s = 0; s < i; ++s) o += r[s](a);
              return o;
            };
          case H.Subtract:
            return (a) => r[0](a) - r[1](a);
          case H.Clamp:
            return (a) => {
              const o = r[0](a), s = r[1](a);
              if (o < s) return s;
              const l = r[2](a);
              return o > l ? l : o;
            };
          case H.Mod:
            return (a) => r[0](a) % r[1](a);
          case H.Pow:
            return (a) => Math.pow(r[0](a), r[1](a));
          case H.Abs:
            return (a) => Math.abs(r[0](a));
          case H.Floor:
            return (a) => Math.floor(r[0](a));
          case H.Ceil:
            return (a) => Math.ceil(r[0](a));
          case H.Round:
            return (a) => Math.round(r[0](a));
          case H.Sin:
            return (a) => Math.sin(r[0](a));
          case H.Cos:
            return (a) => Math.cos(r[0](a));
          case H.Atan:
            return i === 2 ? (a) => Math.atan2(r[0](a), r[1](a)) : (a) => Math.atan(r[0](a));
          case H.Sqrt:
            return (a) => Math.sqrt(r[0](a));
          default:
            throw new Error(`Unsupported numeric operator ${e}`);
        }
      }
      function YJ(n, t) {
        const e = n.args.length, i = new Array(e);
        for (let r = 0; r < e; ++r) i[r] = Ga(n.args[r]);
        return (r) => {
          for (let a = 0; a < e - 1; a += 2) if (i[a](r)) return i[a + 1](r);
          return i[e - 1](r);
        };
      }
      function WJ(n, t) {
        const e = n.args.length, i = new Array(e);
        for (let r = 0; r < e; ++r) i[r] = Ga(n.args[r]);
        return (r) => {
          const a = i[0](r);
          for (let o = 1; o < e; o += 2) if (a === i[o](r)) return i[o + 1](r);
          return i[e - 1](r);
        };
      }
      function XJ(n, t) {
        const e = n.args.length, i = new Array(e);
        for (let r = 0; r < e; ++r) i[r] = Ga(n.args[r]);
        return (r) => {
          const a = i[0](r), o = i[1](r);
          let s, l;
          for (let u = 2; u < e; u += 2) {
            const h = i[u](r);
            let c = i[u + 1](r);
            const f = Array.isArray(c);
            if (f && (c = GK(c)), h >= o) return u === 2 ? c : f ? ZJ(a, o, s, l, h, c) : xA(a, o, s, l, h, c);
            s = h, l = c;
          }
          return l;
        };
      }
      function $J(n, t) {
        const e = n.operator, i = n.args.length, r = new Array(i);
        for (let a = 0; a < i; ++a) r[a] = Ga(n.args[a]);
        switch (e) {
          case H.ToString:
            return (a) => {
              const o = r[0](a);
              return n.args[0].type === hn ? lw(o) : o.toString();
            };
          default:
            throw new Error(`Unsupported convert operator ${e}`);
        }
      }
      function xA(n, t, e, i, r, a) {
        const o = r - e;
        if (o === 0) return i;
        const s = t - e, l = n === 1 ? s / o : (Math.pow(n, s) - 1) / (Math.pow(n, o) - 1);
        return i + l * (a - i);
      }
      function ZJ(n, t, e, i, r, a) {
        if (r - e === 0) return i;
        const s = DN(i), l = DN(a);
        let u = l[2] - s[2];
        u > 180 ? u -= 360 : u < -180 && (u += 360);
        const h = [xA(n, t, e, s[0], r, l[0]), xA(n, t, e, s[1], r, l[1]), s[2] + xA(n, t, e, 0, r, u), xA(n, t, e, i[3], r, a[3])];
        return RN(UK(h));
      }
      function KJ(n) {
        return true;
      }
      function JJ(n) {
        const t = Tw(), e = ttt(n, t), i = cF();
        return function(r, a) {
          if (i.properties = r.getPropertiesInternal(), i.resolution = a, t.featureId) {
            const o = r.getId();
            o !== void 0 ? i.featureId = o : i.featureId = null;
          }
          return t.geometryType && (i.geometryType = Bw(r.getGeometry())), e(i);
        };
      }
      function fF(n) {
        const t = Tw(), e = n.length, i = new Array(e);
        for (let o = 0; o < e; ++o) i[o] = Mw(n[o], t);
        const r = cF(), a = new Array(e);
        return function(o, s) {
          if (r.properties = o.getPropertiesInternal(), r.resolution = s, t.featureId) {
            const u = o.getId();
            u !== void 0 ? r.featureId = u : r.featureId = null;
          }
          let l = 0;
          for (let u = 0; u < e; ++u) {
            const h = i[u](r);
            h && (a[l] = h, l += 1);
          }
          return a.length = l, a;
        };
      }
      function ttt(n, t) {
        const e = n.length, i = new Array(e);
        for (let r = 0; r < e; ++r) {
          const a = n[r], o = "filter" in a ? ws(a.filter, vi, t) : KJ;
          let s;
          if (Array.isArray(a.style)) {
            const l = a.style.length;
            s = new Array(l);
            for (let u = 0; u < l; ++u) s[u] = Mw(a.style[u], t);
          } else s = [Mw(a.style, t)];
          i[r] = { filter: o, styles: s };
        }
        return function(r) {
          const a = [];
          let o = false;
          for (let s = 0; s < e; ++s) {
            const l = i[s].filter;
            if (l(r) && !(n[s].else && o)) {
              o = true;
              for (const u of i[s].styles) {
                const h = u(r);
                h && a.push(h);
              }
            }
          }
          return a;
        };
      }
      function Mw(n, t) {
        const e = wA(n, "", t), i = CA(n, "", t), r = ett(n, t), a = ntt(n, t), o = cr(n, "z-index", t);
        if (!e && !i && !r && !a && !vl(n)) throw new Error("No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(n));
        const s = new pe();
        return function(l) {
          let u = true;
          if (e) {
            const h = e(l);
            h && (u = false), s.setFill(h);
          }
          if (i) {
            const h = i(l);
            h && (u = false), s.setStroke(h);
          }
          if (r) {
            const h = r(l);
            h && (u = false), s.setText(h);
          }
          if (a) {
            const h = a(l);
            h && (u = false), s.setImage(h);
          }
          return o && s.setZIndex(o(l)), u ? null : s;
        };
      }
      function wA(n, t, e) {
        let i;
        if (t + "fill-pattern-src" in n) i = ott(n, t + "fill-", e);
        else {
          if (n[t + "fill-color"] === "none") return (a) => null;
          i = Dw(n, t + "fill-color", e);
        }
        if (!i) return null;
        const r = new me();
        return function(a) {
          const o = i(a);
          return o === aw ? null : (r.setColor(o), r);
        };
      }
      function CA(n, t, e) {
        const i = cr(n, t + "stroke-width", e), r = Dw(n, t + "stroke-color", e);
        if (!i && !r) return null;
        const a = Cs(n, t + "stroke-line-cap", e), o = Cs(n, t + "stroke-line-join", e), s = gF(n, t + "stroke-line-dash", e), l = cr(n, t + "stroke-line-dash-offset", e), u = cr(n, t + "stroke-miter-limit", e), h = new Ke();
        return function(c) {
          if (r) {
            const f = r(c);
            if (f === aw) return null;
            h.setColor(f);
          }
          if (i && h.setWidth(i(c)), a) {
            const f = a(c);
            if (f !== "butt" && f !== "round" && f !== "square") throw new Error("Expected butt, round, or square line cap");
            h.setLineCap(f);
          }
          if (o) {
            const f = o(c);
            if (f !== "bevel" && f !== "round" && f !== "miter") throw new Error("Expected bevel, round, or miter line join");
            h.setLineJoin(f);
          }
          return s && h.setLineDash(s(c)), l && h.setLineDashOffset(l(c)), u && h.setMiterLimit(u(c)), h;
        };
      }
      function ett(n, t) {
        const e = "text-", i = Cs(n, e + "value", t);
        if (!i) return null;
        const r = wA(n, e, t), a = wA(n, e + "background-", t), o = CA(n, e, t), s = CA(n, e + "background-", t), l = Cs(n, e + "font", t), u = cr(n, e + "max-angle", t), h = cr(n, e + "offset-x", t), c = cr(n, e + "offset-y", t), f = df(n, e + "overflow", t), g = Cs(n, e + "placement", t), d = cr(n, e + "repeat", t), A = Um(n, e + "scale", t), p = df(n, e + "rotate-with-view", t), v = cr(n, e + "rotation", t), y = Cs(n, e + "align", t), m = Cs(n, e + "justify", t), _ = Cs(n, e + "baseline", t), I = df(n, e + "keep-upright", t), E = gF(n, e + "padding", t), x = jm(n, e + "declutter-mode"), w = new Si({ declutterMode: x });
        return function(C) {
          if (w.setText(i(C)), r && w.setFill(r(C)), a && w.setBackgroundFill(a(C)), o && w.setStroke(o(C)), s && w.setBackgroundStroke(s(C)), l && w.setFont(l(C)), u && w.setMaxAngle(u(C)), h && w.setOffsetX(h(C)), c && w.setOffsetY(c(C)), f && w.setOverflow(f(C)), g) {
            const S = g(C);
            if (S !== "point" && S !== "line") throw new Error("Expected point or line for text-placement");
            w.setPlacement(S);
          }
          if (d && w.setRepeat(d(C)), A && w.setScale(A(C)), p && w.setRotateWithView(p(C)), v && w.setRotation(v(C)), y) {
            const S = y(C);
            if (S !== "left" && S !== "center" && S !== "right" && S !== "end" && S !== "start") throw new Error("Expected left, right, center, start, or end for text-align");
            w.setTextAlign(S);
          }
          if (m) {
            const S = m(C);
            if (S !== "left" && S !== "right" && S !== "center") throw new Error("Expected left, right, or center for text-justify");
            w.setJustify(S);
          }
          if (_) {
            const S = _(C);
            if (S !== "bottom" && S !== "top" && S !== "middle" && S !== "alphabetic" && S !== "hanging") throw new Error("Expected bottom, top, middle, alphabetic, or hanging for text-baseline");
            w.setTextBaseline(S);
          }
          return E && w.setPadding(E(C)), I && w.setKeepUpright(I(C)), w;
        };
      }
      function ntt(n, t) {
        return "icon-src" in n ? itt(n, t) : "shape-points" in n ? rtt(n, t) : "circle-radius" in n ? att(n, t) : null;
      }
      function itt(n, t) {
        const e = "icon-", i = e + "src", r = vF(n[i], i), a = Gm(n, e + "anchor", t), o = Um(n, e + "scale", t), s = cr(n, e + "opacity", t), l = Gm(n, e + "displacement", t), u = cr(n, e + "rotation", t), h = df(n, e + "rotate-with-view", t), c = AF(n, e + "anchor-origin"), f = pF(n, e + "anchor-x-units"), g = pF(n, e + "anchor-y-units"), d = htt(n, e + "color"), A = ltt(n, e + "cross-origin"), p = utt(n, e + "offset"), v = AF(n, e + "offset-origin"), y = Vm(n, e + "width"), m = Vm(n, e + "height"), _ = stt(n, e + "size"), I = jm(n, e + "declutter-mode"), E = new Qr({ src: r, anchorOrigin: c, anchorXUnits: f, anchorYUnits: g, color: d, crossOrigin: A, offset: p, offsetOrigin: v, height: m, width: y, size: _, declutterMode: I });
        return function(x) {
          return s && E.setOpacity(s(x)), l && E.setDisplacement(l(x)), u && E.setRotation(u(x)), h && E.setRotateWithView(h(x)), o && E.setScale(o(x)), a && E.setAnchor(a(x)), E;
        };
      }
      function rtt(n, t) {
        const e = "shape-", i = e + "points", r = e + "radius", a = Rw(n[i], i), o = Rw(n[r], r), s = wA(n, e, t), l = CA(n, e, t), u = Um(n, e + "scale", t), h = Gm(n, e + "displacement", t), c = cr(n, e + "rotation", t), f = df(n, e + "rotate-with-view", t), g = Vm(n, e + "radius2"), d = Vm(n, e + "angle"), A = jm(n, e + "declutter-mode"), p = new Xu({ points: a, radius: o, radius2: g, angle: d, declutterMode: A });
        return function(v) {
          return s && p.setFill(s(v)), l && p.setStroke(l(v)), h && p.setDisplacement(h(v)), c && p.setRotation(c(v)), f && p.setRotateWithView(f(v)), u && p.setScale(u(v)), p;
        };
      }
      function att(n, t) {
        const e = "circle-", i = wA(n, e, t), r = CA(n, e, t), a = cr(n, e + "radius", t), o = Um(n, e + "scale", t), s = Gm(n, e + "displacement", t), l = cr(n, e + "rotation", t), u = df(n, e + "rotate-with-view", t), h = jm(n, e + "declutter-mode"), c = new kr({ radius: 5, declutterMode: h });
        return function(f) {
          return a && c.setRadius(a(f)), i && c.setFill(i(f)), r && c.setStroke(r(f)), s && c.setDisplacement(s(f)), l && c.setRotation(l(f)), u && c.setRotateWithView(u(f)), o && c.setScale(o(f)), c;
        };
      }
      function cr(n, t, e) {
        if (!(t in n)) return;
        const i = ws(n[t], Bt, e);
        return function(r) {
          return Rw(i(r), t);
        };
      }
      function Cs(n, t, e) {
        if (!(t in n)) return null;
        const i = ws(n[t], Wn, e);
        return function(r) {
          return vF(i(r), t);
        };
      }
      function ott(n, t, e) {
        const i = Cs(n, t + "pattern-src", e), r = dF(n, t + "pattern-offset", e), a = dF(n, t + "pattern-size", e), o = Dw(n, t + "color", e);
        return function(s) {
          return { src: i(s), offset: r && r(s), size: a && a(s), color: o && o(s) };
        };
      }
      function df(n, t, e) {
        if (!(t in n)) return null;
        const i = ws(n[t], vi, e);
        return function(r) {
          const a = i(r);
          if (typeof a != "boolean") throw new Error(`Expected a boolean for ${t}`);
          return a;
        };
      }
      function Dw(n, t, e) {
        if (!(t in n)) return null;
        const i = ws(n[t], hn, e);
        return function(r) {
          return yF(i(r), t);
        };
      }
      function gF(n, t, e) {
        if (!(t in n)) return null;
        const i = ws(n[t], Gi, e);
        return function(r) {
          return SA(i(r), t);
        };
      }
      function Gm(n, t, e) {
        if (!(t in n)) return null;
        const i = ws(n[t], Gi, e);
        return function(r) {
          const a = SA(i(r), t);
          if (a.length !== 2) throw new Error(`Expected two numbers for ${t}`);
          return a;
        };
      }
      function dF(n, t, e) {
        if (!(t in n)) return null;
        const i = ws(n[t], Gi, e);
        return function(r) {
          return mF(i(r), t);
        };
      }
      function Um(n, t, e) {
        if (!(t in n)) return null;
        const i = ws(n[t], Gi | Bt, e);
        return function(r) {
          return ctt(i(r), t);
        };
      }
      function Vm(n, t) {
        const e = n[t];
        if (e !== void 0) {
          if (typeof e != "number") throw new Error(`Expected a number for ${t}`);
          return e;
        }
      }
      function stt(n, t) {
        const e = n[t];
        if (e !== void 0) {
          if (typeof e == "number") return Rn(e);
          if (!Array.isArray(e)) throw new Error(`Expected a number or size array for ${t}`);
          if (e.length !== 2 || typeof e[0] != "number" || typeof e[1] != "number") throw new Error(`Expected a number or size array for ${t}`);
          return e;
        }
      }
      function ltt(n, t) {
        const e = n[t];
        if (e !== void 0) {
          if (typeof e != "string") throw new Error(`Expected a string for ${t}`);
          return e;
        }
      }
      function AF(n, t) {
        const e = n[t];
        if (e !== void 0) {
          if (e !== "bottom-left" && e !== "bottom-right" && e !== "top-left" && e !== "top-right") throw new Error(`Expected bottom-left, bottom-right, top-left, or top-right for ${t}`);
          return e;
        }
      }
      function pF(n, t) {
        const e = n[t];
        if (e !== void 0) {
          if (e !== "pixels" && e !== "fraction") throw new Error(`Expected pixels or fraction for ${t}`);
          return e;
        }
      }
      function utt(n, t) {
        const e = n[t];
        if (e !== void 0) return SA(e, t);
      }
      function jm(n, t) {
        const e = n[t];
        if (e !== void 0) {
          if (typeof e != "string") throw new Error(`Expected a string for ${t}`);
          if (e !== "declutter" && e !== "obstacle" && e !== "none") throw new Error(`Expected declutter, obstacle, or none for ${t}`);
          return e;
        }
      }
      function htt(n, t) {
        const e = n[t];
        if (e !== void 0) return yF(e, t);
      }
      function SA(n, t) {
        if (!Array.isArray(n)) throw new Error(`Expected an array for ${t}`);
        const e = n.length;
        for (let i = 0; i < e; ++i) if (typeof n[i] != "number") throw new Error(`Expected an array of numbers for ${t}`);
        return n;
      }
      function vF(n, t) {
        if (typeof n != "string") throw new Error(`Expected a string for ${t}`);
        return n;
      }
      function Rw(n, t) {
        if (typeof n != "number") throw new Error(`Expected a number for ${t}`);
        return n;
      }
      function yF(n, t) {
        if (typeof n == "string") return n;
        const e = SA(n, t), i = e.length;
        if (i < 3 || i > 4) throw new Error(`Expected a color with 3 or 4 values for ${t}`);
        return e;
      }
      function mF(n, t) {
        const e = SA(n, t);
        if (e.length !== 2) throw new Error(`Expected an array of two numbers for ${t}`);
        return e;
      }
      function ctt(n, t) {
        return typeof n == "number" ? n : mF(n, t);
      }
      const _F = { RENDER_ORDER: "renderOrder" };
      class bA extends Zu {
        constructor(t) {
          t = t || {};
          const e = Object.assign({}, t);
          delete e.style, delete e.renderBuffer, delete e.updateWhileAnimating, delete e.updateWhileInteracting, super(e), this.declutter_ = t.declutter ? String(t.declutter) : void 0, this.renderBuffer_ = t.renderBuffer !== void 0 ? t.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(t.style), this.updateWhileAnimating_ = t.updateWhileAnimating !== void 0 ? t.updateWhileAnimating : false, this.updateWhileInteracting_ = t.updateWhileInteracting !== void 0 ? t.updateWhileInteracting : false;
        }
        getDeclutter() {
          return this.declutter_;
        }
        getFeatures(t) {
          return super.getFeatures(t);
        }
        getRenderBuffer() {
          return this.renderBuffer_;
        }
        getRenderOrder() {
          return this.get(_F.RENDER_ORDER);
        }
        getStyle() {
          return this.style_;
        }
        getStyleFunction() {
          return this.styleFunction_;
        }
        getUpdateWhileAnimating() {
          return this.updateWhileAnimating_;
        }
        getUpdateWhileInteracting() {
          return this.updateWhileInteracting_;
        }
        renderDeclutter(t, e) {
          const i = this.getDeclutter();
          i in t.declutter || (t.declutter[i] = new rF(9)), this.getRenderer().renderDeclutter(t, e);
        }
        setRenderOrder(t) {
          this.set(_F.RENDER_ORDER, t);
        }
        setStyle(t) {
          this.style_ = t === void 0 ? XN : t;
          const e = ftt(t);
          this.styleFunction_ = t === null ? void 0 : uJ(e), this.changed();
        }
        setDeclutter(t) {
          this.declutter_ = t ? String(t) : void 0, this.changed();
        }
      }
      function ftt(n) {
        if (n === void 0) return XN;
        if (!n) return null;
        if (typeof n == "function" || n instanceof pe) return n;
        if (!Array.isArray(n)) return fF([n]);
        if (n.length === 0) return [];
        const t = n.length, e = n[0];
        if (e instanceof pe) {
          const r = new Array(t);
          for (let a = 0; a < t; ++a) {
            const o = n[a];
            if (!(o instanceof pe)) throw new Error("Expected a list of style instances");
            r[a] = o;
          }
          return r;
        }
        if ("style" in e) {
          const r = new Array(t);
          for (let a = 0; a < t; ++a) {
            const o = n[a];
            if (!("style" in o)) throw new Error("Expected a list of rules with a style property");
            r[a] = o;
          }
          return JJ(r);
        }
        return fF(n);
      }
      const Ht = { BEGIN_GEOMETRY: 0, BEGIN_PATH: 1, CIRCLE: 2, CLOSE_PATH: 3, CUSTOM: 4, DRAW_CHARS: 5, DRAW_IMAGE: 6, END_GEOMETRY: 7, FILL: 8, MOVE_TO_LINE_TO: 9, SET_FILL_STYLE: 10, SET_STROKE_STYLE: 11, STROKE: 12 }, qm = [Ht.FILL], wl = [Ht.STROKE], Ju = [Ht.BEGIN_PATH], EF = [Ht.CLOSE_PATH];
      class IF {
        drawCustom(t, e, i, r, a) {
        }
        drawGeometry(t) {
        }
        setStyle(t) {
        }
        drawCircle(t, e, i) {
        }
        drawFeature(t, e, i) {
        }
        drawGeometryCollection(t, e, i) {
        }
        drawLineString(t, e, i) {
        }
        drawMultiLineString(t, e, i) {
        }
        drawMultiPoint(t, e, i) {
        }
        drawMultiPolygon(t, e, i) {
        }
        drawPoint(t, e, i) {
        }
        drawPolygon(t, e, i) {
        }
        drawText(t, e, i) {
        }
        setFillStrokeStyle(t, e) {
        }
        setImageStyle(t, e) {
        }
        setTextStyle(t, e) {
        }
      }
      class TA extends IF {
        constructor(t, e, i, r) {
          super(), this.tolerance = t, this.maxExtent = e, this.pixelRatio = r, this.maxLineWidth = 0, this.resolution = i, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = {};
        }
        applyPixelRatio(t) {
          const e = this.pixelRatio;
          return e == 1 ? t : t.map(function(i) {
            return i * e;
          });
        }
        appendFlatPointCoordinates(t, e) {
          const i = this.getBufferedMaxExtent(), r = this.tmpCoordinate_, a = this.coordinates;
          let o = a.length;
          for (let s = 0, l = t.length; s < l; s += e) r[0] = t[s], r[1] = t[s + 1], Jr(i, r) && (a[o++] = r[0], a[o++] = r[1]);
          return o;
        }
        appendFlatLineCoordinates(t, e, i, r, a, o) {
          const s = this.coordinates;
          let l = s.length;
          const u = this.getBufferedMaxExtent();
          o && (e += r);
          let h = t[e], c = t[e + 1];
          const f = this.tmpCoordinate_;
          let g = true, d, A, p;
          for (d = e + r; d < i; d += r) f[0] = t[d], f[1] = t[d + 1], p = Cx(u, f), p !== A ? (g && (s[l++] = h, s[l++] = c, g = false), s[l++] = f[0], s[l++] = f[1]) : p === ri.INTERSECTING ? (s[l++] = f[0], s[l++] = f[1], g = false) : g = true, h = f[0], c = f[1], A = p;
          return (a && g || d === e + r) && (s[l++] = h, s[l++] = c), l;
        }
        drawCustomCoordinates_(t, e, i, r, a) {
          for (let o = 0, s = i.length; o < s; ++o) {
            const l = i[o], u = this.appendFlatLineCoordinates(t, e, l, r, false, false);
            a.push(u), e = l;
          }
          return e;
        }
        drawCustom(t, e, i, r, a) {
          this.beginGeometry(t, e, a);
          const o = t.getType(), s = t.getStride(), l = this.coordinates.length;
          let u, h, c, f, g;
          switch (o) {
            case "MultiPolygon":
              u = t.getOrientedFlatCoordinates(), f = [];
              const d = t.getEndss();
              g = 0;
              for (let A = 0, p = d.length; A < p; ++A) {
                const v = [];
                g = this.drawCustomCoordinates_(u, g, d[A], s, v), f.push(v);
              }
              this.instructions.push([Ht.CUSTOM, l, f, t, i, $x, a]), this.hitDetectionInstructions.push([Ht.CUSTOM, l, f, t, r || i, $x, a]);
              break;
            case "Polygon":
            case "MultiLineString":
              c = [], u = o == "Polygon" ? t.getOrientedFlatCoordinates() : t.getFlatCoordinates(), g = this.drawCustomCoordinates_(u, 0, t.getEnds(), s, c), this.instructions.push([Ht.CUSTOM, l, c, t, i, cA, a]), this.hitDetectionInstructions.push([Ht.CUSTOM, l, c, t, r || i, cA, a]);
              break;
            case "LineString":
            case "Circle":
              u = t.getFlatCoordinates(), h = this.appendFlatLineCoordinates(u, 0, u.length, s, false, false), this.instructions.push([Ht.CUSTOM, l, h, t, i, ms, a]), this.hitDetectionInstructions.push([Ht.CUSTOM, l, h, t, r || i, ms, a]);
              break;
            case "MultiPoint":
              u = t.getFlatCoordinates(), h = this.appendFlatPointCoordinates(u, s), h > l && (this.instructions.push([Ht.CUSTOM, l, h, t, i, ms, a]), this.hitDetectionInstructions.push([Ht.CUSTOM, l, h, t, r || i, ms, a]));
              break;
            case "Point":
              u = t.getFlatCoordinates(), this.coordinates.push(u[0], u[1]), h = this.coordinates.length, this.instructions.push([Ht.CUSTOM, l, h, t, i, void 0, a]), this.hitDetectionInstructions.push([Ht.CUSTOM, l, h, t, r || i, void 0, a]);
              break;
          }
          this.endGeometry(e);
        }
        beginGeometry(t, e, i) {
          this.beginGeometryInstruction1_ = [Ht.BEGIN_GEOMETRY, e, 0, t, i], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [Ht.BEGIN_GEOMETRY, e, 0, t, i], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
        }
        finish() {
          return { instructions: this.instructions, hitDetectionInstructions: this.hitDetectionInstructions, coordinates: this.coordinates };
        }
        reverseHitDetectionInstructions() {
          const t = this.hitDetectionInstructions;
          t.reverse();
          let e;
          const i = t.length;
          let r, a, o = -1;
          for (e = 0; e < i; ++e) r = t[e], a = r[0], a == Ht.END_GEOMETRY ? o = e : a == Ht.BEGIN_GEOMETRY && (r[2] = e, BZ(this.hitDetectionInstructions, o, e), o = -1);
        }
        setFillStrokeStyle(t, e) {
          const i = this.state;
          if (t) {
            const r = t.getColor();
            i.fillPatternScale = r && typeof r == "object" && "src" in r ? this.pixelRatio : 1, i.fillStyle = _o(r || hr);
          } else i.fillStyle = void 0;
          if (e) {
            const r = e.getColor();
            i.strokeStyle = _o(r || pA);
            const a = e.getLineCap();
            i.lineCap = a !== void 0 ? a : sf;
            const o = e.getLineDash();
            i.lineDash = o ? o.slice() : Es;
            const s = e.getLineDashOffset();
            i.lineDashOffset = s || Is;
            const l = e.getLineJoin();
            i.lineJoin = l !== void 0 ? l : lf;
            const u = e.getWidth();
            i.lineWidth = u !== void 0 ? u : yA;
            const h = e.getMiterLimit();
            i.miterLimit = h !== void 0 ? h : AA, i.lineWidth > this.maxLineWidth && (this.maxLineWidth = i.lineWidth, this.bufferedMaxExtent_ = null);
          } else i.strokeStyle = void 0, i.lineCap = void 0, i.lineDash = null, i.lineDashOffset = void 0, i.lineJoin = void 0, i.lineWidth = void 0, i.miterLimit = void 0;
        }
        createFill(t) {
          const e = t.fillStyle, i = [Ht.SET_FILL_STYLE, e];
          return typeof e != "string" && i.push(t.fillPatternScale), i;
        }
        applyStroke(t) {
          this.instructions.push(this.createStroke(t));
        }
        createStroke(t) {
          return [Ht.SET_STROKE_STYLE, t.strokeStyle, t.lineWidth * this.pixelRatio, t.lineCap, t.lineJoin, t.miterLimit, this.applyPixelRatio(t.lineDash), t.lineDashOffset * this.pixelRatio];
        }
        updateFillStyle(t, e) {
          const i = t.fillStyle;
          (typeof i != "string" || t.currentFillStyle != i) && (i !== void 0 && this.instructions.push(e.call(this, t)), t.currentFillStyle = i);
        }
        updateStrokeStyle(t, e) {
          const i = t.strokeStyle, r = t.lineCap, a = t.lineDash, o = t.lineDashOffset, s = t.lineJoin, l = t.lineWidth, u = t.miterLimit;
          (t.currentStrokeStyle != i || t.currentLineCap != r || a != t.currentLineDash && !co(t.currentLineDash, a) || t.currentLineDashOffset != o || t.currentLineJoin != s || t.currentLineWidth != l || t.currentMiterLimit != u) && (i !== void 0 && e.call(this, t), t.currentStrokeStyle = i, t.currentLineCap = r, t.currentLineDash = a, t.currentLineDashOffset = o, t.currentLineJoin = s, t.currentLineWidth = l, t.currentMiterLimit = u);
        }
        endGeometry(t) {
          this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
          const e = [Ht.END_GEOMETRY, t];
          this.instructions.push(e), this.hitDetectionInstructions.push(e);
        }
        getBufferedMaxExtent() {
          if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = zP(this.maxExtent), this.maxLineWidth > 0)) {
            const t = this.resolution * (this.maxLineWidth + 1) / 2;
            fo(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_);
          }
          return this.bufferedMaxExtent_;
        }
      }
      class gtt extends TA {
        constructor(t, e, i, r) {
          super(t, e, i, r), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
        }
        drawPoint(t, e, i) {
          if (!this.image_ || this.maxExtent && !Jr(this.maxExtent, t.getFlatCoordinates())) return;
          this.beginGeometry(t, e, i);
          const r = t.getFlatCoordinates(), a = t.getStride(), o = this.coordinates.length, s = this.appendFlatPointCoordinates(r, a);
          this.instructions.push([Ht.DRAW_IMAGE, o, s, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]), this.hitDetectionInstructions.push([Ht.DRAW_IMAGE, o, s, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, 1, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]), this.endGeometry(e);
        }
        drawMultiPoint(t, e, i) {
          if (!this.image_) return;
          this.beginGeometry(t, e, i);
          const r = t.getFlatCoordinates(), a = [];
          for (let l = 0, u = r.length; l < u; l += t.getStride()) (!this.maxExtent || Jr(this.maxExtent, r.slice(l, l + 2))) && a.push(r[l], r[l + 1]);
          const o = this.coordinates.length, s = this.appendFlatPointCoordinates(a, 2);
          this.instructions.push([Ht.DRAW_IMAGE, o, s, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]), this.hitDetectionInstructions.push([Ht.DRAW_IMAGE, o, s, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, 1, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]), this.endGeometry(e);
        }
        finish() {
          return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
        }
        setImageStyle(t, e) {
          const i = t.getAnchor(), r = t.getSize(), a = t.getOrigin();
          this.imagePixelRatio_ = t.getPixelRatio(this.pixelRatio), this.anchorX_ = i[0], this.anchorY_ = i[1], this.hitDetectionImage_ = t.getHitDetectionImage(), this.image_ = t.getImage(this.pixelRatio), this.height_ = r[1], this.opacity_ = t.getOpacity(), this.originX_ = a[0], this.originY_ = a[1], this.rotateWithView_ = t.getRotateWithView(), this.rotation_ = t.getRotation(), this.scale_ = t.getScaleArray(), this.width_ = r[0], this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = e;
        }
      }
      class dtt extends TA {
        constructor(t, e, i, r) {
          super(t, e, i, r);
        }
        drawFlatCoordinates_(t, e, i, r) {
          const a = this.coordinates.length, o = this.appendFlatLineCoordinates(t, e, i, r, false, false), s = [Ht.MOVE_TO_LINE_TO, a, o];
          return this.instructions.push(s), this.hitDetectionInstructions.push(s), i;
        }
        drawLineString(t, e, i) {
          const r = this.state, a = r.strokeStyle, o = r.lineWidth;
          if (a === void 0 || o === void 0) return;
          this.updateStrokeStyle(r, this.applyStroke), this.beginGeometry(t, e, i), this.hitDetectionInstructions.push([Ht.SET_STROKE_STYLE, r.strokeStyle, r.lineWidth, r.lineCap, r.lineJoin, r.miterLimit, Es, Is], Ju);
          const s = t.getFlatCoordinates(), l = t.getStride();
          this.drawFlatCoordinates_(s, 0, s.length, l), this.hitDetectionInstructions.push(wl), this.endGeometry(e);
        }
        drawMultiLineString(t, e, i) {
          const r = this.state, a = r.strokeStyle, o = r.lineWidth;
          if (a === void 0 || o === void 0) return;
          this.updateStrokeStyle(r, this.applyStroke), this.beginGeometry(t, e, i), this.hitDetectionInstructions.push([Ht.SET_STROKE_STYLE, r.strokeStyle, r.lineWidth, r.lineCap, r.lineJoin, r.miterLimit, Es, Is], Ju);
          const s = t.getEnds(), l = t.getFlatCoordinates(), u = t.getStride();
          let h = 0;
          for (let c = 0, f = s.length; c < f; ++c) h = this.drawFlatCoordinates_(l, h, s[c], u);
          this.hitDetectionInstructions.push(wl), this.endGeometry(e);
        }
        finish() {
          const t = this.state;
          return t.lastStroke != null && t.lastStroke != this.coordinates.length && this.instructions.push(wl), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
        }
        applyStroke(t) {
          t.lastStroke != null && t.lastStroke != this.coordinates.length && (this.instructions.push(wl), t.lastStroke = this.coordinates.length), t.lastStroke = 0, super.applyStroke(t), this.instructions.push(Ju);
        }
      }
      class xF extends TA {
        constructor(t, e, i, r) {
          super(t, e, i, r);
        }
        drawFlatCoordinatess_(t, e, i, r) {
          const a = this.state, o = a.fillStyle !== void 0, s = a.strokeStyle !== void 0, l = i.length;
          this.instructions.push(Ju), this.hitDetectionInstructions.push(Ju);
          for (let u = 0; u < l; ++u) {
            const h = i[u], c = this.coordinates.length, f = this.appendFlatLineCoordinates(t, e, h, r, true, !s), g = [Ht.MOVE_TO_LINE_TO, c, f];
            this.instructions.push(g), this.hitDetectionInstructions.push(g), s && (this.instructions.push(EF), this.hitDetectionInstructions.push(EF)), e = h;
          }
          return o && (this.instructions.push(qm), this.hitDetectionInstructions.push(qm)), s && (this.instructions.push(wl), this.hitDetectionInstructions.push(wl)), e;
        }
        drawCircle(t, e, i) {
          const r = this.state, a = r.fillStyle, o = r.strokeStyle;
          if (a === void 0 && o === void 0) return;
          this.setFillStrokeStyles_(), this.beginGeometry(t, e, i), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([Ht.SET_FILL_STYLE, hr]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([Ht.SET_STROKE_STYLE, r.strokeStyle, r.lineWidth, r.lineCap, r.lineJoin, r.miterLimit, Es, Is]);
          const s = t.getFlatCoordinates(), l = t.getStride(), u = this.coordinates.length;
          this.appendFlatLineCoordinates(s, 0, s.length, l, false, false);
          const h = [Ht.CIRCLE, u];
          this.instructions.push(Ju, h), this.hitDetectionInstructions.push(Ju, h), r.fillStyle !== void 0 && (this.instructions.push(qm), this.hitDetectionInstructions.push(qm)), r.strokeStyle !== void 0 && (this.instructions.push(wl), this.hitDetectionInstructions.push(wl)), this.endGeometry(e);
        }
        drawPolygon(t, e, i) {
          const r = this.state, a = r.fillStyle, o = r.strokeStyle;
          if (a === void 0 && o === void 0) return;
          this.setFillStrokeStyles_(), this.beginGeometry(t, e, i), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([Ht.SET_FILL_STYLE, hr]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([Ht.SET_STROKE_STYLE, r.strokeStyle, r.lineWidth, r.lineCap, r.lineJoin, r.miterLimit, Es, Is]);
          const s = t.getEnds(), l = t.getOrientedFlatCoordinates(), u = t.getStride();
          this.drawFlatCoordinatess_(l, 0, s, u), this.endGeometry(e);
        }
        drawMultiPolygon(t, e, i) {
          const r = this.state, a = r.fillStyle, o = r.strokeStyle;
          if (a === void 0 && o === void 0) return;
          this.setFillStrokeStyles_(), this.beginGeometry(t, e, i), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([Ht.SET_FILL_STYLE, hr]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([Ht.SET_STROKE_STYLE, r.strokeStyle, r.lineWidth, r.lineCap, r.lineJoin, r.miterLimit, Es, Is]);
          const s = t.getEndss(), l = t.getOrientedFlatCoordinates(), u = t.getStride();
          let h = 0;
          for (let c = 0, f = s.length; c < f; ++c) h = this.drawFlatCoordinatess_(l, h, s[c], u);
          this.endGeometry(e);
        }
        finish() {
          this.reverseHitDetectionInstructions(), this.state = null;
          const t = this.tolerance;
          if (t !== 0) {
            const e = this.coordinates;
            for (let i = 0, r = e.length; i < r; ++i) e[i] = Hu(e[i], t);
          }
          return super.finish();
        }
        setFillStrokeStyles_() {
          const t = this.state;
          t.fillStyle !== void 0 && this.updateFillStyle(t, this.createFill), t.strokeStyle !== void 0 && this.updateStrokeStyle(t, this.applyStroke);
        }
      }
      function Att(n, t, e, i, r) {
        const a = [];
        let o = e, s = 0, l = t.slice(e, 2);
        for (; s < n && o + r < i; ) {
          const [u, h] = l.slice(-2), c = t[o + r], f = t[o + r + 1], g = Math.sqrt((c - u) * (c - u) + (f - h) * (f - h));
          if (s += g, s >= n) {
            const d = (n - s + g) / g, A = Fr(u, c, d), p = Fr(h, f, d);
            l.push(A, p), a.push(l), l = [A, p], s == n && (o += r), s = 0;
          } else if (s < n) l.push(t[o + r], t[o + r + 1]), o += r;
          else {
            const d = g - s, A = Fr(u, c, d / g), p = Fr(h, f, d / g);
            l.push(A, p), a.push(l), l = [A, p], s = 0, o += r;
          }
        }
        return s > 0 && a.push(l), a;
      }
      function ptt(n, t, e, i, r) {
        let a = e, o = e, s = 0, l = 0, u = e, h, c, f, g, d, A, p, v, y, m;
        for (c = e; c < i; c += r) {
          const _ = t[c], I = t[c + 1];
          d !== void 0 && (y = _ - d, m = I - A, g = Math.sqrt(y * y + m * m), p !== void 0 && (l += f, h = Math.acos((p * y + v * m) / (f * g)), h > n && (l > s && (s = l, a = u, o = c), l = 0, u = c - r)), f = g, p = y, v = m), d = _, A = I;
        }
        return l += g, l > s ? [u, c] : [a, o];
      }
      const Hm = { left: 0, center: 0.5, right: 1, top: 0, middle: 0.5, hanging: 0.2, alphabetic: 0.8, ideographic: 0.8, bottom: 1 };
      class vtt extends TA {
        constructor(t, e, i, r) {
          super(t, e, i, r), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textKeepUpright_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.fillStates[hr] = { fillStyle: hr }, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
        }
        finish() {
          const t = super.finish();
          return t.textStates = this.textStates, t.fillStates = this.fillStates, t.strokeStates = this.strokeStates, t;
        }
        drawText(t, e, i) {
          const r = this.textFillState_, a = this.textStrokeState_, o = this.textState_;
          if (this.text_ === "" || !o || !r && !a) return;
          const s = this.coordinates;
          let l = s.length;
          const u = t.getType();
          let h = null, c = t.getStride();
          if (o.placement === "line" && (u == "LineString" || u == "MultiLineString" || u == "Polygon" || u == "MultiPolygon")) {
            if (!Ai(this.maxExtent, t.getExtent())) return;
            let f;
            if (h = t.getFlatCoordinates(), u == "LineString") f = [h.length];
            else if (u == "MultiLineString") f = t.getEnds();
            else if (u == "Polygon") f = t.getEnds().slice(0, 1);
            else if (u == "MultiPolygon") {
              const p = t.getEndss();
              f = [];
              for (let v = 0, y = p.length; v < y; ++v) f.push(p[v][0]);
            }
            this.beginGeometry(t, e, i);
            const g = o.repeat, d = g ? void 0 : o.textAlign;
            let A = 0;
            for (let p = 0, v = f.length; p < v; ++p) {
              let y;
              g ? y = Att(g * this.resolution, h, A, f[p], c) : y = [h.slice(A, f[p])];
              for (let m = 0, _ = y.length; m < _; ++m) {
                const I = y[m];
                let E = 0, x = I.length;
                if (d == null) {
                  const C = ptt(o.maxAngle, I, 0, I.length, 2);
                  E = C[0], x = C[1];
                }
                for (let C = E; C < x; C += c) s.push(I[C], I[C + 1]);
                const w = s.length;
                A = f[p], this.drawChars_(l, w), l = w;
              }
            }
            this.endGeometry(e);
          } else {
            let f = o.overflow ? null : [];
            switch (u) {
              case "Point":
              case "MultiPoint":
                h = t.getFlatCoordinates();
                break;
              case "LineString":
                h = t.getFlatMidpoint();
                break;
              case "Circle":
                h = t.getCenter();
                break;
              case "MultiLineString":
                h = t.getFlatMidpoints(), c = 2;
                break;
              case "Polygon":
                h = t.getFlatInteriorPoint(), o.overflow || f.push(h[2] / this.resolution), c = 3;
                break;
              case "MultiPolygon":
                const y = t.getFlatInteriorPoints();
                h = [];
                for (let m = 0, _ = y.length; m < _; m += 3) o.overflow || f.push(y[m + 2] / this.resolution), h.push(y[m], y[m + 1]);
                if (h.length === 0) return;
                c = 2;
                break;
            }
            const g = this.appendFlatPointCoordinates(h, c);
            if (g === l) return;
            if (f && (g - l) / 2 !== h.length / c) {
              let y = l / 2;
              f = f.filter((m, _) => {
                const I = s[(y + _) * 2] === h[_ * c] && s[(y + _) * 2 + 1] === h[_ * c + 1];
                return I || --y, I;
              });
            }
            this.saveTextStates_(), (o.backgroundFill || o.backgroundStroke) && (this.setFillStrokeStyle(o.backgroundFill, o.backgroundStroke), o.backgroundFill && this.updateFillStyle(this.state, this.createFill), o.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(t, e, i);
            let d = o.padding;
            if (d != Wu && (o.scale[0] < 0 || o.scale[1] < 0)) {
              let y = o.padding[0], m = o.padding[1], _ = o.padding[2], I = o.padding[3];
              o.scale[0] < 0 && (m = -m, I = -I), o.scale[1] < 0 && (y = -y, _ = -_), d = [y, m, _, I];
            }
            const A = this.pixelRatio;
            this.instructions.push([Ht.DRAW_IMAGE, l, g, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, this.declutterMode_, this.declutterImageWithText_, d == Wu ? Wu : d.map(function(y) {
              return y * A;
            }), !!o.backgroundFill, !!o.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, f]);
            const p = 1 / A, v = this.state.fillStyle;
            o.backgroundFill && (this.state.fillStyle = hr, this.hitDetectionInstructions.push(this.createFill(this.state))), this.hitDetectionInstructions.push([Ht.DRAW_IMAGE, l, g, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [p, p], NaN, this.declutterMode_, this.declutterImageWithText_, d, !!o.backgroundFill, !!o.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_ ? hr : this.fillKey_, this.textOffsetX_, this.textOffsetY_, f]), o.backgroundFill && (this.state.fillStyle = v, this.hitDetectionInstructions.push(this.createFill(this.state))), this.endGeometry(e);
          }
        }
        saveTextStates_() {
          const t = this.textStrokeState_, e = this.textState_, i = this.textFillState_, r = this.strokeKey_;
          t && (r in this.strokeStates || (this.strokeStates[r] = { strokeStyle: t.strokeStyle, lineCap: t.lineCap, lineDashOffset: t.lineDashOffset, lineWidth: t.lineWidth, lineJoin: t.lineJoin, miterLimit: t.miterLimit, lineDash: t.lineDash }));
          const a = this.textKey_;
          a in this.textStates || (this.textStates[a] = { font: e.font, textAlign: e.textAlign || vA, justify: e.justify, textBaseline: e.textBaseline || Nm, scale: e.scale });
          const o = this.fillKey_;
          i && (o in this.fillStates || (this.fillStates[o] = { fillStyle: i.fillStyle }));
        }
        drawChars_(t, e) {
          const i = this.textStrokeState_, r = this.textState_, a = this.strokeKey_, o = this.textKey_, s = this.fillKey_;
          this.saveTextStates_();
          const l = this.pixelRatio, u = Hm[r.textBaseline], h = this.textOffsetY_ * l, c = this.text_, f = i ? i.lineWidth * Math.abs(r.scale[0]) / 2 : 0;
          this.instructions.push([Ht.DRAW_CHARS, t, e, u, r.overflow, s, r.maxAngle, l, h, a, f * l, c, o, 1, this.declutterMode_, this.textKeepUpright_]), this.hitDetectionInstructions.push([Ht.DRAW_CHARS, t, e, u, r.overflow, s && hr, r.maxAngle, l, h, a, f * l, c, o, 1 / l, this.declutterMode_, this.textKeepUpright_]);
        }
        setTextStyle(t, e) {
          let i, r, a;
          if (!t) this.text_ = "";
          else {
            const o = t.getFill();
            o ? (r = this.textFillState_, r || (r = {}, this.textFillState_ = r), r.fillStyle = _o(o.getColor() || hr)) : (r = null, this.textFillState_ = r);
            const s = t.getStroke();
            if (!s) a = null, this.textStrokeState_ = a;
            else {
              a = this.textStrokeState_, a || (a = {}, this.textStrokeState_ = a);
              const A = s.getLineDash(), p = s.getLineDashOffset(), v = s.getWidth(), y = s.getMiterLimit();
              a.lineCap = s.getLineCap() || sf, a.lineDash = A ? A.slice() : Es, a.lineDashOffset = p === void 0 ? Is : p, a.lineJoin = s.getLineJoin() || lf, a.lineWidth = v === void 0 ? yA : v, a.miterLimit = y === void 0 ? AA : y, a.strokeStyle = _o(s.getColor() || pA);
            }
            i = this.textState_;
            const l = t.getFont() || HN;
            rJ(l);
            const u = t.getScaleArray();
            i.overflow = t.getOverflow(), i.font = l, i.maxAngle = t.getMaxAngle(), i.placement = t.getPlacement(), i.textAlign = t.getTextAlign(), i.repeat = t.getRepeat(), i.justify = t.getJustify(), i.textBaseline = t.getTextBaseline() || Nm, i.backgroundFill = t.getBackgroundFill(), i.backgroundStroke = t.getBackgroundStroke(), i.padding = t.getPadding() || Wu, i.scale = u === void 0 ? [1, 1] : u;
            const h = t.getOffsetX(), c = t.getOffsetY(), f = t.getRotateWithView(), g = t.getKeepUpright(), d = t.getRotation();
            this.text_ = t.getText() || "", this.textOffsetX_ = h === void 0 ? 0 : h, this.textOffsetY_ = c === void 0 ? 0 : c, this.textRotateWithView_ = f === void 0 ? false : f, this.textKeepUpright_ = g === void 0 ? true : g, this.textRotation_ = d === void 0 ? 0 : d, this.strokeKey_ = a ? (typeof a.strokeStyle == "string" ? a.strokeStyle : xt(a.strokeStyle)) + a.lineCap + a.lineDashOffset + "|" + a.lineWidth + a.lineJoin + a.miterLimit + "[" + a.lineDash.join() + "]" : "", this.textKey_ = i.font + i.scale + (i.textAlign || "?") + (i.repeat || "?") + (i.justify || "?") + (i.textBaseline || "?"), this.fillKey_ = r && r.fillStyle ? typeof r.fillStyle == "string" ? r.fillStyle : "|" + xt(r.fillStyle) : "";
          }
          this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = e;
        }
      }
      const ytt = { Circle: xF, Default: TA, Image: gtt, LineString: dtt, Polygon: xF, Text: vtt };
      class mtt {
        constructor(t, e, i, r) {
          this.tolerance_ = t, this.maxExtent_ = e, this.pixelRatio_ = r, this.resolution_ = i, this.buildersByZIndex_ = {};
        }
        finish() {
          const t = {};
          for (const e in this.buildersByZIndex_) {
            t[e] = t[e] || {};
            const i = this.buildersByZIndex_[e];
            for (const r in i) {
              const a = i[r].finish();
              t[e][r] = a;
            }
          }
          return t;
        }
        getBuilder(t, e) {
          const i = t !== void 0 ? t.toString() : "0";
          let r = this.buildersByZIndex_[i];
          r === void 0 && (r = {}, this.buildersByZIndex_[i] = r);
          let a = r[e];
          if (a === void 0) {
            const o = ytt[e];
            a = new o(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_), r[e] = a;
          }
          return a;
        }
      }
      const _tt = 5;
      class wF extends Jd {
        constructor(t) {
          super(), this.ready = true, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = t, this.staleKeys_ = new Array(), this.maxStaleKeys = _tt;
        }
        getStaleKeys() {
          return this.staleKeys_;
        }
        prependStaleKey(t) {
          this.staleKeys_.unshift(t), this.staleKeys_.length > this.maxStaleKeys && (this.staleKeys_.length = this.maxStaleKeys);
        }
        getFeatures(t) {
          return zt();
        }
        getData(t) {
          return null;
        }
        prepareFrame(t) {
          return zt();
        }
        renderFrame(t, e) {
          return zt();
        }
        forEachFeatureAtCoordinate(t, e, i, r, a) {
        }
        getLayer() {
          return this.layer_;
        }
        handleFontsChanged() {
        }
        handleImageChange_(t) {
          const e = t.target;
          (e.getState() === Mt.LOADED || e.getState() === Mt.ERROR) && this.renderIfReadyAndVisible();
        }
        loadImage(t) {
          let e = t.getState();
          return e != Mt.LOADED && e != Mt.ERROR && t.addEventListener(Rt.CHANGE, this.boundHandleImageChange_), e == Mt.IDLE && (t.load(), e = t.getState()), e == Mt.LOADED;
        }
        renderIfReadyAndVisible() {
          const t = this.getLayer();
          t && t.getVisible() && t.getSourceState() === "ready" && t.changed();
        }
        renderDeferred(t) {
        }
        disposeInternal() {
          delete this.layer_, super.disposeInternal();
        }
      }
      class BA extends Te {
        constructor(t, e, i, r) {
          super(t), this.inversePixelTransform = e, this.frameState = i, this.context = r;
        }
      }
      class CF {
        constructor() {
          Jt(this, "pushMethodArgs_", (...t) => (this.instructions_[this.zIndex + this.offset_].push(t), this));
          this.instructions_ = [], this.zIndex = 0, this.offset_ = 0, this.context_ = new Proxy(Bm(), { get: (t, e) => {
            if (typeof Bm()[e] == "function") return this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(e), this.pushMethodArgs_;
          }, set: (t, e, i) => (this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(e, i), true) });
        }
        pushFunction(t) {
          this.instructions_[this.zIndex + this.offset_].push(t);
        }
        getContext() {
          return this.context_;
        }
        draw(t) {
          this.instructions_.forEach((e) => {
            for (let i = 0, r = e.length; i < r; ++i) {
              const a = e[i];
              if (typeof a == "function") {
                a(t);
                continue;
              }
              const o = e[++i];
              if (typeof t[a] == "function") t[a](...o);
              else {
                if (typeof o == "function") {
                  t[a] = o(t);
                  continue;
                }
                t[a] = o;
              }
            }
          });
        }
        clear() {
          this.instructions_.length = 0, this.zIndex = 0, this.offset_ = 0;
        }
        offset() {
          this.offset_ = this.instructions_.length, this.zIndex = 0;
        }
      }
      const SF = [];
      let Af = null;
      function Ett() {
        Af = In(1, 1, void 0, { willReadFrequently: true });
      }
      class Ym extends wF {
        constructor(t) {
          super(t), this.container = null, this.renderedResolution, this.tempTransform = an(), this.pixelTransform = an(), this.inversePixelTransform = an(), this.context = null, this.deferredContext_ = null, this.containerReused = false, this.frameState = null;
        }
        getImageData(t, e, i) {
          Af || Ett(), Af.clearRect(0, 0, 1, 1);
          let r;
          try {
            Af.drawImage(t, e, i, 1, 1, 0, 0, 1, 1), r = Af.getImageData(0, 0, 1, 1).data;
          } catch (a) {
            return Af = null, null;
          }
          return r;
        }
        getBackground(t) {
          let i = this.getLayer().getBackground();
          return typeof i == "function" && (i = i(t.viewState.resolution)), i || void 0;
        }
        useContainer(t, e, i) {
          const r = this.getLayer().getClassName();
          let a, o;
          if (t && t.className === r && (!i || t && t.style.backgroundColor && co(ia(t.style.backgroundColor), ia(i)))) {
            const s = t.firstElementChild;
            s instanceof HTMLCanvasElement && (o = s.getContext("2d"));
          }
          if (o && o.canvas.style.transform === e ? (this.container = t, this.context = o, this.containerReused = true) : this.containerReused ? (this.container = null, this.context = null, this.containerReused = false) : this.container && (this.container.style.backgroundColor = null), !this.container) {
            a = document.createElement("div"), a.className = r;
            let s = a.style;
            s.position = "absolute", s.width = "100%", s.height = "100%", o = In();
            const l = o.canvas;
            a.appendChild(l), s = l.style, s.position = "absolute", s.left = "0", s.transformOrigin = "top left", this.container = a, this.context = o;
          }
          !this.containerReused && i && !this.container.style.backgroundColor && (this.container.style.backgroundColor = i);
        }
        clipUnrotated(t, e, i) {
          const r = ur(i), a = _l(i), o = Xc(i), s = Wc(i);
          nn(e.coordinateToPixelTransform, r), nn(e.coordinateToPixelTransform, a), nn(e.coordinateToPixelTransform, o), nn(e.coordinateToPixelTransform, s);
          const l = this.inversePixelTransform;
          nn(l, r), nn(l, a), nn(l, o), nn(l, s), t.save(), t.beginPath(), t.moveTo(Math.round(r[0]), Math.round(r[1])), t.lineTo(Math.round(a[0]), Math.round(a[1])), t.lineTo(Math.round(o[0]), Math.round(o[1])), t.lineTo(Math.round(s[0]), Math.round(s[1])), t.clip();
        }
        prepareContainer(t, e) {
          const i = t.extent, r = t.viewState.resolution, a = t.viewState.rotation, o = t.pixelRatio, s = Math.round(he(i) / r * o), l = Math.round(dn(i) / r * o);
          Lr(this.pixelTransform, t.size[0] / 2, t.size[1] / 2, 1 / o, 1 / o, a, -s / 2, -l / 2), ml(this.inversePixelTransform, this.pixelTransform);
          const u = QP(this.pixelTransform);
          if (this.useContainer(e, u, this.getBackground(t)), !this.containerReused) {
            const h = this.context.canvas;
            h.width != s || h.height != l ? (h.width = s, h.height = l) : this.context.clearRect(0, 0, s, l), u !== h.style.transform && (h.style.transform = u);
          }
        }
        dispatchRenderEvent_(t, e, i) {
          const r = this.getLayer();
          if (r.hasListener(t)) {
            const a = new BA(t, this.inversePixelTransform, i, e);
            r.dispatchEvent(a);
          }
        }
        preRender(t, e) {
          this.frameState = e, !e.declutter && this.dispatchRenderEvent_(si.PRERENDER, t, e);
        }
        postRender(t, e) {
          e.declutter || this.dispatchRenderEvent_(si.POSTRENDER, t, e);
        }
        renderDeferredInternal(t) {
        }
        getRenderContext(t) {
          return t.declutter && !this.deferredContext_ && (this.deferredContext_ = new CF()), t.declutter ? this.deferredContext_.getContext() : this.context;
        }
        renderDeferred(t) {
          t.declutter && (this.dispatchRenderEvent_(si.PRERENDER, this.context, t), t.declutter && this.deferredContext_ && (this.deferredContext_.draw(this.context), this.deferredContext_.clear()), this.renderDeferredInternal(t), this.dispatchRenderEvent_(si.POSTRENDER, this.context, t));
        }
        getRenderTransform(t, e, i, r, a, o, s) {
          const l = a / 2, u = o / 2, h = r / e, c = -h, f = -t[0] + s, g = -t[1];
          return Lr(this.tempTransform, l, u, h, c, -i, f, g);
        }
        disposeInternal() {
          delete this.frameState, super.disposeInternal();
        }
      }
      function Itt(n, t, e, i, r, a, o, s, l, u, h, c, f = true) {
        let g = n[t], d = n[t + 1], A = 0, p = 0, v = 0, y = 0;
        function m() {
          A = g, p = d, t += i, g = n[t], d = n[t + 1], y += v, v = Math.sqrt((g - A) * (g - A) + (d - p) * (d - p));
        }
        do
          m();
        while (t < e - i && y + v < a);
        let _ = v === 0 ? 0 : (a - y) / v;
        const I = Fr(A, g, _), E = Fr(p, d, _), x = t - i, w = y, C = a + s * l(u, r, h);
        for (; t < e - i && y + v < C; ) m();
        _ = v === 0 ? 0 : (C - y) / v;
        const S = Fr(A, g, _), b = Fr(p, d, _);
        let T = false;
        if (f) if (c) {
          const N = [I, E, S, b];
          jx(N, 0, 4, 2, c, N, N), T = N[0] > N[2];
        } else T = I > S;
        const B = Math.PI, R = [], M = x + i === t;
        t = x, v = 0, y = w, g = n[t], d = n[t + 1];
        let L;
        if (M) {
          m(), L = Math.atan2(d - p, g - A), T && (L += L > 0 ? -B : B);
          const N = (S + I) / 2, F = (b + E) / 2;
          return R[0] = [N, F, (C - a) / 2, L, r], R;
        }
        r = r.replace(/\n/g, " ");
        for (let N = 0, F = r.length; N < F; ) {
          m();
          let k = Math.atan2(d - p, g - A);
          if (T && (k += k > 0 ? -B : B), L !== void 0) {
            let $ = k - L;
            if ($ += $ > B ? -2 * B : $ < -B ? 2 * B : 0, Math.abs($) > o) return null;
          }
          L = k;
          const O = N;
          let Q = 0;
          for (; N < F; ++N) {
            const $ = T ? F - N - 1 : N, J = s * l(u, r[$], h);
            if (t + i < e && y + v < a + Q + J / 2) break;
            Q += J;
          }
          if (N === O) continue;
          const j = T ? r.substring(F - O, F - N) : r.substring(O, N);
          _ = v === 0 ? 0 : (a + Q / 2 - y) / v;
          const Y = Fr(A, g, _), G = Fr(p, d, _);
          R.push([Y, G, Q / 2, k, j]), a += Q;
        }
        return R;
      }
      const pf = ai(), Cl = [], Ss = [], bs = [], Sl = [];
      function bF(n) {
        return n[3].declutterBox;
      }
      const TF = new RegExp("[-----]");
      function Lw(n, t) {
        return t === "start" ? t = TF.test(n) ? "right" : "left" : t === "end" && (t = TF.test(n) ? "left" : "right"), Hm[t];
      }
      function xtt(n, t, e) {
        return e > 0 && n.push(`
`, ""), n.push(t, ""), n;
      }
      class wtt {
        constructor(t, e, i, r, a) {
          this.overlaps = i, this.pixelRatio = e, this.resolution = t, this.alignAndScaleFill_, this.instructions = r.instructions, this.coordinates = r.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = an(), this.hitDetectionInstructions = r.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = r.fillStates || {}, this.strokeStates = r.strokeStates || {}, this.textStates = r.textStates || {}, this.widths_ = {}, this.labels_ = {}, this.zIndexContext_ = a ? new CF() : null;
        }
        getZIndexContext() {
          return this.zIndexContext_;
        }
        createLabel(t, e, i, r) {
          const a = t + e + i + r;
          if (this.labels_[a]) return this.labels_[a];
          const o = r ? this.strokeStates[r] : null, s = i ? this.fillStates[i] : null, l = this.textStates[e], u = this.pixelRatio, h = [l.scale[0] * u, l.scale[1] * u], c = l.justify ? Hm[l.justify] : Lw(Array.isArray(t) ? t[0] : t, l.textAlign || vA), f = r && o.lineWidth ? o.lineWidth : 0, g = Array.isArray(t) ? t : String(t).split(`
`).reduce(xtt, []), { width: d, height: A, widths: p, heights: v, lineWidths: y } = oJ(l, g), m = d + f, _ = [], I = (m + 2) * h[0], E = (A + f) * h[1], x = { width: I < 0 ? Math.floor(I) : Math.ceil(I), height: E < 0 ? Math.floor(E) : Math.ceil(E), contextInstructions: _ };
          (h[0] != 1 || h[1] != 1) && _.push("scale", h), r && (_.push("strokeStyle", o.strokeStyle), _.push("lineWidth", f), _.push("lineCap", o.lineCap), _.push("lineJoin", o.lineJoin), _.push("miterLimit", o.miterLimit), _.push("setLineDash", [o.lineDash]), _.push("lineDashOffset", o.lineDashOffset)), i && _.push("fillStyle", s.fillStyle), _.push("textBaseline", "middle"), _.push("textAlign", "center");
          const w = 0.5 - c;
          let C = c * m + w * f;
          const S = [], b = [];
          let T = 0, B = 0, R = 0, M = 0, L;
          for (let N = 0, F = g.length; N < F; N += 2) {
            const k = g[N];
            if (k === `
`) {
              B += T, T = 0, C = c * m + w * f, ++M;
              continue;
            }
            const O = g[N + 1] || l.font;
            O !== L && (r && S.push("font", O), i && b.push("font", O), L = O), T = Math.max(T, v[R]);
            const Q = [k, C + w * p[R] + c * (p[R] - y[M]), 0.5 * (f + T) + B];
            C += p[R], r && S.push("strokeText", Q), i && b.push("fillText", Q), ++R;
          }
          return Array.prototype.push.apply(_, S), Array.prototype.push.apply(_, b), this.labels_[a] = x, x;
        }
        replayTextBackground_(t, e, i, r, a, o, s) {
          t.beginPath(), t.moveTo.apply(t, e), t.lineTo.apply(t, i), t.lineTo.apply(t, r), t.lineTo.apply(t, a), t.lineTo.apply(t, e), o && (this.alignAndScaleFill_ = o[2], this.fill_(t)), s && (this.setStrokeStyle_(t, s), t.stroke());
        }
        calculateImageOrLabelDimensions_(t, e, i, r, a, o, s, l, u, h, c, f, g, d, A, p) {
          s *= f[0], l *= f[1];
          let v = i - s, y = r - l;
          const m = a + u > t ? t - u : a, _ = o + h > e ? e - h : o, I = d[3] + m * f[0] + d[1], E = d[0] + _ * f[1] + d[2], x = v - d[3], w = y - d[0];
          (A || c !== 0) && (Cl[0] = x, Sl[0] = x, Cl[1] = w, Ss[1] = w, Ss[0] = x + I, bs[0] = Ss[0], bs[1] = w + E, Sl[1] = bs[1]);
          let C;
          return c !== 0 ? (C = Lr(an(), i, r, 1, 1, c, -i, -r), nn(C, Cl), nn(C, Ss), nn(C, bs), nn(C, Sl), ta(Math.min(Cl[0], Ss[0], bs[0], Sl[0]), Math.min(Cl[1], Ss[1], bs[1], Sl[1]), Math.max(Cl[0], Ss[0], bs[0], Sl[0]), Math.max(Cl[1], Ss[1], bs[1], Sl[1]), pf)) : ta(Math.min(x, x + I), Math.min(w, w + E), Math.max(x, x + I), Math.max(w, w + E), pf), g && (v = Math.round(v), y = Math.round(y)), { drawImageX: v, drawImageY: y, drawImageW: m, drawImageH: _, originX: u, originY: h, declutterBox: { minX: pf[0], minY: pf[1], maxX: pf[2], maxY: pf[3], value: p }, canvasTransform: C, scale: f };
        }
        replayImageOrLabel_(t, e, i, r, a, o, s) {
          const l = !!(o || s), u = r.declutterBox, h = s ? s[2] * r.scale[0] / 2 : 0;
          return u.minX - h <= e[0] && u.maxX + h >= 0 && u.minY - h <= e[1] && u.maxY + h >= 0 && (l && this.replayTextBackground_(t, Cl, Ss, bs, Sl, o, s), sJ(t, r.canvasTransform, a, i, r.originX, r.originY, r.drawImageW, r.drawImageH, r.drawImageX, r.drawImageY, r.scale)), true;
        }
        fill_(t) {
          const e = this.alignAndScaleFill_;
          if (e) {
            const i = nn(this.renderedTransform_, [0, 0]), r = 512 * this.pixelRatio;
            t.save(), t.translate(i[0] % r, i[1] % r), e !== 1 && t.scale(e, e), t.rotate(this.viewRotation_);
          }
          t.fill(), e && t.restore();
        }
        setStrokeStyle_(t, e) {
          t.strokeStyle = e[1], t.lineWidth = e[2], t.lineCap = e[3], t.lineJoin = e[4], t.miterLimit = e[5], t.lineDashOffset = e[7], t.setLineDash(e[6]);
        }
        drawLabelWithPointPlacement_(t, e, i, r) {
          const a = this.textStates[e], o = this.createLabel(t, e, r, i), s = this.strokeStates[i], l = this.pixelRatio, u = Lw(Array.isArray(t) ? t[0] : t, a.textAlign || vA), h = Hm[a.textBaseline || Nm], c = s && s.lineWidth ? s.lineWidth : 0, f = o.width / l - 2 * a.scale[0], g = u * f + 2 * (0.5 - u) * c, d = h * o.height / l + 2 * (0.5 - h) * c;
          return { label: o, anchorX: g, anchorY: d };
        }
        execute_(t, e, i, r, a, o, s, l) {
          const u = this.zIndexContext_;
          let h;
          this.pixelCoordinates_ && co(i, this.renderedTransform_) ? h = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), h = yo(this.coordinates, 0, this.coordinates.length, 2, i, this.pixelCoordinates_), FP(this.renderedTransform_, i));
          let c = 0;
          const f = r.length;
          let g = 0, d, A, p, v, y, m, _, I, E, x, w, C, S, b = 0, T = 0, B = null, R = null;
          const M = this.coordinateCache_, L = this.viewRotation_, N = Math.round(Math.atan2(-i[1], i[0]) * 1e12) / 1e12, F = { context: t, pixelRatio: this.pixelRatio, resolution: this.resolution, rotation: L }, k = this.instructions != r || this.overlaps ? 0 : 200;
          let O, Q, j, Y;
          for (; c < f; ) {
            const G = r[c];
            switch (G[0]) {
              case Ht.BEGIN_GEOMETRY:
                O = G[1], Y = G[3], O.getGeometry() ? s !== void 0 && !Ai(s, Y.getExtent()) ? c = G[2] + 1 : ++c : c = G[2], u && (u.zIndex = G[4]);
                break;
              case Ht.BEGIN_PATH:
                b > k && (this.fill_(t), b = 0), T > k && (t.stroke(), T = 0), !b && !T && (t.beginPath(), y = NaN, m = NaN), ++c;
                break;
              case Ht.CIRCLE:
                g = G[1];
                const J = h[g], et = h[g + 1], nt = h[g + 2], gt = h[g + 3], q = nt - J, W = gt - et, it = Math.sqrt(q * q + W * W);
                t.moveTo(J + it, et), t.arc(J, et, it, 0, 2 * Math.PI, true), ++c;
                break;
              case Ht.CLOSE_PATH:
                t.closePath(), ++c;
                break;
              case Ht.CUSTOM:
                g = G[1], d = G[2];
                const Ot = G[3], pt = G[4], St = G[5];
                F.geometry = Ot, F.feature = O, c in M || (M[c] = []);
                const bt = M[c];
                St ? St(h, g, d, 2, bt) : (bt[0] = h[g], bt[1] = h[g + 1], bt.length = 2), u && (u.zIndex = G[6]), pt(bt, F), ++c;
                break;
              case Ht.DRAW_IMAGE:
                g = G[1], d = G[2], E = G[3], A = G[4], p = G[5];
                let xe = G[6];
                const sn = G[7], Ie = G[8], yn = G[9], ln = G[10];
                let Br = G[11];
                const Mr = G[12];
                let gs = G[13];
                v = G[14] || "declutter";
                const Vn = G[15];
                if (!E && G.length >= 20) {
                  x = G[19], w = G[20], C = G[21], S = G[22];
                  const Na = this.drawLabelWithPointPlacement_(x, w, C, S);
                  E = Na.label, G[3] = E;
                  const Uc = G[23];
                  A = (Na.anchorX - Uc) * this.pixelRatio, G[4] = A;
                  const Fa = G[24];
                  p = (Na.anchorY - Fa) * this.pixelRatio, G[5] = p, xe = E.height, G[6] = xe, gs = E.width, G[13] = gs;
                }
                let Yd;
                G.length > 25 && (Yd = G[25]);
                let tm, Wd, Xd;
                G.length > 17 ? (tm = G[16], Wd = G[17], Xd = G[18]) : (tm = Wu, Wd = false, Xd = false), ln && N ? Br += L : !ln && !N && (Br -= L);
                let bP = 0;
                for (; g < d; g += 2) {
                  if (Yd && Yd[bP++] < gs / this.pixelRatio) continue;
                  const Na = this.calculateImageOrLabelDimensions_(E.width, E.height, h[g], h[g + 1], gs, xe, A, p, Ie, yn, Br, Mr, a, tm, Wd || Xd, O), Uc = [t, e, E, Na, sn, Wd ? B : null, Xd ? R : null];
                  if (l) {
                    let Fa, ds, ka;
                    if (Vn) {
                      const Bn = d - g;
                      if (!Vn[Bn]) {
                        Vn[Bn] = { args: Uc, declutterMode: v };
                        continue;
                      }
                      const sr = Vn[Bn];
                      Fa = sr.args, ds = sr.declutterMode, delete Vn[Bn], ka = bF(Fa);
                    }
                    let gl, dl;
                    if (Fa && (ds !== "declutter" || !l.collides(ka)) && (gl = true), (v !== "declutter" || !l.collides(Na.declutterBox)) && (dl = true), ds === "declutter" && v === "declutter") {
                      const Bn = gl && dl;
                      gl = Bn, dl = Bn;
                    }
                    gl && (ds !== "none" && l.insert(ka), this.replayImageOrLabel_.apply(this, Fa)), dl && (v !== "none" && l.insert(Na.declutterBox), this.replayImageOrLabel_.apply(this, Uc));
                  } else this.replayImageOrLabel_.apply(this, Uc);
                }
                ++c;
                break;
              case Ht.DRAW_CHARS:
                const $d = G[1], TP = G[2], em = G[3], px = G[4];
                S = G[5];
                const nm = G[6], lo = G[7], Zd = G[8];
                C = G[9];
                const vx = G[10];
                x = G[11], w = G[12];
                const IZ = [G[13], G[13]];
                v = G[14] || "declutter";
                const P5t = G[15], BP = this.textStates[w], im = BP.font, rm = [BP.scale[0] * lo, BP.scale[1] * lo];
                let am;
                im in this.widths_ ? am = this.widths_[im] : (am = {}, this.widths_[im] = am);
                const xZ = GN(h, $d, TP, 2), wZ = Math.abs(rm[0]) * WN(im, x, am);
                if (px || wZ <= xZ) {
                  const Na = this.textStates[w].textAlign, Uc = (xZ - wZ) * Lw(x, Na), Fa = Itt(h, $d, TP, 2, x, Uc, nm, Math.abs(rm[0]), WN, im, am, N ? 0 : this.viewRotation_, P5t);
                  t: if (Fa) {
                    const ds = [];
                    let ka, gl, dl, Bn, sr;
                    if (C) for (ka = 0, gl = Fa.length; ka < gl; ++ka) {
                      sr = Fa[ka], dl = sr[4], Bn = this.createLabel(dl, w, "", C), A = sr[2] + (rm[0] < 0 ? -vx : vx), p = em * Bn.height + (0.5 - em) * 2 * vx * rm[1] / rm[0] - Zd;
                      const Al = this.calculateImageOrLabelDimensions_(Bn.width, Bn.height, sr[0], sr[1], Bn.width, Bn.height, A, p, 0, 0, sr[3], IZ, false, Wu, false, O);
                      if (l && v === "declutter" && l.collides(Al.declutterBox)) break t;
                      ds.push([t, e, Bn, Al, 1, null, null]);
                    }
                    if (S) for (ka = 0, gl = Fa.length; ka < gl; ++ka) {
                      sr = Fa[ka], dl = sr[4], Bn = this.createLabel(dl, w, S, ""), A = sr[2], p = em * Bn.height - Zd;
                      const Al = this.calculateImageOrLabelDimensions_(Bn.width, Bn.height, sr[0], sr[1], Bn.width, Bn.height, A, p, 0, 0, sr[3], IZ, false, Wu, false, O);
                      if (l && v === "declutter" && l.collides(Al.declutterBox)) break t;
                      ds.push([t, e, Bn, Al, 1, null, null]);
                    }
                    l && v !== "none" && l.load(ds.map(bF));
                    for (let Al = 0, N5t = ds.length; Al < N5t; ++Al) this.replayImageOrLabel_.apply(this, ds[Al]);
                  }
                }
                ++c;
                break;
              case Ht.END_GEOMETRY:
                if (o !== void 0) {
                  O = G[1];
                  const Na = o(O, Y, v);
                  if (Na) return Na;
                }
                ++c;
                break;
              case Ht.FILL:
                k ? b++ : this.fill_(t), ++c;
                break;
              case Ht.MOVE_TO_LINE_TO:
                for (g = G[1], d = G[2], Q = h[g], j = h[g + 1], t.moveTo(Q, j), y = Q + 0.5 | 0, m = j + 0.5 | 0, g += 2; g < d; g += 2) Q = h[g], j = h[g + 1], _ = Q + 0.5 | 0, I = j + 0.5 | 0, (g == d - 2 || _ !== y || I !== m) && (t.lineTo(Q, j), y = _, m = I);
                ++c;
                break;
              case Ht.SET_FILL_STYLE:
                B = G, this.alignAndScaleFill_ = G[2], b && (this.fill_(t), b = 0, T && (t.stroke(), T = 0)), t.fillStyle = G[1], ++c;
                break;
              case Ht.SET_STROKE_STYLE:
                R = G, T && (t.stroke(), T = 0), this.setStrokeStyle_(t, G), ++c;
                break;
              case Ht.STROKE:
                k ? T++ : t.stroke(), ++c;
                break;
              default:
                ++c;
                break;
            }
          }
          b && this.fill_(t), T && t.stroke();
        }
        execute(t, e, i, r, a, o) {
          this.viewRotation_ = r, this.execute_(t, e, i, this.instructions, a, void 0, void 0, o);
        }
        executeHitDetection(t, e, i, r, a) {
          return this.viewRotation_ = i, this.execute_(t, [t.canvas.width, t.canvas.height], e, this.hitDetectionInstructions, true, r, a);
        }
      }
      const vf = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"], BF = ["Image", "Text"], Ctt = vf.filter((n) => !BF.includes(n));
      class Stt {
        constructor(t, e, i, r, a, o, s) {
          this.maxExtent_ = t, this.overlaps_ = r, this.pixelRatio_ = i, this.resolution_ = e, this.renderBuffer_ = o, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = an(), this.renderedContext_ = null, this.deferredZIndexContexts_ = {}, this.createExecutors_(a, s);
        }
        clip(t, e) {
          const i = this.getClipCoords(e);
          t.beginPath(), t.moveTo(i[0], i[1]), t.lineTo(i[2], i[3]), t.lineTo(i[4], i[5]), t.lineTo(i[6], i[7]), t.clip();
        }
        createExecutors_(t, e) {
          for (const i in t) {
            let r = this.executorsByZIndex_[i];
            r === void 0 && (r = {}, this.executorsByZIndex_[i] = r);
            const a = t[i];
            for (const o in a) {
              const s = a[o];
              r[o] = new wtt(this.resolution_, this.pixelRatio_, this.overlaps_, s, e);
            }
          }
        }
        hasExecutors(t) {
          for (const e in this.executorsByZIndex_) {
            const i = this.executorsByZIndex_[e];
            for (let r = 0, a = t.length; r < a; ++r) if (t[r] in i) return true;
          }
          return false;
        }
        forEachFeatureAtCoordinate(t, e, i, r, a, o) {
          r = Math.round(r);
          const s = r * 2 + 1, l = Lr(this.hitDetectionTransform_, r + 0.5, r + 0.5, 1 / e, -1 / e, -i, -t[0], -t[1]), u = !this.hitDetectionContext_;
          u && (this.hitDetectionContext_ = In(s, s, void 0, { willReadFrequently: true }));
          const h = this.hitDetectionContext_;
          h.canvas.width !== s || h.canvas.height !== s ? (h.canvas.width = s, h.canvas.height = s) : u || h.clearRect(0, 0, s, s);
          let c;
          this.renderBuffer_ !== void 0 && (c = ai(), tA(c, t), fo(c, e * (this.renderBuffer_ + r), c));
          const f = btt(r);
          let g;
          function d(I, E, x) {
            const w = h.getImageData(0, 0, s, s).data;
            for (let C = 0, S = f.length; C < S; C++) if (w[f[C]] > 0) {
              if (!o || x === "none" || g !== "Image" && g !== "Text" || o.includes(I)) {
                const b = (f[C] - 3) / 4, T = r - b % s, B = r - (b / s | 0), R = a(I, E, T * T + B * B);
                if (R) return R;
              }
              h.clearRect(0, 0, s, s);
              break;
            }
          }
          const A = Object.keys(this.executorsByZIndex_).map(Number);
          A.sort(Rr);
          let p, v, y, m, _;
          for (p = A.length - 1; p >= 0; --p) {
            const I = A[p].toString();
            for (y = this.executorsByZIndex_[I], v = vf.length - 1; v >= 0; --v) if (g = vf[v], m = y[g], m !== void 0 && (_ = m.executeHitDetection(h, l, i, d, c), _)) return _;
          }
        }
        getClipCoords(t) {
          const e = this.maxExtent_;
          if (!e) return null;
          const i = e[0], r = e[1], a = e[2], o = e[3], s = [i, r, i, o, a, o, a, r];
          return yo(s, 0, 8, 2, t, s), s;
        }
        isEmpty() {
          return vl(this.executorsByZIndex_);
        }
        execute(t, e, i, r, a, o, s) {
          const l = Object.keys(this.executorsByZIndex_).map(Number);
          l.sort(s ? ho : Rr), o = o || vf;
          const u = vf.length;
          for (let h = 0, c = l.length; h < c; ++h) {
            const f = l[h].toString(), g = this.executorsByZIndex_[f];
            for (let d = 0, A = o.length; d < A; ++d) {
              const p = o[d], v = g[p];
              if (v !== void 0) {
                const y = s === null ? void 0 : v.getZIndexContext(), m = y ? y.getContext() : t, _ = this.maxExtent_ && p !== "Image" && p !== "Text";
                if (_ && (m.save(), this.clip(m, i)), !y || p === "Text" || p === "Image" ? v.execute(m, e, i, r, a, s) : y.pushFunction((I) => v.execute(I, e, i, r, a, s)), _ && m.restore(), y) {
                  y.offset();
                  const I = l[h] * u + d;
                  this.deferredZIndexContexts_[I] || (this.deferredZIndexContexts_[I] = []), this.deferredZIndexContexts_[I].push(y);
                }
              }
            }
          }
          this.renderedContext_ = t;
        }
        getDeferredZIndexContexts() {
          return this.deferredZIndexContexts_;
        }
        getRenderedContext() {
          return this.renderedContext_;
        }
        renderDeferred() {
          const t = this.deferredZIndexContexts_, e = Object.keys(t).map(Number).sort(Rr);
          for (let i = 0, r = e.length; i < r; ++i) t[e[i]].forEach((a) => {
            a.draw(this.renderedContext_), a.clear();
          }), t[e[i]].length = 0;
        }
      }
      const Pw = {};
      function btt(n) {
        if (Pw[n] !== void 0) return Pw[n];
        const t = n * 2 + 1, e = n * n, i = new Array(e + 1);
        for (let a = 0; a <= n; ++a) for (let o = 0; o <= n; ++o) {
          const s = a * a + o * o;
          if (s > e) break;
          let l = i[s];
          l || (l = [], i[s] = l), l.push(((n + a) * t + (n + o)) * 4 + 3), a > 0 && l.push(((n - a) * t + (n + o)) * 4 + 3), o > 0 && (l.push(((n + a) * t + (n - o)) * 4 + 3), a > 0 && l.push(((n - a) * t + (n - o)) * 4 + 3));
        }
        const r = [];
        for (let a = 0, o = i.length; a < o; ++a) i[a] && r.push(...i[a]);
        return Pw[n] = r, r;
      }
      class Ttt extends IF {
        constructor(t, e, i, r, a, o, s) {
          super(), this.context_ = t, this.pixelRatio_ = e, this.extent_ = i, this.transform_ = r, this.transformRotation_ = r ? rA(Math.atan2(r[1], r[0]), 10) : 0, this.viewRotation_ = a, this.squaredTolerance_ = o, this.userTransform_ = s, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = false, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = false, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = an();
        }
        drawImages_(t, e, i, r) {
          if (!this.image_) return;
          const a = yo(t, e, i, r, this.transform_, this.pixelCoordinates_), o = this.context_, s = this.tmpLocalTransform_, l = o.globalAlpha;
          this.imageOpacity_ != 1 && (o.globalAlpha = l * this.imageOpacity_);
          let u = this.imageRotation_;
          this.transformRotation_ === 0 && (u -= this.viewRotation_), this.imageRotateWithView_ && (u += this.viewRotation_);
          for (let h = 0, c = a.length; h < c; h += 2) {
            const f = a[h] - this.imageAnchorX_, g = a[h + 1] - this.imageAnchorY_;
            if (u !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
              const d = f + this.imageAnchorX_, A = g + this.imageAnchorY_;
              Lr(s, d, A, 1, 1, u, -d, -A), o.save(), o.transform.apply(o, s), o.translate(d, A), o.scale(this.imageScale_[0], this.imageScale_[1]), o.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_), o.restore();
            } else o.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, f, g, this.imageWidth_, this.imageHeight_);
          }
          this.imageOpacity_ != 1 && (o.globalAlpha = l);
        }
        drawText_(t, e, i, r) {
          if (!this.textState_ || this.text_ === "") return;
          this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
          const a = yo(t, e, i, r, this.transform_, this.pixelCoordinates_), o = this.context_;
          let s = this.textRotation_;
          for (this.transformRotation_ === 0 && (s -= this.viewRotation_), this.textRotateWithView_ && (s += this.viewRotation_); e < i; e += r) {
            const l = a[e] + this.textOffsetX_, u = a[e + 1] + this.textOffsetY_;
            s !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (o.save(), o.translate(l - this.textOffsetX_, u - this.textOffsetY_), o.rotate(s), o.translate(this.textOffsetX_, this.textOffsetY_), o.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && o.strokeText(this.text_, 0, 0), this.textFillState_ && o.fillText(this.text_, 0, 0), o.restore()) : (this.textStrokeState_ && o.strokeText(this.text_, l, u), this.textFillState_ && o.fillText(this.text_, l, u));
          }
        }
        moveToLineTo_(t, e, i, r, a) {
          const o = this.context_, s = yo(t, e, i, r, this.transform_, this.pixelCoordinates_);
          o.moveTo(s[0], s[1]);
          let l = s.length;
          a && (l -= 2);
          for (let u = 2; u < l; u += 2) o.lineTo(s[u], s[u + 1]);
          return a && o.closePath(), i;
        }
        drawRings_(t, e, i, r) {
          for (let a = 0, o = i.length; a < o; ++a) e = this.moveToLineTo_(t, e, i[a], r, true);
          return e;
        }
        drawCircle(t) {
          if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), !!Ai(this.extent_, t.getExtent())) {
            if (this.fillState_ || this.strokeState_) {
              this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
              const e = SK(t, this.transform_, this.pixelCoordinates_), i = e[2] - e[0], r = e[3] - e[1], a = Math.sqrt(i * i + r * r), o = this.context_;
              o.beginPath(), o.arc(e[0], e[1], a, 0, 2 * Math.PI), this.fillState_ && o.fill(), this.strokeState_ && o.stroke();
            }
            this.text_ !== "" && this.drawText_(t.getCenter(), 0, 2, 2);
          }
        }
        setStyle(t) {
          this.setFillStrokeStyle(t.getFill(), t.getStroke()), this.setImageStyle(t.getImage()), this.setTextStyle(t.getText());
        }
        setTransform(t) {
          this.transform_ = t;
        }
        drawGeometry(t) {
          switch (t.getType()) {
            case "Point":
              this.drawPoint(t);
              break;
            case "LineString":
              this.drawLineString(t);
              break;
            case "Polygon":
              this.drawPolygon(t);
              break;
            case "MultiPoint":
              this.drawMultiPoint(t);
              break;
            case "MultiLineString":
              this.drawMultiLineString(t);
              break;
            case "MultiPolygon":
              this.drawMultiPolygon(t);
              break;
            case "GeometryCollection":
              this.drawGeometryCollection(t);
              break;
            case "Circle":
              this.drawCircle(t);
              break;
          }
        }
        drawFeature(t, e) {
          const i = e.getGeometryFunction()(t);
          i && (this.setStyle(e), this.drawGeometry(i));
        }
        drawGeometryCollection(t) {
          const e = t.getGeometriesArray();
          for (let i = 0, r = e.length; i < r; ++i) this.drawGeometry(e[i]);
        }
        drawPoint(t) {
          this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          const e = t.getFlatCoordinates(), i = t.getStride();
          this.image_ && this.drawImages_(e, 0, e.length, i), this.text_ !== "" && this.drawText_(e, 0, e.length, i);
        }
        drawMultiPoint(t) {
          this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          const e = t.getFlatCoordinates(), i = t.getStride();
          this.image_ && this.drawImages_(e, 0, e.length, i), this.text_ !== "" && this.drawText_(e, 0, e.length, i);
        }
        drawLineString(t) {
          if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), !!Ai(this.extent_, t.getExtent())) {
            if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              const e = this.context_, i = t.getFlatCoordinates();
              e.beginPath(), this.moveToLineTo_(i, 0, i.length, t.getStride(), false), e.stroke();
            }
            if (this.text_ !== "") {
              const e = t.getFlatMidpoint();
              this.drawText_(e, 0, 2, 2);
            }
          }
        }
        drawMultiLineString(t) {
          this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          const e = t.getExtent();
          if (Ai(this.extent_, e)) {
            if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              const i = this.context_, r = t.getFlatCoordinates();
              let a = 0;
              const o = t.getEnds(), s = t.getStride();
              i.beginPath();
              for (let l = 0, u = o.length; l < u; ++l) a = this.moveToLineTo_(r, a, o[l], s, false);
              i.stroke();
            }
            if (this.text_ !== "") {
              const i = t.getFlatMidpoints();
              this.drawText_(i, 0, i.length, 2);
            }
          }
        }
        drawPolygon(t) {
          if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), !!Ai(this.extent_, t.getExtent())) {
            if (this.strokeState_ || this.fillState_) {
              this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
              const e = this.context_;
              e.beginPath(), this.drawRings_(t.getOrientedFlatCoordinates(), 0, t.getEnds(), t.getStride()), this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
            }
            if (this.text_ !== "") {
              const e = t.getFlatInteriorPoint();
              this.drawText_(e, 0, 2, 2);
            }
          }
        }
        drawMultiPolygon(t) {
          if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), !!Ai(this.extent_, t.getExtent())) {
            if (this.strokeState_ || this.fillState_) {
              this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
              const e = this.context_, i = t.getOrientedFlatCoordinates();
              let r = 0;
              const a = t.getEndss(), o = t.getStride();
              e.beginPath();
              for (let s = 0, l = a.length; s < l; ++s) {
                const u = a[s];
                r = this.drawRings_(i, r, u, o);
              }
              this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
            }
            if (this.text_ !== "") {
              const e = t.getFlatInteriorPoints();
              this.drawText_(e, 0, e.length, 2);
            }
          }
        }
        setContextFillState_(t) {
          const e = this.context_, i = this.contextFillState_;
          i ? i.fillStyle != t.fillStyle && (i.fillStyle = t.fillStyle, e.fillStyle = t.fillStyle) : (e.fillStyle = t.fillStyle, this.contextFillState_ = { fillStyle: t.fillStyle });
        }
        setContextStrokeState_(t) {
          const e = this.context_, i = this.contextStrokeState_;
          i ? (i.lineCap != t.lineCap && (i.lineCap = t.lineCap, e.lineCap = t.lineCap), co(i.lineDash, t.lineDash) || e.setLineDash(i.lineDash = t.lineDash), i.lineDashOffset != t.lineDashOffset && (i.lineDashOffset = t.lineDashOffset, e.lineDashOffset = t.lineDashOffset), i.lineJoin != t.lineJoin && (i.lineJoin = t.lineJoin, e.lineJoin = t.lineJoin), i.lineWidth != t.lineWidth && (i.lineWidth = t.lineWidth, e.lineWidth = t.lineWidth), i.miterLimit != t.miterLimit && (i.miterLimit = t.miterLimit, e.miterLimit = t.miterLimit), i.strokeStyle != t.strokeStyle && (i.strokeStyle = t.strokeStyle, e.strokeStyle = t.strokeStyle)) : (e.lineCap = t.lineCap, e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset, e.lineJoin = t.lineJoin, e.lineWidth = t.lineWidth, e.miterLimit = t.miterLimit, e.strokeStyle = t.strokeStyle, this.contextStrokeState_ = { lineCap: t.lineCap, lineDash: t.lineDash, lineDashOffset: t.lineDashOffset, lineJoin: t.lineJoin, lineWidth: t.lineWidth, miterLimit: t.miterLimit, strokeStyle: t.strokeStyle });
        }
        setContextTextState_(t) {
          const e = this.context_, i = this.contextTextState_, r = t.textAlign ? t.textAlign : vA;
          i ? (i.font != t.font && (i.font = t.font, e.font = t.font), i.textAlign != r && (i.textAlign = r, e.textAlign = r), i.textBaseline != t.textBaseline && (i.textBaseline = t.textBaseline, e.textBaseline = t.textBaseline)) : (e.font = t.font, e.textAlign = r, e.textBaseline = t.textBaseline, this.contextTextState_ = { font: t.font, textAlign: r, textBaseline: t.textBaseline });
        }
        setFillStrokeStyle(t, e) {
          if (!t) this.fillState_ = null;
          else {
            const i = t.getColor();
            this.fillState_ = { fillStyle: _o(i || hr) };
          }
          if (!e) this.strokeState_ = null;
          else {
            const i = e.getColor(), r = e.getLineCap(), a = e.getLineDash(), o = e.getLineDashOffset(), s = e.getLineJoin(), l = e.getWidth(), u = e.getMiterLimit(), h = a || Es;
            this.strokeState_ = { lineCap: r !== void 0 ? r : sf, lineDash: this.pixelRatio_ === 1 ? h : h.map((c) => c * this.pixelRatio_), lineDashOffset: (o || Is) * this.pixelRatio_, lineJoin: s !== void 0 ? s : lf, lineWidth: (l !== void 0 ? l : yA) * this.pixelRatio_, miterLimit: u !== void 0 ? u : AA, strokeStyle: _o(i || pA) };
          }
        }
        setImageStyle(t) {
          let e;
          if (!t || !(e = t.getSize())) {
            this.image_ = null;
            return;
          }
          const i = t.getPixelRatio(this.pixelRatio_), r = t.getAnchor(), a = t.getOrigin();
          this.image_ = t.getImage(this.pixelRatio_), this.imageAnchorX_ = r[0] * i, this.imageAnchorY_ = r[1] * i, this.imageHeight_ = e[1] * i, this.imageOpacity_ = t.getOpacity(), this.imageOriginX_ = a[0], this.imageOriginY_ = a[1], this.imageRotateWithView_ = t.getRotateWithView(), this.imageRotation_ = t.getRotation();
          const o = t.getScaleArray();
          this.imageScale_ = [o[0] * this.pixelRatio_ / i, o[1] * this.pixelRatio_ / i], this.imageWidth_ = e[0] * i;
        }
        setTextStyle(t) {
          if (!t) this.text_ = "";
          else {
            const e = t.getFill();
            if (!e) this.textFillState_ = null;
            else {
              const g = e.getColor();
              this.textFillState_ = { fillStyle: _o(g || hr) };
            }
            const i = t.getStroke();
            if (!i) this.textStrokeState_ = null;
            else {
              const g = i.getColor(), d = i.getLineCap(), A = i.getLineDash(), p = i.getLineDashOffset(), v = i.getLineJoin(), y = i.getWidth(), m = i.getMiterLimit();
              this.textStrokeState_ = { lineCap: d !== void 0 ? d : sf, lineDash: A || Es, lineDashOffset: p || Is, lineJoin: v !== void 0 ? v : lf, lineWidth: y !== void 0 ? y : yA, miterLimit: m !== void 0 ? m : AA, strokeStyle: _o(g || pA) };
            }
            const r = t.getFont(), a = t.getOffsetX(), o = t.getOffsetY(), s = t.getRotateWithView(), l = t.getRotation(), u = t.getScaleArray(), h = t.getText(), c = t.getTextAlign(), f = t.getTextBaseline();
            this.textState_ = { font: r !== void 0 ? r : HN, textAlign: c !== void 0 ? c : vA, textBaseline: f !== void 0 ? f : Nm }, this.text_ = h !== void 0 ? Array.isArray(h) ? h.reduce((g, d, A) => g += A % 2 ? " " : d, "") : h : "", this.textOffsetX_ = a !== void 0 ? this.pixelRatio_ * a : 0, this.textOffsetY_ = o !== void 0 ? this.pixelRatio_ * o : 0, this.textRotateWithView_ = s !== void 0 ? s : false, this.textRotation_ = l !== void 0 ? l : 0, this.textScale_ = [this.pixelRatio_ * u[0], this.pixelRatio_ * u[1]];
          }
        }
      }
      const Eo = 0.5;
      function Btt(n, t, e, i, r, a, o, s, l) {
        const u = r, h = n[0] * Eo, c = n[1] * Eo, f = In(h, c);
        f.imageSmoothingEnabled = false;
        const g = f.canvas, d = new Ttt(f, Eo, r, null, o, s, null), A = e.length, p = Math.floor((256 * 256 * 256 - 1) / A), v = {};
        for (let m = 1; m <= A; ++m) {
          const _ = e[m - 1], I = _.getStyleFunction() || i;
          if (!I) continue;
          let E = I(_, a);
          if (!E) continue;
          Array.isArray(E) || (E = [E]);
          const w = (m * p).toString(16).padStart(7, "#00000");
          for (let C = 0, S = E.length; C < S; ++C) {
            const b = E[C], T = b.getGeometryFunction()(_);
            if (!T || !Ai(u, T.getExtent())) continue;
            const B = b.clone(), R = B.getFill();
            R && R.setColor(w);
            const M = B.getStroke();
            M && (M.setColor(w), M.setLineDash(null)), B.setText(void 0);
            const L = b.getImage();
            if (L) {
              const O = L.getImageSize();
              if (!O) continue;
              const Q = In(O[0], O[1], void 0, { alpha: false }), j = Q.canvas;
              Q.fillStyle = w, Q.fillRect(0, 0, j.width, j.height), B.setImage(new Qr({ img: j, anchor: L.getAnchor(), anchorXUnits: "pixels", anchorYUnits: "pixels", offset: L.getOrigin(), opacity: 1, size: L.getSize(), scale: L.getScale(), rotation: L.getRotation(), rotateWithView: L.getRotateWithView() }));
            }
            const N = B.getZIndex() || 0;
            let F = v[N];
            F || (F = {}, v[N] = F, F.Polygon = [], F.Circle = [], F.LineString = [], F.Point = []);
            const k = T.getType();
            if (k === "GeometryCollection") {
              const O = T.getGeometriesArrayRecursive();
              for (let Q = 0, j = O.length; Q < j; ++Q) {
                const Y = O[Q];
                F[Y.getType().replace("Multi", "")].push(Y, B);
              }
            } else F[k.replace("Multi", "")].push(T, B);
          }
        }
        const y = Object.keys(v).map(Number).sort(Rr);
        for (let m = 0, _ = y.length; m < _; ++m) {
          const I = v[y[m]];
          for (const E in I) {
            const x = I[E];
            for (let w = 0, C = x.length; w < C; w += 2) {
              d.setStyle(x[w + 1]);
              for (let S = 0, b = t.length; S < b; ++S) d.setTransform(t[S]), d.drawGeometry(x[w]);
            }
          }
        }
        return f.getImageData(0, 0, g.width, g.height);
      }
      function Mtt(n, t, e) {
        const i = [];
        if (e) {
          const r = Math.floor(Math.round(n[0]) * Eo), a = Math.floor(Math.round(n[1]) * Eo), o = (Ze(r, 0, e.width - 1) + Ze(a, 0, e.height - 1) * e.width) * 4, s = e.data[o], l = e.data[o + 1], h = e.data[o + 2] + 256 * (l + 256 * s), c = Math.floor((256 * 256 * 256 - 1) / t.length);
          h && h % c === 0 && i.push(t[h / c - 1]);
        }
        return i;
      }
      const Dtt = 0.5, MF = { Point: Qtt, LineString: Ftt, Polygon: Gtt, MultiPoint: ztt, MultiLineString: ktt, MultiPolygon: Ott, GeometryCollection: Ntt, Circle: Ltt };
      function Rtt(n, t) {
        return parseInt(xt(n), 10) - parseInt(xt(t), 10);
      }
      function DF(n, t) {
        const e = RF(n, t);
        return e * e;
      }
      function RF(n, t) {
        return Dtt * n / t;
      }
      function Ltt(n, t, e, i, r) {
        const a = e.getFill(), o = e.getStroke();
        if (a || o) {
          const l = n.getBuilder(e.getZIndex(), "Circle");
          l.setFillStrokeStyle(a, o), l.drawCircle(t, i, r);
        }
        const s = e.getText();
        if (s && s.getText()) {
          const l = n.getBuilder(e.getZIndex(), "Text");
          l.setTextStyle(s), l.drawText(t, i);
        }
      }
      function LF(n, t, e, i, r, a, o, s) {
        const l = [], u = e.getImage();
        if (u) {
          let f = true;
          const g = u.getImageState();
          g == Mt.LOADED || g == Mt.ERROR ? f = false : g == Mt.IDLE && u.load(), f && l.push(u.ready());
        }
        const h = e.getFill();
        h && h.loading() && l.push(h.ready());
        const c = l.length > 0;
        return c && Promise.all(l).then(() => r(null)), Ptt(n, t, e, i, a, o, s), c;
      }
      function Ptt(n, t, e, i, r, a, o) {
        const s = e.getGeometryFunction()(t);
        if (!s) return;
        const l = s.simplifyTransformed(i, r);
        if (e.getRenderer()) PF(n, l, e, t, o);
        else {
          const h = MF[l.getType()];
          h(n, l, e, t, o, a);
        }
      }
      function PF(n, t, e, i, r) {
        if (t.getType() == "GeometryCollection") {
          const o = t.getGeometries();
          for (let s = 0, l = o.length; s < l; ++s) PF(n, o[s], e, i, r);
          return;
        }
        n.getBuilder(e.getZIndex(), "Default").drawCustom(t, i, e.getRenderer(), e.getHitDetectionRenderer(), r);
      }
      function Ntt(n, t, e, i, r, a) {
        const o = t.getGeometriesArray();
        let s, l;
        for (s = 0, l = o.length; s < l; ++s) {
          const u = MF[o[s].getType()];
          u(n, o[s], e, i, r, a);
        }
      }
      function Ftt(n, t, e, i, r) {
        const a = e.getStroke();
        if (a) {
          const s = n.getBuilder(e.getZIndex(), "LineString");
          s.setFillStrokeStyle(null, a), s.drawLineString(t, i, r);
        }
        const o = e.getText();
        if (o && o.getText()) {
          const s = n.getBuilder(e.getZIndex(), "Text");
          s.setTextStyle(o), s.drawText(t, i, r);
        }
      }
      function ktt(n, t, e, i, r) {
        const a = e.getStroke();
        if (a) {
          const s = n.getBuilder(e.getZIndex(), "LineString");
          s.setFillStrokeStyle(null, a), s.drawMultiLineString(t, i, r);
        }
        const o = e.getText();
        if (o && o.getText()) {
          const s = n.getBuilder(e.getZIndex(), "Text");
          s.setTextStyle(o), s.drawText(t, i, r);
        }
      }
      function Ott(n, t, e, i, r) {
        const a = e.getFill(), o = e.getStroke();
        if (o || a) {
          const l = n.getBuilder(e.getZIndex(), "Polygon");
          l.setFillStrokeStyle(a, o), l.drawMultiPolygon(t, i, r);
        }
        const s = e.getText();
        if (s && s.getText()) {
          const l = n.getBuilder(e.getZIndex(), "Text");
          l.setTextStyle(s), l.drawText(t, i, r);
        }
      }
      function Qtt(n, t, e, i, r, a) {
        const o = e.getImage(), s = e.getText(), l = s && s.getText(), u = a && o && l ? {} : void 0;
        if (o) {
          if (o.getImageState() != Mt.LOADED) return;
          const h = n.getBuilder(e.getZIndex(), "Image");
          h.setImageStyle(o, u), h.drawPoint(t, i, r);
        }
        if (l) {
          const h = n.getBuilder(e.getZIndex(), "Text");
          h.setTextStyle(s, u), h.drawText(t, i, r);
        }
      }
      function ztt(n, t, e, i, r, a) {
        const o = e.getImage(), s = o && o.getOpacity() !== 0, l = e.getText(), u = l && l.getText(), h = a && s && u ? {} : void 0;
        if (s) {
          if (o.getImageState() != Mt.LOADED) return;
          const c = n.getBuilder(e.getZIndex(), "Image");
          c.setImageStyle(o, h), c.drawMultiPoint(t, i, r);
        }
        if (u) {
          const c = n.getBuilder(e.getZIndex(), "Text");
          c.setTextStyle(l, h), c.drawText(t, i, r);
        }
      }
      function Gtt(n, t, e, i, r) {
        const a = e.getFill(), o = e.getStroke();
        if (a || o) {
          const l = n.getBuilder(e.getZIndex(), "Polygon");
          l.setFillStrokeStyle(a, o), l.drawPolygon(t, i, r);
        }
        const s = e.getText();
        if (s && s.getText()) {
          const l = n.getBuilder(e.getZIndex(), "Text");
          l.setTextStyle(s), l.drawText(t, i, r);
        }
      }
      class Utt extends Ym {
        constructor(t) {
          super(t), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.clipped_ = false, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = ai(), this.wrappedRenderedExtent_ = ai(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedPixelRatio_ = 1, this.renderedRenderOrder_ = null, this.renderedFrameDeclutter_, this.replayGroup_ = null, this.replayGroupChanged = true, this.clipping = true, this.targetContext_ = null, this.opacity_ = 1;
        }
        renderWorlds(t, e, i) {
          const r = e.extent, a = e.viewState, o = a.center, s = a.resolution, l = a.projection, u = a.rotation, h = l.getExtent(), c = this.getLayer().getSource(), f = this.getLayer().getDeclutter(), g = e.pixelRatio, d = e.viewHints, A = !(d[xn.ANIMATING] || d[xn.INTERACTING]), p = this.context, v = Math.round(he(r) / s * g), y = Math.round(dn(r) / s * g), m = c.getWrapX() && l.canWrapX(), _ = m ? he(h) : null, I = m ? Math.ceil((r[2] - h[2]) / _) + 1 : 1;
          let E = m ? Math.floor((r[0] - h[0]) / _) : 0;
          do {
            let x = this.getRenderTransform(o, s, 0, g, v, y, E * _);
            e.declutter && (x = x.slice(0)), t.execute(p, [p.canvas.width, p.canvas.height], x, u, A, i === void 0 ? vf : i ? BF : Ctt, i ? f && e.declutter[f] : void 0);
          } while (++E < I);
        }
        setDrawContext_() {
          this.opacity_ !== 1 && (this.targetContext_ = this.context, this.context = In(this.context.canvas.width, this.context.canvas.height, SF));
        }
        resetDrawContext_() {
          if (this.opacity_ !== 1) {
            const t = this.targetContext_.globalAlpha;
            this.targetContext_.globalAlpha = this.opacity_, this.targetContext_.drawImage(this.context.canvas, 0, 0), this.targetContext_.globalAlpha = t, Mm(this.context), SF.push(this.context.canvas), this.context = this.targetContext_, this.targetContext_ = null;
          }
        }
        renderDeclutter(t) {
          !this.replayGroup_ || !this.getLayer().getDeclutter() || this.renderWorlds(this.replayGroup_, t, true);
        }
        renderDeferredInternal(t) {
          this.replayGroup_ && (this.replayGroup_.renderDeferred(), this.clipped_ && this.context.restore(), this.resetDrawContext_());
        }
        renderFrame(t, e) {
          const i = t.layerStatesArray[t.layerIndex];
          this.opacity_ = i.opacity;
          const r = t.viewState;
          this.prepareContainer(t, e);
          const a = this.context, o = this.replayGroup_;
          let s = o && !o.isEmpty();
          if (!s && !(this.getLayer().hasListener(si.PRERENDER) || this.getLayer().hasListener(si.POSTRENDER))) return null;
          if (this.setDrawContext_(), this.preRender(a, t), r.projection, this.clipped_ = false, s && i.extent && this.clipping) {
            const l = zi(i.extent);
            s = Ai(l, t.extent), this.clipped_ = s && !Pr(l, t.extent), this.clipped_ && this.clipUnrotated(a, t, l);
          }
          return s && this.renderWorlds(o, t, this.getLayer().getDeclutter() ? false : void 0), !t.declutter && this.clipped_ && a.restore(), this.postRender(a, t), this.renderedRotation_ !== r.rotation && (this.renderedRotation_ = r.rotation, this.hitDetectionImageData_ = null), t.declutter || this.resetDrawContext_(), this.container;
        }
        getFeatures(t) {
          return new Promise((e) => {
            if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
              const i = this.frameState.size.slice(), r = this.renderedCenter_, a = this.renderedResolution_, o = this.renderedRotation_, s = this.renderedProjection_, l = this.wrappedRenderedExtent_, u = this.getLayer(), h = [], c = i[0] * Eo, f = i[1] * Eo;
              h.push(this.getRenderTransform(r, a, o, Eo, c, f, 0).slice());
              const g = u.getSource(), d = s.getExtent();
              if (g.getWrapX() && s.canWrapX() && !Pr(d, l)) {
                let A = l[0];
                const p = he(d);
                let v = 0, y;
                for (; A < d[0]; ) --v, y = p * v, h.push(this.getRenderTransform(r, a, o, Eo, c, f, y).slice()), A += p;
                for (v = 0, A = l[2]; A > d[2]; ) ++v, y = p * v, h.push(this.getRenderTransform(r, a, o, Eo, c, f, y).slice()), A -= p;
              }
              this.hitDetectionImageData_ = Btt(i, h, this.renderedFeatures_, u.getStyleFunction(), l, a, o, DF(a, this.renderedPixelRatio_));
            }
            e(Mtt(t, this.renderedFeatures_, this.hitDetectionImageData_));
          });
        }
        forEachFeatureAtCoordinate(t, e, i, r, a) {
          if (!this.replayGroup_) return;
          const o = e.viewState.resolution, s = e.viewState.rotation, l = this.getLayer(), u = {}, h = function(f, g, d) {
            const A = xt(f), p = u[A];
            if (p) {
              if (p !== true && d < p.distanceSq) {
                if (d === 0) return u[A] = true, a.splice(a.lastIndexOf(p), 1), r(f, l, g);
                p.geometry = g, p.distanceSq = d;
              }
            } else {
              if (d === 0) return u[A] = true, r(f, l, g);
              a.push(u[A] = { feature: f, layer: l, geometry: g, distanceSq: d, callback: r });
            }
          }, c = this.getLayer().getDeclutter();
          return this.replayGroup_.forEachFeatureAtCoordinate(t, o, s, i, h, c ? e.declutter[c].all().map((f) => f.value) : null);
        }
        handleFontsChanged() {
          const t = this.getLayer();
          t.getVisible() && this.replayGroup_ && t.changed();
        }
        handleStyleImageChange_(t) {
          this.renderIfReadyAndVisible();
        }
        prepareFrame(t) {
          const e = this.getLayer(), i = e.getSource();
          if (!i) return false;
          const r = t.viewHints[xn.ANIMATING], a = t.viewHints[xn.INTERACTING], o = e.getUpdateWhileAnimating(), s = e.getUpdateWhileInteracting();
          if (this.ready && !o && r || !s && a) return this.animatingOrInteracting_ = true, true;
          this.animatingOrInteracting_ = false;
          const l = t.extent, u = t.viewState, h = u.projection, c = u.resolution, f = t.pixelRatio, g = e.getRevision(), d = e.getRenderBuffer();
          let A = e.getRenderOrder();
          A === void 0 && (A = Rtt);
          const p = u.center.slice(), v = fo(l, d * c), y = v.slice(), m = [v.slice()], _ = h.getExtent();
          if (i.getWrapX() && h.canWrapX() && !Pr(_, t.extent)) {
            const R = he(_), M = Math.max(he(v) / 2, R);
            v[0] = _[0] - M, v[2] = _[2] + M, Px(p, h);
            const L = VP(m[0], h);
            L[0] < _[0] && L[2] < _[2] ? m.push([L[0] + R, L[1], L[2] + R, L[3]]) : L[0] > _[0] && L[2] > _[2] && m.push([L[0] - R, L[1], L[2] - R, L[3]]);
          }
          if (this.ready && this.renderedResolution_ == c && this.renderedRevision_ == g && this.renderedRenderOrder_ == A && this.renderedFrameDeclutter_ === !!t.declutter && Pr(this.wrappedRenderedExtent_, v)) return co(this.renderedExtent_, y) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = y), this.renderedCenter_ = p, this.replayGroupChanged = false, true;
          this.replayGroup_ = null;
          const I = new mtt(RF(c, f), v, c, f);
          let E;
          for (let R = 0, M = m.length; R < M; ++R) i.loadFeatures(m[R], c, h);
          const x = DF(c, f);
          let w = true;
          const C = (R, M) => {
            let L;
            const N = R.getStyleFunction() || e.getStyleFunction();
            if (N && (L = N(R, c)), L) {
              const F = this.renderFeature(R, x, L, I, E, this.getLayer().getDeclutter(), M);
              w = w && !F;
            }
          }, S = sA(v), b = i.getFeaturesInExtent(S);
          A && b.sort(A);
          for (let R = 0, M = b.length; R < M; ++R) C(b[R], R);
          this.renderedFeatures_ = b, this.ready = w;
          const T = I.finish(), B = new Stt(v, c, f, i.getOverlaps(), T, e.getRenderBuffer(), !!t.declutter);
          return this.renderedResolution_ = c, this.renderedRevision_ = g, this.renderedRenderOrder_ = A, this.renderedFrameDeclutter_ = !!t.declutter, this.renderedExtent_ = y, this.wrappedRenderedExtent_ = v, this.renderedCenter_ = p, this.renderedProjection_ = h, this.renderedPixelRatio_ = f, this.replayGroup_ = B, this.hitDetectionImageData_ = null, this.replayGroupChanged = true, true;
        }
        renderFeature(t, e, i, r, a, o, s) {
          if (!i) return false;
          let l = false;
          if (Array.isArray(i)) for (let u = 0, h = i.length; u < h; ++u) l = LF(r, t, i[u], e, this.boundHandleStyleImageChange_, a, o, s) || l;
          else l = LF(r, t, i, e, this.boundHandleStyleImageChange_, a, o, s);
          return l;
        }
      }
      class aa extends bA {
        constructor(t) {
          super(t);
        }
        createRenderer() {
          return new Utt(this);
        }
      }
      class Wm {
        constructor(t) {
          this.rbush_ = new rF(t), this.items_ = {};
        }
        insert(t, e) {
          const i = { minX: t[0], minY: t[1], maxX: t[2], maxY: t[3], value: e };
          this.rbush_.insert(i), this.items_[xt(e)] = i;
        }
        load(t, e) {
          const i = new Array(e.length);
          for (let r = 0, a = e.length; r < a; r++) {
            const o = t[r], s = e[r], l = { minX: o[0], minY: o[1], maxX: o[2], maxY: o[3], value: s };
            i[r] = l, this.items_[xt(s)] = l;
          }
          this.rbush_.load(i);
        }
        remove(t) {
          const e = xt(t), i = this.items_[e];
          return delete this.items_[e], this.rbush_.remove(i) !== null;
        }
        update(t, e) {
          const i = this.items_[xt(e)], r = [i.minX, i.minY, i.maxX, i.maxY];
          As(r, t) || (this.remove(e), this.insert(t, e));
        }
        getAll() {
          return this.rbush_.all().map(function(e) {
            return e.value;
          });
        }
        getInExtent(t) {
          const e = { minX: t[0], minY: t[1], maxX: t[2], maxY: t[3] };
          return this.rbush_.search(e).map(function(r) {
            return r.value;
          });
        }
        forEach(t) {
          return this.forEach_(this.getAll(), t);
        }
        forEachInExtent(t, e) {
          return this.forEach_(this.getInExtent(t), e);
        }
        forEach_(t, e) {
          let i;
          for (let r = 0, a = t.length; r < a; r++) if (i = e(t[r]), i) return i;
          return i;
        }
        isEmpty() {
          return vl(this.items_);
        }
        clear() {
          this.rbush_.clear(), this.items_ = {};
        }
        getExtent(t) {
          const e = this.rbush_.toJSON();
          return ta(e.minX, e.minY, e.maxX, e.maxY, t);
        }
        concat(t) {
          this.rbush_.load(t.rbush_.all());
          for (const e in t.items_) this.items_[e] = t.items_[e];
        }
      }
      let MA = class TZ extends Oa {
        constructor(t, e, i) {
          super(), i !== void 0 && e === void 0 ? this.setFlatCoordinates(i, t) : (e = e || 0, this.setCenterAndRadius(t, e, i));
        }
        clone() {
          const t = new TZ(this.flatCoordinates.slice(), void 0, this.layout);
          return t.applyProperties(this), t;
        }
        closestPointXY(t, e, i, r) {
          const a = this.flatCoordinates, o = t - a[0], s = e - a[1], l = o * o + s * s;
          if (l < r) {
            if (l === 0) for (let u = 0; u < this.stride; ++u) i[u] = a[u];
            else {
              const u = this.getRadius() / Math.sqrt(l);
              i[0] = a[0] + u * o, i[1] = a[1] + u * s;
              for (let h = 2; h < this.stride; ++h) i[h] = a[h];
            }
            return i.length = this.stride, l;
          }
          return r;
        }
        containsXY(t, e) {
          const i = this.flatCoordinates, r = t - i[0], a = e - i[1];
          return r * r + a * a <= this.getRadiusSquared_();
        }
        getCenter() {
          return this.flatCoordinates.slice(0, this.stride);
        }
        computeExtent(t) {
          const e = this.flatCoordinates, i = e[this.stride] - e[0];
          return ta(e[0] - i, e[1] - i, e[0] + i, e[1] + i, t);
        }
        getRadius() {
          return Math.sqrt(this.getRadiusSquared_());
        }
        getRadiusSquared_() {
          const t = this.flatCoordinates[this.stride] - this.flatCoordinates[0], e = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
          return t * t + e * e;
        }
        getType() {
          return "Circle";
        }
        intersectsExtent(t) {
          const e = this.getExtent();
          if (Ai(t, e)) {
            const i = this.getCenter();
            return t[0] <= i[0] && t[2] >= i[0] || t[1] <= i[1] && t[3] >= i[1] ? true : Tx(t, this.intersectsCoordinate.bind(this));
          }
          return false;
        }
        setCenter(t) {
          const e = this.stride, i = this.flatCoordinates[e] - this.flatCoordinates[0], r = t.slice();
          r[e] = r[0] + i;
          for (let a = 1; a < e; ++a) r[e + a] = t[a];
          this.setFlatCoordinates(this.layout, r), this.changed();
        }
        setCenterAndRadius(t, e, i) {
          this.setLayout(i, t, 0), this.flatCoordinates || (this.flatCoordinates = []);
          const r = this.flatCoordinates;
          let a = pN(r, 0, t, this.stride);
          r[a++] = r[0] + e;
          for (let o = 1, s = this.stride; o < s; ++o) r[a++] = r[o];
          r.length = a, this.changed();
        }
        getCoordinates() {
          return null;
        }
        setCoordinates(t, e) {
        }
        setRadius(t) {
          this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t, this.changed();
        }
        rotate(t, e) {
          const i = this.getCenter(), r = this.getStride();
          this.setCenter(jx(i, 0, i.length, r, t, e, i)), this.changed();
        }
      };
      MA.prototype.transform;
      class wn extends wm {
        constructor(t) {
          super(), this.geometries_ = t, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
        }
        unlistenGeometriesChange_() {
          this.changeEventsKeys_.forEach(we), this.changeEventsKeys_.length = 0;
        }
        listenGeometriesChange_() {
          const t = this.geometries_;
          for (let e = 0, i = t.length; e < i; ++e) this.changeEventsKeys_.push(Ut(t[e], Rt.CHANGE, this.changed, this));
        }
        clone() {
          const t = new wn(Nw(this.geometries_));
          return t.applyProperties(this), t;
        }
        closestPointXY(t, e, i, r) {
          if (r < Qu(this.getExtent(), t, e)) return r;
          const a = this.geometries_;
          for (let o = 0, s = a.length; o < s; ++o) r = a[o].closestPointXY(t, e, i, r);
          return r;
        }
        containsXY(t, e) {
          const i = this.geometries_;
          for (let r = 0, a = i.length; r < a; ++r) if (i[r].containsXY(t, e)) return true;
          return false;
        }
        computeExtent(t) {
          Hc(t);
          const e = this.geometries_;
          for (let i = 0, r = e.length; i < r; ++i) bx(t, e[i].getExtent());
          return t;
        }
        getGeometries() {
          return Nw(this.geometries_);
        }
        getGeometriesArray() {
          return this.geometries_;
        }
        getGeometriesArrayRecursive() {
          let t = [];
          const e = this.geometries_;
          for (let i = 0, r = e.length; i < r; ++i) e[i].getType() === this.getType() ? t = t.concat(e[i].getGeometriesArrayRecursive()) : t.push(e[i]);
          return t;
        }
        getSimplifiedGeometry(t) {
          if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t < this.simplifiedGeometryMaxMinSquaredTolerance) return this;
          const e = [], i = this.geometries_;
          let r = false;
          for (let a = 0, o = i.length; a < o; ++a) {
            const s = i[a], l = s.getSimplifiedGeometry(t);
            e.push(l), l !== s && (r = true);
          }
          return r ? new wn(e) : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
        }
        getType() {
          return "GeometryCollection";
        }
        intersectsExtent(t) {
          const e = this.geometries_;
          for (let i = 0, r = e.length; i < r; ++i) if (e[i].intersectsExtent(t)) return true;
          return false;
        }
        isEmpty() {
          return this.geometries_.length === 0;
        }
        rotate(t, e) {
          const i = this.geometries_;
          for (let r = 0, a = i.length; r < a; ++r) i[r].rotate(t, e);
          this.changed();
        }
        scale(t, e, i) {
          i || (i = Nr(this.getExtent()));
          const r = this.geometries_;
          for (let a = 0, o = r.length; a < o; ++a) r[a].scale(t, e, i);
          this.changed();
        }
        setGeometries(t) {
          this.setGeometriesArray(Nw(t));
        }
        setGeometriesArray(t) {
          this.unlistenGeometriesChange_(), this.geometries_ = t, this.listenGeometriesChange_(), this.changed();
        }
        applyTransform(t) {
          const e = this.geometries_;
          for (let i = 0, r = e.length; i < r; ++i) e[i].applyTransform(t);
          this.changed();
        }
        translate(t, e) {
          const i = this.geometries_;
          for (let r = 0, a = i.length; r < a; ++r) i[r].translate(t, e);
          this.changed();
        }
        disposeInternal() {
          this.unlistenGeometriesChange_(), super.disposeInternal();
        }
      }
      function Nw(n) {
        return n.map((t) => t.clone());
      }
      class ui extends Oa {
        constructor(t, e, i) {
          if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(t[0])) this.setCoordinates(t, e);
          else if (e !== void 0 && i) this.setFlatCoordinates(e, t), this.ends_ = i;
          else {
            const r = t, a = [], o = [];
            for (let l = 0, u = r.length; l < u; ++l) {
              const h = r[l];
              Le(a, h.getFlatCoordinates()), o.push(a.length);
            }
            const s = r.length === 0 ? this.getLayout() : r[0].getLayout();
            this.setFlatCoordinates(s, a), this.ends_ = o;
          }
        }
        appendLineString(t) {
          Le(this.flatCoordinates, t.getFlatCoordinates().slice()), this.ends_.push(this.flatCoordinates.length), this.changed();
        }
        clone() {
          const t = new ui(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
          return t.applyProperties(this), t;
        }
        closestPointXY(t, e, i, r) {
          return r < Qu(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(Hx(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Wx(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, t, e, i, r));
        }
        getCoordinateAtM(t, e, i) {
          return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (e = e !== void 0 ? e : false, i = i !== void 0 ? i : false, JK(this.flatCoordinates, 0, this.ends_, this.stride, t, e, i));
        }
        getCoordinates() {
          return cA(this.flatCoordinates, 0, this.ends_, this.stride);
        }
        getEnds() {
          return this.ends_;
        }
        getLineString(t) {
          return t < 0 || this.ends_.length <= t ? null : new Be(this.flatCoordinates.slice(t === 0 ? 0 : this.ends_[t - 1], this.ends_[t]), this.layout);
        }
        getLineStrings() {
          const t = this.flatCoordinates, e = this.ends_, i = this.layout, r = [];
          let a = 0;
          for (let o = 0, s = e.length; o < s; ++o) {
            const l = e[o], u = new Be(t.slice(a, l), i);
            r.push(u), a = l;
          }
          return r;
        }
        getFlatMidpoints() {
          const t = [], e = this.flatCoordinates;
          let i = 0;
          const r = this.ends_, a = this.stride;
          for (let o = 0, s = r.length; o < s; ++o) {
            const l = r[o], u = Dm(e, i, l, a, 0.5);
            Le(t, u), i = l;
          }
          return t;
        }
        getSimplifiedGeometryInternal(t) {
          const e = [], i = [];
          return e.length = yN(this.flatCoordinates, 0, this.ends_, this.stride, t, e, 0, i), new ui(e, "XY", i);
        }
        getType() {
          return "MultiLineString";
        }
        intersectsExtent(t) {
          return PK(this.flatCoordinates, 0, this.ends_, this.stride, t);
        }
        setCoordinates(t, e) {
          this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
          const i = hA(this.flatCoordinates, 0, t, this.stride, this.ends_);
          this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1], this.changed();
        }
      }
      class fr extends Oa {
        constructor(t, e) {
          super(), e && !Array.isArray(t[0]) ? this.setFlatCoordinates(e, t) : this.setCoordinates(t, e);
        }
        appendPoint(t) {
          Le(this.flatCoordinates, t.getFlatCoordinates()), this.changed();
        }
        clone() {
          const t = new fr(this.flatCoordinates.slice(), this.layout);
          return t.applyProperties(this), t;
        }
        closestPointXY(t, e, i, r) {
          if (r < Qu(this.getExtent(), t, e)) return r;
          const a = this.flatCoordinates, o = this.stride;
          for (let s = 0, l = a.length; s < l; s += o) {
            const u = vs(t, e, a[s], a[s + 1]);
            if (u < r) {
              r = u;
              for (let h = 0; h < o; ++h) i[h] = a[s + h];
              i.length = o;
            }
          }
          return r;
        }
        getCoordinates() {
          return ms(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
        }
        getPoint(t) {
          const e = this.flatCoordinates.length / this.stride;
          return t < 0 || e <= t ? null : new Ge(this.flatCoordinates.slice(t * this.stride, (t + 1) * this.stride), this.layout);
        }
        getPoints() {
          const t = this.flatCoordinates, e = this.layout, i = this.stride, r = [];
          for (let a = 0, o = t.length; a < o; a += i) {
            const s = new Ge(t.slice(a, a + i), e);
            r.push(s);
          }
          return r;
        }
        getType() {
          return "MultiPoint";
        }
        intersectsExtent(t) {
          const e = this.flatCoordinates, i = this.stride;
          for (let r = 0, a = e.length; r < a; r += i) {
            const o = e[r], s = e[r + 1];
            if (xx(t, o, s)) return true;
          }
          return false;
        }
        setCoordinates(t, e) {
          this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = uA(this.flatCoordinates, 0, t, this.stride), this.changed();
        }
      }
      function NF(n, t, e, i) {
        const r = [];
        let a = ai();
        for (let o = 0, s = e.length; o < s; ++o) {
          const l = e[o];
          a = Sx(n, t, l[0], i), r.push((a[0] + a[2]) / 2, (a[1] + a[3]) / 2), t = l[l.length - 1];
        }
        return r;
      }
      class bi extends Oa {
        constructor(t, e, i) {
          if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !i && !Array.isArray(t[0])) {
            const r = t, a = [], o = [];
            for (let s = 0, l = r.length; s < l; ++s) {
              const u = r[s], h = a.length, c = u.getEnds();
              for (let f = 0, g = c.length; f < g; ++f) c[f] += h;
              Le(a, u.getFlatCoordinates()), o.push(c);
            }
            e = r.length === 0 ? this.getLayout() : r[0].getLayout(), t = a, i = o;
          }
          e !== void 0 && i ? (this.setFlatCoordinates(e, t), this.endss_ = i) : this.setCoordinates(t, e);
        }
        appendPolygon(t) {
          let e;
          if (!this.flatCoordinates) this.flatCoordinates = t.getFlatCoordinates().slice(), e = t.getEnds().slice(), this.endss_.push();
          else {
            const i = this.flatCoordinates.length;
            Le(this.flatCoordinates, t.getFlatCoordinates()), e = t.getEnds().slice();
            for (let r = 0, a = e.length; r < a; ++r) e[r] += i;
          }
          this.endss_.push(e), this.changed();
        }
        clone() {
          const t = this.endss_.length, e = new Array(t);
          for (let r = 0; r < t; ++r) e[r] = this.endss_[r].slice();
          const i = new bi(this.flatCoordinates.slice(), this.layout, e);
          return i.applyProperties(this), i;
        }
        closestPointXY(t, e, i, r) {
          return r < Qu(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(bK(this.flatCoordinates, 0, this.endss_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), TK(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, t, e, i, r));
        }
        containsXY(t, e) {
          return LK(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t, e);
        }
        getArea() {
          return DK(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
        }
        getCoordinates(t) {
          let e;
          return t !== void 0 ? (e = this.getOrientedFlatCoordinates().slice(), tw(e, 0, this.endss_, this.stride, t)) : e = this.flatCoordinates, $x(e, 0, this.endss_, this.stride);
        }
        getEndss() {
          return this.endss_;
        }
        getFlatInteriorPoints() {
          if (this.flatInteriorPointsRevision_ != this.getRevision()) {
            const t = NF(this.flatCoordinates, 0, this.endss_, this.stride);
            this.flatInteriorPoints_ = EN(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t), this.flatInteriorPointsRevision_ = this.getRevision();
          }
          return this.flatInteriorPoints_;
        }
        getInteriorPoints() {
          return new fr(this.getFlatInteriorPoints().slice(), "XYM");
        }
        getOrientedFlatCoordinates() {
          if (this.orientedRevision_ != this.getRevision()) {
            const t = this.flatCoordinates;
            CN(t, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = tw(this.orientedFlatCoordinates_, 0, this.endss_, this.stride)), this.orientedRevision_ = this.getRevision();
          }
          return this.orientedFlatCoordinates_;
        }
        getSimplifiedGeometryInternal(t) {
          const e = [], i = [];
          return e.length = MK(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(t), e, 0, i), new bi(e, "XY", i);
        }
        getPolygon(t) {
          if (t < 0 || this.endss_.length <= t) return null;
          let e;
          if (t === 0) e = 0;
          else {
            const a = this.endss_[t - 1];
            e = a[a.length - 1];
          }
          const i = this.endss_[t].slice(), r = i[i.length - 1];
          if (e !== 0) for (let a = 0, o = i.length; a < o; ++a) i[a] -= e;
          return new Dn(this.flatCoordinates.slice(e, r), this.layout, i);
        }
        getPolygons() {
          const t = this.layout, e = this.flatCoordinates, i = this.endss_, r = [];
          let a = 0;
          for (let o = 0, s = i.length; o < s; ++o) {
            const l = i[o].slice(), u = l[l.length - 1];
            if (a !== 0) for (let c = 0, f = l.length; c < f; ++c) l[c] -= a;
            const h = new Dn(e.slice(a, u), t, l);
            r.push(h), a = u;
          }
          return r;
        }
        getType() {
          return "MultiPolygon";
        }
        intersectsExtent(t) {
          return NK(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t);
        }
        setCoordinates(t, e) {
          this.setLayout(e, t, 3), this.flatCoordinates || (this.flatCoordinates = []);
          const i = vN(this.flatCoordinates, 0, t, this.stride, this.endss_);
          if (i.length === 0) this.flatCoordinates.length = 0;
          else {
            const r = i[i.length - 1];
            this.flatCoordinates.length = r.length === 0 ? 0 : r[r.length - 1];
          }
          this.changed();
        }
      }
      const FF = an();
      class Ti {
        constructor(t, e, i, r, a, o) {
          this.styleFunction, this.extent_, this.id_ = o, this.type_ = t, this.flatCoordinates_ = e, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = i || null, this.properties_ = a, this.squaredTolerance_, this.stride_ = r, this.simplifiedGeometry_;
        }
        get(t) {
          return this.properties_[t];
        }
        getExtent() {
          return this.extent_ || (this.extent_ = this.type_ === "Point" ? Yc(this.flatCoordinates_) : Sx(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2)), this.extent_;
        }
        getFlatInteriorPoint() {
          if (!this.flatInteriorPoints_) {
            const t = Nr(this.getExtent());
            this.flatInteriorPoints_ = Kx(this.flatCoordinates_, 0, this.ends_, 2, t, 0);
          }
          return this.flatInteriorPoints_;
        }
        getFlatInteriorPoints() {
          if (!this.flatInteriorPoints_) {
            const t = ew(this.flatCoordinates_, this.ends_), e = NF(this.flatCoordinates_, 0, t, 2);
            this.flatInteriorPoints_ = EN(this.flatCoordinates_, 0, t, 2, e);
          }
          return this.flatInteriorPoints_;
        }
        getFlatMidpoint() {
          return this.flatMidpoints_ || (this.flatMidpoints_ = Dm(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5)), this.flatMidpoints_;
        }
        getFlatMidpoints() {
          if (!this.flatMidpoints_) {
            this.flatMidpoints_ = [];
            const t = this.flatCoordinates_;
            let e = 0;
            const i = this.ends_;
            for (let r = 0, a = i.length; r < a; ++r) {
              const o = i[r], s = Dm(t, e, o, 2, 0.5);
              Le(this.flatMidpoints_, s), e = o;
            }
          }
          return this.flatMidpoints_;
        }
        getId() {
          return this.id_;
        }
        getOrientedFlatCoordinates() {
          return this.flatCoordinates_;
        }
        getGeometry() {
          return this;
        }
        getSimplifiedGeometry(t) {
          return this;
        }
        simplifyTransformed(t, e) {
          return this;
        }
        getProperties() {
          return this.properties_;
        }
        getPropertiesInternal() {
          return this.properties_;
        }
        getStride() {
          return this.stride_;
        }
        getStyleFunction() {
          return this.styleFunction;
        }
        getType() {
          return this.type_;
        }
        transform(t) {
          t = qt(t);
          const e = t.getExtent(), i = t.getWorldExtent();
          if (e && i) {
            const r = dn(i) / dn(e);
            Lr(FF, i[0], i[3], r, -r, 0, 0, 0), yo(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, FF, this.flatCoordinates_);
          }
        }
        applyTransform(t) {
          t(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
        }
        clone() {
          var t;
          return new Ti(this.type_, this.flatCoordinates_.slice(), (t = this.ends_) == null ? void 0 : t.slice(), this.stride_, Object.assign({}, this.properties_), this.id_);
        }
        getEnds() {
          return this.ends_;
        }
        enableSimplifyTransformed() {
          return this.simplifyTransformed = RP((t, e) => {
            if (t === this.squaredTolerance_) return this.simplifiedGeometry_;
            this.simplifiedGeometry_ = this.clone(), e && this.simplifiedGeometry_.applyTransform(e);
            const i = this.simplifiedGeometry_.getFlatCoordinates();
            let r;
            switch (this.type_) {
              case "LineString":
                i.length = Cm(i, 0, this.simplifiedGeometry_.flatCoordinates_.length, this.simplifiedGeometry_.stride_, t, i, 0), r = [i.length];
                break;
              case "MultiLineString":
                r = [], i.length = yN(i, 0, this.simplifiedGeometry_.ends_, this.simplifiedGeometry_.stride_, t, i, 0, r);
                break;
              case "Polygon":
                r = [], i.length = Xx(i, 0, this.simplifiedGeometry_.ends_, this.simplifiedGeometry_.stride_, Math.sqrt(t), i, 0, r);
                break;
            }
            return r && (this.simplifiedGeometry_ = new Ti(this.type_, i, r, 2, this.properties_, this.id_)), this.squaredTolerance_ = t, this.simplifiedGeometry_;
          }), this;
        }
      }
      Ti.prototype.getFlatCoordinates = Ti.prototype.getOrientedFlatCoordinates;
      class Fw extends Kr {
        constructor(t) {
          var i;
          super(), this.projection = qt(t.projection), this.attributions_ = kF(t.attributions), this.attributionsCollapsible_ = (i = t.attributionsCollapsible) != null ? i : true, this.loading = false, this.state_ = t.state !== void 0 ? t.state : "ready", this.wrapX_ = t.wrapX !== void 0 ? t.wrapX : false, this.interpolate_ = !!t.interpolate, this.viewResolver = null, this.viewRejector = null;
          const e = this;
          this.viewPromise_ = new Promise(function(r, a) {
            e.viewResolver = r, e.viewRejector = a;
          });
        }
        getAttributions() {
          return this.attributions_;
        }
        getAttributionsCollapsible() {
          return this.attributionsCollapsible_;
        }
        getProjection() {
          return this.projection;
        }
        getResolutions(t) {
          return null;
        }
        getView() {
          return this.viewPromise_;
        }
        getState() {
          return this.state_;
        }
        getWrapX() {
          return this.wrapX_;
        }
        getInterpolate() {
          return this.interpolate_;
        }
        refresh() {
          this.changed();
        }
        setAttributions(t) {
          this.attributions_ = kF(t), this.changed();
        }
        setState(t) {
          this.state_ = t, this.changed();
        }
      }
      function kF(n) {
        return n ? typeof n == "function" ? n : (Array.isArray(n) || (n = [n]), (t) => n) : null;
      }
      const An = { ADDFEATURE: "addfeature", CHANGEFEATURE: "changefeature", CLEAR: "clear", REMOVEFEATURE: "removefeature", FEATURESLOADSTART: "featuresloadstart", FEATURESLOADEND: "featuresloadend", FEATURESLOADERROR: "featuresloaderror" };
      function Vtt(n, t) {
        return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
      }
      function Xm(n, t) {
        return [n];
      }
      let jtt = false;
      function qtt(n, t, e, i, r, a, o) {
        const s = new XMLHttpRequest();
        s.open("GET", typeof n == "function" ? n(e, i, r) : n, true), t.getType() == "arraybuffer" && (s.responseType = "arraybuffer"), s.withCredentials = jtt, s.onload = function(l) {
          if (!s.status || s.status >= 200 && s.status < 300) {
            const u = t.getType();
            try {
              let h;
              u == "text" || u == "json" ? h = s.responseText : u == "xml" ? h = s.responseXML || s.responseText : u == "arraybuffer" && (h = s.response), h ? a(t.readFeatures(h, { extent: e, featureProjection: r }), t.readProjection(h)) : o();
            } catch (h) {
              o();
            }
          } else o();
        }, s.onerror = o, s.send();
      }
      function OF(n, t) {
        return function(e, i, r, a, o) {
          const s = this;
          qtt(n, t, e, i, r, function(l, u) {
            s.addFeatures(l), a !== void 0 && a(l);
          }, o || Vc);
        };
      }
      class bl extends Te {
        constructor(t, e, i) {
          super(t), this.feature = e, this.features = i;
        }
      }
      class oa extends Fw {
        constructor(t) {
          t = t || {}, super({ attributions: t.attributions, interpolate: true, projection: void 0, state: "ready", wrapX: t.wrapX !== void 0 ? t.wrapX : true }), this.on, this.once, this.un, this.loader_ = Vc, this.format_ = t.format || null, this.overlaps_ = t.overlaps === void 0 ? true : t.overlaps, this.url_ = t.url, t.loader !== void 0 ? this.loader_ = t.loader : this.url_ !== void 0 && (ue(this.format_, "`format` must be set when `url` is set"), this.loader_ = OF(this.url_, this.format_)), this.strategy_ = t.strategy !== void 0 ? t.strategy : Vtt;
          const e = t.useSpatialIndex !== void 0 ? t.useSpatialIndex : true;
          this.featuresRtree_ = e ? new Wm() : null, this.loadedExtentsRtree_ = new Wm(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
          let i, r;
          Array.isArray(t.features) ? r = t.features : t.features && (i = t.features, r = i.getArray()), !e && i === void 0 && (i = new lr(r)), r !== void 0 && this.addFeaturesInternal(r), i !== void 0 && this.bindFeaturesCollection_(i);
        }
        addFeature(t) {
          this.addFeatureInternal(t), this.changed();
        }
        addFeatureInternal(t) {
          const e = xt(t);
          if (!this.addToIndex_(e, t)) {
            this.featuresCollection_ && this.featuresCollection_.remove(t);
            return;
          }
          this.setupChangeEvents_(e, t);
          const i = t.getGeometry();
          if (i) {
            const r = i.getExtent();
            this.featuresRtree_ && this.featuresRtree_.insert(r, t);
          } else this.nullGeometryFeatures_[e] = t;
          this.dispatchEvent(new bl(An.ADDFEATURE, t));
        }
        setupChangeEvents_(t, e) {
          e instanceof Ti || (this.featureChangeKeys_[t] = [Ut(e, Rt.CHANGE, this.handleFeatureChange_, this), Ut(e, uo.PROPERTYCHANGE, this.handleFeatureChange_, this)]);
        }
        addToIndex_(t, e) {
          let i = true;
          if (e.getId() !== void 0) {
            const r = String(e.getId());
            if (!(r in this.idIndex_)) this.idIndex_[r] = e;
            else if (e instanceof Ti) {
              const a = this.idIndex_[r];
              a instanceof Ti ? Array.isArray(a) ? a.push(e) : this.idIndex_[r] = [a, e] : i = false;
            } else i = false;
          }
          return i && (ue(!(t in this.uidIndex_), "The passed `feature` was already added to the source"), this.uidIndex_[t] = e), i;
        }
        addFeatures(t) {
          this.addFeaturesInternal(t), this.changed();
        }
        addFeaturesInternal(t) {
          const e = [], i = [], r = [];
          for (let a = 0, o = t.length; a < o; a++) {
            const s = t[a], l = xt(s);
            this.addToIndex_(l, s) && i.push(s);
          }
          for (let a = 0, o = i.length; a < o; a++) {
            const s = i[a], l = xt(s);
            this.setupChangeEvents_(l, s);
            const u = s.getGeometry();
            if (u) {
              const h = u.getExtent();
              e.push(h), r.push(s);
            } else this.nullGeometryFeatures_[l] = s;
          }
          if (this.featuresRtree_ && this.featuresRtree_.load(e, r), this.hasListener(An.ADDFEATURE)) for (let a = 0, o = i.length; a < o; a++) this.dispatchEvent(new bl(An.ADDFEATURE, i[a]));
        }
        bindFeaturesCollection_(t) {
          let e = false;
          this.addEventListener(An.ADDFEATURE, function(i) {
            e || (e = true, t.push(i.feature), e = false);
          }), this.addEventListener(An.REMOVEFEATURE, function(i) {
            e || (e = true, t.remove(i.feature), e = false);
          }), t.addEventListener(ii.ADD, (i) => {
            e || (e = true, this.addFeature(i.element), e = false);
          }), t.addEventListener(ii.REMOVE, (i) => {
            e || (e = true, this.removeFeature(i.element), e = false);
          }), this.featuresCollection_ = t;
        }
        clear(t) {
          if (t) {
            for (const i in this.featureChangeKeys_) this.featureChangeKeys_[i].forEach(we);
            this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
          } else if (this.featuresRtree_) {
            this.featuresRtree_.forEach((i) => {
              this.removeFeatureInternal(i);
            });
            for (const i in this.nullGeometryFeatures_) this.removeFeatureInternal(this.nullGeometryFeatures_[i]);
          }
          this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
          const e = new bl(An.CLEAR);
          this.dispatchEvent(e), this.changed();
        }
        forEachFeature(t) {
          if (this.featuresRtree_) return this.featuresRtree_.forEach(t);
          this.featuresCollection_ && this.featuresCollection_.forEach(t);
        }
        forEachFeatureAtCoordinateDirect(t, e) {
          const i = [t[0], t[1], t[0], t[1]];
          return this.forEachFeatureInExtent(i, function(r) {
            const a = r.getGeometry();
            if (a instanceof Ti || a.intersectsCoordinate(t)) return e(r);
          });
        }
        forEachFeatureInExtent(t, e) {
          if (this.featuresRtree_) return this.featuresRtree_.forEachInExtent(t, e);
          this.featuresCollection_ && this.featuresCollection_.forEach(e);
        }
        forEachFeatureIntersectingExtent(t, e) {
          return this.forEachFeatureInExtent(t, function(i) {
            const r = i.getGeometry();
            if (r instanceof Ti || r.intersectsExtent(t)) {
              const a = e(i);
              if (a) return a;
            }
          });
        }
        getFeaturesCollection() {
          return this.featuresCollection_;
        }
        getFeatures() {
          let t;
          return this.featuresCollection_ ? t = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (t = this.featuresRtree_.getAll(), vl(this.nullGeometryFeatures_) || Le(t, Object.values(this.nullGeometryFeatures_))), t;
        }
        getFeaturesAtCoordinate(t) {
          const e = [];
          return this.forEachFeatureAtCoordinateDirect(t, function(i) {
            e.push(i);
          }), e;
        }
        getFeaturesInExtent(t, e) {
          if (this.featuresRtree_) {
            if (!(e && e.canWrapX() && this.getWrapX())) return this.featuresRtree_.getInExtent(t);
            const r = Bx(t, e);
            return [].concat(...r.map((a) => this.featuresRtree_.getInExtent(a)));
          }
          return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
        }
        getClosestFeatureToCoordinate(t, e) {
          const i = t[0], r = t[1];
          let a = null;
          const o = [NaN, NaN];
          let s = 1 / 0;
          const l = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
          return e = e || Fu, this.featuresRtree_.forEachInExtent(l, function(u) {
            if (e(u)) {
              const h = u.getGeometry(), c = s;
              if (s = h instanceof Ti ? 0 : h.closestPointXY(i, r, o, s), s < c) {
                a = u;
                const f = Math.sqrt(s);
                l[0] = i - f, l[1] = r - f, l[2] = i + f, l[3] = r + f;
              }
            }
          }), a;
        }
        getExtent(t) {
          return this.featuresRtree_.getExtent(t);
        }
        getFeatureById(t) {
          const e = this.idIndex_[t.toString()];
          return e !== void 0 ? e : null;
        }
        getFeatureByUid(t) {
          const e = this.uidIndex_[t];
          return e !== void 0 ? e : null;
        }
        getFormat() {
          return this.format_;
        }
        getOverlaps() {
          return this.overlaps_;
        }
        getUrl() {
          return this.url_;
        }
        handleFeatureChange_(t) {
          const e = t.target, i = xt(e), r = e.getGeometry();
          if (!r) i in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(e), this.nullGeometryFeatures_[i] = e);
          else {
            const o = r.getExtent();
            i in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[i], this.featuresRtree_ && this.featuresRtree_.insert(o, e)) : this.featuresRtree_ && this.featuresRtree_.update(o, e);
          }
          const a = e.getId();
          if (a !== void 0) {
            const o = a.toString();
            this.idIndex_[o] !== e && (this.removeFromIdIndex_(e), this.idIndex_[o] = e);
          } else this.removeFromIdIndex_(e), this.uidIndex_[i] = e;
          this.changed(), this.dispatchEvent(new bl(An.CHANGEFEATURE, e));
        }
        hasFeature(t) {
          const e = t.getId();
          return e !== void 0 ? e in this.idIndex_ : xt(t) in this.uidIndex_;
        }
        isEmpty() {
          return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && vl(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : true;
        }
        loadFeatures(t, e, i) {
          const r = this.loadedExtentsRtree_, a = this.strategy_(t, e, i);
          for (let o = 0, s = a.length; o < s; ++o) {
            const l = a[o];
            r.forEachInExtent(l, function(h) {
              return Pr(h.extent, l);
            }) || (++this.loadingExtentsCount_, this.dispatchEvent(new bl(An.FEATURESLOADSTART)), this.loader_.call(this, l, e, i, (h) => {
              --this.loadingExtentsCount_, this.dispatchEvent(new bl(An.FEATURESLOADEND, void 0, h));
            }, () => {
              --this.loadingExtentsCount_, this.dispatchEvent(new bl(An.FEATURESLOADERROR));
            }), r.insert(l, { extent: l.slice() }));
          }
          this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
        }
        refresh() {
          this.clear(true), this.loadedExtentsRtree_.clear(), super.refresh();
        }
        removeLoadedExtent(t) {
          const e = this.loadedExtentsRtree_, i = e.forEachInExtent(t, function(r) {
            if (As(r.extent, t)) return r;
          });
          i && e.remove(i);
        }
        removeFeatures(t) {
          let e = false;
          for (let i = 0, r = t.length; i < r; ++i) e = this.removeFeatureInternal(t[i]) || e;
          e && this.changed();
        }
        removeFeature(t) {
          if (!t) return;
          this.removeFeatureInternal(t) && this.changed();
        }
        removeFeatureInternal(t) {
          const e = xt(t);
          if (!(e in this.uidIndex_)) return false;
          e in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[e] : this.featuresRtree_ && this.featuresRtree_.remove(t);
          const i = this.featureChangeKeys_[e];
          i == null || i.forEach(we), delete this.featureChangeKeys_[e];
          const r = t.getId();
          if (r !== void 0) {
            const a = r.toString(), o = this.idIndex_[a];
            o === t ? delete this.idIndex_[a] : Array.isArray(o) && (o.splice(o.indexOf(t), 1), o.length === 1 && (this.idIndex_[a] = o[0]));
          }
          return delete this.uidIndex_[e], this.hasListener(An.REMOVEFEATURE) && this.dispatchEvent(new bl(An.REMOVEFEATURE, t)), true;
        }
        removeFromIdIndex_(t) {
          for (const e in this.idIndex_) if (this.idIndex_[e] === t) {
            delete this.idIndex_[e];
            break;
          }
        }
        setLoader(t) {
          this.loader_ = t;
        }
        setUrl(t) {
          ue(this.format_, "`format` must be set when `url` is set"), this.url_ = t, this.setLoader(OF(t, this.format_));
        }
        setOverlaps(t) {
          this.overlaps_ = t, this.changed();
        }
      }
      const At = { IDLE: 0, LOADING: 1, LOADED: 2, ERROR: 3, EMPTY: 4 };
      class kw extends qc {
        constructor(t, e, i) {
          super(), i = i || {}, this.tileCoord = t, this.state = e, this.key = "", this.transition_ = i.transition === void 0 ? 250 : i.transition, this.transitionStarts_ = {}, this.interpolate = !!i.interpolate;
        }
        changed() {
          this.dispatchEvent(Rt.CHANGE);
        }
        release() {
          this.state === At.ERROR && this.setState(At.EMPTY);
        }
        getKey() {
          return this.key + "/" + this.tileCoord;
        }
        getTileCoord() {
          return this.tileCoord;
        }
        getState() {
          return this.state;
        }
        setState(t) {
          if (this.state !== At.ERROR && this.state > t) throw new Error("Tile load sequence violation");
          this.state = t, this.changed();
        }
        load() {
          zt();
        }
        getAlpha(t, e) {
          if (!this.transition_) return 1;
          let i = this.transitionStarts_[t];
          if (!i) i = e, this.transitionStarts_[t] = i;
          else if (i === -1) return 1;
          const r = e - i + 1e3 / 60;
          return r >= this.transition_ ? 1 : nF(r / this.transition_);
        }
        inTransition(t) {
          return this.transition_ ? this.transitionStarts_[t] !== -1 : false;
        }
        endTransition(t) {
          this.transition_ && (this.transitionStarts_[t] = -1);
        }
        disposeInternal() {
          this.release(), super.disposeInternal();
        }
      }
      class $m extends kw {
        constructor(t, e, i, r, a, o) {
          super(t, e, o), this.crossOrigin_ = r, this.src_ = i, this.key = i, this.image_ = new Image(), r !== null && (this.image_.crossOrigin = r), this.unlisten_ = null, this.tileLoadFunction_ = a;
        }
        getImage() {
          return this.image_;
        }
        setImage(t) {
          this.image_ = t, this.state = At.LOADED, this.unlistenImage_(), this.changed();
        }
        handleImageError_() {
          this.state = At.ERROR, this.unlistenImage_(), this.image_ = Htt(), this.changed();
        }
        handleImageLoad_() {
          const t = this.image_;
          t.naturalWidth && t.naturalHeight ? this.state = At.LOADED : this.state = At.EMPTY, this.unlistenImage_(), this.changed();
        }
        load() {
          this.state == At.ERROR && (this.state = At.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == At.IDLE && (this.state = At.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = $K(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this)));
        }
        unlistenImage_() {
          this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
        }
        disposeInternal() {
          this.unlistenImage_(), this.image_ = null, super.disposeInternal();
        }
      }
      function Htt() {
        const n = In(1, 1);
        return n.fillStyle = "rgba(0,0,0,0)", n.fillRect(0, 0, 1, 1), n.canvas;
      }
      class Ytt {
        constructor(t, e, i) {
          this.decay_ = t, this.minVelocity_ = e, this.delay_ = i, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
        }
        begin() {
          this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
        }
        update(t, e) {
          this.points_.push(t, e, Date.now());
        }
        end() {
          if (this.points_.length < 6) return false;
          const t = Date.now() - this.delay_, e = this.points_.length - 3;
          if (this.points_[e + 2] < t) return false;
          let i = e - 3;
          for (; i > 0 && this.points_[i + 2] > t; ) i -= 3;
          const r = this.points_[e + 2] - this.points_[i + 2];
          if (r < 1e3 / 60) return false;
          const a = this.points_[e] - this.points_[i], o = this.points_[e + 1] - this.points_[i + 1];
          return this.angle_ = Math.atan2(o, a), this.initialVelocity_ = Math.sqrt(a * a + o * o) / r, this.initialVelocity_ > this.minVelocity_;
        }
        getDistance() {
          return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
        }
        getAngle() {
          return this.angle_;
        }
      }
      class Wtt extends Nu {
        constructor(t) {
          super(), this.map_ = t;
        }
        dispatchRenderEvent(t, e) {
          zt();
        }
        calculateMatrices2D(t) {
          const e = t.viewState, i = t.coordinateToPixelTransform, r = t.pixelToCoordinateTransform;
          Lr(i, t.size[0] / 2, t.size[1] / 2, 1 / e.resolution, -1 / e.resolution, -e.rotation, -e.center[0], -e.center[1]), ml(r, i);
        }
        forEachFeatureAtCoordinate(t, e, i, r, a, o, s, l) {
          let u;
          const h = e.viewState;
          function c(_, I, E, x) {
            return a.call(o, I, _ ? E : null, x);
          }
          const f = h.projection, g = Px(t.slice(), f), d = [[0, 0]];
          if (f.canWrapX() && r) {
            const _ = f.getExtent(), I = he(_);
            d.push([-I, 0], [I, 0]);
          }
          const A = e.layerStatesArray, p = A.length, v = [], y = [];
          for (let _ = 0; _ < d.length; _++) for (let I = p - 1; I >= 0; --I) {
            const E = A[I], x = E.layer;
            if (x.hasRenderer() && ww(E, h) && s.call(l, x)) {
              const w = x.getRenderer(), C = x.getSource();
              if (w && C) {
                const S = C.getWrapX() ? g : t, b = c.bind(null, E.managed);
                y[0] = S[0] + d[_][0], y[1] = S[1] + d[_][1], u = w.forEachFeatureAtCoordinate(y, e, i, b, v);
              }
              if (u) return u;
            }
          }
          if (v.length === 0) return;
          const m = 1 / v.length;
          return v.forEach((_, I) => _.distanceSq += I * m), v.sort((_, I) => _.distanceSq - I.distanceSq), v.some((_) => u = _.callback(_.feature, _.layer, _.geometry)), u;
        }
        hasFeatureAtCoordinate(t, e, i, r, a, o) {
          return this.forEachFeatureAtCoordinate(t, e, i, r, Fu, this, a, o) !== void 0;
        }
        getMap() {
          return this.map_;
        }
        renderFrame(t) {
          zt();
        }
        scheduleExpireIconCache(t) {
          ra.canExpireCache() && t.postRenderFunctions.push(Xtt);
        }
      }
      function Xtt(n, t) {
        ra.expire();
      }
      class $tt extends Wtt {
        constructor(t) {
          super(t), this.fontChangeListenerKey_ = Ut(xs, uo.PROPERTYCHANGE, t.redrawText, t), this.element_ = document.createElement("div");
          const e = this.element_.style;
          e.position = "absolute", e.width = "100%", e.height = "100%", e.zIndex = "0", this.element_.className = _s + " ol-layers";
          const i = t.getViewport();
          i.insertBefore(this.element_, i.firstChild || null), this.children_ = [], this.renderedVisible_ = true;
        }
        dispatchRenderEvent(t, e) {
          const i = this.getMap();
          if (i.hasListener(t)) {
            const r = new BA(t, void 0, e);
            i.dispatchEvent(r);
          }
        }
        disposeInternal() {
          we(this.fontChangeListenerKey_), this.element_.remove(), super.disposeInternal();
        }
        renderFrame(t) {
          if (!t) {
            this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = false);
            return;
          }
          this.calculateMatrices2D(t), this.dispatchRenderEvent(si.PRECOMPOSE, t);
          const e = t.layerStatesArray.sort((s, l) => s.zIndex - l.zIndex);
          e.some((s) => s.layer instanceof bA && s.layer.getDeclutter()) && (t.declutter = {});
          const r = t.viewState;
          this.children_.length = 0;
          const a = [];
          let o = null;
          for (let s = 0, l = e.length; s < l; ++s) {
            const u = e[s];
            t.layerIndex = s;
            const h = u.layer, c = h.getSourceState();
            if (!ww(u, r) || c != "ready" && c != "undefined") {
              h.unrender();
              continue;
            }
            const f = h.render(t, o);
            f && (f !== o && (this.children_.push(f), o = f), a.push(u));
          }
          this.declutter(t, a), XK(this.element_, this.children_), this.dispatchRenderEvent(si.POSTCOMPOSE, t), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = true), this.scheduleExpireIconCache(t);
        }
        declutter(t, e) {
          if (t.declutter) {
            for (let i = e.length - 1; i >= 0; --i) {
              const r = e[i], a = r.layer;
              a.getDeclutter() && a.renderDeclutter(t, r);
            }
            e.forEach((i) => i.layer.renderDeferred(t));
          }
        }
      }
      class Tl extends Te {
        constructor(t, e) {
          super(t), this.layer = e;
        }
      }
      const Ow = { LAYERS: "layers" };
      class zr extends KN {
        constructor(t) {
          t = t || {};
          const e = Object.assign({}, t);
          delete e.layers;
          let i = t.layers;
          super(e), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(Ow.LAYERS, this.handleLayersChanged_), i ? Array.isArray(i) ? i = new lr(i.slice(), { unique: true }) : ue(typeof i.getArray == "function", "Expected `layers` to be an array or a `Collection`") : i = new lr(void 0, { unique: true }), this.setLayers(i);
        }
        handleLayerChange_() {
          this.changed();
        }
        handleLayersChanged_() {
          this.layersListenerKeys_.forEach(we), this.layersListenerKeys_.length = 0;
          const t = this.getLayers();
          this.layersListenerKeys_.push(Ut(t, ii.ADD, this.handleLayersAdd_, this), Ut(t, ii.REMOVE, this.handleLayersRemove_, this));
          for (const i in this.listenerKeys_) this.listenerKeys_[i].forEach(we);
          jc(this.listenerKeys_);
          const e = t.getArray();
          for (let i = 0, r = e.length; i < r; i++) {
            const a = e[i];
            this.registerLayerListeners_(a), this.dispatchEvent(new Tl("addlayer", a));
          }
          this.changed();
        }
        registerLayerListeners_(t) {
          const e = [Ut(t, uo.PROPERTYCHANGE, this.handleLayerChange_, this), Ut(t, Rt.CHANGE, this.handleLayerChange_, this)];
          t instanceof zr && e.push(Ut(t, "addlayer", this.handleLayerGroupAdd_, this), Ut(t, "removelayer", this.handleLayerGroupRemove_, this)), this.listenerKeys_[xt(t)] = e;
        }
        handleLayerGroupAdd_(t) {
          this.dispatchEvent(new Tl("addlayer", t.layer));
        }
        handleLayerGroupRemove_(t) {
          this.dispatchEvent(new Tl("removelayer", t.layer));
        }
        handleLayersAdd_(t) {
          const e = t.element;
          this.registerLayerListeners_(e), this.dispatchEvent(new Tl("addlayer", e)), this.changed();
        }
        handleLayersRemove_(t) {
          const e = t.element, i = xt(e);
          this.listenerKeys_[i].forEach(we), delete this.listenerKeys_[i], this.dispatchEvent(new Tl("removelayer", e)), this.changed();
        }
        getLayers() {
          return this.get(Ow.LAYERS);
        }
        setLayers(t) {
          const e = this.getLayers();
          if (e) {
            const i = e.getArray();
            for (let r = 0, a = i.length; r < a; ++r) this.dispatchEvent(new Tl("removelayer", i[r]));
          }
          this.set(Ow.LAYERS, t);
        }
        getLayersArray(t) {
          return t = t !== void 0 ? t : [], this.getLayers().forEach(function(e) {
            e.getLayersArray(t);
          }), t;
        }
        getLayerStatesArray(t) {
          const e = t !== void 0 ? t : [], i = e.length;
          this.getLayers().forEach(function(o) {
            o.getLayerStatesArray(e);
          });
          const r = this.getLayerState();
          let a = r.zIndex;
          !t && r.zIndex === void 0 && (a = 0);
          for (let o = i, s = e.length; o < s; o++) {
            const l = e[o];
            l.opacity *= r.opacity, l.visible = l.visible && r.visible, l.maxResolution = Math.min(l.maxResolution, r.maxResolution), l.minResolution = Math.max(l.minResolution, r.minResolution), l.minZoom = Math.max(l.minZoom, r.minZoom), l.maxZoom = Math.min(l.maxZoom, r.maxZoom), r.extent !== void 0 && (l.extent !== void 0 ? l.extent = oi(l.extent, r.extent) : l.extent = r.extent), l.zIndex === void 0 && (l.zIndex = a);
          }
          return e;
        }
        getSourceState() {
          return "ready";
        }
      }
      class yf extends Te {
        constructor(t, e, i) {
          super(t), this.map = e, this.frameState = i !== void 0 ? i : null;
        }
      }
      class Ts extends yf {
        constructor(t, e, i, r, a, o) {
          super(t, e, a), this.originalEvent = i, this.pixel_ = null, this.coordinate_ = null, this.dragging = r !== void 0 ? r : false, this.activePointers = o;
        }
        get pixel() {
          return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
        }
        set pixel(t) {
          this.pixel_ = t;
        }
        get coordinate() {
          return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
        }
        set coordinate(t) {
          this.coordinate_ = t;
        }
        preventDefault() {
          super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
        }
        stopPropagation() {
          super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
        }
      }
      const Me = { SINGLECLICK: "singleclick", CLICK: Rt.CLICK, DBLCLICK: Rt.DBLCLICK, POINTERDRAG: "pointerdrag", POINTERMOVE: "pointermove", POINTERDOWN: "pointerdown", POINTERUP: "pointerup", POINTEROVER: "pointerover", POINTEROUT: "pointerout", POINTERENTER: "pointerenter", POINTERLEAVE: "pointerleave", POINTERCANCEL: "pointercancel" }, Io = { POINTERMOVE: "pointermove", POINTERDOWN: "pointerdown", POINTERUP: "pointerup", POINTEROVER: "pointerover", POINTEROUT: "pointerout", POINTERENTER: "pointerenter", POINTERLEAVE: "pointerleave", POINTERCANCEL: "pointercancel" };
      class Ztt extends qc {
        constructor(t, e) {
          super(t), this.map_ = t, this.clickTimeoutId_, this.emulateClicks_ = false, this.dragging_ = false, this.dragListenerKeys_ = [], this.moveTolerance_ = e === void 0 ? 1 : e, this.down_ = null;
          const i = this.map_.getViewport();
          this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = i, this.pointerdownListenerKey_ = Ut(i, Io.POINTERDOWN, this.handlePointerDown_, this), this.originalPointerMoveEvent_, this.relayedListenerKey_ = Ut(i, Io.POINTERMOVE, this.relayMoveEvent_, this), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(Rt.TOUCHMOVE, this.boundHandleTouchMove_, NN ? { passive: false } : false);
        }
        emulateClick_(t) {
          let e = new Ts(Me.CLICK, this.map_, t);
          this.dispatchEvent(e), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, e = new Ts(Me.DBLCLICK, this.map_, t), this.dispatchEvent(e)) : this.clickTimeoutId_ = setTimeout(() => {
            this.clickTimeoutId_ = void 0;
            const i = new Ts(Me.SINGLECLICK, this.map_, t);
            this.dispatchEvent(i);
          }, 250);
        }
        updateActivePointers_(t) {
          const e = t, i = e.pointerId;
          if (e.type == Me.POINTERUP || e.type == Me.POINTERCANCEL) {
            delete this.trackedTouches_[i];
            for (const r in this.trackedTouches_) if (this.trackedTouches_[r].target !== e.target) {
              delete this.trackedTouches_[r];
              break;
            }
          } else (e.type == Me.POINTERDOWN || e.type == Me.POINTERMOVE) && (this.trackedTouches_[i] = e);
          this.activePointers_ = Object.values(this.trackedTouches_);
        }
        handlePointerUp_(t) {
          this.updateActivePointers_(t);
          const e = new Ts(Me.POINTERUP, this.map_, t, void 0, void 0, this.activePointers_);
          this.dispatchEvent(e), this.emulateClicks_ && !e.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(t) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(we), this.dragListenerKeys_.length = 0, this.dragging_ = false, this.down_ = null);
        }
        isMouseActionButton_(t) {
          return t.button === 0;
        }
        handlePointerDown_(t) {
          this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(t);
          const e = new Ts(Me.POINTERDOWN, this.map_, t, void 0, void 0, this.activePointers_);
          if (this.dispatchEvent(e), this.down_ = new PointerEvent(t.type, t), Object.defineProperty(this.down_, "target", { writable: false, value: t.target }), this.dragListenerKeys_.length === 0) {
            const i = this.map_.getOwnerDocument();
            this.dragListenerKeys_.push(Ut(i, Me.POINTERMOVE, this.handlePointerMove_, this), Ut(i, Me.POINTERUP, this.handlePointerUp_, this), Ut(this.element_, Me.POINTERCANCEL, this.handlePointerUp_, this)), this.element_.getRootNode && this.element_.getRootNode() !== i && this.dragListenerKeys_.push(Ut(this.element_.getRootNode(), Me.POINTERUP, this.handlePointerUp_, this));
          }
        }
        handlePointerMove_(t) {
          if (this.isMoving_(t)) {
            this.updateActivePointers_(t), this.dragging_ = true;
            const e = new Ts(Me.POINTERDRAG, this.map_, t, this.dragging_, void 0, this.activePointers_);
            this.dispatchEvent(e);
          }
        }
        relayMoveEvent_(t) {
          this.originalPointerMoveEvent_ = t;
          const e = !!(this.down_ && this.isMoving_(t));
          this.dispatchEvent(new Ts(Me.POINTERMOVE, this.map_, t, e));
        }
        handleTouchMove_(t) {
          const e = this.originalPointerMoveEvent_;
          (!e || e.defaultPrevented) && (typeof t.cancelable != "boolean" || t.cancelable === true) && t.preventDefault();
        }
        isMoving_(t) {
          return this.dragging_ || Math.abs(t.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(t.clientY - this.down_.clientY) > this.moveTolerance_;
        }
        disposeInternal() {
          this.relayedListenerKey_ && (we(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(Rt.TOUCHMOVE, this.boundHandleTouchMove_), this.pointerdownListenerKey_ && (we(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(we), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
        }
      }
      const xo = { POSTRENDER: "postrender", MOVESTART: "movestart", MOVEEND: "moveend", LOADSTART: "loadstart", LOADEND: "loadend" }, Ln = { LAYERGROUP: "layergroup", SIZE: "size", TARGET: "target", VIEW: "view" }, Zm = 1 / 0;
      class Ktt {
        constructor(t, e) {
          this.priorityFunction_ = t, this.keyFunction_ = e, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
        }
        clear() {
          this.elements_.length = 0, this.priorities_.length = 0, jc(this.queuedElements_);
        }
        dequeue() {
          const t = this.elements_, e = this.priorities_, i = t[0];
          t.length == 1 ? (t.length = 0, e.length = 0) : (t[0] = t.pop(), e[0] = e.pop(), this.siftUp_(0));
          const r = this.keyFunction_(i);
          return delete this.queuedElements_[r], i;
        }
        enqueue(t) {
          ue(!(this.keyFunction_(t) in this.queuedElements_), "Tried to enqueue an `element` that was already added to the queue");
          const e = this.priorityFunction_(t);
          return e != Zm ? (this.elements_.push(t), this.priorities_.push(e), this.queuedElements_[this.keyFunction_(t)] = true, this.siftDown_(0, this.elements_.length - 1), true) : false;
        }
        getCount() {
          return this.elements_.length;
        }
        getLeftChildIndex_(t) {
          return t * 2 + 1;
        }
        getRightChildIndex_(t) {
          return t * 2 + 2;
        }
        getParentIndex_(t) {
          return t - 1 >> 1;
        }
        heapify_() {
          let t;
          for (t = (this.elements_.length >> 1) - 1; t >= 0; t--) this.siftUp_(t);
        }
        isEmpty() {
          return this.elements_.length === 0;
        }
        isKeyQueued(t) {
          return t in this.queuedElements_;
        }
        isQueued(t) {
          return this.isKeyQueued(this.keyFunction_(t));
        }
        siftUp_(t) {
          const e = this.elements_, i = this.priorities_, r = e.length, a = e[t], o = i[t], s = t;
          for (; t < r >> 1; ) {
            const l = this.getLeftChildIndex_(t), u = this.getRightChildIndex_(t), h = u < r && i[u] < i[l] ? u : l;
            e[t] = e[h], i[t] = i[h], t = h;
          }
          e[t] = a, i[t] = o, this.siftDown_(s, t);
        }
        siftDown_(t, e) {
          const i = this.elements_, r = this.priorities_, a = i[e], o = r[e];
          for (; e > t; ) {
            const s = this.getParentIndex_(e);
            if (r[s] > o) i[e] = i[s], r[e] = r[s], e = s;
            else break;
          }
          i[e] = a, r[e] = o;
        }
        reprioritize() {
          const t = this.priorityFunction_, e = this.elements_, i = this.priorities_;
          let r = 0;
          const a = e.length;
          let o, s, l;
          for (s = 0; s < a; ++s) o = e[s], l = t(o), l == Zm ? delete this.queuedElements_[this.keyFunction_(o)] : (i[r] = l, e[r++] = o);
          e.length = r, i.length = r, this.heapify_();
        }
      }
      class Jtt extends Ktt {
        constructor(t, e) {
          super(function(i) {
            return t.apply(null, i);
          }, function(i) {
            return i[0].getKey();
          }), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = e, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
        }
        enqueue(t) {
          const e = super.enqueue(t);
          return e && t[0].addEventListener(Rt.CHANGE, this.boundHandleTileChange_), e;
        }
        getTilesLoading() {
          return this.tilesLoading_;
        }
        handleTileChange(t) {
          const e = t.target, i = e.getState();
          if (i === At.LOADED || i === At.ERROR || i === At.EMPTY) {
            i !== At.ERROR && e.removeEventListener(Rt.CHANGE, this.boundHandleTileChange_);
            const r = e.getKey();
            r in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[r], --this.tilesLoading_), this.tileChangeCallback_();
          }
        }
        loadMoreTiles(t, e) {
          let i = 0;
          for (; this.tilesLoading_ < t && i < e && this.getCount() > 0; ) {
            const r = this.dequeue()[0], a = r.getKey();
            r.getState() === At.IDLE && !(a in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[a] = true, ++this.tilesLoading_, ++i, r.load());
          }
        }
      }
      function tet(n, t, e, i, r) {
        if (!n || !(e in n.wantedTiles) || !n.wantedTiles[e][t.getKey()]) return Zm;
        const a = n.viewState.center, o = i[0] - a[0], s = i[1] - a[1];
        return 65536 * Math.log(r) + Math.sqrt(o * o + s * s) / r;
      }
      class Bl extends Kr {
        constructor(t) {
          super();
          const e = t.element;
          e && !t.target && !e.style.pointerEvents && (e.style.pointerEvents = "auto"), this.element = e || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], t.render && (this.render = t.render), t.target && this.setTarget(t.target);
        }
        disposeInternal() {
          var t;
          (t = this.element) == null || t.remove(), super.disposeInternal();
        }
        getMap() {
          return this.map_;
        }
        setMap(t) {
          var e, i;
          this.map_ && ((e = this.element) == null || e.remove());
          for (let r = 0, a = this.listenerKeys.length; r < a; ++r) we(this.listenerKeys[r]);
          if (this.listenerKeys.length = 0, this.map_ = t, t) {
            const r = (i = this.target_) != null ? i : t.getOverlayContainerStopEvent();
            this.element && r.appendChild(this.element), this.render !== Vc && this.listenerKeys.push(Ut(t, xo.POSTRENDER, this.render, this)), t.render();
          }
        }
        render(t) {
        }
        setTarget(t) {
          this.target_ = typeof t == "string" ? document.getElementById(t) : t;
        }
      }
      class eet extends Bl {
        constructor(t) {
          t = t || {}, super({ element: document.createElement("div"), render: t.render, target: t.target }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = t.collapsed !== void 0 ? t.collapsed : true, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = t.collapsible !== void 0, this.collapsible_ = t.collapsible !== void 0 ? t.collapsible : true, this.collapsible_ || (this.collapsed_ = false), this.attributions_ = t.attributions;
          const e = t.className !== void 0 ? t.className : "ol-attribution", i = t.tipLabel !== void 0 ? t.tipLabel : "Attributions", r = t.expandClassName !== void 0 ? t.expandClassName : e + "-expand", a = t.collapseLabel !== void 0 ? t.collapseLabel : "", o = t.collapseClassName !== void 0 ? t.collapseClassName : e + "-collapse";
          typeof a == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = a, this.collapseLabel_.className = o) : this.collapseLabel_ = a;
          const s = t.label !== void 0 ? t.label : "i";
          typeof s == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = s, this.label_.className = r) : this.label_ = s;
          const l = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
          this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = i, this.toggleButton_.appendChild(l), this.toggleButton_.addEventListener(Rt.CLICK, this.handleClick_.bind(this), false);
          const u = e + " " + _s + " " + of + (this.collapsed_ && this.collapsible_ ? " " + Pm : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), h = this.element;
          h.className = u, h.appendChild(this.toggleButton_), h.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = true;
        }
        collectSourceAttributions_(t) {
          const e = this.getMap().getAllLayers(), i = new Set(e.flatMap((r) => r.getAttributions(t)));
          if (this.attributions_ !== void 0 && (Array.isArray(this.attributions_) ? this.attributions_.forEach((r) => i.add(r)) : i.add(this.attributions_)), !this.overrideCollapsible_) {
            const r = !e.some((a) => {
              var o;
              return ((o = a.getSource()) == null ? void 0 : o.getAttributionsCollapsible()) === false;
            });
            this.setCollapsible(r);
          }
          return Array.from(i);
        }
        updateElement_(t) {
          return Tt(this, null, function* () {
            if (!t) {
              this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = false);
              return;
            }
            const e = yield Promise.all(this.collectSourceAttributions_(t).map((r) => _x(() => r))), i = e.length > 0;
            if (this.renderedVisible_ != i && (this.element.style.display = i ? "" : "none", this.renderedVisible_ = i), !co(e, this.renderedAttributions_)) {
              FN(this.ulElement_);
              for (let r = 0, a = e.length; r < a; ++r) {
                const o = document.createElement("li");
                o.innerHTML = e[r], this.ulElement_.appendChild(o);
              }
              this.renderedAttributions_ = e;
            }
          });
        }
        handleClick_(t) {
          t.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
        }
        handleToggle_() {
          this.element.classList.toggle(Pm), this.collapsed_ ? af(this.collapseLabel_, this.label_) : af(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
        }
        getCollapsible() {
          return this.collapsible_;
        }
        setCollapsible(t) {
          this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
        }
        setCollapsed(t) {
          this.userCollapsed_ = t, !(!this.collapsible_ || this.collapsed_ === t) && this.handleToggle_();
        }
        getCollapsed() {
          return this.collapsed_;
        }
        render(t) {
          this.updateElement_(t.frameState);
        }
      }
      class net extends Bl {
        constructor(t) {
          t = t || {}, super({ element: document.createElement("div"), render: t.render, target: t.target });
          const e = t.className !== void 0 ? t.className : "ol-rotate", i = t.label !== void 0 ? t.label : "", r = t.compassClassName !== void 0 ? t.compassClassName : "ol-compass";
          this.label_ = null, typeof i == "string" ? (this.label_ = document.createElement("span"), this.label_.className = r, this.label_.textContent = i) : (this.label_ = i, this.label_.classList.add(r));
          const a = t.tipLabel ? t.tipLabel : "Reset rotation", o = document.createElement("button");
          o.className = e + "-reset", o.setAttribute("type", "button"), o.title = a, o.appendChild(this.label_), o.addEventListener(Rt.CLICK, this.handleClick_.bind(this), false);
          const s = e + " " + _s + " " + of, l = this.element;
          l.className = s, l.appendChild(o), this.callResetNorth_ = t.resetNorth ? t.resetNorth : void 0, this.duration_ = t.duration !== void 0 ? t.duration : 250, this.autoHide_ = t.autoHide !== void 0 ? t.autoHide : true, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(Lm);
        }
        handleClick_(t) {
          t.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
        }
        resetNorth_() {
          const e = this.getMap().getView();
          if (!e) return;
          const i = e.getRotation();
          i !== void 0 && (this.duration_ > 0 && i % (2 * Math.PI) !== 0 ? e.animate({ rotation: 0, duration: this.duration_, easing: $u }) : e.setRotation(0));
        }
        render(t) {
          const e = t.frameState;
          if (!e) return;
          const i = e.viewState.rotation;
          if (i != this.rotation_) {
            const r = "rotate(" + i + "rad)";
            if (this.autoHide_) {
              const a = this.element.classList.contains(Lm);
              !a && i === 0 ? this.element.classList.add(Lm) : a && i !== 0 && this.element.classList.remove(Lm);
            }
            this.label_.style.transform = r;
          }
          this.rotation_ = i;
        }
      }
      class iet extends Bl {
        constructor(t) {
          t = t || {}, super({ element: document.createElement("div"), target: t.target });
          const e = t.className !== void 0 ? t.className : "ol-zoom", i = t.delta !== void 0 ? t.delta : 1, r = t.zoomInClassName !== void 0 ? t.zoomInClassName : e + "-in", a = t.zoomOutClassName !== void 0 ? t.zoomOutClassName : e + "-out", o = t.zoomInLabel !== void 0 ? t.zoomInLabel : "+", s = t.zoomOutLabel !== void 0 ? t.zoomOutLabel : "", l = t.zoomInTipLabel !== void 0 ? t.zoomInTipLabel : "Zoom in", u = t.zoomOutTipLabel !== void 0 ? t.zoomOutTipLabel : "Zoom out", h = document.createElement("button");
          h.className = r, h.setAttribute("type", "button"), h.title = l, h.appendChild(typeof o == "string" ? document.createTextNode(o) : o), h.addEventListener(Rt.CLICK, this.handleClick_.bind(this, i), false);
          const c = document.createElement("button");
          c.className = a, c.setAttribute("type", "button"), c.title = u, c.appendChild(typeof s == "string" ? document.createTextNode(s) : s), c.addEventListener(Rt.CLICK, this.handleClick_.bind(this, -i), false);
          const f = e + " " + _s + " " + of, g = this.element;
          g.className = f, g.appendChild(h), g.appendChild(c), this.duration_ = t.duration !== void 0 ? t.duration : 250;
        }
        handleClick_(t, e) {
          e.preventDefault(), this.zoomByDelta_(t);
        }
        zoomByDelta_(t) {
          const i = this.getMap().getView();
          if (!i) return;
          const r = i.getZoom();
          if (r !== void 0) {
            const a = i.getConstrainedZoom(r + t);
            this.duration_ > 0 ? (i.getAnimating() && i.cancelAnimations(), i.animate({ zoom: a, duration: this.duration_, easing: $u })) : i.setZoom(a);
          }
        }
      }
      function QF(n) {
        n = n || {};
        const t = new lr();
        return (n.zoom !== void 0 ? n.zoom : true) && t.push(new iet(n.zoomOptions)), (n.rotate !== void 0 ? n.rotate : true) && t.push(new net(n.rotateOptions)), (n.attribution !== void 0 ? n.attribution : true) && t.push(new eet(n.attributionOptions)), t;
      }
      const Qw = { ACTIVE: "active" };
      class DA extends Kr {
        constructor(t) {
          super(), this.on, this.once, this.un, t && t.handleEvent && (this.handleEvent = t.handleEvent), this.map_ = null, this.setActive(true);
        }
        getActive() {
          return this.get(Qw.ACTIVE);
        }
        getMap() {
          return this.map_;
        }
        handleEvent(t) {
          return true;
        }
        setActive(t) {
          this.set(Qw.ACTIVE, t);
        }
        setMap(t) {
          this.map_ = t;
        }
      }
      function ret(n, t, e) {
        const i = n.getCenterInternal();
        if (i) {
          const r = [i[0] + t[0], i[1] + t[1]];
          n.animateInternal({ duration: e !== void 0 ? e : 250, easing: yJ, center: n.getConstrainedCenter(r) });
        }
      }
      function zw(n, t, e, i) {
        const r = n.getZoom();
        if (r === void 0) return;
        const a = n.getConstrainedZoom(r + t), o = n.getResolutionForZoom(a);
        n.getAnimating() && n.cancelAnimations(), n.animate({ resolution: o, anchor: e, duration: i !== void 0 ? i : 250, easing: $u });
      }
      class aet extends DA {
        constructor(t) {
          super(), t = t || {}, this.delta_ = t.delta ? t.delta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 250;
        }
        handleEvent(t) {
          let e = false;
          if (t.type == Me.DBLCLICK) {
            const i = t.originalEvent, r = t.map, a = t.coordinate, o = i.shiftKey ? -this.delta_ : this.delta_, s = r.getView();
            zw(s, o, a, this.duration_), i.preventDefault(), e = true;
          }
          return !e;
        }
      }
      class Bs extends DA {
        constructor(t) {
          t = t || {}, super(t), t.handleDownEvent && (this.handleDownEvent = t.handleDownEvent), t.handleDragEvent && (this.handleDragEvent = t.handleDragEvent), t.handleMoveEvent && (this.handleMoveEvent = t.handleMoveEvent), t.handleUpEvent && (this.handleUpEvent = t.handleUpEvent), t.stopDown && (this.stopDown = t.stopDown), this.handlingDownUpSequence = false, this.targetPointers = [];
        }
        getPointerCount() {
          return this.targetPointers.length;
        }
        handleDownEvent(t) {
          return false;
        }
        handleDragEvent(t) {
        }
        handleEvent(t) {
          if (!t.originalEvent) return true;
          let e = false;
          if (this.updateTrackedPointers_(t), this.handlingDownUpSequence) {
            if (t.type == Me.POINTERDRAG) this.handleDragEvent(t), t.originalEvent.preventDefault();
            else if (t.type == Me.POINTERUP) {
              const i = this.handleUpEvent(t);
              this.handlingDownUpSequence = i && this.targetPointers.length > 0;
            }
          } else if (t.type == Me.POINTERDOWN) {
            const i = this.handleDownEvent(t);
            this.handlingDownUpSequence = i, e = this.stopDown(i);
          } else t.type == Me.POINTERMOVE && this.handleMoveEvent(t);
          return !e;
        }
        handleMoveEvent(t) {
        }
        handleUpEvent(t) {
          return false;
        }
        stopDown(t) {
          return t;
        }
        updateTrackedPointers_(t) {
          t.activePointers && (this.targetPointers = t.activePointers);
        }
      }
      function Gw(n) {
        const t = n.length;
        let e = 0, i = 0;
        for (let r = 0; r < t; r++) e += n[r].clientX, i += n[r].clientY;
        return { clientX: e / t, clientY: i / t };
      }
      function Uw(n) {
        const t = arguments;
        return function(e) {
          let i = true;
          for (let r = 0, a = t.length; r < a && (i = i && t[r](e), !!i); ++r) ;
          return i;
        };
      }
      const oet = function(n) {
        const t = n.originalEvent;
        return t.altKey && !(t.metaKey || t.ctrlKey) && !t.shiftKey;
      }, set = function(n) {
        const t = n.originalEvent;
        return t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey;
      }, uet = function(n) {
        const t = n.map.getTargetElement(), e = t.getRootNode(), i = n.map.getOwnerDocument().activeElement;
        return e instanceof ShadowRoot ? e.host.contains(i) : t.contains(i);
      }, zF = function(n) {
        const t = n.map.getTargetElement(), e = t.getRootNode();
        return (e instanceof ShadowRoot ? e.host : t).hasAttribute("tabindex") ? uet(n) : true;
      }, Km = Fu, GF = function(n) {
        const t = n.originalEvent;
        return t.button == 0 && !(qK && LN && t.ctrlKey);
      }, het = ku, cet = function(n) {
        return n.type == Me.SINGLECLICK;
      }, Vw = function(n) {
        const t = n.originalEvent;
        return !t.altKey && !(t.metaKey || t.ctrlKey) && !t.shiftKey;
      }, fet = function(n) {
        const t = n.originalEvent;
        return LN ? t.metaKey : t.ctrlKey;
      }, jw = function(n) {
        const t = n.originalEvent;
        return !t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey;
      }, UF = function(n) {
        const t = n.originalEvent, e = t.target.tagName;
        return e !== "INPUT" && e !== "SELECT" && e !== "TEXTAREA" && !t.target.isContentEditable;
      }, mf = function(n) {
        const t = n.originalEvent;
        return ue(t !== void 0, "mapBrowserEvent must originate from a pointer event"), t.pointerType == "mouse";
      }, VF = function(n) {
        const t = n.originalEvent;
        return ue(t !== void 0, "mapBrowserEvent must originate from a pointer event"), t.isPrimary && t.button === 0;
      };
      class get extends Bs {
        constructor(t) {
          super({ stopDown: ku }), t = t || {}, this.kinetic_ = t.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = false;
          const e = t.condition ? t.condition : Uw(Vw, VF);
          this.condition_ = t.onFocusOnly ? Uw(zF, e) : e, this.noKinetic_ = false;
        }
        handleDragEvent(t) {
          const e = t.map;
          this.panning_ || (this.panning_ = true, e.getView().beginInteraction());
          const i = this.targetPointers, r = e.getEventPixel(Gw(i));
          if (i.length == this.lastPointersCount_) {
            if (this.kinetic_ && this.kinetic_.update(r[0], r[1]), this.lastCentroid) {
              const a = [this.lastCentroid[0] - r[0], r[1] - this.lastCentroid[1]], s = t.map.getView();
              XP(a, s.getResolution()), Lx(a, s.getRotation()), s.adjustCenterInternal(a);
            }
          } else this.kinetic_ && this.kinetic_.begin();
          this.lastCentroid = r, this.lastPointersCount_ = i.length, t.originalEvent.preventDefault();
        }
        handleUpEvent(t) {
          const e = t.map, i = e.getView();
          if (this.targetPointers.length === 0) {
            if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
              const r = this.kinetic_.getDistance(), a = this.kinetic_.getAngle(), o = i.getCenterInternal(), s = e.getPixelFromCoordinateInternal(o), l = e.getCoordinateFromPixelInternal([s[0] - r * Math.cos(a), s[1] - r * Math.sin(a)]);
              i.animateInternal({ center: i.getConstrainedCenter(l), duration: 500, easing: $u });
            }
            return this.panning_ && (this.panning_ = false, i.endInteraction()), false;
          }
          return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, true;
        }
        handleDownEvent(t) {
          if (this.targetPointers.length > 0 && this.condition_(t)) {
            const i = t.map.getView();
            return this.lastCentroid = null, i.getAnimating() && i.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, true;
          }
          return false;
        }
      }
      class det extends Bs {
        constructor(t) {
          t = t || {}, super({ stopDown: ku }), this.condition_ = t.condition ? t.condition : set, this.lastAngle_ = void 0, this.duration_ = t.duration !== void 0 ? t.duration : 250;
        }
        handleDragEvent(t) {
          if (!mf(t)) return;
          const e = t.map, i = e.getView();
          if (i.getConstraints().rotation === Ew) return;
          const r = e.getSize(), a = t.pixel, o = Math.atan2(r[1] / 2 - a[1], a[0] - r[0] / 2);
          if (this.lastAngle_ !== void 0) {
            const s = o - this.lastAngle_;
            i.adjustRotationInternal(-s);
          }
          this.lastAngle_ = o;
        }
        handleUpEvent(t) {
          return mf(t) ? (t.map.getView().endInteraction(this.duration_), false) : true;
        }
        handleDownEvent(t) {
          return mf(t) && GF(t) && this.condition_(t) ? (t.map.getView().beginInteraction(), this.lastAngle_ = void 0, true) : false;
        }
      }
      class Aet extends Nu {
        constructor(t) {
          super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + t, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
        }
        disposeInternal() {
          this.setMap(null);
        }
        render_() {
          const t = this.startPixel_, e = this.endPixel_, i = "px", r = this.element_.style;
          r.left = Math.min(t[0], e[0]) + i, r.top = Math.min(t[1], e[1]) + i, r.width = Math.abs(e[0] - t[0]) + i, r.height = Math.abs(e[1] - t[1]) + i;
        }
        setMap(t) {
          if (this.map_) {
            this.map_.getOverlayContainer().removeChild(this.element_);
            const e = this.element_.style;
            e.left = "inherit", e.top = "inherit", e.width = "inherit", e.height = "inherit";
          }
          this.map_ = t, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
        }
        setPixels(t, e) {
          this.startPixel_ = t, this.endPixel_ = e, this.createOrUpdateGeometry(), this.render_();
        }
        createOrUpdateGeometry() {
          if (!this.map_) return;
          const t = this.startPixel_, e = this.endPixel_, r = [t, [t[0], e[1]], e, [e[0], t[1]]].map(this.map_.getCoordinateFromPixelInternal, this.map_);
          r[4] = r[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([r]) : this.geometry_ = new Dn([r]);
        }
        getGeometry() {
          return this.geometry_;
        }
      }
      const _f = { BOXSTART: "boxstart", BOXDRAG: "boxdrag", BOXEND: "boxend", BOXCANCEL: "boxcancel" };
      class RA extends Te {
        constructor(t, e, i) {
          super(t), this.coordinate = e, this.mapBrowserEvent = i;
        }
      }
      class pet extends Bs {
        constructor(t) {
          var e, i, r;
          super(), this.on, this.once, this.un, t = t != null ? t : {}, this.box_ = new Aet(t.className || "ol-dragbox"), this.minArea_ = (e = t.minArea) != null ? e : 64, t.onBoxEnd && (this.onBoxEnd = t.onBoxEnd), this.startPixel_ = null, this.condition_ = (i = t.condition) != null ? i : GF, this.boxEndCondition_ = (r = t.boxEndCondition) != null ? r : this.defaultBoxEndCondition;
        }
        defaultBoxEndCondition(t, e, i) {
          const r = i[0] - e[0], a = i[1] - e[1];
          return r * r + a * a >= this.minArea_;
        }
        getGeometry() {
          return this.box_.getGeometry();
        }
        handleDragEvent(t) {
          this.startPixel_ && (this.box_.setPixels(this.startPixel_, t.pixel), this.dispatchEvent(new RA(_f.BOXDRAG, t.coordinate, t)));
        }
        handleUpEvent(t) {
          if (!this.startPixel_) return false;
          const e = this.boxEndCondition_(t, this.startPixel_, t.pixel);
          return e && this.onBoxEnd(t), this.dispatchEvent(new RA(e ? _f.BOXEND : _f.BOXCANCEL, t.coordinate, t)), this.box_.setMap(null), this.startPixel_ = null, false;
        }
        handleDownEvent(t) {
          return this.condition_(t) ? (this.startPixel_ = t.pixel, this.box_.setMap(t.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(new RA(_f.BOXSTART, t.coordinate, t)), true) : false;
        }
        onBoxEnd(t) {
        }
        setActive(t) {
          t || (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(new RA(_f.BOXCANCEL, this.startPixel_, null)), this.startPixel_ = null)), super.setActive(t);
        }
        setMap(t) {
          this.getMap() && (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(new RA(_f.BOXCANCEL, this.startPixel_, null)), this.startPixel_ = null)), super.setMap(t);
        }
      }
      class vet extends pet {
        constructor(t) {
          t = t || {};
          const e = t.condition ? t.condition : jw;
          super({ condition: e, className: t.className || "ol-dragzoom", minArea: t.minArea }), this.duration_ = t.duration !== void 0 ? t.duration : 200, this.out_ = t.out !== void 0 ? t.out : false;
        }
        onBoxEnd(t) {
          const i = this.getMap().getView();
          let r = this.getGeometry();
          if (this.out_) {
            const a = i.rotatedExtentForGeometry(r), o = i.getResolutionForExtentInternal(a), s = i.getResolution() / o;
            r = r.clone(), r.scale(s * s);
          }
          i.fitInternal(r, { duration: this.duration_, easing: $u });
        }
      }
      const th = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", DOWN: "ArrowDown" };
      class yet extends DA {
        constructor(t) {
          super(), t = t || {}, this.defaultCondition_ = function(e) {
            return Vw(e) && UF(e);
          }, this.condition_ = t.condition !== void 0 ? t.condition : this.defaultCondition_, this.duration_ = t.duration !== void 0 ? t.duration : 100, this.pixelDelta_ = t.pixelDelta !== void 0 ? t.pixelDelta : 128;
        }
        handleEvent(t) {
          let e = false;
          if (t.type == Rt.KEYDOWN) {
            const i = t.originalEvent, r = i.key;
            if (this.condition_(t) && (r == th.DOWN || r == th.LEFT || r == th.RIGHT || r == th.UP)) {
              const o = t.map.getView(), s = o.getResolution() * this.pixelDelta_;
              let l = 0, u = 0;
              r == th.DOWN ? u = -s : r == th.LEFT ? l = -s : r == th.RIGHT ? l = s : u = s;
              const h = [l, u];
              Lx(h, o.getRotation()), ret(o, h, this.duration_), i.preventDefault(), e = true;
            }
          }
          return !e;
        }
      }
      class met extends DA {
        constructor(t) {
          super(), t = t || {}, this.condition_ = t.condition ? t.condition : function(e) {
            return !fet(e) && UF(e);
          }, this.delta_ = t.delta ? t.delta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 100;
        }
        handleEvent(t) {
          let e = false;
          if (t.type == Rt.KEYDOWN || t.type == Rt.KEYPRESS) {
            const i = t.originalEvent, r = i.key;
            if (this.condition_(t) && (r === "+" || r === "-")) {
              const a = t.map, o = r === "+" ? this.delta_ : -this.delta_, s = a.getView();
              zw(s, o, void 0, this.duration_), i.preventDefault(), e = true;
            }
          }
          return !e;
        }
      }
      class _et extends DA {
        constructor(t) {
          t = t || {}, super(t), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = t.maxDelta !== void 0 ? t.maxDelta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 250, this.timeout_ = t.timeout !== void 0 ? t.timeout : 80, this.useAnchor_ = t.useAnchor !== void 0 ? t.useAnchor : true, this.constrainResolution_ = t.constrainResolution !== void 0 ? t.constrainResolution : false;
          const e = t.condition ? t.condition : Km;
          this.condition_ = t.onFocusOnly ? Uw(zF, e) : e, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
        }
        endInteraction_() {
          this.trackpadTimeoutId_ = void 0;
          const t = this.getMap();
          if (!t) return;
          t.getView().endInteraction(void 0, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_ ? t.getCoordinateFromPixel(this.lastAnchor_) : null);
        }
        handleEvent(t) {
          if (!this.condition_(t) || t.type !== Rt.WHEEL) return true;
          const i = t.map, r = t.originalEvent;
          r.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = t.pixel);
          let a;
          if (t.type == Rt.WHEEL && (a = r.deltaY, VK && r.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (a /= PN), r.deltaMode === WheelEvent.DOM_DELTA_LINE && (a *= 40)), a === 0) return false;
          this.lastDelta_ = a;
          const o = Date.now();
          this.startTime_ === void 0 && (this.startTime_ = o), (!this.mode_ || o - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(a) < 4 ? "trackpad" : "wheel");
          const s = i.getView();
          if (this.mode_ === "trackpad" && !(s.getConstrainResolution() || this.constrainResolution_)) return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (s.getAnimating() && s.cancelAnimations(), s.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_), s.adjustZoom(-a / this.deltaPerZoom_, this.lastAnchor_ ? i.getCoordinateFromPixel(this.lastAnchor_) : null), this.startTime_ = o, false;
          this.totalDelta_ += a;
          const l = Math.max(this.timeout_ - (o - this.startTime_), 0);
          return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, i), l), false;
        }
        handleWheelZoom_(t) {
          const e = t.getView();
          e.getAnimating() && e.cancelAnimations();
          let i = -Ze(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
          (e.getConstrainResolution() || this.constrainResolution_) && (i = i ? i > 0 ? 1 : -1 : 0), zw(e, i, this.lastAnchor_ ? t.getCoordinateFromPixel(this.lastAnchor_) : null, this.duration_), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
        }
        setMouseAnchor(t) {
          this.useAnchor_ = t, t || (this.lastAnchor_ = null);
        }
      }
      class Eet extends Bs {
        constructor(t) {
          t = t || {};
          const e = t;
          e.stopDown || (e.stopDown = ku), super(e), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = false, this.rotationDelta_ = 0, this.threshold_ = t.threshold !== void 0 ? t.threshold : 0.3, this.duration_ = t.duration !== void 0 ? t.duration : 250;
        }
        handleDragEvent(t) {
          let e = 0;
          const i = this.targetPointers[0], r = this.targetPointers[1], a = Math.atan2(r.clientY - i.clientY, r.clientX - i.clientX);
          if (this.lastAngle_ !== void 0) {
            const l = a - this.lastAngle_;
            this.rotationDelta_ += l, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = true), e = l;
          }
          this.lastAngle_ = a;
          const o = t.map, s = o.getView();
          s.getConstraints().rotation !== Ew && (this.anchor_ = o.getCoordinateFromPixelInternal(o.getEventPixel(Gw(this.targetPointers))), this.rotating_ && (o.render(), s.adjustRotationInternal(e, this.anchor_)));
        }
        handleUpEvent(t) {
          return this.targetPointers.length < 2 ? (t.map.getView().endInteraction(this.duration_), false) : true;
        }
        handleDownEvent(t) {
          if (this.targetPointers.length >= 2) {
            const e = t.map;
            return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = false, this.rotationDelta_ = 0, this.handlingDownUpSequence || e.getView().beginInteraction(), true;
          }
          return false;
        }
      }
      class Iet extends Bs {
        constructor(t) {
          t = t || {};
          const e = t;
          e.stopDown || (e.stopDown = ku), super(e), this.anchor_ = null, this.duration_ = t.duration !== void 0 ? t.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
        }
        handleDragEvent(t) {
          let e = 1;
          const i = this.targetPointers[0], r = this.targetPointers[1], a = i.clientX - r.clientX, o = i.clientY - r.clientY, s = Math.sqrt(a * a + o * o);
          this.lastDistance_ !== void 0 && (e = this.lastDistance_ / s), this.lastDistance_ = s;
          const l = t.map, u = l.getView();
          e != 1 && (this.lastScaleDelta_ = e), this.anchor_ = l.getCoordinateFromPixelInternal(l.getEventPixel(Gw(this.targetPointers))), l.render(), u.adjustResolutionInternal(e, this.anchor_);
        }
        handleUpEvent(t) {
          if (this.targetPointers.length < 2) {
            const i = t.map.getView(), r = this.lastScaleDelta_ > 1 ? 1 : -1;
            return i.endInteraction(this.duration_, r), false;
          }
          return true;
        }
        handleDownEvent(t) {
          if (this.targetPointers.length >= 2) {
            const e = t.map;
            return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || e.getView().beginInteraction(), true;
          }
          return false;
        }
      }
      function jF(n) {
        n = n || {};
        const t = new lr(), e = new Ytt(-5e-3, 0.05, 100);
        return (n.altShiftDragRotate !== void 0 ? n.altShiftDragRotate : true) && t.push(new det()), (n.doubleClickZoom !== void 0 ? n.doubleClickZoom : true) && t.push(new aet({ delta: n.zoomDelta, duration: n.zoomDuration })), (n.dragPan !== void 0 ? n.dragPan : true) && t.push(new get({ onFocusOnly: n.onFocusOnly, kinetic: e })), (n.pinchRotate !== void 0 ? n.pinchRotate : true) && t.push(new Eet()), (n.pinchZoom !== void 0 ? n.pinchZoom : true) && t.push(new Iet({ duration: n.zoomDuration })), (n.keyboard !== void 0 ? n.keyboard : true) && (t.push(new yet()), t.push(new met({ delta: n.zoomDelta, duration: n.zoomDuration }))), (n.mouseWheelZoom !== void 0 ? n.mouseWheelZoom : true) && t.push(new _et({ onFocusOnly: n.onFocusOnly, duration: n.zoomDuration })), (n.shiftDragZoom !== void 0 ? n.shiftDragZoom : true) && t.push(new vet({ duration: n.zoomDuration })), t;
      }
      function qF(n) {
        if (n instanceof Zu) {
          n.setMapInternal(null);
          return;
        }
        n instanceof zr && n.getLayers().forEach(qF);
      }
      function HF(n, t) {
        if (n instanceof Zu) {
          n.setMapInternal(t);
          return;
        }
        if (n instanceof zr) {
          const e = n.getLayers().getArray();
          for (let i = 0, r = e.length; i < r; ++i) HF(e[i], t);
        }
      }
      let qw = class extends Kr {
        constructor(t) {
          super(), t = t || {}, this.on, this.once, this.un;
          const e = xet(t);
          this.renderComplete_ = false, this.loaded_ = true, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = t.maxTilesLoading !== void 0 ? t.maxTilesLoading : 16, this.pixelRatio_ = t.pixelRatio !== void 0 ? t.pixelRatio : PN, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = an(), this.pixelToCoordinateTransform_ = an(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = t.moveTolerance, this.keyboardEventTarget_ = e.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.targetElement_ = null, this.resizeObserver_ = new ResizeObserver(() => this.updateSize()), this.controls = e.controls || QF(), this.interactions = e.interactions || jF({ onFocusOnly: true }), this.overlays_ = e.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new Jtt(this.getTilePriority.bind(this), this.handleTileChange_.bind(this)), this.addChangeListener(Ln.LAYERGROUP, this.handleLayerGroupChanged_), this.addChangeListener(Ln.VIEW, this.handleViewChanged_), this.addChangeListener(Ln.SIZE, this.handleSizeChanged_), this.addChangeListener(Ln.TARGET, this.handleTargetChanged_), this.setProperties(e.values);
          const i = this;
          t.view && !(t.view instanceof Qa) && t.view.then(function(r) {
            i.setView(new Qa(r));
          }), this.controls.addEventListener(ii.ADD, (r) => {
            r.element.setMap(this);
          }), this.controls.addEventListener(ii.REMOVE, (r) => {
            r.element.setMap(null);
          }), this.interactions.addEventListener(ii.ADD, (r) => {
            r.element.setMap(this);
          }), this.interactions.addEventListener(ii.REMOVE, (r) => {
            r.element.setMap(null);
          }), this.overlays_.addEventListener(ii.ADD, (r) => {
            this.addOverlayInternal_(r.element);
          }), this.overlays_.addEventListener(ii.REMOVE, (r) => {
            const a = r.element.getId();
            a !== void 0 && delete this.overlayIdIndex_[a.toString()], r.element.setMap(null);
          }), this.controls.forEach((r) => {
            r.setMap(this);
          }), this.interactions.forEach((r) => {
            r.setMap(this);
          }), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
        }
        addControl(t) {
          this.getControls().push(t);
        }
        addInteraction(t) {
          this.getInteractions().push(t);
        }
        addLayer(t) {
          this.getLayerGroup().getLayers().push(t);
        }
        handleLayerAdd_(t) {
          HF(t.layer, this);
        }
        addOverlay(t) {
          this.getOverlays().push(t);
        }
        addOverlayInternal_(t) {
          const e = t.getId();
          e !== void 0 && (this.overlayIdIndex_[e.toString()] = t), t.setMap(this);
        }
        disposeInternal() {
          this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.resizeObserver_.disconnect(), this.setTarget(null), super.disposeInternal();
        }
        forEachFeatureAtPixel(t, e, i) {
          if (!this.frameState_ || !this.renderer_) return;
          const r = this.getCoordinateFromPixelInternal(t);
          i = i !== void 0 ? i : {};
          const a = i.hitTolerance !== void 0 ? i.hitTolerance : 0, o = i.layerFilter !== void 0 ? i.layerFilter : Fu, s = i.checkWrapped !== false;
          return this.renderer_.forEachFeatureAtCoordinate(r, this.frameState_, a, s, e, null, o, null);
        }
        getFeaturesAtPixel(t, e) {
          const i = [];
          return this.forEachFeatureAtPixel(t, function(r) {
            i.push(r);
          }, e), i;
        }
        getAllLayers() {
          const t = [];
          function e(i) {
            i.forEach(function(r) {
              r instanceof zr ? e(r.getLayers()) : t.push(r);
            });
          }
          return e(this.getLayers()), t;
        }
        hasFeatureAtPixel(t, e) {
          if (!this.frameState_ || !this.renderer_) return false;
          const i = this.getCoordinateFromPixelInternal(t);
          e = e !== void 0 ? e : {};
          const r = e.layerFilter !== void 0 ? e.layerFilter : Fu, a = e.hitTolerance !== void 0 ? e.hitTolerance : 0, o = e.checkWrapped !== false;
          return this.renderer_.hasFeatureAtCoordinate(i, this.frameState_, a, o, r, null);
        }
        getEventCoordinate(t) {
          return this.getCoordinateFromPixel(this.getEventPixel(t));
        }
        getEventCoordinateInternal(t) {
          return this.getCoordinateFromPixelInternal(this.getEventPixel(t));
        }
        getEventPixel(t) {
          const i = this.viewport_.getBoundingClientRect(), r = this.getSize(), a = i.width / r[0], o = i.height / r[1], s = "changedTouches" in t ? t.changedTouches[0] : t;
          return [(s.clientX - i.left) / a, (s.clientY - i.top) / o];
        }
        getTarget() {
          return this.get(Ln.TARGET);
        }
        getTargetElement() {
          return this.targetElement_;
        }
        getCoordinateFromPixel(t) {
          return vo(this.getCoordinateFromPixelInternal(t), this.getView().getProjection());
        }
        getCoordinateFromPixelInternal(t) {
          const e = this.frameState_;
          return e ? nn(e.pixelToCoordinateTransform, t.slice()) : null;
        }
        getControls() {
          return this.controls;
        }
        getOverlays() {
          return this.overlays_;
        }
        getOverlayById(t) {
          const e = this.overlayIdIndex_[t.toString()];
          return e !== void 0 ? e : null;
        }
        getInteractions() {
          return this.interactions;
        }
        getLayerGroup() {
          return this.get(Ln.LAYERGROUP);
        }
        setLayers(t) {
          const e = this.getLayerGroup();
          if (t instanceof lr) {
            e.setLayers(t);
            return;
          }
          const i = e.getLayers();
          i.clear(), i.extend(t);
        }
        getLayers() {
          return this.getLayerGroup().getLayers();
        }
        getLoadingOrNotReady() {
          const t = this.getLayerGroup().getLayerStatesArray();
          for (let e = 0, i = t.length; e < i; ++e) {
            const r = t[e];
            if (!r.visible) continue;
            const a = r.layer.getRenderer();
            if (a && !a.ready) return true;
            const o = r.layer.getSource();
            if (o && o.loading) return true;
          }
          return false;
        }
        getPixelFromCoordinate(t) {
          const e = ke(t, this.getView().getProjection());
          return this.getPixelFromCoordinateInternal(e);
        }
        getPixelFromCoordinateInternal(t) {
          const e = this.frameState_;
          return e ? nn(e.coordinateToPixelTransform, t.slice(0, 2)) : null;
        }
        getRenderer() {
          return this.renderer_;
        }
        getSize() {
          return this.get(Ln.SIZE);
        }
        getView() {
          return this.get(Ln.VIEW);
        }
        getViewport() {
          return this.viewport_;
        }
        getOverlayContainer() {
          return this.overlayContainer_;
        }
        getOverlayContainerStopEvent() {
          return this.overlayContainerStopEvent_;
        }
        getOwnerDocument() {
          const t = this.getTargetElement();
          return t ? t.ownerDocument : document;
        }
        getTilePriority(t, e, i, r) {
          return tet(this.frameState_, t, e, i, r);
        }
        handleBrowserEvent(t, e) {
          e = e || t.type;
          const i = new Ts(e, this, t);
          this.handleMapBrowserEvent(i);
        }
        handleMapBrowserEvent(t) {
          if (!this.frameState_) return;
          const e = t.originalEvent, i = e.type;
          if (i === Io.POINTERDOWN || i === Rt.WHEEL || i === Rt.KEYDOWN) {
            const r = this.getOwnerDocument(), a = this.viewport_.getRootNode ? this.viewport_.getRootNode() : r, o = e.target, s = a instanceof ShadowRoot ? a.host === o ? a.host.ownerDocument : a : a === r ? r.documentElement : a;
            if (this.overlayContainerStopEvent_.contains(o) || !s.contains(o)) return;
          }
          if (t.frameState = this.frameState_, this.dispatchEvent(t) !== false) {
            const r = this.getInteractions().getArray().slice();
            for (let a = r.length - 1; a >= 0; a--) {
              const o = r[a];
              if (o.getMap() !== this || !o.getActive() || !this.getTargetElement()) continue;
              if (!o.handleEvent(t) || t.propagationStopped) break;
            }
          }
        }
        handlePostRender() {
          const t = this.frameState_, e = this.tileQueue_;
          if (!e.isEmpty()) {
            let r = this.maxTilesLoading_, a = r;
            if (t) {
              const o = t.viewHints;
              if (o[xn.ANIMATING] || o[xn.INTERACTING]) {
                const s = Date.now() - t.time > 8;
                r = s ? 0 : 8, a = s ? 0 : 2;
              }
            }
            e.getTilesLoading() < r && (e.reprioritize(), e.loadMoreTiles(r, a));
          }
          t && this.renderer_ && !t.animate && (this.renderComplete_ ? (this.hasListener(si.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(si.RENDERCOMPLETE, t), this.loaded_ === false && (this.loaded_ = true, this.dispatchEvent(new yf(xo.LOADEND, this, t)))) : this.loaded_ === true && (this.loaded_ = false, this.dispatchEvent(new yf(xo.LOADSTART, this, t))));
          const i = this.postRenderFunctions_;
          if (t) for (let r = 0, a = i.length; r < a; ++r) i[r](this, t);
          i.length = 0;
        }
        handleSizeChanged_() {
          this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
        }
        handleTargetChanged_() {
          if (this.mapBrowserEventHandler_) {
            for (let i = 0, r = this.targetChangeHandlerKeys_.length; i < r; ++i) we(this.targetChangeHandlerKeys_[i]);
            this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(Rt.CONTEXTMENU, this.boundHandleBrowserEvent_), this.viewport_.removeEventListener(Rt.WHEEL, this.boundHandleBrowserEvent_), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, this.viewport_.remove();
          }
          if (this.targetElement_) {
            this.resizeObserver_.unobserve(this.targetElement_);
            const i = this.targetElement_.getRootNode();
            i instanceof ShadowRoot && this.resizeObserver_.unobserve(i.host), this.setSize(void 0);
          }
          const t = this.getTarget(), e = typeof t == "string" ? document.getElementById(t) : t;
          if (this.targetElement_ = e, !e) this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
          else {
            e.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new $tt(this)), this.mapBrowserEventHandler_ = new Ztt(this, this.moveTolerance_);
            for (const a in Me) this.mapBrowserEventHandler_.addEventListener(Me[a], this.handleMapBrowserEvent.bind(this));
            this.viewport_.addEventListener(Rt.CONTEXTMENU, this.boundHandleBrowserEvent_, false), this.viewport_.addEventListener(Rt.WHEEL, this.boundHandleBrowserEvent_, NN ? { passive: false } : false);
            let i;
            if (this.keyboardEventTarget_) i = this.keyboardEventTarget_;
            else {
              const a = e.getRootNode();
              i = a instanceof ShadowRoot ? a.host : e;
            }
            this.targetChangeHandlerKeys_ = [Ut(i, Rt.KEYDOWN, this.handleBrowserEvent, this), Ut(i, Rt.KEYPRESS, this.handleBrowserEvent, this)];
            const r = e.getRootNode();
            r instanceof ShadowRoot && this.resizeObserver_.observe(r.host), this.resizeObserver_.observe(e);
          }
          this.updateSize();
        }
        handleTileChange_() {
          this.render();
        }
        handleViewPropertyChanged_() {
          this.render();
        }
        handleViewChanged_() {
          this.viewPropertyListenerKey_ && (we(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (we(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
          const t = this.getView();
          t && (this.updateViewportSize_(this.getSize()), this.viewPropertyListenerKey_ = Ut(t, uo.PROPERTYCHANGE, this.handleViewPropertyChanged_, this), this.viewChangeListenerKey_ = Ut(t, Rt.CHANGE, this.handleViewPropertyChanged_, this), t.resolveConstraints(0)), this.render();
        }
        handleLayerGroupChanged_() {
          this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(we), this.layerGroupPropertyListenerKeys_ = null);
          const t = this.getLayerGroup();
          t && (this.handleLayerAdd_(new Tl("addlayer", t)), this.layerGroupPropertyListenerKeys_ = [Ut(t, uo.PROPERTYCHANGE, this.render, this), Ut(t, Rt.CHANGE, this.render, this), Ut(t, "addlayer", this.handleLayerAdd_, this), Ut(t, "removelayer", this.handleLayerRemove_, this)]), this.render();
        }
        isRendered() {
          return !!this.frameState_;
        }
        animationDelay_() {
          this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
        }
        renderSync() {
          this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
        }
        redrawText() {
          const t = this.getLayerGroup().getLayerStatesArray();
          for (let e = 0, i = t.length; e < i; ++e) {
            const r = t[e].layer;
            r.hasRenderer() && r.getRenderer().handleFontsChanged();
          }
        }
        render() {
          this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
        }
        removeControl(t) {
          return this.getControls().remove(t);
        }
        removeInteraction(t) {
          return this.getInteractions().remove(t);
        }
        removeLayer(t) {
          return this.getLayerGroup().getLayers().remove(t);
        }
        handleLayerRemove_(t) {
          qF(t.layer);
        }
        removeOverlay(t) {
          return this.getOverlays().remove(t);
        }
        renderFrame_(t) {
          const e = this.getSize(), i = this.getView(), r = this.frameState_;
          let a = null;
          if (e !== void 0 && UN(e) && i && i.isDef()) {
            const o = i.getHints(this.frameState_ ? this.frameState_.viewHints : void 0), s = i.getState();
            if (a = { animate: false, coordinateToPixelTransform: this.coordinateToPixelTransform_, declutter: null, extent: nA(s.center, s.resolution, s.rotation, e), index: this.frameIndex_++, layerIndex: 0, layerStatesArray: this.getLayerGroup().getLayerStatesArray(), pixelRatio: this.pixelRatio_, pixelToCoordinateTransform: this.pixelToCoordinateTransform_, postRenderFunctions: [], size: e, tileQueue: this.tileQueue_, time: t, usedTiles: {}, viewState: s, viewHints: o, wantedTiles: {}, mapId: xt(this), renderTargets: {} }, s.nextCenter && s.nextResolution) {
              const l = isNaN(s.nextRotation) ? s.rotation : s.nextRotation;
              a.nextExtent = nA(s.nextCenter, s.nextResolution, l, e);
            }
          }
          this.frameState_ = a, this.renderer_.renderFrame(a), a && (a.animate && this.render(), Array.prototype.push.apply(this.postRenderFunctions_, a.postRenderFunctions), r && (!this.previousExtent_ || !ps(this.previousExtent_) && !As(a.extent, this.previousExtent_)) && (this.dispatchEvent(new yf(xo.MOVESTART, this, r)), this.previousExtent_ = Hc(this.previousExtent_)), this.previousExtent_ && !a.viewHints[xn.ANIMATING] && !a.viewHints[xn.INTERACTING] && !As(a.extent, this.previousExtent_) && (this.dispatchEvent(new yf(xo.MOVEEND, this, a)), zP(a.extent, this.previousExtent_))), this.dispatchEvent(new yf(xo.POSTRENDER, this, a)), this.renderComplete_ = (this.hasListener(xo.LOADSTART) || this.hasListener(xo.LOADEND) || this.hasListener(si.RENDERCOMPLETE)) && !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady(), this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
            this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
          }, 0));
        }
        setLayerGroup(t) {
          const e = this.getLayerGroup();
          e && this.handleLayerRemove_(new Tl("removelayer", e)), this.set(Ln.LAYERGROUP, t);
        }
        setSize(t) {
          this.set(Ln.SIZE, t);
        }
        setTarget(t) {
          this.set(Ln.TARGET, t);
        }
        setView(t) {
          if (!t || t instanceof Qa) {
            this.set(Ln.VIEW, t);
            return;
          }
          this.set(Ln.VIEW, new Qa());
          const e = this;
          t.then(function(i) {
            e.setView(new Qa(i));
          });
        }
        updateSize() {
          const t = this.getTargetElement();
          let e;
          if (t) {
            const r = getComputedStyle(t), a = t.offsetWidth - parseFloat(r.borderLeftWidth) - parseFloat(r.paddingLeft) - parseFloat(r.paddingRight) - parseFloat(r.borderRightWidth), o = t.offsetHeight - parseFloat(r.borderTopWidth) - parseFloat(r.paddingTop) - parseFloat(r.paddingBottom) - parseFloat(r.borderBottomWidth);
            !isNaN(a) && !isNaN(o) && (e = [Math.max(0, a), Math.max(0, o)], !UN(e) && (t.offsetWidth || t.offsetHeight || t.getClientRects().length) && lN("No map visible because the map container's width or height are 0."));
          }
          const i = this.getSize();
          e && (!i || !co(e, i)) && (this.setSize(e), this.updateViewportSize_(e));
        }
        updateViewportSize_(t) {
          const e = this.getView();
          e && e.setViewportSize(t);
        }
      };
      function xet(n) {
        let t = null;
        n.keyboardEventTarget !== void 0 && (t = typeof n.keyboardEventTarget == "string" ? document.getElementById(n.keyboardEventTarget) : n.keyboardEventTarget);
        const e = {}, i = n.layers && typeof n.layers.getLayers == "function" ? n.layers : new zr({ layers: n.layers });
        e[Ln.LAYERGROUP] = i, e[Ln.TARGET] = n.target, e[Ln.VIEW] = n.view instanceof Qa ? n.view : new Qa();
        let r;
        n.controls !== void 0 && (Array.isArray(n.controls) ? r = new lr(n.controls.slice()) : (ue(typeof n.controls.getArray == "function", "Expected `controls` to be an array or an `ol/Collection.js`"), r = n.controls));
        let a;
        n.interactions !== void 0 && (Array.isArray(n.interactions) ? a = new lr(n.interactions.slice()) : (ue(typeof n.interactions.getArray == "function", "Expected `interactions` to be an array or an `ol/Collection.js`"), a = n.interactions));
        let o;
        return n.overlays !== void 0 ? Array.isArray(n.overlays) ? o = new lr(n.overlays.slice()) : (ue(typeof n.overlays.getArray == "function", "Expected `overlays` to be an array or an `ol/Collection.js`"), o = n.overlays) : o = new lr(), { controls: r, interactions: a, keyboardEventTarget: t, overlays: o, values: e };
      }
      const Bi = { ELEMENT: "element", MAP: "map", OFFSET: "offset", POSITION: "position", POSITIONING: "positioning" };
      class YF extends Kr {
        constructor(t) {
          super(), this.on, this.once, this.un, this.options = t, this.id = t.id, this.insertFirst = t.insertFirst !== void 0 ? t.insertFirst : true, this.stopEvent = t.stopEvent !== void 0 ? t.stopEvent : true, this.element = document.createElement("div"), this.element.className = t.className !== void 0 ? t.className : "ol-overlay-container " + nJ, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = t.autoPan === true ? {} : t.autoPan || void 0, this.rendered = { transform_: "", visible: true }, this.mapPostrenderListenerKey = null, this.addChangeListener(Bi.ELEMENT, this.handleElementChanged), this.addChangeListener(Bi.MAP, this.handleMapChanged), this.addChangeListener(Bi.OFFSET, this.handleOffsetChanged), this.addChangeListener(Bi.POSITION, this.handlePositionChanged), this.addChangeListener(Bi.POSITIONING, this.handlePositioningChanged), t.element !== void 0 && this.setElement(t.element), this.setOffset(t.offset !== void 0 ? t.offset : [0, 0]), this.setPositioning(t.positioning || "top-left"), t.position !== void 0 && this.setPosition(t.position);
        }
        getElement() {
          return this.get(Bi.ELEMENT);
        }
        getId() {
          return this.id;
        }
        getMap() {
          return this.get(Bi.MAP) || null;
        }
        getOffset() {
          return this.get(Bi.OFFSET);
        }
        getPosition() {
          return this.get(Bi.POSITION);
        }
        getPositioning() {
          return this.get(Bi.POSITIONING);
        }
        handleElementChanged() {
          FN(this.element);
          const t = this.getElement();
          t && this.element.appendChild(t);
        }
        handleMapChanged() {
          var e;
          this.mapPostrenderListenerKey && ((e = this.element) == null || e.remove(), we(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
          const t = this.getMap();
          if (t) {
            this.mapPostrenderListenerKey = Ut(t, xo.POSTRENDER, this.render, this), this.updatePixelPosition();
            const i = this.stopEvent ? t.getOverlayContainerStopEvent() : t.getOverlayContainer();
            this.insertFirst ? i.insertBefore(this.element, i.childNodes[0] || null) : i.appendChild(this.element), this.performAutoPan();
          }
        }
        render() {
          this.updatePixelPosition();
        }
        handleOffsetChanged() {
          this.updatePixelPosition();
        }
        handlePositionChanged() {
          this.updatePixelPosition(), this.performAutoPan();
        }
        handlePositioningChanged() {
          this.updatePixelPosition();
        }
        setElement(t) {
          this.set(Bi.ELEMENT, t);
        }
        setMap(t) {
          this.set(Bi.MAP, t);
        }
        setOffset(t) {
          this.set(Bi.OFFSET, t);
        }
        setPosition(t) {
          this.set(Bi.POSITION, t);
        }
        performAutoPan() {
          this.autoPan && this.panIntoView(this.autoPan);
        }
        panIntoView(t) {
          const e = this.getMap();
          if (!e || !e.getTargetElement() || !this.get(Bi.POSITION)) return;
          const i = this.getRect(e.getTargetElement(), e.getSize()), r = this.getElement(), a = this.getRect(r, [YK(r), WK(r)]);
          t = t || {};
          const o = t.margin === void 0 ? 20 : t.margin;
          if (!Pr(i, a)) {
            const s = a[0] - i[0], l = i[2] - a[2], u = a[1] - i[1], h = i[3] - a[3], c = [0, 0];
            if (s < 0 ? c[0] = s - o : l < 0 && (c[0] = Math.abs(l) + o), u < 0 ? c[1] = u - o : h < 0 && (c[1] = Math.abs(h) + o), c[0] !== 0 || c[1] !== 0) {
              const f = e.getView().getCenterInternal(), g = e.getPixelFromCoordinateInternal(f);
              if (!g) return;
              const d = [g[0] + c[0], g[1] + c[1]], A = t.animation || {};
              e.getView().animateInternal({ center: e.getCoordinateFromPixelInternal(d), duration: A.duration, easing: A.easing });
            }
          }
        }
        getRect(t, e) {
          const i = t.getBoundingClientRect(), r = i.left + window.pageXOffset, a = i.top + window.pageYOffset;
          return [r, a, r + e[0], a + e[1]];
        }
        setPositioning(t) {
          this.set(Bi.POSITIONING, t);
        }
        setVisible(t) {
          this.rendered.visible !== t && (this.element.style.display = t ? "" : "none", this.rendered.visible = t);
        }
        updatePixelPosition() {
          const t = this.getMap(), e = this.getPosition();
          if (!t || !t.isRendered() || !e) {
            this.setVisible(false);
            return;
          }
          const i = t.getPixelFromCoordinate(e), r = t.getSize();
          this.updateRenderedPosition(i, r);
        }
        updateRenderedPosition(t, e) {
          const i = this.element.style, r = this.getOffset(), a = this.getPositioning();
          this.setVisible(true);
          const o = Math.round(t[0] + r[0]) + "px", s = Math.round(t[1] + r[1]) + "px";
          let l = "0%", u = "0%";
          a == "bottom-right" || a == "center-right" || a == "top-right" ? l = "-100%" : (a == "bottom-center" || a == "center-center" || a == "top-center") && (l = "-50%"), a == "bottom-left" || a == "bottom-center" || a == "bottom-right" ? u = "-100%" : (a == "center-left" || a == "center-center" || a == "center-right") && (u = "-50%");
          const h = `translate(${l}, ${u}) translate(${o}, ${s})`;
          this.rendered.transform_ != h && (this.rendered.transform_ = h, i.transform = h);
        }
        getOptions() {
          return this.options;
        }
      }
      class WF {
        constructor(t) {
          this.highWaterMark = t !== void 0 ? t : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
        }
        deleteOldest() {
          const t = this.pop();
          t instanceof Nu && t.dispose();
        }
        canExpireCache() {
          return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
        }
        expireCache(t) {
          for (; this.canExpireCache(); ) this.deleteOldest();
        }
        clear() {
          for (; this.oldest_; ) this.deleteOldest();
        }
        containsKey(t) {
          return this.entries_.hasOwnProperty(t);
        }
        forEach(t) {
          let e = this.oldest_;
          for (; e; ) t(e.value_, e.key_, this), e = e.newer;
        }
        get(t, e) {
          const i = this.entries_[t];
          return ue(i !== void 0, "Tried to get a value for a key that does not exist in the cache"), i === this.newest_ || (i === this.oldest_ ? (this.oldest_ = this.oldest_.newer, this.oldest_.older = null) : (i.newer.older = i.older, i.older.newer = i.newer), i.newer = null, i.older = this.newest_, this.newest_.newer = i, this.newest_ = i), i.value_;
        }
        remove(t) {
          const e = this.entries_[t];
          return ue(e !== void 0, "Tried to get a value for a key that does not exist in the cache"), e === this.newest_ ? (this.newest_ = e.older, this.newest_ && (this.newest_.newer = null)) : e === this.oldest_ ? (this.oldest_ = e.newer, this.oldest_ && (this.oldest_.older = null)) : (e.newer.older = e.older, e.older.newer = e.newer), delete this.entries_[t], --this.count_, e.value_;
        }
        getCount() {
          return this.count_;
        }
        getKeys() {
          const t = new Array(this.count_);
          let e = 0, i;
          for (i = this.newest_; i; i = i.older) t[e++] = i.key_;
          return t;
        }
        getValues() {
          const t = new Array(this.count_);
          let e = 0, i;
          for (i = this.newest_; i; i = i.older) t[e++] = i.value_;
          return t;
        }
        peekLast() {
          return this.oldest_.value_;
        }
        peekLastKey() {
          return this.oldest_.key_;
        }
        peekFirstKey() {
          return this.newest_.key_;
        }
        peek(t) {
          var e;
          return (e = this.entries_[t]) == null ? void 0 : e.value_;
        }
        pop() {
          const t = this.oldest_;
          return delete this.entries_[t.key_], t.newer && (t.newer.older = null), this.oldest_ = t.newer, this.oldest_ || (this.newest_ = null), --this.count_, t.value_;
        }
        replace(t, e) {
          this.get(t), this.entries_[t].value_ = e;
        }
        set(t, e) {
          ue(!(t in this.entries_), "Tried to set a value for a key that is used already");
          const i = { key_: t, newer: null, older: this.newest_, value_: e };
          this.newest_ ? this.newest_.newer = i : this.oldest_ = i, this.newest_ = i, this.entries_[t] = i, ++this.count_;
        }
        setSize(t) {
          this.highWaterMark = t;
        }
      }
      function Ef(n, t, e, i) {
        return i !== void 0 ? (i[0] = n, i[1] = t, i[2] = e, i) : [n, t, e];
      }
      function XF(n, t, e) {
        return n + "/" + t + "/" + e;
      }
      function If(n) {
        return XF(n[0], n[1], n[2]);
      }
      function $F(n) {
        return wet(n[0], n[1], n[2]);
      }
      function wet(n, t, e) {
        return (t << n) + e;
      }
      function Cet(n, t) {
        const e = n[0], i = n[1], r = n[2];
        if (t.getMinZoom() > e || e > t.getMaxZoom()) return false;
        const a = t.getFullTileRange(e);
        return a ? a.containsXY(i, r) : true;
      }
      class Jm {
        constructor(t, e, i, r) {
          this.minX = t, this.maxX = e, this.minY = i, this.maxY = r;
        }
        contains(t) {
          return this.containsXY(t[1], t[2]);
        }
        containsTileRange(t) {
          return this.minX <= t.minX && t.maxX <= this.maxX && this.minY <= t.minY && t.maxY <= this.maxY;
        }
        containsXY(t, e) {
          return this.minX <= t && t <= this.maxX && this.minY <= e && e <= this.maxY;
        }
        equals(t) {
          return this.minX == t.minX && this.minY == t.minY && this.maxX == t.maxX && this.maxY == t.maxY;
        }
        extend(t) {
          t.minX < this.minX && (this.minX = t.minX), t.maxX > this.maxX && (this.maxX = t.maxX), t.minY < this.minY && (this.minY = t.minY), t.maxY > this.maxY && (this.maxY = t.maxY);
        }
        getHeight() {
          return this.maxY - this.minY + 1;
        }
        getSize() {
          return [this.getWidth(), this.getHeight()];
        }
        getWidth() {
          return this.maxX - this.minX + 1;
        }
        intersects(t) {
          return this.minX <= t.maxX && this.maxX >= t.minX && this.minY <= t.maxY && this.maxY >= t.minY;
        }
      }
      function xf(n, t, e, i, r) {
        return r !== void 0 ? (r.minX = n, r.maxX = t, r.minY = e, r.maxY = i, r) : new Jm(n, t, e, i);
      }
      class bet extends Bs {
        constructor(t) {
          t = t || {}, super(t), this.condition_ = t.condition ? t.condition : jw, this.lastAngle_ = void 0, this.lastMagnitude_ = void 0, this.lastScaleDelta_ = 0, this.duration_ = t.duration !== void 0 ? t.duration : 400;
        }
        handleDragEvent(t) {
          if (!mf(t)) return;
          const e = t.map, i = e.getSize(), r = t.pixel, a = r[0] - i[0] / 2, o = i[1] / 2 - r[1], s = Math.atan2(o, a), l = Math.sqrt(a * a + o * o), u = e.getView();
          if (this.lastAngle_ !== void 0) {
            const h = this.lastAngle_ - s;
            u.adjustRotationInternal(h);
          }
          this.lastAngle_ = s, this.lastMagnitude_ !== void 0 && u.adjustResolutionInternal(this.lastMagnitude_ / l), this.lastMagnitude_ !== void 0 && (this.lastScaleDelta_ = this.lastMagnitude_ / l), this.lastMagnitude_ = l;
        }
        handleUpEvent(t) {
          if (!mf(t)) return true;
          const i = t.map.getView(), r = this.lastScaleDelta_ > 1 ? 1 : -1;
          return i.endInteraction(this.duration_, r), this.lastScaleDelta_ = 0, false;
        }
        handleDownEvent(t) {
          return mf(t) && this.condition_(t) ? (t.map.getView().beginInteraction(), this.lastAngle_ = void 0, this.lastMagnitude_ = void 0, true) : false;
        }
      }
      const t0 = { DRAWSTART: "drawstart", DRAWEND: "drawend", DRAWABORT: "drawabort" };
      class e0 extends Te {
        constructor(t, e) {
          super(t), this.feature = e;
        }
      }
      function Tet(n, t) {
        const e = [];
        for (let i = 0; i < t.length; ++i) {
          const a = t[i].getGeometry();
          ZF(n, a, e);
        }
        return e;
      }
      function n0(n, t) {
        return vs(n[0], n[1], t[0], t[1]);
      }
      function wf(n, t) {
        const e = n.length;
        return t < 0 ? n[t + e] : t >= e ? n[t - e] : n[t];
      }
      function i0(n, t, e) {
        let i, r;
        t < e ? (i = t, r = e) : (i = e, r = t);
        const a = Math.ceil(i), o = Math.floor(r);
        if (a > o) {
          const l = Cf(n, i), u = Cf(n, r);
          return n0(l, u);
        }
        let s = 0;
        if (i < a) {
          const l = Cf(n, i), u = wf(n, a);
          s += n0(l, u);
        }
        if (o < r) {
          const l = wf(n, o), u = Cf(n, r);
          s += n0(l, u);
        }
        for (let l = a; l < o - 1; ++l) {
          const u = wf(n, l), h = wf(n, l + 1);
          s += n0(u, h);
        }
        return s;
      }
      function ZF(n, t, e) {
        if (t instanceof Be) {
          r0(n, t.getCoordinates(), false, e);
          return;
        }
        if (t instanceof ui) {
          const i = t.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) r0(n, i[r], false, e);
          return;
        }
        if (t instanceof Dn) {
          const i = t.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) r0(n, i[r], true, e);
          return;
        }
        if (t instanceof bi) {
          const i = t.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r];
            for (let s = 0, l = o.length; s < l; ++s) r0(n, o[s], true, e);
          }
          return;
        }
        if (t instanceof wn) {
          const i = t.getGeometries();
          for (let r = 0; r < i.length; ++r) ZF(n, i[r], e);
          return;
        }
      }
      const Hw = { index: -1, endIndex: NaN };
      function Bet(n, t, e, i) {
        const r = n[0], a = n[1];
        let o = 1 / 0, s = -1, l = NaN;
        for (let c = 0; c < t.targets.length; ++c) {
          const f = t.targets[c], g = f.coordinates;
          let d = 1 / 0, A;
          for (let p = 0; p < g.length - 1; ++p) {
            const v = g[p], y = g[p + 1], m = KF(r, a, v, y);
            m.squaredDistance < d && (d = m.squaredDistance, A = p + m.along);
          }
          d < o && (o = d, f.ring && t.targetIndex === c && (f.endIndex > f.startIndex ? A < f.startIndex && (A += g.length) : f.endIndex < f.startIndex && A > f.startIndex && (A -= g.length)), l = A, s = c);
        }
        const u = t.targets[s];
        let h = u.ring;
        if (t.targetIndex === s && h) {
          const c = Cf(u.coordinates, l), f = e.getPixelFromCoordinate(c);
          Am(f, t.startPx) > i && (h = false);
        }
        if (h) {
          const c = u.coordinates, f = c.length, g = u.startIndex, d = l;
          if (g < d) {
            const A = i0(c, g, d);
            i0(c, g, d - f) < A && (l -= f);
          } else {
            const A = i0(c, g, d);
            i0(c, g, d + f) < A && (l += f);
          }
        }
        return Hw.index = s, Hw.endIndex = l, Hw;
      }
      function r0(n, t, e, i) {
        const r = n[0], a = n[1];
        for (let o = 0, s = t.length - 1; o < s; ++o) {
          const l = t[o], u = t[o + 1], h = KF(r, a, l, u);
          if (h.squaredDistance === 0) {
            const c = o + h.along;
            i.push({ coordinates: t, ring: e, startIndex: c, endIndex: c });
            return;
          }
        }
      }
      const Yw = { along: 0, squaredDistance: 0 };
      function KF(n, t, e, i) {
        const r = e[0], a = e[1], o = i[0], s = i[1], l = o - r, u = s - a;
        let h = 0, c = r, f = a;
        return (l !== 0 || u !== 0) && (h = Ze(((n - r) * l + (t - a) * u) / (l * l + u * u), 0, 1), c += l * h, f += u * h), Yw.along = h, Yw.squaredDistance = rA(vs(n, t, c, f), 10), Yw;
      }
      function Cf(n, t) {
        const e = n.length;
        let i = Math.floor(t);
        const r = t - i;
        i >= e ? i -= e : i < 0 && (i += e);
        let a = i + 1;
        a >= e && (a -= e);
        const o = n[i], s = o[0], l = o[1], u = n[a], h = u[0] - s, c = u[1] - l;
        return [s + h * r, l + c * r];
      }
      class JF extends Bs {
        constructor(t) {
          const e = t;
          e.stopDown || (e.stopDown = ku), super(e), this.on, this.once, this.un, this.shouldHandle_ = false, this.downPx_ = null, this.downTimeout_, this.lastDragTime_, this.pointerType_, this.freehand_ = false, this.source_ = t.source ? t.source : null, this.features_ = t.features ? t.features : null, this.snapTolerance_ = t.snapTolerance ? t.snapTolerance : 12, this.type_ = t.type, this.mode_ = Let(this.type_), this.stopClick_ = !!t.stopClick, this.minPoints_ = t.minPoints ? t.minPoints : this.mode_ === "Polygon" ? 3 : 2, this.maxPoints_ = this.mode_ === "Circle" ? 2 : t.maxPoints ? t.maxPoints : 1 / 0, this.finishCondition_ = t.finishCondition ? t.finishCondition : Fu, this.geometryLayout_ = t.geometryLayout ? t.geometryLayout : "XY";
          let i = t.geometryFunction;
          if (!i) {
            const r = this.mode_;
            if (r === "Circle") i = (a, o, s) => {
              const l = o || new MA([NaN, NaN]), u = ke(a[0]), h = go(u, ke(a[a.length - 1]));
              return l.setCenterAndRadius(u, Math.sqrt(h), this.geometryLayout_), l;
            };
            else {
              let a;
              r === "Point" ? a = Ge : r === "LineString" ? a = Be : r === "Polygon" && (a = Dn), i = (o, s, l) => (s ? r === "Polygon" ? o[0].length ? s.setCoordinates([o[0].concat([o[0][0]])], this.geometryLayout_) : s.setCoordinates([], this.geometryLayout_) : s.setCoordinates(o, this.geometryLayout_) : s = new a(o, this.geometryLayout_), s);
            }
          }
          this.geometryFunction_ = i, this.dragVertexDelay_ = t.dragVertexDelay !== void 0 ? t.dragVertexDelay : 500, this.finishCoordinate_ = null, this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchCoords_ = null, this.sketchLine_ = null, this.sketchLineCoords_ = null, this.squaredClickTolerance_ = t.clickTolerance ? t.clickTolerance * t.clickTolerance : 36, this.overlay_ = new aa({ source: new oa({ useSpatialIndex: false, wrapX: t.wrapX ? t.wrapX : false }), style: t.style ? t.style : Met(), updateWhileInteracting: true }), this.geometryName_ = t.geometryName, this.condition_ = t.condition ? t.condition : Vw, this.freehandCondition_, t.freehand ? this.freehandCondition_ = Km : this.freehandCondition_ = t.freehandCondition ? t.freehandCondition : jw, this.traceCondition_, this.setTrace(t.trace || false), this.traceState_ = { active: false }, this.traceSource_ = t.traceSource || t.source || null, this.addChangeListener(Qw.ACTIVE, this.updateState_);
        }
        setTrace(t) {
          let e;
          t ? t === true ? e = Km : e = t : e = het, this.traceCondition_ = e;
        }
        setMap(t) {
          super.setMap(t), this.updateState_();
        }
        getOverlay() {
          return this.overlay_;
        }
        handleEvent(t) {
          t.originalEvent.type === Rt.CONTEXTMENU && t.originalEvent.preventDefault(), this.freehand_ = this.mode_ !== "Point" && this.freehandCondition_(t);
          let e = t.type === Me.POINTERMOVE, i = true;
          return !this.freehand_ && this.lastDragTime_ && t.type === Me.POINTERDRAG && (Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = t.pixel, this.shouldHandle_ = !this.freehand_, e = true) : this.lastDragTime_ = void 0, this.shouldHandle_ && this.downTimeout_ !== void 0 && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0)), this.freehand_ && t.type === Me.POINTERDRAG && this.sketchFeature_ !== null ? (this.addToDrawing_(t.coordinate), i = false) : this.freehand_ && t.type === Me.POINTERDOWN ? i = false : e && this.getPointerCount() < 2 ? (i = t.type === Me.POINTERMOVE, i && this.freehand_ ? (this.handlePointerMove_(t), this.shouldHandle_ && t.originalEvent.preventDefault()) : (t.originalEvent.pointerType === "mouse" || t.type === Me.POINTERDRAG && this.downTimeout_ === void 0) && this.handlePointerMove_(t)) : t.type === Me.DBLCLICK && (i = false), super.handleEvent(t) && i;
        }
        handleDownEvent(t) {
          return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = t.pixel, this.finishCoordinate_ || this.startDrawing_(t.coordinate), true) : this.condition_(t) ? (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(() => {
            this.handlePointerMove_(new Ts(Me.POINTERMOVE, t.map, t.originalEvent, false, t.frameState));
          }, this.dragVertexDelay_), this.downPx_ = t.pixel, true) : (this.lastDragTime_ = void 0, false);
        }
        deactivateTrace_() {
          this.traceState_ = { active: false };
        }
        toggleTraceState_(t) {
          if (!this.traceSource_ || !this.traceCondition_(t)) return;
          if (this.traceState_.active) {
            this.deactivateTrace_();
            return;
          }
          const e = this.getMap(), i = e.getCoordinateFromPixel([t.pixel[0] - this.snapTolerance_, t.pixel[1] + this.snapTolerance_]), r = e.getCoordinateFromPixel([t.pixel[0] + this.snapTolerance_, t.pixel[1] - this.snapTolerance_]), a = Mn([i, r]), o = this.traceSource_.getFeaturesInExtent(a);
          if (o.length === 0) return;
          const s = Tet(t.coordinate, o);
          s.length && (this.traceState_ = { active: true, startPx: t.pixel.slice(), targets: s, targetIndex: -1 });
        }
        addOrRemoveTracedCoordinates_(t, e) {
          const i = t.startIndex <= t.endIndex, r = t.startIndex <= e;
          i === r ? i && e > t.endIndex || !i && e < t.endIndex ? this.addTracedCoordinates_(t, t.endIndex, e) : (i && e < t.endIndex || !i && e > t.endIndex) && this.removeTracedCoordinates_(e, t.endIndex) : (this.removeTracedCoordinates_(t.startIndex, t.endIndex), this.addTracedCoordinates_(t, t.startIndex, e));
        }
        removeTracedCoordinates_(t, e) {
          if (t === e) return;
          let i = 0;
          if (t < e) {
            const r = Math.ceil(t);
            let a = Math.floor(e);
            a === e && (a -= 1), i = a - r + 1;
          } else {
            const r = Math.floor(t);
            let a = Math.ceil(e);
            a === e && (a += 1), i = r - a + 1;
          }
          i > 0 && this.removeLastPoints_(i);
        }
        addTracedCoordinates_(t, e, i) {
          if (e === i) return;
          const r = [];
          if (e < i) {
            const a = Math.ceil(e);
            let o = Math.floor(i);
            o === i && (o -= 1);
            for (let s = a; s <= o; ++s) r.push(wf(t.coordinates, s));
          } else {
            const a = Math.floor(e);
            let o = Math.ceil(i);
            o === i && (o += 1);
            for (let s = a; s >= o; --s) r.push(wf(t.coordinates, s));
          }
          r.length && this.appendCoordinates(r);
        }
        updateTrace_(t) {
          const e = this.traceState_;
          if (!e.active || e.targetIndex === -1 && Am(e.startPx, t.pixel) < this.snapTolerance_) return;
          const i = Bet(t.coordinate, e, this.getMap(), this.snapTolerance_);
          if (e.targetIndex !== i.index) {
            if (e.targetIndex !== -1) {
              const l = e.targets[e.targetIndex];
              this.removeTracedCoordinates_(l.startIndex, l.endIndex);
            }
            const s = e.targets[i.index];
            this.addTracedCoordinates_(s, s.startIndex, i.endIndex);
          } else {
            const s = e.targets[e.targetIndex];
            this.addOrRemoveTracedCoordinates_(s, i.endIndex);
          }
          e.targetIndex = i.index;
          const r = e.targets[e.targetIndex];
          r.endIndex = i.endIndex;
          const a = Cf(r.coordinates, r.endIndex), o = this.getMap().getPixelFromCoordinate(a);
          t.coordinate = a, t.pixel = [Math.round(o[0]), Math.round(o[1])];
        }
        handleUpEvent(t) {
          let e = true;
          if (this.getPointerCount() === 0) {
            this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(t);
            const i = this.traceState_.active;
            if (this.toggleTraceState_(t), this.shouldHandle_) {
              const r = !this.finishCoordinate_;
              r && this.startDrawing_(t.coordinate), !r && this.freehand_ ? this.finishDrawing() : !this.freehand_ && (!r || this.mode_ === "Point") && (this.atFinish_(t.pixel, i) ? this.finishCondition_(t) && this.finishDrawing() : this.addToDrawing_(t.coordinate)), e = false;
            } else this.freehand_ && this.abortDrawing();
          }
          return !e && this.stopClick_ && t.preventDefault(), e;
        }
        handlePointerMove_(t) {
          if (this.pointerType_ = t.originalEvent.pointerType, this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
            const e = this.downPx_, i = t.pixel, r = e[0] - i[0], a = e[1] - i[1], o = r * r + a * a;
            if (this.shouldHandle_ = this.freehand_ ? o > this.squaredClickTolerance_ : o <= this.squaredClickTolerance_, !this.shouldHandle_) return;
          }
          if (!this.finishCoordinate_) {
            this.createOrUpdateSketchPoint_(t.coordinate.slice());
            return;
          }
          this.updateTrace_(t), this.modifyDrawing_(t.coordinate);
        }
        atFinish_(t, e) {
          let i = false;
          if (this.sketchFeature_) {
            let r = false, a = [this.finishCoordinate_];
            const o = this.mode_;
            if (o === "Point") i = true;
            else if (o === "Circle") i = this.sketchCoords_.length === 2;
            else if (o === "LineString") r = !e && this.sketchCoords_.length > this.minPoints_;
            else if (o === "Polygon") {
              const s = this.sketchCoords_;
              r = s[0].length > this.minPoints_, a = [s[0][0], s[0][s[0].length - 2]], e ? a = [s[0][0]] : a = [s[0][0], s[0][s[0].length - 2]];
            }
            if (r) {
              const s = this.getMap();
              for (let l = 0, u = a.length; l < u; l++) {
                const h = a[l], c = s.getPixelFromCoordinate(h), f = t[0] - c[0], g = t[1] - c[1], d = this.freehand_ ? 1 : this.snapTolerance_;
                if (i = Math.sqrt(f * f + g * g) <= d, i) {
                  this.finishCoordinate_ = h;
                  break;
                }
              }
            }
          }
          return i;
        }
        createOrUpdateSketchPoint_(t) {
          this.sketchPoint_ ? this.sketchPoint_.getGeometry().setCoordinates(t) : (this.sketchPoint_ = new Ce(new Ge(t)), this.updateSketchFeatures_());
        }
        createOrUpdateCustomSketchLine_(t) {
          this.sketchLine_ || (this.sketchLine_ = new Ce());
          const e = t.getLinearRing(0);
          let i = this.sketchLine_.getGeometry();
          i ? (i.setFlatCoordinates(e.getLayout(), e.getFlatCoordinates()), i.changed()) : (i = new Be(e.getFlatCoordinates(), e.getLayout()), this.sketchLine_.setGeometry(i));
        }
        startDrawing_(t) {
          const e = this.getMap().getView().getProjection(), i = lA(this.geometryLayout_);
          for (; t.length < i; ) t.push(0);
          this.finishCoordinate_ = t, this.mode_ === "Point" ? this.sketchCoords_ = t.slice() : this.mode_ === "Polygon" ? (this.sketchCoords_ = [[t.slice(), t.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [t.slice(), t.slice()], this.sketchLineCoords_ && (this.sketchLine_ = new Ce(new Be(this.sketchLineCoords_)));
          const r = this.geometryFunction_(this.sketchCoords_, void 0, e);
          this.sketchFeature_ = new Ce(), this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(r), this.updateSketchFeatures_(), this.dispatchEvent(new e0(t0.DRAWSTART, this.sketchFeature_));
        }
        modifyDrawing_(t) {
          const e = this.getMap(), i = this.sketchFeature_.getGeometry(), r = e.getView().getProjection(), a = lA(this.geometryLayout_);
          let o, s;
          for (; t.length < a; ) t.push(0);
          this.mode_ === "Point" ? s = this.sketchCoords_ : this.mode_ === "Polygon" ? (o = this.sketchCoords_[0], s = o[o.length - 1], this.atFinish_(e.getPixelFromCoordinate(t)) && (t = this.finishCoordinate_.slice())) : (o = this.sketchCoords_, s = o[o.length - 1]), s[0] = t[0], s[1] = t[1], this.geometryFunction_(this.sketchCoords_, i, r), this.sketchPoint_ && this.sketchPoint_.getGeometry().setCoordinates(t), i.getType() === "Polygon" && this.mode_ !== "Polygon" ? this.createOrUpdateCustomSketchLine_(i) : this.sketchLineCoords_ && this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_), this.updateSketchFeatures_();
        }
        addToDrawing_(t) {
          const e = this.sketchFeature_.getGeometry(), i = this.getMap().getView().getProjection();
          let r, a;
          const o = this.mode_;
          return o === "LineString" || o === "Circle" ? (this.finishCoordinate_ = t.slice(), a = this.sketchCoords_, a.length >= this.maxPoints_ && (this.freehand_ ? a.pop() : r = true), a.push(t.slice()), this.geometryFunction_(a, e, i)) : o === "Polygon" && (a = this.sketchCoords_[0], a.length >= this.maxPoints_ && (this.freehand_ ? a.pop() : r = true), a.push(t.slice()), r && (this.finishCoordinate_ = a[0]), this.geometryFunction_(this.sketchCoords_, e, i)), this.createOrUpdateSketchPoint_(t.slice()), this.updateSketchFeatures_(), r ? this.finishDrawing() : this.sketchFeature_;
        }
        removeLastPoints_(t) {
          if (!this.sketchFeature_) return;
          const e = this.sketchFeature_.getGeometry(), i = this.getMap().getView().getProjection(), r = this.mode_;
          for (let a = 0; a < t; ++a) {
            let o;
            if (r === "LineString" || r === "Circle") {
              if (o = this.sketchCoords_, o.splice(-2, 1), o.length >= 2) {
                this.finishCoordinate_ = o[o.length - 2].slice();
                const s = this.finishCoordinate_.slice();
                o[o.length - 1] = s, this.createOrUpdateSketchPoint_(s);
              }
              this.geometryFunction_(o, e, i), e.getType() === "Polygon" && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(e);
            } else if (r === "Polygon") {
              o = this.sketchCoords_[0], o.splice(-2, 1);
              const s = this.sketchLine_.getGeometry();
              if (o.length >= 2) {
                const l = o[o.length - 2].slice();
                o[o.length - 1] = l, this.createOrUpdateSketchPoint_(l);
              }
              s.setCoordinates(o), this.geometryFunction_(this.sketchCoords_, e, i);
            }
            if (o.length === 1) {
              this.abortDrawing();
              break;
            }
          }
          this.updateSketchFeatures_();
        }
        removeLastPoint() {
          this.removeLastPoints_(1);
        }
        finishDrawing() {
          const t = this.abortDrawing_();
          if (!t) return null;
          let e = this.sketchCoords_;
          const i = t.getGeometry(), r = this.getMap().getView().getProjection();
          return this.mode_ === "LineString" ? (e.pop(), this.geometryFunction_(e, i, r)) : this.mode_ === "Polygon" && (e[0].pop(), this.geometryFunction_(e, i, r), e = i.getCoordinates()), this.type_ === "MultiPoint" ? t.setGeometry(new fr([e])) : this.type_ === "MultiLineString" ? t.setGeometry(new ui([e])) : this.type_ === "MultiPolygon" && t.setGeometry(new bi([e])), this.dispatchEvent(new e0(t0.DRAWEND, t)), this.features_ && this.features_.push(t), this.source_ && this.source_.addFeature(t), t;
        }
        abortDrawing_() {
          this.finishCoordinate_ = null;
          const t = this.sketchFeature_;
          return this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(true), this.deactivateTrace_(), t;
        }
        abortDrawing() {
          const t = this.abortDrawing_();
          t && this.dispatchEvent(new e0(t0.DRAWABORT, t));
        }
        appendCoordinates(t) {
          const e = this.mode_, i = !this.sketchFeature_;
          i && this.startDrawing_(t[0]);
          let r;
          if (e === "LineString" || e === "Circle") r = this.sketchCoords_;
          else if (e === "Polygon") r = this.sketchCoords_ && this.sketchCoords_.length ? this.sketchCoords_[0] : [];
          else return;
          i && r.shift(), r.pop();
          for (let o = 0; o < t.length; o++) this.addToDrawing_(t[o]);
          const a = t[t.length - 1];
          this.sketchFeature_ = this.addToDrawing_(a), this.modifyDrawing_(a);
        }
        extend(t) {
          const i = t.getGeometry();
          this.sketchFeature_ = t, this.sketchCoords_ = i.getCoordinates();
          const r = this.sketchCoords_[this.sketchCoords_.length - 1];
          this.finishCoordinate_ = r.slice(), this.sketchCoords_.push(r.slice()), this.sketchPoint_ = new Ce(new Ge(r)), this.updateSketchFeatures_(), this.dispatchEvent(new e0(t0.DRAWSTART, this.sketchFeature_));
        }
        updateSketchFeatures_() {
          const t = [];
          this.sketchFeature_ && t.push(this.sketchFeature_), this.sketchLine_ && t.push(this.sketchLine_), this.sketchPoint_ && t.push(this.sketchPoint_);
          const e = this.overlay_.getSource();
          e.clear(true), e.addFeatures(t);
        }
        updateState_() {
          const t = this.getMap(), e = this.getActive();
          (!t || !e) && this.abortDrawing(), this.overlay_.setMap(e ? t : null);
        }
      }
      function Met() {
        const n = $N();
        return function(t, e) {
          return n[t.getGeometry().getType()];
        };
      }
      function Det(n, t) {
        return function(e, i, r) {
          const a = ke(e[0]), o = ke(e[e.length - 1]), s = Math.sqrt(go(a, o));
          i = i || SN(new MA(a), n);
          let l = t;
          {
            const u = o[0] - a[0], h = o[1] - a[1];
            l = Math.atan2(h, u);
          }
          return bN(i, a, s, l), i;
        };
      }
      function Ret() {
        return function(n, t, e) {
          const i = Mn([n[0], n[n.length - 1]].map(function(a) {
            return ke(a);
          })), r = [[Wc(i), Xc(i), _l(i), ur(i), Wc(i)]];
          return t ? t.setCoordinates(r) : t = new Dn(r), t;
        };
      }
      function Let(n) {
        switch (n) {
          case "Point":
          case "MultiPoint":
            return "Point";
          case "LineString":
          case "MultiLineString":
            return "LineString";
          case "Polygon":
          case "MultiPolygon":
            return "Polygon";
          case "Circle":
            return "Circle";
          default:
            throw new Error("Invalid type: " + n);
        }
      }
      const tk = 0, LA = 1, ek = [0, 0, 0, 0], Sf = [], Ww = { MODIFYSTART: "modifystart", MODIFYEND: "modifyend" };
      class Xw extends Te {
        constructor(t, e, i) {
          super(t), this.features = e, this.mapBrowserEvent = i;
        }
      }
      class $w extends Bs {
        constructor(t) {
          super(t), this.on, this.once, this.un, this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this), this.condition_ = t.condition ? t.condition : VF, this.defaultDeleteCondition_ = function(i) {
            return oet(i) && cet(i);
          }, this.deleteCondition_ = t.deleteCondition ? t.deleteCondition : this.defaultDeleteCondition_, this.insertVertexCondition_ = t.insertVertexCondition ? t.insertVertexCondition : Km, this.vertexFeature_ = null, this.vertexSegments_ = null, this.lastPixel_ = [0, 0], this.ignoreNextSingleClick_ = false, this.featuresBeingModified_ = null, this.rBush_ = new Wm(), this.pixelTolerance_ = t.pixelTolerance !== void 0 ? t.pixelTolerance : 10, this.snappedToVertex_ = false, this.changingFeature_ = false, this.dragSegments_ = [], this.overlay_ = new aa({ source: new oa({ useSpatialIndex: false, wrapX: !!t.wrapX }), style: t.style ? t.style : Net(), updateWhileAnimating: true, updateWhileInteracting: true }), this.SEGMENT_WRITERS_ = { Point: this.writePointGeometry_.bind(this), LineString: this.writeLineStringGeometry_.bind(this), LinearRing: this.writeLineStringGeometry_.bind(this), Polygon: this.writePolygonGeometry_.bind(this), MultiPoint: this.writeMultiPointGeometry_.bind(this), MultiLineString: this.writeMultiLineStringGeometry_.bind(this), MultiPolygon: this.writeMultiPolygonGeometry_.bind(this), Circle: this.writeCircleGeometry_.bind(this), GeometryCollection: this.writeGeometryCollectionGeometry_.bind(this) }, this.source_ = null, this.hitDetection_ = null;
          let e;
          if (t.features ? e = t.features : t.source && (this.source_ = t.source, e = new lr(this.source_.getFeatures()), this.source_.addEventListener(An.ADDFEATURE, this.handleSourceAdd_.bind(this)), this.source_.addEventListener(An.REMOVEFEATURE, this.handleSourceRemove_.bind(this))), !e) throw new Error("The modify interaction requires features, a source or a layer");
          t.hitDetection && (this.hitDetection_ = t.hitDetection), this.features_ = e, this.features_.forEach(this.addFeature_.bind(this)), this.features_.addEventListener(ii.ADD, this.handleFeatureAdd_.bind(this)), this.features_.addEventListener(ii.REMOVE, this.handleFeatureRemove_.bind(this)), this.lastPointerEvent_ = null, this.delta_ = [0, 0], this.snapToPointer_ = t.snapToPointer === void 0 ? !this.hitDetection_ : t.snapToPointer;
        }
        addFeature_(t) {
          const e = t.getGeometry();
          if (e) {
            const r = this.SEGMENT_WRITERS_[e.getType()];
            r && r(t, e);
          }
          const i = this.getMap();
          i && i.isRendered() && this.getActive() && this.handlePointerAtPixel_(i.getCoordinateFromPixel(this.lastPixel_)), t.addEventListener(Rt.CHANGE, this.boundHandleFeatureChange_);
        }
        willModifyFeatures_(t, e) {
          if (!this.featuresBeingModified_) {
            this.featuresBeingModified_ = new lr();
            const i = this.featuresBeingModified_.getArray();
            for (let r = 0, a = e.length; r < a; ++r) {
              const o = e[r].feature;
              o && !i.includes(o) && this.featuresBeingModified_.push(o);
            }
            this.featuresBeingModified_.getLength() === 0 ? this.featuresBeingModified_ = null : this.dispatchEvent(new Xw(Ww.MODIFYSTART, this.featuresBeingModified_, t));
          }
        }
        removeFeature_(t) {
          this.removeFeatureSegmentData_(t), this.vertexFeature_ && this.features_.getLength() === 0 && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), t.removeEventListener(Rt.CHANGE, this.boundHandleFeatureChange_);
        }
        removeFeatureSegmentData_(t) {
          const e = this.rBush_, i = [];
          e.forEach(function(r) {
            t === r.feature && i.push(r);
          });
          for (let r = i.length - 1; r >= 0; --r) {
            const a = i[r];
            for (let o = this.dragSegments_.length - 1; o >= 0; --o) this.dragSegments_[o][0] === a && this.dragSegments_.splice(o, 1);
            e.remove(a);
          }
        }
        setActive(t) {
          this.vertexFeature_ && !t && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), super.setActive(t);
        }
        setMap(t) {
          this.overlay_.setMap(t), super.setMap(t);
        }
        getOverlay() {
          return this.overlay_;
        }
        handleSourceAdd_(t) {
          t.feature && this.features_.push(t.feature);
        }
        handleSourceRemove_(t) {
          t.feature && this.features_.remove(t.feature);
        }
        handleFeatureAdd_(t) {
          this.addFeature_(t.element);
        }
        handleFeatureChange_(t) {
          if (!this.changingFeature_) {
            const e = t.target;
            this.removeFeature_(e), this.addFeature_(e);
          }
        }
        handleFeatureRemove_(t) {
          this.removeFeature_(t.element);
        }
        writePointGeometry_(t, e) {
          const i = e.getCoordinates(), r = { feature: t, geometry: e, segment: [i, i] };
          this.rBush_.insert(e.getExtent(), r);
        }
        writeMultiPointGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r], s = { feature: t, geometry: e, depth: [r], index: r, segment: [o, o] };
            this.rBush_.insert(e.getExtent(), s);
          }
        }
        writeLineStringGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length - 1; r < a; ++r) {
            const o = i.slice(r, r + 2), s = { feature: t, geometry: e, index: r, segment: o };
            this.rBush_.insert(Mn(o), s);
          }
        }
        writeMultiLineStringGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r];
            for (let s = 0, l = o.length - 1; s < l; ++s) {
              const u = o.slice(s, s + 2), h = { feature: t, geometry: e, depth: [r], index: s, segment: u };
              this.rBush_.insert(Mn(u), h);
            }
          }
        }
        writePolygonGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r];
            for (let s = 0, l = o.length - 1; s < l; ++s) {
              const u = o.slice(s, s + 2), h = { feature: t, geometry: e, depth: [r], index: s, segment: u };
              this.rBush_.insert(Mn(u), h);
            }
          }
        }
        writeMultiPolygonGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r];
            for (let s = 0, l = o.length; s < l; ++s) {
              const u = o[s];
              for (let h = 0, c = u.length - 1; h < c; ++h) {
                const f = u.slice(h, h + 2), g = { feature: t, geometry: e, depth: [s, r], index: h, segment: f };
                this.rBush_.insert(Mn(f), g);
              }
            }
          }
        }
        writeCircleGeometry_(t, e) {
          const i = e.getCenter(), r = { feature: t, geometry: e, index: tk, segment: [i, i] }, a = { feature: t, geometry: e, index: LA, segment: [i, i] }, o = [r, a];
          r.featureSegments = o, a.featureSegments = o, this.rBush_.insert(Yc(i), r);
          let s = e;
          this.rBush_.insert(s.getExtent(), a);
        }
        writeGeometryCollectionGeometry_(t, e) {
          const i = e.getGeometriesArray();
          for (let r = 0; r < i.length; ++r) {
            const a = i[r], o = this.SEGMENT_WRITERS_[a.getType()];
            o(t, a);
          }
        }
        createOrUpdateVertexFeature_(t, e, i, r) {
          let a = this.vertexFeature_;
          return a ? a.getGeometry().setCoordinates(t) : (a = new Ce(new Ge(t)), this.vertexFeature_ = a, this.overlay_.getSource().addFeature(a)), a.set("features", e), a.set("geometries", i), a.set("existing", r), a;
        }
        handleEvent(t) {
          if (!t.originalEvent) return true;
          this.lastPointerEvent_ = t;
          let e;
          return !t.map.getView().getInteracting() && t.type == Me.POINTERMOVE && !this.handlingDownUpSequence && this.handlePointerMove_(t), this.vertexFeature_ && this.deleteCondition_(t) && (t.type != Me.SINGLECLICK || !this.ignoreNextSingleClick_ ? e = this.removePoint() : e = true), t.type == Me.SINGLECLICK && (this.ignoreNextSingleClick_ = false), super.handleEvent(t) && !e;
        }
        findInsertVerticesAndUpdateDragSegments_(t) {
          this.handlePointerAtPixel_(t), this.dragSegments_.length = 0, this.featuresBeingModified_ = null;
          const e = this.vertexFeature_;
          if (!e) return;
          this.getMap().getView().getProjection();
          const i = [], r = e.getGeometry().getCoordinates(), a = Mn([r]), o = this.rBush_.getInExtent(a), s = {};
          o.sort(Pet);
          for (let l = 0, u = o.length; l < u; ++l) {
            const h = o[l], c = h.segment;
            let f = xt(h.geometry);
            const g = h.depth;
            if (g && (f += "-" + g.join("-")), s[f] || (s[f] = new Array(2)), h.geometry.getType() === "Circle" && h.index === LA) {
              const d = ik(t, h);
              Qi(d, r) && !s[f][0] && (this.dragSegments_.push([h, 0]), s[f][0] = h);
              continue;
            }
            if (Qi(c[0], r) && !s[f][0]) {
              this.dragSegments_.push([h, 0]), s[f][0] = h;
              continue;
            }
            if (Qi(c[1], r) && !s[f][1]) {
              if (s[f][0] && s[f][0].index === 0) {
                let d = h.geometry.getCoordinates();
                switch (h.geometry.getType()) {
                  case "LineString":
                  case "MultiLineString":
                    continue;
                  case "MultiPolygon":
                    d = d[g[1]];
                  case "Polygon":
                    if (h.index !== d[g[0]].length - 2) continue;
                    break;
                }
              }
              this.dragSegments_.push([h, 1]), s[f][1] = h;
              continue;
            }
            xt(c) in this.vertexSegments_ && !s[f][0] && !s[f][1] && i.push(h);
          }
          return i;
        }
        handleDragEvent(t) {
          this.ignoreNextSingleClick_ = false, this.willModifyFeatures_(t, this.dragSegments_.map(([a]) => a));
          const e = [t.coordinate[0] + this.delta_[0], t.coordinate[1] + this.delta_[1]], i = [], r = [];
          for (let a = 0, o = this.dragSegments_.length; a < o; ++a) {
            const s = this.dragSegments_[a], l = s[0], u = l.feature;
            i.includes(u) || i.push(u);
            const h = l.geometry;
            r.includes(h) || r.push(h);
            const c = l.depth;
            let f;
            const g = l.segment, d = s[1];
            for (; e.length < h.getStride(); ) e.push(g[d][e.length]);
            switch (h.getType()) {
              case "Point":
                f = e, g[0] = e, g[1] = e;
                break;
              case "MultiPoint":
                f = h.getCoordinates(), f[l.index] = e, g[0] = e, g[1] = e;
                break;
              case "LineString":
                f = h.getCoordinates(), f[l.index + d] = e, g[d] = e;
                break;
              case "MultiLineString":
                f = h.getCoordinates(), f[c[0]][l.index + d] = e, g[d] = e;
                break;
              case "Polygon":
                f = h.getCoordinates(), f[c[0]][l.index + d] = e, g[d] = e;
                break;
              case "MultiPolygon":
                f = h.getCoordinates(), f[c[1]][c[0]][l.index + d] = e, g[d] = e;
                break;
              case "Circle":
                const A = h;
                if (g[0] = e, g[1] = e, l.index === tk) this.changingFeature_ = true, A.setCenter(e), this.changingFeature_ = false;
                else {
                  this.changingFeature_ = true, t.map.getView().getProjection();
                  let p = Am(ke(A.getCenter()), ke(e));
                  A.setRadius(p), this.changingFeature_ = false;
                }
                break;
            }
            f && this.setGeometryCoordinates_(h, f);
          }
          this.createOrUpdateVertexFeature_(e, i, r, true);
        }
        handleDownEvent(t) {
          if (!this.condition_(t)) return false;
          const e = t.coordinate, i = this.findInsertVerticesAndUpdateDragSegments_(e);
          if (i != null && i.length && this.insertVertexCondition_(t) && (this.willModifyFeatures_(t, i), this.vertexFeature_)) {
            const r = this.vertexFeature_.getGeometry().getCoordinates();
            for (let a = i.length - 1; a >= 0; --a) this.insertVertex_(i[a], r);
            this.ignoreNextSingleClick_ = true;
          }
          return !!this.vertexFeature_;
        }
        handleUpEvent(t) {
          for (let e = this.dragSegments_.length - 1; e >= 0; --e) {
            const i = this.dragSegments_[e][0], r = i.geometry;
            if (r.getType() === "Circle") {
              const a = r, o = a.getCenter(), s = i.featureSegments[0], l = i.featureSegments[1];
              s.segment[0] = o, s.segment[1] = o, l.segment[0] = o, l.segment[1] = o, this.rBush_.update(Yc(o), s);
              let u = a;
              this.rBush_.update(u.getExtent(), l);
            } else this.rBush_.update(Mn(i.segment), i);
          }
          return this.featuresBeingModified_ && (this.dispatchEvent(new Xw(Ww.MODIFYEND, this.featuresBeingModified_, t)), this.featuresBeingModified_ = null), false;
        }
        handlePointerMove_(t) {
          this.lastPixel_ = t.pixel, this.handlePointerAtPixel_(t.coordinate);
        }
        handlePointerAtPixel_(t) {
          const e = this.getMap(), i = e.getPixelFromCoordinate(t);
          e.getView().getProjection();
          const r = function(s, l) {
            return nk(t, s) - nk(t, l);
          };
          let a, o;
          if (this.hitDetection_) {
            const s = typeof this.hitDetection_ == "object" ? (l) => l === this.hitDetection_ : void 0;
            e.forEachFeatureAtPixel(i, (l, u, h) => {
              h && h.getType() === "Point" && (h = new Ge(vo(h.getCoordinates())));
              const c = h || l.getGeometry();
              if (c && c.getType() === "Point" && l instanceof Ce && this.features_.getArray().includes(l)) {
                o = c;
                const f = l.getGeometry().getFlatCoordinates().slice(0, 2);
                a = [{ feature: l, geometry: o, segment: [f, f] }];
              }
              return true;
            }, { layerFilter: s });
          }
          if (!a) {
            const s = zi(Yc(t, ek)), l = e.getView().getResolution() * this.pixelTolerance_, u = sA(fo(s, l, ek));
            a = this.rBush_.getInExtent(u);
          }
          if (a && a.length > 0) {
            const s = a.sort(r)[0], l = s.segment;
            let u = ik(t, s);
            const h = e.getPixelFromCoordinate(u);
            let c = Am(i, h);
            if (o || c <= this.pixelTolerance_) {
              const f = {};
              if (f[xt(l)] = true, this.snapToPointer_ || (this.delta_[0] = u[0] - t[0], this.delta_[1] = u[1] - t[1]), s.geometry.getType() === "Circle" && s.index === LA) this.snappedToVertex_ = true, this.createOrUpdateVertexFeature_(u, [s.feature], [s.geometry], this.snappedToVertex_);
              else {
                const g = e.getPixelFromCoordinate(l[0]), d = e.getPixelFromCoordinate(l[1]), A = go(h, g), p = go(h, d);
                c = Math.sqrt(Math.min(A, p)), this.snappedToVertex_ = c <= this.pixelTolerance_, this.snappedToVertex_ && (u = A > p ? l[1] : l[0]), this.createOrUpdateVertexFeature_(u, [s.feature], [s.geometry], this.snappedToVertex_);
                const v = {};
                v[xt(s.geometry)] = true;
                for (let y = 1, m = a.length; y < m; ++y) {
                  const _ = a[y].segment;
                  if (Qi(l[0], _[0]) && Qi(l[1], _[1]) || Qi(l[0], _[1]) && Qi(l[1], _[0])) {
                    const I = xt(a[y].geometry);
                    I in v || (v[I] = true, f[xt(_)] = true);
                  } else break;
                }
              }
              this.vertexSegments_ = f;
              return;
            }
          }
          this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null);
        }
        insertVertex_(t, e) {
          const i = t.segment, r = t.feature, a = t.geometry, o = t.depth, s = t.index;
          let l;
          for (; e.length < a.getStride(); ) e.push(0);
          switch (a.getType()) {
            case "MultiLineString":
              l = a.getCoordinates(), l[o[0]].splice(s + 1, 0, e);
              break;
            case "Polygon":
              l = a.getCoordinates(), l[o[0]].splice(s + 1, 0, e);
              break;
            case "MultiPolygon":
              l = a.getCoordinates(), l[o[1]][o[0]].splice(s + 1, 0, e);
              break;
            case "LineString":
              l = a.getCoordinates(), l.splice(s + 1, 0, e);
              break;
            default:
              return false;
          }
          this.setGeometryCoordinates_(a, l);
          const u = this.rBush_;
          u.remove(t), this.updateSegmentIndices_(a, s, o, 1);
          const h = { segment: [i[0], e], feature: r, geometry: a, depth: o, index: s };
          u.insert(Mn(h.segment), h), this.dragSegments_.push([h, 1]);
          const c = { segment: [e, i[1]], feature: r, geometry: a, depth: o, index: s + 1 };
          return u.insert(Mn(c.segment), c), this.dragSegments_.push([c, 0]), true;
        }
        updatePointer_(t) {
          var e;
          return t && this.findInsertVerticesAndUpdateDragSegments_(t), (e = this.vertexFeature_) == null ? void 0 : e.getGeometry().getCoordinates();
        }
        getPoint() {
          var e;
          const t = (e = this.vertexFeature_) == null ? void 0 : e.getGeometry().getCoordinates();
          return t ? vo(t, this.getMap().getView().getProjection()) : null;
        }
        canRemovePoint() {
          if (!this.vertexFeature_ || this.vertexFeature_.get("geometries").every((i) => i.getType() === "Circle" || i.getType().endsWith("Point"))) return false;
          const t = this.vertexFeature_.getGeometry().getCoordinates();
          return this.rBush_.getInExtent(Mn([t])).some(({ segment: i }) => Qi(i[0], t) || Qi(i[1], t));
        }
        removePoint(t) {
          if (t && (t = ke(t, this.getMap().getView().getProjection()), this.updatePointer_(t)), !this.lastPointerEvent_ || this.lastPointerEvent_ && this.lastPointerEvent_.type != Me.POINTERDRAG) {
            const e = this.lastPointerEvent_;
            this.willModifyFeatures_(e, this.dragSegments_.map(([r]) => r));
            const i = this.removeVertex_();
            return this.featuresBeingModified_ && this.dispatchEvent(new Xw(Ww.MODIFYEND, this.featuresBeingModified_, e)), this.featuresBeingModified_ = null, i;
          }
          return false;
        }
        removeVertex_() {
          const t = this.dragSegments_, e = {};
          let i = false, r, a, o, s, l, u, h, c, f, g, d;
          for (l = t.length - 1; l >= 0; --l) o = t[l], g = o[0], d = xt(g.feature), g.depth && (d += "-" + g.depth.join("-")), d in e || (e[d] = {}), o[1] === 0 ? (e[d].right = g, e[d].index = g.index) : o[1] == 1 && (e[d].left = g, e[d].index = g.index + 1);
          for (d in e) {
            switch (f = e[d].right, h = e[d].left, u = e[d].index, c = u - 1, h !== void 0 ? g = h : g = f, c < 0 && (c = 0), s = g.geometry, a = s.getCoordinates(), r = a, i = false, s.getType()) {
              case "MultiLineString":
                a[g.depth[0]].length > 2 && (a[g.depth[0]].splice(u, 1), i = true);
                break;
              case "LineString":
                a.length > 2 && (a.splice(u, 1), i = true);
                break;
              case "MultiPolygon":
                r = r[g.depth[1]];
              case "Polygon":
                r = r[g.depth[0]], r.length > 4 && (u == r.length - 1 && (u = 0), r.splice(u, 1), i = true, u === 0 && (r.pop(), r.push(r[0]), c = r.length - 1));
                break;
            }
            if (i) {
              this.setGeometryCoordinates_(s, a);
              const A = [];
              if (h !== void 0 && (this.rBush_.remove(h), A.push(h.segment[0])), f !== void 0 && (this.rBush_.remove(f), A.push(f.segment[1])), h !== void 0 && f !== void 0) {
                const p = { depth: g.depth, feature: g.feature, geometry: g.geometry, index: c, segment: A };
                this.rBush_.insert(Mn(p.segment), p);
              }
              this.updateSegmentIndices_(s, u, g.depth, -1), this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), t.length = 0;
            }
          }
          return i;
        }
        canInsertPoint() {
          if (!this.vertexFeature_ || this.vertexFeature_.get("geometries").every((i) => i.getType() === "Circle" || i.getType().endsWith("Point"))) return false;
          const t = this.vertexFeature_.getGeometry().getCoordinates();
          return this.rBush_.getInExtent(Mn([t])).some(({ segment: i }) => !(Qi(i[0], t) || Qi(i[1], t)));
        }
        insertPoint(t) {
          var r;
          const e = t ? ke(t, this.getMap().getView().getProjection()) : (r = this.vertexFeature_) == null ? void 0 : r.getGeometry().getCoordinates();
          return e ? this.findInsertVerticesAndUpdateDragSegments_(e).reduce((a, o) => a || this.insertVertex_(o, e), false) : false;
        }
        setGeometryCoordinates_(t, e) {
          this.changingFeature_ = true, t.setCoordinates(e), this.changingFeature_ = false;
        }
        updateSegmentIndices_(t, e, i, r) {
          this.rBush_.forEachInExtent(t.getExtent(), function(a) {
            a.geometry === t && (i === void 0 || a.depth === void 0 || co(a.depth, i)) && a.index > e && (a.index += r);
          });
        }
      }
      function Pet(n, t) {
        return n.index - t.index;
      }
      function nk(n, t, e) {
        const i = t.geometry;
        if (i.getType() === "Circle") {
          let a = i;
          if (t.index === LA) {
            const o = go(a.getCenter(), ke(n)), s = Math.sqrt(o) - a.getRadius();
            return s * s;
          }
        }
        const r = ke(n);
        return Sf[0] = ke(t.segment[0]), Sf[1] = ke(t.segment[1]), nK(r, Sf);
      }
      function ik(n, t, e) {
        const i = t.geometry;
        if (i.getType() === "Circle" && t.index === LA) return vo(i.getClosestPoint(ke(n)));
        const r = ke(n);
        return Sf[0] = ke(t.segment[0]), Sf[1] = ke(t.segment[1]), vo(Rx(r, Sf));
      }
      function Net() {
        const n = $N();
        return function(t, e) {
          return n.Point;
        };
      }
      const Fet = { SNAP: "snap" };
      class ket extends Te {
        constructor(t, e) {
          super(t), this.vertex = e.vertex, this.vertexPixel = e.vertexPixel, this.feature = e.feature, this.segment = e.segment;
        }
      }
      function rk(n) {
        return n.feature ? n.feature : n.element ? n.element : null;
      }
      const Zw = [];
      class Oet extends Bs {
        constructor(t) {
          t = t || {};
          const e = t;
          e.handleDownEvent || (e.handleDownEvent = Fu), e.stopDown || (e.stopDown = ku), super(e), this.on, this.once, this.un, this.source_ = t.source ? t.source : null, this.vertex_ = t.vertex !== void 0 ? t.vertex : true, this.edge_ = t.edge !== void 0 ? t.edge : true, this.features_ = t.features ? t.features : null, this.featuresListenerKeys_ = [], this.featureChangeListenerKeys_ = {}, this.indexedFeaturesExtents_ = {}, this.pendingFeatures_ = {}, this.pixelTolerance_ = t.pixelTolerance !== void 0 ? t.pixelTolerance : 10, this.rBush_ = new Wm(), this.GEOMETRY_SEGMENTERS_ = { Point: this.segmentPointGeometry_.bind(this), LineString: this.segmentLineStringGeometry_.bind(this), LinearRing: this.segmentLineStringGeometry_.bind(this), Polygon: this.segmentPolygonGeometry_.bind(this), MultiPoint: this.segmentMultiPointGeometry_.bind(this), MultiLineString: this.segmentMultiLineStringGeometry_.bind(this), MultiPolygon: this.segmentMultiPolygonGeometry_.bind(this), GeometryCollection: this.segmentGeometryCollectionGeometry_.bind(this), Circle: this.segmentCircleGeometry_.bind(this) };
        }
        addFeature(t, e) {
          e = e !== void 0 ? e : true;
          const i = xt(t), r = t.getGeometry();
          if (r) {
            const a = this.GEOMETRY_SEGMENTERS_[r.getType()];
            if (a) {
              this.indexedFeaturesExtents_[i] = r.getExtent(ai());
              const o = [];
              if (a(o, r), o.length === 1) this.rBush_.insert(Mn(o[0]), { feature: t, segment: o[0] });
              else if (o.length > 1) {
                const s = o.map((u) => Mn(u)), l = o.map((u) => ({ feature: t, segment: u }));
                this.rBush_.load(s, l);
              }
            }
          }
          e && (this.featureChangeListenerKeys_[i] = Ut(t, Rt.CHANGE, this.handleFeatureChange_, this));
        }
        getFeatures_() {
          let t;
          return this.features_ ? t = this.features_ : this.source_ && (t = this.source_.getFeatures()), t;
        }
        handleEvent(t) {
          const e = this.snapTo(t.pixel, t.coordinate, t.map);
          return e && (t.coordinate = e.vertex.slice(0, 2), t.pixel = e.vertexPixel, this.dispatchEvent(new ket(Fet.SNAP, { vertex: t.coordinate, vertexPixel: t.pixel, feature: e.feature, segment: e.segment }))), super.handleEvent(t);
        }
        handleFeatureAdd_(t) {
          const e = rk(t);
          e && this.addFeature(e);
        }
        handleFeatureRemove_(t) {
          const e = rk(t);
          e && this.removeFeature(e);
        }
        handleFeatureChange_(t) {
          const e = t.target;
          if (this.handlingDownUpSequence) {
            const i = xt(e);
            i in this.pendingFeatures_ || (this.pendingFeatures_[i] = e);
          } else this.updateFeature_(e);
        }
        handleUpEvent(t) {
          const e = Object.values(this.pendingFeatures_);
          return e.length && (e.forEach(this.updateFeature_.bind(this)), this.pendingFeatures_ = {}), false;
        }
        removeFeature(t, e) {
          const i = e !== void 0 ? e : true, r = xt(t), a = this.indexedFeaturesExtents_[r];
          if (a) {
            const o = this.rBush_, s = [];
            o.forEachInExtent(a, function(l) {
              t === l.feature && s.push(l);
            });
            for (let l = s.length - 1; l >= 0; --l) o.remove(s[l]);
          }
          i && (we(this.featureChangeListenerKeys_[r]), delete this.featureChangeListenerKeys_[r]);
        }
        setMap(t) {
          const e = this.getMap(), i = this.featuresListenerKeys_, r = this.getFeatures_();
          e && (i.forEach(we), i.length = 0, this.rBush_.clear(), Object.values(this.featureChangeListenerKeys_).forEach(we), this.featureChangeListenerKeys_ = {}), super.setMap(t), t && (this.features_ ? i.push(Ut(this.features_, ii.ADD, this.handleFeatureAdd_, this), Ut(this.features_, ii.REMOVE, this.handleFeatureRemove_, this)) : this.source_ && i.push(Ut(this.source_, An.ADDFEATURE, this.handleFeatureAdd_, this), Ut(this.source_, An.REMOVEFEATURE, this.handleFeatureRemove_, this)), r.forEach((a) => this.addFeature(a)));
        }
        snapTo(t, e, i) {
          i.getView().getProjection();
          const r = ke(e), a = sA(fo(Mn([r]), i.getView().getResolution() * this.pixelTolerance_)), o = this.rBush_.getInExtent(a), s = o.length;
          if (s === 0) return null;
          let l, u = 1 / 0, h, c = null;
          const f = this.pixelTolerance_ * this.pixelTolerance_, g = () => {
            if (l) {
              const d = i.getPixelFromCoordinate(l);
              if (go(t, d) <= f) return { vertex: l, vertexPixel: [Math.round(d[0]), Math.round(d[1])], feature: h, segment: c };
            }
            return null;
          };
          if (this.vertex_) {
            for (let A = 0; A < s; ++A) {
              const p = o[A];
              p.feature.getGeometry().getType() !== "Circle" && p.segment.forEach((v) => {
                const y = ke(v), m = go(r, y);
                m < u && (l = v, u = m, h = p.feature);
              });
            }
            const d = g();
            if (d) return d;
          }
          if (this.edge_) {
            for (let A = 0; A < s; ++A) {
              let p = null;
              const v = o[A];
              if (v.feature.getGeometry().getType() === "Circle") {
                let y = v.feature.getGeometry();
                p = JZ(r, y);
              } else {
                const [y, m] = v.segment;
                m && (Zw[0] = ke(y), Zw[1] = ke(m), p = Rx(r, Zw));
              }
              if (p) {
                const y = go(r, p);
                y < u && (l = vo(p), c = v.feature.getGeometry().getType() === "Circle" ? null : v.segment, u = y, h = v.feature);
              }
            }
            const d = g();
            if (d) return d;
          }
          return null;
        }
        updateFeature_(t) {
          this.removeFeature(t, false), this.addFeature(t, false);
        }
        segmentCircleGeometry_(t, e) {
          this.getMap().getView().getProjection();
          const a = SN(e).getCoordinates()[0];
          for (let o = 0, s = a.length - 1; o < s; ++o) t.push(a.slice(o, o + 2));
        }
        segmentGeometryCollectionGeometry_(t, e) {
          const i = e.getGeometriesArray();
          for (let r = 0; r < i.length; ++r) {
            const a = this.GEOMETRY_SEGMENTERS_[i[r].getType()];
            a && a(t, i[r]);
          }
        }
        segmentLineStringGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length - 1; r < a; ++r) t.push(i.slice(r, r + 2));
        }
        segmentMultiLineStringGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r];
            for (let s = 0, l = o.length - 1; s < l; ++s) t.push(o.slice(s, s + 2));
          }
        }
        segmentMultiPointGeometry_(t, e) {
          e.getCoordinates().forEach((i) => {
            t.push([i]);
          });
        }
        segmentMultiPolygonGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r];
            for (let s = 0, l = o.length; s < l; ++s) {
              const u = o[s];
              for (let h = 0, c = u.length - 1; h < c; ++h) t.push(u.slice(h, h + 2));
            }
          }
        }
        segmentPointGeometry_(t, e) {
          t.push([e.getCoordinates()]);
        }
        segmentPolygonGeometry_(t, e) {
          const i = e.getCoordinates();
          for (let r = 0, a = i.length; r < a; ++r) {
            const o = i[r];
            for (let s = 0, l = o.length - 1; s < l; ++s) t.push(o.slice(s, s + 2));
          }
        }
      }
      const ak = ["fullscreenchange", "webkitfullscreenchange", "MSFullscreenChange"], ok = { ENTERFULLSCREEN: "enterfullscreen", LEAVEFULLSCREEN: "leavefullscreen" };
      class Qet extends Bl {
        constructor(t) {
          t = t || {}, super({ element: document.createElement("div"), target: t.target }), this.on, this.once, this.un, this.keys_ = t.keys !== void 0 ? t.keys : false, this.source_ = t.source, this.isInFullscreen_ = false, this.boundHandleMapTargetChange_ = this.handleMapTargetChange_.bind(this), this.cssClassName_ = t.className !== void 0 ? t.className : "ol-full-screen", this.documentListeners_ = [], this.activeClassName_ = t.activeClassName !== void 0 ? t.activeClassName.split(" ") : [this.cssClassName_ + "-true"], this.inactiveClassName_ = t.inactiveClassName !== void 0 ? t.inactiveClassName.split(" ") : [this.cssClassName_ + "-false"];
          const e = t.label !== void 0 ? t.label : "";
          this.labelNode_ = typeof e == "string" ? document.createTextNode(e) : e;
          const i = t.labelActive !== void 0 ? t.labelActive : "";
          this.labelActiveNode_ = typeof i == "string" ? document.createTextNode(i) : i;
          const r = t.tipLabel ? t.tipLabel : "Toggle full-screen";
          this.button_ = document.createElement("button"), this.button_.title = r, this.button_.setAttribute("type", "button"), this.button_.appendChild(this.labelNode_), this.button_.addEventListener(Rt.CLICK, this.handleClick_.bind(this), false), this.setClassName_(this.button_, this.isInFullscreen_), this.element.className = `${this.cssClassName_} ${_s} ${of}`, this.element.appendChild(this.button_);
        }
        handleClick_(t) {
          t.preventDefault(), this.handleFullScreen_();
        }
        handleFullScreen_() {
          const t = this.getMap();
          if (!t) return;
          const e = t.getOwnerDocument();
          if (sk(e)) if (lk(e)) Get(e);
          else {
            let i;
            this.source_ ? i = typeof this.source_ == "string" ? e.getElementById(this.source_) : this.source_ : i = t.getTargetElement(), this.keys_ ? zet(i) : uk(i);
          }
        }
        handleFullScreenChange_() {
          const t = this.getMap();
          if (!t) return;
          const e = this.isInFullscreen_;
          this.isInFullscreen_ = lk(t.getOwnerDocument()), e !== this.isInFullscreen_ && (this.setClassName_(this.button_, this.isInFullscreen_), this.isInFullscreen_ ? (af(this.labelActiveNode_, this.labelNode_), this.dispatchEvent(ok.ENTERFULLSCREEN)) : (af(this.labelNode_, this.labelActiveNode_), this.dispatchEvent(ok.LEAVEFULLSCREEN)), t.updateSize());
        }
        setClassName_(t, e) {
          e ? (t.classList.remove(...this.inactiveClassName_), t.classList.add(...this.activeClassName_)) : (t.classList.remove(...this.activeClassName_), t.classList.add(...this.inactiveClassName_));
        }
        setMap(t) {
          const e = this.getMap();
          e && e.removeChangeListener(Ln.TARGET, this.boundHandleMapTargetChange_), super.setMap(t), this.handleMapTargetChange_(), t && t.addChangeListener(Ln.TARGET, this.boundHandleMapTargetChange_);
        }
        handleMapTargetChange_() {
          const t = this.documentListeners_;
          for (let i = 0, r = t.length; i < r; ++i) we(t[i]);
          t.length = 0;
          const e = this.getMap();
          if (e) {
            const i = e.getOwnerDocument();
            sk(i) ? this.element.classList.remove(VN) : this.element.classList.add(VN);
            for (let r = 0, a = ak.length; r < a; ++r) t.push(Ut(i, ak[r], this.handleFullScreenChange_, this));
            this.handleFullScreenChange_();
          }
        }
      }
      function sk(n) {
        const t = n.body;
        return !!(t.webkitRequestFullscreen || t.requestFullscreen && n.fullscreenEnabled);
      }
      function lk(n) {
        return !!(n.webkitIsFullScreen || n.fullscreenElement);
      }
      function uk(n) {
        n.requestFullscreen ? n.requestFullscreen() : n.webkitRequestFullscreen && n.webkitRequestFullscreen();
      }
      function zet(n) {
        n.webkitRequestFullscreen ? n.webkitRequestFullscreen() : uk(n);
      }
      function Get(n) {
        n.exitFullscreen ? n.exitFullscreen() : n.webkitExitFullscreen && n.webkitExitFullscreen();
      }
      const Kw = "projection", hk = "coordinateFormat";
      class Uet extends Bl {
        constructor(t) {
          t = t || {};
          const e = document.createElement("div");
          e.className = t.className !== void 0 ? t.className : "ol-mouse-position", super({ element: e, render: t.render, target: t.target }), this.on, this.once, this.un, this.addChangeListener(Kw, this.handleProjectionChanged_), t.coordinateFormat && this.setCoordinateFormat(t.coordinateFormat), t.projection && this.setProjection(t.projection), this.renderOnMouseOut_ = t.placeholder !== void 0, this.placeholder_ = this.renderOnMouseOut_ ? t.placeholder : "&#160;", this.renderedHTML_ = e.innerHTML, this.mapProjection_ = null, this.transform_ = null, this.wrapX_ = t.wrapX !== false;
        }
        handleProjectionChanged_() {
          this.transform_ = null;
        }
        getCoordinateFormat() {
          return this.get(hk);
        }
        getProjection() {
          return this.get(Kw);
        }
        handleMouseMove(t) {
          const e = this.getMap();
          this.updateHTML_(e.getEventPixel(t));
        }
        handleMouseOut(t) {
          this.updateHTML_(null);
        }
        setMap(t) {
          if (super.setMap(t), t) {
            const e = t.getViewport();
            this.listenerKeys.push(Ut(e, Io.POINTERMOVE, this.handleMouseMove, this)), this.renderOnMouseOut_ && this.listenerKeys.push(Ut(e, Io.POINTEROUT, this.handleMouseOut, this)), this.updateHTML_(null);
          }
        }
        setCoordinateFormat(t) {
          this.set(hk, t);
        }
        setProjection(t) {
          this.set(Kw, qt(t));
        }
        updateHTML_(t) {
          let e = this.placeholder_;
          if (t && this.mapProjection_) {
            if (!this.transform_) {
              const a = this.getProjection();
              a ? this.transform_ = xm(this.mapProjection_, a) : this.transform_ = _K;
            }
            const r = this.getMap().getCoordinateFromPixelInternal(t);
            if (r) {
              if (this.transform_(r, r), this.wrapX_) {
                const o = this.getProjection() || this.mapProjection_;
                Px(r, o);
              }
              const a = this.getCoordinateFormat();
              a ? e = a(r) : e = r.toString();
            }
          }
          (!this.renderedHTML_ || e !== this.renderedHTML_) && (this.element.innerHTML = e, this.renderedHTML_ = e);
        }
        render(t) {
          const e = t.frameState;
          e ? this.mapProjection_ != e.viewState.projection && (this.mapProjection_ = e.viewState.projection, this.transform_ = null) : this.mapProjection_ = null;
        }
      }
      const Jw = 0.75, a0 = 0.1;
      class Vet extends Bl {
        constructor(t) {
          t = t || {}, super({ element: document.createElement("div"), render: t.render, target: t.target }), this.boundHandleRotationChanged_ = this.handleRotationChanged_.bind(this), this.collapsed_ = t.collapsed !== void 0 ? t.collapsed : true, this.collapsible_ = t.collapsible !== void 0 ? t.collapsible : true, this.collapsible_ || (this.collapsed_ = false), this.rotateWithView_ = t.rotateWithView !== void 0 ? t.rotateWithView : false, this.viewExtent_ = void 0;
          const e = t.className !== void 0 ? t.className : "ol-overviewmap", i = t.tipLabel !== void 0 ? t.tipLabel : "Overview map", r = t.collapseLabel !== void 0 ? t.collapseLabel : "";
          typeof r == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = r) : this.collapseLabel_ = r;
          const a = t.label !== void 0 ? t.label : "";
          typeof a == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = a) : this.label_ = a;
          const o = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_, s = document.createElement("button");
          s.setAttribute("type", "button"), s.title = i, s.appendChild(o), s.addEventListener(Rt.CLICK, this.handleClick_.bind(this), false), this.ovmapDiv_ = document.createElement("div"), this.ovmapDiv_.className = "ol-overviewmap-map", this.view_ = t.view;
          const l = new qw({ view: t.view, controls: new lr(), interactions: new lr() });
          this.ovmap_ = l, t.layers && t.layers.forEach(function(y) {
            l.addLayer(y);
          });
          const u = document.createElement("div");
          u.className = "ol-overviewmap-box", u.style.boxSizing = "border-box", this.boxOverlay_ = new YF({ position: [0, 0], positioning: "center-center", element: u }), this.ovmap_.addOverlay(this.boxOverlay_);
          const h = e + " " + _s + " " + of + (this.collapsed_ && this.collapsible_ ? " " + Pm : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), c = this.element;
          c.className = h, c.appendChild(this.ovmapDiv_), c.appendChild(s);
          const f = this, g = this.boxOverlay_, d = this.boxOverlay_.getElement(), A = function(y) {
            return { clientX: y.clientX, clientY: y.clientY };
          }, p = function(y) {
            const m = A(y), _ = l.getEventCoordinate(m);
            g.setPosition(_);
          }, v = function(y) {
            const m = l.getEventCoordinateInternal(y);
            f.getMap().getView().setCenterInternal(m), window.removeEventListener("pointermove", p), window.removeEventListener("pointerup", v);
          };
          this.ovmapDiv_.addEventListener("pointerdown", function() {
            event.target === d && window.addEventListener("pointermove", p), window.addEventListener("pointerup", v);
          });
        }
        setMap(t) {
          const e = this.getMap();
          if (t !== e) {
            if (e) {
              const i = e.getView();
              i && this.unbindView_(i), this.ovmap_.setTarget(null);
            }
            if (super.setMap(t), t) {
              this.ovmap_.setTarget(this.ovmapDiv_), this.listenerKeys.push(Ut(t, uo.PROPERTYCHANGE, this.handleMapPropertyChange_, this));
              const i = t.getView();
              i && this.bindView_(i), this.ovmap_.isRendered() || this.updateBoxAfterOvmapIsRendered_();
            }
          }
        }
        handleMapPropertyChange_(t) {
          if (t.key === Ln.VIEW) {
            const e = t.oldValue;
            e && this.unbindView_(e);
            const i = this.getMap().getView();
            this.bindView_(i);
          } else !this.ovmap_.isRendered() && (t.key === Ln.TARGET || t.key === Ln.SIZE) && this.ovmap_.updateSize();
        }
        bindView_(t) {
          if (!this.view_) {
            const e = new Qa({ projection: t.getProjection() });
            this.ovmap_.setView(e);
          }
          t.addChangeListener(Or.ROTATION, this.boundHandleRotationChanged_), this.handleRotationChanged_(), t.isDef() && (this.ovmap_.updateSize(), this.resetExtent_());
        }
        unbindView_(t) {
          t.removeChangeListener(Or.ROTATION, this.boundHandleRotationChanged_);
        }
        handleRotationChanged_() {
          this.rotateWithView_ && this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
        }
        validateExtent_() {
          const t = this.getMap(), e = this.ovmap_;
          if (!t.isRendered() || !e.isRendered()) return;
          const i = t.getSize(), a = t.getView().calculateExtentInternal(i);
          if (this.viewExtent_ && As(a, this.viewExtent_)) return;
          this.viewExtent_ = a;
          const o = e.getSize(), l = e.getView().calculateExtentInternal(o), u = e.getPixelFromCoordinateInternal(ur(a)), h = e.getPixelFromCoordinateInternal(Xc(a)), c = Math.abs(u[0] - h[0]), f = Math.abs(u[1] - h[1]), g = o[0], d = o[1];
          c < g * a0 || f < d * a0 || c > g * Jw || f > d * Jw ? this.resetExtent_() : Pr(l, a) || this.recenter_();
        }
        resetExtent_() {
          const t = this.getMap(), e = this.ovmap_, i = t.getSize(), a = t.getView().calculateExtentInternal(i), o = e.getView(), s = Math.log(Jw / a0) / Math.LN2, l = 1 / (Math.pow(2, s / 2) * a0);
          GZ(a, l), o.fitInternal(nw(a));
        }
        recenter_() {
          const t = this.getMap(), e = this.ovmap_, i = t.getView();
          e.getView().setCenterInternal(i.getCenterInternal());
        }
        updateBox_() {
          const t = this.getMap(), e = this.ovmap_;
          if (!t.isRendered() || !e.isRendered()) return;
          const i = t.getSize(), r = t.getView(), a = e.getView(), o = this.rotateWithView_ ? 0 : -r.getRotation(), s = this.boxOverlay_, l = this.boxOverlay_.getElement(), u = r.getCenter(), h = r.getResolution(), c = a.getResolution(), f = i[0] * h / c, g = i[1] * h / c;
          if (s.setPosition(u), l) {
            l.style.width = f + "px", l.style.height = g + "px";
            const d = "rotate(" + o + "rad)";
            l.style.transform = d;
          }
        }
        updateBoxAfterOvmapIsRendered_() {
          this.ovmapPostrenderKey_ || (this.ovmapPostrenderKey_ = Kd(this.ovmap_, xo.POSTRENDER, (t) => {
            delete this.ovmapPostrenderKey_, this.updateBox_();
          }));
        }
        handleClick_(t) {
          t.preventDefault(), this.handleToggle_();
        }
        handleToggle_() {
          this.element.classList.toggle(Pm), this.collapsed_ ? af(this.collapseLabel_, this.label_) : af(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_;
          const t = this.ovmap_;
          if (!this.collapsed_) {
            if (t.isRendered()) {
              this.viewExtent_ = void 0, t.render();
              return;
            }
            t.updateSize(), this.resetExtent_(), this.updateBoxAfterOvmapIsRendered_();
          }
        }
        getCollapsible() {
          return this.collapsible_;
        }
        setCollapsible(t) {
          this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle("ol-uncollapsible"), !t && this.collapsed_ && this.handleToggle_());
        }
        setCollapsed(t) {
          !this.collapsible_ || this.collapsed_ === t || this.handleToggle_();
        }
        getCollapsed() {
          return this.collapsed_;
        }
        getRotateWithView() {
          return this.rotateWithView_;
        }
        setRotateWithView(t) {
          this.rotateWithView_ !== t && (this.rotateWithView_ = t, this.getMap().getView().getRotation() !== 0 && (this.rotateWithView_ ? this.handleRotationChanged_() : this.ovmap_.getView().setRotation(0), this.viewExtent_ = void 0, this.validateExtent_(), this.updateBox_()));
        }
        getOverviewMap() {
          return this.ovmap_;
        }
        render(t) {
          this.validateExtent_(), this.updateBox_();
        }
      }
      const tC = "units", jet = [1, 2, 5], PA = 25.4 / 0.28;
      class qet extends Bl {
        constructor(t) {
          t = t || {};
          const e = document.createElement("div");
          e.style.pointerEvents = "none", super({ element: e, render: t.render, target: t.target }), this.on, this.once, this.un;
          const i = t.className !== void 0 ? t.className : t.bar ? "ol-scale-bar" : "ol-scale-line";
          this.innerElement_ = document.createElement("div"), this.innerElement_.className = i + "-inner", this.element.className = i + " " + _s, this.element.appendChild(this.innerElement_), this.viewState_ = null, this.minWidth_ = t.minWidth !== void 0 ? t.minWidth : 64, this.maxWidth_ = t.maxWidth, this.renderedVisible_ = false, this.renderedWidth_ = void 0, this.renderedHTML_ = "", this.addChangeListener(tC, this.handleUnitsChanged_), this.setUnits(t.units || "metric"), this.scaleBar_ = t.bar || false, this.scaleBarSteps_ = t.steps || 4, this.scaleBarText_ = t.text || false, this.dpi_ = t.dpi || void 0;
        }
        getUnits() {
          return this.get(tC);
        }
        handleUnitsChanged_() {
          this.updateElement_();
        }
        setUnits(t) {
          this.set(tC, t);
        }
        setDpi(t) {
          this.dpi_ = t;
        }
        updateElement_() {
          const t = this.viewState_;
          if (!t) {
            this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = false);
            return;
          }
          const e = t.center, i = t.projection, r = this.getUnits(), a = r == "degrees" ? "degrees" : "m";
          let o = Em(i, t.resolution, e, a);
          const s = this.minWidth_ * (this.dpi_ || PA) / PA, l = this.maxWidth_ !== void 0 ? this.maxWidth_ * (this.dpi_ || PA) / PA : void 0;
          let u = s * o, h = "";
          if (r == "degrees") {
            const m = $c.degrees;
            u *= m, u < m / 60 ? (h = "", o *= 3600) : u < m ? (h = "", o *= 60) : h = "";
          } else if (r == "imperial") u < 0.9144 ? (h = "in", o /= 0.0254) : u < 1609.344 ? (h = "ft", o /= 0.3048) : (h = "mi", o /= 1609.344);
          else if (r == "nautical") o /= 1852, h = "NM";
          else if (r == "metric") u < 1e-6 ? (h = "nm", o *= 1e9) : u < 1e-3 ? (h = "m", o *= 1e6) : u < 1 ? (h = "mm", o *= 1e3) : u < 1e3 ? h = "m" : (h = "km", o /= 1e3);
          else if (r == "us") u < 0.9144 ? (h = "in", o *= 39.37) : u < 1609.344 ? (h = "ft", o /= 0.30480061) : (h = "mi", o /= 1609.3472);
          else throw new Error("Invalid units");
          let c = 3 * Math.floor(Math.log(s * o) / Math.log(10)), f, g, d, A, p, v;
          for (; ; ) {
            d = Math.floor(c / 3);
            const m = Math.pow(10, d);
            if (f = jet[(c % 3 + 3) % 3] * m, g = Math.round(f / o), isNaN(g)) {
              this.element.style.display = "none", this.renderedVisible_ = false;
              return;
            }
            if (l !== void 0 && g >= l) {
              f = A, g = p, d = v;
              break;
            } else if (g >= s) break;
            A = f, p = g, v = d, ++c;
          }
          const y = this.scaleBar_ ? this.createScaleBar(g, f, h) : f.toFixed(d < 0 ? -d : 0) + " " + h;
          this.renderedHTML_ != y && (this.innerElement_.innerHTML = y, this.renderedHTML_ = y), this.renderedWidth_ != g && (this.innerElement_.style.width = g + "px", this.renderedWidth_ = g), this.renderedVisible_ || (this.element.style.display = "", this.renderedVisible_ = true);
        }
        createScaleBar(t, e, i) {
          const r = this.getScaleForResolution(), a = r < 1 ? Math.round(1 / r).toLocaleString() + " : 1" : "1 : " + Math.round(r).toLocaleString(), o = this.scaleBarSteps_, s = t / o, l = [this.createMarker("absolute")];
          for (let h = 0; h < o; ++h) {
            const c = h % 2 === 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even";
            l.push(`<div><div class="ol-scale-singlebar ${c}" style="width: ${s}px;"></div>` + this.createMarker("relative") + (h % 2 === 0 || o === 2 ? this.createStepText(h, t, false, e, i) : "") + "</div>");
          }
          return l.push(this.createStepText(o, t, true, e, i)), (this.scaleBarText_ ? `<div class="ol-scale-text" style="width: ${t}px;">` + a + "</div>" : "") + l.join("");
        }
        createMarker(t) {
          return `<div class="ol-scale-step-marker" style="position: ${t}; top: ${t === "absolute" ? 3 : -10}px;"></div>`;
        }
        createStepText(t, e, i, r, a) {
          const s = (t === 0 ? 0 : Math.round(r / this.scaleBarSteps_ * t * 100) / 100) + (t === 0 ? "" : " " + a), l = t === 0 ? -3 : e / this.scaleBarSteps_ * -1, u = t === 0 ? 0 : e / this.scaleBarSteps_ * 2;
          return `<div class="ol-scale-step-text" style="margin-left: ${l}px;text-align: ${t === 0 ? "left" : "center"};min-width: ${u}px;left: ${i ? e + "px" : "unset"};">` + s + "</div>";
        }
        getScaleForResolution() {
          const t = Em(this.viewState_.projection, this.viewState_.resolution, this.viewState_.center, "m"), e = this.dpi_ || PA, i = 1e3 / 25.4;
          return t * i * e;
        }
        render(t) {
          const e = t.frameState;
          e ? this.viewState_ = e.viewState : this.viewState_ = null, this.updateElement_();
        }
      }
      const NA = { VERTICAL: 0, HORIZONTAL: 1 };
      class Het extends Bl {
        constructor(t) {
          t = t || {}, super({ target: t.target, element: document.createElement("div"), render: t.render }), this.dragListenerKeys_ = [], this.currentResolution_ = void 0, this.direction_ = NA.VERTICAL, this.dragging_, this.heightLimit_ = 0, this.widthLimit_ = 0, this.startX_, this.startY_, this.thumbSize_ = null, this.sliderInitialized_ = false, this.duration_ = t.duration !== void 0 ? t.duration : 200;
          const e = t.className !== void 0 ? t.className : "ol-zoomslider", i = document.createElement("button");
          i.setAttribute("type", "button"), i.className = e + "-thumb " + _s;
          const r = this.element;
          r.className = e + " " + _s + " " + of, r.appendChild(i), r.addEventListener(Io.POINTERDOWN, this.handleDraggerStart_.bind(this), false), r.addEventListener(Io.POINTERMOVE, this.handleDraggerDrag_.bind(this), false), r.addEventListener(Io.POINTERUP, this.handleDraggerEnd_.bind(this), false), r.addEventListener(Rt.CLICK, this.handleContainerClick_.bind(this), false), i.addEventListener(Rt.CLICK, Dr, false);
        }
        setMap(t) {
          super.setMap(t), t && t.render();
        }
        initSlider_() {
          const t = this.element;
          let e = t.offsetWidth, i = t.offsetHeight;
          if (e === 0 && i === 0) return this.sliderInitialized_ = false;
          const r = getComputedStyle(t);
          e -= parseFloat(r.paddingRight) + parseFloat(r.paddingLeft), i -= parseFloat(r.paddingTop) + parseFloat(r.paddingBottom);
          const a = t.firstElementChild, o = getComputedStyle(a), s = a.offsetWidth + parseFloat(o.marginRight) + parseFloat(o.marginLeft), l = a.offsetHeight + parseFloat(o.marginTop) + parseFloat(o.marginBottom);
          return this.thumbSize_ = [s, l], e > i ? (this.direction_ = NA.HORIZONTAL, this.widthLimit_ = e - s) : (this.direction_ = NA.VERTICAL, this.heightLimit_ = i - l), this.sliderInitialized_ = true;
        }
        handleContainerClick_(t) {
          const e = this.getMap().getView(), i = this.getRelativePosition_(t.offsetX - this.thumbSize_[0] / 2, t.offsetY - this.thumbSize_[1] / 2), r = this.getResolutionForPosition_(i), a = e.getConstrainedZoom(e.getZoomForResolution(r));
          e.animateInternal({ zoom: a, duration: this.duration_, easing: $u });
        }
        handleDraggerStart_(t) {
          if (!this.dragging_ && t.target === this.element.firstElementChild) {
            const e = this.element.firstElementChild;
            if (this.getMap().getView().beginInteraction(), this.startX_ = t.clientX - parseFloat(e.style.left), this.startY_ = t.clientY - parseFloat(e.style.top), this.dragging_ = true, this.dragListenerKeys_.length === 0) {
              const i = this.handleDraggerDrag_, r = this.handleDraggerEnd_, a = this.getMap().getOwnerDocument();
              this.dragListenerKeys_.push(Ut(a, Io.POINTERMOVE, i, this), Ut(a, Io.POINTERUP, r, this));
            }
          }
        }
        handleDraggerDrag_(t) {
          if (this.dragging_) {
            const e = t.clientX - this.startX_, i = t.clientY - this.startY_, r = this.getRelativePosition_(e, i);
            this.currentResolution_ = this.getResolutionForPosition_(r), this.getMap().getView().setResolution(this.currentResolution_);
          }
        }
        handleDraggerEnd_(t) {
          this.dragging_ && (this.getMap().getView().endInteraction(), this.dragging_ = false, this.startX_ = void 0, this.startY_ = void 0, this.dragListenerKeys_.forEach(we), this.dragListenerKeys_.length = 0);
        }
        setThumbPosition_(t) {
          const e = this.getPositionForResolution_(t), i = this.element.firstElementChild;
          this.direction_ == NA.HORIZONTAL ? i.style.left = this.widthLimit_ * e + "px" : i.style.top = this.heightLimit_ * e + "px";
        }
        getRelativePosition_(t, e) {
          let i;
          return this.direction_ === NA.HORIZONTAL ? i = t / this.widthLimit_ : i = e / this.heightLimit_, Ze(i, 0, 1);
        }
        getResolutionForPosition_(t) {
          return this.getMap().getView().getResolutionForValueFunction()(1 - t);
        }
        getPositionForResolution_(t) {
          const e = this.getMap().getView().getValueForResolutionFunction();
          return Ze(1 - e(t), 0, 1);
        }
        render(t) {
          if (!t.frameState || !this.sliderInitialized_ && !this.initSlider_()) return;
          const e = t.frameState.viewState.resolution;
          this.currentResolution_ = e, this.setThumbPosition_(e);
        }
      }
      const o0 = 6378137, ck = 85.0511287798, s0 = Math.PI / 180, Mi = Math.PI, fk = 6378245, gk = 0.006693421622965943, dk = [1289059486e-2, 836237787e-2, 5591021, 348198983e-2, 167804312e-2, 0], l0 = [75, 60, 45, 30, 15, 0], Yet = [[1410526172116255e-23, 898305509648872e-20, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 173379812e-1], [-7435856389565537e-24, 8983055097726239e-21, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 1026014486e-2], [-3030883460898826e-23, 898305509983578e-20, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 685681737e-2], [-1981981304930552e-23, 8983055099779535e-21, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 448277706e-2], [309191371068437e-23, 8983055096812155e-21, 6995724062e-14, 23.10934304144901, -23663490511e-14, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 25551644e-1], [2890871144776878e-24, 8983055095805407e-21, -3068298e-14, 7.47137025468032, -353937994e-14, -0.02145144861037, -1234426596e-14, 10322952773e-14, -323890364e-14, 826088.5]], Ak = [[-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5], [8277824516172526e-19, 111320.7020463578, 6477955746671607e-7, -4082003173641316e-6, 1077490566351142e-5, -1517187553151559e-5, 1205306533862167e-5, -5124939663577472e-6, 9133119359512032e-7, 67.5], [0.00337398766765, 111320.7020202162, 4481351045890365e-9, -2339375119931662e-8, 7968221547186455e-8, -1159649932797253e-7, 9723671115602145e-8, -4366194633752821e-8, 8477230501135234e-9, 52.5], [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837749470245e-9, 992013.7397791013, -122195221711287e-8, 1340652697009075e-9, -620943.6990984312, 144416.9293806241, 37.5], [-3441963504368392e-19, 111320.7020576856, 278.2353980772752, 2485758690035394e-9, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-3218135878613132e-19, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]], u0 = Mi * 3e3 / 180, Ml = (n) => (e, i, r) => {
        const a = e.length, o = r || 2;
        let s;
        i ? s = i : o !== 2 ? s = e.slice() : s = new Array(a);
        for (let l = 0; l < a; l += o) n(e, s, l);
        return s;
      }, pk = (n, t) => n < 72.004 || n > 137.8347 || t < 0.8293 || t > 55.8271, vk = (n, t) => {
        let e = Wet(n - 105, t - 35), i = Xet(n - 105, t - 35);
        const r = t / 180 * Mi;
        let a = Math.sin(r);
        a = 1 - gk * a * a;
        const o = Math.sqrt(a);
        return e = e * 180 / (fk * (1 - gk) / (a * o) * Mi), i = i * 180 / (fk / o * Math.cos(r) * Mi), [i, e];
      }, Wet = (n, t) => {
        let e = -100 + 2 * n + 3 * t + 0.2 * t * t + 0.1 * n * t + 0.2 * Math.sqrt(Math.abs(n));
        return e += (20 * Math.sin(6 * n * Mi) + 20 * Math.sin(2 * n * Mi)) * 2 / 3, e += (20 * Math.sin(t * Mi) + 40 * Math.sin(t / 3 * Mi)) * 2 / 3, e += (160 * Math.sin(t / 12 * Mi) + 320 * Math.sin(t * Mi / 30)) * 2 / 3, e;
      }, Xet = (n, t) => {
        let e = 300 + n + 2 * t + 0.1 * n * n + 0.1 * n * t + 0.1 * Math.sqrt(Math.abs(n));
        return e += (20 * Math.sin(6 * n * Mi) + 20 * Math.sin(2 * n * Mi)) * 2 / 3, e += (20 * Math.sin(n * Mi) + 40 * Math.sin(n / 3 * Mi)) * 2 / 3, e += (150 * Math.sin(n / 12 * Mi) + 300 * Math.sin(n / 30 * Mi)) * 2 / 3, e;
      }, $et = (n, t, e) => (n = Math.max(n, t), n = Math.min(n, e), n), Zet = (n, t, e) => {
        const i = e - t;
        for (; n > e; ) n -= i;
        for (; n < t; ) n += i;
        return n;
      }, yk = (n, t, e, i) => {
        const r = n[e], a = n[e + 1], o = i[0] + i[1] * Math.abs(r), s = Math.abs(a) / i[9], l = i[2] + i[3] * s + i[4] * s * s + i[5] * s * s * s + i[6] * s * s * s * s + i[7] * s * s * s * s * s + i[8] * s * s * s * s * s * s;
        t[e] = o * (r < 0 ? -1 : 1), t[e + 1] = l * (a < 0 ? -1 : 1);
      }, Ket = (n, t, e) => {
        const i = n[e] - 65e-4, r = n[e + 1] - 6e-3, a = Math.sqrt(i * i + r * r) - 2e-5 * Math.sin(r * u0), o = Math.atan2(r, i) - 3e-6 * Math.cos(i * u0);
        return t[e] = a * Math.cos(o), t[e + 1] = a * Math.sin(o), t;
      }, Jet = (n, t, e) => {
        const i = n[e], r = n[e + 1], a = Math.sqrt(i * i + r * r) + 2e-5 * Math.sin(r * u0), o = Math.atan2(r, i) + 3e-6 * Math.cos(i * u0);
        return t[e] = a * Math.cos(o) + 65e-4, t[e + 1] = a * Math.sin(o) + 6e-3, t;
      }, wo = { forward: Ml((n, t, e) => {
        const i = Math.max(Math.min(ck, n[e + 1]), -ck), r = Math.sin(i * s0);
        t[e] = o0 * n[e] * s0, t[e + 1] = o0 * Math.log((1 + r) / (1 - r)) / 2;
      }), inverse: Ml((n, t, e) => {
        t[e] = n[e] / o0 / s0, t[e + 1] = (2 * Math.atan(Math.exp(n[e + 1] / o0)) - Math.PI / 2) / s0;
      }) }, Dl = { toWGS84: Ml((n, t, e) => {
        let i = n[e], r = n[e + 1];
        if (!pk(i, r)) {
          const a = vk(i, r);
          i = i - a[0], r = r - a[1];
        }
        t[e] = i, t[e + 1] = r;
      }), fromWGS84: Ml((n, t, e) => {
        let i = n[e], r = n[e + 1];
        if (!pk(i, r)) {
          const a = vk(i, r);
          i = i + a[0], r = r + a[1];
        }
        t[e] = i, t[e + 1] = r;
      }) }, bf = { forward: Ml((n, t, e) => {
        const i = Zet(n[e], -180, 180), r = $et(n[e + 1], -74, 74);
        let a = null, o;
        for (o = 0; o < l0.length; ++o) if (r >= l0[o]) {
          a = Ak[o];
          break;
        }
        if (a === null) {
          for (o = l0.length - 1; o >= 0; --o) if (r <= -l0[o]) {
            a = Ak[o];
            break;
          }
        }
        t[e] = i, t[e + 1] = r, yk(t, t, e, a);
      }), inverse: Ml((n, t, e) => {
        const i = Math.abs(n[e + 1]);
        let r = null;
        for (let a = 0; a < dk.length; a++) if (i >= dk[a]) {
          r = Yet[a];
          break;
        }
        yk(n, t, e, r);
      }) }, Tf = { toWGS84: (n, t, e) => {
        const i = Ml(Ket)(n, t, e);
        return Dl.toWGS84(i, i, e);
      }, fromWGS84: (n, t, e) => {
        const i = Dl.fromWGS84(n, t, e);
        return Ml(Jet)(i, i, e);
      } }, mk = (n, t, e) => {
        let i = wo.inverse(n, t, e);
        return i = Tf.fromWGS84(i, i, e), bf.forward(i, i, e);
      }, _k = (n, t, e) => {
        let i = bf.inverse(n, t, e);
        return i = Tf.toWGS84(i, i, e), wo.forward(i, i, e);
      }, tnt = (n, t, e) => {
        const i = bf.inverse(n, t, e);
        return Tf.toWGS84(i, i, e);
      }, ent = (n, t, e) => {
        const i = Tf.fromWGS84(n, t, e);
        return bf.forward(i, i, e);
      }, Ek = (n, t, e) => {
        let i = bf.inverse(n, t, e);
        return i = Tf.toWGS84(i, i, e), i = Dl.fromWGS84(i, i, e), wo.forward(i, i, e);
      }, Ik = (n, t, e) => {
        let i = wo.inverse(n, t, e);
        return i = Dl.fromWGS84(i, i, e), wo.forward(i, i, e);
      }, xk = (n, t, e) => {
        let i = wo.inverse(n, t, e);
        return i = Dl.toWGS84(i, i, e), wo.forward(i, i, e);
      }, nnt = (n, t, e) => {
        const i = wo.inverse(n, t, e);
        return Dl.toWGS84(i, i, e);
      }, int = (n, t, e) => {
        const i = Dl.fromWGS84(n, t, e);
        return wo.forward(i, i, e);
      }, wk = (n, t, e) => {
        let i = wo.inverse(n, t, e);
        return i = Dl.toWGS84(i, i, e), i = Tf.fromWGS84(i, i, e), bf.forward(i, i, e);
      };
      function rnt(n) {
        n("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), n("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), n("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
        for (var t = 1; t <= 60; ++t) n("EPSG:" + (32600 + t), "+proj=utm +zone=" + t + " +datum=WGS84 +units=m"), n("EPSG:" + (32700 + t), "+proj=utm +zone=" + t + " +south +datum=WGS84 +units=m");
        n.WGS84 = n["EPSG:4326"], n["EPSG:3785"] = n["EPSG:3857"], n.GOOGLE = n["EPSG:3857"], n["EPSG:900913"] = n["EPSG:3857"], n["EPSG:102113"] = n["EPSG:3857"];
      }
      var eh = 1, nh = 2, Bf = 3, ant = 4, eC = 5, Ck = 6378137, ont = 6356752314e-3, Sk = 0.0066943799901413165, FA = 484813681109536e-20, ut = Math.PI / 2, snt = 0.16666666666666666, lnt = 0.04722222222222222, unt = 0.022156084656084655, vt = 1e-10, yi = 0.017453292519943295, Rl = 57.29577951308232, Ye = Math.PI / 4, kA = Math.PI * 2, Pn = 3.14159265359, gr = {};
      gr.greenwich = 0, gr.lisbon = -9.131906111111, gr.paris = 2.337229166667, gr.bogota = -74.080916666667, gr.madrid = -3.687938888889, gr.rome = 12.452333333333, gr.bern = 7.439583333333, gr.jakarta = 106.807719444444, gr.ferro = -17.666666666667, gr.brussels = 4.367975, gr.stockholm = 18.058277777778, gr.athens = 23.7163375, gr.oslo = 10.722916666667;
      const hnt = { mm: { to_meter: 1e-3 }, cm: { to_meter: 0.01 }, ft: { to_meter: 0.3048 }, "us-ft": { to_meter: 1200 / 3937 }, fath: { to_meter: 1.8288 }, kmi: { to_meter: 1852 }, "us-ch": { to_meter: 20.1168402336805 }, "us-mi": { to_meter: 1609.34721869444 }, km: { to_meter: 1e3 }, "ind-ft": { to_meter: 0.30479841 }, "ind-yd": { to_meter: 0.91439523 }, mi: { to_meter: 1609.344 }, yd: { to_meter: 0.9144 }, ch: { to_meter: 20.1168 }, link: { to_meter: 0.201168 }, dm: { to_meter: 0.01 }, in: { to_meter: 0.0254 }, "ind-ch": { to_meter: 20.11669506 }, "us-in": { to_meter: 0.025400050800101 }, "us-yd": { to_meter: 0.914401828803658 } };
      var bk = /[\s_\-\/\(\)]/g;
      function Ll(n, t) {
        if (n[t]) return n[t];
        for (var e = Object.keys(n), i = t.toLowerCase().replace(bk, ""), r = -1, a, o; ++r < e.length; ) if (a = e[r], o = a.toLowerCase().replace(bk, ""), o === i) return n[a];
      }
      function nC(n) {
        var t = {}, e = n.split("+").map(function(s) {
          return s.trim();
        }).filter(function(s) {
          return s;
        }).reduce(function(s, l) {
          var u = l.split("=");
          return u.push(true), s[u[0].toLowerCase()] = u[1], s;
        }, {}), i, r, a, o = { proj: "projName", datum: "datumCode", rf: function(s) {
          t.rf = parseFloat(s);
        }, lat_0: function(s) {
          t.lat0 = s * yi;
        }, lat_1: function(s) {
          t.lat1 = s * yi;
        }, lat_2: function(s) {
          t.lat2 = s * yi;
        }, lat_ts: function(s) {
          t.lat_ts = s * yi;
        }, lon_0: function(s) {
          t.long0 = s * yi;
        }, lon_1: function(s) {
          t.long1 = s * yi;
        }, lon_2: function(s) {
          t.long2 = s * yi;
        }, alpha: function(s) {
          t.alpha = parseFloat(s) * yi;
        }, gamma: function(s) {
          t.rectified_grid_angle = parseFloat(s);
        }, lonc: function(s) {
          t.longc = s * yi;
        }, x_0: function(s) {
          t.x0 = parseFloat(s);
        }, y_0: function(s) {
          t.y0 = parseFloat(s);
        }, k_0: function(s) {
          t.k0 = parseFloat(s);
        }, k: function(s) {
          t.k0 = parseFloat(s);
        }, a: function(s) {
          t.a = parseFloat(s);
        }, b: function(s) {
          t.b = parseFloat(s);
        }, r: function(s) {
          t.a = t.b = parseFloat(s);
        }, r_a: function() {
          t.R_A = true;
        }, zone: function(s) {
          t.zone = parseInt(s, 10);
        }, south: function() {
          t.utmSouth = true;
        }, towgs84: function(s) {
          t.datum_params = s.split(",").map(function(l) {
            return parseFloat(l);
          });
        }, to_meter: function(s) {
          t.to_meter = parseFloat(s);
        }, units: function(s) {
          t.units = s;
          var l = Ll(hnt, s);
          l && (t.to_meter = l.to_meter);
        }, from_greenwich: function(s) {
          t.from_greenwich = s * yi;
        }, pm: function(s) {
          var l = Ll(gr, s);
          t.from_greenwich = (l || parseFloat(s)) * yi;
        }, nadgrids: function(s) {
          s === "@null" ? t.datumCode = "none" : t.nadgrids = s;
        }, axis: function(s) {
          var l = "ewnsud";
          s.length === 3 && l.indexOf(s.substr(0, 1)) !== -1 && l.indexOf(s.substr(1, 1)) !== -1 && l.indexOf(s.substr(2, 1)) !== -1 && (t.axis = s);
        }, approx: function() {
          t.approx = true;
        } };
        for (i in e) r = e[i], i in o ? (a = o[i], typeof a == "function" ? a(r) : t[a] = r) : t[i] = r;
        return typeof t.datumCode == "string" && t.datumCode !== "WGS84" && (t.datumCode = t.datumCode.toLowerCase()), t;
      }
      var OA = 1, Tk = 2, Bk = 3, h0 = 4, Mk = 5, iC = -1, cnt = /\s/, fnt = /[A-Za-z]/, gnt = /[A-Za-z84_]/, c0 = /[,\]]/, Dk = /[\d\.E\-\+]/;
      function Ms(n) {
        if (typeof n != "string") throw new Error("not a string");
        this.text = n.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = OA;
      }
      Ms.prototype.readCharicter = function() {
        var n = this.text[this.place++];
        if (this.state !== h0) for (; cnt.test(n); ) {
          if (this.place >= this.text.length) return;
          n = this.text[this.place++];
        }
        switch (this.state) {
          case OA:
            return this.neutral(n);
          case Tk:
            return this.keyword(n);
          case h0:
            return this.quoted(n);
          case Mk:
            return this.afterquote(n);
          case Bk:
            return this.number(n);
          case iC:
            return;
        }
      }, Ms.prototype.afterquote = function(n) {
        if (n === '"') {
          this.word += '"', this.state = h0;
          return;
        }
        if (c0.test(n)) {
          this.word = this.word.trim(), this.afterItem(n);
          return;
        }
        throw new Error(`havn't handled "` + n + '" in afterquote yet, index ' + this.place);
      }, Ms.prototype.afterItem = function(n) {
        if (n === ",") {
          this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = OA;
          return;
        }
        if (n === "]") {
          this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = OA, this.currentObject = this.stack.pop(), this.currentObject || (this.state = iC);
          return;
        }
      }, Ms.prototype.number = function(n) {
        if (Dk.test(n)) {
          this.word += n;
          return;
        }
        if (c0.test(n)) {
          this.word = parseFloat(this.word), this.afterItem(n);
          return;
        }
        throw new Error(`havn't handled "` + n + '" in number yet, index ' + this.place);
      }, Ms.prototype.quoted = function(n) {
        if (n === '"') {
          this.state = Mk;
          return;
        }
        this.word += n;
      }, Ms.prototype.keyword = function(n) {
        if (gnt.test(n)) {
          this.word += n;
          return;
        }
        if (n === "[") {
          var t = [];
          t.push(this.word), this.level++, this.root === null ? this.root = t : this.currentObject.push(t), this.stack.push(this.currentObject), this.currentObject = t, this.state = OA;
          return;
        }
        if (c0.test(n)) {
          this.afterItem(n);
          return;
        }
        throw new Error(`havn't handled "` + n + '" in keyword yet, index ' + this.place);
      }, Ms.prototype.neutral = function(n) {
        if (fnt.test(n)) {
          this.word = n, this.state = Tk;
          return;
        }
        if (n === '"') {
          this.word = "", this.state = h0;
          return;
        }
        if (Dk.test(n)) {
          this.word = n, this.state = Bk;
          return;
        }
        if (c0.test(n)) {
          this.afterItem(n);
          return;
        }
        throw new Error(`havn't handled "` + n + '" in neutral yet, index ' + this.place);
      }, Ms.prototype.output = function() {
        for (; this.place < this.text.length; ) this.readCharicter();
        if (this.state === iC) return this.root;
        throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
      };
      function dnt(n) {
        var t = new Ms(n);
        return t.output();
      }
      function rC(n, t, e) {
        Array.isArray(t) && (e.unshift(t), t = null);
        var i = t ? {} : n, r = e.reduce(function(a, o) {
          return Mf(o, a), a;
        }, i);
        t && (n[t] = r);
      }
      function Mf(n, t) {
        if (!Array.isArray(n)) {
          t[n] = true;
          return;
        }
        var e = n.shift();
        if (e === "PARAMETER" && (e = n.shift()), n.length === 1) {
          if (Array.isArray(n[0])) {
            t[e] = {}, Mf(n[0], t[e]);
            return;
          }
          t[e] = n[0];
          return;
        }
        if (!n.length) {
          t[e] = true;
          return;
        }
        if (e === "TOWGS84") {
          t[e] = n;
          return;
        }
        if (e === "AXIS") {
          e in t || (t[e] = []), t[e].push(n);
          return;
        }
        Array.isArray(e) || (t[e] = {});
        var i;
        switch (e) {
          case "UNIT":
          case "PRIMEM":
          case "VERT_DATUM":
            t[e] = { name: n[0].toLowerCase(), convert: n[1] }, n.length === 3 && Mf(n[2], t[e]);
            return;
          case "SPHEROID":
          case "ELLIPSOID":
            t[e] = { name: n[0], a: n[1], rf: n[2] }, n.length === 4 && Mf(n[3], t[e]);
            return;
          case "EDATUM":
          case "ENGINEERINGDATUM":
          case "LOCAL_DATUM":
          case "DATUM":
          case "VERT_CS":
          case "VERTCRS":
          case "VERTICALCRS":
            n[0] = ["name", n[0]], rC(t, e, n);
            return;
          case "COMPD_CS":
          case "COMPOUNDCRS":
          case "FITTED_CS":
          case "PROJECTEDCRS":
          case "PROJCRS":
          case "GEOGCS":
          case "GEOCCS":
          case "PROJCS":
          case "LOCAL_CS":
          case "GEODCRS":
          case "GEODETICCRS":
          case "GEODETICDATUM":
          case "ENGCRS":
          case "ENGINEERINGCRS":
            n[0] = ["name", n[0]], rC(t, e, n), t[e].type = e;
            return;
          default:
            for (i = -1; ++i < n.length; ) if (!Array.isArray(n[i])) return Mf(n, t[e]);
            return rC(t, e, n);
        }
      }
      var Ant = 0.017453292519943295, pnt = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
      function vnt(n, t) {
        var e = t[0], i = t[1];
        !(e in n) && i in n && (n[e] = n[i], t.length === 3 && (n[e] = t[2](n[e])));
      }
      function Co(n) {
        return n * Ant;
      }
      function Rk(n) {
        for (var t = Object.keys(n), e = 0, i = t.length; e < i; ++e) {
          var r = t[e];
          pnt.indexOf(r) !== -1 && ynt(n[r]), typeof n[r] == "object" && Rk(n[r]);
        }
      }
      function ynt(n) {
        if (n.AUTHORITY) {
          var t = Object.keys(n.AUTHORITY)[0];
          t && t in n.AUTHORITY && (n.title = t + ":" + n.AUTHORITY[t]);
        }
        if (n.type === "GEOGCS" ? n.projName = "longlat" : n.type === "LOCAL_CS" ? (n.projName = "identity", n.local = true) : typeof n.PROJECTION == "object" ? n.projName = Object.keys(n.PROJECTION)[0] : n.projName = n.PROJECTION, n.AXIS) {
          for (var e = "", i = 0, r = n.AXIS.length; i < r; ++i) {
            var a = [n.AXIS[i][0].toLowerCase(), n.AXIS[i][1].toLowerCase()];
            a[0].indexOf("north") !== -1 || (a[0] === "y" || a[0] === "lat") && a[1] === "north" ? e += "n" : a[0].indexOf("south") !== -1 || (a[0] === "y" || a[0] === "lat") && a[1] === "south" ? e += "s" : a[0].indexOf("east") !== -1 || (a[0] === "x" || a[0] === "lon") && a[1] === "east" ? e += "e" : (a[0].indexOf("west") !== -1 || (a[0] === "x" || a[0] === "lon") && a[1] === "west") && (e += "w");
          }
          e.length === 2 && (e += "u"), e.length === 3 && (n.axis = e);
        }
        n.UNIT && (n.units = n.UNIT.name.toLowerCase(), n.units === "metre" && (n.units = "meter"), n.UNIT.convert && (n.type === "GEOGCS" ? n.DATUM && n.DATUM.SPHEROID && (n.to_meter = n.UNIT.convert * n.DATUM.SPHEROID.a) : n.to_meter = n.UNIT.convert));
        var o = n.GEOGCS;
        n.type === "GEOGCS" && (o = n), o && (o.DATUM ? n.datumCode = o.DATUM.name.toLowerCase() : n.datumCode = o.name.toLowerCase(), n.datumCode.slice(0, 2) === "d_" && (n.datumCode = n.datumCode.slice(2)), n.datumCode === "new_zealand_1949" && (n.datumCode = "nzgd49"), (n.datumCode === "wgs_1984" || n.datumCode === "world_geodetic_system_1984") && (n.PROJECTION === "Mercator_Auxiliary_Sphere" && (n.sphere = true), n.datumCode = "wgs84"), n.datumCode === "belge_1972" && (n.datumCode = "rnb72"), o.DATUM && o.DATUM.SPHEROID && (n.ellps = o.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), n.ellps.toLowerCase().slice(0, 13) === "international" && (n.ellps = "intl"), n.a = o.DATUM.SPHEROID.a, n.rf = parseFloat(o.DATUM.SPHEROID.rf, 10)), o.DATUM && o.DATUM.TOWGS84 && (n.datum_params = o.DATUM.TOWGS84), ~n.datumCode.indexOf("osgb_1936") && (n.datumCode = "osgb36"), ~n.datumCode.indexOf("osni_1952") && (n.datumCode = "osni52"), (~n.datumCode.indexOf("tm65") || ~n.datumCode.indexOf("geodetic_datum_of_1965")) && (n.datumCode = "ire65"), n.datumCode === "ch1903+" && (n.datumCode = "ch1903"), ~n.datumCode.indexOf("israel") && (n.datumCode = "isr93")), n.b && !isFinite(n.b) && (n.b = n.a);
        function s(h) {
          var c = n.to_meter || 1;
          return h * c;
        }
        var l = function(h) {
          return vnt(n, h);
        }, u = [["standard_parallel_1", "Standard_Parallel_1"], ["standard_parallel_1", "Latitude of 1st standard parallel"], ["standard_parallel_2", "Standard_Parallel_2"], ["standard_parallel_2", "Latitude of 2nd standard parallel"], ["false_easting", "False_Easting"], ["false_easting", "False easting"], ["false-easting", "Easting at false origin"], ["false_northing", "False_Northing"], ["false_northing", "False northing"], ["false_northing", "Northing at false origin"], ["central_meridian", "Central_Meridian"], ["central_meridian", "Longitude of natural origin"], ["central_meridian", "Longitude of false origin"], ["latitude_of_origin", "Latitude_Of_Origin"], ["latitude_of_origin", "Central_Parallel"], ["latitude_of_origin", "Latitude of natural origin"], ["latitude_of_origin", "Latitude of false origin"], ["scale_factor", "Scale_Factor"], ["k0", "scale_factor"], ["latitude_of_center", "Latitude_Of_Center"], ["latitude_of_center", "Latitude_of_center"], ["lat0", "latitude_of_center", Co], ["longitude_of_center", "Longitude_Of_Center"], ["longitude_of_center", "Longitude_of_center"], ["longc", "longitude_of_center", Co], ["x0", "false_easting", s], ["y0", "false_northing", s], ["long0", "central_meridian", Co], ["lat0", "latitude_of_origin", Co], ["lat0", "standard_parallel_1", Co], ["lat1", "standard_parallel_1", Co], ["lat2", "standard_parallel_2", Co], ["azimuth", "Azimuth"], ["alpha", "azimuth", Co], ["srsCode", "name"]];
        u.forEach(l), !n.long0 && n.longc && (n.projName === "Albers_Conic_Equal_Area" || n.projName === "Lambert_Azimuthal_Equal_Area") && (n.long0 = n.longc), !n.lat_ts && n.lat1 && (n.projName === "Stereographic_South_Pole" || n.projName === "Polar Stereographic (variant B)") ? (n.lat0 = Co(n.lat1 > 0 ? 90 : -90), n.lat_ts = n.lat1) : !n.lat_ts && n.lat0 && n.projName === "Polar_Stereographic" && (n.lat_ts = n.lat0, n.lat0 = Co(n.lat0 > 0 ? 90 : -90));
      }
      function Lk(n) {
        var t = dnt(n), e = t[0], i = {};
        return Mf(t, i), Rk(i), i[e];
      }
      function Ui(n) {
        var t = this;
        if (arguments.length === 2) {
          var e = arguments[1];
          typeof e == "string" ? e.charAt(0) === "+" ? Ui[n] = nC(arguments[1]) : Ui[n] = Lk(arguments[1]) : Ui[n] = e;
        } else if (arguments.length === 1) {
          if (Array.isArray(n)) return n.map(function(i) {
            Array.isArray(i) ? Ui.apply(t, i) : Ui(i);
          });
          if (typeof n == "string") {
            if (n in Ui) return Ui[n];
          } else "EPSG" in n ? Ui["EPSG:" + n.EPSG] = n : "ESRI" in n ? Ui["ESRI:" + n.ESRI] = n : "IAU2000" in n && (Ui["IAU2000:" + n.IAU2000] = n);
          return;
        }
      }
      rnt(Ui);
      function mnt(n) {
        return typeof n == "string";
      }
      function _nt(n) {
        return n in Ui;
      }
      var Ent = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
      function Int(n) {
        return Ent.some(function(t) {
          return n.indexOf(t) > -1;
        });
      }
      var xnt = ["3857", "900913", "3785", "102113"];
      function wnt(n) {
        var t = Ll(n, "authority");
        if (t) {
          var e = Ll(t, "epsg");
          return e && xnt.indexOf(e) > -1;
        }
      }
      function Cnt(n) {
        var t = Ll(n, "extension");
        if (t) return Ll(t, "proj4");
      }
      function Snt(n) {
        return n[0] === "+";
      }
      function bnt(n) {
        if (mnt(n)) {
          if (_nt(n)) return Ui[n];
          if (Int(n)) {
            var t = Lk(n);
            if (wnt(t)) return Ui["EPSG:3857"];
            var e = Cnt(t);
            return e ? nC(e) : t;
          }
          if (Snt(n)) return nC(n);
        } else return n;
      }
      function Pk(n, t) {
        n = n || {};
        var e, i;
        if (!t) return n;
        for (i in t) e = t[i], e !== void 0 && (n[i] = e);
        return n;
      }
      function So(n, t, e) {
        var i = n * t;
        return e / Math.sqrt(1 - i * i);
      }
      function QA(n) {
        return n < 0 ? -1 : 1;
      }
      function mt(n) {
        return Math.abs(n) <= Pn ? n : n - QA(n) * kA;
      }
      function Ua(n, t, e) {
        var i = n * e, r = 0.5 * n;
        return i = Math.pow((1 - i) / (1 + i), r), Math.tan(0.5 * (ut - t)) / i;
      }
      function zA(n, t) {
        for (var e = 0.5 * n, i, r, a = ut - 2 * Math.atan(t), o = 0; o <= 15; o++) if (i = n * Math.sin(a), r = ut - 2 * Math.atan(t * Math.pow((1 - i) / (1 + i), e)) - a, a += r, Math.abs(r) <= 1e-10) return a;
        return -9999;
      }
      function Tnt() {
        var n = this.b / this.a;
        this.es = 1 - n * n, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = So(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
      }
      function Bnt(n) {
        var t = n.x, e = n.y;
        if (e * Rl > 90 && e * Rl < -90 && t * Rl > 180 && t * Rl < -180) return null;
        var i, r;
        if (Math.abs(Math.abs(e) - ut) <= vt) return null;
        if (this.sphere) i = this.x0 + this.a * this.k0 * mt(t - this.long0), r = this.y0 + this.a * this.k0 * Math.log(Math.tan(Ye + 0.5 * e));
        else {
          var a = Math.sin(e), o = Ua(this.e, e, a);
          i = this.x0 + this.a * this.k0 * mt(t - this.long0), r = this.y0 - this.a * this.k0 * Math.log(o);
        }
        return n.x = i, n.y = r, n;
      }
      function Mnt(n) {
        var t = n.x - this.x0, e = n.y - this.y0, i, r;
        if (this.sphere) r = ut - 2 * Math.atan(Math.exp(-e / (this.a * this.k0)));
        else {
          var a = Math.exp(-e / (this.a * this.k0));
          if (r = zA(this.e, a), r === -9999) return null;
        }
        return i = mt(this.long0 + t / (this.a * this.k0)), n.x = i, n.y = r, n;
      }
      var Dnt = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
      const Rnt = { init: Tnt, forward: Bnt, inverse: Mnt, names: Dnt };
      function Lnt() {
      }
      function Nk(n) {
        return n;
      }
      var Pnt = ["longlat", "identity"], Nnt = [Rnt, { init: Lnt, forward: Nk, inverse: Nk, names: Pnt }], f0 = {}, g0 = [];
      function Fk(n, t) {
        var e = g0.length;
        return n.names ? (g0[e] = n, n.names.forEach(function(i) {
          f0[i.toLowerCase()] = e;
        }), this) : true;
      }
      function Fnt(n) {
        if (!n) return false;
        var t = n.toLowerCase();
        if (typeof f0[t] != "undefined" && g0[f0[t]]) return g0[f0[t]];
      }
      function knt() {
        Nnt.forEach(Fk);
      }
      const Ont = { start: knt, add: Fk, get: Fnt };
      var se = {};
      se.MERIT = { a: 6378137, rf: 298.257, ellipseName: "MERIT 1983" }, se.SGS85 = { a: 6378136, rf: 298.257, ellipseName: "Soviet Geodetic System 85" }, se.GRS80 = { a: 6378137, rf: 298.257222101, ellipseName: "GRS 1980(IUGG, 1980)" }, se.IAU76 = { a: 6378140, rf: 298.257, ellipseName: "IAU 1976" }, se.airy = { a: 6377563396e-3, b: 635625691e-2, ellipseName: "Airy 1830" }, se.APL4 = { a: 6378137, rf: 298.25, ellipseName: "Appl. Physics. 1965" }, se.NWL9D = { a: 6378145, rf: 298.25, ellipseName: "Naval Weapons Lab., 1965" }, se.mod_airy = { a: 6377340189e-3, b: 6356034446e-3, ellipseName: "Modified Airy" }, se.andrae = { a: 637710443e-2, rf: 300, ellipseName: "Andrae 1876 (Den., Iclnd.)" }, se.aust_SA = { a: 6378160, rf: 298.25, ellipseName: "Australian Natl & S. Amer. 1969" }, se.GRS67 = { a: 6378160, rf: 298.247167427, ellipseName: "GRS 67(IUGG 1967)" }, se.bessel = { a: 6377397155e-3, rf: 299.1528128, ellipseName: "Bessel 1841" }, se.bess_nam = { a: 6377483865e-3, rf: 299.1528128, ellipseName: "Bessel 1841 (Namibia)" }, se.clrk66 = { a: 63782064e-1, b: 63565838e-1, ellipseName: "Clarke 1866" }, se.clrk80 = { a: 6378249145e-3, rf: 293.4663, ellipseName: "Clarke 1880 mod." }, se.clrk80ign = { a: 63782492e-1, b: 6356515, rf: 293.4660213, ellipseName: "Clarke 1880 (IGN)" }, se.clrk58 = { a: 6378293645208759e-9, rf: 294.2606763692654, ellipseName: "Clarke 1858" }, se.CPM = { a: 63757387e-1, rf: 334.29, ellipseName: "Comm. des Poids et Mesures 1799" }, se.delmbr = { a: 6376428, rf: 311.5, ellipseName: "Delambre 1810 (Belgium)" }, se.engelis = { a: 637813605e-2, rf: 298.2566, ellipseName: "Engelis 1985" }, se.evrst30 = { a: 6377276345e-3, rf: 300.8017, ellipseName: "Everest 1830" }, se.evrst48 = { a: 6377304063e-3, rf: 300.8017, ellipseName: "Everest 1948" }, se.evrst56 = { a: 6377301243e-3, rf: 300.8017, ellipseName: "Everest 1956" }, se.evrst69 = { a: 6377295664e-3, rf: 300.8017, ellipseName: "Everest 1969" }, se.evrstSS = { a: 6377298556e-3, rf: 300.8017, ellipseName: "Everest (Sabah & Sarawak)" }, se.fschr60 = { a: 6378166, rf: 298.3, ellipseName: "Fischer (Mercury Datum) 1960" }, se.fschr60m = { a: 6378155, rf: 298.3, ellipseName: "Fischer 1960" }, se.fschr68 = { a: 6378150, rf: 298.3, ellipseName: "Fischer 1968" }, se.helmert = { a: 6378200, rf: 298.3, ellipseName: "Helmert 1906" }, se.hough = { a: 6378270, rf: 297, ellipseName: "Hough" }, se.intl = { a: 6378388, rf: 297, ellipseName: "International 1909 (Hayford)" }, se.kaula = { a: 6378163, rf: 298.24, ellipseName: "Kaula 1961" }, se.lerch = { a: 6378139, rf: 298.257, ellipseName: "Lerch 1979" }, se.mprts = { a: 6397300, rf: 191, ellipseName: "Maupertius 1738" }, se.new_intl = { a: 63781575e-1, b: 63567722e-1, ellipseName: "New International 1967" }, se.plessis = { a: 6376523, rf: 6355863, ellipseName: "Plessis 1817 (France)" }, se.krass = { a: 6378245, rf: 298.3, ellipseName: "Krassovsky, 1942" }, se.SEasia = { a: 6378155, b: 63567733205e-4, ellipseName: "Southeast Asia" }, se.walbeck = { a: 6376896, b: 63558348467e-4, ellipseName: "Walbeck" }, se.WGS60 = { a: 6378165, rf: 298.3, ellipseName: "WGS 60" }, se.WGS66 = { a: 6378145, rf: 298.25, ellipseName: "WGS 66" }, se.WGS7 = { a: 6378135, rf: 298.26, ellipseName: "WGS 72" };
      var Qnt = se.WGS84 = { a: 6378137, rf: 298.257223563, ellipseName: "WGS 84" };
      se.sphere = { a: 6370997, b: 6370997, ellipseName: "Normal Sphere (r=6370997)" };
      function znt(n, t, e, i) {
        var r = n * n, a = t * t, o = (r - a) / r, s = 0;
        i ? (n *= 1 - o * (snt + o * (lnt + o * unt)), r = n * n, o = 0) : s = Math.sqrt(o);
        var l = (r - a) / a;
        return { es: o, e: s, ep2: l };
      }
      function Gnt(n, t, e, i, r) {
        if (!n) {
          var a = Ll(se, i);
          a || (a = Qnt), n = a.a, t = a.b, e = a.rf;
        }
        return e && !t && (t = (1 - 1 / e) * n), (e === 0 || Math.abs(n - t) < vt) && (r = true, t = n), { a: n, b: t, rf: e, sphere: r };
      }
      var d0 = { wgs84: { towgs84: "0,0,0", ellipse: "WGS84", datumName: "WGS84" }, ch1903: { towgs84: "674.374,15.056,405.346", ellipse: "bessel", datumName: "swiss" }, ggrs87: { towgs84: "-199.87,74.79,246.62", ellipse: "GRS80", datumName: "Greek_Geodetic_Reference_System_1987" }, nad83: { towgs84: "0,0,0", ellipse: "GRS80", datumName: "North_American_Datum_1983" }, nad27: { nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat", ellipse: "clrk66", datumName: "North_American_Datum_1927" }, potsdam: { towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7", ellipse: "bessel", datumName: "Potsdam Rauenberg 1950 DHDN" }, carthage: { towgs84: "-263.0,6.0,431.0", ellipse: "clark80", datumName: "Carthage 1934 Tunisia" }, hermannskogel: { towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232", ellipse: "bessel", datumName: "Hermannskogel" }, mgi: { towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232", ellipse: "bessel", datumName: "Militar-Geographische Institut" }, osni52: { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "airy", datumName: "Irish National" }, ire65: { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "mod_airy", datumName: "Ireland 1965" }, rassadiran: { towgs84: "-133.63,-157.5,-158.62", ellipse: "intl", datumName: "Rassadiran" }, nzgd49: { towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993", ellipse: "intl", datumName: "New Zealand Geodetic Datum 1949" }, osgb36: { towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894", ellipse: "airy", datumName: "Ordnance Survey of Great Britain 1936" }, s_jtsk: { towgs84: "589,76,480", ellipse: "bessel", datumName: "S-JTSK (Ferro)" }, beduaram: { towgs84: "-106,-87,188", ellipse: "clrk80", datumName: "Beduaram" }, gunung_segara: { towgs84: "-403,684,41", ellipse: "bessel", datumName: "Gunung Segara Jakarta" }, rnb72: { towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1", ellipse: "intl", datumName: "Reseau National Belge 1972" } };
      for (var Unt in d0) {
        var kk = d0[Unt];
        d0[kk.datumName] = kk;
      }
      function Vnt(n, t, e, i, r, a, o) {
        var s = {};
        return n === void 0 || n === "none" ? s.datum_type = eC : s.datum_type = ant, t && (s.datum_params = t.map(parseFloat), (s.datum_params[0] !== 0 || s.datum_params[1] !== 0 || s.datum_params[2] !== 0) && (s.datum_type = eh), s.datum_params.length > 3 && (s.datum_params[3] !== 0 || s.datum_params[4] !== 0 || s.datum_params[5] !== 0 || s.datum_params[6] !== 0) && (s.datum_type = nh, s.datum_params[3] *= FA, s.datum_params[4] *= FA, s.datum_params[5] *= FA, s.datum_params[6] = s.datum_params[6] / 1e6 + 1)), o && (s.datum_type = Bf, s.grids = o), s.a = e, s.b = i, s.es = r, s.ep2 = a, s;
      }
      var Ok = {};
      function jnt(n, t) {
        var e = new DataView(t), i = Ynt(e), r = Wnt(e, i), a = Xnt(e, r, i), o = { header: r, subgrids: a };
        return Ok[n] = o, o;
      }
      function qnt(n) {
        if (n === void 0) return null;
        var t = n.split(",");
        return t.map(Hnt);
      }
      function Hnt(n) {
        if (n.length === 0) return null;
        var t = n[0] === "@";
        return t && (n = n.slice(1)), n === "null" ? { name: "null", mandatory: !t, grid: null, isNull: true } : { name: n, mandatory: !t, grid: Ok[n] || null, isNull: false };
      }
      function Df(n) {
        return n / 3600 * Math.PI / 180;
      }
      function Ynt(n) {
        var t = n.getInt32(8, false);
        return t === 11 ? false : (t = n.getInt32(8, true), true);
      }
      function Wnt(n, t) {
        return { nFields: n.getInt32(8, t), nSubgridFields: n.getInt32(24, t), nSubgrids: n.getInt32(40, t), shiftType: aC(n, 56, 64).trim(), fromSemiMajorAxis: n.getFloat64(120, t), fromSemiMinorAxis: n.getFloat64(136, t), toSemiMajorAxis: n.getFloat64(152, t), toSemiMinorAxis: n.getFloat64(168, t) };
      }
      function aC(n, t, e) {
        return String.fromCharCode.apply(null, new Uint8Array(n.buffer.slice(t, e)));
      }
      function Xnt(n, t, e) {
        for (var i = 176, r = [], a = 0; a < t.nSubgrids; a++) {
          var o = Znt(n, i, e), s = Knt(n, i, o, e), l = Math.round(1 + (o.upperLongitude - o.lowerLongitude) / o.longitudeInterval), u = Math.round(1 + (o.upperLatitude - o.lowerLatitude) / o.latitudeInterval);
          r.push({ ll: [Df(o.lowerLongitude), Df(o.lowerLatitude)], del: [Df(o.longitudeInterval), Df(o.latitudeInterval)], lim: [l, u], count: o.gridNodeCount, cvs: $nt(s) }), i += 176 + o.gridNodeCount * 16;
        }
        return r;
      }
      function $nt(n) {
        return n.map(function(t) {
          return [Df(t.longitudeShift), Df(t.latitudeShift)];
        });
      }
      function Znt(n, t, e) {
        return { name: aC(n, t + 8, t + 16).trim(), parent: aC(n, t + 24, t + 24 + 8).trim(), lowerLatitude: n.getFloat64(t + 72, e), upperLatitude: n.getFloat64(t + 88, e), lowerLongitude: n.getFloat64(t + 104, e), upperLongitude: n.getFloat64(t + 120, e), latitudeInterval: n.getFloat64(t + 136, e), longitudeInterval: n.getFloat64(t + 152, e), gridNodeCount: n.getInt32(t + 168, e) };
      }
      function Knt(n, t, e, i) {
        for (var r = t + 176, a = 16, o = [], s = 0; s < e.gridNodeCount; s++) {
          var l = { latitudeShift: n.getFloat32(r + s * a, i), longitudeShift: n.getFloat32(r + s * a + 4, i), latitudeAccuracy: n.getFloat32(r + s * a + 8, i), longitudeAccuracy: n.getFloat32(r + s * a + 12, i) };
          o.push(l);
        }
        return o;
      }
      function bo(n, t) {
        if (!(this instanceof bo)) return new bo(n);
        t = t || function(u) {
          if (u) throw u;
        };
        var e = bnt(n);
        if (typeof e != "object") {
          t("Could not parse to valid json: " + n);
          return;
        }
        var i = bo.projections.get(e.projName);
        if (!i) {
          t("Could not get projection name from: " + n);
          return;
        }
        if (e.datumCode && e.datumCode !== "none") {
          var r = Ll(d0, e.datumCode);
          r && (e.datum_params = e.datum_params || (r.towgs84 ? r.towgs84.split(",") : null), e.ellps = r.ellipse, e.datumName = r.datumName ? r.datumName : e.datumCode);
        }
        e.k0 = e.k0 || 1, e.axis = e.axis || "enu", e.ellps = e.ellps || "wgs84", e.lat1 = e.lat1 || e.lat0;
        var a = Gnt(e.a, e.b, e.rf, e.ellps, e.sphere), o = znt(a.a, a.b, a.rf, e.R_A), s = qnt(e.nadgrids), l = e.datum || Vnt(e.datumCode, e.datum_params, a.a, a.b, o.es, o.ep2, s);
        Pk(this, e), Pk(this, i), this.a = a.a, this.b = a.b, this.rf = a.rf, this.sphere = a.sphere, this.es = o.es, this.e = o.e, this.ep2 = o.ep2, this.datum = l, this.init(), t(null, this);
      }
      bo.projections = Ont, bo.projections.start();
      function Jnt(n, t) {
        return n.datum_type !== t.datum_type || n.a !== t.a || Math.abs(n.es - t.es) > 5e-11 ? false : n.datum_type === eh ? n.datum_params[0] === t.datum_params[0] && n.datum_params[1] === t.datum_params[1] && n.datum_params[2] === t.datum_params[2] : n.datum_type === nh ? n.datum_params[0] === t.datum_params[0] && n.datum_params[1] === t.datum_params[1] && n.datum_params[2] === t.datum_params[2] && n.datum_params[3] === t.datum_params[3] && n.datum_params[4] === t.datum_params[4] && n.datum_params[5] === t.datum_params[5] && n.datum_params[6] === t.datum_params[6] : true;
      }
      function Qk(n, t, e) {
        var i = n.x, r = n.y, a = n.z ? n.z : 0, o, s, l, u;
        if (r < -ut && r > -1.001 * ut) r = -ut;
        else if (r > ut && r < 1.001 * ut) r = ut;
        else {
          if (r < -ut) return { x: -1 / 0, y: -1 / 0, z: n.z };
          if (r > ut) return { x: 1 / 0, y: 1 / 0, z: n.z };
        }
        return i > Math.PI && (i -= 2 * Math.PI), s = Math.sin(r), u = Math.cos(r), l = s * s, o = e / Math.sqrt(1 - t * l), { x: (o + a) * u * Math.cos(i), y: (o + a) * u * Math.sin(i), z: (o * (1 - t) + a) * s };
      }
      function zk(n, t, e, i) {
        var r = 1e-12, a = r * r, o = 30, s, l, u, h, c, f, g, d, A, p, v, y, m, _ = n.x, I = n.y, E = n.z ? n.z : 0, x, w, C;
        if (s = Math.sqrt(_ * _ + I * I), l = Math.sqrt(_ * _ + I * I + E * E), s / e < r) {
          if (x = 0, l / e < r) return w = ut, C = -i, { x: n.x, y: n.y, z: n.z };
        } else x = Math.atan2(I, _);
        u = E / l, h = s / l, c = 1 / Math.sqrt(1 - t * (2 - t) * h * h), d = h * (1 - t) * c, A = u * c, m = 0;
        do
          m++, g = e / Math.sqrt(1 - t * A * A), C = s * d + E * A - g * (1 - t * A * A), f = t * g / (g + C), c = 1 / Math.sqrt(1 - f * (2 - f) * h * h), p = h * (1 - f) * c, v = u * c, y = v * d - p * A, d = p, A = v;
        while (y * y > a && m < o);
        return w = Math.atan(v / Math.abs(p)), { x, y: w, z: C };
      }
      function tit(n, t, e) {
        if (t === eh) return { x: n.x + e[0], y: n.y + e[1], z: n.z + e[2] };
        if (t === nh) {
          var i = e[0], r = e[1], a = e[2], o = e[3], s = e[4], l = e[5], u = e[6];
          return { x: u * (n.x - l * n.y + s * n.z) + i, y: u * (l * n.x + n.y - o * n.z) + r, z: u * (-s * n.x + o * n.y + n.z) + a };
        }
      }
      function eit(n, t, e) {
        if (t === eh) return { x: n.x - e[0], y: n.y - e[1], z: n.z - e[2] };
        if (t === nh) {
          var i = e[0], r = e[1], a = e[2], o = e[3], s = e[4], l = e[5], u = e[6], h = (n.x - i) / u, c = (n.y - r) / u, f = (n.z - a) / u;
          return { x: h + l * c - s * f, y: -l * h + c + o * f, z: s * h - o * c + f };
        }
      }
      function A0(n) {
        return n === eh || n === nh;
      }
      function nit(n, t, e) {
        if (Jnt(n, t) || n.datum_type === eC || t.datum_type === eC) return e;
        var i = n.a, r = n.es;
        if (n.datum_type === Bf) {
          var a = Gk(n, false, e);
          if (a !== 0) return;
          i = Ck, r = Sk;
        }
        var o = t.a, s = t.b, l = t.es;
        if (t.datum_type === Bf && (o = Ck, s = ont, l = Sk), r === l && i === o && !A0(n.datum_type) && !A0(t.datum_type)) return e;
        if (e = Qk(e, r, i), A0(n.datum_type) && (e = tit(e, n.datum_type, n.datum_params)), A0(t.datum_type) && (e = eit(e, t.datum_type, t.datum_params)), e = zk(e, l, o, s), t.datum_type === Bf) {
          var u = Gk(t, true, e);
          if (u !== 0) return;
        }
        return e;
      }
      function Gk(n, t, e) {
        if (n.grids === null || n.grids.length === 0) return -1;
        var i = { x: -e.x, y: e.y }, r = { x: Number.NaN, y: Number.NaN }, a = [];
        t: for (var o = 0; o < n.grids.length; o++) {
          var s = n.grids[o];
          if (a.push(s.name), s.isNull) {
            r = i;
            break;
          }
          if (s.mandatory, s.grid === null) {
            if (s.mandatory) return -1;
            continue;
          }
          for (var l = s.grid.subgrids, u = 0, h = l.length; u < h; u++) {
            var c = l[u], f = (Math.abs(c.del[1]) + Math.abs(c.del[0])) / 1e4, g = c.ll[0] - f, d = c.ll[1] - f, A = c.ll[0] + (c.lim[0] - 1) * c.del[0] + f, p = c.ll[1] + (c.lim[1] - 1) * c.del[1] + f;
            if (!(d > i.y || g > i.x || p < i.y || A < i.x) && (r = iit(i, t, c), !isNaN(r.x))) break t;
          }
        }
        return isNaN(r.x) ? -1 : (e.x = -r.x, e.y = r.y, 0);
      }
      function iit(n, t, e) {
        var i = { x: Number.NaN, y: Number.NaN };
        if (isNaN(n.x)) return i;
        var r = { x: n.x, y: n.y };
        r.x -= e.ll[0], r.y -= e.ll[1], r.x = mt(r.x - Math.PI) + Math.PI;
        var a = Uk(r, e);
        if (t) {
          if (isNaN(a.x)) return i;
          a.x = r.x - a.x, a.y = r.y - a.y;
          var o = 9, s = 1e-12, l, u;
          do {
            if (u = Uk(a, e), isNaN(u.x)) break;
            l = { x: r.x - (u.x + a.x), y: r.y - (u.y + a.y) }, a.x += l.x, a.y += l.y;
          } while (o-- && Math.abs(l.x) > s && Math.abs(l.y) > s);
          if (o < 0) return i;
          i.x = mt(a.x + e.ll[0]), i.y = a.y + e.ll[1];
        } else isNaN(a.x) || (i.x = n.x + a.x, i.y = n.y + a.y);
        return i;
      }
      function Uk(n, t) {
        var e = { x: n.x / t.del[0], y: n.y / t.del[1] }, i = { x: Math.floor(e.x), y: Math.floor(e.y) }, r = { x: e.x - 1 * i.x, y: e.y - 1 * i.y }, a = { x: Number.NaN, y: Number.NaN }, o;
        if (i.x < 0 || i.x >= t.lim[0] || i.y < 0 || i.y >= t.lim[1]) return a;
        o = i.y * t.lim[0] + i.x;
        var s = { x: t.cvs[o][0], y: t.cvs[o][1] };
        o++;
        var l = { x: t.cvs[o][0], y: t.cvs[o][1] };
        o += t.lim[0];
        var u = { x: t.cvs[o][0], y: t.cvs[o][1] };
        o--;
        var h = { x: t.cvs[o][0], y: t.cvs[o][1] }, c = r.x * r.y, f = r.x * (1 - r.y), g = (1 - r.x) * (1 - r.y), d = (1 - r.x) * r.y;
        return a.x = g * s.x + f * l.x + d * h.x + c * u.x, a.y = g * s.y + f * l.y + d * h.y + c * u.y, a;
      }
      function Vk(n, t, e) {
        var i = e.x, r = e.y, a = e.z || 0, o, s, l, u = {};
        for (l = 0; l < 3; l++) if (!(t && l === 2 && e.z === void 0)) switch (l === 0 ? (o = i, "ew".indexOf(n.axis[l]) !== -1 ? s = "x" : s = "y") : l === 1 ? (o = r, "ns".indexOf(n.axis[l]) !== -1 ? s = "y" : s = "x") : (o = a, s = "z"), n.axis[l]) {
          case "e":
            u[s] = o;
            break;
          case "w":
            u[s] = -o;
            break;
          case "n":
            u[s] = o;
            break;
          case "s":
            u[s] = -o;
            break;
          case "u":
            e[s] !== void 0 && (u.z = o);
            break;
          case "d":
            e[s] !== void 0 && (u.z = -o);
            break;
          default:
            return null;
        }
        return u;
      }
      function jk(n) {
        var t = { x: n[0], y: n[1] };
        return n.length > 2 && (t.z = n[2]), n.length > 3 && (t.m = n[3]), t;
      }
      function rit(n) {
        qk(n.x), qk(n.y);
      }
      function qk(n) {
        if (typeof Number.isFinite == "function") {
          if (Number.isFinite(n)) return;
          throw new TypeError("coordinates must be finite numbers");
        }
        if (typeof n != "number" || n !== n || !isFinite(n)) throw new TypeError("coordinates must be finite numbers");
      }
      function ait(n, t) {
        return (n.datum.datum_type === eh || n.datum.datum_type === nh || n.datum.datum_type === Bf) && t.datumCode !== "WGS84" || (t.datum.datum_type === eh || t.datum.datum_type === nh || t.datum.datum_type === Bf) && n.datumCode !== "WGS84";
      }
      function p0(n, t, e, i) {
        var r;
        Array.isArray(e) ? e = jk(e) : e = { x: e.x, y: e.y, z: e.z, m: e.m };
        var a = e.z !== void 0;
        if (rit(e), n.datum && t.datum && ait(n, t) && (r = new bo("WGS84"), e = p0(n, r, e, i), n = r), i && n.axis !== "enu" && (e = Vk(n, false, e)), n.projName === "longlat") e = { x: e.x * yi, y: e.y * yi, z: e.z || 0 };
        else if (n.to_meter && (e = { x: e.x * n.to_meter, y: e.y * n.to_meter, z: e.z || 0 }), e = n.inverse(e), !e) return;
        if (n.from_greenwich && (e.x += n.from_greenwich), e = nit(n.datum, t.datum, e), !!e) return t.from_greenwich && (e = { x: e.x - t.from_greenwich, y: e.y, z: e.z || 0 }), t.projName === "longlat" ? e = { x: e.x * Rl, y: e.y * Rl, z: e.z || 0 } : (e = t.forward(e), t.to_meter && (e = { x: e.x / t.to_meter, y: e.y / t.to_meter, z: e.z || 0 })), i && t.axis !== "enu" ? Vk(t, true, e) : (e && !a && delete e.z, e);
      }
      var Hk = bo("WGS84");
      function oC(n, t, e, i) {
        var r, a, o;
        return Array.isArray(e) ? (r = p0(n, t, e, i) || { x: NaN, y: NaN }, e.length > 2 ? typeof n.name != "undefined" && n.name === "geocent" || typeof t.name != "undefined" && t.name === "geocent" ? typeof r.z == "number" ? [r.x, r.y, r.z].concat(e.slice(3)) : [r.x, r.y, e[2]].concat(e.slice(3)) : [r.x, r.y].concat(e.slice(2)) : [r.x, r.y]) : (a = p0(n, t, e, i), o = Object.keys(e), o.length === 2 || o.forEach(function(s) {
          if (typeof n.name != "undefined" && n.name === "geocent" || typeof t.name != "undefined" && t.name === "geocent") {
            if (s === "x" || s === "y" || s === "z") return;
          } else if (s === "x" || s === "y") return;
          a[s] = e[s];
        }), a);
      }
      function Yk(n) {
        return n instanceof bo ? n : n.oProj ? n.oProj : bo(n);
      }
      function rn(n, t, e) {
        n = Yk(n);
        var i = false, r;
        return typeof t == "undefined" ? (t = n, n = Hk, i = true) : (typeof t.x != "undefined" || Array.isArray(t)) && (e = t, t = n, n = Hk, i = true), t = Yk(t), e ? oC(n, t, e) : (r = { forward: function(a, o) {
          return oC(n, t, a, o);
        }, inverse: function(a, o) {
          return oC(t, n, a, o);
        } }, i && (r.oProj = t), r);
      }
      var Wk = 6, Xk = "AJSAJS", $k = "AFAFAF", Rf = 65, dr = 73, sa = 79, GA = 86, UA = 90;
      const oit = { forward: Zk, inverse: sit, toPoint: Kk };
      function Zk(n, t) {
        return t = t || 5, hit(lit({ lat: n[1], lon: n[0] }), t);
      }
      function sit(n) {
        var t = lC(eO(n.toUpperCase()));
        return t.lat && t.lon ? [t.lon, t.lat, t.lon, t.lat] : [t.left, t.bottom, t.right, t.top];
      }
      function Kk(n) {
        var t = lC(eO(n.toUpperCase()));
        return t.lat && t.lon ? [t.lon, t.lat] : [(t.left + t.right) / 2, (t.top + t.bottom) / 2];
      }
      function sC(n) {
        return n * (Math.PI / 180);
      }
      function Jk(n) {
        return 180 * (n / Math.PI);
      }
      function lit(n) {
        var t = n.lat, e = n.lon, i = 6378137, r = 669438e-8, a = 0.9996, o, s, l, u, h, c, f, g = sC(t), d = sC(e), A, p;
        p = Math.floor((e + 180) / 6) + 1, e === 180 && (p = 60), t >= 56 && t < 64 && e >= 3 && e < 12 && (p = 32), t >= 72 && t < 84 && (e >= 0 && e < 9 ? p = 31 : e >= 9 && e < 21 ? p = 33 : e >= 21 && e < 33 ? p = 35 : e >= 33 && e < 42 && (p = 37)), o = (p - 1) * 6 - 180 + 3, A = sC(o), s = r / (1 - r), l = i / Math.sqrt(1 - r * Math.sin(g) * Math.sin(g)), u = Math.tan(g) * Math.tan(g), h = s * Math.cos(g) * Math.cos(g), c = Math.cos(g) * (d - A), f = i * ((1 - r / 4 - 3 * r * r / 64 - 5 * r * r * r / 256) * g - (3 * r / 8 + 3 * r * r / 32 + 45 * r * r * r / 1024) * Math.sin(2 * g) + (15 * r * r / 256 + 45 * r * r * r / 1024) * Math.sin(4 * g) - 35 * r * r * r / 3072 * Math.sin(6 * g));
        var v = a * l * (c + (1 - u + h) * c * c * c / 6 + (5 - 18 * u + u * u + 72 * h - 58 * s) * c * c * c * c * c / 120) + 5e5, y = a * (f + l * Math.tan(g) * (c * c / 2 + (5 - u + 9 * h + 4 * h * h) * c * c * c * c / 24 + (61 - 58 * u + u * u + 600 * h - 330 * s) * c * c * c * c * c * c / 720));
        return t < 0 && (y += 1e7), { northing: Math.round(y), easting: Math.round(v), zoneNumber: p, zoneLetter: uit(t) };
      }
      function lC(n) {
        var t = n.northing, e = n.easting, i = n.zoneLetter, r = n.zoneNumber;
        if (r < 0 || r > 60) return null;
        var a = 0.9996, o = 6378137, s = 669438e-8, l, u = (1 - Math.sqrt(1 - s)) / (1 + Math.sqrt(1 - s)), h, c, f, g, d, A, p, v, y, m = e - 5e5, _ = t;
        i < "N" && (_ -= 1e7), p = (r - 1) * 6 - 180 + 3, l = s / (1 - s), A = _ / a, v = A / (o * (1 - s / 4 - 3 * s * s / 64 - 5 * s * s * s / 256)), y = v + (3 * u / 2 - 27 * u * u * u / 32) * Math.sin(2 * v) + (21 * u * u / 16 - 55 * u * u * u * u / 32) * Math.sin(4 * v) + 151 * u * u * u / 96 * Math.sin(6 * v), h = o / Math.sqrt(1 - s * Math.sin(y) * Math.sin(y)), c = Math.tan(y) * Math.tan(y), f = l * Math.cos(y) * Math.cos(y), g = o * (1 - s) / Math.pow(1 - s * Math.sin(y) * Math.sin(y), 1.5), d = m / (h * a);
        var I = y - h * Math.tan(y) / g * (d * d / 2 - (5 + 3 * c + 10 * f - 4 * f * f - 9 * l) * d * d * d * d / 24 + (61 + 90 * c + 298 * f + 45 * c * c - 252 * l - 3 * f * f) * d * d * d * d * d * d / 720);
        I = Jk(I);
        var E = (d - (1 + 2 * c + f) * d * d * d / 6 + (5 - 2 * f + 28 * c - 3 * f * f + 8 * l + 24 * c * c) * d * d * d * d * d / 120) / Math.cos(y);
        E = p + Jk(E);
        var x;
        if (n.accuracy) {
          var w = lC({ northing: n.northing + n.accuracy, easting: n.easting + n.accuracy, zoneLetter: n.zoneLetter, zoneNumber: n.zoneNumber });
          x = { top: w.lat, right: w.lon, bottom: I, left: E };
        } else x = { lat: I, lon: E };
        return x;
      }
      function uit(n) {
        var t = "Z";
        return 84 >= n && n >= 72 ? t = "X" : 72 > n && n >= 64 ? t = "W" : 64 > n && n >= 56 ? t = "V" : 56 > n && n >= 48 ? t = "U" : 48 > n && n >= 40 ? t = "T" : 40 > n && n >= 32 ? t = "S" : 32 > n && n >= 24 ? t = "R" : 24 > n && n >= 16 ? t = "Q" : 16 > n && n >= 8 ? t = "P" : 8 > n && n >= 0 ? t = "N" : 0 > n && n >= -8 ? t = "M" : -8 > n && n >= -16 ? t = "L" : -16 > n && n >= -24 ? t = "K" : -24 > n && n >= -32 ? t = "J" : -32 > n && n >= -40 ? t = "H" : -40 > n && n >= -48 ? t = "G" : -48 > n && n >= -56 ? t = "F" : -56 > n && n >= -64 ? t = "E" : -64 > n && n >= -72 ? t = "D" : -72 > n && n >= -80 && (t = "C"), t;
      }
      function hit(n, t) {
        var e = "00000" + n.easting, i = "00000" + n.northing;
        return n.zoneNumber + n.zoneLetter + cit(n.easting, n.northing, n.zoneNumber) + e.substr(e.length - 5, t) + i.substr(i.length - 5, t);
      }
      function cit(n, t, e) {
        var i = tO(e), r = Math.floor(n / 1e5), a = Math.floor(t / 1e5) % 20;
        return fit(r, a, i);
      }
      function tO(n) {
        var t = n % Wk;
        return t === 0 && (t = Wk), t;
      }
      function fit(n, t, e) {
        var i = e - 1, r = Xk.charCodeAt(i), a = $k.charCodeAt(i), o = r + n - 1, s = a + t, l = false;
        o > UA && (o = o - UA + Rf - 1, l = true), (o === dr || r < dr && o > dr || (o > dr || r < dr) && l) && o++, (o === sa || r < sa && o > sa || (o > sa || r < sa) && l) && (o++, o === dr && o++), o > UA && (o = o - UA + Rf - 1), s > GA ? (s = s - GA + Rf - 1, l = true) : l = false, (s === dr || a < dr && s > dr || (s > dr || a < dr) && l) && s++, (s === sa || a < sa && s > sa || (s > sa || a < sa) && l) && (s++, s === dr && s++), s > GA && (s = s - GA + Rf - 1);
        var u = String.fromCharCode(o) + String.fromCharCode(s);
        return u;
      }
      function eO(n) {
        if (n && n.length === 0) throw "MGRSPoint coverting from nothing";
        for (var t = n.length, e = null, i = "", r, a = 0; !/[A-Z]/.test(r = n.charAt(a)); ) {
          if (a >= 2) throw "MGRSPoint bad conversion from: " + n;
          i += r, a++;
        }
        var o = parseInt(i, 10);
        if (a === 0 || a + 3 > t) throw "MGRSPoint bad conversion from: " + n;
        var s = n.charAt(a++);
        if (s <= "A" || s === "B" || s === "Y" || s >= "Z" || s === "I" || s === "O") throw "MGRSPoint zone letter " + s + " not handled: " + n;
        e = n.substring(a, a += 2);
        for (var l = tO(o), u = git(e.charAt(0), l), h = dit(e.charAt(1), l); h < Ait(s); ) h += 2e6;
        var c = t - a;
        if (c % 2 !== 0) throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + n;
        var f = c / 2, g = 0, d = 0, A, p, v, y, m;
        return f > 0 && (A = 1e5 / Math.pow(10, f), p = n.substring(a, a + f), g = parseFloat(p) * A, v = n.substring(a + f), d = parseFloat(v) * A), y = g + u, m = d + h, { easting: y, northing: m, zoneLetter: s, zoneNumber: o, accuracy: A };
      }
      function git(n, t) {
        for (var e = Xk.charCodeAt(t - 1), i = 1e5, r = false; e !== n.charCodeAt(0); ) {
          if (e++, e === dr && e++, e === sa && e++, e > UA) {
            if (r) throw "Bad character: " + n;
            e = Rf, r = true;
          }
          i += 1e5;
        }
        return i;
      }
      function dit(n, t) {
        if (n > "V") throw "MGRSPoint given invalid Northing " + n;
        for (var e = $k.charCodeAt(t - 1), i = 0, r = false; e !== n.charCodeAt(0); ) {
          if (e++, e === dr && e++, e === sa && e++, e > GA) {
            if (r) throw "Bad character: " + n;
            e = Rf, r = true;
          }
          i += 1e5;
        }
        return i;
      }
      function Ait(n) {
        var t;
        switch (n) {
          case "C":
            t = 11e5;
            break;
          case "D":
            t = 2e6;
            break;
          case "E":
            t = 28e5;
            break;
          case "F":
            t = 37e5;
            break;
          case "G":
            t = 46e5;
            break;
          case "H":
            t = 55e5;
            break;
          case "J":
            t = 64e5;
            break;
          case "K":
            t = 73e5;
            break;
          case "L":
            t = 82e5;
            break;
          case "M":
            t = 91e5;
            break;
          case "N":
            t = 0;
            break;
          case "P":
            t = 8e5;
            break;
          case "Q":
            t = 17e5;
            break;
          case "R":
            t = 26e5;
            break;
          case "S":
            t = 35e5;
            break;
          case "T":
            t = 44e5;
            break;
          case "U":
            t = 53e5;
            break;
          case "V":
            t = 62e5;
            break;
          case "W":
            t = 7e6;
            break;
          case "X":
            t = 79e5;
            break;
          default:
            t = -1;
        }
        if (t >= 0) return t;
        throw "Invalid zone letter: " + n;
      }
      function Lf(n, t, e) {
        if (!(this instanceof Lf)) return new Lf(n, t, e);
        if (Array.isArray(n)) this.x = n[0], this.y = n[1], this.z = n[2] || 0;
        else if (typeof n == "object") this.x = n.x, this.y = n.y, this.z = n.z || 0;
        else if (typeof n == "string" && typeof t == "undefined") {
          var i = n.split(",");
          this.x = parseFloat(i[0], 10), this.y = parseFloat(i[1], 10), this.z = parseFloat(i[2], 10) || 0;
        } else this.x = n, this.y = t, this.z = e || 0;
      }
      Lf.fromMGRS = function(n) {
        return new Lf(Kk(n));
      }, Lf.prototype.toMGRS = function(n) {
        return Zk([this.x, this.y], n);
      };
      var pit = 1, vit = 0.25, nO = 0.046875, iO = 0.01953125, rO = 0.01068115234375, yit = 0.75, mit = 0.46875, _it = 0.013020833333333334, Eit = 0.007120768229166667, Iit = 0.3645833333333333, xit = 0.005696614583333333, wit = 0.3076171875;
      function uC(n) {
        var t = [];
        t[0] = pit - n * (vit + n * (nO + n * (iO + n * rO))), t[1] = n * (yit - n * (nO + n * (iO + n * rO)));
        var e = n * n;
        return t[2] = e * (mit - n * (_it + n * Eit)), e *= n, t[3] = e * (Iit - n * xit), t[4] = e * n * wit, t;
      }
      function Pf(n, t, e, i) {
        return e *= t, t *= t, i[0] * n - e * (i[1] + t * (i[2] + t * (i[3] + t * i[4])));
      }
      var Cit = 20;
      function hC(n, t, e) {
        for (var i = 1 / (1 - t), r = n, a = Cit; a; --a) {
          var o = Math.sin(r), s = 1 - t * o * o;
          if (s = (Pf(r, o, Math.cos(r), e) - n) * (s * Math.sqrt(s)) * i, r -= s, Math.abs(s) < vt) return r;
        }
        return r;
      }
      function Sit() {
        this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = uC(this.es), this.ml0 = Pf(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
      }
      function bit(n) {
        var t = n.x, e = n.y, i = mt(t - this.long0), r, a, o, s = Math.sin(e), l = Math.cos(e);
        if (this.es) {
          var h = l * i, c = Math.pow(h, 2), f = this.ep2 * Math.pow(l, 2), g = Math.pow(f, 2), d = Math.abs(l) > vt ? Math.tan(e) : 0, A = Math.pow(d, 2), p = Math.pow(A, 2);
          r = 1 - this.es * Math.pow(s, 2), h = h / Math.sqrt(r);
          var v = Pf(e, s, l, this.en);
          a = this.a * (this.k0 * h * (1 + c / 6 * (1 - A + f + c / 20 * (5 - 18 * A + p + 14 * f - 58 * A * f + c / 42 * (61 + 179 * p - p * A - 479 * A))))) + this.x0, o = this.a * (this.k0 * (v - this.ml0 + s * i * h / 2 * (1 + c / 12 * (5 - A + 9 * f + 4 * g + c / 30 * (61 + p - 58 * A + 270 * f - 330 * A * f + c / 56 * (1385 + 543 * p - p * A - 3111 * A)))))) + this.y0;
        } else {
          var u = l * Math.sin(i);
          if (Math.abs(Math.abs(u) - 1) < vt) return 93;
          if (a = 0.5 * this.a * this.k0 * Math.log((1 + u) / (1 - u)) + this.x0, o = l * Math.cos(i) / Math.sqrt(1 - Math.pow(u, 2)), u = Math.abs(o), u >= 1) {
            if (u - 1 > vt) return 93;
            o = 0;
          } else o = Math.acos(o);
          e < 0 && (o = -o), o = this.a * this.k0 * (o - this.lat0) + this.y0;
        }
        return n.x = a, n.y = o, n;
      }
      function Tit(n) {
        var t, e, i, r, a = (n.x - this.x0) * (1 / this.a), o = (n.y - this.y0) * (1 / this.a);
        if (this.es) if (t = this.ml0 + o / this.k0, e = hC(t, this.es, this.en), Math.abs(e) < ut) {
          var c = Math.sin(e), f = Math.cos(e), g = Math.abs(f) > vt ? Math.tan(e) : 0, d = this.ep2 * Math.pow(f, 2), A = Math.pow(d, 2), p = Math.pow(g, 2), v = Math.pow(p, 2);
          t = 1 - this.es * Math.pow(c, 2);
          var y = a * Math.sqrt(t) / this.k0, m = Math.pow(y, 2);
          t = t * g, i = e - t * m / (1 - this.es) * 0.5 * (1 - m / 12 * (5 + 3 * p - 9 * d * p + d - 4 * A - m / 30 * (61 + 90 * p - 252 * d * p + 45 * v + 46 * d - m / 56 * (1385 + 3633 * p + 4095 * v + 1574 * v * p)))), r = mt(this.long0 + y * (1 - m / 6 * (1 + 2 * p + d - m / 20 * (5 + 28 * p + 24 * v + 8 * d * p + 6 * d - m / 42 * (61 + 662 * p + 1320 * v + 720 * v * p)))) / f);
        } else i = ut * QA(o), r = 0;
        else {
          var s = Math.exp(a / this.k0), l = 0.5 * (s - 1 / s), u = this.lat0 + o / this.k0, h = Math.cos(u);
          t = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(l, 2))), i = Math.asin(t), o < 0 && (i = -i), l === 0 && h === 0 ? r = 0 : r = mt(Math.atan2(l, h) + this.long0);
        }
        return n.x = r, n.y = i, n;
      }
      var Bit = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
      const v0 = { init: Sit, forward: bit, inverse: Tit, names: Bit };
      function aO(n) {
        var t = Math.exp(n);
        return t = (t - 1 / t) / 2, t;
      }
      function Ar(n, t) {
        n = Math.abs(n), t = Math.abs(t);
        var e = Math.max(n, t), i = Math.min(n, t) / (e || 1);
        return e * Math.sqrt(1 + Math.pow(i, 2));
      }
      function Mit(n) {
        var t = 1 + n, e = t - 1;
        return e === 0 ? n : n * Math.log(t) / e;
      }
      function Dit(n) {
        var t = Math.abs(n);
        return t = Mit(t * (1 + t / (Ar(1, t) + 1))), n < 0 ? -t : t;
      }
      function cC(n, t) {
        for (var e = 2 * Math.cos(2 * t), i = n.length - 1, r = n[i], a = 0, o; --i >= 0; ) o = -a + e * r + n[i], a = r, r = o;
        return t + o * Math.sin(2 * t);
      }
      function Rit(n, t) {
        for (var e = 2 * Math.cos(t), i = n.length - 1, r = n[i], a = 0, o; --i >= 0; ) o = -a + e * r + n[i], a = r, r = o;
        return Math.sin(t) * o;
      }
      function Lit(n) {
        var t = Math.exp(n);
        return t = (t + 1 / t) / 2, t;
      }
      function oO(n, t, e) {
        for (var i = Math.sin(t), r = Math.cos(t), a = aO(e), o = Lit(e), s = 2 * r * o, l = -2 * i * a, u = n.length - 1, h = n[u], c = 0, f = 0, g = 0, d, A; --u >= 0; ) d = f, A = c, f = h, c = g, h = -d + s * f - l * c + n[u], g = -A + l * f + s * c;
        return s = i * o, l = r * a, [s * h - l * g, s * g + l * h];
      }
      function Pit() {
        if (!this.approx && (isNaN(this.es) || this.es <= 0)) throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
        this.approx && (v0.init.apply(this), this.forward = v0.forward, this.inverse = v0.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
        var n = this.es / (1 + Math.sqrt(1 - this.es)), t = n / (2 - n), e = t;
        this.cgb[0] = t * (2 + t * (-2 / 3 + t * (-2 + t * (116 / 45 + t * (26 / 45 + t * (-2854 / 675)))))), this.cbg[0] = t * (-2 + t * (2 / 3 + t * (4 / 3 + t * (-82 / 45 + t * (32 / 45 + t * (4642 / 4725)))))), e = e * t, this.cgb[1] = e * (7 / 3 + t * (-8 / 5 + t * (-227 / 45 + t * (2704 / 315 + t * (2323 / 945))))), this.cbg[1] = e * (5 / 3 + t * (-16 / 15 + t * (-13 / 9 + t * (904 / 315 + t * (-1522 / 945))))), e = e * t, this.cgb[2] = e * (56 / 15 + t * (-136 / 35 + t * (-1262 / 105 + t * (73814 / 2835)))), this.cbg[2] = e * (-26 / 15 + t * (34 / 21 + t * (8 / 5 + t * (-12686 / 2835)))), e = e * t, this.cgb[3] = e * (4279 / 630 + t * (-332 / 35 + t * (-399572 / 14175))), this.cbg[3] = e * (1237 / 630 + t * (-12 / 5 + t * (-24832 / 14175))), e = e * t, this.cgb[4] = e * (4174 / 315 + t * (-144838 / 6237)), this.cbg[4] = e * (-734 / 315 + t * (109598 / 31185)), e = e * t, this.cgb[5] = e * (601676 / 22275), this.cbg[5] = e * (444337 / 155925), e = Math.pow(t, 2), this.Qn = this.k0 / (1 + t) * (1 + e * (1 / 4 + e * (1 / 64 + e / 256))), this.utg[0] = t * (-0.5 + t * (2 / 3 + t * (-37 / 96 + t * (1 / 360 + t * (81 / 512 + t * (-96199 / 604800)))))), this.gtu[0] = t * (0.5 + t * (-2 / 3 + t * (5 / 16 + t * (41 / 180 + t * (-127 / 288 + t * (7891 / 37800)))))), this.utg[1] = e * (-1 / 48 + t * (-1 / 15 + t * (437 / 1440 + t * (-46 / 105 + t * (1118711 / 3870720))))), this.gtu[1] = e * (13 / 48 + t * (-3 / 5 + t * (557 / 1440 + t * (281 / 630 + t * (-1983433 / 1935360))))), e = e * t, this.utg[2] = e * (-17 / 480 + t * (37 / 840 + t * (209 / 4480 + t * (-5569 / 90720)))), this.gtu[2] = e * (61 / 240 + t * (-103 / 140 + t * (15061 / 26880 + t * (167603 / 181440)))), e = e * t, this.utg[3] = e * (-4397 / 161280 + t * (11 / 504 + t * (830251 / 7257600))), this.gtu[3] = e * (49561 / 161280 + t * (-179 / 168 + t * (6601661 / 7257600))), e = e * t, this.utg[4] = e * (-4583 / 161280 + t * (108847 / 3991680)), this.gtu[4] = e * (34729 / 80640 + t * (-3418889 / 1995840)), e = e * t, this.utg[5] = e * (-20648693 / 638668800), this.gtu[5] = e * (212378941 / 319334400);
        var i = cC(this.cbg, this.lat0);
        this.Zb = -this.Qn * (i + Rit(this.gtu, 2 * i));
      }
      function Nit(n) {
        var t = mt(n.x - this.long0), e = n.y;
        e = cC(this.cbg, e);
        var i = Math.sin(e), r = Math.cos(e), a = Math.sin(t), o = Math.cos(t);
        e = Math.atan2(i, o * r), t = Math.atan2(a * r, Ar(i, r * o)), t = Dit(Math.tan(t));
        var s = oO(this.gtu, 2 * e, 2 * t);
        e = e + s[0], t = t + s[1];
        var l, u;
        return Math.abs(t) <= 2.623395162778 ? (l = this.a * (this.Qn * t) + this.x0, u = this.a * (this.Qn * e + this.Zb) + this.y0) : (l = 1 / 0, u = 1 / 0), n.x = l, n.y = u, n;
      }
      function Fit(n) {
        var t = (n.x - this.x0) * (1 / this.a), e = (n.y - this.y0) * (1 / this.a);
        e = (e - this.Zb) / this.Qn, t = t / this.Qn;
        var i, r;
        if (Math.abs(t) <= 2.623395162778) {
          var a = oO(this.utg, 2 * e, 2 * t);
          e = e + a[0], t = t + a[1], t = Math.atan(aO(t));
          var o = Math.sin(e), s = Math.cos(e), l = Math.sin(t), u = Math.cos(t);
          e = Math.atan2(o * u, Ar(l, u * s)), t = Math.atan2(l, u * s), i = mt(t + this.long0), r = cC(this.cgb, e);
        } else i = 1 / 0, r = 1 / 0;
        return n.x = i, n.y = r, n;
      }
      var kit = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
      const y0 = { init: Pit, forward: Nit, inverse: Fit, names: kit };
      function Oit(n, t) {
        if (n === void 0) {
          if (n = Math.floor((mt(t) + Math.PI) * 30 / Math.PI) + 1, n < 0) return 0;
          if (n > 60) return 60;
        }
        return n;
      }
      var Qit = "etmerc";
      function zit() {
        var n = Oit(this.zone, this.long0);
        if (n === void 0) throw new Error("unknown utm zone");
        this.lat0 = 0, this.long0 = (6 * Math.abs(n) - 183) * yi, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, y0.init.apply(this), this.forward = y0.forward, this.inverse = y0.inverse;
      }
      var Git = ["Universal Transverse Mercator System", "utm"];
      const Uit = { init: zit, names: Git, dependsOn: Qit };
      function fC(n, t) {
        return Math.pow((1 - n) / (1 + n), t);
      }
      var Vit = 20;
      function jit() {
        var n = Math.sin(this.lat0), t = Math.cos(this.lat0);
        t *= t, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * n * n), this.C = Math.sqrt(1 + this.es * t * t / (1 - this.es)), this.phic0 = Math.asin(n / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + Ye) / (Math.pow(Math.tan(0.5 * this.lat0 + Ye), this.C) * fC(this.e * n, this.ratexp));
      }
      function qit(n) {
        var t = n.x, e = n.y;
        return n.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * e + Ye), this.C) * fC(this.e * Math.sin(e), this.ratexp)) - ut, n.x = this.C * t, n;
      }
      function Hit(n) {
        for (var t = 1e-14, e = n.x / this.C, i = n.y, r = Math.pow(Math.tan(0.5 * i + Ye) / this.K, 1 / this.C), a = Vit; a > 0 && (i = 2 * Math.atan(r * fC(this.e * Math.sin(n.y), -0.5 * this.e)) - ut, !(Math.abs(i - n.y) < t)); --a) n.y = i;
        return a ? (n.x = e, n.y = i, n) : null;
      }
      var Yit = ["gauss"];
      const gC = { init: jit, forward: qit, inverse: Hit, names: Yit };
      function Wit() {
        gC.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
      }
      function Xit(n) {
        var t, e, i, r;
        return n.x = mt(n.x - this.long0), gC.forward.apply(this, [n]), t = Math.sin(n.y), e = Math.cos(n.y), i = Math.cos(n.x), r = this.k0 * this.R2 / (1 + this.sinc0 * t + this.cosc0 * e * i), n.x = r * e * Math.sin(n.x), n.y = r * (this.cosc0 * t - this.sinc0 * e * i), n.x = this.a * n.x + this.x0, n.y = this.a * n.y + this.y0, n;
      }
      function $it(n) {
        var t, e, i, r, a;
        if (n.x = (n.x - this.x0) / this.a, n.y = (n.y - this.y0) / this.a, n.x /= this.k0, n.y /= this.k0, a = Ar(n.x, n.y)) {
          var o = 2 * Math.atan2(a, this.R2);
          t = Math.sin(o), e = Math.cos(o), r = Math.asin(e * this.sinc0 + n.y * t * this.cosc0 / a), i = Math.atan2(n.x * t, a * this.cosc0 * e - n.y * this.sinc0 * t);
        } else r = this.phic0, i = 0;
        return n.x = i, n.y = r, gC.inverse.apply(this, [n]), n.x = mt(n.x + this.long0), n;
      }
      var Zit = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
      const Kit = { init: Wit, forward: Xit, inverse: $it, names: Zit };
      function Jit(n, t, e) {
        return t *= e, Math.tan(0.5 * (ut + n)) * Math.pow((1 - t) / (1 + t), 0.5 * e);
      }
      function trt() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= vt && (this.k0 = 0.5 * (1 + QA(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= vt && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= vt && Math.abs(Math.cos(this.lat_ts)) > vt && (this.k0 = 0.5 * this.cons * So(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Ua(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = So(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - ut, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
      }
      function ert(n) {
        var t = n.x, e = n.y, i = Math.sin(e), r = Math.cos(e), a, o, s, l, u, h, c = mt(t - this.long0);
        return Math.abs(Math.abs(t - this.long0) - Math.PI) <= vt && Math.abs(e + this.lat0) <= vt ? (n.x = NaN, n.y = NaN, n) : this.sphere ? (a = 2 * this.k0 / (1 + this.sinlat0 * i + this.coslat0 * r * Math.cos(c)), n.x = this.a * a * r * Math.sin(c) + this.x0, n.y = this.a * a * (this.coslat0 * i - this.sinlat0 * r * Math.cos(c)) + this.y0, n) : (o = 2 * Math.atan(this.ssfn_(e, i, this.e)) - ut, l = Math.cos(o), s = Math.sin(o), Math.abs(this.coslat0) <= vt ? (u = Ua(this.e, e * this.con, this.con * i), h = 2 * this.a * this.k0 * u / this.cons, n.x = this.x0 + h * Math.sin(t - this.long0), n.y = this.y0 - this.con * h * Math.cos(t - this.long0), n) : (Math.abs(this.sinlat0) < vt ? (a = 2 * this.a * this.k0 / (1 + l * Math.cos(c)), n.y = a * s) : (a = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * s + this.cosX0 * l * Math.cos(c))), n.y = a * (this.cosX0 * s - this.sinX0 * l * Math.cos(c)) + this.y0), n.x = a * l * Math.sin(c) + this.x0, n));
      }
      function nrt(n) {
        n.x -= this.x0, n.y -= this.y0;
        var t, e, i, r, a, o = Math.sqrt(n.x * n.x + n.y * n.y);
        if (this.sphere) {
          var s = 2 * Math.atan(o / (2 * this.a * this.k0));
          return t = this.long0, e = this.lat0, o <= vt ? (n.x = t, n.y = e, n) : (e = Math.asin(Math.cos(s) * this.sinlat0 + n.y * Math.sin(s) * this.coslat0 / o), Math.abs(this.coslat0) < vt ? this.lat0 > 0 ? t = mt(this.long0 + Math.atan2(n.x, -1 * n.y)) : t = mt(this.long0 + Math.atan2(n.x, n.y)) : t = mt(this.long0 + Math.atan2(n.x * Math.sin(s), o * this.coslat0 * Math.cos(s) - n.y * this.sinlat0 * Math.sin(s))), n.x = t, n.y = e, n);
        } else if (Math.abs(this.coslat0) <= vt) {
          if (o <= vt) return e = this.lat0, t = this.long0, n.x = t, n.y = e, n;
          n.x *= this.con, n.y *= this.con, i = o * this.cons / (2 * this.a * this.k0), e = this.con * zA(this.e, i), t = this.con * mt(this.con * this.long0 + Math.atan2(n.x, -1 * n.y));
        } else r = 2 * Math.atan(o * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), t = this.long0, o <= vt ? a = this.X0 : (a = Math.asin(Math.cos(r) * this.sinX0 + n.y * Math.sin(r) * this.cosX0 / o), t = mt(this.long0 + Math.atan2(n.x * Math.sin(r), o * this.cosX0 * Math.cos(r) - n.y * this.sinX0 * Math.sin(r)))), e = -1 * zA(this.e, Math.tan(0.5 * (ut + a)));
        return n.x = t, n.y = e, n;
      }
      var irt = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"];
      const rrt = { init: trt, forward: ert, inverse: nrt, names: irt, ssfn_: Jit };
      function art() {
        var n = this.lat0;
        this.lambda0 = this.long0;
        var t = Math.sin(n), e = this.a, i = this.rf, r = 1 / i, a = 2 * r - Math.pow(r, 2), o = this.e = Math.sqrt(a);
        this.R = this.k0 * e * Math.sqrt(1 - a) / (1 - a * Math.pow(t, 2)), this.alpha = Math.sqrt(1 + a / (1 - a) * Math.pow(Math.cos(n), 4)), this.b0 = Math.asin(t / this.alpha);
        var s = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), l = Math.log(Math.tan(Math.PI / 4 + n / 2)), u = Math.log((1 + o * t) / (1 - o * t));
        this.K = s - this.alpha * l + this.alpha * o / 2 * u;
      }
      function ort(n) {
        var t = Math.log(Math.tan(Math.PI / 4 - n.y / 2)), e = this.e / 2 * Math.log((1 + this.e * Math.sin(n.y)) / (1 - this.e * Math.sin(n.y))), i = -this.alpha * (t + e) + this.K, r = 2 * (Math.atan(Math.exp(i)) - Math.PI / 4), a = this.alpha * (n.x - this.lambda0), o = Math.atan(Math.sin(a) / (Math.sin(this.b0) * Math.tan(r) + Math.cos(this.b0) * Math.cos(a))), s = Math.asin(Math.cos(this.b0) * Math.sin(r) - Math.sin(this.b0) * Math.cos(r) * Math.cos(a));
        return n.y = this.R / 2 * Math.log((1 + Math.sin(s)) / (1 - Math.sin(s))) + this.y0, n.x = this.R * o + this.x0, n;
      }
      function srt(n) {
        for (var t = n.x - this.x0, e = n.y - this.y0, i = t / this.R, r = 2 * (Math.atan(Math.exp(e / this.R)) - Math.PI / 4), a = Math.asin(Math.cos(this.b0) * Math.sin(r) + Math.sin(this.b0) * Math.cos(r) * Math.cos(i)), o = Math.atan(Math.sin(i) / (Math.cos(this.b0) * Math.cos(i) - Math.sin(this.b0) * Math.tan(r))), s = this.lambda0 + o / this.alpha, l = 0, u = a, h = -1e3, c = 0; Math.abs(u - h) > 1e-7; ) {
          if (++c > 20) return;
          l = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + a / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(u)) / 2)), h = u, u = 2 * Math.atan(Math.exp(l)) - Math.PI / 2;
        }
        return n.x = s, n.y = u, n;
      }
      var lrt = ["somerc"];
      const urt = { init: art, forward: ort, inverse: srt, names: lrt };
      var Nf = 1e-7;
      function hrt(n) {
        var t = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], e = typeof n.PROJECTION == "object" ? Object.keys(n.PROJECTION)[0] : n.PROJECTION;
        return "no_uoff" in n || "no_off" in n || t.indexOf(e) !== -1;
      }
      function crt() {
        var n, t, e, i, r, a, o, s, l, u, h = 0, c, f = 0, g = 0, d = 0, A = 0, p = 0, v = 0;
        this.no_off = hrt(this), this.no_rot = "no_rot" in this;
        var y = false;
        "alpha" in this && (y = true);
        var m = false;
        if ("rectified_grid_angle" in this && (m = true), y && (v = this.alpha), m && (h = this.rectified_grid_angle * yi), y || m) f = this.longc;
        else if (g = this.long1, A = this.lat1, d = this.long2, p = this.lat2, Math.abs(A - p) <= Nf || (n = Math.abs(A)) <= Nf || Math.abs(n - ut) <= Nf || Math.abs(Math.abs(this.lat0) - ut) <= Nf || Math.abs(Math.abs(p) - ut) <= Nf) throw new Error();
        var _ = 1 - this.es;
        t = Math.sqrt(_), Math.abs(this.lat0) > vt ? (s = Math.sin(this.lat0), e = Math.cos(this.lat0), n = 1 - this.es * s * s, this.B = e * e, this.B = Math.sqrt(1 + this.es * this.B * this.B / _), this.A = this.B * this.k0 * t / n, i = this.B * t / (e * Math.sqrt(n)), r = i * i - 1, r <= 0 ? r = 0 : (r = Math.sqrt(r), this.lat0 < 0 && (r = -r)), this.E = r += i, this.E *= Math.pow(Ua(this.e, this.lat0, s), this.B)) : (this.B = 1 / t, this.A = this.k0, this.E = i = r = 1), y || m ? (y ? (c = Math.asin(Math.sin(v) / i), m || (h = v)) : (c = h, v = Math.asin(i * Math.sin(c))), this.lam0 = f - Math.asin(0.5 * (r - 1 / r) * Math.tan(c)) / this.B) : (a = Math.pow(Ua(this.e, A, Math.sin(A)), this.B), o = Math.pow(Ua(this.e, p, Math.sin(p)), this.B), r = this.E / a, l = (o - a) / (o + a), u = this.E * this.E, u = (u - o * a) / (u + o * a), n = g - d, n < -Math.pi ? d -= kA : n > Math.pi && (d += kA), this.lam0 = mt(0.5 * (g + d) - Math.atan(u * Math.tan(0.5 * this.B * (g - d)) / l) / this.B), c = Math.atan(2 * Math.sin(this.B * mt(g - this.lam0)) / (r - 1 / r)), h = v = Math.asin(i * Math.sin(c))), this.singam = Math.sin(c), this.cosgam = Math.cos(c), this.sinrot = Math.sin(h), this.cosrot = Math.cos(h), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A * this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(i * i - 1) / Math.cos(v))), this.lat0 < 0 && (this.u_0 = -this.u_0)), r = 0.5 * c, this.v_pole_n = this.ArB * Math.log(Math.tan(Ye - r)), this.v_pole_s = this.ArB * Math.log(Math.tan(Ye + r));
      }
      function frt(n) {
        var t = {}, e, i, r, a, o, s, l, u;
        if (n.x = n.x - this.lam0, Math.abs(Math.abs(n.y) - ut) > vt) {
          if (o = this.E / Math.pow(Ua(this.e, n.y, Math.sin(n.y)), this.B), s = 1 / o, e = 0.5 * (o - s), i = 0.5 * (o + s), a = Math.sin(this.B * n.x), r = (e * this.singam - a * this.cosgam) / i, Math.abs(Math.abs(r) - 1) < vt) throw new Error();
          u = 0.5 * this.ArB * Math.log((1 - r) / (1 + r)), s = Math.cos(this.B * n.x), Math.abs(s) < Nf ? l = this.A * n.x : l = this.ArB * Math.atan2(e * this.cosgam + a * this.singam, s);
        } else u = n.y > 0 ? this.v_pole_n : this.v_pole_s, l = this.ArB * n.y;
        return this.no_rot ? (t.x = l, t.y = u) : (l -= this.u_0, t.x = u * this.cosrot + l * this.sinrot, t.y = l * this.cosrot - u * this.sinrot), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t;
      }
      function grt(n) {
        var t, e, i, r, a, o, s, l = {};
        if (n.x = (n.x - this.x0) * (1 / this.a), n.y = (n.y - this.y0) * (1 / this.a), this.no_rot ? (e = n.y, t = n.x) : (e = n.x * this.cosrot - n.y * this.sinrot, t = n.y * this.cosrot + n.x * this.sinrot + this.u_0), i = Math.exp(-this.BrA * e), r = 0.5 * (i - 1 / i), a = 0.5 * (i + 1 / i), o = Math.sin(this.BrA * t), s = (o * this.cosgam + r * this.singam) / a, Math.abs(Math.abs(s) - 1) < vt) l.x = 0, l.y = s < 0 ? -ut : ut;
        else {
          if (l.y = this.E / Math.sqrt((1 + s) / (1 - s)), l.y = zA(this.e, Math.pow(l.y, 1 / this.B)), l.y === 1 / 0) throw new Error();
          l.x = -this.rB * Math.atan2(r * this.cosgam - o * this.singam, Math.cos(this.BrA * t));
        }
        return l.x += this.lam0, l;
      }
      var drt = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
      const Art = { init: crt, forward: frt, inverse: grt, names: drt };
      function prt() {
        if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < vt)) {
          var n = this.b / this.a;
          this.e = Math.sqrt(1 - n * n);
          var t = Math.sin(this.lat1), e = Math.cos(this.lat1), i = So(this.e, t, e), r = Ua(this.e, this.lat1, t), a = Math.sin(this.lat2), o = Math.cos(this.lat2), s = So(this.e, a, o), l = Ua(this.e, this.lat2, a), u = Ua(this.e, this.lat0, Math.sin(this.lat0));
          Math.abs(this.lat1 - this.lat2) > vt ? this.ns = Math.log(i / s) / Math.log(r / l) : this.ns = t, isNaN(this.ns) && (this.ns = t), this.f0 = i / (this.ns * Math.pow(r, this.ns)), this.rh = this.a * this.f0 * Math.pow(u, this.ns), this.title || (this.title = "Lambert Conformal Conic");
        }
      }
      function vrt(n) {
        var t = n.x, e = n.y;
        Math.abs(2 * Math.abs(e) - Math.PI) <= vt && (e = QA(e) * (ut - 2 * vt));
        var i = Math.abs(Math.abs(e) - ut), r, a;
        if (i > vt) r = Ua(this.e, e, Math.sin(e)), a = this.a * this.f0 * Math.pow(r, this.ns);
        else {
          if (i = e * this.ns, i <= 0) return null;
          a = 0;
        }
        var o = this.ns * mt(t - this.long0);
        return n.x = this.k0 * (a * Math.sin(o)) + this.x0, n.y = this.k0 * (this.rh - a * Math.cos(o)) + this.y0, n;
      }
      function yrt(n) {
        var t, e, i, r, a, o = (n.x - this.x0) / this.k0, s = this.rh - (n.y - this.y0) / this.k0;
        this.ns > 0 ? (t = Math.sqrt(o * o + s * s), e = 1) : (t = -Math.sqrt(o * o + s * s), e = -1);
        var l = 0;
        if (t !== 0 && (l = Math.atan2(e * o, e * s)), t !== 0 || this.ns > 0) {
          if (e = 1 / this.ns, i = Math.pow(t / (this.a * this.f0), e), r = zA(this.e, i), r === -9999) return null;
        } else r = -ut;
        return a = mt(l / this.ns + this.long0), n.x = a, n.y = r, n;
      }
      var mrt = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_1SP", "Lambert_Conformal_Conic_2SP", "lcc", "Lambert Conic Conformal (1SP)", "Lambert Conic Conformal (2SP)"];
      const _rt = { init: prt, forward: vrt, inverse: yrt, names: mrt };
      function Ert() {
        this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
      }
      function Irt(n) {
        var t, e, i, r, a, o, s, l = n.x, u = n.y, h = mt(l - this.long0);
        return t = Math.pow((1 + this.e * Math.sin(u)) / (1 - this.e * Math.sin(u)), this.alfa * this.e / 2), e = 2 * (Math.atan(this.k * Math.pow(Math.tan(u / 2 + this.s45), this.alfa) / t) - this.s45), i = -h * this.alfa, r = Math.asin(Math.cos(this.ad) * Math.sin(e) + Math.sin(this.ad) * Math.cos(e) * Math.cos(i)), a = Math.asin(Math.cos(e) * Math.sin(i) / Math.cos(r)), o = this.n * a, s = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(r / 2 + this.s45), this.n), n.y = s * Math.cos(o) / 1, n.x = s * Math.sin(o) / 1, this.czech || (n.y *= -1, n.x *= -1), n;
      }
      function xrt(n) {
        var t, e, i, r, a, o, s, l, u = n.x;
        n.x = n.y, n.y = u, this.czech || (n.y *= -1, n.x *= -1), o = Math.sqrt(n.x * n.x + n.y * n.y), a = Math.atan2(n.y, n.x), r = a / Math.sin(this.s0), i = 2 * (Math.atan(Math.pow(this.ro0 / o, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), t = Math.asin(Math.cos(this.ad) * Math.sin(i) - Math.sin(this.ad) * Math.cos(i) * Math.cos(r)), e = Math.asin(Math.cos(i) * Math.sin(r) / Math.cos(t)), n.x = this.long0 - e / this.alfa, s = t, l = 0;
        var h = 0;
        do
          n.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(t / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(s)) / (1 - this.e * Math.sin(s)), this.e / 2)) - this.s45), Math.abs(s - n.y) < 1e-10 && (l = 1), s = n.y, h += 1;
        while (l === 0 && h < 15);
        return h >= 15 ? null : n;
      }
      var wrt = ["Krovak", "krovak"];
      const Crt = { init: Ert, forward: Irt, inverse: xrt, names: wrt };
      function Vi(n, t, e, i, r) {
        return n * r - t * Math.sin(2 * r) + e * Math.sin(4 * r) - i * Math.sin(6 * r);
      }
      function VA(n) {
        return 1 - 0.25 * n * (1 + n / 16 * (3 + 1.25 * n));
      }
      function jA(n) {
        return 0.375 * n * (1 + 0.25 * n * (1 + 0.46875 * n));
      }
      function qA(n) {
        return 0.05859375 * n * n * (1 + 0.75 * n);
      }
      function HA(n) {
        return n * n * n * (35 / 3072);
      }
      function Ff(n, t, e) {
        var i = t * e;
        return n / Math.sqrt(1 - i * i);
      }
      function Pl(n) {
        return Math.abs(n) < ut ? n : n - QA(n) * Math.PI;
      }
      function m0(n, t, e, i, r) {
        var a, o;
        a = n / t;
        for (var s = 0; s < 15; s++) if (o = (n - (t * a - e * Math.sin(2 * a) + i * Math.sin(4 * a) - r * Math.sin(6 * a))) / (t - 2 * e * Math.cos(2 * a) + 4 * i * Math.cos(4 * a) - 6 * r * Math.cos(6 * a)), a += o, Math.abs(o) <= 1e-10) return a;
        return NaN;
      }
      function Srt() {
        this.sphere || (this.e0 = VA(this.es), this.e1 = jA(this.es), this.e2 = qA(this.es), this.e3 = HA(this.es), this.ml0 = this.a * Vi(this.e0, this.e1, this.e2, this.e3, this.lat0));
      }
      function brt(n) {
        var t, e, i = n.x, r = n.y;
        if (i = mt(i - this.long0), this.sphere) t = this.a * Math.asin(Math.cos(r) * Math.sin(i)), e = this.a * (Math.atan2(Math.tan(r), Math.cos(i)) - this.lat0);
        else {
          var a = Math.sin(r), o = Math.cos(r), s = Ff(this.a, this.e, a), l = Math.tan(r) * Math.tan(r), u = i * Math.cos(r), h = u * u, c = this.es * o * o / (1 - this.es), f = this.a * Vi(this.e0, this.e1, this.e2, this.e3, r);
          t = s * u * (1 - h * l * (1 / 6 - (8 - l + 8 * c) * h / 120)), e = f - this.ml0 + s * a / o * h * (0.5 + (5 - l + 6 * c) * h / 24);
        }
        return n.x = t + this.x0, n.y = e + this.y0, n;
      }
      function Trt(n) {
        n.x -= this.x0, n.y -= this.y0;
        var t = n.x / this.a, e = n.y / this.a, i, r;
        if (this.sphere) {
          var a = e + this.lat0;
          i = Math.asin(Math.sin(a) * Math.cos(t)), r = Math.atan2(Math.tan(t), Math.cos(a));
        } else {
          var o = this.ml0 / this.a + e, s = m0(o, this.e0, this.e1, this.e2, this.e3);
          if (Math.abs(Math.abs(s) - ut) <= vt) return n.x = this.long0, n.y = ut, e < 0 && (n.y *= -1), n;
          var l = Ff(this.a, this.e, Math.sin(s)), u = l * l * l / this.a / this.a * (1 - this.es), h = Math.pow(Math.tan(s), 2), c = t * this.a / l, f = c * c;
          i = s - l * Math.tan(s) / u * c * c * (0.5 - (1 + 3 * h) * c * c / 24), r = c * (1 - f * (h / 3 + (1 + 3 * h) * h * f / 15)) / Math.cos(s);
        }
        return n.x = mt(r + this.long0), n.y = Pl(i), n;
      }
      var Brt = ["Cassini", "Cassini_Soldner", "cass"];
      const Mrt = { init: Srt, forward: brt, inverse: Trt, names: Brt };
      function Nl(n, t) {
        var e;
        return n > 1e-7 ? (e = n * t, (1 - n * n) * (t / (1 - e * e) - 0.5 / n * Math.log((1 - e) / (1 + e)))) : 2 * t;
      }
      var Drt = 1, Rrt = 2, Lrt = 3, Prt = 4;
      function Nrt() {
        var n = Math.abs(this.lat0);
        if (Math.abs(n - ut) < vt ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(n) < vt ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
          var t;
          switch (this.qp = Nl(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = jrt(this.es), this.mode) {
            case this.N_POLE:
              this.dd = 1;
              break;
            case this.S_POLE:
              this.dd = 1;
              break;
            case this.EQUIT:
              this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
              break;
            case this.OBLIQ:
              this.rq = Math.sqrt(0.5 * this.qp), t = Math.sin(this.lat0), this.sinb1 = Nl(this.e, t) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * t * t) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
              break;
          }
        } else this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
      }
      function Frt(n) {
        var t, e, i, r, a, o, s, l, u, h, c = n.x, f = n.y;
        if (c = mt(c - this.long0), this.sphere) {
          if (a = Math.sin(f), h = Math.cos(f), i = Math.cos(c), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
            if (e = this.mode === this.EQUIT ? 1 + h * i : 1 + this.sinph0 * a + this.cosph0 * h * i, e <= vt) return null;
            e = Math.sqrt(2 / e), t = e * h * Math.sin(c), e *= this.mode === this.EQUIT ? a : this.cosph0 * a - this.sinph0 * h * i;
          } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
            if (this.mode === this.N_POLE && (i = -i), Math.abs(f + this.lat0) < vt) return null;
            e = Ye - f * 0.5, e = 2 * (this.mode === this.S_POLE ? Math.cos(e) : Math.sin(e)), t = e * Math.sin(c), e *= i;
          }
        } else {
          switch (s = 0, l = 0, u = 0, i = Math.cos(c), r = Math.sin(c), a = Math.sin(f), o = Nl(this.e, a), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (s = o / this.qp, l = Math.sqrt(1 - s * s)), this.mode) {
            case this.OBLIQ:
              u = 1 + this.sinb1 * s + this.cosb1 * l * i;
              break;
            case this.EQUIT:
              u = 1 + l * i;
              break;
            case this.N_POLE:
              u = ut + f, o = this.qp - o;
              break;
            case this.S_POLE:
              u = f - ut, o = this.qp + o;
              break;
          }
          if (Math.abs(u) < vt) return null;
          switch (this.mode) {
            case this.OBLIQ:
            case this.EQUIT:
              u = Math.sqrt(2 / u), this.mode === this.OBLIQ ? e = this.ymf * u * (this.cosb1 * s - this.sinb1 * l * i) : e = (u = Math.sqrt(2 / (1 + l * i))) * s * this.ymf, t = this.xmf * u * l * r;
              break;
            case this.N_POLE:
            case this.S_POLE:
              o >= 0 ? (t = (u = Math.sqrt(o)) * r, e = i * (this.mode === this.S_POLE ? u : -u)) : t = e = 0;
              break;
          }
        }
        return n.x = this.a * t + this.x0, n.y = this.a * e + this.y0, n;
      }
      function krt(n) {
        n.x -= this.x0, n.y -= this.y0;
        var t = n.x / this.a, e = n.y / this.a, i, r, a, o, s, l, u;
        if (this.sphere) {
          var h = 0, c, f = 0;
          if (c = Math.sqrt(t * t + e * e), r = c * 0.5, r > 1) return null;
          switch (r = 2 * Math.asin(r), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (f = Math.sin(r), h = Math.cos(r)), this.mode) {
            case this.EQUIT:
              r = Math.abs(c) <= vt ? 0 : Math.asin(e * f / c), t *= f, e = h * c;
              break;
            case this.OBLIQ:
              r = Math.abs(c) <= vt ? this.lat0 : Math.asin(h * this.sinph0 + e * f * this.cosph0 / c), t *= f * this.cosph0, e = (h - Math.sin(r) * this.sinph0) * c;
              break;
            case this.N_POLE:
              e = -e, r = ut - r;
              break;
            case this.S_POLE:
              r -= ut;
              break;
          }
          i = e === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(t, e);
        } else {
          if (u = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
            if (t /= this.dd, e *= this.dd, l = Math.sqrt(t * t + e * e), l < vt) return n.x = this.long0, n.y = this.lat0, n;
            o = 2 * Math.asin(0.5 * l / this.rq), a = Math.cos(o), t *= o = Math.sin(o), this.mode === this.OBLIQ ? (u = a * this.sinb1 + e * o * this.cosb1 / l, s = this.qp * u, e = l * this.cosb1 * a - e * this.sinb1 * o) : (u = e * o / l, s = this.qp * u, e = l * a);
          } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
            if (this.mode === this.N_POLE && (e = -e), s = t * t + e * e, !s) return n.x = this.long0, n.y = this.lat0, n;
            u = 1 - s / this.qp, this.mode === this.S_POLE && (u = -u);
          }
          i = Math.atan2(t, e), r = qrt(Math.asin(u), this.apa);
        }
        return n.x = mt(this.long0 + i), n.y = r, n;
      }
      var Ort = 0.3333333333333333, Qrt = 0.17222222222222222, zrt = 0.10257936507936508, Grt = 0.06388888888888888, Urt = 0.0664021164021164, Vrt = 0.016415012942191543;
      function jrt(n) {
        var t, e = [];
        return e[0] = n * Ort, t = n * n, e[0] += t * Qrt, e[1] = t * Grt, t *= n, e[0] += t * zrt, e[1] += t * Urt, e[2] = t * Vrt, e;
      }
      function qrt(n, t) {
        var e = n + n;
        return n + t[0] * Math.sin(e) + t[1] * Math.sin(e + e) + t[2] * Math.sin(e + e + e);
      }
      var Hrt = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
      const Yrt = { init: Nrt, forward: Frt, inverse: krt, names: Hrt, S_POLE: Drt, N_POLE: Rrt, EQUIT: Lrt, OBLIQ: Prt };
      function Fl(n) {
        return Math.abs(n) > 1 && (n = n > 1 ? 1 : -1), Math.asin(n);
      }
      function Wrt() {
        Math.abs(this.lat1 + this.lat2) < vt || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = So(this.e3, this.sin_po, this.cos_po), this.qs1 = Nl(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = So(this.e3, this.sin_po, this.cos_po), this.qs2 = Nl(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = Nl(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > vt ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
      }
      function Xrt(n) {
        var t = n.x, e = n.y;
        this.sin_phi = Math.sin(e), this.cos_phi = Math.cos(e);
        var i = Nl(this.e3, this.sin_phi), r = this.a * Math.sqrt(this.c - this.ns0 * i) / this.ns0, a = this.ns0 * mt(t - this.long0), o = r * Math.sin(a) + this.x0, s = this.rh - r * Math.cos(a) + this.y0;
        return n.x = o, n.y = s, n;
      }
      function $rt(n) {
        var t, e, i, r, a, o;
        return n.x -= this.x0, n.y = this.rh - n.y + this.y0, this.ns0 >= 0 ? (t = Math.sqrt(n.x * n.x + n.y * n.y), i = 1) : (t = -Math.sqrt(n.x * n.x + n.y * n.y), i = -1), r = 0, t !== 0 && (r = Math.atan2(i * n.x, i * n.y)), i = t * this.ns0 / this.a, this.sphere ? o = Math.asin((this.c - i * i) / (2 * this.ns0)) : (e = (this.c - i * i) / this.ns0, o = this.phi1z(this.e3, e)), a = mt(r / this.ns0 + this.long0), n.x = a, n.y = o, n;
      }
      function Zrt(n, t) {
        var e, i, r, a, o, s = Fl(0.5 * t);
        if (n < vt) return s;
        for (var l = n * n, u = 1; u <= 25; u++) if (e = Math.sin(s), i = Math.cos(s), r = n * e, a = 1 - r * r, o = 0.5 * a * a / i * (t / (1 - l) - e / a + 0.5 / n * Math.log((1 - r) / (1 + r))), s = s + o, Math.abs(o) <= 1e-7) return s;
        return null;
      }
      var Krt = ["Albers_Conic_Equal_Area", "Albers", "aea"];
      const Jrt = { init: Wrt, forward: Xrt, inverse: $rt, names: Krt, phi1z: Zrt };
      function tat() {
        this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
      }
      function eat(n) {
        var t, e, i, r, a, o, s, l, u = n.x, h = n.y;
        return i = mt(u - this.long0), t = Math.sin(h), e = Math.cos(h), r = Math.cos(i), o = this.sin_p14 * t + this.cos_p14 * e * r, a = 1, o > 0 || Math.abs(o) <= vt ? (s = this.x0 + this.a * a * e * Math.sin(i) / o, l = this.y0 + this.a * a * (this.cos_p14 * t - this.sin_p14 * e * r) / o) : (s = this.x0 + this.infinity_dist * e * Math.sin(i), l = this.y0 + this.infinity_dist * (this.cos_p14 * t - this.sin_p14 * e * r)), n.x = s, n.y = l, n;
      }
      function nat(n) {
        var t, e, i, r, a, o;
        return n.x = (n.x - this.x0) / this.a, n.y = (n.y - this.y0) / this.a, n.x /= this.k0, n.y /= this.k0, (t = Math.sqrt(n.x * n.x + n.y * n.y)) ? (r = Math.atan2(t, this.rc), e = Math.sin(r), i = Math.cos(r), o = Fl(i * this.sin_p14 + n.y * e * this.cos_p14 / t), a = Math.atan2(n.x * e, t * this.cos_p14 * i - n.y * this.sin_p14 * e), a = mt(this.long0 + a)) : (o = this.phic0, a = 0), n.x = a, n.y = o, n;
      }
      var iat = ["gnom"];
      const rat = { init: tat, forward: eat, inverse: nat, names: iat };
      function aat(n, t) {
        var e = 1 - (1 - n * n) / (2 * n) * Math.log((1 - n) / (1 + n));
        if (Math.abs(Math.abs(t) - e) < 1e-6) return t < 0 ? -1 * ut : ut;
        for (var i = Math.asin(0.5 * t), r, a, o, s, l = 0; l < 30; l++) if (a = Math.sin(i), o = Math.cos(i), s = n * a, r = Math.pow(1 - s * s, 2) / (2 * o) * (t / (1 - n * n) - a / (1 - s * s) + 0.5 / n * Math.log((1 - s) / (1 + s))), i += r, Math.abs(r) <= 1e-10) return i;
        return NaN;
      }
      function oat() {
        this.sphere || (this.k0 = So(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
      }
      function sat(n) {
        var t = n.x, e = n.y, i, r, a = mt(t - this.long0);
        if (this.sphere) i = this.x0 + this.a * a * Math.cos(this.lat_ts), r = this.y0 + this.a * Math.sin(e) / Math.cos(this.lat_ts);
        else {
          var o = Nl(this.e, Math.sin(e));
          i = this.x0 + this.a * this.k0 * a, r = this.y0 + this.a * o * 0.5 / this.k0;
        }
        return n.x = i, n.y = r, n;
      }
      function lat(n) {
        n.x -= this.x0, n.y -= this.y0;
        var t, e;
        return this.sphere ? (t = mt(this.long0 + n.x / this.a / Math.cos(this.lat_ts)), e = Math.asin(n.y / this.a * Math.cos(this.lat_ts))) : (e = aat(this.e, 2 * n.y * this.k0 / this.a), t = mt(this.long0 + n.x / (this.a * this.k0))), n.x = t, n.y = e, n;
      }
      var uat = ["cea"];
      const hat = { init: oat, forward: sat, inverse: lat, names: uat };
      function cat() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
      }
      function fat(n) {
        var t = n.x, e = n.y, i = mt(t - this.long0), r = Pl(e - this.lat0);
        return n.x = this.x0 + this.a * i * this.rc, n.y = this.y0 + this.a * r, n;
      }
      function gat(n) {
        var t = n.x, e = n.y;
        return n.x = mt(this.long0 + (t - this.x0) / (this.a * this.rc)), n.y = Pl(this.lat0 + (e - this.y0) / this.a), n;
      }
      var dat = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
      const Aat = { init: cat, forward: fat, inverse: gat, names: dat };
      var sO = 20;
      function pat() {
        this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = VA(this.es), this.e1 = jA(this.es), this.e2 = qA(this.es), this.e3 = HA(this.es), this.ml0 = this.a * Vi(this.e0, this.e1, this.e2, this.e3, this.lat0);
      }
      function vat(n) {
        var t = n.x, e = n.y, i, r, a, o = mt(t - this.long0);
        if (a = o * Math.sin(e), this.sphere) Math.abs(e) <= vt ? (i = this.a * o, r = -1 * this.a * this.lat0) : (i = this.a * Math.sin(a) / Math.tan(e), r = this.a * (Pl(e - this.lat0) + (1 - Math.cos(a)) / Math.tan(e)));
        else if (Math.abs(e) <= vt) i = this.a * o, r = -1 * this.ml0;
        else {
          var s = Ff(this.a, this.e, Math.sin(e)) / Math.tan(e);
          i = s * Math.sin(a), r = this.a * Vi(this.e0, this.e1, this.e2, this.e3, e) - this.ml0 + s * (1 - Math.cos(a));
        }
        return n.x = i + this.x0, n.y = r + this.y0, n;
      }
      function yat(n) {
        var t, e, i, r, a, o, s, l, u;
        if (i = n.x - this.x0, r = n.y - this.y0, this.sphere) if (Math.abs(r + this.a * this.lat0) <= vt) t = mt(i / this.a + this.long0), e = 0;
        else {
          o = this.lat0 + r / this.a, s = i * i / this.a / this.a + o * o, l = o;
          var h;
          for (a = sO; a; --a) if (h = Math.tan(l), u = -1 * (o * (l * h + 1) - l - 0.5 * (l * l + s) * h) / ((l - o) / h - 1), l += u, Math.abs(u) <= vt) {
            e = l;
            break;
          }
          t = mt(this.long0 + Math.asin(i * Math.tan(l) / this.a) / Math.sin(e));
        }
        else if (Math.abs(r + this.ml0) <= vt) e = 0, t = mt(this.long0 + i / this.a);
        else {
          o = (this.ml0 + r) / this.a, s = i * i / this.a / this.a + o * o, l = o;
          var c, f, g, d, A;
          for (a = sO; a; --a) if (A = this.e * Math.sin(l), c = Math.sqrt(1 - A * A) * Math.tan(l), f = this.a * Vi(this.e0, this.e1, this.e2, this.e3, l), g = this.e0 - 2 * this.e1 * Math.cos(2 * l) + 4 * this.e2 * Math.cos(4 * l) - 6 * this.e3 * Math.cos(6 * l), d = f / this.a, u = (o * (c * d + 1) - d - 0.5 * c * (d * d + s)) / (this.es * Math.sin(2 * l) * (d * d + s - 2 * o * d) / (4 * c) + (o - d) * (c * g - 2 / Math.sin(2 * l)) - g), l -= u, Math.abs(u) <= vt) {
            e = l;
            break;
          }
          c = Math.sqrt(1 - this.es * Math.pow(Math.sin(e), 2)) * Math.tan(e), t = mt(this.long0 + Math.asin(i * c / this.a) / Math.sin(e));
        }
        return n.x = t, n.y = e, n;
      }
      var mat = ["Polyconic", "poly"];
      const _at = { init: pat, forward: vat, inverse: yat, names: mat };
      function Eat() {
        this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
      }
      function Iat(n) {
        var t, e = n.x, i = n.y, r = i - this.lat0, a = e - this.long0, o = r / FA * 1e-5, s = a, l = 1, u = 0;
        for (t = 1; t <= 10; t++) l = l * o, u = u + this.A[t] * l;
        var h = u, c = s, f = 1, g = 0, d, A, p = 0, v = 0;
        for (t = 1; t <= 6; t++) d = f * h - g * c, A = g * h + f * c, f = d, g = A, p = p + this.B_re[t] * f - this.B_im[t] * g, v = v + this.B_im[t] * f + this.B_re[t] * g;
        return n.x = v * this.a + this.x0, n.y = p * this.a + this.y0, n;
      }
      function xat(n) {
        var t, e = n.x, i = n.y, r = e - this.x0, a = i - this.y0, o = a / this.a, s = r / this.a, l = 1, u = 0, h, c, f = 0, g = 0;
        for (t = 1; t <= 6; t++) h = l * o - u * s, c = u * o + l * s, l = h, u = c, f = f + this.C_re[t] * l - this.C_im[t] * u, g = g + this.C_im[t] * l + this.C_re[t] * u;
        for (var d = 0; d < this.iterations; d++) {
          var A = f, p = g, v, y, m = o, _ = s;
          for (t = 2; t <= 6; t++) v = A * f - p * g, y = p * f + A * g, A = v, p = y, m = m + (t - 1) * (this.B_re[t] * A - this.B_im[t] * p), _ = _ + (t - 1) * (this.B_im[t] * A + this.B_re[t] * p);
          A = 1, p = 0;
          var I = this.B_re[1], E = this.B_im[1];
          for (t = 2; t <= 6; t++) v = A * f - p * g, y = p * f + A * g, A = v, p = y, I = I + t * (this.B_re[t] * A - this.B_im[t] * p), E = E + t * (this.B_im[t] * A + this.B_re[t] * p);
          var x = I * I + E * E;
          f = (m * I + _ * E) / x, g = (_ * I - m * E) / x;
        }
        var w = f, C = g, S = 1, b = 0;
        for (t = 1; t <= 9; t++) S = S * w, b = b + this.D[t] * S;
        var T = this.lat0 + b * FA * 1e5, B = this.long0 + C;
        return n.x = B, n.y = T, n;
      }
      var wat = ["New_Zealand_Map_Grid", "nzmg"];
      const Cat = { init: Eat, forward: Iat, inverse: xat, names: wat };
      function Sat() {
      }
      function bat(n) {
        var t = n.x, e = n.y, i = mt(t - this.long0), r = this.x0 + this.a * i, a = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + e / 2.5)) * 1.25;
        return n.x = r, n.y = a, n;
      }
      function Tat(n) {
        n.x -= this.x0, n.y -= this.y0;
        var t = mt(this.long0 + n.x / this.a), e = 2.5 * (Math.atan(Math.exp(0.8 * n.y / this.a)) - Math.PI / 4);
        return n.x = t, n.y = e, n;
      }
      var Bat = ["Miller_Cylindrical", "mill"];
      const Mat = { init: Sat, forward: bat, inverse: Tat, names: Bat };
      var Dat = 20;
      function Rat() {
        this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = uC(this.es);
      }
      function Lat(n) {
        var t, e, i = n.x, r = n.y;
        if (i = mt(i - this.long0), this.sphere) {
          if (!this.m) r = this.n !== 1 ? Math.asin(this.n * Math.sin(r)) : r;
          else for (var a = this.n * Math.sin(r), o = Dat; o; --o) {
            var s = (this.m * r + Math.sin(r) - a) / (this.m + Math.cos(r));
            if (r -= s, Math.abs(s) < vt) break;
          }
          t = this.a * this.C_x * i * (this.m + Math.cos(r)), e = this.a * this.C_y * r;
        } else {
          var l = Math.sin(r), u = Math.cos(r);
          e = this.a * Pf(r, l, u, this.en), t = this.a * i * u / Math.sqrt(1 - this.es * l * l);
        }
        return n.x = t, n.y = e, n;
      }
      function Pat(n) {
        var t, e, i, r;
        return n.x -= this.x0, i = n.x / this.a, n.y -= this.y0, t = n.y / this.a, this.sphere ? (t /= this.C_y, i = i / (this.C_x * (this.m + Math.cos(t))), this.m ? t = Fl((this.m * t + Math.sin(t)) / this.n) : this.n !== 1 && (t = Fl(Math.sin(t) / this.n)), i = mt(i + this.long0), t = Pl(t)) : (t = hC(n.y / this.a, this.es, this.en), r = Math.abs(t), r < ut ? (r = Math.sin(t), e = this.long0 + n.x * Math.sqrt(1 - this.es * r * r) / (this.a * Math.cos(t)), i = mt(e)) : r - vt < ut && (i = this.long0)), n.x = i, n.y = t, n;
      }
      var Nat = ["Sinusoidal", "sinu"];
      const Fat = { init: Rat, forward: Lat, inverse: Pat, names: Nat };
      function kat() {
      }
      function Oat(n) {
        for (var t = n.x, e = n.y, i = mt(t - this.long0), r = e, a = Math.PI * Math.sin(e); ; ) {
          var o = -(r + Math.sin(r) - a) / (1 + Math.cos(r));
          if (r += o, Math.abs(o) < vt) break;
        }
        r /= 2, Math.PI / 2 - Math.abs(e) < vt && (i = 0);
        var s = 0.900316316158 * this.a * i * Math.cos(r) + this.x0, l = 1.4142135623731 * this.a * Math.sin(r) + this.y0;
        return n.x = s, n.y = l, n;
      }
      function Qat(n) {
        var t, e;
        n.x -= this.x0, n.y -= this.y0, e = n.y / (1.4142135623731 * this.a), Math.abs(e) > 0.999999999999 && (e = 0.999999999999), t = Math.asin(e);
        var i = mt(this.long0 + n.x / (0.900316316158 * this.a * Math.cos(t)));
        i < -Math.PI && (i = -Math.PI), i > Math.PI && (i = Math.PI), e = (2 * t + Math.sin(2 * t)) / Math.PI, Math.abs(e) > 1 && (e = 1);
        var r = Math.asin(e);
        return n.x = i, n.y = r, n;
      }
      var zat = ["Mollweide", "moll"];
      const Gat = { init: kat, forward: Oat, inverse: Qat, names: zat };
      function Uat() {
        Math.abs(this.lat1 + this.lat2) < vt || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = VA(this.es), this.e1 = jA(this.es), this.e2 = qA(this.es), this.e3 = HA(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = So(this.e, this.sinphi, this.cosphi), this.ml1 = Vi(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < vt ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = So(this.e, this.sinphi, this.cosphi), this.ml2 = Vi(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = Vi(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
      }
      function Vat(n) {
        var t = n.x, e = n.y, i;
        if (this.sphere) i = this.a * (this.g - e);
        else {
          var r = Vi(this.e0, this.e1, this.e2, this.e3, e);
          i = this.a * (this.g - r);
        }
        var a = this.ns * mt(t - this.long0), o = this.x0 + i * Math.sin(a), s = this.y0 + this.rh - i * Math.cos(a);
        return n.x = o, n.y = s, n;
      }
      function jat(n) {
        n.x -= this.x0, n.y = this.rh - n.y + this.y0;
        var t, e, i, r;
        this.ns >= 0 ? (e = Math.sqrt(n.x * n.x + n.y * n.y), t = 1) : (e = -Math.sqrt(n.x * n.x + n.y * n.y), t = -1);
        var a = 0;
        if (e !== 0 && (a = Math.atan2(t * n.x, t * n.y)), this.sphere) return r = mt(this.long0 + a / this.ns), i = Pl(this.g - e / this.a), n.x = r, n.y = i, n;
        var o = this.g - e / this.a;
        return i = m0(o, this.e0, this.e1, this.e2, this.e3), r = mt(this.long0 + a / this.ns), n.x = r, n.y = i, n;
      }
      var qat = ["Equidistant_Conic", "eqdc"];
      const Hat = { init: Uat, forward: Vat, inverse: jat, names: qat };
      function Yat() {
        this.R = this.a;
      }
      function Wat(n) {
        var t = n.x, e = n.y, i = mt(t - this.long0), r, a;
        Math.abs(e) <= vt && (r = this.x0 + this.R * i, a = this.y0);
        var o = Fl(2 * Math.abs(e / Math.PI));
        (Math.abs(i) <= vt || Math.abs(Math.abs(e) - ut) <= vt) && (r = this.x0, e >= 0 ? a = this.y0 + Math.PI * this.R * Math.tan(0.5 * o) : a = this.y0 + Math.PI * this.R * -Math.tan(0.5 * o));
        var s = 0.5 * Math.abs(Math.PI / i - i / Math.PI), l = s * s, u = Math.sin(o), h = Math.cos(o), c = h / (u + h - 1), f = c * c, g = c * (2 / u - 1), d = g * g, A = Math.PI * this.R * (s * (c - d) + Math.sqrt(l * (c - d) * (c - d) - (d + l) * (f - d))) / (d + l);
        i < 0 && (A = -A), r = this.x0 + A;
        var p = l + c;
        return A = Math.PI * this.R * (g * p - s * Math.sqrt((d + l) * (l + 1) - p * p)) / (d + l), e >= 0 ? a = this.y0 + A : a = this.y0 - A, n.x = r, n.y = a, n;
      }
      function Xat(n) {
        var t, e, i, r, a, o, s, l, u, h, c, f, g;
        return n.x -= this.x0, n.y -= this.y0, c = Math.PI * this.R, i = n.x / c, r = n.y / c, a = i * i + r * r, o = -Math.abs(r) * (1 + a), s = o - 2 * r * r + i * i, l = -2 * o + 1 + 2 * r * r + a * a, g = r * r / l + (2 * s * s * s / l / l / l - 9 * o * s / l / l) / 27, u = (o - s * s / 3 / l) / l, h = 2 * Math.sqrt(-u / 3), c = 3 * g / u / h, Math.abs(c) > 1 && (c >= 0 ? c = 1 : c = -1), f = Math.acos(c) / 3, n.y >= 0 ? e = (-h * Math.cos(f + Math.PI / 3) - s / 3 / l) * Math.PI : e = -(-h * Math.cos(f + Math.PI / 3) - s / 3 / l) * Math.PI, Math.abs(i) < vt ? t = this.long0 : t = mt(this.long0 + Math.PI * (a - 1 + Math.sqrt(1 + 2 * (i * i - r * r) + a * a)) / 2 / i), n.x = t, n.y = e, n;
      }
      var $at = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
      const Zat = { init: Yat, forward: Wat, inverse: Xat, names: $at };
      function Kat() {
        this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
      }
      function Jat(n) {
        var t = n.x, e = n.y, i = Math.sin(n.y), r = Math.cos(n.y), a = mt(t - this.long0), o, s, l, u, h, c, f, g, d, A, p, v, y, m, _, I, E, x, w, C, S, b, T;
        return this.sphere ? Math.abs(this.sin_p12 - 1) <= vt ? (n.x = this.x0 + this.a * (ut - e) * Math.sin(a), n.y = this.y0 - this.a * (ut - e) * Math.cos(a), n) : Math.abs(this.sin_p12 + 1) <= vt ? (n.x = this.x0 + this.a * (ut + e) * Math.sin(a), n.y = this.y0 + this.a * (ut + e) * Math.cos(a), n) : (x = this.sin_p12 * i + this.cos_p12 * r * Math.cos(a), I = Math.acos(x), E = I ? I / Math.sin(I) : 1, n.x = this.x0 + this.a * E * r * Math.sin(a), n.y = this.y0 + this.a * E * (this.cos_p12 * i - this.sin_p12 * r * Math.cos(a)), n) : (o = VA(this.es), s = jA(this.es), l = qA(this.es), u = HA(this.es), Math.abs(this.sin_p12 - 1) <= vt ? (h = this.a * Vi(o, s, l, u, ut), c = this.a * Vi(o, s, l, u, e), n.x = this.x0 + (h - c) * Math.sin(a), n.y = this.y0 - (h - c) * Math.cos(a), n) : Math.abs(this.sin_p12 + 1) <= vt ? (h = this.a * Vi(o, s, l, u, ut), c = this.a * Vi(o, s, l, u, e), n.x = this.x0 + (h + c) * Math.sin(a), n.y = this.y0 + (h + c) * Math.cos(a), n) : (f = i / r, g = Ff(this.a, this.e, this.sin_p12), d = Ff(this.a, this.e, i), A = Math.atan((1 - this.es) * f + this.es * g * this.sin_p12 / (d * r)), p = Math.atan2(Math.sin(a), this.cos_p12 * Math.tan(A) - this.sin_p12 * Math.cos(a)), p === 0 ? w = Math.asin(this.cos_p12 * Math.sin(A) - this.sin_p12 * Math.cos(A)) : Math.abs(Math.abs(p) - Math.PI) <= vt ? w = -Math.asin(this.cos_p12 * Math.sin(A) - this.sin_p12 * Math.cos(A)) : w = Math.asin(Math.sin(a) * Math.cos(A) / Math.sin(p)), v = this.e * this.sin_p12 / Math.sqrt(1 - this.es), y = this.e * this.cos_p12 * Math.cos(p) / Math.sqrt(1 - this.es), m = v * y, _ = y * y, C = w * w, S = C * w, b = S * w, T = b * w, I = g * w * (1 - C * _ * (1 - _) / 6 + S / 8 * m * (1 - 2 * _) + b / 120 * (_ * (4 - 7 * _) - 3 * v * v * (1 - 7 * _)) - T / 48 * m), n.x = this.x0 + I * Math.sin(p), n.y = this.y0 + I * Math.cos(p), n));
      }
      function tot(n) {
        n.x -= this.x0, n.y -= this.y0;
        var t, e, i, r, a, o, s, l, u, h, c, f, g, d, A, p, v, y, m, _, I, E, x, w;
        return this.sphere ? (t = Math.sqrt(n.x * n.x + n.y * n.y), t > 2 * ut * this.a ? void 0 : (e = t / this.a, i = Math.sin(e), r = Math.cos(e), a = this.long0, Math.abs(t) <= vt ? o = this.lat0 : (o = Fl(r * this.sin_p12 + n.y * i * this.cos_p12 / t), s = Math.abs(this.lat0) - ut, Math.abs(s) <= vt ? this.lat0 >= 0 ? a = mt(this.long0 + Math.atan2(n.x, -n.y)) : a = mt(this.long0 - Math.atan2(-n.x, n.y)) : a = mt(this.long0 + Math.atan2(n.x * i, t * this.cos_p12 * r - n.y * this.sin_p12 * i))), n.x = a, n.y = o, n)) : (l = VA(this.es), u = jA(this.es), h = qA(this.es), c = HA(this.es), Math.abs(this.sin_p12 - 1) <= vt ? (f = this.a * Vi(l, u, h, c, ut), t = Math.sqrt(n.x * n.x + n.y * n.y), g = f - t, o = m0(g / this.a, l, u, h, c), a = mt(this.long0 + Math.atan2(n.x, -1 * n.y)), n.x = a, n.y = o, n) : Math.abs(this.sin_p12 + 1) <= vt ? (f = this.a * Vi(l, u, h, c, ut), t = Math.sqrt(n.x * n.x + n.y * n.y), g = t - f, o = m0(g / this.a, l, u, h, c), a = mt(this.long0 + Math.atan2(n.x, n.y)), n.x = a, n.y = o, n) : (t = Math.sqrt(n.x * n.x + n.y * n.y), p = Math.atan2(n.x, n.y), d = Ff(this.a, this.e, this.sin_p12), v = Math.cos(p), y = this.e * this.cos_p12 * v, m = -y * y / (1 - this.es), _ = 3 * this.es * (1 - m) * this.sin_p12 * this.cos_p12 * v / (1 - this.es), I = t / d, E = I - m * (1 + m) * Math.pow(I, 3) / 6 - _ * (1 + 3 * m) * Math.pow(I, 4) / 24, x = 1 - m * E * E / 2 - I * E * E * E / 6, A = Math.asin(this.sin_p12 * Math.cos(E) + this.cos_p12 * Math.sin(E) * v), a = mt(this.long0 + Math.asin(Math.sin(p) * Math.sin(E) / Math.cos(A))), w = Math.sin(A), o = Math.atan2((w - this.es * x * this.sin_p12) * Math.tan(A), w * (1 - this.es)), n.x = a, n.y = o, n));
      }
      var eot = ["Azimuthal_Equidistant", "aeqd"];
      const not = { init: Kat, forward: Jat, inverse: tot, names: eot };
      function iot() {
        this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
      }
      function rot(n) {
        var t, e, i, r, a, o, s, l, u = n.x, h = n.y;
        return i = mt(u - this.long0), t = Math.sin(h), e = Math.cos(h), r = Math.cos(i), o = this.sin_p14 * t + this.cos_p14 * e * r, a = 1, (o > 0 || Math.abs(o) <= vt) && (s = this.a * a * e * Math.sin(i), l = this.y0 + this.a * a * (this.cos_p14 * t - this.sin_p14 * e * r)), n.x = s, n.y = l, n;
      }
      function aot(n) {
        var t, e, i, r, a, o, s;
        return n.x -= this.x0, n.y -= this.y0, t = Math.sqrt(n.x * n.x + n.y * n.y), e = Fl(t / this.a), i = Math.sin(e), r = Math.cos(e), o = this.long0, Math.abs(t) <= vt ? (s = this.lat0, n.x = o, n.y = s, n) : (s = Fl(r * this.sin_p14 + n.y * i * this.cos_p14 / t), a = Math.abs(this.lat0) - ut, Math.abs(a) <= vt ? (this.lat0 >= 0 ? o = mt(this.long0 + Math.atan2(n.x, -n.y)) : o = mt(this.long0 - Math.atan2(-n.x, n.y)), n.x = o, n.y = s, n) : (o = mt(this.long0 + Math.atan2(n.x * i, t * this.cos_p14 * r - n.y * this.sin_p14 * i)), n.x = o, n.y = s, n));
      }
      var oot = ["ortho"];
      const sot = { init: iot, forward: rot, inverse: aot, names: oot };
      var mn = { FRONT: 1, RIGHT: 2, BACK: 3, LEFT: 4, TOP: 5, BOTTOM: 6 }, We = { AREA_0: 1, AREA_1: 2, AREA_2: 3, AREA_3: 4 };
      function lot() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= ut - Ye / 2 ? this.face = mn.TOP : this.lat0 <= -(ut - Ye / 2) ? this.face = mn.BOTTOM : Math.abs(this.long0) <= Ye ? this.face = mn.FRONT : Math.abs(this.long0) <= ut + Ye ? this.face = this.long0 > 0 ? mn.RIGHT : mn.LEFT : this.face = mn.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
      }
      function uot(n) {
        var t = { x: 0, y: 0 }, e, i, r, a, o, s, l = { value: 0 };
        if (n.x -= this.long0, this.es !== 0 ? e = Math.atan(this.one_minus_f_squared * Math.tan(n.y)) : e = n.y, i = n.x, this.face === mn.TOP) a = ut - e, i >= Ye && i <= ut + Ye ? (l.value = We.AREA_0, r = i - ut) : i > ut + Ye || i <= -(ut + Ye) ? (l.value = We.AREA_1, r = i > 0 ? i - Pn : i + Pn) : i > -(ut + Ye) && i <= -Ye ? (l.value = We.AREA_2, r = i + ut) : (l.value = We.AREA_3, r = i);
        else if (this.face === mn.BOTTOM) a = ut + e, i >= Ye && i <= ut + Ye ? (l.value = We.AREA_0, r = -i + ut) : i < Ye && i >= -Ye ? (l.value = We.AREA_1, r = -i) : i < -Ye && i >= -(ut + Ye) ? (l.value = We.AREA_2, r = -i - ut) : (l.value = We.AREA_3, r = i > 0 ? -i + Pn : -i - Pn);
        else {
          var u, h, c, f, g, d, A;
          this.face === mn.RIGHT ? i = kf(i, +ut) : this.face === mn.BACK ? i = kf(i, +Pn) : this.face === mn.LEFT && (i = kf(i, -ut)), f = Math.sin(e), g = Math.cos(e), d = Math.sin(i), A = Math.cos(i), u = g * A, h = g * d, c = f, this.face === mn.FRONT ? (a = Math.acos(u), r = _0(a, c, h, l)) : this.face === mn.RIGHT ? (a = Math.acos(h), r = _0(a, c, -u, l)) : this.face === mn.BACK ? (a = Math.acos(-u), r = _0(a, c, -h, l)) : this.face === mn.LEFT ? (a = Math.acos(-h), r = _0(a, c, u, l)) : (a = r = 0, l.value = We.AREA_0);
        }
        return s = Math.atan(12 / Pn * (r + Math.acos(Math.sin(r) * Math.cos(Ye)) - ut)), o = Math.sqrt((1 - Math.cos(a)) / (Math.cos(s) * Math.cos(s)) / (1 - Math.cos(Math.atan(1 / Math.cos(r))))), l.value === We.AREA_1 ? s += ut : l.value === We.AREA_2 ? s += Pn : l.value === We.AREA_3 && (s += 1.5 * Pn), t.x = o * Math.cos(s), t.y = o * Math.sin(s), t.x = t.x * this.a + this.x0, t.y = t.y * this.a + this.y0, n.x = t.x, n.y = t.y, n;
      }
      function hot(n) {
        var t = { lam: 0, phi: 0 }, e, i, r, a, o, s, l, u, h, c = { value: 0 };
        if (n.x = (n.x - this.x0) / this.a, n.y = (n.y - this.y0) / this.a, i = Math.atan(Math.sqrt(n.x * n.x + n.y * n.y)), e = Math.atan2(n.y, n.x), n.x >= 0 && n.x >= Math.abs(n.y) ? c.value = We.AREA_0 : n.y >= 0 && n.y >= Math.abs(n.x) ? (c.value = We.AREA_1, e -= ut) : n.x < 0 && -n.x >= Math.abs(n.y) ? (c.value = We.AREA_2, e = e < 0 ? e + Pn : e - Pn) : (c.value = We.AREA_3, e += ut), h = Pn / 12 * Math.tan(e), o = Math.sin(h) / (Math.cos(h) - 1 / Math.sqrt(2)), s = Math.atan(o), r = Math.cos(e), a = Math.tan(i), l = 1 - r * r * a * a * (1 - Math.cos(Math.atan(1 / Math.cos(s)))), l < -1 ? l = -1 : l > 1 && (l = 1), this.face === mn.TOP) u = Math.acos(l), t.phi = ut - u, c.value === We.AREA_0 ? t.lam = s + ut : c.value === We.AREA_1 ? t.lam = s < 0 ? s + Pn : s - Pn : c.value === We.AREA_2 ? t.lam = s - ut : t.lam = s;
        else if (this.face === mn.BOTTOM) u = Math.acos(l), t.phi = u - ut, c.value === We.AREA_0 ? t.lam = -s + ut : c.value === We.AREA_1 ? t.lam = -s : c.value === We.AREA_2 ? t.lam = -s - ut : t.lam = s < 0 ? -s - Pn : -s + Pn;
        else {
          var f, g, d;
          f = l, h = f * f, h >= 1 ? d = 0 : d = Math.sqrt(1 - h) * Math.sin(s), h += d * d, h >= 1 ? g = 0 : g = Math.sqrt(1 - h), c.value === We.AREA_1 ? (h = g, g = -d, d = h) : c.value === We.AREA_2 ? (g = -g, d = -d) : c.value === We.AREA_3 && (h = g, g = d, d = -h), this.face === mn.RIGHT ? (h = f, f = -g, g = h) : this.face === mn.BACK ? (f = -f, g = -g) : this.face === mn.LEFT && (h = f, f = g, g = -h), t.phi = Math.acos(-d) - ut, t.lam = Math.atan2(g, f), this.face === mn.RIGHT ? t.lam = kf(t.lam, -ut) : this.face === mn.BACK ? t.lam = kf(t.lam, -Pn) : this.face === mn.LEFT && (t.lam = kf(t.lam, +ut));
        }
        if (this.es !== 0) {
          var A, p, v;
          A = t.phi < 0 ? 1 : 0, p = Math.tan(t.phi), v = this.b / Math.sqrt(p * p + this.one_minus_f_squared), t.phi = Math.atan(Math.sqrt(this.a * this.a - v * v) / (this.one_minus_f * v)), A && (t.phi = -t.phi);
        }
        return t.lam += this.long0, n.x = t.lam, n.y = t.phi, n;
      }
      function _0(n, t, e, i) {
        var r;
        return n < vt ? (i.value = We.AREA_0, r = 0) : (r = Math.atan2(t, e), Math.abs(r) <= Ye ? i.value = We.AREA_0 : r > Ye && r <= ut + Ye ? (i.value = We.AREA_1, r -= ut) : r > ut + Ye || r <= -(ut + Ye) ? (i.value = We.AREA_2, r = r >= 0 ? r - Pn : r + Pn) : (i.value = We.AREA_3, r += ut)), r;
      }
      function kf(n, t) {
        var e = n + t;
        return e < -Pn ? e += kA : e > +Pn && (e -= kA), e;
      }
      var cot = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
      const fot = { init: lot, forward: uot, inverse: hot, names: cot };
      var dC = [[1, 22199e-21, -715515e-10, 31103e-10], [0.9986, -482243e-9, -24897e-9, -13309e-10], [0.9954, -83103e-8, -448605e-10, -986701e-12], [0.99, -135364e-8, -59661e-9, 36777e-10], [0.9822, -167442e-8, -449547e-11, -572411e-11], [0.973, -214868e-8, -903571e-10, 18736e-12], [0.96, -305085e-8, -900761e-10, 164917e-11], [0.9427, -382792e-8, -653386e-10, -26154e-10], [0.9216, -467746e-8, -10457e-8, 481243e-11], [0.8962, -536223e-8, -323831e-10, -543432e-11], [0.8679, -609363e-8, -113898e-9, 332484e-11], [0.835, -698325e-8, -640253e-10, 934959e-12], [0.7986, -755338e-8, -500009e-10, 935324e-12], [0.7597, -798324e-8, -35971e-9, -227626e-11], [0.7186, -851367e-8, -701149e-10, -86303e-10], [0.6732, -986209e-8, -199569e-9, 191974e-10], [0.6213, -0.010418, 883923e-10, 624051e-11], [0.5722, -906601e-8, 182e-6, 624051e-11], [0.5322, -677797e-8, 275608e-9, 624051e-11]], YA = [[-520417e-23, 0.0124, 121431e-23, -845284e-16], [0.062, 0.0124, -126793e-14, 422642e-15], [0.124, 0.0124, 507171e-14, -160604e-14], [0.186, 0.0123999, -190189e-13, 600152e-14], [0.248, 0.0124002, 710039e-13, -224e-10], [0.31, 0.0123992, -264997e-12, 835986e-13], [0.372, 0.0124029, 988983e-12, -311994e-12], [0.434, 0.0123893, -369093e-11, -435621e-12], [0.4958, 0.0123198, -102252e-10, -345523e-12], [0.5571, 0.0121916, -154081e-10, -582288e-12], [0.6176, 0.0119938, -241424e-10, -525327e-12], [0.6769, 0.011713, -320223e-10, -516405e-12], [0.7346, 0.0113541, -397684e-10, -609052e-12], [0.7903, 0.0109107, -489042e-10, -104739e-11], [0.8435, 0.0103431, -64615e-9, -140374e-14], [0.8936, 969686e-8, -64636e-9, -8547e-9], [0.9394, 840947e-8, -192841e-9, -42106e-10], [0.9761, 616527e-8, -256e-6, -42106e-10], [1, 328947e-8, -319159e-9, -42106e-10]], lO = 0.8487, uO = 1.3523, hO = Rl / 5, got = 1 / hO, Of = 18, E0 = function(n, t) {
        return n[0] + t * (n[1] + t * (n[2] + t * n[3]));
      }, dot = function(n, t) {
        return n[1] + t * (2 * n[2] + t * 3 * n[3]);
      };
      function Aot(n, t, e, i) {
        for (var r = t; i; --i) {
          var a = n(r);
          if (r -= a, Math.abs(a) < e) break;
        }
        return r;
      }
      function pot() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
      }
      function vot(n) {
        var t = mt(n.x - this.long0), e = Math.abs(n.y), i = Math.floor(e * hO);
        i < 0 ? i = 0 : i >= Of && (i = Of - 1), e = Rl * (e - got * i);
        var r = { x: E0(dC[i], e) * t, y: E0(YA[i], e) };
        return n.y < 0 && (r.y = -r.y), r.x = r.x * this.a * lO + this.x0, r.y = r.y * this.a * uO + this.y0, r;
      }
      function yot(n) {
        var t = { x: (n.x - this.x0) / (this.a * lO), y: Math.abs(n.y - this.y0) / (this.a * uO) };
        if (t.y >= 1) t.x /= dC[Of][0], t.y = n.y < 0 ? -ut : ut;
        else {
          var e = Math.floor(t.y * Of);
          for (e < 0 ? e = 0 : e >= Of && (e = Of - 1); ; ) if (YA[e][0] > t.y) --e;
          else if (YA[e + 1][0] <= t.y) ++e;
          else break;
          var i = YA[e], r = 5 * (t.y - i[0]) / (YA[e + 1][0] - i[0]);
          r = Aot(function(a) {
            return (E0(i, a) - t.y) / dot(i, a);
          }, r, vt, 100), t.x /= E0(dC[e], r), t.y = (5 * e + r) * yi, n.y < 0 && (t.y = -t.y);
        }
        return t.x = mt(t.x + this.long0), t;
      }
      var mot = ["Robinson", "robin"];
      const _ot = { init: pot, forward: vot, inverse: yot, names: mot };
      function Eot() {
        this.name = "geocent";
      }
      function Iot(n) {
        var t = Qk(n, this.es, this.a);
        return t;
      }
      function xot(n) {
        var t = zk(n, this.es, this.a, this.b);
        return t;
      }
      var wot = ["Geocentric", "geocentric", "geocent", "Geocent"];
      const Cot = { init: Eot, forward: Iot, inverse: xot, names: wot };
      var Di = { N_POLE: 0, S_POLE: 1, EQUIT: 2, OBLIQ: 3 }, WA = { h: { def: 1e5, num: true }, azi: { def: 0, num: true, degrees: true }, tilt: { def: 0, num: true, degrees: true }, long0: { def: 0, num: true }, lat0: { def: 0, num: true } };
      function Sot() {
        if (Object.keys(WA).forEach((function(e) {
          if (typeof this[e] == "undefined") this[e] = WA[e].def;
          else {
            if (WA[e].num && isNaN(this[e])) throw new Error("Invalid parameter value, must be numeric " + e + " = " + this[e]);
            WA[e].num && (this[e] = parseFloat(this[e]));
          }
          WA[e].degrees && (this[e] = this[e] * yi);
        }).bind(this)), Math.abs(Math.abs(this.lat0) - ut) < vt ? this.mode = this.lat0 < 0 ? Di.S_POLE : Di.N_POLE : Math.abs(this.lat0) < vt ? this.mode = Di.EQUIT : (this.mode = Di.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10) throw new Error("Invalid height");
        this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
        var n = this.tilt, t = this.azi;
        this.cg = Math.cos(t), this.sg = Math.sin(t), this.cw = Math.cos(n), this.sw = Math.sin(n);
      }
      function bot(n) {
        n.x -= this.long0;
        var t = Math.sin(n.y), e = Math.cos(n.y), i = Math.cos(n.x), r, a;
        switch (this.mode) {
          case Di.OBLIQ:
            a = this.sinph0 * t + this.cosph0 * e * i;
            break;
          case Di.EQUIT:
            a = e * i;
            break;
          case Di.S_POLE:
            a = -t;
            break;
          case Di.N_POLE:
            a = t;
            break;
        }
        switch (a = this.pn1 / (this.p - a), r = a * e * Math.sin(n.x), this.mode) {
          case Di.OBLIQ:
            a *= this.cosph0 * t - this.sinph0 * e * i;
            break;
          case Di.EQUIT:
            a *= t;
            break;
          case Di.N_POLE:
            a *= -(e * i);
            break;
          case Di.S_POLE:
            a *= e * i;
            break;
        }
        var o, s;
        return o = a * this.cg + r * this.sg, s = 1 / (o * this.sw * this.h1 + this.cw), r = (r * this.cg - a * this.sg) * this.cw * s, a = o * s, n.x = r * this.a, n.y = a * this.a, n;
      }
      function Tot(n) {
        n.x /= this.a, n.y /= this.a;
        var t = { x: n.x, y: n.y }, e, i, r;
        r = 1 / (this.pn1 - n.y * this.sw), e = this.pn1 * n.x * r, i = this.pn1 * n.y * this.cw * r, n.x = e * this.cg + i * this.sg, n.y = i * this.cg - e * this.sg;
        var a = Ar(n.x, n.y);
        if (Math.abs(a) < vt) t.x = 0, t.y = n.y;
        else {
          var o, s;
          switch (s = 1 - a * a * this.pfact, s = (this.p - Math.sqrt(s)) / (this.pn1 / a + a / this.pn1), o = Math.sqrt(1 - s * s), this.mode) {
            case Di.OBLIQ:
              t.y = Math.asin(o * this.sinph0 + n.y * s * this.cosph0 / a), n.y = (o - this.sinph0 * Math.sin(t.y)) * a, n.x *= s * this.cosph0;
              break;
            case Di.EQUIT:
              t.y = Math.asin(n.y * s / a), n.y = o * a, n.x *= s;
              break;
            case Di.N_POLE:
              t.y = Math.asin(o), n.y = -n.y;
              break;
            case Di.S_POLE:
              t.y = -Math.asin(o);
              break;
          }
          t.x = Math.atan2(n.x, n.y);
        }
        return n.x = t.x + this.long0, n.y = t.y, n;
      }
      var Bot = ["Tilted_Perspective", "tpers"];
      const Mot = { init: Sot, forward: bot, inverse: Tot, names: Bot };
      function Dot() {
        if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) throw new Error();
        if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
          var n = 1 - this.es, t = 1 / n;
          this.radius_p = Math.sqrt(n), this.radius_p2 = n, this.radius_p_inv2 = t, this.shape = "ellipse";
        } else this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
        this.title || (this.title = "Geostationary Satellite View");
      }
      function Rot(n) {
        var t = n.x, e = n.y, i, r, a, o;
        if (t = t - this.long0, this.shape === "ellipse") {
          e = Math.atan(this.radius_p2 * Math.tan(e));
          var s = this.radius_p / Ar(this.radius_p * Math.cos(e), Math.sin(e));
          if (r = s * Math.cos(t) * Math.cos(e), a = s * Math.sin(t) * Math.cos(e), o = s * Math.sin(e), (this.radius_g - r) * r - a * a - o * o * this.radius_p_inv2 < 0) return n.x = Number.NaN, n.y = Number.NaN, n;
          i = this.radius_g - r, this.flip_axis ? (n.x = this.radius_g_1 * Math.atan(a / Ar(o, i)), n.y = this.radius_g_1 * Math.atan(o / i)) : (n.x = this.radius_g_1 * Math.atan(a / i), n.y = this.radius_g_1 * Math.atan(o / Ar(a, i)));
        } else this.shape === "sphere" && (i = Math.cos(e), r = Math.cos(t) * i, a = Math.sin(t) * i, o = Math.sin(e), i = this.radius_g - r, this.flip_axis ? (n.x = this.radius_g_1 * Math.atan(a / Ar(o, i)), n.y = this.radius_g_1 * Math.atan(o / i)) : (n.x = this.radius_g_1 * Math.atan(a / i), n.y = this.radius_g_1 * Math.atan(o / Ar(a, i))));
        return n.x = n.x * this.a, n.y = n.y * this.a, n;
      }
      function Lot(n) {
        var t = -1, e = 0, i = 0, r, a, o, s;
        if (n.x = n.x / this.a, n.y = n.y / this.a, this.shape === "ellipse") {
          this.flip_axis ? (i = Math.tan(n.y / this.radius_g_1), e = Math.tan(n.x / this.radius_g_1) * Ar(1, i)) : (e = Math.tan(n.x / this.radius_g_1), i = Math.tan(n.y / this.radius_g_1) * Ar(1, e));
          var l = i / this.radius_p;
          if (r = e * e + l * l + t * t, a = 2 * this.radius_g * t, o = a * a - 4 * r * this.C, o < 0) return n.x = Number.NaN, n.y = Number.NaN, n;
          s = (-a - Math.sqrt(o)) / (2 * r), t = this.radius_g + s * t, e *= s, i *= s, n.x = Math.atan2(e, t), n.y = Math.atan(i * Math.cos(n.x) / t), n.y = Math.atan(this.radius_p_inv2 * Math.tan(n.y));
        } else if (this.shape === "sphere") {
          if (this.flip_axis ? (i = Math.tan(n.y / this.radius_g_1), e = Math.tan(n.x / this.radius_g_1) * Math.sqrt(1 + i * i)) : (e = Math.tan(n.x / this.radius_g_1), i = Math.tan(n.y / this.radius_g_1) * Math.sqrt(1 + e * e)), r = e * e + i * i + t * t, a = 2 * this.radius_g * t, o = a * a - 4 * r * this.C, o < 0) return n.x = Number.NaN, n.y = Number.NaN, n;
          s = (-a - Math.sqrt(o)) / (2 * r), t = this.radius_g + s * t, e *= s, i *= s, n.x = Math.atan2(e, t), n.y = Math.atan(i * Math.cos(n.x) / t);
        }
        return n.x = n.x + this.long0, n;
      }
      var Pot = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
      const Not = { init: Dot, forward: Rot, inverse: Lot, names: Pot };
      var XA = 1.340264, $A = -0.081106, ZA = 893e-6, KA = 3796e-6, I0 = Math.sqrt(3) / 2;
      function Fot() {
        this.es = 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0;
      }
      function kot(n) {
        var t = mt(n.x - this.long0), e = n.y, i = Math.asin(I0 * Math.sin(e)), r = i * i, a = r * r * r;
        return n.x = t * Math.cos(i) / (I0 * (XA + 3 * $A * r + a * (7 * ZA + 9 * KA * r))), n.y = i * (XA + $A * r + a * (ZA + KA * r)), n.x = this.a * n.x + this.x0, n.y = this.a * n.y + this.y0, n;
      }
      function Oot(n) {
        n.x = (n.x - this.x0) / this.a, n.y = (n.y - this.y0) / this.a;
        var t = 1e-9, e = 12, i = n.y, r, a, o, s, l, u;
        for (u = 0; u < e && (r = i * i, a = r * r * r, o = i * (XA + $A * r + a * (ZA + KA * r)) - n.y, s = XA + 3 * $A * r + a * (7 * ZA + 9 * KA * r), i -= l = o / s, !(Math.abs(l) < t)); ++u) ;
        return r = i * i, a = r * r * r, n.x = I0 * n.x * (XA + 3 * $A * r + a * (7 * ZA + 9 * KA * r)) / Math.cos(i), n.y = Math.asin(Math.sin(i) / I0), n.x = mt(n.x + this.long0), n;
      }
      var Qot = ["eqearth", "Equal Earth", "Equal_Earth"];
      const zot = { init: Fot, forward: kot, inverse: Oot, names: Qot };
      var JA = 1e-10;
      function Got() {
        var n;
        if (this.phi1 = this.lat1, Math.abs(this.phi1) < JA) throw new Error();
        this.es ? (this.en = uC(this.es), this.m1 = Pf(this.phi1, this.am1 = Math.sin(this.phi1), n = Math.cos(this.phi1), this.en), this.am1 = n / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1), this.inverse = Vot, this.forward = Uot) : (Math.abs(this.phi1) + JA >= ut ? this.cphi1 = 0 : this.cphi1 = 1 / Math.tan(this.phi1), this.inverse = qot, this.forward = jot);
      }
      function Uot(n) {
        var t = mt(n.x - (this.long0 || 0)), e = n.y, i, r, a;
        return i = this.am1 + this.m1 - Pf(e, r = Math.sin(e), a = Math.cos(e), this.en), r = a * t / (i * Math.sqrt(1 - this.es * r * r)), n.x = i * Math.sin(r), n.y = this.am1 - i * Math.cos(r), n.x = this.a * n.x + (this.x0 || 0), n.y = this.a * n.y + (this.y0 || 0), n;
      }
      function Vot(n) {
        n.x = (n.x - (this.x0 || 0)) / this.a, n.y = (n.y - (this.y0 || 0)) / this.a;
        var t, e, i, r;
        if (e = Ar(n.x, n.y = this.am1 - n.y), r = hC(this.am1 + this.m1 - e, this.es, this.en), (t = Math.abs(r)) < ut) t = Math.sin(r), i = e * Math.atan2(n.x, n.y) * Math.sqrt(1 - this.es * t * t) / Math.cos(r);
        else if (Math.abs(t - ut) <= JA) i = 0;
        else throw new Error();
        return n.x = mt(i + (this.long0 || 0)), n.y = Pl(r), n;
      }
      function jot(n) {
        var t = mt(n.x - (this.long0 || 0)), e = n.y, i, r;
        return r = this.cphi1 + this.phi1 - e, Math.abs(r) > JA ? (n.x = r * Math.sin(i = t * Math.cos(e) / r), n.y = this.cphi1 - r * Math.cos(i)) : n.x = n.y = 0, n.x = this.a * n.x + (this.x0 || 0), n.y = this.a * n.y + (this.y0 || 0), n;
      }
      function qot(n) {
        n.x = (n.x - (this.x0 || 0)) / this.a, n.y = (n.y - (this.y0 || 0)) / this.a;
        var t, e, i = Ar(n.x, n.y = this.cphi1 - n.y);
        if (e = this.cphi1 + this.phi1 - i, Math.abs(e) > ut) throw new Error();
        return Math.abs(Math.abs(e) - ut) <= JA ? t = 0 : t = i * Math.atan2(n.x, n.y) / Math.cos(e), n.x = mt(t + (this.long0 || 0)), n.y = Pl(e), n;
      }
      var Hot = ["bonne", "Bonne (Werner lat_1=90)"];
      const Yot = { init: Got, names: Hot };
      function Wot(n) {
        n.Proj.projections.add(v0), n.Proj.projections.add(y0), n.Proj.projections.add(Uit), n.Proj.projections.add(Kit), n.Proj.projections.add(rrt), n.Proj.projections.add(urt), n.Proj.projections.add(Art), n.Proj.projections.add(_rt), n.Proj.projections.add(Crt), n.Proj.projections.add(Mrt), n.Proj.projections.add(Yrt), n.Proj.projections.add(Jrt), n.Proj.projections.add(rat), n.Proj.projections.add(hat), n.Proj.projections.add(Aat), n.Proj.projections.add(_at), n.Proj.projections.add(Cat), n.Proj.projections.add(Mat), n.Proj.projections.add(Fat), n.Proj.projections.add(Gat), n.Proj.projections.add(Hat), n.Proj.projections.add(Zat), n.Proj.projections.add(not), n.Proj.projections.add(sot), n.Proj.projections.add(fot), n.Proj.projections.add(_ot), n.Proj.projections.add(Cot), n.Proj.projections.add(Mot), n.Proj.projections.add(Not), n.Proj.projections.add(zot), n.Proj.projections.add(Yot);
      }
      rn.defaultDatum = "WGS84", rn.Proj = bo, rn.WGS84 = new rn.Proj("WGS84"), rn.Point = Lf, rn.toPoint = jk, rn.defs = Ui, rn.nadgrid = jnt, rn.transform = p0, rn.mgrs = oit, rn.version = "__VERSION__", Wot(rn);
      function Xot(n) {
        const t = Object.keys(n.defs), e = t.length;
        let i, r;
        for (i = 0; i < e; ++i) {
          const a = t[i];
          if (!fm(a)) {
            const o = n.defs(a);
            let s = o.units;
            !s && o.projName === "longlat" && (s = "degrees"), nf(new Oi({ code: a, axisOrientation: o.axis, metersPerUnit: o.to_meter, units: s }));
          }
        }
        for (i = 0; i < e; ++i) {
          const a = t[i], o = fm(a);
          for (r = 0; r < e; ++r) {
            const s = t[r], l = fm(s);
            if (!gm(a, s)) if (n.defs[a] === n.defs[s]) oA([o, l]);
            else {
              const u = n(a, s);
              ju(o, l, gN(o, l, u.forward), gN(l, o, u.inverse));
            }
          }
        }
      }
      const $ot = () => {
        rn.defs("EPSG:3395", "+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs"), rn.defs("EPSG:4548", "+proj=tmerc +lat_0=0 +lon_0=117 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs"), rn.defs("EPSG:4490", "+proj=longlat +ellps=GRS80 +no_defs +type=crs"), Xot(rn);
        const n = new Oi({ code: "EPSG:4490", units: "degrees", axisOrientation: "neu" });
        n.setExtent([-180, -90, 180, 90]), n.setWorldExtent([-180, -90, 180, 90]), nf(n), ju("EPSG:4326", "EPSG:4490", function(r) {
          return rn("EPSG:4326", "EPSG:4490", r);
        }, function(r) {
          return rn("EPSG:4490", "EPSG:4326", r);
        }), ju("EPSG:3857", "EPSG:4490", function(r) {
          return rn("EPSG:3857", "EPSG:4490", r);
        }, function(r) {
          return rn("EPSG:4490", "EPSG:3857", r);
        });
        const t = new Oi({ code: "GCJ:02", axisOrientation: "enu", extent: [-20037508342789244e-9, -2003750834278071e-8, 20037508342789244e-9, 2003750834278071e-8], worldExtent: [-180, -85, 180, 85], global: true, units: "m", getPointResolution: function(r, a) {
          return r / Math.cosh(a[1] / 6378137);
        } });
        oA([t]), Vu(cm, [t], int, nnt), Vu(hm, [t], Ik, xk);
        const e = new Oi({ code: "BD:09", axisOrientation: "enu", extent: [-33554432, -33554432, 33554432, 33554432], worldExtent: [-180, -85, 180, 85], global: true, units: "m", getPointResolution: function(r, a) {
          return r / Math.cosh(a[1] / 6378137);
        } });
        oA([e]), Vu(cm, [e], ent, tnt), Vu(hm, [e], mk, _k);
        const i = new Oi({ code: "EPSG:3395", extent: [-20037508342789244e-9, -20037508342789244e-9, 20037508342789244e-9, 20037508342789244e-9], worldExtent: [-180, -80, 180, 84], global: true, units: "m", axisOrientation: "neu" });
        nf(i), ju("EPSG:4326", "EPSG:3395", function(r) {
          return rn("EPSG:4326", "EPSG:3395", r);
        }, function(r) {
          return rn("EPSG:3395", "EPSG:4326", r);
        }), ju("EPSG:3857", "EPSG:3395", function(r) {
          return rn("EPSG:3857", "EPSG:3395", r);
        }, function(r) {
          return rn("EPSG:3395", "EPSG:3857", r);
        }), ju("GCJ:02", "EPSG:3395", function(r) {
          const a = xk(r, r, void 0);
          return rn("EPSG:3857", "EPSG:3395", a);
        }, function(r) {
          const a = rn("EPSG:3395", "EPSG:3857", r);
          return Ik(a, a, void 0);
        }), ju("BD:09", "EPSG:3395", function(r) {
          const a = _k(r, r, void 0);
          return rn("EPSG:3857", "EPSG:3395", a);
        }, function(r) {
          const a = rn("EPSG:3395", "EPSG:3857", r);
          return mk(a, a, void 0);
        }), Vu([e], [t], Ek, wk), Vu([t], [e], wk, Ek);
      }, Zot = /^[\uD800-\uDBFF]$/, Kot = /^[\uDC00-\uDFFF]$/, Jot = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var cO;
      (function(n) {
        n[n.Unknown = 1e-13] = "Unknown", n[n.Rule = 1e-12] = "Rule", n[n.DICT = 2e-8] = "DICT", n[n.Surname = 1] = "Surname", n[n.Custom = 1] = "Custom";
      })(cO || (cO = {}));
      const Gr = { Normal: 1, Surname: 10, Custom: 100 };
      function Va(n) {
        var t;
        return n.length - (((t = n.match(Jot)) === null || t === void 0 ? void 0 : t.length) || 0);
      }
      function x0(n) {
        const t = [];
        let e = 0;
        for (; e < n.length; ) {
          const i = n[e];
          Zot.test(i) && Kot.test(n[e + 1]) ? (t.push(n.substring(e, e + 2)), e += 2) : (t.push(i), e += 1);
        }
        return t;
      }
      class fO {
        constructor() {
          this.NumberDICT = [], this.StringDICT = /* @__PURE__ */ new Map();
        }
        get(t) {
          if (t.length > 1) return this.StringDICT.get(t);
          {
            const e = t.charCodeAt(0);
            return this.NumberDICT[e];
          }
        }
        set(t, e) {
          if (t.length > 1) this.StringDICT.set(t, e);
          else {
            const i = t.charCodeAt(0);
            this.NumberDICT[i] = e;
          }
        }
        clear() {
          this.NumberDICT = [], this.StringDICT.clear();
        }
      }
      const gO = { "bng png png": [""], lng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "dng zhng": [""], "ko qio y": [""], q: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], shng: ["", "", "", "", "", ""], xi: ["", "", "", "", "", "", "", "", "", "", "", "", ""], hn: ["", "", "", "", "", ""], "wn m": [""], zhng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sn: ["", "", "", "", "", "", "", "", ""], "shng shng shang": [""], "q j": ["", "", ""], "b fu": [""], "y y y": [""], min: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chu: ["", "", "", "", "", "", "", "", ""], zhun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qi j": [""], p: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], cng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], s: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], di: ["", "", "", ""], ling: ["", "", "", "", "", "", "", "", "", "", "", "", ""], yu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bng: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "sng sng": [""], gn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "g g": ["", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], pn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zhng zhng": [""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], fng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "gun kung": [""], chun: ["", "", "", "", "", ""], chn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ln: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], b: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], wn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "wi wi": [""], "jng dn": [""], "l l": [""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], pi: ["", "", "", ""], f: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "y j": [""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ni: ["", "", "", "", "", "", "", "", "", ""], w: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tu zh": ["", "", ""], "me m ma yo": [""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "w w": [""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", ""], h: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], f: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "l yu yo lo": ["", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], png: ["", "", "", "", "", "", "", "", ""], png: ["", "", "", "", "", ""], qio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], h: ["", "", "", "", "", "", ""], gui: [""], "chng shng": ["", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ho y": [""], "ni mi": [""], q: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], y: ["", "", "", "", "", "", ""], x: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], du: ["", "", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], nng: ["", "", "", "", ""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mo: ["", "", "", "", "", "", "", "", "", "", ""], mi: ["", "", "", "", "", ""], lun: ["", "", ""], r: ["", "", "", "", "", ""], xu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], f: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], n: ["", ""], qin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], su: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", ""], "qin gn": [""], "zh lun": [""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ln ln": [""], ju: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "le lio": [""], "g m": [""], "y y": ["", ""], zhng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], r: ["", "", "", "", "", "", "", "", "", "", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ku: ["", "", "", "", "", "", "", "", "", "", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], h: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], q: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], s: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], su: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gn: ["", "", "", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "xi su": [""], "q zhi": ["", ""], "y y": ["", "", "", "", ""], "j q": ["", ""], tu: ["", "", "", ""], "wng w": [""], "kng hng gng": [""], d: ["", ""], jio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hi: ["", "", "", "", "", "", "", "", ""], "hng png": [""], m: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ye: [""], xing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ling: ["", "", "", "", "", "", "", "", "", "", ""], "qn qng": ["", ""], b: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "dn dn": ["", ""], lin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], du: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "wi mn": ["", ""], rn: ["", "", "", "", "", "", "", "", "", "", ""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], wng: ["", "", "", "", ""], "shn sh": [""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dng: ["", "", "", "", "", "", "", "", ""], z: ["", "", "", "", "", "", ""], "jn jn": ["", "", ""], "p p": [""], "chu qi": [""], zhng: ["", "", "", ""], jn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bng: ["", "", "", "", "", "", "", ""], rng: ["", "", "", "", ""], f: ["", "", ""], "jn sn": [""], ln: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], cng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zi z z": [""], t: ["", "", "", "", "", "", "", "", "", "", ""], f: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tu ch du": [""], hng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], rn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "gn hn": [""], "y g": [""], di: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "lng lng lng": [""], cho: ["", "", ""], "chng zhng": ["", "", "", ""], s: [""], chng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], m: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "men mn": [""], fn: ["", "", "", ""], "cho mio": [""], "yng ng": [""], zhng: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "p p": [""], w: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ji ji jie": [""], "yo f": [""], "rn rn": [""], "fn bn": [""], d: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], fng: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], pi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], wn: ["", "", "", "", "", "", "", "", "", "", "", ""], xn: [""], kng: ["", "", "", "", "", "", ""], i: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "j q": ["", ""], "xi x": [""], "jn yn": [""], dn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], f: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tng: ["", "", "", "", "", "", "", "", "", "", "", ""], yu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hu: ["", "", "", "", "", "", ""], "hu kui": ["", "", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], cu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sn: ["", "", "", "", "", ""], wi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chun zhun": ["", ""], "ch j": ["", "", ""], "j ch": [""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], shng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chen cng": [""], xn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xn: ["", "", "", "", "", "", "", "", "", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "xin xun": [""], "n n": [""], "b bi": [""], "g g": [""], n: ["", "", "", "", "", "", "", "", "", "", "", ""], "n n": [""], bn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], x: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], shn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], q: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "s c": [""], bng: ["", "", "", "", "", ""], "s sh": [""], "ji qi g": [""], "y ch": [""], "din tin": ["", ""], "hn gn": [""], mi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], b: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], b: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zho sho": [""], c: ["", "", "", "", ""], wi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zu: ["", "", ""], yng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "t t": ["", ""], zhn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "h h h": [""], b: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sh: ["", "", "", ""], "y di": ["", "", "", ""], "f f b b": [""], "zu zu": [""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], nng: ["", "", "", "", "", "", ""], q: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "yng yng": [""], w: ["", "", "", ""], k: ["", "", "", "", ""], bo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hui hu": [""], "g h": [""], lo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xing: ["", "", "", "", "", "", "", ""], g: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bi: ["", "", "", "", "", "", "", "", ""], f: ["", "", "", "", "", ""], mng: ["", "", "", "", ""], "r ni": [""], hn: ["", "", "", "", ""], hu: ["", ""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tio: ["", "", "", "", ""], jio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], c: ["", "", "", "", "", "", "", "", "", "", "", "", ""], xng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], kn: ["", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ku: ["", "", "", ""], gng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], m: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], n: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mu: ["", "", "", "", "", "", "", "", "", "", ""], r: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "dng tng tng": [""], ch: ["", "", "", "", "", "", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "gng gng": ["", ""], zhu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], r: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "jin cn": [""], xi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ta: [""], "jio yo": ["", "", ""], zhn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "c z zhi": ["", ""], kui: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chi: ["", "", "", "", "", "", ""], nng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hu hu": ["", ""], jing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chng tng": [""], "zhn zhn": ["", ""], zu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "sh du": [""], tng: ["", "", "", "", "", "", "", "", "", "", "", ""], shn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tu tu": [""], nn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], xio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "bin pin": ["", "", ""], tu: ["", "", "", ""], x: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], c: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], : ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], x: ["", "", ""], "gung kung": [""], k: ["", "", "", "", "", "", "", "", "", "", "", "", ""], w: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ling: ["", "", "", "", "", "", "", "", "", "", "", ""], z: ["", "", "", "", "", "", "", "", "", "", ""], "qio xio": [""], yng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hn: ["", "", "", "", "", "", "", "", "", "", "", ""], jng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sn: ["", ""], pi: [""], s: [""], x: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "y sh y": [""], "s q": [""], "xn shn": [""], xi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], d: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "li ling": [""], jin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "j j": ["", "", "", ""], xio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], pi: ["", "", "", "", "", "", "", ""], bio: ["", "", ""], "ch t": [""], fi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], fng: ["", "", "", "", "", "", "", "", "", "", ""], n: ["", "", "", "", "", "", ""], bi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], y: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "h ch": [""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "cu z": [""], "ling li": [""], wn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gun: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], tin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mn: ["", "", "", "", "", "", "", "", "", "", "", ""], "do do": [""], "tn tn": ["", ""], "ju ju": [""], chu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xng: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], png: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tng chng": [""], hu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], t: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ling jng": ["", ""], su: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "chng chng": [""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "kng kng": [""], jun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], n: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhu: ["", "", "", "", "", "", "", "", "", "", "", ""], "w wi": [""], lu: ["", "", "", "", "", "", "", "", "", ""], sng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lng: ["", "", "", "", ""], z: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], bn: ["", "", "", "", "", "", ""], ci: ["", "", "", "", "", "", "", "", "", "", ""], zhi: ["", "", "", "", ""], y: ["", "", "", "", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", ""], qng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chng chn": ["", ""], run: ["", "", "", "", "", "", "", "", "", "", ""], "zhng tng": [""], chn: ["", "", "", "", "", ""], "ji ji": [""], "j ji": [""], "bng bng": [""], ru: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], t: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], wi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], pin: ["", "", "", "", "", "", "", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tng dng": [""], : ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ch: ["", "", ""], shng: ["", "", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", ""], hung: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chu qio": [""], yu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], x: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", ""], c: ["", "", "", "", "", "", ""], b: ["", "", "", "", "", "", "", "", ""], xn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ci s": [""], dun: ["", "", "", "", ""], u: ["", "", "", "", "", "", "", "", ""], tu: ["", "", ""], "zn z z": [""], "l lu": ["", ""], fn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ku gu": [""], su: ["", "", "", "", "", "", "", ""], "zh s t": [""], s: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xi: ["", "", "", "", "", "", ""], "yun yun": ["", ""], rng: ["", "", "", "", ""], n: ["", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "gu jing": [""], m: ["", "", "", "", "", "", "", "", "", "", ""], bng: ["", "", "", "", "", "", "", "", "", "", "", ""], din: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ho: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "x x": [""], shn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qin jin": [""], "qu ju": ["", ""], "cng chen": [""], rng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "t tn": [""], su: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], di: ["", ""], zi: ["", "", "", "", "", "", "", ""], g: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], nu: ["", "", "", "", ""], "cn cn": [""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], cu: ["", "", "", "", "", "", "", "", "", "", ""], yng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zo co": [""], sng: ["", "", "", "", "", "", "", "", "", "", ""], o: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "q cu": [""], chung: ["", "", "", ""], sh: ["", ""], hn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "yn yn": ["", "", ""], "pio bio": ["", ""], lin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tn tn": [""], yng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhun: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], xing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], shn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tu tu": [""], zn: ["", "", "", ""], p: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chng: ["", "", "", "", "", "", "", ""], gung: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], dng: ["", "", "", "", "", "", "", "", "", "", ""], "chn zhn zhun": [""], b: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chun: ["", "", "", "", ""], "ti jin": [""], sng: ["", ""], xin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "y j": [""], " w": [""], "tng zhung": [""], ln: ["", "", "", "", "", "", "", "", "", "", "", "", ""], g: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ji jie": [""], qio: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], p: ["", "", "", "", "", "", "", "", "", "", "", ""], si: ["", "", "", ""], "chn tn shn": [""], "dng dng": ["", "", ""], xun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "dn dn": ["", "", ""], cn: ["", "", "", "", "", "", "", ""], "bn bn": [""], "n n": [""], ti: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ln: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "n y i y": [""], mng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], nng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], kung: ["", "", ""], bo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zn: ["", "", "", "", "", "", ""], ho: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qng: ["", "", "", "", "", "", "", "", "", ""], chn: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], tng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "lng lng lng": [""], "chn chn": [""], "rng xing": ["", ""], "hu xi": [""], lu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "nng nng": [""], "w w": [""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zn: ["", "", "", "", "", "", "", ""], yun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zho: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "du ru yu": ["", "", ""], k: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], t: ["", "", "", "", ""], dng: ["", "", "", "", "", "", "", ""], du: ["", "", "", "", "", ""], hung: ["", "", "", "", "", "", "", "", "", "", "", ""], r: ["", "", "", "", "", "", "", "", "", "", "", ""], ni: ["", "", "", ""], "y sh": [""], "li l": [""], han: ["", ""], tin: ["", "", "", "", "", "", "", ""], "xng xng": [""], din: ["", "", "", "", "", "", "", "", "", "", "", ""], "z c": [""], jin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], shu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jing: ["", "", "", "", "", "", "", "", "", ""], mo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], rn: ["", "", "", "", "", "", "", "", ""], "ni n": [""], gng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], c: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gu: ["", "", "", "", ""], "mo m": [""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], x: ["", "", "", "", "", "", "", "", "", "", "", ""], m: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "yu yn": [""], xi: ["", "", ""], jn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], m: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "gun gun": ["", "", "", "", ""], mng: ["", "", "", "", "", "", "", "", "", "", "", "", ""], zhng: ["", "", "", "", "", "", "", "", ""], zu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ku: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], ti: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "fng png": ["", ""], "chng chng": [""], kung: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lng: [""], pn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], f: ["", "", "", "", ""], xin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qi: ["", "", "", "", "", "", "", "", ""], "jng chng": ["", "", ""], su: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], t: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhn: ["", "", "", "", ""], "ling ling": ["", "", ""], dio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], cu: ["", "", "", "", ""], i: ["", "", "", "", "", "", "", ""], du: ["", "", "", "", "", "", "", "", ""], d: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "j j": [""], fn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], j: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ch ch": ["", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], png: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ki: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "kn qin": [""], t: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "o w": [""], ch: ["", "", "", "", "", "", "", "", "", ""], dng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zo: ["", ""], do: ["", "", "", "", "", "", "", "", ""], chung: ["", "", "", "", "", "", "", "", ""], "fn fn": [""], "qi qi": [""], kn: ["", "", "", "", "", "", ""], cn: ["", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hu hu": [""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], yu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], z: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chung chung": ["", ""], q: ["", "", "", "", "", "", "", ""], "bi bi": ["", ""], "po bo": [""], "chn chn": ["", "", ""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", ""], gng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], do: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], chung: ["", "", "", "", ""], k: ["", "", "", "", "", "", "", "", "", "", "", ""], du: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "shu shu": [""], "qun xun": [""], "ch sh": ["", ""], "c c": [""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], cu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "xio xu": [""], "ki k": ["", ""], "l l": [""], t: ["", "", "", "", "", "", "", "", ""], pu: [""], wn: ["", "", "", "", "", "", "", "", "", "", "", ""], "bo b": ["", ""], du: ["", "", "", "", "", "", "", "", "", "", ""], qng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "yn shn": [""], "d zhu": [""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hu: ["", "", "", "", "", "", "", "", ""], shng: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "dun zh": [""], w: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], g: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "d zh": [""], chun: ["", "", "", "", "", "", "", "", ""], "tun zhun": ["", "", ""], "l ji": [""], png: ["", "", "", "", "", "", "", "", "", "", ""], pio: ["", "", "", "", "", "", "", "", "", "", ""], ku: ["", "", "", "", "", "", "", ""], "jio cho": ["", "", "", ""], qio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hu hu": [""], "zh zh": [""], "p p": ["", ""], tng: ["", "", "", "", "", "", "", ""], chn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zun: ["", "", "", "", ""], m: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qun: ["", "", "", "", ""], "jn jng": ["", "", ""], kng: ["", "", "", "", "", "", "", "", "", "", ""], "xi li": [""], "zh ch": [""], n: ["", "", "", ""], sho: ["", "", "", "", "", "", "", "", ""], mio: ["", "", "", "", "", "", "", "", "", "", ""], ku: ["", ""], w: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], kung: ["", "", "", "", "", "", "", "", "", "", "", ""], h: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], go: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "b bi": [""], lng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "jun jun": ["", ""], "l li": [""], ki: ["", "", "", ""], "wng yng": [""], qn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], fn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jun: ["", "", "", "", "", "", "", "", "", "", ""], "tng dng": ["", "", "", ""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sho: ["", "", ""], "gu gu": [""], cng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "to yo": ["", ""], po: ["", "", "", "", "", "", "", "", "", "", ""], d: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hu hu": [""], "bi bi": [""], no: ["", "", "", "", "", "", "", "", "", "", "", ""], "ch shi": [""], fng: ["", "", "", "", "", "", "", "", "", "", ""], z: ["", "", "", "", "", "", "", "", ""], qi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zng cng": [""], fi: ["", "", "", "", "", "", "", "", "", ""], "ku gu": ["", ""], sun: [""], p: ["", "", "", "", "", "", "", "", "", "", ""], "q u": ["", ""], "k qi": [""], "yn yn": ["", ""], bin: ["", "", "", "", "", "", "", "", "", "", ""], n: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], nin: ["", "", "", "", "", "", ""], s: ["", "", "", "", "", "", "", "", "", "", ""], z: ["", "", "", "", "", "", "", ""], shng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], wn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "hu hu hu": ["", ""], bi: ["", "", "", "", "", "", "", "", "", ""], "z c": [""], "dn shn chn": ["", ""], "nn n": [""], "shui l": [""], "b bo p": [""], "kung gun": [""], bin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], b: ["", "", "", "", "", "", ""], "zhn zhn": ["", ""], "k qi": [""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gu: ["", "", "", "", "", "", "", ""], "ng yng": [""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], qu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lun: [""], "jun jun": ["", ""], "chng n hn": [""], "wi yn": [""], tng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zh zhi": [""], "hn n": ["", ""], y: ["", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], d: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zh zhi": [""], png: ["", "", "", "", "", "", "", "", "", "", ""], "zh sh": [""], mng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zu: ["", "", "", ""], "sh xi": ["", ""], o: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ln qin": [""], "s mu": [""], "gng hng": [""], "ln mio": [""], "qi ru": [""], d: ["", "", "", ""], "xin xun": ["", ""], "cn shn cn sn": ["", "", "", ""], "i y": [""], "ch ch ch ch": [""], shung: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], shu: ["", ""], gui: [""], b: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "f f": [""], "zhu y l ju": [""], q: ["", "", "", "", "", "", ""], "ji xi": ["", ""], "wi y": ["", "", ""], di: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ru: ["", "", "", "", "", "", "", "", "", "", ""], "j gu": [""], lng: ["", "", "", ""], "do do to": [""], "zh zh": [""], jio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zho sho": [""], "k k": [""], "ti ti": ["", ""], p: ["", "", "", "", "", "", ""], "y xi": [""], "ho ho": [""], tn: ["", "", "", "", "", "", "", ""], "hng hng": [""], mi: ["", "", "", ""], "x y y": [""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "xun sng": [""], yo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], z: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "h g": ["", ""], "cn du": [""], "tng tng": [""], "t t": ["", ""], "zh zh": ["", ""], "xi h": [""], " y": [""], "ma m m": [""], ln: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tn: ["", "", "", ""], "b p": [""], qn: ["", "", "", "", "", "", "", "", "", "", ""], "ji g": [""], "fu p": [""], "ba b": [""], dn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], fn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], " hu": [""], "kng hng": ["", ""], shn: [""], "zh z": [""], "yn shn": [""], w: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "cho cho": [""], "n n": [""], "xu chu ju": [""], chu: ["", "", ""], "du r": [""], hu: ["", ""], "hng hu u": [""], "w y": [""], "ya y": [""], " e": [""], di: ["", "", ""], "mn q": [""], hng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], n: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tn tin": [""], "f ": ["", ""], "di ti": [""], "u u u": [""], "bi bei": [""], "yun yn yn": ["", ""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hu q": [""], "qing qing": ["", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jun: ["", "", "", "", "", ""], pn: ["", ""], "wn mn": [""], "ne n": [""], " m mu": [""], rn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "ti ch": [""], "q zh": [""], "z c": [""], "gu g gu": [""], "c z": [""], "hu x gu": [""], "h     a": [""], no: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "xi g": [""], pi: ["", "", "", "", "", ""], "ho xio": [""], mng: ["", ""], "d dn": [""], "zu j": [""], "xin gn": [""], pu: ["", "", ""], "yng yng": [""], "z z zh": [""], "h h hu hu h": [""], hi: [""], d: ["", "", "", "", "", "", "", "", "", ""], "k k": [""], g: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "k g": [""], zuo: [""], lng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "xin xin": [""], q: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "x di": [""], "li li li lie": [""], z: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], m: [""], "j x qi": [""], "g lu k lo": [""], "sh xn": [""], "zn z z zan": [""], "hi k": [""], hu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hui sh": [""], to: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], xin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], " n": [""], "xun xun": ["", ""], "wi h w gu gu": [""], "yn y yn": [""], i: ["", "", "", "", "", "", ""], pn: ["", ""], shn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hng hng hng": [""], "w wa": [""], "h h h": [""], zi: ["", "", "", "", "", "", "", "", ""], "d di": [""], pi: ["", "", "", "", "", "", ""], "gn hn": [""], "y y": ["", ""], "yu hu": ["", ""], nin: ["", "", "", "", "", "", "", "", "", ""], "hu hu": ["", ""], "j ji zhi": ["", ""], mu: [""], "y yo": ["", ""], lng: ["", "", ""], "  ": [""], "l l li": [""], "n na ni n ni": [""], h: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "b p b": [""], zh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ling lng": [""], "li l": [""], hn: ["", "", "", "", "", "", "", "", "", ""], "hng hng": [""], gng: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chu yu": [""], "g ji": [""], "bei bi": [""], "hn hn": [""], chn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "i i": [""], "ji qin": [""], "yn dn xin": [""], ch: ["", "", "", "", ""], "w g ": [""], zo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], d: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "gng hng gng": ["", ""], du: [""], "lo lo": ["", "", ""], hun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lng: ["", "", "", "", ""], "w wi": [""], fng: ["", "", "", ""], "yn jn": [""], "h xi": [""], wi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], shu: [""], chng: ["", "", "", "", "", "", "", "", "", ""], "r w": [""], qing: ["", "", "", ""], y: [""], y: ["", "", "", "", "", "", "", "", "", "", ""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], tu: ["", "", "", "", "", "", "", "", "", ""], "zhu zho tio": [""], kn: ["", "", "", "", "", "", "", "", "", ""], "zhu zho": ["", ""], "hng hng": ["", ""], "ln ln": [""], "a    ": [""], qing: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "tn zhn xing du": [""], wn: ["", "", "", "", "", "", ""], "cu qi": [""], "di sh ji t": [""], "yu w": [""], "z c": [""], "b t": [""], "chu chui": [""], "y y ": [""], fi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], p: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sh: [""], "l la": [""], "yng qng": [""], p: ["", "", "", "", ""], "zh sh": [""], s: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ni: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "lu lu luo": ["", ""], "tn chn tu": [""], bo: ["", ""], dng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], lng: [""], "n n": [""], k: ["", ""], "yng y": [""], "l l l": [""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "di zh": [""], wi: ["", "", ""], "nu r": [""], "x hu gu": [""], zn: [""], "w ": [""], h: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hun yun xun h": [""], x: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "h h y": [""], ku: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zhng chung": [""], "wi wi": ["", "", ""], "du zh": [""], "sng sng": [""], "qio jio": [""], "pn bn": [""], "cn sn q": [""], "zh ch": [""], mio: [""], "pn pn": [""], ku: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "lou lu": [""], "zo qio": [""], "h xio xio h": [""], " sh": [""], xi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qing qing": ["", "", "", "", ""], "i y": ["", ""], "m m ma": [""], "k k": [""], "d t": ["", ""], sng: ["", "", "", "", "", "", ""], chn: ["", "", "", "", "", "", "", "", ""], "w g": [""], "png bng": [""], "xin qin qin": [""], lo: ["", "", "", "", "", "", "", "", "", ""], wng: ["", "", "", "", "", "", "", ""], w: ["", "", "", "", "", ""], "hi hi": [""], h: ["", "", "", "", ""], zi: [""], si: [""], "g g g": [""], g: ["", ""], n: ["", "", "", "", ""], di: [""], "i i i": [""], tng: ["", "", "", ""], "zu su": [""], "zh zh zh zhe": [""], m: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], su: ["", ""], tn: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "jio do": [""], "ki g": [""], "shn cn": [""], co: ["", "", "", "", "", "", "", "", "", "", "", ""], pio: ["", "", "", ""], "lu lou": [""], g: ["", ""], "g ji": [""], "jio xio": [""], "x sh": ["", ""], p: ["", "", "", "", "", ""], "d di": [""], "ma m": [""], "l lei": [""], "g g g": [""], si: ["", "", "", "", "", ""], "zu chui": [""], "cho zho": ["", "", ""], zu: ["", "", "", ""], "qio qio": ["", "", ""], "ch x shu": [""], "tn chn": [""], "dn tn": ["", "", "", "", ""], "hi m": [""], : ["", "", "", "", ""], "fn bo": [""], chung: ["", "", ""], "c z h": [""], "tn ku": [""], "cng chng": [""], dng: ["", "", "", "", "", "", "", "", "", ""], p: ["", "", "", "", "", "", "", ""], ju: ["", "", "", ""], l: ["", "", "", "", ""], zhn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], : [""], "zhu zhu": [""], "jio qio ch": [""], yun: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "i i i": [""], "yng yng": ["", ""], "ju xu": [""], "pn pn fn": [""], g: ["", "", "", "", ""], "xn hn hn": [""], dng: ["", "", "", "", "", "", "", "", "", ""], ln: ["", "", "", "", "", "", "", "", "", "", ""], t: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hu hu ": [""], ho: ["", "", "", ""], "h xi": [""], "xi p": [""], "zhu chu": ["", "", ""], m: [""], "ch c": [""], "b po bo": [""], "me mi m": [""], "xi hi": [""], "o xio": [""], m: ["", ""], pn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], m: ["", ""], "rng rng": [""], l: ["", ""], "jio ju jio": [""], chu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hun hun": [""], "z c": [""], chi: ["", "", "", "", ""], "nng nng": [""], "z zn cn": [""], s: ["", "", "", "", "", "", "", "", "", ""], zng: ["", "", "", "", "", "", ""], "z ni yn": [""], nng: [""], "lu lu luo": [""], "wi gu": [""], hu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], nn: ["", "", ""], "jin nn": [""], nn: [""], tun: ["", "", "", "", "", "", "", "", "", "", ""], "tn dn": ["", ""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], kn: ["", "", ""], "wi tng": [""], qn: ["", "", ""], r: ["", "", "", "", "", ""], ti: ["", "", ""], p: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qun jun jun": ["", ""], "chu chun": [""], tun: ["", "", ""], l: ["", "", "", "", "", "", "", "", ""], "hun yun": [""], lun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], t: ["", "", "", ""], "x wi": [""], "d de": ["", ""], "qin s": [""], zhn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "chng chng": ["", "", ""], "q yn": [""], ji: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zh zh": [""], bn: ["", "", "", "", "", "", "", "", "", "", "", "", ""], qn: ["", "", "", "", "", "", "", "", "", "", ""], "mi fn": [""], "rng kng": [""], "fng fng": [""], "fn bn": [""], tn: ["", "", "", "", "", "", "", "", "", "", "", ""], "hui pi p pi": [""], "d ln": [""], tn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], b: ["", "", "", "", "", "", "", "", "", "", "", ""], fn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], p: ["", "", "", "", "", "", "", "", "", "", ""], "pn bn": [""], kn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], din: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "m m": [""], "k k": ["", ""], xu: ["", "", "", "", "", "", "", "", ""], "d ch": ["", ""], l: ["", "", "", ""], lng: ["", "", "", "", "", "", "", "", "", ""], mn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "dng tng": ["", "", ""], c: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], du: ["", "", "", "", "", "", "", ""], "du du": [""], "du du": ["", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", ""], shng: ["", "", "", "", "", "", "", "", ""], shu: ["", "", "", "", "", ""], da: ["", "", ""], hng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "n n": [""], xng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "yun hun": [""], bng: ["", "", "", "", "", "", "", "", "", "", "", ""], "pu f": [""], cn: ["", "", ""], "bng fng": [""], "d fng": [""], "xi ji": [""], "mi mn": [""], lng: ["", "", "", "", "", ""], "shn yn": [""], "qn jn": [""], "p b": [""], hu: ["", "", "", "", "", "", "", "", "", ""], "su s": [""], "p p": [""], "qng zhng": ["", ""], "wn wn": [""], ln: ["", "", ""], "zhng chng": [""], kng: ["", "", "", "", "", ""], "ci ci": ["", "", ""], "ch tu": [""], bng: ["", "", "", ""], "kn xin": [""], "y sh": ["", ""], pi: ["", "", "", "", "", "", "", "", "", ""], "so so": [""], "jn qn jn": [""], "png bng": [""], "qin zn jin": [""], n: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "du hu": ["", ""], hun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "bo b p": [""], "mo mu w": [""], run: ["", "", ""], "i  y": [""], gng: ["", ""], mi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], d: ["", "", "", "", "", "", "", ""], fng: ["", "", "", ""], hng: [""], chn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], jing: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], hung: ["", "", "", "", "", ""], dun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], t: ["", "", "", "", "", "", ""], wng: ["", "", "", "", "", "", ""], "si si s": [""], zng: ["", "", "", "", "", "", ""], tin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], zhng: ["", "", "", "", "", "", "", "", "", "", "", ""], "tin zhn": [""], wn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], li: ["", "", "", "", "", "", "", "", "", ""], hi: ["", "", "", "", ""], lng: ["", "", "", "", "", "", ""], bng: ["", "", "", "", "", "", "", "", "", ""], chn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "u qi": [""], "qin jin": [""], "zhun tun": [""], shung: ["", "", "", "", "", ""], sh: ["", "", "", "", "", "", ""], lu: ["", "", "", "", "", ""], ch: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "d zh": ["", ""], kn: ["", "", "", "", "", "", ""], chn: ["", "", "", "", "", "", "", "", ""], "zh zhu": [""], qing: ["", "", "", "", ""], zng: ["", "", "", "", "", "", "", "", "", "", ""], qing: ["", "", "", "", "", "", "", "", "", "", "", ""], "kui tu": [""], "tun dng": [""], "qio qu": [""], "zn dn": [""], "qio o": [""], "y t": [""], "xu b ju": [""], ln: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hui: ["", "", ""], rng: ["", "", "", ""], "ln xin": [""], do: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ru: ["", "", "", "", "", "", "", ""], san: [""], zhung: ["", "", "", "", "", "", ""], "k qio": ["", ""], kn: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], mng: ["", "", "", "", "", ""], cn: ["", ""], "zh zhng": [""], "g yng": [""], "jing xing": ["", ""], "png fng fng": [""], zhi: ["", "", "", "", "", "", "", ""], "xun xing": [""], wi: ["", ""], "wn yun wn yun": [""], "mo wn": [""], mng: ["", "", "", "", "", ""], "d di": [""], "f f": ["", "", "", ""], gui: ["", "", ""], yng: ["", "", "", "", "", "", "", "", "", "", "", ""], "hng bn": [""], go: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "to bn": [""], "tu tou": [""], "yn to": [""], "ku ku": ["", ""], "ji ji g xi": [""], hu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ji ji g xi": [""], n: ["", "", ""], "d t": [""], "yn yn": ["", ""], po: ["", "", "", "", "", "", "", ""], ni: ["", "", "", "", "", "", "", ""], "qun jun": ["", "", ""], zu: ["", ""], "q qi xi": [""], ki: ["", "", "", "", "", ""], "bn bn": ["", ""], to: [""], "zng zhung": [""], bn: ["", "", "", "", "", ""], "xn zhu": [""], sh: ["", "", "", "", "", "", "", "", "", ""], "h p ti": [""], "o y": ["", "", ""], yn: ["", "", "", "", "", "", "", "", ""], "du ch": [""], "n r": [""], n: ["", "", "", "", ""], "dng dng tin": [""], "t ji": [""], nun: [""], "ho ho": [""], fn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], shu: ["", "", "", "", "", "", "", "", "", "", ""], "fi pi": [""], wng: ["", "", "", "", ""], zhung: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], m: ["", ""], "f yu": [""], "hi ji": [""], d: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], mio: ["", "", "", "", "", ""], "fu pi p": [""], "yu ju": [""], ni: [""], "n nn": [""], tu: ["", "", "", "", "", "", "", "", ""], "wn yun": [""], fng: ["", "", "", "", "", ""], n: [""], zhu: ["", ""], zho: ["", "", "", "", "", "", "", "", "", ""], "ni n": [""], tu: ["", "", "", "", ""], "xin xun x": [""], "zh y": ["", ""], : ["", "", "", ""], mi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "q q": [""], "x x": ["", ""], "shn shn": ["", "", "", "", ""], mn: ["", "", "", "", "", "", "", "", "", "", "", ""], ji: ["", "", "", "", ""], "wi wi": [""], pn: ["", "", "", "", "", ""], "hu hu": [""], "jio xio": [""], "gu d": [""], "lo m": [""], "nin nin": [""], zhn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], hng: ["", "", "", "", "", "", "", "", "", "", "", ""], "jn xn": [""], "ku h": [""], " y": [""], "xin shn": [""], w: [""], "ro ro": ["", ""], "sho sho": [""], xi: ["", "", "", "", "", ""], "w mi m": [""], "chu li": [""], ning: ["", "", ""], "n nu": ["", ""], "pu b": [""], "ni su": [""], tu: ["", "", "", "", "", ""], mn: ["", "", "", "", "", "", "", "", ""], "w w y": [""], "x i": [""], "zhu shu": [""], "dng dng": [""], "i i ": [""], " ": [""], min: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "pu pi b": [""], bio: ["", "", "", "", "", "", ""], "f fn": [""], w: ["", "", ""], "n n": ["", ""], "qun jun": ["", ""], hn: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qin jn": [""], "wn w": [""], "li li": ["", "", ""], "zhu chu": [""], "chu no": [""], "n n": [""], "hn kn": [""], "dng yng": [""], nn: [""], "ru chu": [""], ji: ["", "", "", "", "", "", "", "", "", "", "", ""], "tu y": ["", ""], "y y": [""], "wi wi": [""], "d t": ["", "", ""], ru: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "run nn": [""], mio: ["", "", "", "", "", "", ""], "y pi": [""], "min min": [""], "t sh": ["", ""], "du tu": ["", ""], o: ["", "", "", "", "", "", ""], "ch zu": [""], yng: ["", "", "", "", "", ""], "qn shn": [""], ji: ["", "", "", "", "", "", ""], so: [""], "zhn zhn": [""], "ji su": [""], "mng mng": [""], nio: ["", "", "", "", "", "", "", "", ""], to: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bio: [""], "pio pio": ["", ""], xun: ["", "", "", "", "", "", "", "", "", "", "", ""], "mn mn": [""], kng: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "hn nn": [""], nn: ["", ""], zh: ["", ""], "m m": [""], pi: [""], zhn: ["", "", "", "", "", "", "", "", "", "", "", ""], "xin yn jn": [""], lin: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qing hun xun": [""], dng: ["", "", "", "", "", ""], cn: ["", "", "", "", "", "", ""], tio: ["", "", "", "", "", ""], b: ["", "", ""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qin xin": ["", ""], "xi hu": [""], "hun qun": [""], "l l": ["", ""], "zh chu": [""], kng: ["", ""], "m z": [""], "sn xn": ["", ""], "bi b": ["", ""], "yu ni": [""], zhun: ["", "", ""], hi: ["", ""], no: [""], "chn cn": [""], b: ["", "", "", ""], ni: ["", ""], "nng nng": ["", "", "", "", "", ""], zhi: [""], "t ji": [""], sng: ["", "", "", "", "", "", "", "", "", ""], ru: ["", "", ""], zhn: ["", "", "", "", "", ""], "m f": [""], "dng tn": [""], "wn yun": [""], chng: ["", ""], qn: ["", "", "", "", "", "", ""], zi: ["", ""], "bo sh": [""], "ji jia jie": [""], "hung hung": [""], kun: ["", "", "", "", "", "", ""], "s xi xi": [""], "ji zn": [""], "bng bng": [""], "jn qn": [""], "lu j": [""], "xi xi": [""], "qn qn": [""], cn: ["", ""], du: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "l lu": [""], "sh y y": [""], "jing jing qing": [""], "jing jing": ["", "", "", ""], zn: ["", "", "", "", "", "", "", "", "", "", ""], "sh zh": ["", ""], xio: ["", "", "", "", "", "", "", "", "", "", ""], "ji j": ["", "", ""], "sho sho": [""], r: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "wng yu": [""], wng: ["", "", "", "", ""], lio: ["", "", "", "", "", "", "", "", "", ""], "mng mng lng png": [""], g: ["", ""], "ku ku": [""], tu: ["", "", "", "", "", "", "", "", "", "", "", ""], yn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ch ch": [""], ko: ["", ""], "jn jn": [""], "wi y": [""], "nio su": [""], cng: ["", "", "", ""], dio: [""], "png bng bng": [""], lu: ["", "", "", "", "", "", "", ""], "sh zh": ["", ""], "xi t": [""], "ch co": [""], "tn zhn": [""], "n j": [""], "hng lng": [""], "q ki": ["", ""], ng: ["", "", ""], "gng gng": ["", ""], k: ["", "", "", "", ""], gu: ["", "", "", "", "", "", "", "", ""], tio: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "q j": [""], lng: ["", "", "", ""], p: ["", "", "", "", "", "", "", "", "", "", ""], "b k": [""], lu: ["", "", "", "", "", "", "", "", "", "", "", "", "", ""], "f ni": [""], n: [""], "zh sh": ["", ""], qi: ["", "", "", ""], "qio jio": ["", ""], "xi y": [""], b: ["", "", "", "", "", "", "", "", "", ""], chng: ["", "", "", "", "", "", "", ""], "z cu": ["", ""], "lng lng": [""], "dng dng": [""], xio: ["", "", "", "", ""], "p b": ["", ""], "zhn chn": ["", "", ""], "wi wi": [""], "yng dng": [""], "sh di": [""], yo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "kn zhn": [""], "hn dng": [""], "qin kn": [""], "w mo": [""], "k ji": ["", ""], "wi wi": [""], k: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "dng tng": [""], "rng yng": ["", ""], "i ki": [""], "ko qio": [""], cu: ["", "", "", "", "", "", "", "", ""], "qin qn": [""], "d di": [""], cn: [""], dng: ["", "", "", "", "", "", "", ""], "o o": [""], "p pi": [""], "jio qio": ["", ""], "ju gu": ["", ""], "zhn shn": ["", ""], "xi ji": [""], "gu x jun": [""], r: [""], "l li": ["", "", "", ""], "x gu jun": [""], "yng hng": [""], yng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], cho: ["", "", "", "", ""], cun: ["", "", ""], chun: ["", "", "", "", ""], "jng xng": [""], cho: ["", "", "", "", "", "", "", "", "", "", "", ""], qio: ["", "", ""], gng: ["", "", "", "", "", "", "", "", ""], "ch ch chi c": [""], "xing hng": [""], shui: ["", "", ""], p: ["", "", "", ""], "tng n": [""], "m w": [""], "ti ti ti": [""], zhu: ["", "", "", "", "", "", "", ""], "jun jun": [""], shu: ["", "", "", "", "", "", ""], "chu do": ["", ""], "jin jin sn": [""], "sh qi": [""], "q j": ["", ""], "shn qio shn": [""], "zhung chung": [""], "chn chn": [""], mi: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "gn gn": [""], "bng bng": ["", ""], "j j": [""], "gung n": [""], gung: ["", "", "", ""], me: [""], "dn tn": [""], "bi tng": [""], "yng yng": [""], "d de": [""], "d du": [""], "mng mng png": [""], "bng png": [""], chng: ["", "", "", "", "", ""], "j cu": [""], qng: ["", "", "", "", "", "", "", "", "", ""], "gu wi hu": [""], "jn qn": [""], ku: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "qing s": ["", ""], "yn yn": ["", "", "", "", "", "", ""], "p pi": ["", ""], "nng lng": [""], "d t tu": [""], "ju zhng": [""], "m m": ["", "", ""], cho: ["", "", "", "", "", "", "", ""], yi: [""], sho: ["", "", "", "", "", "", "", "", "", "", "", ""], "xun yun": [""], "qing qing jing": ["", ""], "tn dn": ["", ""], bi: [""], "qing jing qing": [""], "j xu": [""], tun: ["", ""], yu: ["", "", "", ""], "shn xin": [""], wn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "png bng": [""], "pio pio": [""], "zhu b": [""], "tu y": [""], "png fng": [""], wng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], c: ["", ""], "di di": [""], hui: ["", "", "", "", "", "", "", "", "", "", ""], "w wng ji": [""], "chng zhng": [""], "d di de": [""], "cng zng": [""], "sh t": [""], "t ch": ["", "", ""], d: ["", "", "", "", "", "", "", ""], "zh zhng": ["", ""], bi: ["", "", "", "", "", ""], "chng zhng": [""], "jio jio": ["", "", ""], "lng lng": [""], "q j": ["", "", "", ""], "dng tng": [""], gi: ["", ""], rn: ["", "", "", "", "", "", "", "", ""], chn: ["", "", "", "", "", "", ""], t: ["", "", "", "", "", ""], "t ti tu": [""], "gn hn": ["", ""], "y q": [""], "ti sh": [""], "x li": [""], "yng yng": ["", "", ""], "mn wn mn": ["", ""], "sng zhng": [""], "y sh": ["", ""], "q sh": ["", ""], "tn zhn dn": [""], "qin qn": ["", ""], hn: ["", "", "", "", "", "", ""], ni: ["", "", "", "", "", "", "", "", "", ""], "kung wng": [""], "kng hng": [""], "ki x": ["", ""], u: ["", ""], "bo bo": [""], "mn mn": [""], "zu zh": [""], zn: [""], yng: ["", "", "", "", "", "", "", ""], "ku j": [""], "no ni": [""], "zhng zhng": ["", "", "", ""], "ti zhn": [""], "h g": [""], "c j z": [""], "s si": [""], "yu chu": [""], "t di": [""], "yu yo": [""], xun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "x xu": [""], "b p": [""], "x sh": [""], "nn nn": [""], "tio yo": [""], "x q x": [""], "xio jio": [""], "h ku": [""], n: ["", "", "", ""], hn: [""], "dng tng": [""], "qun zhun": [""], " w  w": ["", ""], tng: ["", "", "", "", ""], "yun jun": [""], "qio qio": [""], "ji k": [""], "ho jio": [""], hu: ["", "", "", "", "", "", ""], "mn mn": ["", ""], "y y": ["", ""], qun: ["", "", "", ""], "ku l": [""], "y nin": [""], "mn mn": [""], gun: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "kng kng": [""], "ln ln": [""], gu: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "yun wn": ["", ""], "ln ln": [""], "y x": ["", ""], "chu chu": [""], "hn mn": [""], "chng tng": [""], "su ru": [""], cn: ["", "", "", "", "", ""], cn: ["", "", "", "", "", "", "", "", ""], "dn d": ["", ""], r: [""], "y tu": [""], "ki q": [""], "dng tng shng yng": [""], "chn xn dn": [""], "k qi": [""], nu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], gn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "cng sng": [""], "si s s": [""], "gng gng hng": ["", ""], "shu s": ["", ""], "yo yo": [""], hung: ["", "", "", "", "", "", "", ""], zhng: ["", "", "", "", ""], co: ["", "", "", ""], "x xi": [""], "co so": [""], "x ch": [""], "qi qin": [""], "co cng": [""], "o o": [""], "lin lin": ["", "", "", ""], "jn qn jn": [""], "d ch": [""], "zh zh": [""], "lu l": ["", ""], cng: ["", ""], "zh zh": ["", "", "", ""], chng: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], bi: ["", "", "", "", "", ""], "chng dng zhng": [""], "x x": [""], "du dn tn": [""], "xio jio": [""], "xin xin": [""], "lio lio": ["", "", "", ""], shng: ["", "", "", "", "", ""], "no no nng": [""], "jng jng": [""], "j jio": [""], "xun hun": [""], "co so so": [""], mn: ["", "", "", "", ""], "mng mng mng": [""], "i y n": [""], "mng mng": ["", "", ""], "q j j": [""], m: [""], "ln xin": [""], "yu yu": [""], "li li": ["", ""], rng: ["", "", "", ""], hun: ["", "", "", "", "", "", "", "", "", "", ""], nn: ["", "", "", "", "", "", ""], "m m": [""], "gng zhung": ["", ""], "zhung gng": [""], "x qu": [""], "x h": ["", "", ""], "ji g": [""], zi: ["", "", "", "", "", "", ""], dng: ["", ""], "h x": [""], chu: ["", "", ""], "bin pin": [""], "shng jing": [""], "shn shn": [""], ci: ["", "", "", "", "", ""], "zh z zh": [""], "l l ci": [""], "b p": [""], "d d": [""], rng: [""], "fn f": [""], "dio d yu l": [""], "kng gng": [""], "y w": [""], "y w k": [""], "tu ch y": [""], "g ji x g": [""], dn: ["", ""], "so so": ["", ""], ro: ["", "", ""], "x ch q": [""], "bn pn": [""], "b o": [""], "x zh": [""], "zh sn kn": [""], zho: ["", "", ""], "kung wng zi": [""], "h g": ["", "", ""], "b b": [""], "dn shn": [""], "n n ru n": [""], zhu: ["", "", "", "", ""], pu: ["", ""], "zh sh zh": [""], "pu pu f": ["", ""], po: ["", "", "", ""], "o o ni": [""], "ln ln": ["", ""], "qing qing chng": [""], "zh zhi": [""], "b p": ["", ""], "yo to": [""], "h h qi": [""], "n n": [""], "p pi": [""], "m m m": [""], chu: ["", "", "", "", ""], "ji y": [""], "f b": ["", "", ""], zh: ["", "", "", "", ""], "dn dn dn": [""], "chi c": [""], nin: ["", ""], "l l l l": [""], "bn pn": [""], pi: [""], ln: [""], gui: ["", "", ""], "tu t zh": [""], "o o ni": [""], "j gu": [""], "pn pn fn": [""], "bi bi": [""], bi: ["", "", "", "", "", "", "", ""], qi: [""], "nng nng nng": [""], "z zhi": ["", ""], hn: ["", "", ""], "ku gu": [""], "ji ji": [""], nn: [""], shun: ["", "", "", ""], "cn zn": [""], "z zn": ["", ""], ko: ["", "", "", "", ""], "y ch hi": [""], "c s chu": [""], "zhui zhui y": [""], "sh sh": [""], bi: ["", ""], "ku gung": [""], nng: ["", "", ""], "jio jio": ["", "", ""], "ku k": [""], "n r": [""], "tio tio": [""], "di sh": [""], li: ["", ""], "y y": ["", ""], "w zhu": [""], "xi ji": ["", ""], "dng dng": ["", ""], "zhng zhng": ["", "", ""], "i i": [""], "tu shu": ["", ""], "t t": [""], "su sh": [""], "s sh su": [""], "kng qin": ["", ""], "bng png": [""], "ru ru": [""], "jio k": [""], "w w": [""], tng: ["", "", "", "", "", "", "", ""], "hu ch": [""], "t sh ch": [""], "l lu": [""], "sho sho": ["", ""], ni: ["", ""], "sh sng su": [""], "y y": [""], "ju zhu": [""], "b p zh": [""], zn: ["", ""], lo: ["", "", ""], sn: ["", "", "", "", "", "", "", ""], "wn wn wn y": [""], png: ["", "", ""], sh: [""], "f f b": [""], do: [""], "lu lu w": [""], "jun qun": [""], "chn tin": [""], "nin ni": [""], "ru wi r": [""], zu: ["", "", "", "", "", "", ""], "w xi": [""], "qng qin": [""], "pu pu": [""], qi: ["", ""], "pi pi": [""], "qin wn": [""], "y y": [""], "ni n y": [""], "hu x": [""], "yn shn yn": [""], "zhng dng": [""], kng: ["", ""], tu: ["", "", ""], "zu zhu chu": [""], tin: ["", ""], kn: ["", "", ""], p: ["", "", "", "", "", ""], "gu gui": [""], "dn shn": ["", ""], "chn xin cn shn": [""], so: ["", "", "", "", "", "", "", "", "", "", ""], png: ["", "", "", "", ""], "zhng kng": [""], "ji yu": [""], "jin jin": ["", ""], "p ch": [""], "si zng ci": [""], "t d d": [""], "zng sng": [""], "hung yng": [""], "zn zun": [""], "x j": [""], "k qi": [""], "chui chui chui tun zhu": [""], "d t": [""], "l l": [""], l: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "ji q": [""], "chng dng": [""], "di sh y": [""], "jin qin jin": [""], y: ["", "", "", "", "", "", ""], chn: ["", "", "", "", "", "", "", "", ""], "g g": ["", ""], "lu lu": ["", ""], "chu zu": [""], chui: [""], sn: ["", "", "", "", "", "", "", "", "", ""], "rng nng nng": [""], "png bng": [""], cu: ["", "", "", "", "", ""], "k ": [""], "n nu nu": [""], "l xi xin": [""], qi: ["", ""], "xin xin": [""], "ji zh": [""], "pn bn p": [""], bn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zh ni": [""], "w w w": [""], hu: ["", "", "", "", "", "", "", "", "", "", "", ""], "qing qing chng": [""], "tin shn": [""], "n nu": [""], n: [""], "sh ni": ["", ""], bn: ["", "", "", "", "", "", "", "", "", "", "", ""], "sh s shi": [""], "chn sn": [""], "ji li lio jio no": [""], "fng png": [""], shui: [""], "d t zh": [""], "q j ch": [""], "su sng": [""], "lin lin": [""], "gi x": [""], "h ch": [""], tng: ["", "", "", ""], "ni zh": [""], "m m": [""], "jing qing": [""], "o qio": [""], "ni ch": [""], "mn mn": [""], "chn cn": [""], "s m s": [""], "bio bio": [""], "ju ju": [""], pi: ["", "", "", ""], "pi pi": [""], "zn zn zn qin": [""], "s s": [""], hng: ["", "", "", "", ""], "hng gung": [""], nin: ["", "", "", "", "", "", "", "", "", "", "", ""], "chng zhng": [""], "hu wi": [""], co: ["", "", ""], "xio su": [""], "lio lio": [""], "cu zu": [""], "wi tu": [""], cun: ["", "", "", "", "", "", ""], "qio yo j": [""], "zhu w": [""], "li li": [""], nng: ["", "", "", ""], "qng jng": [""], kui: ["", "", ""], "p b": [""], "b bi": [""], "j j": [""], mng: [""], "su su": [""], xng: ["", "", ""], c: [""], "nng nng nng": [""], "zh ji": [""], "l li": ["", ""], "su su": [""], "l lu yu": [""], "t zhi zh": [""], pn: ["", "", "", ""], li: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "c s": [""], "jn pi": [""], "l lu": ["", ""], "l li": ["", ""], "l lu": [""], "zn cun": [""], "xin jin": [""], "m m m": [""], "zn cun zn zun": [""], zun: [""], "l shi": [""], "l lu": [""], "gu gu": [""], "j q y": [""], fng: [""], "w mu": [""], "ch shu": [""], "g gu ": [""], "du du": ["", ""], "du qu": ["", ""], "sn sn": [""], "dn du": ["", ""], "q y j": [""], "xio xu": [""], "sh sh shu": ["", ""], "i zh": ["", ""], "xing xun": [""], "zhu zh": [""], "y d": [""], "l ti": [""], "fi fi": [""], "y zhng": [""], "du du": [""], "w gun": [""], "tu tio": [""], du: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "yn zh": [""], "chn ji": [""], "w y y": [""], "yu li": [""], "png bng": [""], "mo mo": [""], "p b": [""], "xun xun": [""], "w m": [""], zo: ["", "", "", "", "", "", "", "", ""], g: [""], "gn hn": [""], "ti yng": [""], "x x": [""], "tn zhn": [""], "w w": [""], "p pi": [""], zng: ["", "", "", "", "", "", "", ""], i: ["", "", "", "", "", "", "", "", ""], "hung hung": [""], xun: ["", "", "", "", ""], "x ku": [""], hng: [""], shi: ["", ""], "yn yn": ["", ""], "shng chng": ["", "", ""], "jng yng": [""], shn: ["", "", "", "", "", "", "", ""], "q d": [""], "n n yn": [""], "wng wng": [""], zn: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "yn yn": [""], "mn mn": [""], "d sh": [""], sh: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "jin ln": [""], nun: ["", "", ""], "bo p": [""], "x x": [""], "p bo": ["", ""], "q q": [""], "q q": [""], "gng gng": [""], "h h": ["", ""], "zng cng": ["", ""], "cng zng": ["", ""], "cn qin jin": [""], "qi h": [""], "b p": ["", "", "", ""], "yu yu": [""], "bn fn": ["", ""], "f f": ["", ""], "fi k": ["", ""], "q x chn": [""], "jun zu": [""], "hung mng wng": [""], "q j": [""], "tng chung": ["", ""], zh: ["", "", "", "", "", "", "", "", ""], "zh sh sh": [""], "sh sh zh": [""], "zh sh": [""], "p p p pio": [""], "do tio m": [""], "gu qi": [""], xi: ["", "", "", ""], "chng chng": [""], z: ["", "", "", "", "", "", "", ""], "y w": [""], "gn gn": [""], "ch ch": [""], "shn sh": [""], cn: ["", "", "", "", "", ""], "rn r": ["", ""], "sho bio": [""], "d du": ["", ""], "g gi": [""], "y zh l du": [""], "gng gng": [""], "tio tio": ["", ""], "m m": [""], "s zh x": [""], "yun wn": ["", ""], "bi fi": [""], "sh du": [""], "ni chu": [""], "w yu": ["", ""], mo: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "p m": [""], ng: ["", "", ""], "fng bng": [""], "h d": [""], xn: ["", "", "", ""], "yo yo": [""], " ": [""], "zh q": [""], "cng zng": ["", ""], "xin zhn": [""], "ti s": [""], "gu j gu": [""], "bo f": [""], "y xi": ["", ""], "tu du": ["", "", "", ""], "y du l": [""], "n ch": [""], "pn bn": ["", ""], "yng yng yng yng": [""], "f f f": [""], "bi b b": [""], mu: [""], "sho sho": [""], zh: ["", "", "", "", "", "", "", "", "", ""], "yu yu": ["", ""], "gu j": [""], "zh zu": [""], "di zh": ["", ""], "zh z z": [""], "ch zh": ["", ""], "o o": ["", ""], "b f pi b bi": [""], "du zu w": [""], "b bi": [""], "zh ch": [""], "bi pi": [""], "sh fi": [""], "shn zh shi c": [""], "l yu": ["", ""], "q qi": ["", ""], "q x": ["", ""], "gu ku": [""], "bng bn": [""], "xio jio": [""], "jin zn": ["", ""], "yu y": [""], "h h": [""], gn: ["", ""], "zh y": [""], "g g": [""], "hng hng": [""], "gung gung": [""], "y t": ["", ""], sng: ["", "", ""], "j ji": [""], "y mu": [""], "ro no": ["", ""], "gu hu": ["", ""], "chn zhn": [""], "tng yng": [""], "b po": [""], "bn fn": [""], "fng fng": ["", ""], "s yn": [""], "tng tng": [""], "xun jun xi": [""], "t ch": [""], "o yu": [""], kun: ["", "", "", ""], "sho so": [""], "qn chn cn": [""], "l s q": [""], "chn yn": [""], "bn bng": ["", "", ""], "to chu do": [""], "cng sng": [""], "gn hn": [""], "d zh": [""], "pi bi pi": [""], "bng pu bi bi": [""], "d di t": [""], sn: ["", "", "", ""], "rn shn": [""], "lng lng lng": [""], "f s": [""], "zu su": [""], zu: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zho zhu": [""], "chn shn": [""], "ji qi": [""], "y y": [""], "chu zhu dio": [""], "qing kng": [""], "zhu chu": [""], "bi p": [""], mn: [""], "qun jun qun": [""], "du chun": [""], "wi hu": [""], "ji ji": [""], "hn jin": [""], "shn zhn": [""], "yn y": [""], "zh ch": [""], "gu ku": [""], "j zh": [""], "k h": [""], "yu yu": [""], "sng cng": [""], "yun xun": [""], "yng yng yng": [""], pin: ["", "", "", "", "", "", "", "", "", ""], "di y": [""], "dn shn": [""], "cu zu": [""], "d d sh": [""], "ki ji": [""], "ru ru": [""], "l yu": [""], "wn yn": ["", ""], l: ["", "", "", "", "", "", "", "", ""], shn: ["", "", "", "", ""], "b pi": [""], "zhn nin zhn": [""], "f f b": [""], "jin jn": [""], "bng bng": [""], "sh xi": ["", ""], nu: ["", "", "", ""], "qin lin xin": [""], gng: ["", "", "", "", ""], go: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "din zhn zhn": [""], "kn jin": [""], "x di": [""], "j gu": [""], "rng yng": [""], "tun shun qun": [""], "q s": [""], "cu zh": [""], "yu cho": [""], "mn wn": [""], "l ch": [""], "li li": ["", "", ""], "cho jio cho": [""], "chng tng": [""], "ji lio": [""], "m m": [""], "nio m": [""], "hng hng": ["", ""], xu: ["", "", "", "", "", "", ""], "f fi": [""], rn: ["", "", "", "", "", "", ""], "zhn jin": [""], shn: ["", "", "", "", "", "", "", ""], "tu dn": [""], "tng chng": [""], "s qi": [""], "tn din": [""], "fn fn fi": [""], "rn yn": [""], "c chu": [""], "sh qio": [""], "png b": [""], "zhi sh t": [""], "bio bio": [""], "qin lin": [""], "n m": [""], "jin kn": [""], "nu run r": [""], "j j": ["", ""], "hung gu g": [""], "l ch": [""], "mi mi": [""], u: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zh zhu": [""], "ju j": [""], "hui gu": [""], "chn zhn": [""], "wi zu": [""], cng: ["", ""], "y y": [""], "ch q x": [""], "ki i": [""], "y yn": [""], "x ki": [""], "shu su": [""], "i i i i i    ": [""], "q y": [""], "chu x": [""], "ch chui": [""], "kn qin": [""], "kn k": [""], "chun chun": [""], "yn yn": [""], "jn qn": [""], pn: [""], "x chu": [""], "x sh": [""], "lin hn": [""], "zh ch": [""], "s sh": [""], s: [""], "wn m": [""], pio: ["", "", "", "", ""], "qng jng": [""], "fu b": [""], "zh shi": [""], "y yn yn": [""], "hn mi": [""], chu: ["", "", ""], "ku hu": ["", "", ""], cun: ["", "", "", "", "", "", ""], "yn yn yn": [""], "qng kng shng": [""], "yo xio xio": [""], "g g": ["", ""], "gun wn": [""], "d di": [""], "xn xn": [""], m: ["", ""], "du nu": [""], "si su": [""], lu: [""], so: ["", "", "", ""], "sh zh": [""], "d d": [""], "mng mng": [""], "yng r": [""], shu: ["", "", "", ""], "zhng chng zhng": [""], tn: [""], "fn fn": [""], "gu ji": [""], "bn p p": [""], "zhu qu": [""], "d ti": [""], pn: ["", "", ""], "hn hn": ["", ""], tu: [""], "tng shng": ["", ""], "zh j": [""], "gn hn cn": [""], "wn mn": [""], "fng png": [""], "h hung": [""], "ni yu": [""], hng: [""], "shn chn": [""], "dn zhun": [""], "n ni": [""], "mi m": ["", ""], "t d": [""], "m w": [""], "hng png": [""], "sh sh": [""], "zhu z": [""], "u u": ["", ""], "j j": [""], "tu du": [""], "m l": [""], "y ch": [""], "xi y": [""], "b p": [""], "m b": ["", ""], "ch sh": [""], "yu yu o": [""], "png png": ["", ""], "po po": [""], "n n": ["", ""], "yu s": [""], "ju xu": ["", ""], "lng shung": ["", ""], "lu p": ["", ""], "z sh": ["", ""], "s x": [""], "s q z": [""], "x xin": [""], "ko ko": [""], "n yn ": [""], "li li": [""], "qi ji": [""], "qin jin": [""], "j j": ["", "", "", ""], "h x": ["", ""], "jn xn": ["", ""], "yng chng yng": [""], "lin l": [""], "fng hng": ["", ""], "jing jing": [""], "su ni": [""], "yng chng": [""], "tn yn": [""], "w gu": ["", ""], hng: ["", ""], "zhng zhng": ["", ""], "shu to": [""], shun: ["", ""], "kng nng": [""], "w wn yun": [""], "tu tu": [""], w: ["", "", "", "", "", "", "", "", ""], "qi j": [""], "gu gun": [""], "ln ln": ["", "", ""], "tng chng": [""], "no chu zhu": [""], "png png": [""], fi: ["", "", "", ""], "p pi": [""], "nin shn": [""], "bio h": [""], "chn zhn": [""], "hn hn": [""], qin: ["", "", "", "", "", "", "", "", "", ""], "wn mn": [""], "r ru lu": [""], "d du": ["", "", ""], "jin jin": ["", "", "", ""], "min shng": ["", ""], "nun nun": [""], "qi w": [""], "tng tng": [""], "d t d": [""], "gng jing": [""], "hng qng": [""], tun: ["", ""], "hu mn x": [""], "x x": [""], pn: ["", "", "", ""], "mn hn": [""], "tun nun": [""], "qi jio": ["", ""], "yn yn": [""], "bn pn": [""], "zhung hn": [""], "yn gu": [""], "lin lin nin xin xin": [""], "d t": ["", ""], "li li": ["", "", ""], ln: [""], m: ["", "", "", "", "", "", "", "", "", "", "", "", ""], "zhn qn": [""], "n nio": [""], "ch x": ["", ""], "wng wng": [""], "ho xu": [""], "q x xi": [""], "xng yng": [""], "z ho": [""], "pio pio pio": [""], "cng sng": [""], "fng png": [""], "lu t": [""], "png bn": [""], "chng shung": [""], "hu ku hu": [""], "lio li": [""], "cu cu": [""], "cng zng": [""], "cng zng": [""], "p pi": [""], "dng xing": [""], "hung gung": [""], "lio lo lo": [""], "cng zng": [""], "zh zh": [""], "tn shn": [""], "t zh": [""], "sn s": [""], hi: ["", "", "", ""], "chng dng": ["", ""], "cn cn": [""], "png png": [""], "hng gng": ["", ""], "wn mn": [""], "kui hu": [""], "gu w": [""], "pn fn": [""], "j sh": [""], "hu hu": [""], "dng tng": [""], "m n": [""], "b p": [""], "cu zu": [""], "h hu": [""], "i ki k": [""], "wi du": ["", ""], "zn cun": ["", ""], "yng yng": [""], "wng wng": [""], "m mi": ["", ""], su: ["", "", ""], "hui wi": [""], "zn jin": [""], "yng yng yng": [""], "rng rng": [""], shung: [""], "zhu jio z": [""], s: ["", "", ""], "lun lun": [""], "dng tng": [""], "xn qun qun": [""], "hu bio": [""], "zh y": [""], "fn bn": [""], "jing gu": [""], "png fng": [""], qu: ["", "", "", ""], bin: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "zho zho": [""], "zhu ch": [""], "po po bo": [""], "po fu": [""], "shn qin shn": [""], "zh zh": [""], "jio yo": [""], qun: ["", "", "", "", "", "", ""], "yng yng": [""], "lo lu": [""], "hu hu": [""], r: ["", ""], "f po": [""], "xi ch": ["", ""], "yn shn": [""], "hn xn": [""], ko: ["", "", "", "", "", "", "", "", ""], "jun y": [""], "jn q": [""], "to do": [""], "cho j": [""], "w i": [""], "zng cng": [""], "x y": [""], "xn xn": [""], "cho zhu": [""], "xing yng": ["", ""], ku: ["", "", "", "", ""], "hu yn xn": [""], "jio qio": [""], "qin shn shn": [""], "x y": [""], "sh sh": [""], "y zh": [""], "yng yng": [""], "n yn": [""], "yn yn": [""], "h xio": [""], xing: ["", "", ""], "xn xn": ["", ""], gng: ["", "", ""], li: [""], "cng zng": [""], "l o": [""], "sh shu": [""], "fng png": [""], "cu su": [""], tng: ["", "", ""], "yn y": [""], "o o": [""], "hn rn": [""], "u u": [""], "hung hung": [""], "chn dn chn": [""], "jio zhu qio ju": [""], "yn yn": [""], "ti li": [""], o: [""], "yn xn": [""], "ju jio": ["", "", "", "", ""], "ln ln": [""], "zhu zho": [""], "zho zhu": [""], "f f": [""], di: ["", "", ""], zng: ["", "", "", "", "", "", "", "", ""], "pin pin": [""], "bin min": [""], bng: ["", "", ""], "yu yng": [""], "chng chng": ["", ""], ni: ["", ""], "ji l": [""], "m mu": [""], mng: [""], "g qi": [""], "yu chu": [""], "t zh": [""], bn: ["", "", ""], "jin qin": ["", ""], m: ["", "", "", "", ""], "mo l": [""], "b qun": [""], "zhu bo": [""], "n hn": [""], "kng gng": [""], "pi fi": [""], "fn hun": [""], kung: ["", "", "", "", "", "", "", ""], "y qun ch": [""], "xng shng": [""], "tu y": [""], k: ["", ""], "hun hun": [""], "h m": [""], "t sh": [""], "mng du": [""], "x sh": [""], sun: ["", "", ""], "bi p": [""], "jin yn": ["", ""], "y y": [""], "y wi": [""], ci: [""], "mo mo": ["", ""], "chun chun": [""], "tun tun": ["", ""], "y ji qi": [""], "h xi g hi": [""], "bin pin": ["", ""], "b p": [""], "ho go": [""], "fn fn": [""], "yo xio": [""], "shu x": [""], "g li xi": [""], "nu r": [""], "no no yu": [""], rng: ["", "", "", "", "", "", "", ""], "no yu": [""], "l shui": [""], "wng wng": [""], "yng chng": [""], "mn wn": [""], "bn fn": [""], "mn yn": [""], "qing cng": ["", "", ""], "n gn": [""], "xun xin": [""], "c c": ["", ""], "y ti": [""], "z j": [""], f: ["", "", "", "", ""], "yn kn": [""], "hu hn": [""], "xun qing": [""], "f f": [""], "bng pn": [""], "cu s": [""], "y wi": [""], "tin tin": [""], "zhu zu": [""], "bng pi": [""], gun: ["", "", "", "", "", "", "", "", "", "", ""], "hn hu": [""], "xi ji": [""], "chng dng yng": [""], "tin zhn": [""], "bn pin": ["", ""], "t sh": [""], cu: ["", "", ""], "zo su": [""], "ju qing": [""], "l f": [""], "j z": [""], su: ["", "", "", "", "", "", ""], "m x": [""], "qing wi wi": [""], "hun y y": [""], "b po": [""], "zh h": [""], pio: ["", ""], "w w": [""], "xing hng": [""], wng: ["", "", "", "", ""], "shn shn": [""], ru: ["", "", ""], yng: ["", "", "", "", "", ""], shui: [""], bng: ["", ""], "yu zh": [""], "din tin shng": [""], "tng dng": ["", ""], "zi z": [""], "b q": [""], "d f": [""], "c j": [""], "zi z tin": [""], "zh chu sh": [""], "fn pn": ["", ""], "sh y": [""], "dng dng dng": [""], "jing qing": [""], "p y sh": [""], "ji qi": [""], "y n": [""], n: ["", "", "", ""], "g y": [""], "n yo": ["", ""], "l li": ["", ""], "y xi": [""], xu: ["", "", "", "", "", "", ""], "dn da": [""], "f bin": [""], "fi fi": ["", ""], "shn din": [""], "tng chng": [""], "tng tng": [""], "wi yu y": [""], "tn sh": [""], "p p": ["", ""], "bng png": [""], "m ln": [""], "tin din": [""], "n y ": [""], "k ": [""], "zh ch": [""], "ji xi xi": [""], "li hu": [""], "chi cu": [""], "din chn": [""], "da d": [""], "bi bi": [""], qu: [""], "dn dn": [""], "gu wi": [""], "nng nng": [""], "bi bi": [""], "b b": [""], bi: [""], "j b": [""], "de d d d": [""], "p b": [""], "go ho": [""], "go yo": [""], "l lu b": [""], "zh c": [""], "zho zhn dn": [""], "jin jin": ["", "", "", "", ""], "gi g h": [""], "mng wng": [""], yun: ["", "", ""], "tin xin": [""], "xing xing": [""], dn: ["", "", ""], "x pn": [""], "shng xng": [""], "yn hn": [""], "min min": [""], "kn kn": [""], "yng yng yng": [""], "yo o o": [""], "j x ku": [""], "y ch": [""], "di t": [""], "bng fng": [""], "png pn": [""], "m m": ["", ""], "xun shn xn": [""], tio: ["", "", "", "", ""], "zhe zhu zho zho": [""], "qio sho xio": [""], "cu zhui": [""], gn: ["", ""], "su zu": [""], "p b": ["", "", ""], "y z go": [""], "xng xng": [""], "gu wi ku": [""], "ku j": [""], "qing hun": [""], "mn mn": ["", ""], "dio du": [""], "lou lu l": [""], "shn rn": [""], "lio lio": ["", ""], "jin xin": [""], "w m": [""], "gu ku": [""], "nng chng": [""], "hu yu": [""], "mng mng": [""], "kung gu": [""], "gun qun": [""], "mn mn": [""], "jn gun qn": [""], "jn qn gun": [""], "y x ju": [""], "jio jio": ["", ""], dun: [""], "sh dn": [""], "gng qing kng": [""], "hu x": [""], "pn bn fn": [""], "yn yn": ["", ""], "lu k": [""], "f fi": ["", ""], "zh zh": [""], "l l l": [""], "kung gung": [""], "g lu": [""], "shu sh": ["", ""], "wi wi i": [""], "qu k k": [""], "mng bng": [""], "lu lng": [""], "yng tng": [""], n: ["", ""], "kng kng": [""], "yn yn": [""], "zhu chu du": [""], "kng kng": [""], "zng cng": [""], "jin zhn": [""], "l li": ["", ""], "qu x": [""], "ln ln ln": [""], "no gng": [""], "ji y": [""], "wi wi": [""], "t d": [""], "ch ch": [""], "qio qu": [""], "s xi": [""], "li li": ["", "", "", ""], "s t": [""], "bng png": [""], "hu k g": [""], "wi ku": [""], "xi qi y": [""], "lin qin": [""], "wi i gi": [""], "l l": [""], "o qio": [""], "png png": ["", ""], "yn yn": [""], "li li": [""], "m m": [""], "q zh": [""], "lo lu": [""], "pn b": [""], "j sh": [""], "h qio qio": [""], "k hu": [""], "qu h": [""], " q": [""], c: ["", ""], "xin xn": [""], "li li li": [""], "yn yn": [""], "q zh": ["", ""], "bng fng": [""], "b m": [""], sun: ["", "", "", "", ""], "pio pio": [""], "j zhi": [""], "shu li": [""], "jn jn": [""], "chn shn": [""], "yng shng": [""], "zh zh t": [""], "shn chn": [""], "y y u": [""], "z z": [""], "ch n": [""], "zhng zhng chng": [""], "ho mo": [""], "k k": [""], z: ["", ""], chng: ["", ""], "hu ku": ["", ""], "chng chn chng": ["", ""], "sh zh": ["", ""], "f p": [""], "xn z": [""], "t sh": [""], "zhn zhn": [""], "j q": ["", "", ""], "lng lng": [""], "zu z s": [""], "x qi": ["", ""], "zhng zhng": [""], "zng zng": [""], "xin jin lin": [""], "z ji": [""], "j q": [""], rng: [""], "shn cn cn": [""], "mn mi": [""], "j j": [""], "xio ro": [""], "zhu b": [""], "tng zhng zhng": [""], zu: [""], "bio po": ["", ""], "zhu ju": [""], "cun zn": [""], "kng kng kng": [""], "y y": [""], zhi: ["", ""], bo: ["", ""], "k zh": [""], "jio lio li": [""], "w gu": [""], "tio yo": [""], "xn yn": [""], "y y": [""], "tin din yn": [""], "cho k": [""], "kun cun": ["", ""], "ch q": [""], "q ku": [""], "jng zhn": [""], "kn kn": [""], "zh d": [""], "l jn": [""], "zhu ru": [""], "hng hng": [""], "cn jn hn": [""], "d xi n": [""], "z zu": [""], "lng lng": ["", "", "", "", ""], "zh zh": ["", ""], "d d": ["", ""], shi: ["", "", "", ""], "yn jn": [""], "lng lng": ["", "", ""], "zh zh": [""], o: [""], "pu b f p": [""], "pi bi": [""], g: ["", "", "", ""], "ti ch": [""], "gui di": [""], "zho do": [""], "jng qng": [""], "ln ln": [""], "jn qn": [""], "sh y": ["", ""], "yu yo chu": [""], "xio shu qio": [""], "gng gn lng": [""], "png png": [""], "zhu hu": [""], "jin jin": [""], "d zh": [""], "zn cn cn": [""], "zhun sun zun": [""], "pio bio": [""], "gu gu": [""], "c j": [""], "m mi": [""], "shi s": [""], "sn zhun": [""], "gn gn": [""], "b b": [""], "b b": [""], shi: [""], "zhn jin": [""], "zhun zun": [""], "fn pn bin": [""], "su sh": [""], zun: ["", "", "", "", "", ""], n: ["", "", ""], "sh cho": [""], "kng jng": [""], fn: ["", ""], c: ["", "", "", "", ""], "nin zhn": [""], "c s": [""], "zhu y": [""], "shn sn": [""], "bin bin": ["", ""], min: ["", "", "", "", "", "", ""], "h h h": [""], "g gu": [""], "m mi": [""], "sn shn": ["", ""], zo: ["", "", "", ""], "m s": [""], "ji ji": [""], "x j": ["", ""], "zhng zhng": [""], "ch ch": ["", ""], "yu yo": ["", ""], "hng gng": ["", ""], "h g": ["", ""], "wn wn": ["", ""], fu: [""], "j ji ji": [""], "p p b": ["", ""], "jn jn": [""], "zh z": ["", ""], h: [""], "f f": [""], "chu chu": [""], "li li li": [""], "b b": [""], "tin zhn": [""], "jing jing": [""], "ji ji": ["", "", ""], "gu ku": [""], "bi m": [""], "gng hun": [""], "ji xi": [""], "qun shun": [""], "gi i": [""], "lu lo": ["", ""], "bng bng png": [""], "gi j": ["", ""], "tng tng dng": [""], "tio dio do": [""], "li li li": [""], "gi hi": [""], "ch zh": [""], "wn min mn wn": [""], "hun hun wn": [""], "qn xin": [""], "t t": [""], "yn xin": [""], "zng zng zng": [""], "chn ln": [""], "zhn zhn": [""], "qin qng zhng": [""], "qng q": [""], "ln gun": ["", ""], "chu cho": ["", ""], "tin tn chn": [""], "l l": ["", ""], "run run": [""], "j q": [""], "zhng chng": ["", ""], "mio mo": [""], "xi y": [""], hun: ["", "", ""], "gng gng": ["", ""], "tu x sh": [""], "zng zng": ["", ""], "yn gn": [""], "gu w": [""], "yn yn wn": ["", ""], "bng bng": [""], "g h": ["", ""], "c cu su": [""], "cu shui": [""], "rng rng rng": [""], "zi zng": [""], ci: ["", "", ""], "fng fng": [""], "su s": ["", ""], "yn yn": ["", ""], "zng zng": ["", ""], "zhun jun": [""], "m m": ["", ""], "pio pio": ["", ""], "fn p": [""], "bng bng": [""], "mu mi mio lio": [""], "yo yu zhu": [""], "zng zng": ["", ""], "j ju": [""], "chu chu": [""], "zn zn": [""], ro: ["", "", ""], "chn chn": [""], "hu hu": ["", "", ""], "qio so zo": [""], "jio zhu": ["", ""], "dn tn chn": [""], nng: [""], "p f": [""], "yo l": [""], "rng xing": [""], "l s x l": [""], "xin qin": [""], "jng jng": [""], "t t": [""], "bng bng bng": [""], "zng zng": [""], "j q": [""], "wn yn yn": [""], "fng fng": [""], "shui cu su": [""], "mi mu lio mio m": [""], "qio so": [""], fu: ["", "", "", "", ""], "b ba p": ["", ""], "gu gui": [""], "yng xing": ["", ""], "mi go": [""], "y x": [""], "qing qin": [""], "qing kng": [""], "qin xin yn": [""], nu: [""], "hng gng": [""], "p b p": [""], "q y": [""], k: [""], "qio qio": [""], "zhi d": [""], "do zhu": [""], "hu q": [""], shu: [""], "run nu": [""], "r ni": [""], "zhun dun": [""], "p b": [""], "ch s": [""], "q ch": [""], "ln ln": [""], "j ji": [""], "tng tng": [""], png: ["", ""], "zh z": [""], "y y": [""], "yn yng": [""], "w tu zhu": [""], "r n": [""], "ti zh": [""], "d zh": [""], qi: [""], "n jin": [""], "li l": [""], co: ["", "", "", ""], "b d": [""], "xio xio": [""], "d d": [""], chi: ["", "", ""], "hn qn hn": [""], "png pn pn": ["", ""], "zhn chn": [""], ng: ["", ""], "y y": [""], "p b b": [""], "fi b": [""], "bi bi": [""], "fi z": [""], "png png": ["", ""], "f f zhu": [""], "shng shng": [""], ku: ["", "", ""], "gi hi": [""], "g g g": [""], "nng ni": [""], "gu ku": [""], "mi m": [""], "zng zng": [""], "jio ju": ["", ""], cu: [""], "de te": [""], "zu jun": [""], ni: ["", "", "", "", "", ""], "p f": [""], nio: [""], shu: [""], gu: ["", "", ""], "l x": [""], "yn ": [""], "go go": [""], "l bio": [""], chui: [""], "zhun chun chn zhun": [""], chui: ["", ""], "fn pn": [""], "w h": [""], "shn dn": [""], tn: ["", "", "", "", "", "", "", "", "", "", "", ""], "b bei": [""], "l g": [""], "so so": [""], no: ["", "", "", ""], "n lun": [""], "qin xin": [""], "gung jing": [""], "gung jing": [""], "chu xi": [""], "min bin": [""], "di zh": [""], "zh jn": [""], "sh sh": [""], p: ["", ""], "bn b pn": [""], ku: [""], "gn gn": [""], "s shi": [""], "f b": [""], "jio qi": [""], "chi ch": [""], "sho qu": [""], "h xi": [""], "z z": [""], "hu h": [""], "tn chn": [""], "ji gi": [""], "x zh": [""], "yun yn": [""], "xn xn": [""], "ln hu": [""], "w h": [""], "gu gu": [""], "mo mo": [""], "fi f": [""], "chn yn": [""], qi: [""], "s s": [""], "tio sho": [""], "l j": [""], "k h": [""], "j q": [""], "ru r": [""], "zh nng": [""], "p b": [""], xi: [""], "zh zu": [""], "j ch": [""], ni: [""], "shng ru": [""], "qi ji": [""], "z c": [""], "qin x": [""], chi: [""], "f pi": [""], ro: ["", "", "", "", ""], "yng xng": [""], "qin xn": ["", ""], "yn yn": [""], "h h": [""], "sh su": [""], "png fng": [""], "shn xn": [""], "wn gun gun": [""], "yu s": [""], "sho xio": ["", ""], "lng ling": [""], "pio f": [""], "wn wn min": [""], "sh sh": ["", ""], "t t": [""], "xin lin": ["", ""], "wn y": [""], "zu ch": [""], "l l": [""], "jn jn": [""], "ni rn": [""], "z z zi": [""], "t t": [""], "ji sh": [""], "qio zho": [""], "ti zh ch": [""], "fi fi": ["", ""], "qn qn jn": [""], "z j": ["", ""], "ln m": [""], "tin tin": [""], ti: ["", "", ""], "lu l lo lu": [""], "zh zhu zhe": [""], "shn rn": [""], "g g": [""], "jn su": [""], "ku kui": [""], "r n": [""], "mng mng mng": [""], "yun hun": [""], "x sh": [""], "x x": [""], "m mng": [""], "su su": [""], "gi g h hi": [""], "yo zhu": [""], "dio tio d": [""], "x qi f": [""], "z j": [""], "lio l": [""], xu: [""], "hn hn": [""], "mn wn mn": [""], "p b": [""], "fn fn b": [""], "hng hng": [""], "y o": ["", ""], "x xio": [""], "bo b b": [""], "c z": [""], "wn lun": [""], "ko ho": [""], "yun wi": [""], "zhu chu": [""], "w mi": [""], "xio ho": [""], "y x x": [""], "ji j": [""], "dio zhu": [""], "cng zng": [""], l: [""], "ch zh": [""], "pn png": [""], "gn hn": [""], "hng jing": [""], "hu hu": [""], "xi h": [""], "m m m": [""], "fng bng": [""], "bng bng": [""], "ju qu": [""], "qn qin": [""], "gng zhng": [""], "f f": [""], "di d": [""], "gu q x": [""], "b p": [""], "sh y": [""], ti: ["", "", "", "", "", "", ""], "g lu": [""], "mng bng": [""], "y x": [""], "h g": [""], "qi n": [""], " y": [""], "zh zh": [""], "l zh": [""], su: ["", ""], "yu qi": [""], "xi h": [""], "x q": [""], "b p": [""], "ni nng": [""], "h xi": [""], "gu hu": [""], "m m m": [""], "sh zh": [""], "zh di": [""], "jin chn": [""], "ma m m": [""], "mng mng": [""], "bi bi": [""], "bn fi": [""], "lo lio": [""], "yn xn": [""], "l l": [""], "xu xi": [""], "xng hng hng hng": [""], "shui cu": [""], "tu tu": [""], "lng lng": [""], "bo po po": [""], "j ji": [""], "h k": [""], "y y": ["", ""], "n ju": [""], "bi p": [""], "ch nu": [""], "ch q du nu": [""], "ji qi ji": [""], "b m": [""], "gu gu": [""], "li li": [""], "chng chng": [""], "ji g": [""], "do chu": [""], "shang chng": [""], "yun gn": [""], "yn n": [""], "t x": [""], "f f": [""], "ch zh": [""], "tu tn": [""], li: [""], "yo yo": [""], "qn tn": [""], "jin xin": ["", ""], pin: ["", "", "", "", ""], "pi mi": [""], "yng yng": [""], "q q": ["", "", ""], "jin bin": [""], "lu lun": [""], "z zu": [""], "hu xi": [""], "ji ji xi": ["", ""], "xu h": [""], "l l": [""], to: ["", ""], zhn: [""], "z z": [""], "y di": ["", ""], xing: ["", ""], "dio tio": [""], "y ch ch": [""], "lng lng": [""], "i i i i x": ["", ""], shu: [""], "y y": ["", "", ""], "shu shu yu": ["", ""], "shu shi": ["", ""], "q ju": [""], "ch li": [""], "n n": [""], "dio tio": [""], "p bi": [""], "j j": [""], "z zu zh cu": [""], "ch j": [""], "ho xi": [""], "ln ln": ["", ""], "sh d": [""], "hu gu": [""], "x shi i": [""], "nn nn": ["", ""], mi: ["", ""], zn: ["", ""], "sh zh": ["", ""], "jun xun": [""], "y tu": [""], zhn: [""], "x h": [""], "xing yng": [""], "tio dio zhu": [""], "chn shn": [""], "m mi": [""], "mn mn": [""], "g y": [""], "hu hu hu": [""], "zh zhi": [""], "hun hun": [""], "kn kn": [""], "m h": [""], "m h ho": [""], "j lu": [""], "z zhi": ["", ""], "di t": [""], "b bn": [""], "ji g ji": [""], "xing mn": [""], cng: [""], "zhun zun": ["", ""], "wn zhun": [""], "gn gng zhung": [""], "yun yn": [""], "bn b": [""], "ji g": [""], zu: ["", "", ""], "di t": [""], "j qi": [""], "q c": ["", ""], "j ji": [""], "gu hu": [""], "qu q j": [""], "tng tng": [""], "chu zhu": [""], "q c": [""], "yu t": [""], "b bo": [""], "ku w": [""], "gu ju": [""], "fng fng png": [""], "po b": [""], "q q": [""], "jin chn": [""], "po po": [""], "din di ti": [""], "j j qi": [""], b: [""], "lu l": [""], "di du du ch": [""], zhui: [""], "bng pin": [""], "tio to": [""], "sh chu": [""], "ling ling": [""], "t t": [""], ch: ["", "", ""], "d zh": [""], "dng dng": ["", "", ""], cng: [""], "dn cn": [""], "ju ju": [""], lio: [""], "xi s": [""], t: ["", "", ""], "y zh g": ["", ""], "xn xin": [""], "fn gu": [""], "zhun zhun": [""], "zhu zhu": ["", ""], b: ["", "", ""], "zhun zhun zhui": [""], "zi zi": [""], "nin zhn": [""], "bin bian": [""], "do bin": [""], "y y": ["", "", ""], "gu guo gu": [""], "wng kung": [""], "hi hun": [""], "zh zhi": [""], "yun yun": [""], "zh l": [""], "zh wng": [""], "zhu du": [""], "sh ku": [""], tu: [""], "tng tng": [""], gung: [""], "di di": [""], "su su": [""], "t d": [""], "y wi": [""], "sh d zh": [""], c: [""], "hun hi": [""], "l ch": [""], "kng hng": [""], "n ni n": [""], "xi y y y x": [""], "gi hi": [""], "hun xn": [""], "ch x": [""], ho: [""], "l zh": [""], "xio o": [""], "du d": [""], lio: ["", "", ""], "zn cun cu": ["", ""], "dng dng": [""], "c zu": [""], "f p": [""], "shi sh": [""], ning: ["", ""], "qi chu": [""], "p f": ["", ""], "chn chn": [""], "yn lin xin": [""], "ning ning": [""], "l li": [""], "l x x": [""], "lio lio": [""], "dng dng": ["", ""], "qio jio": [""], "y hu": [""], "hu w": [""], "r rn jin": ["", ""], "d di": [""], "p zho": [""], "y y": [""], "b p": ["", ""], "t tu": ["", ""], bi: [""], "bng png": [""], "h k": ["", ""], chng: ["", ""], "xing jing": [""], "y s": [""], "x hu": [""], "rn rn": [""], "shn shu": [""], "ch l": [""], "xin x": ["", ""], "hu xing": [""], "dio tio yo": [""], "xin ku tin gu": ["", "", ""], "zh ni": [""], "zhng yng": [""], "tu t du": [""], "mi mng": [""], "wn jin": ["", ""], "tng dng": ["", ""], "jun jin cun": [""], "s tu": [""], "jun xun jun": [""], "w hu w": [""], "zhu chu": [""], "xng xng jng": [""], "j j": ["", ""], "zu ni": [""], "yun yun wn wn": [""], "gng gng": ["", ""], zhu: ["", "", "", "", ""], : ["", ""], "cu ch": [""], "su s": [""], "yo z": [""], "y t g": [""], "qing chng": [""], "g l": ["", "", ""], "b p b": [""], "go ho": [""], "z chu": [""], "xi xi": [""], "shu su": [""], "d d": ["", ""], "qio sn cn": [""], "l o": [""], "tng tng": [""], "jin zn": [""], "hu su ru": [""], "qing qing": ["", ""], "sn xin s": [""], "jin jin": ["", ""], "dng chng": ["", ""], "zun zun": [""], "s x": [""], "yo yu": [""], "tu du": [""], "zun zun": [""], "qin yn": [""], "p p": [""], "yo dio tio": [""], "tng tng": [""], "p p": [""], "tn xin": [""], "li li": [""], "ho go": [""], "tng tng": [""], "tn chn xn": [""], "hu shn": [""], "hn b": ["", ""], "kng kng": ["", ""], "xin jin jin jin": [""], "xi xi": [""], "xi k": [""], "bin gun": [""], "h g": ["", ""], "hng xing": [""], "s x": [""], "tng tng": [""], " yn": ["", ""], "hng jun xing": [""], "bn pn": [""], "d sh": ["", ""], "qu qu": [""], "tng tng chng": [""], "kn hn": ["", ""], "x s t": [""], "mn mn": [""], "qu qu": [""], "yn din": [""], " ": [""], "bi p p": [""], "yn yn": [""], "y yo sh": [""], "lng lng": [""], "du zhu": [""], "su du": [""], "gi q i": [""], "hu du": ["", ""], "wi ku": [""], "l di": [""], "zhu cu wi": [""], "h h": ["", ""], "jn jun": ["", ""], "nn nn nu": [""], "qu qio qio": [""], "gun hun": [""], "gu x": [""], "s x": [""], n: [""], "w mng": [""], tng: [""], "l lu": [""], mi: [""], "jng ling": [""], "g j": [""], b: [""], "yng yng": [""], "g t s": [""], "bin yng": [""], "qio sho": [""], "jun xun": [""], "shng zhng": [""], "p bng b bi": [""], la: [""], "xi di": [""], ng: [""], "mu m": [""], "b bng": [""], "mi w": [""], ru: [""], "sh xi": [""], "yn wn": [""], "dn d": ["", ""], du: [""], lu: [""], "bn pn": [""], yng: ["", "", ""], mn: ["", ""], "jng gng": [""], "ji xi ji": [""], "k k": [""], "pn bn": [""], "chn zhn": [""], "fng fng": ["", ""], "bio di": [""], "b f": [""], "so su": [""], "li lio": [""], "sh s y": [""], "yng jun": [""], "zh tu": [""], "y s": [""], "zu z zh": [""], ti: ["", ""], "xing nng": [""], "tng xng": [""], "g le": [""], "ch zha": [""], "nng nng": [""], "yn w": [""], "zh sh": [""], "xn jn": [""], "kui ju": [""], zng: ["", ""], "ti di": [""], "xn xun": [""], "ling lng": [""], pin: ["", "", "", ""], "di ti": [""], "so so": [""], "g g": [""], "bi m": [""], "xio qio": [""], "bng png": [""], "b ju": [""], "b p": [""], "mo mng": [""], "ku yu": [""], "b b": ["", ""], "j c": [""], "b b": [""], "zh zh": ["", ""], "chu di": [""], "lu g": [""], "gu xi w ku": [""], "xin xin": ["", ""], "p b": [""], "y s": [""], "b b": [""], "gu xi": [""], "si x": [""], "nio dio": [""], "dio zho": [""], "gn hn yn": [""], "f gu": [""], "jin qin zhn": [""], "h ji": [""], "pin bin": [""], "chun zh": [""], "cng qing": [""], "sn xn": [""], "bio po": [""], "zh c": [""], "jn qn": ["", ""], chi: [""], "m me": [""], "m me ma": [""], "m m": [""], "dn shn": [""], "zhn yn": [""], "dn zhn": [""], "min mn mng": [""], hu: [""], nng: [""], "q j z zhi": [""], "yn kn yn": [""], "yn kn": [""], "gng w": [""], "gu jn qi": ["", ""], "ku w": [""], lu: [""], "u q": [""], "lu l": [""], "g g g": [""], "w gu": [""], "zh d": [""], "gng hng": [""], "yo xio": [""] }, kl = new fO();
      Object.keys(gO).forEach((n) => {
        const t = gO[n];
        for (let e of t) kl.set(e, n);
      });
      const tst = ["zh", "ch", "sh", "z", "c", "s", "b", "p", "m", "f", "d", "t", "n", "l", "g", "k", "h", "j", "q", "x", "r", "y", "w", ""], est = ["j", "q", "x"], nst = ["un", "un", "un", "un", "uan", "u", "u", "u", "u", "ue", "n", "n", "n", "n", "un", "", "", "", "", "u"], ist = { un: "n", un: "n", un: "n", un: "n", uan: "an", u: "", u: "", u: "", u: "", ue: "e", n: "n", n: "n", n: "n", n: "n", un: "n", : "", : "", : "", : "", u: "" }, rst = ["ia", "ian", "iang", "iao", "ie", "iu", "iong", "ua", "uai", "uan", "uang", "ue", "ui", "uo", "an", "e", "van", "ve"], dO = { : "y", : "r", : "sn", : "s", : "w", : "li", : "q", : "b", : "ji", : "sh", : "bi", : "qin", : "wn", : "y", : "dn", : "ling", : "shung", : "du", : "j", : "sh y", : "lng y", : "d y", : "y sh", : "y sh y" }, AO = { : "chng", : "hng", : "du", : "gng" };
      function ast() {
        const n = { : "lng y", "": "lng y", : "sh y", : "y sh", : "d y", : "y sh y" };
        for (let t in dO) for (let e in AO) {
          const i = `${t}${e}`, r = `${dO[t]} ${AO[e]}`;
          n[i] = r;
        }
        return n;
      }
      const pO = ast(), ost = Object.keys(pO).map((n) => ({ zh: n, pinyin: pO[n], probability: 1e-12, length: Va(n), priority: Gr.Normal, dict: Symbol("rule") })), vO = { : { b: [4] }, : { y: [4], y: [1, 2, 3] } }, sst = { : ["", "", "", "", "", "", ""], : ["", "", "", "", "", "", ""] }, lst = Object.keys(vO);
      function ust(n, t, e) {
        if (lst.indexOf(n) === -1) return tp(n);
        if (t === e && t && tp(t) !== t) return w0(tp(n));
        if (e && !sst[n].includes(e)) {
          const i = tp(e);
          if (i !== e) {
            const r = b0(i), a = vO[n];
            for (let o in a) if (a[o].indexOf(Number(r)) !== -1) return o;
          }
        }
      }
      function hst(n, t) {
        if (n === "" && (!t || !kl.get(t))) return "lio";
      }
      function cst(n, t) {
        if (n === "") return !t || !kl.get(t) ? "tng" : kl.get(t).split(" ")[0];
      }
      function yO(n, t, e) {
        return cst(n, t) || hst(n, t) || ust(n, t, e) || tp(n);
      }
      const AC = { : "nn gng", : "d w", : "m q", : "s m", : "shng gun", : "u yng", : "xi hu", : "zh g", : "wn rn", : "dng fng", : "h lin", : "hung f", : "y ch", : "gng yng", : "tn ti", : "gng y", : "zng zhng", : "p yng", : "chn y", : "ti sh", : "shn t", : "gng sn", : "zhng sn", : "xun yun", : "lng h", : "zhng l", : "y wn", : "zhng sn", : "m rng", : "xin y", : "l qi", : "s t", : "s kng", : "q gun", : "s ku", : "zhng d", : "z j", : "zhun sn", : "dun m", : "w m", : "gng x", : "q dio", : "yu zhng", : "rng s", : "gng ling", : "tu b", : "ji g", : "zi f", : "g ling", : "dun gn", : "bi l", : "dng gu", : "nn mn", : "h yn", : "yng sh", : "ling qi", : "zu qi", : "dng mn", : "x mn", : "gu lng", : "gun qi", : "zho", : "qin", : "sn", : "l", : "zhu", : "w", : "zhng", : "wng", : "fng", : "chn", : "ch", : "wi", : "jing", : "shn", : "hn", : "yng", : "zh", : "qn", : "yu", : "x", : "h", : "l", : "sh", : "zhng", : "kng", : "co", : "yn", : "hu", : "jn", : "wi", : "to", : "jing", : "q", : "xi", : "zu", : "y", : "bi", : "shu", : "du", : "zhng", : "yn", : "s", : "pn", : "g", : "x", : "fn", : "png", : "lng", : "l", : "wi", : "chng", : "m", : "mio", : "fng", : "hu", : "fng", : "y", : "rn", : "yun", : "li", : "fng", : "bo", : "sh", : "tng", : "fi", : "lin", : "cn", : "xu", : "li", : "h", : "n", : "tng", : "tng", : "yn", : "lu", : "b", : "ho", : "w", : "n", : "chng", : "yu", : "y", : "sh", : "f", : "p", : "bin", : "q", : "kng", : "w", : "y", : "yun", : "b", : "g", : "mng", : "png", : "hung", : "h", : "m", : "xio", : "yn", : "yo", : "sho", : "zhn", : "wng", : "q", : "mo", : "y", : "d", : "m", : "bi", : "mng", : "zng", : "j", : "f", : "chng", : "di", : "tn", : "sng", : "mo", : "png", : "xing", : "j", : "sh", : "q", : "xing", : "zh", : "dng", : "ling", : "d", : "run", : "ln", : "mn", : "x", : "j", : "m", : "qing", : "ji", : "l", : "lu", : "wi", : "jing", : "tng", : "yn", : "gu", : "mi", : "shng", : "ln", : "dio", : "zhng", : "x", : "qi", : "lu", : "go", : "xi", : "ci", : "tin", : "fn", : "h", : "lng", : "hu", : "y", : "wn", : "zh", : "k", : "zn", : "gun", : "l", : "m", : "jng", : "fng", : "qi", : "mio", : "gn", : "xi", : "yng", : "zng", : "dng", : "xun", : "bn", : "dng", : "y", : "shn", : "hng", : "hng", : "bo", : "zh", : "zu", : "sh", : "cu", : "j", : "ni", : "gng", : "chng", : "j", : "xng", : "hu", : "pi", : "l", : "rng", : "wng", : "xn", : "yng", : "y", : "hu", : "zhn", : "q", : "ji", : "fng", : "ru", : "y", : "ch", : "jn", : "j", : "bng", : "m", : "sng", : "jng", : "dun", : "f", : "w", : "w", : "jio", : "b", : "gng", : "m", : "wi", : "shn", : "g", : "ch", : "hu", : "m", : "png", : "qun", : "x", : "bn", : "yng", : "qi", : "zhng", : "y", : "gng", : "nng", : "qi", : "lun", : "bo", : "gn", : "tu", : "l", : "rng", : "z", : "w", : "f", : "li", : "jng", : "zhn", : "sh", : "lng", : "y", : "xng", : "s", : "sho", : "go", : "l", : "j", : "b", : "yn", : "s", : "bi", : "hui", : "p", : "ti", : "cng", : "", : "su", : "xin", : "j", : "li", : "zhu", : "ln", : "t", : "mng", : "ch", : "qio", : "yn", : "y", : "x", : "ni", : "cng", : "shung", : "wn", : "shn", : "dng", : "zhi", : "tn", : "gng", : "lo", : "png", : "j", : "shn", : "f", : "d", : "rn", : "zi", : "l", : "yng", : "x", : "q", : "sng", : "gu", : "p", : "ni", : "shu", : "tng", : "bin", : "h", : "yn", : "j", : "ji", : "p", : "shng", : "nng", : "wn", : "bi", : "zhung", : "yn", : "chi", : "q", : "yn", : "chng", : "m", : "lin", : "r", : "x", : "hun", : "i", : "y", : "rng", : "xing", : "g", : "y", : "shn", : "g", : "lio", : "y", : "zhng", : "j", : "j", : "hng", : "b", : "d", : "gng", : "mn", : "hng", : "kung", : "gu", : "wn", : "ku", : "gung", : "l", : "qu", : "dng", : "u", : "sh", : "w", : "l", : "wi", : "yu", : "ku", : "lng", : "sh", : "gng", : "sh", : "ni", : "cho", : "gu", : "o", : "rng", : "lng", : "z", : "xn", : "kn", : "n", : "jin", : "ro", : "kng", : "zng", : "m", : "sh", : "ni", : "yng", : "j", : "x", : "fng", : "cho", : "gun", : "kui", : "xing", : "zh", : "hu", : "jng", : "hng", : "yu", : "zh", : "qun", : "l", : "g", : "y", : "hun", : "gng", : "mu", : "h", : "yn", : "f", : "xio", : "u", : "qn", : "pio", : "p", : "yn", : "gu", : "yo", : "gu", : "zun", : "chn", : "sh", : "sho", : "qi", : "s", : "nng", : "l", : "chui", : "xng" }, fst = Object.keys(AC).map((n) => ({ zh: n, pinyin: AC[n], probability: 1 + Va(n), length: Va(n), priority: Gr.Surname, dict: Symbol("surname") })), mO = { : "zh ge", : "chng wi", : "rn wi", : "zu wi", : "b fen", : "yo qi", : "yng gi", : "zng zhng", : "t gng", : "ju de", : "rn wu", : "n ge", : "chng wi", : "wi zh", : "lio ji", : "ch l", : "hung shang", : "zh yo", : "d ling", : "l ling", : "j h", : "gn b", : "m d", : "xng wi", : "zh jin", : "rn shi", : "sh zhng", : "sh fu", : "dio ch", : "chng xn", : "fn wi", : "zh shi", : "do dn", : "zh ling", : "hng kun", : "hng li", : "hng hu", : "hng y", : "g hng", : "zi hng", : "hng jia", : "ni hng", : "wi hng", : "tng hng", : "bn hng", : "hng w", : "yng hng", : "yn hng", : "shng hng", : "zh hng", : "zng hng", : "hng qng", : "dng hng", : "hng gu", : "hng dang", : "hng hu", : "ti hng", : "r hng", : "zhng hng", : "nng hng", : "gng hng", : "jin hng", : "g hng", : "hng ho", : "hng go", : "hng shu", : "hng wi", : "hng m", : "hng chng", : "hng j", : "hun hng", : "hng hu", : "hng bi", : "hng do", : "do heng", : "cn y", : "chng fn", : "jn gun", : "shng zhng", : "sh ling", : "yng dng", : "yun zhng", : "qing dio", : "zh nng", : "yn yu", : "y wi", : "ch y", : "b zhng", : "mng g", : "zh yu", : "sh dng", : "zh ho", : "chng zhng", : "go xng", : "b lio", : "chn ling", : "png zi", : "xin de", : "zh sh", : "sh de", : "shui lng", : "gi wi", : "b jn", : "chng fn", : "d ying", : "sho nin", : "xng q", : "ti jian", : "xi xi", : "xio zhng", : "gng xn", : "h tong", : "h do", : "chng qng", : "chng jin", : "sh de", : "shn ch", : "li j", : "j y", : "j wi", : "gun jn", : "fng f", : "tu fa", : "tu xing", : "ji zhng", : "z x", : "yo shi", : "jing lng", : "hn ling", : "gng wi", : "j li", : "d ch", : "xin zhng", : "sho n", : "l shang", : "zh p", : "nng ling", : "ch ling", : "gng yng", : "tio zhn", : "x zng", : "j de", : "zng ling", : "dng zhn", : "jing sh", : "ch bi", : "jio wi", : "zhng lo", : "di fu", : "ch y", : "dng de", : "jn ling", : "m yng", : "d qu", : "wi shu", : "pin yi", : "gng mng", : "sh tou", : "zhu zhng", : "wi zh", : "pio liang", : "po dn", : "zng z", : "ju s", : "dng zu", : "jn kui", : "rn wi", : "chng f", : "h tng", : "ch j", : "d xiong", : "d jing", : "shu jio", : "y jio", : "tun zhng", : "du zhng", : "q zhng", : "nn d", : "y tou", : "hu zhng", : "d di", : "wng ye", : "zhng ling", : "y wi", : "ji huo", : "hu shn", : "y zi", : "li ling", : "zhng d", : "min qing", : "kui j", : "gu fn", : "j nn", : "dio dng", : "yn jng", : "sho jing", : "zhng d", : "xio de", : "bin gng", : "d gng", : "rn de", : "png gu", : "nin tou", : "zhng zh", : "sn zng", : "b xu", : "chng xing", : "sho ling", : "xn si", : "du d", : "gn xin", : "h y", : "ch f", : "zhng gun", : "b ln", : "qn qi", : "shn fn", : "g bo", : "zhu shu", : "zh dn", : "k sou", : "y zi", : "wi zhng", : "gng j", : "sh zhng", : "bin ling", : "yng yu", : "xi zi", : "yu q", : "jin ji", : "d xi", : "d bn", : "z dn", : "dn yo", : "r ling", : "xu ru", : "g gn", : "rng ling", : "m hu", : "zhun dng", : "chng hu", : "k zhng", : "ch zh", : "zhu zhng", : "zho j", : "qing p", : "tng zhng", : "shu xing", : "l ma", : "zhn zhng", : "zh gun", : "chng chng", : "min de", : "zhu sh", : "d ji", : "zhn xing", : "xing mo", : "ch fn", : "wi qu", : "wi q", : "b bo", : "bi zi", : "qun zi", : "jin shi", : "lng zho", : "y hu", : "d du", : "d sh", : "chng d", : "shu d", : "d d", : "wng d", : "dng d", : "d h", : "d chng", : "jin d", : "qin d", : "g d", : "dng d", : "zhng d", : "l n", : "zi xing", : "jio ling", : "du chn", : "zng zhng", : "xing gong", : "kng bi", : "d liang", : "shu fn", : "sh tou", : "m shu", : "xng li", : "pn ch", : "sn wn", : "ch jng", : "sn zi", : "qun tou", : "d f", : "z zhng", : "g tou", : "nng k", : "gng hun", : "b ru", : "hun yun", : "chng xi", : "chng li", : "zh g", : "i ho", : "mn tou", : "jn zhng", : "shu zhng", : "chng zhng", : "s zhng", : "zhng z", : "qing jng", : "qi dng", : "tu er", : "zhn zhng", : "zh teng", : "xing ch", : "tng shui", : "zhng jing", : "mng zhng", : "mng jing", : "m tou", : "dng tan", : "d qio", : "gn hu", : "sho ye", : "shu ling", : "b j", : "wi ba", : "li de", : "ho q", : "yo shi", : "dng zu", : "chn zhu", : "y ba", : "ch zi", : "shng jing", : " xn", : "dn zi", : "yng ji", : "zh ju", : "yn zhun", : "xing zhng", : "g sh", : "zhng yu", : "yng zhng", : "dng chng", : "n xu", : "yn hu", : "chng yng", : "hu wi", : "t b", : "zun jn", : "yu du", : "ling xing", : "bi zi", : "sh de", : "sh m", : "j zhng", : "pi zhng", : "ji q", : "fn ling", : "sh c", : "d fng", : "yo he", : "ch ch", : "ling z", : "l tou", : "dio yn", : "c hou", : "chng shn", : "zhn tou", : "pn mng", : "sh zhng", : "gu hun", : "p ling", : "x m", : "din zho", : "shn wi", : "xio jing", : "zhu yn", : "ch s", : "yn w", : "g yu", : "sh gn", : "b l", : "d fng", : "wi tou", : "bn zhng", : "xng xi", : "nng yun", : "qn chi", : "wi sh", : "gu dng", : "xu jin", : "jin di", : "mn yun", : "ji shi", : "j ling", : "yn m", : "cn zhng", : "lin zhng", : "z j", : "w jing", : "wn ch", : "zh bn", : "gng qi", : "j ling", : "do zhng", : "xi lu", : "wng ba", : "qi g", : "jin g", : "y hung", : "chng ji", : "lng h", : "wi hi", : "j zi", : "chng hun", : "g da", : "yn shn", : "d s", : "du gun", : "zh shi", : "din h", : "kn shu", : "f b", : "y mn", : "jn zo", : "qi dun", : "zh tou", : "wi shng", : "ch sheng", : "qi ch", : "zhu l", : "zhu xing", : "j ch", : "tu bn", : "gn zi", : "hn hu", : "sho f", : "xng zh", : "n mn", : "gn li", : "jun q", : "shn zi", : "gng gi", : "lng lu", : "l ba", : "zi h", : "tu dng", : "wi nn", : "zhu l", : "yn zi", : "gn m", : "bi f", : "zng di", : "ji j", : "bo gung", : "q dio", : "xing j", : "jio hu", : "ju zh", : " y", : "zi zhng", : "zhng bi", : "ch chi", : "du ku", : "pi ki", : "tng zhng", : "z fn", : "w ch", : "ji dng", : "zhun j", : "g zi", : "p sh", : "gn sh", : "gn jn", : "dng ling", : "yn zi", : "hu er", : "qi zhng", : "chng fn", : "ch ", : "lu min", : "zun yn", : "di chng", : "shng dng", : "xio ling", : "zu fang", : "zho xing", : "i y", : "dio j", : "kn zhng", : "y zhng", : "fng zheng", : "b xi", : "kng x", : "gng di", : "pin ch", : "shng dio", : "sh ling", : "tn zi", : "w ling", : "kng d", : "dio d", : "sn sh", : "chung shng", : "hi shn", : "mn zi", : "chng di", : "lu ch", : "dn dio", : "lo jing", : "rn shn", : "jin dun", : "chng xin", : "ji z", : "dio yng", : "lu bo", : "f zhu", : "yng shng", : "zh jing", : "zu guo", : "j ju", : "wi zhng", : "gu ling", : "yu q", : "f h", : "qing dn", : "qio rn", : "ch fng", : "qio shng", : "q zi", : "qng dio", : "tio xn", : "di wi", : "lio ji", : "d zhng", : "ji b", : "ln de", : "zng ling", : "y zhu", : "b jing", : "yo si", : "ch j", : "gng gn", : "ch m", : "xin yu", : "jin x", : "zhng dn", : "chng yn", : "chng sh", : "yng chou", : "zh dng", : "w nng", : "bo z", : "qin tou", : "jun yn", : "fi di", : "dn do", : "gn zi", : "mn jing", : "hu tou", : "h ci", : "nun huo", : "li j", : "dio qin", : "ju jing", : "bo zng", : "sng sh", : "yu mo", : "qin f", : "gng t", : "zhung zi", : "bi bo", : "ti zi", : "sng sn", : "h h", : "k w", : "z zhun", : "gng din", : "fn xng", : "tn shui", : "s d", : "bn fn", : "lu de", : "b b", : "xing jin", : "dn b", : "hn dn", : "zhn gun", : "f h", : "nng ni", : "xi hu", : "wi lio", : "yn zho", : "chu dio", : "sh zi", : "x jun", : "bio d", : "bi niu", : "s liang", : "h ci", : "ln y", : "gi zi", : "fn wi", : "lng tng", : "yu w", : "y ling", : "mo f", : "chi qin", : "bi f", : "zhun s", : "shng yu", : "ji gng", : "gng shu", : "zh gn", : "chng ch", : "zhng xing", : "gng chi", : "li dn", : "shng de", : "tio zi", : "chng wi", : "z s", : "jng fng", : "ji g", : "din b", : "din zhng", : "zhng chung", : "lo lao", : "m hu", : "gng jia", : "j l", : "k mn", : "d ling", : "ch cu", : "sh ji", : "cn c", : "d zi", : "zh zhng", : "xing chn", : "hng yn", : "sh mng", : "x ho", : "li zhun", : "jng d", : "h ma", : "qng ji", : "dng zi", : "chn m", : "go l", : "xi ji", : "w wi", : "b jie", : "lio d", : "bin xing", : "h dn", : "qng jia", : "chng zi", : "h wn", : "hun j", : "jio hun", : "jing lng", : "chn y", : "kng qu", : "l ln", : "dn ling", : "zh zhu", : "d dio", : "b s", : "qng b", : "d dng", : "zhn b", : "so zhou", : "qi c", : "nin zhng", : "wi zhun", : "tu zi", : "ci feng", : "l yu", : "xu p", : "sn lun", : "dng ling", : "do teng", : "q sh", : "zn ji", : "chng f", : "zho w", : "dn k", : "xng w", : "rng rang", : "lin li", : "yng d", : "z zhng", : "gu zi", : "li g", : "xun yn", : "tio pi", : "q gn", : "chi y", : "kn k", : "sho r", : "yu tun", : "yng fn", : "tu hun", : "g dio", : "y dio", : "yn dio", : "yu f", : "g p", : "d din", : "chi sh", : "yn chn", : "shu xu", : "go yao", : "tn m", : "dio rn", : "sn j", : "shng tu", : "fng m", : "fng ji", : "g liang", : "sh dng", : "zhng dn", : "wng wi", : "zhng zh", : "q hng", : "m lio", : "xing sheng", : "jio zhng", : "qun xing", : "sh ling", : "chn mn", : "j y", : "ji f", : "si wi", : "jing xio", : "sh ho", : "m lu", : "p do", : "pin zi", : "qi xio", : "dn wn", : "x b", : "ku d", : "jin xi", : "qio shu", : "s dio", : "ch ju", : "bio shui", : "ch zi", : "zho xing", : "chn zh", : "du peng", : "p zi", : "d zi", : "f zi", : "gn jng", : "do sh", : "jing gun", : "ch tou", : "gu xing", : "n ji", : "lo dao", : "xin ling", : "bng x", : "chng fng", : "q yu", : "qng dn", : "b gng", : "fi zi", : "ch sh", : "cn ling", : "qng shui", : "pio mio", : "zhng jing", : "ci gn", : "sh sh", : "jun zi", : "yu shu", : "xing zi", : "png gung", : "qi w", : "kn gun", : "fng tou", : "jng gn", : "go ch", : "kng h", : "bin dn", : "j yng", : "g zi", : "gng x", : "fn ch", : "fi dn", : "wi b", : "f xng", : "j xng", : "cun dng", : "jin hu", : "qin b", : "yu zhng", : "shn ch", : "dio zi", : "xing wi", : "zhun z", : "jng l", : "k ch", : "lio sh", : "zhun you", : "dng p", : "zhu zi", : "dn zi", : "ho zhn", : "yn mi", : "zh x", : "gn lin", : "n jing", : "ji ling", : "hu chun", : "j ling", : "tio b", : "sho xio", : "zhu lu", : "zng w", : "k b", : "yo xi", : "yng chu", : "hun shu", : "m j", : "zh zhu", : "h lng", : "bo zhng", : "x zhe", : "zhng ji", : "gng zhun", : "jio kn", : "chng t", : "so xng", : "p gi", : "zhng sh", : "ch ji", : "y gn", : "zhng zh", : "yng yn", : "qi r", : "zhn jing", : "nin sho", : "sh shn", : "zh ni", : "ch sh", : "zhng fng", : "dng ling", : "fng ling", : "qing dio", : "lo sho", : "m r", : "gu g", : "jing shui", : "ch zi", : "w nang", : "zhng jn", : "k hn", : "bng zhu", : "gng xio", : "qi pin", : "chi sh", : "zh hui", : "yng zho", : "ch n", : "qi cu", : "r tou", : "y ji", : "z zhng", : "do gun", : "ju s", : "dng ling", : "p jia", : "yun fn", : "kng xin", : "ho s", : "n h", : "lng tng", : "bin si", : "h cng", : "chng h", : "lng sn", : "hng lng", : "hu zi", : "ni mng", : "sh lu", : "n ch", : "mu l", : "zh lan", : "zhng bio", : "dio dng", : "gu lu", : "chng zi", : "ji qio", : "chng wn", : "po zh", : "fn hun", : "z zhun", : "go dio", : "yn hng", : "g zhu", : "qing qi", : "bn xing", : "jio hng", : "co shui", : "q mn", : "zhu s", : "nng kn", : "xng tou", : "j n", : "ji jio", : "f j", : "mng jing", : "yu mo", : "tu li", : "n rng", : "zun tn", : "ji cng", : "lu p", : "hng do", : "yn ling", : "ji mn", : "kng er", : "g mo", : "ho k", : "zun kng", : "h nng", : "xng yng", : "fn mn", : "cng c", : "fn ch", : "chng zi", : "xio dio", : "sho yng", : "shu xing", : "rn fng", : "g bei", : "jing mn", : "m bn", : "pi j", : "wi w", : "gn tou", : "hu sun", : "li zhui", : "hng xio", : "yn xun", : "gn dio", : "fng zh", : "nn ch", : "zhu y", : "mn hng", : "j sh", : "dun f", : "shng hun", : "hun qng", : "kn h", : "zh shui", : "zu yu", : "zi k", : "zhun hng", : "yn m", : "kng g", : "p din", : "ling jing", : "hu l", : "sn mn", : "tu f", : "sng hun", : "mi m", : "li j", : "b w", : "dio l", : "sh ti", : "j zhng", : "shun s", : "pi ju", : "qi ku", : "chung ku", : "h qian", : "sh dn", : "p png", : "h d", : "ln sn", : "sh gn", : "tin kng", : "dio zun", : "yu sh", : "ling bin", : "yu xing", : "tng s", : "zhng dio", : "ji do", : "gn k", : "zh k", : "yu gng", : "hu gu", : "zho hu", : "gng zhng", : "j f", : "kng zi", : "n zh", : "zhng zho", : "shu zi", : "sng zng", : "ji di", : "n fn", : "zhng y", : "zhng sn", : "jio dng", : "jun q", : "zi yn", : "tu dn", : "zu cn", : "fn ling", : "dio hun", : "lio rn", : "li zu", : "din dng", : "hn ji", : "zhng xing", : "j shu", : "x f", : "zh gn", : "sh xing", : "hng qing", : "k hu", : "si zi", : "dn gn", : "hun xing", : "zho tou", : "s gun", : "d shui", : " ha", : "g sh", : "m b", : "ho w", : "xi ch", : "xio zhng", : "l jin", : "zhn tou", : "jio du", : "sh w", : "pn y", : "f ye", : "m fi", : "yn fn", : "h jing", : "b he", : "d ch", : "kng wi", : "p l", : "w l", : "dio hu", : "li tou", : "xin sn", : "jio jun", : "mo shi", : "gn jn", : "xin yu", : "xing gu", : "dn shn", : "zh xng", : "p ki", : "c zhng", : "f qi", : "ji j", : "sh ch", : "shng f", : "chng b", : "fng h", : "yn ling", : "sho wi", : "chng y", : "cng jng", : "hu bo", : "wi h", : "wi xing", : "h ho", : "zho m", : "tio dn", : "wn l", : "hun s", : "qing hng", : "zho sh", : "xing shn", : "tio mng", : "m feng", : "fn ni", : "gng y", : "run huo", : "jn xng", : "ho zi", : "zho y", : "bi jing", : "ci zhng", : "ji z", : "mi kng", : "ji fng", : "sh duo", : "chn huo", : "b ji", : "din ling", : "h zi", : "dio sh", : "ch shn", : "d shu", : "dn gng", : "hng mn", : "nng gn", : "jio din", : "ji zi", : "gn xio", : "hng chun", : "jio zh", : "y s", : "m zh", : "yu zh", : "go gn", : "jng zhun", : "zng sn", : "ho du", : "gun qi", : "to bn", : "m ceng", : "mu q", : "zhn l", : "m zha", : "cu he", : "li qie", : "shui d", : "ti zi", : "fn de", : "nin zhu", : "ci y", : "sn zhung", : " nu", : "xng wi", : "xng tou", : "q ling", : "dio yn", : "ch zh", : "yu yn", : "chng s", : "dng h", : "ln dio", : "xing zhng", : "mn yu", : "po zhang", : "sng f", : "xio jing", : "ling xng", : "fng b", : "ci kui", : "d gn", : "l sh", : "jio chng", : "si bi", : "sh xing", : "r m", : "xin ling", : "y s", : "lu lin", : "ling kuai", : "yo gn", : "li da", : "g g", : "gng gn", : "ji gng", : "tio du", : "kn mn", : "yu g", : "t pin", : "tio dng", : "zhn jing", : "qi jng", : "m fng", : "wi y", : "jio huo", : "m su", : "zu nng", : "mio tou", : "d zhn", : "d zng", : "ch shng", : "gu da", : "sh yn", : "sh ch", : "ti gn", : "jing xing", : "fn zi", : "sh ch", : "l yn", : "qing gn", : "fng rn", : "chu mn", : "din jing", : "hu tu", : "jng sh", : "xing lng", : "zhng lio", : "bn f", : "ji ba", : "k gn", : "kn ji", : "zhng dn", : "zhng kn", : "xi mn", : "dng gun", : "sh ling", : "gng dio", : "jin zu", : "dn pin", : "ch ch", : "pio bi", : "gng zi", : "tio ch", : "ho dng", : "zhun l", : "bng q", : "ji bn", : "i yu", : "gn do", : "k ch", : "p chi", : "zhng sh", : "tin hu", : "gng ch", : "jio yn", : "ch si", : "m pn", : "wi m", : "bn sng", : "chng h", : "d dio", : "fi fn", : "zun yng", : "ji zi", : "cho zi", : "gng sh", : "lng dang", : "p sn", : "f hun", : "zhun ln", : "hng ci", : "po tng", : "po s", : "tin y", : "h hu", : "q qio", : "tng ling", : "fng hun", : "w jio", : "mn gn", : "lng tou", : "yn ti", : "yu fng", : "xu zhng", : "gu zi", : "b dio", : "y bi", : "x chn", : "dio yu", : "mn gn", : "zng z", : "t gn", : "bin dio", : "f m", : "m zi", : "yu l", : "chn xn", : "m gn", : "chng yn", : "z xng", : "t dio", : "kn xing", : "y tou", : "xi qi", : "si shng", : "p zhng", : "tng wn", : "b xng", : "xi sh", : "tu q", : "xin dn", : "yu m", : "hn ling", : "y yu", : "ho k", : "zh xing", : "zh jun", : "z sh", : "x chung", : "fng dn", : "jin jing", : "l shu", : "xu f", : "kng dng", : "du xing", : "xin jin", : "hu jing", : "zi b", : "tio zao", : "qio p", : "b d", : "ji f", : "lio dun", : "tng dio", : "sh m", : "sh ch", : "b s", : "tio zi", : "tu m", : "w hu", : "m sh", : "dio zhun", : "j m", : "hun zhi", : "dio yn", : "fn hu", : "j u", : "dun h", : "mn li", : "lng j", : "fn ling", : "hun l", : "zhun dio", : "xng xing", : "shu xing", : "pi yu", : "gi tou", : "lin gn", : "b j", : "do b", : "ling c", : "mng ju", : "b dio", : "jio bn", : "zhng b", : "jun yng", : "sho wi", : "y zhun", : "yu p", : "qin li", : "d li", : "h ch", : "yn ", : "gn q", : "hi ling", : "jng dng", : "zhu chung", : "yu xing", : "sh j", : "gng gun", : "ln ch", : "zhng b", : "hu p", : "ji qio", : "kng ch", : "k xi", : "p chn", : "chng shng", : "yu l", : "i ho", : "zng l", : "gng jng", : "xu png", : "nng yn", : "chng du", : "dng chi", : "zhng zhun", : "bng ch", : "chung min", : "dn ju", : "b l", : "hung dang", : "so zi", : "ji sh", : "mn tu", : "mi f", : "d shu", : "zho ling", : "chung jing", : "j n", : "pn tou", : "ch sh", : "sn su", : "yng s", : "hn zhn", : "qin qing", : "w jin", : "ln zhun", : "ho jio", : "p pi", : "xing f", : "zh gng", : "dng ", : "bng ji", : "li ji", : "gng s", : "dn ji", : "zun xn", : "hung yn", : "m zho", : "bio ling", : "bi mn", : "ci du", : "ch sh", : "gun chi", : "to hun", : "chng mn", : "li fn", : "l lng", : "s xing", : "y xng", : "ju l", : "dn kng", : "zh ch", : "ji j", : "ch xng", : "hn jing", : "ho xu", : "ho ho", : "yn f", : "so b", : "f xing", : "gu gn", : "gng q", : "kng y", : "kn z", : "j b", : "jing hu", : "g zh", : "dio lng", : "f ti", : "ln bng", : "dio pi", : "zhun pn", : "gng go", : "chi gun", : "yu mn", : "jio zhng", : "chng chng", : "ji xng", : "yu tn", : "hu n", : "ch h", : "bng b", : "d kng", : "zhun qun", : "hng bo", : "hng ti", : "yn hng", : "zi hu", : "zhng j", : "gun zhng", : "xing min", : "kn tou", : "pn tou", : "y xng", : "jn yu", : "li c", : "g d", : "yn zho", : "bo sng", : "m sa", : "i du", : "pin zhu", : "chu ju", : "dio sng", : "qing jing", : "chng zu", : "f bin", : "zho m", : "zho f", : "shng fng", : "tin s", : "xing hng", : "q shu", : "bi ti", : "chng ling", : "f ci", : "ji f", : "fn jun", : "xio ling", : "jio zhu", : "l zi", : "dio diao", : "sn bng", : "go tio", : "b s", : "ji xn", : "shn dng", : "to ro", : "n chng", : "nin zi", : "m fng", : "s b", : "chng yun", : "xng qn", : "t l", : "gun ling", : "qing b", : "qing zhng", : "yn ch", : "sh do", : "di li", : "t bn", : "xin w", : "s jing", : "jn li", : "chn ji", : "f sh", : "g shn", : "tin fn", : "p ho", : "s tng", : "bi zh", : "hu shng", : "ju du", : "tng chi", : "su ch", : "sng l", : "m m", : "xu shu", : "s b", : "su co", : "qin wi", : "dio tu", : "lng jun", : "wi dio", : "z ti", : "jun f", : "chui du", : "yng xing", : "sn gung", : "g lu", : "b mng", : "lng tu", : "yn yn", : "li zhou", : "pin er", : "qin shu", : "sn t", : "ni xng", : "qing li", : "ji sng", : "fn jin", : "sho zhung", : "li kng", : "go ji", : "k xu", : "b m", : "p gu", : "m xu", : "zh sng", : "ch zi", : "hng dng", : " zi", : "ch lu", : "g zhng", : "gu ch", : "hun hn", : "l ji", : "sh zh", : "shn ling", : "tng ho", : "m ling", : "gng shng", : "f sng", : "shui zh", : "z m", : "sn ji", : "d qing", : "jio w", : "b qng", : "yn po", : "nio nu", : "co du", : "chng jn", : "n nn", : "qi zhng", : "tio dng", : "hun yun", : "j jing", : "gng g", : "m yo", : "bi xng", : "qi min", : "sn h", : "li jn", : "bi di", : "chng gn", : "nin fng", : "b zi", : "bn shu", : "yn shn", : "r jing", : "chng gung", : "jin f", : "zhng shng", : "xio zhun", : "y zhu", : "ru gun", : "hu jun", : "hng hu", : "ji k", : "gung yn", : "p m", : "du dio", : "ji ch", : "kng ", : "png dio", : "p chung", : "sng zhng", : "zu l", : "sho f", : "shu shu", : "bn tou", : "jn j", : "shui xng", : "l zi", : "bng z", : "tio su", : "pio x", : "ji qing", : "k chun", : "mi xie", : "cu ch", : "mn ji", : "sh dio", : "chng sn", : "jng chung", : "x chng", : "dio mn", : "hu tu", : "hu la", : "to shi", : "c shui", : "xing shui", : "kun zh", : "y qng", : "yn b", : "wn g", : "d d", : "dio q", : "jio chi", : "lu z", : "xing c", : "x dao", : "lu f", : "y xing", : "jn m", : "ju d", : "xi zi", : "chn jun", : "zh zheng", : "x yng", : "b lu", : "du zi", : " sho", : "f j", : "hng sho", : "jing hu", : "k sng", : "sho x", : "yn chun", : "jio yng", : "wi ch", : "jio zho", : "p zhn", : "yn sui", : "ji jn", : "su po", : "sng lun", : "xing xing", : "hu f", : "d chng", : "yn ling", : "zhng qi", : "hu qun", : "hu tng", : "png zhun", : "l qin", : "j du", : "sn j", : "g shi", : "s yn", : "p x", : "yn zh", : "lng zhn", : "sh zh", : "sho nn", : "gun yu", : "ho to", : "n xing", : "yng s", : "wn shng", : "gn r", : "g tng", : "b j", : "p ji", : "jio zhn", : "yn dng", : "q ling", : "xun dio", : "bn xing", : "gn ci", : "j gn", : "g qi", : "gu yu", : "qi k", : "b g", : "m fng", : "y y", : "ji mo", : "b j", : "chn ji", : "sh xng", : "chng ch", : "zhun y", : "zhu liang", : "b c", : "zng qng", : "d sh", : "dio rn", : "ji yun", : "jng gn", : "j ling", : "lng tou", : "shui zhn", : "pn xing", : "su yu", : "h m", : "xing t", : "xng hu", : "zo tu", : "chng hn", : "zun dng", : "cn du", : "dng shn", : "dio wn", : "gn t", : "g b", : "gng xun", : "ji shng", : "lu xin", : "qi qi", : "sn jin", : "sho qi", : "tng f", : "t ling", : "tng ku", : "j di", : "xing sh", : "yng jun", : "zhun j", : "b ti", : "cng zh", : "fi b", : "g ji", : "g l", : "gu wn", : "gui xing", : "ln ti", : "n gng", : "bo chung", : "qio ch", : "sh ji", : "tn xng", : "xing jng", : "z rn", : "zh yn", : "zhu zhng", : "zhun tou", : "p shu", : "chn huo", : "chng p", : "d ling", : "gn ji", : "gng ch", : "ji li", : "q shu", : "sh shn", : "tio hu", : " mn", : "bi lu", : "bi sn", : "ci ch", : "chung tng", : "f xing", : "gng dng", : "ho xng", : "hun yng", : "hun zu", : "ji dio", : "jun yn", : "li dn", : "xing tou", : "xu ji", : "jio yu", : "y ling", : "bi zhun", : "b ji", : "chn ji", : "f q", : "hu hu", : "kun chuo", : "lio w", : "qi hu", : "shn du", : "yng x", : "zhun ti", : "z zh", : "ci ling", : "zng x", : "chng xng", : "chu mu", : "cu zh", : "tio jng", : "dio zh", : "fng zhu", : "g du", : "h er", : "hng ling", : "hun ji", : "hn p", : "k chi", : "min h", : "sh ch", : "xng sh", : "sh jn", : "xn chi", : "y qi", : "cun mi", : "zh go", : "zun gn", : "p hu", : "bn hu", : "chng dio", : "d li", : "du lu", : "fi zhun", : "gn zhng", : "ho shng", : "hu pin", : "jio hn", : "lu gn", : "m m", : "n ho", : "pn sh", : "w nng", : "y sho", : "yu chi", : "zhn gu", : "zhn xng", : "chng shn", : "z ling", : "dio fng", : "f lng", : "fn dio", : "fng zi", : "gng f", : "g zi", : "gung gn", : "ji gn", : "j sng", : "j g", : "kn y", : "kng zhun", : "ling l", : "po lu", : "pi hun", : "p shn", : "sn j", : "sn jin", : "shn xu", : "sh gn", : "tio j", : "tu kng", : "xu b", : "jio h", : "yn gn", : "zhi ci", : "chng ji", : "zh dio", : "z jn", : "b j", : "bin nio", : "c dio", : "do gu", : "lo zhn", : "p q", : "shu bi", : "wi m", : "x b", : "xing m", : "y ti", : "zhun jn", : "bng h", : "bn xing", : "go tu", : "jin mio", : "yu ch", : "mi xing", : "bng q", : "qin dn", : "qi bin", : "qng dio", : "qn mng", : "sn bn", : "xng ch", : "sh ji", : "qin shng", : "chng yng", : "gng zhng", : "zhng d", : "zhng ci", : "zi zhng", : "ji zhng", : "kn zhng", : "zhng zh", : "zhng gu", : "zhng du", : "zhng sh", : "shu zho", : "lng zi", : "chng q", : "chng zhng", : "chng tn", : "chng z", : "chng shn", : "chng yu", : "chng lun", : "y ye", : "ni nai", : "lo ye", : "b ba", : "m ma", : "shn shen", : "ji jiu", : "g gu", : "sh shu", : "y fu", : "ji mu", : "g fu", : "ji fu", : "p po", : "gng gong", : "ji zi", : "ji jie", : "g ge", : "mi mei", : "mi fu", : "y zi", : "bo bao", : "w wa", : "hi zi", : "r zi", : "yng zi", : "sh zi", : "shn zi", : "ji zi", : "so zi", : "b zi", : "tng zi", : "zh zi", : "min zi", : "b zi", : "bi zi", : "mo zi", : "pi zi", : "zh zi", : "bin zi", : "g zi", : "fng zi", : "wn zi", : "tn zi", : "pi zi", : "h zi", : "gu zi", : "i zi", : "y zi", : "xio zi", : "yng zi", : "w zi", : "du zi", : "din zi", : "bn zi", : "zhng zi", : "r zi", : "t zi", : "pin zi", : "yun zi", : "hu zi", : "sng zi", : "zh zi", : "sh zi", : "qin zi", : "sh zi", : "png zi", : "bo zi", : "kui zi", : "ln zi", : "shng zi", : "zu ba", : "r duo", : "qi zi", : "bng b", : "kng tng", : "p pa", : "m gu", : "h lu", : "h li", : "j zi", : "h zi", : "zhu zi", : "zh zi", : "sh fu", : "y fu", : "w zi", : "bi zi", : "c wei", : "mi zi", : "du wu", : "zh lio", : "y er", : "hn tun", : "dng long", : "zhung jia", : "cng ming", : "jng zi", : "yn zi", : "pn zi", : "lio qu", : "l qi", : "x zi", : "ln zi", : "zho xi", : "zho x", : "zho q", : "ch bng", : "shng zhng", : "zng p", : "p ti", : "bin de", : "zhng fu", : "du fu", : "b gn", : "zng yng", : "xng rn", : "d zhe", : "d y", : "wn y", : "zh y", : "d zh", : "tng y", : "wi y", : "zhun y", : "dn y", : "r y", : "q y", : "h y", : "zh y", : "zhu y", : "ch y", : "yn y", : "gu y", : "ji y", : "wn y", : "lio lio", : "gng lio", : "s lio", : "y yu", : "y ho", : "y j", : "y dng", : "y g", : "yu y", : "y y", : "r y", : "sn y", : "s y", : "w y", : "li y", : "q y", : "b y", : "ji y", "": "y lng", : "y lng", : "y r", : "y sn", : "y s", : "y w", : "y li", : "y q", : "y b", : "y ji", : "y yu", : "y bng", : "y lu", : "wi l", : "wi zhn", : "cng hi", : "nn wi", : "z nn", : "hun nn", : "m nn", : "d nn", : "dio nn", : "xn nn", : "lu nn", : "l nn", : "zi nn", : "nn mn", : "k nn", : "wi nn", : "f nn", : "to nn", : "b nn", : "y nn", : "z nn", : " nn", : "xn nn", : "kng nn", : "x huan", : "zho zho", : "b xng", : "y y", : "wn q", : "ni q", : "q zh", : "wi q", : "ji q", : "q jng", : "q ji", : "wi q", : "q xin", : "q f", : "ji q", : "q zh", : "q gng", : "q y", : "g lo" }, gst = Object.keys(mO).map((n) => ({ zh: n, pinyin: mO[n], probability: 2e-8, length: 2, priority: Gr.Normal, dict: Symbol("dict2") })), _O = { : "wi shn me", : "sh j shang", : "jin ch zhng", : "gn shn me", : "zh hu er", : "jn k nng", : "dng sh zhng", : "lio b q", : "cn mu zhng", : "cho xin z", : "hi ni wi", : "jn b zh", : "b l t", : "b zi hu", : "lu shn j", : "yu din er", : "pi j po", : "b d lio", : "m wi sng", : "yn sh ling", : "f p qi", : "sh d f", : "y l jing", : "y gn er", : "du de q", : "n hu er", : "z g er", : "w l ling", : "zn me zho", : "mng hung hung", : "ji ji r", : "xn l hu", : "f xng ling", : "xng chng chng", : "fn z ling", : "gu z jin", : "lo d nn", : "dng ni wi", : "zh me zho", : "sho ni nai", : "n d l", : "gng nin q", : "gng zu ling", : "bi d l", : "shn li hng", : "ho ho er", : "jio xing yu", : "ho y si", : "t y hn", : "mi y si", : "l f sh", : "t sh gn", : "chng q ling", : "ko de zh", : "ch xng do", : "rn xng do", : "zhng lng jing", : "zho mng dn", : "yn m dn", : "m ni h", : "lun hng hng", : "hu gng s", : "zi zhng ling", : "qio de q", : "j zhun t", : " png gng", : "jun xn ci", : "x bn zi", : "gu de q", : "hu gng sh", : "wi sheng n", : "tun tun zhun", : "d bo jio", : "rn sho dn", : "lo sh zi", : "yo gn yu", : "ji zh to", : "no hng hng", : "sn lin gun", : "zhng tu x", : "r rn zhun", : "ji g yn", : "zh shi min", : "h shi zhng", : "xn ho dn", : "gn din ch", : "qing gn zi", : "k sng bng", : "b yn i", : "w gng jn", : "mi de q", : "li h ma", : "j liang g", : "z m dn", : "ki xio chi", : "n qing rn", : "yng xing zhun", : "ju sh yu", : "shu xio hua", : "png tu hu", : "b li gng", : "y gung dn", : "sho ln qun", : "yng tn dio", : "sho xin du", : "lng zhng m", : "du zhe gn", : "mng mng ling", : "run g tou", : "p gi jun", : "hu x n", : "bi hi gu", : "hng tng tng", : "w hu c", : "d du suo", : "h ku b", : "m wi zo", : "y mo zi", : "d shu sh", : "lng wng y", : "q tu shang", : "h tu chng", : "b gn zi", : "zhn pin yi", : "d zh y", : "du dn tu", : "lu y shu", : "yn s h", : "bo de zh", : "bo t qun", : "o de h", : "s w zhng", : "jn b q", : "sh ch hi", : "lin hu lo", : "jin sh min", : "hu ch q", : "din wi ch", : "i g er", : "n zhn er", : "fi hu ling", : "d sh fu", : "zh dn tng", : "d h lu", : "n q mn", : "wi jin d", : "d shn er", : "tn de li", : "jio y zi", : "kng bo dn", : "w li du", : "dn zhu din", : "g tu er", : "kn de q", : "h tu zhng", : "d xng xing", : "jn de q", : "f xing zng", : "k lin xing", : "ch de xi", : "hn bo bo", : "no rng rng", : "sh li bo", : "h de li", : "gn xng yu", : "mn h lu", : "gu gu jio", : "x yng shn", : "ln yn do", : "l ji chng", : "jun p gi", : "gu de yng", : "fi jing jn", : "tio d ling", : "h ba gu", : "gu ji ji", : "cu li dn", : "y ji xu", : "qio zh gng", : "li ch zhng", : "hu d n", : "fn de zho", : "t g da", : "sh fng jng", : "qng ling j", : "xi d d", : "sh z er", : "d m dn", : "k jio pin", : "kn d shn", : "dng din er", : "ch de xio", : "lu h x", : "go l shn", : "zhng shng xing", : "yn xi yn", : "jn de zh", : "ch de ki", : "zu s chu", : "yng shng chng", : "sh de zho", : "sh jn er", : "qin b li", : "k d sng", : "hu de li", : "yn h h", : "sh ke lng", : "lio ju zi", : "zng hng hu", : "mn gun ch", : "qi b zi", : "hng deng deng", : "gn de j", : "dng jin er", : "lu m jio", : "j ni jn", : "fn de shng", : "dng ch b", : "bo h din", : "lng zho hui", : "h do ci", : "dng gun c", : "dn dan min", : "ch de zh", : "zhu jin er", : "zh zho er", : "zh gn tou", : "yn zho er", : "yn jun er", : "xun chun dn", : "xn p er", : "xin qi jio", : "s sh m", : "shu de li", : "shu pio er", : "shu b gn", : "sh de shng", : "sh b zho", : "sh b qng", : "sh jin er", : "shng s b", : "shn fng j", : "s y zheng", : "r j b", : "r de kui", : "qng jia gng", : "j hn sh", : "pi zh b", : "n jn er", : "n w wa", : "ni qi yun", : "n hu er", : "mn tu er", : "mi p er", : "mo jn er", : "li jin bng", : "lio wng ti", : "lo li sho", : "kn ju er", : "ko qn b", : "jun b do", : "jn j ling", : "hu b li", : "hn gu er", : "g nng nng", : "gu jn er", : "gng qi xin", : "g de zh", : "gn lng tu", : "gn de shng", : "gn jio m", : "g zh er", : "g bng cu", : "du de zh", : "du mn zi", : "dng gu gu", : "d li er", : "d zhu zi", : "d bn zi", : "cn jn er", : "c jn er", : "chui shu er", : "chng jn er", : "ch de li", : "b gng sh", : "bn tou er", : "bi f zhng", : "w wa qn", : "s jn er", : "g du er", : "gng lo b", : "d jing yn", : "y dn shu", : "p j ti", : "ti li p", : "k t lng", : "ki h hng", : "l y j", : "hu sh lio", : "y gng gng", : "y chng shn", : "fng y gng", : "xu y gng", : "gu y m", : "xng q y", : "l bi y", : "y j d", : "y yu y", : "y z m", : "y sh y", : "y c fng", : "y yng zh", : "y z ju", : "y nin j", : "y b zu", : "q qu r", : "nn wi shu", : "nn wi qng", : "xng y hng", : "bi bi de", : "gn n hng", : "gn y hng", : "q bi zhn" }, dst = Object.keys(_O).map((n) => ({ zh: n, pinyin: _O[n], probability: 2e-8, length: 3, priority: Gr.Normal, dict: Symbol("dict3") })), EO = { : "chng j s hn", : "s tng b d", : "y m y yng", : "qng zng go yun", : " m tu f", : "ji fng s xing", : "su zu su wi", : "m m hu h", : "h qing sh dn", : "xng go ci li", : "w nng wi l", : "b l si r", : "wi su y wi", : "k sh m r", : "mi wn mi lio", : "b wi rn zh", : "ji ji b b", : "qin p hu j", : "p tin gi d", : "zh ji lio dng", : "gng b yng qi", : "y sh d f", : "b wi w qun", : "b k shu shi", : "h zu fi wi", : "fn ho b ch", : "m m hu h", : "b z wi q", : "qio w shng x", : "lio r zh zhng", : "shn w tng ju", : "go go xng xng", : "i shng tn q", : "hn zng y x", : "ch xn j l", : "q b chng shng", : "bn y sn gng", : "sh hn lu p", : "r sh b xi", : "zhun li zhun q", : "sh y wn j", : "xing y wi mng", : "lin lin b sh", : "q zh k sh", : "shn ch gu m", : "ji ji sh sh", : "yu d fng sh", : "j l g l", : "dio bng qin jing", : "zi g zi w", : "zhun wi wi n", : "t t shi sh", : "sng j b r", : "zhung m zu yng", : "jin y yng wi", : "xing ch w j", : "tn wi gun zh", : "mn mn b l", : "x n i l", : "xin wi rn zh", : "zhng y w zho", : "wi fi zu di", : "hn h q c", : "p y bn mng", : "min wi q nn", : "y y b sh", : "dng tu shng si", : "b zhu bin j", : "d m d yng", : "xn hun zu l", : "y zu lio zh", : "z l hng jin", : "hn hn hu h", : "qi r q fn", : "p t wi xio", : "shn gng bn y", : "qin ch wn bi", : "sh b shng sh", : "j wi j yu", : "tin xun d zhun", : "yng zn ch yu", : "b li xin wi", : "cho chao no no", : "yn tu zhun xing", : "t shng t zhng", : "nng s b q", : "b xng rn sh", : "jn l r wi", : "jng mng qing gn", : "lo lao do do", : "j ji zh zh", : "gng b k m", : "qi r b sh", : "pi yu ji nn", : "x li h t", : "g yu su chng", : "d d qu qu", : "hng tng d xio", : "tng r b wn", : "do gng hu zhng", : "ni fn m xin", : "hu xin wi y", : "bi f bi zhng", : "chng jin tin r", : "fn bi wi shng", : "y lio bi lio", : "d da li li", : "xn j hu lio", : "c xn d yi", : "j p g da", : "y wi png d", : "r j yu li", : "sh shn ch d", : "tu q su ho", : "jin b rng f", : "rn mn wi hun", : "qing zhu b sh", : "wi sh y wn", : "r sh ji zhn", : "xn l yu sh", : "y y hun y", : "shn b shu sh", : "mng sh wi k", : "g z wi zhn", : "yun shng zi do", : "ji k ji nn", : "ho ho xin sheng", : "gui m gui yng", : "po tu l min", : "yu shu ho xin", : "w su b wi", : "dio h l shn", : "b b wi yng", : "ho d x gng", : "zhng sh zh d", : "chng shng b s", : "wi wi zhung gun", : "b k shng sh", : "gu sh shn chi", : "ji shn z ho", : "gn zu gn wi", : "mo s dn ki", : "zu m hun jing", : "wi sh gu zo", : "wi rn sh bio", : "yn ch yng cu", : "yu qing hu dio", : "chng do f zh", : "m ma li li", : "x x do do", : "r l b bng", : "sn bng zh jing", : "gui wn m jio", : "xing m xing yng", : "gng gu y qi", : "ki hu ji gu", : "z z x x", : "chun zng gng l", : "h bi bng zi", : "chng nin li yu", : "zhng er b jng", : "b sh ti ju", : "chng zhn q g", : "q x yn yn", : "jn zhu b sh", : "f fu ti ti", : "qing c du l", : "p li p l", : "rn ci j j", : "f rn shn xng", : "b z wi png", : "wi f b rn", : "lin pin li d", : "h tin qing d", : "lu lu d fng", : "z chu z li", : "l shn ho sh", : "y gng wi shu", : "m m cng cng", : "xu ti r n", : "zh zhu wi n", : "y tu wi jn", : "q q ch ch", : "qing ln dn y", : "lng rn f zh", : "zhun bi wi shng", : "zhun wn m jio", : "zi ji nn to", : "zhng dng fng wi", : "b z wi gui", : "nn xing nn d", : "y y y y", : "dn jn ling ju", : " y fng chng", : "x li hu l", : "fn lo hun tng", : "ho go w yun", : "l s shi shu", : "ch qing rn y", : "d chu d li", : "chng ji l y", : "z yun z y", : "f zhi li li", : "g wi jn yng", : "r t wi n", : "xi b wi l", : "y hng r shng", : "mi tu cng ying", : "tin ch d yun", : "fng jun cn yn", : "du zi du nn", : "r xi wi gn", : "hng ji l shu", : "lng bi wi jin", : "ch bin b jng", : "y chng y h", : "y nin zh ch", : "jn chn tu qio", : "d d d d", : "shu gu li li", : "ho zhng y xi", : "hng de f z", : "chun wi mi tn", : "f shng d g", : "s hi wi ji", : "lio ru zh zhng", : "d yu k wi", : "ch tu l min", : "g gu nng nng", : "chung mng j jng", : "ti rn ch zh", : "n f chng gun", : "yu j b li", : "g tou ji zi", : "y b yn tin", : "y dng din er", : "sh li yn zhun", : "chn c ln dio", : "hu zhng wi lng", : "hu sho hu lio", : "gn cu l su", : "dio er lng dng", : "gung zhng b shu", : "zhng gu d gu", : "zhng du d du", : "nn sh nn fn", : "sh xu wi mng", : "fn f yu wi", : "yn cu yng ch", : "dng du x cng", : "yn xn hu lio", : "zun ni jio jin", : "qio zhung d bn", : "gi xin gng zhng", : "h nn bng zi", : "ho ch ln zu", : "h l b wi", : "d ch fng tu", : "gng chng l d", : "pio pio liang liang", : "zh zhng zh y", : "d m h y", : "l sh chng yn", : "shui xin chu fn", : "ji chng l dun", : "kun d wi hui", : "zu bng yu b", : "y xio lio zh", : "tin xi wi gng", : "hun w h shn", : "h z wi q", : "ho z wi zh", : "fng z chu yu", : "d y png tu", : "chun wi ji hu", : "ch l p wi", : "chng co ji y", : "xio ji zi q", : "sho b gng sh", : "nn fn nn sh", : "tin zhun ji w", : "sh fi fn mng", : "sh w q shu", : "pin tng pin xn", : "ling r wi ch", : "xing lng f h", : "gng hu b li", : "zhng zhng xi hui", : "y shn x gu", : "y y zhng d", : "sng hn lu p", : "sn zu d shn", : "j j y tng", : "ho sh zh t", : "gn jng l su", : "ch jing r xing", : "nio nio nu nu", : "h li wi ba", : "ho y w lo", : "d r w dng", : "d m hu yn", : "bn shng dng dng", : "yo w h li", : "xi bng xi jing", : "shu dio g tu", : "sh din wng z", : "rn sh b xng", : "q go h gu", : "l jio b gi", : "h wi yn gu", : "h wi bio l", : "hu c b b", : "gu gun zhn jing", : "g ge d d", : "d f pin pin", : "zu wi shng c", : "yun jia du tu", : "yu x k chng", : "y ln bn zho", : "pin yn zh y", : "ki hu ji sh", : "jng nin li yu", : "hn h q c", : "gu lin xin ch", : "chng nin li yu", : "b xn s qng", : "b dng rn z", : "bng d yo yun", : "zh f wi hn", : "zh me din er", : "y xng su rn", : "xi hu zhn tou", : "w d fng sh", : "wng wn wn qi", : "sh j wi rn", : "qing nin li yu", : "pi nn ji fn", : "ch zh ti rn", : "zh l wi m", : "wi r li lun", : "tin bng tin jing", : "sh jn qi yun", : "nn qing bi dio", : "k zhng zu l", : "hu j b f", : "xi wi xing tu", : "zhng yu yu x", : "b ling wi chng", : "bi bi qi qi", : "bi jn zh jing", : "q hng b sh", : "xu z sh l", : "xin d wi kui", : "t j ho hn", : "sh b jin qn", : "shn chi gu sh", : "qio qio d d", : "png p zh x", : "mi tu m wi", : "lio lio k sh", : "hng h r jing", : "h f tng yn", : "g bn qin chng", : "dn w x f", : "d rn xin sheng", : "y mn gng sh", : "sh bi l zhun", : "sh fi d sh", : "sh b ch c", : "si wng sh m", : "r b x shn", : "qi shn t hu", : "pin yn zh z", : "po m mi xi", : "nng zh b wn", : "lng lng sn sn", : "ling t ci y", : "lin zhng sn yun", : "l bng yu hui", : "b wi y shn", : "zhun bi wi x", : "y yn hun yn", : "wi wi d gun", : "wi wi b k", : "tng yn h f", : "png b wi jin", : "m c wi shn", : "ji qing di bng", : "f shng j ji", : "dn rn ch zh", : "dn sh h jing", : "chung j tng shn", : "co zhng yng fi", : "zu sh b ji", : "y j du rn", : "su hng ji sh", : "wn y zi do", : "wn b du t", : "ti bn dng dng", : "shn t f f", : "qu ch sho chun", : "m w zn zhng", : "j rn tin xing", : "hu ji sh nn", : "gng jn ti g", : "di z bo j", : "di sn l s", : "b m s tng", : "xu jin no di", : "wi fi zu ", : "rn ci nn d", : "qng fi d y", : "qi zhng yo hi", : "hu j hu lio", : "hu d wi lo", : "ho ji tn bi", : "chng g dng k", : "zi chn zi f", : "y nn chng xing", : "y m g da", : "y ln wi h", : "yng wi zhng yng", : "yn wi xn shng", : "yn b yu zhng", : "t qing b xin", : "png tu d y", : "m b xi j", : "ling ci l yng", : "jio xu xing zhng", : "hu b dng ch", : "h yo h li", : "b z wi xn", : "b j xng j", : "png ru w rn", : "zu z nn to", : "z w chu x", : "zhun hu wi f", : "yng gun sn jn", : "y d r ch", : "xi m sh l", : "wn r b zhun", : "tin do ho hun", : "shn dn l b", : "s du chng bng", : "pin zh zh z", : "nng qu w ln", : "m m w wn", : "ling l r wi", : "l l k sh", : "ku bi zi do", : "jn z ho qi", : "ho wi rn sh", : "ho shng j ji", : "g yu su ho", : "du d ling l", : "zh tin wi sh", : "y xng chun fi", : "xn kun t pn", : "wi d b z", : "tin xi wi ji", : "sh wi wi t", : "sn zi b nn", : "m hu r gun", : "l li l l", : "jin fng ji zun", : "ji cng b li", : "j gng ho y", : "j nin li yu", : "hu d wi lo", : "gng mng gi xng", : "fng wi gu ni", : "du nn xng bng", : "b p b l", : "zu d z hu", : "zu b chng x", : "zu b ku tng", : "zu ji y shang", : "zu zh yu w", : "zu y yu yu", : "zun tu m fng", : "zun tin d dng", : "zun p ch y", : "zun hu d bng", : "zun dng m fng", : "zun bng qi hu", : "z wi f yn", : "zhu f nn sh", : "zhu rn xin bin", : "zhu dio wi p", : "zhu ch nng zhng", : "chu xn yn q", : "chu xn q xu", : "chu ni xing sh", : "chu ni sh xu", : "chu ni f zhng", : "chu mi t gu", : "chu mi gu qi", : "zhung f chng gun", : "zhung yn bo xing", : "zhun chu wi x", : "zhun chn wi x", : "zhui xing lu ji", : "zhui p f l", : "zhui b tu m", : "zh chng wn dun", : "zh jin wi l", : "zh yu q kng", : "zh yu kng x", : "zh tin wi n", : "zh yun yu r", : "zh mo l l", : "zh c b sh", : "zh w b hun", : "zh ling cn du", : "zh ling x chn", : "zh r gun x", : "zh fn zo gi", : "zhu du y s", : "zhu zhng wi hun", : "chng mng j yn", : "zhng zhu tng yn", : "zhng mo cun qi", : "zhng ho zhng w", : "zhi zh su t", : "zh ch w tu", : "zh dng b y", : "zh zo wi bi", : "zh yn wi gng", : "zh sh wi xng", : "zh shn shu m", : "zh g wi w", : "zh gn xing ch", : "zh d y bn", : "zh w q c", : "zhng shn shui xi", : "zhng gun l xi", : "zhng gun n l", : "zhng gng shui w", : "zhng dn gn kn", : "zhn tu xu ti", : "zhn sng jng bi", : "zh y s l", : "sh jin wi sh", : "zh r z zh", : "zho d s wi", : "zhng j xio r", : "zhn n wng hu", : "zhn fng wng q", : "zhn jing qin q", : "zng m tu zh", : "zng shn sh rn", : "zo yo zhng shng", : "zo zhn w yo", : "zo gu sh c", : "cun sn j w", : "cun mei c ", : "cun lng h zhng", : "cun fng j d", : "zi xio zi yn", : "zi ji wn z", : "yn shn b x", : "yn sh xi jun", : "yu zhng sh gu", : "yu lu shn hng", : "y n qi ji", : "y j wi fng", : "y nn chng xing", : "y y li li", : "y zh w dng", : "y xio xun tin", : "y sh chn f", : "y sh xio xi", : "y qing zun x", : "y du qn mu", : "y chun p d", : "y yng k g", : "y zh y xing", : "y q y qi", : "y ji wi gu", : "yu ji w hun", : "yu ji w y", : "yu gu nn tu", : "yu b yu fng", : "yu gn dng jn", : "yu yn t y", : "yng zhng jio jio", : "yng sh yn shu", : "yng yng fi jn", : "yng xn yn zho", : "yng yn yn w", : "yng tin shn sh", : "yn li shu ru", : "yn zhn shn t", : "yn d shng li", : "yn shng qi m", : "yn ch dn sh", : "yn yun wi sh", : "yn sh wi w", : "y mi y w", : "y s li lu", : "y l wng qi", : "y y wi zh", : "y yn wi hu", : "y sh jin qn", : "y shu j shu", : "y sh wi y", : "y shu wi gng", : "y shng ling dn", : "y shn wi jin", : "y qun wi y", : "y l li xng", : "y hu wi f", : "y hi wi bi", : "y gu wi tin", : "y g wi jin", : "y gng xio ju", : "y f wi jio", : "y d w x", : "y sh wng li", : "y qn zi hui", : "y d ji jin", : "y tu l dng", : "y z sh shu", : "y qng chng fi", : "y shang zh hu", : "y dn sh b", : "y hun y bo", : "y gng ho lng", : "y dio w qing", : "yo ch n sh", : "yo m xio chu", : "yng jng x ru", : "ng shu shn mi", : "yng yng s s", : "yng go mi ji", : "yng fng ji y", : "yn zho sh jn", : "yn zho ho m", : "yn sh wng zhn", : "yn jn qin jn", : "yn jn m xi", : "yn ji yu g", : "yn g zho w", : "yn di zh sh", : "yn ch wi cho", : "shn zo fi shng", : "yn g wi xun", : "yn ch ho ", : "y ling wi jin", : "chn hng du sh", : "q sh hng xi", : "dng hng ch s", : "xi ch bn hng", : "r n chng hng", : "d hng d sh", : "xn hng sh m", : "xn ch xing h", : "xu zhi li li", : "xun y g sh", : "xun sh wi y", : "xun dn chng sh", : "xun hun s cn", : "xun gu x y", : "xun qun lu xi", : "xun h gun hu", : "x q yng z", : "xi rn d d", : "xi ln yng zho", : "xing j h zh", : "xing s d j", : "xng wn zi shng", : "xng wn yn w", : "xng gun qn yun", : "xng go ci li", : "xn shu xing yng", : "xn ku xing yng", : "xi sh nng qun", : "xi jin li z", : "jio dun ling chng", : "xio yn b p", : "xio yn dn y", : "xio mng sh bo", : "xu zh ju gn", : "xu ti w shng", : "xu zh wi mn", : "xu m wi l", : "xing wng fng hui", : "xiang pei yu zhu", : "xing sh yu p", : "xing sh r dng", : "xing qi xing cu", : "xing n pi f", : "xing mn yu xing", : "xin zhng ch j", : "xin w zhu bin", : "x yn b ch", : "sh q  jio", : "x mo bin f", : "x su b f", : "w ln yn zho", : "w x wi gu", : "w f hn y", : "w dun zhun hng", : "w sh li y", : "w s xing xun", : "w hu q gu", : "w hu l zh", : "w g d f", : "w z yu ch", : "w xi zh ch", : "w shng w xi", : "w nng wi y", : "w ku bo s", : "w kng b zun", : "w jin k chng", : "w jin dng xi", : "w  b wi", : "w dng wi d", : "w ling wi do", : "w qun tu zho", : "wn w chi sh", : "wi wi tu tu", : "wi r wi su", : "wi b b xi", : "wi shn zu l", : "wi shn zh ku", : "wi rn b f", : "wi qi wi j", : "wi mn f m", : "wi hu f cu", : "wi ho chng qin", : "wi gu wi y", : "wng fng xing yng", : "wng chn pio shng", : "wng zh hun tng", : "wng gng dn gun", : "wng gu d f", : "wn gun ji s", : "wn sh dng ru", : "wn ji b bo", : "wn su ki sh", : "w m shng f", : "tn yn yn l", : "tu yun dun qin", : "tu gn ji sh", : "tun fn ju j", : "tun tu j min", : "t s yn mi", : "t tu zhng no", : "t ku yn mi", : "t b w f", : "tu zhun r q", : "tu m bi n", : "tu hn no mn", : "tu kui j lin", : "tu ch tu m", : "tng z chung y", : "tng w xing zh", : "tng w xing x", : "tng gun zi bo", : "tng wn dio w", : "tng li zhng zh", : "ti sh ki hu", : "tio gun b fn", : "tio y lio chn", : "tio yo tio li", : "tio chn lio zu", : "tin b wi y", : "tin b wi gui", : "tin xi wi lng", : "tin ti l m", : "tin nin b su", : "tn nng q qi", : "tn yn wi zhng", : "tn yn wi zhng", : "sh kng j m", : "su w yng j", : "su yn ci gn", : "sng jn l xu", : "sng yn zh ji", : "s tng b dng", : "s m cun t", : "s b ni li", : "s su zh zh", : "s n f yun", : "shu wng xi d", : "shu g qi jn", : "shn fng r h", : "shn fng chu hu", : "shu zhng zhu yn", : "shung gn du ji", : "sh m r chu", : "sh m ling chi", : "sh l lu ji", : "sh hi ln hung", : "sh bi ln hung", : "sh yn hun f", : "sh p wi p", : "sh chun wi zh", : "sh qu yu jin", : "shu z chng jin", : "shu z y ch", : "shu jio gn jng", : "shu b yng xn", : "sh shu ji wn", : "sh zh y xng", : "sh sh yng w", : "sh qng shui y", : "sh dng q chng", : "sh wi zh j", : "sh yng jing lng", : "sh wi mn tin", : "sh du w y", : "sh y yu l", : "sh yng b li", : "sh sh jn gu", : "sh x zhn cng", : "sh w dng x", : "sh wi w gng", : "sh m ji nn", : "sh sh f zhng", : "sh ch kn zhng", : "sh zh wi zhung", : "sh j lng xin", : "shng jng xin zhun", : "shng jn xin xing", : "shng tu s zhui", : "shn j du rn", : "shn w gu gun", : "shn lng sh sh", : "shn wn q sh", : "shn l qin q", : "shn g wi lng", : "shn w tng j", : "shn chu xi yun", : "sh j wi gng", : "sh dun q chng", : "sh c zhu yng", : "sh xi wi xn", : "sho chng ru xng", : "shng dng xu gui", : "shng b dng gng", : "shn z wi mu", : "shn wi shu c", : "shn shn w ", : "shn ci nn sh", : "shn yn p mi", : "shn y xin k", : "shn yn chng xng", : "shn yo y wi", : "shn li chun sh", : "shn ji zo zhu", : "sh j wi sh", : "s l dn b", : "sng yn wi y", : "sng yn b x", : "sng t chu mi", : "sng h jun sh", : "sn zhn sn bi", : "sn w ling sh", : "sn rn wi zhng", : "sn ch ling cu", : "si jng fn sh", : "s xn gng sh", : "s so yng du", : "run hng xing t", : "r w gu zhng", : "r ti zh b", : "r l qi qng", : "r chng rn y", : "r shu tu sh", : "r qi r cu", : "r dng chn ti", : "ru b g bng", : "ru qng chu ti", : "rng m kung rng", : "r zhng wi sh", : "r yu shn chn", : "r xng yu xi", : "r xu yu g", : "r xng yu sh", : "rn d b j", : "rn yn j j", : "rn m gu yng", : "rn m y d", : "r o fn bng", : "jun lo yng w", : "q y yu ji", : "q yo ro gu", : "qing xng jn xing", : "qng q y qi", : "qng xin sh q", : "qng xin h c", : "qng du jing qu", : "qng chng do d", : "qng z p t", : "qng ln hi si", : "qn shu  mi", : "qn s zh ho", : "qi zh wi ji", : "qi sh do gn", : "qi l yn xn", : "qi jn de dng", : "qio z yn lng", : "qio f q zhng", : "jing zu ni sh", : "qing zh z su", : "qing s qing hu", : "qing sh z i", : "qing sh m jio", : "qing gng jng n", : "qing gu b sh", : "qing f bin h", : "qing r hu k", : "qing d y pn", : "qin xng to qng", : "qin yng dn ji", : "qin lio bi dng", : "q xi r y", : "q yn wi sh", : "ki t jn z", : "q x l q", : "q sh xin zhu", : "q wng sh ni", : "q tin kung d", : "p tin shui t", : "p xing n d", : "p jn li xi", : "p ji wi gu", : "p g wi yun", : "png pio png zhun", : "png tin j d", : "bng shng x q", : "png j j zhng", : "pn zu b sh", : "pin y zh c", : "p f wn shn", : "png lng po fng", : "fu bi kui l", : "png mi ho f", : "pn hu zh li", : "pn chn sh gu", : "n d nn li", : "nng y chu xio", : "nng gun tio xin", : "nng fn dio zh", : "nng m dn zhung", : "nin t wi xing", : "nin y sh ho", : "nin hu chu m", : "n b y ln", : "n r b z", : "nng zh wi sh", : "nng b chn gun", : "no zh wi q", : "nn jn y tu", : "nn d h t", : "nn mn ju sh", : "nn fn bi g", : "m zh n x", : "m yun xn tn", : "m tio xn zho", : "m ling y yng", : "m tu m no", : "m gn nio q", : "mu s chui chn", : "m y d y", : "m fn sh zh", : "m lng jun qi", : "m lng wn jio", : "m mn b zho", : "m b zhu bin", : "mng zhng zh dng", : "mng h zh yng", : "mng xio d yn", : "mng w g dng", : "mio ch kn sh", : "mng xu q cho", : "min l b ci", : "m yu ji y", : "m y tu sh", : "m lin hi g", : "mn shn l jng", : "mn dn h b", : "mi dn chn xng", : "mo mng ji jio", : "mo su du jng", : "mo f do sh", : "mi wn wi shng", : "mi l zun h", : "mi d hun zh", : "mn sn yun s", : "m r hu shn", : "lu p jing h", : "lu lu nn h", : "lu co wi ku", : "lu zh gu xin", : "lun fng h mng", : "shui yu ji zhng", : "shui t tng qng", : "shui shu sh rn", : "shui t gu xn", : "shui m y j", : "shui r chng zhng", : "l jn yn xu", : "lu jn gng ln", : "lng nio jin yun", : "lng nio ch y", : "lng yu q zho", : "lng xu xun hung", : "lng dio fng j", : "li ch zh tu", : "lng yun zh q", : "lng rn png f", : "lng jng cu l", : "ln d y jing", : "li shang y chung", : "li gun hu min", : "lio w j s", : "lio shn d mng", : "lio rn w wn", : "lio b k jin", : "lio b zhng jn", : "lio f cu k", : "shn sh du sh", : "ling xio l wi", : "xing sh du l", : "ling ru zh zo", : "ling r jing hi", : "ling jn mi f", : "ling j shn fn", : "lin g chu hn", : "l y wi zh", : "l lng zh hn", : "l gung b hu", : "l wi qng mo", : "l rng wi gu", : "l shng xng jio", : "l bn jio m", : "lng mi hng yn", : "li tin do d", : "li z chng b", : "li w ji shng", : "li t zh shn", : "li t j sh", : "li lun zh wi", : "li li r zh", : "li kui j s", : "l shn l shu", : "lo yun jn tin", : "lo sh xi r", : "lo sh g zi", : "lng hun f d", : "ku qng du l", : "kung r li sh", : "kung ji m fng", : "k sh shng hu", : "ku qng sh b", : "ku jio shng fng", : "ku jio chn fng", : "ku jio fng qng", : "ku gn sh jio", : "ku f zh li", : "kng f pin pin", : "k y lio zu", : "k m wi h", : "k zh tu y", : "k tu chng zh", : "kng yn wi sh", : "ki hu ji gu", : "jn bn yn ch", : "jio ti j jn", : "ju m pn zh", : "ju tu jing no", : "ju tu ju no", : "jun nio zh hun", : "jun x r zng", : "jun ji bi do", : "j m wi shn", : "j shu xing qng", : "j sh hn zhu", : "j wi mo co", : "j shn qin jing", : "j xi shn shng", : "ji yo b wng", : "ji zhun gng chng", : "ji zhng sn hn", : "jng y l qn", : "jng d xi m", : "jng q jun sh", : "jng j zi t", : "jn sh ki si", : "jn wi shng rng", : "jn tu xio chng", : "jn tu yng j", : "jn tu ch fn", : "jn tu b zh", : "jn du jn sho", : "jn nng hun sh", : "jn j z sh", : "jn gng f q", : "jn gun xin si", : "jn w b jn", : "jn ch bi hi", : "ji y y rn", : "ji rn nn d", : "ji lng x lng", : "ji f yng kung", : "ji q o qio", : "jio no shng m", : "jio shu ling fi", : "jio l ji ch", : "jio sh ln sh", : "jio r s n", : "jio fng b s", : "xing yo zhu gui", : "jing q g y", : "jing mn yu jing", : "jing du g y", : "jin hu lng h", : "jin yng du xng", : "jin b k zhng", : "xin s bo p", : "jin q y rn", : "jin s sh m", : "jin b zhng l", : "jin xin cng ch", : "jin zu b sh", : "ji gun tin xi", : "ji f zh qn", : "ji li qin jn", : "ji j rn z", : "ji do cng rng", : "ji di rn w", : "j fng lng yu", : "j xng y qng", : "j shn l yun", : "j gng ling zu", : "j shang lin y", : "j sh xing dio", : "j b k wi", : "j shn yn j", : "j bn yu y", : "j b tng jio", : "j s li ji", : "j sh li r", : "j l wi b", : "j d li gng", : "j chn mi g", : "j pi mo m", : "hu wi f xin", : "hu f xing y", : "hu jn gng ch", : "hn yng ln yng", : "hu zhu wi du", : "hu zhng wi du", : "hu gun li chng", : "hu mng p s", : "hu chun zhun du", : "hung ch do nng", : "hung gun co l", : "hung f r ch", : "hung f chu tio", : "hun zh fn b", : "hun nin zh s", : "hun nin qu lo", : "hui shang wi k", : "hu d hu wn", : "hu xio wi ji", : "hu f wi q", : "hu ch wi fng", : "hu bu lng dng", : "h xin wi chun", : "h l h zh", : "h li h q", : "h b j x", : "hu wi x d", : "hu d zi w", : "hng jin y gn", : "hng l lio f", : "hng shng j z", : "hng bu lng dng", : "hng qing yng du", : "hng n ln shng", : "hn hi nn tin", : "h f j p", : "h s gn l", : "h h hi gn", : "h yn yu s", : "h zng lin hng", : "ho ho shng shng", : "ho yng du hn", : "ho wn z y", : "ho wi sh dun", : "ho wn ju y", : "ho shng zh d", : "ho q shng y", : "ho  b tng", : "ho dn fi s", : "ho gn bo q", : "ho f b shung", : "hn sun lu p", : "hn yng j hu", : "hn h b mng", : "gu wi y shn", : "gu sh ln cu", : "gu xun j sh", : "gung wn xin sheng", : "gung lng sn ju", : "gun shn di l", : "gun j do sh", : "gu x wi mn", : "gu jin xin wn", : "gu g xing lin", : "g wn fn zho", : "g dio dn tn", : "g dio b tn", : "g y shn rn", : "gu h q rng", : "gu x hu gun", : "gu zho j y", : "gng zh bi gn", : "gng wi chn ch", : "gng shu r xing", : "gng jin su bi", : "gng b chn y", : "gng dio m f", : "gng xng gi w", : "gng p nn sh", : "gng lng mng ho", : "gng di gn b", : "gng chng di h", : "gng chng mng dun", : "g s mng yng", : "g g b n", : "g g b t", : "g shu x yng", : "go ch m m", : "go y b yn", : "gng tu z d", : "gn wi gn zu", : "gn fn su sh", : "gn ch xi li", : "gn t sh k", : "gn mng fn y", : "gn jing m y", : "gn chng zh jing", : "f zi w ch", : "f zhi z hun", : "f wi z yn", : "f sh zhng mn", : "f wi hu sh", : "f ho lu j", : "f shu l sh", : "f shu zh s", : "p zhng z ti", : "f tu zhu fn", : "fng wi ki m", : "fng m lun ", : "fng x xi sh", : "fng yng f yn", : "fng w b ji", : "fn t b r", : "fn fng p li", : "fi fi shng shng", : "fi sh b y", : "fi jing sh q", : "fng p xi ch", : "fng lng yun gun", : "fn r b jio", : "fn bn hun yun", : "fn lo wi y", : "f ln chng zhun", : "f b dng zu", : "f yn qin jn", : "f jin t f", : "f dun xn chng", : "r sh wi n", : "r n xn chng", : "r n qng ji", : " w yng shn", : " pio zhn j", : " pio zi do", : "w zu qing ji", : " y zhng shng", : "w sh j xi", : "w j xi li", : "w b q shn", : " hng du sh", : " jn kng yn", : "  shng shng", : " jn nio yn", : "du y d jio", : "du rn su ho", : "du yn shu qing", : "du wn wi f", : "du dun gu yo", : "du ci shn g", : "dn sh w mn", : "dn j hung gun", : "du n yng j", : "dun hun gu zng", : "dun jin b sh", : "d j q ch", : "du j y shng", : "d m wi sh", : "d jun t xu", : "d jn j yun", : "d yu qin qi", : "d sh d jin", : "du zhun shn hng", : "du d lin chng", : "dng jin zhng ji", : "dng y x h", : "dng zhng kun yo", : "dng mng x yng", : "dng ln x zho", : "dng ling x sh", : "dng ji x sh", : "dng ch x zhui", : "dng chng yu r", : "dng chng y sh", : "dng tu ln ln", : "di dng b j", : "di dn bn ji", : "dio xn yn zho", : "din do y chng", : "d b nng xin", : "d m sh z", : "do q f zh", : "do x pi kng", : "do zi gn g", : "do chng su lng", : "do gu wi yn", : "to zi zh j", : "to pi m zu", : "dng chi wi n", : "dng zhu ch zhng", : "dng zhu b zhu", : "dng w sh zhng", : "dn r nng m", : "tn wn tu shu", : "dn ji w y", : "dn s pio yn", : "d p b wn", : "d mng f d", : "d ch y zi", : "d mn h lu", : "t li zhng zh", : "cu hu lio yun", : "cu k d hng", : "cn j zh li", : "cu cu ch ch", : "cu zh ho qing", : "cu gng wi ru", : "cng s ji jin", : "c f b yng", : "c chng b h", : "c bi wi bn", : "chn sh pin j", : "chn sn n f", : "chu tu t y", : "chun wi xio tn", : "chun fng shn hu", : "chun hng zhu l", : "ch ch j li", : "ch zn j xin", : "ch tng yn qu", : "ch sh xio gng", : "ch go ln shn", : "ch r w jin", : "ch mn yng zh", : "ch ch y m", : "ch ch sh t", : "ch ch jn tu", : "chu shn mn hi", : "chng gun z li", : "ch y wi hu", : "ch r yun jia", : "ch dun cn chng", : "ch cn zh gng", : "chng bi x gng", : "chng bi xng fi", : "chn shu hu n", : "chng y do qng", : "chng t zi y", : "chn t ci y", : "chn ji yu w", : "chng d du gng", : "chn yn zhng j", : "chn yn b ju", : "chn k s j", : "ch qin l yn", : "ch shn fng q", : "ch zi chun zhung", : "zho shng m g", : "zho pn m sh", : "cho jn gun g", : "chng r b h", : "chng su y wi", : "chng hng b xi", : "zhng yu zn bi", : "chng shng j r", : "zhng nin sn lo", : "chng chn b lo", : "zhng o sh fi", : "chng tng l sh", : "chn x zhn n", : "ch sn cu s", : "cng ti li xi", : "cng xin di ch", : "cng zng ni j", : "cng yng jin xi", : "cn sng dn b", : "cn fng s xi", : "cn w cu zng", : "shn chn mo yu", : "ci yu gn j", : "ci b zh shui", : "ci d nn yng", : "ci b zh qin", : "b z wi y", : "b z wi j", : "b z wi f", : "b z ch sh", : "b zhu tng r", : "b zh dng dng", : "b yu li ch", : "b xing wi mu", : "b tn wi bo", : "b lio r lio", : "b k ku du", : "b hung q ch", : "b dng b zhng", : "b ch shn me", : "b ch li sh", : "b ling fn xng", : "b t yng sh", : "b w x g", : "b hn zhng rn", : "b wn yu l", : "b kng m m", : "b p chu jn", : "b f chu su", : "b zh yn wi", : "b hi yn zh", : "bng wi jing gu", : "bng qing jing yng", : "bng du jing gung", : "bng b yu jing", : "bng ji d p", : "bn bn j j", : "bio mi zh nin", : "bio l wi jin", : "bio f din j", : "bin tn l b", : "b gi b q", : "b yn mi shu", : "b w zh sh", : "p shn di h", : "p ji zhn g", : "p ji j n", : "p h hui y", : "p f yng gun", : "bi q yo gng", : "bi chung go w", : "bi chn xng gng", : "bi b zh yn", : "bi gng fi sh", : "p y l gun", : "p si lng mn", : "bo l wn xu", : "bo h png h", : "bo wn zhi gu", : "bo f ch sh", : "bo bin y du", : "bng xin zun ln", : "bi jing fng hu", : "bi shu shui w", : "bi kng qin chung", : "bi y qng xing", : "bi shu wi lng", : "bi shu xing zh", : "b wn w yn", : "b gu jun x", : "b bn s yun", : "o b k zhng", : "o gng shu y", : "n sh ch shn", : "n shn wi l", : "n lo hui sho", : "n b dng ch", : "i rn ho sh", : "i rn gun chng", : "i fng j fng", : "i shn s hi", : " ji  wng", : " dng xing wi", : "zhu wng zh bi", : "zh ln d shu", : "zh tng zho r", : "y b jng rn", : "y jn wi li", : "y r sn xng", : "xu j y ch", : "w j li shu", : "w shng w xi", : "wi y b xn", : "sh shn wi gu", : "sh q qi jing", : "qing zu ji rn", : "q chng du ni", : "ln shn l b", : "jn tin gung yu", : "jin nn ji ju", : "ji q ji b", : "hn hn  ", : "hu g b jn", : "gu p  rn", : "g m sh xin", : "f tu zhu fn", : "fng wi zh bo", : "dng tn bi jing", : "chn hn dng xng", : "ch ch wi mng", : "b wn qing zh", : "b nn ji y", : "lio w shng j", : "yu y shu y", : "d y w r", : "shu y b r", : "j y fn sn", : "sh y sh r", : "sh y jng bi", : "dng y mo r", : "dng y qu r", : "b y r zh", : "w y xng min", : "bio l b y", : "ling yu b y", : "xn ku b y", : "yn xng b y", : "zhng lng b y", : "cn c b y", : "fn fn b y", : "hu y b y", : "b y r sn", : "bi b y y", : "yn xng bo y", : "y bi xi y", : "bi chng ji y", : "png chng ji y", : "qun bi fng y", : "qn j h y", : "bi b hu y", : "bi b sh y", : "bi w sh y", : "wn b sh y", : "wn w sh y", : "h r wi y", : "h ling wi y", : "h r wi y", : "tin xi wi y", : "xing y wi y", : "jio ru hu y", : "jio r hu y", : "jio ru hu y", : "yn xng ru y", : "sh zhng ru y", : "zhng sh ru y", : "wi jng wi y", : "zhng du fi y", : "b nng zn y", : "wn y d sh", : "y b ni zhng", : "y y gun zh", : "y y dng bi", : "bi b dng y", : "sh b dng y", : "y y jng bi", : "y y fng bi", : "y y ch wn", : "y y zh wn", : "bi l tio y", : "zhng q hu y", : "y li r q", : "y l gng jio", : "y l q ch", : "y l b sh", : "zho cho zho lu", : "q y fng yng", : "y hng b xng", : "hng hng b xng" }, Ast = Object.keys(EO).map((n) => ({ zh: n, pinyin: EO[n], probability: 2e-8, length: 4, priority: Gr.Normal, dict: Symbol("dict4") })), IO = { : "b r gn bn do", : "b r k sh h", : "b xng r yn zhng", : "b r sh wi k", : "h l r b wi", : "k zhng mng y h", : "mng d wi d y", : "mn y sh wi tin", : "sh hu zh g ling", : "w y x wi gu", : "xin xi shu wi qing", : "hng hng ch zhung yuan", : "y d l y hi", : "yn b jin wi jng", : "zh tng do du zi" }, pst = Object.keys(IO).map((n) => ({ zh: n, pinyin: IO[n], probability: 2e-8, length: 5, priority: Gr.Normal, dict: Symbol("dict5") }));
      function xO(n, t) {
        return n && (n.decimal < t.decimal || n.decimal === t.decimal && n.probability > t.probability) ? n : t;
      }
      function wO(n) {
        n.probability < 1e-300 && (n.probability *= 1e300, n.decimal += 1);
      }
      function vst(n) {
        return n.priority === Gr.Custom ? -(n.length * n.length * 100) : n.priority === Gr.Surname ? -(n.length * n.length * 10) : 0;
      }
      function yst(n, t) {
        const e = [];
        let i = n.length - 1, r = n[i];
        for (let a = t - 1; a >= 0; a--) {
          const o = a + 1 >= t ? { probability: 1, decimal: 0, patterns: [] } : e[a + 1];
          for (; r && r.index + r.length - 1 === a; ) {
            const l = r.index, u = { probability: r.probability * o.probability, decimal: o.decimal + vst(r), patterns: o.patterns, concatPattern: r };
            wO(u), e[l] = xO(e[l], u), r = n[--i];
          }
          const s = { probability: 1e-13 * o.probability, decimal: 0, patterns: o.patterns };
          wO(s), e[a] = xO(e[a], s), e[a].concatPattern && (e[a].patterns = e[a].patterns.concat(e[a].concatPattern), e[a].concatPattern = void 0, delete e[a + 1]);
        }
        return e[0].patterns.reverse();
      }
      function CO(n, t) {
        return n && n.count <= t.count ? n : t;
      }
      function mst(n) {
        return n.priority === Gr.Custom ? -(n.length * n.length * 1e5) : n.priority === Gr.Surname ? -(n.length * n.length * 100) : 1;
      }
      function _st(n, t) {
        const e = [];
        let i = n.length - 1, r = n[i];
        for (let a = t - 1; a >= 0; a--) {
          const o = a + 1 >= t ? { count: 0, patterns: [] } : e[a + 1];
          for (; r && r.index + r.length - 1 === a; ) {
            const l = r.index, u = { count: mst(r) + o.count, patterns: o.patterns, concatPattern: r };
            e[l] = CO(e[l], u), r = n[--i];
          }
          const s = { count: 1 + o.count, patterns: o.patterns };
          e[a] = CO(e[a], s), e[a].concatPattern && (e[a].patterns = e[a].patterns.concat(e[a].concatPattern), e[a].concatPattern = void 0, delete e[a + 1]);
        }
        return e[0].patterns.reverse();
      }
      function Est(n, t) {
        return !(t.index + t.length <= n.index || t.priority > n.priority || t.priority === n.priority && t.length > n.length);
      }
      function Ist(n) {
        const t = [];
        for (let e = n.length - 1; e >= 0; ) {
          const { index: i } = n[e];
          let r = e - 1;
          for (; r >= 0 && Est(n[e], n[r]); ) r--;
          (r < 0 || n[r].index + n[r].length <= i) && t.push(n[e]), e = r;
        }
        return t.reverse();
      }
      var SO;
      (function(n) {
        n[n.ReverseMaxMatch = 1] = "ReverseMaxMatch", n[n.MaxProbability = 2] = "MaxProbability", n[n.MinTokenization = 3] = "MinTokenization";
      })(SO || (SO = {}));
      class bO {
        constructor(t, e = "", i = "") {
          this.children = /* @__PURE__ */ new Map(), this.fail = null, this.patterns = [], this.parent = t, this.prefix = e, this.key = i;
        }
      }
      class xst {
        constructor() {
          this.dictMap = /* @__PURE__ */ new Map(), this.queues = [], this.root = new bO(null);
        }
        build(t) {
          this.buildTrie(t), this.buildFailPointer();
        }
        buildTrie(t) {
          for (let e of t) {
            const i = x0(e.zh);
            let r = this.root;
            for (let a = 0; a < i.length; a++) {
              let o = i[a];
              if (!r.children.has(o)) {
                const s = new bO(r, i.slice(0, a).join(""), o);
                r.children.set(o, s), this.addNodeToQueues(s);
              }
              r = r.children.get(o);
            }
            this.insertPattern(r.patterns, e), e.node = r, this.addPatternToDictMap(e);
          }
        }
        buildFailPointer() {
          let t = [], e = 0;
          for (this.queues.forEach((i) => {
            t = t.concat(i);
          }), this.queues = []; t.length > e; ) {
            let i = t[e++], r = i.parent && i.parent.fail, a = i.key;
            for (; r && !r.children.has(a); ) r = r.fail;
            r ? i.fail = r.children.get(a) : i.fail = this.root;
          }
        }
        addPatternToDictMap(t) {
          this.dictMap.has(t.dict) || this.dictMap.set(t.dict, /* @__PURE__ */ new Set()), this.dictMap.get(t.dict).add(t);
        }
        addNodeToQueues(t) {
          this.queues[Va(t.prefix)] || (this.queues[Va(t.prefix)] = []), this.queues[Va(t.prefix)].push(t);
        }
        insertPattern(t, e) {
          for (let i = t.length - 1; i >= 0; i--) {
            const r = t[i];
            if (e.priority === r.priority && e.probability >= r.probability) t[i + 1] = r;
            else if (e.priority > r.priority) t[i + 1] = r;
            else {
              t[i + 1] = e;
              return;
            }
          }
          t[0] = e;
        }
        removeDict(t) {
          this.dictMap.has(t) && (this.dictMap.get(t).forEach((i) => {
            i.node.patterns = i.node.patterns.filter((r) => r !== i);
          }), this.dictMap.delete(t));
        }
        match(t, e) {
          let i = this.root, r = [];
          const a = x0(t);
          for (let o = 0; o < a.length; o++) {
            let s = a[o];
            for (; i !== null && !i.children.has(s); ) i = i.fail;
            if (i === null) i = this.root;
            else {
              i = i.children.get(s);
              const l = i.patterns.find((h) => e === "off" ? h.priority !== Gr.Surname : e === "head" ? h.length - 1 - o === 0 : true);
              l && r.push(Object.assign(Object.assign({}, l), { index: o - l.length + 1 }));
              let u = i.fail;
              for (; u !== null; ) {
                const h = u.patterns.find((c) => e === "off" ? c.priority !== Gr.Surname : e === "head" ? c.length - 1 - o === 0 : true);
                h && r.push(Object.assign(Object.assign({}, h), { index: o - h.length + 1 })), u = u.fail;
              }
            }
          }
          return r;
        }
        search(t, e, i = 2) {
          const r = this.match(t, e);
          return i === 1 ? Ist(r) : i === 3 ? _st(r, Va(t)) : yst(r, Va(t));
        }
      }
      const wst = [...pst, ...Ast, ...dst, ...gst, ...ost, ...fst], TO = new xst();
      TO.build(wst);
      const Cst = new fO(), Sst = () => Cst, tp = (n) => {
        const t = kl.get(n);
        return t ? t.split(" ")[0] : n;
      }, bst = (n, t, e, i) => {
        const r = TO.search(n, e, i);
        let a = 0;
        const o = x0(n);
        for (let s = 0; s < o.length; ) {
          const l = r[a];
          if (l && s === l.index) {
            if (l.length === 1 && l.priority <= Gr.Normal) {
              const c = o[s];
              let f = "";
              f = yO(c, o[s - 1], o[s + 1]), t[s] = { origin: c, result: f, isZh: f !== c, originPinyin: f }, s++, a++;
              continue;
            }
            const u = l.pinyin.split(" ");
            let h = 0;
            for (let c = 0; c < l.length; c++) {
              const f = x0(l.zh);
              t[s + c] = { origin: f[c], result: u[h], isZh: true, originPinyin: u[h] }, h++;
            }
            s += l.length, a++;
          } else {
            const u = o[s];
            let h = "";
            h = yO(u, o[s - 1], o[s + 1]), t[s] = { origin: u, result: h, isZh: h !== u, originPinyin: h }, s++;
          }
        }
        return { list: t, matches: r };
      }, w0 = (n) => n.replace(/(|||)/g, "a").replace(/(|||)/g, "o").replace(/(|||)/g, "e").replace(/(|||)/g, "i").replace(/(|||)/g, "u").replace(/(|||)/g, "").replace(/(n|||)/g, "n").replace(/(m||m|m)/g, "m").replace(/(|||)/g, ""), BO = (n, t = "off") => {
        const e = Sst();
        let i = kl.get(n) ? kl.get(n).split(" ") : [];
        if (e.get(n)) i = e.get(n).split(" ");
        else if (t !== "off") {
          const r = AC[n];
          r && (i = [r].concat(i.filter((a) => a !== r)));
        }
        return i;
      }, Tst = (n, t = "off") => {
        let e = BO(n, t);
        return e.length > 0 ? e.map((i) => ({ origin: n, result: i, isZh: true, originPinyin: i })) : [{ origin: n, result: n, isZh: false, originPinyin: n }];
      }, C0 = (n) => {
        const t = n.split(" "), e = [], i = [];
        for (let r of t) for (let a of tst) if (r.startsWith(a)) {
          let o = r.slice(a.length);
          est.indexOf(a) !== -1 && nst.indexOf(o) !== -1 && (o = ist[o]), e.push(a), i.push(o);
          break;
        }
        return { final: i.join(" "), initial: e.join(" ") };
      }, S0 = (n) => {
        const { final: t } = C0(n);
        let e = "", i = "", r = "";
        return rst.indexOf(w0(t)) !== -1 ? (e = t[0], i = t[1], r = t.slice(2)) : (i = t[0] || "", r = t.slice(1) || ""), { head: e, body: i, tail: r };
      }, b0 = (n) => {
        const t = /(||||||n|m|)/, e = /(||||||||)/, i = /(|||||||m|)/, r = /(|||||||m|)/, a = /(a|o|e|i|u||)/, o = /(n|m)$/, s = [];
        return n.split(" ").forEach((u) => {
          t.test(u) ? s.push("1") : e.test(u) ? s.push("2") : i.test(u) ? s.push("3") : r.test(u) ? s.push("4") : a.test(u) || o.test(u) ? s.push("0") : s.push("");
        }), s.join(" ");
      }, Bst = (n, t) => {
        const e = w0(n).split(" "), i = b0(t).split(" "), r = [];
        return e.forEach((a, o) => {
          r.push(`${a}${i[o]}`);
        }), r.join(" ");
      }, MO = (n, t) => {
        const e = [];
        return n.split(" ").forEach((r) => {
          e.push(t ? r[0] : r);
        }), e.join(" ");
      }, Mst = (n) => typeof n == "string";
      function pC(n, t) {
        return t instanceof RegExp ? t.test(n) : true;
      }
      const Dst = (n, t) => {
        let e = t.nonZh;
        if (e === "removed") return n.filter((i) => i.isZh || !pC(i.origin, t.nonZhScope));
        if (e === "consecutive") {
          for (let i = n.length - 2; i >= 0; i--) {
            const r = n[i], a = n[i + 1];
            !r.isZh && !a.isZh && pC(r.origin, t.nonZhScope) && pC(a.origin, t.nonZhScope) && (r.origin += a.origin, r.result += a.result, a.delete = true);
          }
          return n.filter((i) => !i.delete);
        } else return n;
      }, DO = (n, t) => Va(n) === 1 && t.multiple ? Tst(n, t.surname) : false, Rst = (n, t) => {
        switch (t.pattern) {
          case "pinyin":
            break;
          case "num":
            n.forEach((e) => {
              e.result = e.isZh ? b0(e.result) : "";
            });
            break;
          case "initial":
            n.forEach((e) => {
              e.result = e.isZh ? C0(e.result).initial : "";
            });
            break;
          case "final":
            n.forEach((e) => {
              e.result = e.isZh ? C0(e.result).final : "";
            });
            break;
          case "first":
            n.forEach((e) => {
              e.result = MO(e.result, e.isZh);
            });
            break;
          case "finalHead":
            n.forEach((e) => {
              e.result = e.isZh ? S0(e.result).head : "";
            });
            break;
          case "finalBody":
            n.forEach((e) => {
              e.result = e.isZh ? S0(e.result).body : "";
            });
            break;
          case "finalTail":
            n.forEach((e) => {
              e.result = e.isZh ? S0(e.result).tail : "";
            });
            break;
        }
      }, Lst = (n, t) => {
        switch (t.toneType) {
          case "symbol":
            break;
          case "none":
            n.forEach((e) => {
              e.isZh && (e.result = w0(e.result));
            });
            break;
          case "num": {
            n.forEach((e) => {
              e.isZh && (e.result = Bst(e.result, e.originPinyin));
            });
            break;
          }
        }
      }, Pst = (n, t) => {
        t.v && n.forEach((e) => {
          e.isZh && (e.result = e.result.replace(//g, "v"));
        });
      }, Nst = (n, t, e) => {
        if (t.multiple && Va(e) === 1) {
          let i = "";
          n = n.filter((r) => {
            const a = r.result !== i;
            return i = r.result, a;
          });
        }
        return t.type === "array" ? n.map((i) => i.result) : t.type === "all" ? n.map((i) => {
          const r = i.isZh ? i.result : "", { initial: a, final: o } = C0(r), { head: s, body: l, tail: u } = S0(r);
          let h = [];
          return r !== "" && (h = [r].concat(BO(i.origin, t.surname).filter((c) => c !== r))), { origin: i.origin, pinyin: r, initial: a, final: o, first: MO(i.result, i.isZh), finalHead: s, finalBody: l, finalTail: u, num: Number(b0(i.originPinyin)), isZh: i.isZh, polyphonic: h, inZhRange: !!kl.get(i.origin), result: i.result };
        }) : n.map((i) => i.result).join(t.separator);
      }, Fst = (n, t) => (t === false && n.forEach((e) => {
        e.origin === "" ? e.result = e.originPinyin = "y" : e.origin === "" && (e.result = e.originPinyin = "b");
      }), n), kst = { pattern: "pinyin", toneType: "symbol", type: "string", multiple: false, mode: "normal", removeNonZh: false, nonZh: "spaced", v: false, separator: " ", toneSandhi: true, segmentit: 2 };
      function Ost(n, t) {
        if (t = Object.assign(Object.assign({}, kst), t || {}), !Mst(n)) return n;
        if (n === "") return t.type === "array" || t.type === "all" ? [] : "";
        t.surname === void 0 && (t.mode === "surname" ? t.surname = "all" : t.surname = "off"), t.type === "all" && (t.pattern = "pinyin"), t.pattern === "num" && (t.toneType = "none"), t.removeNonZh && (t.nonZh = "removed");
        let i = Array(Va(n)), { list: r } = bst(n, i, t.surname, t.segmentit);
        return r = Fst(r, t.toneSandhi), r = Dst(r, t), DO(n, t) && (r = DO(n, t)), Rst(r, t), Lst(r, t), Pst(r, t), Nst(r, t, n);
      }
      var vC;
      (function(n) {
        n[n.AllSegment = 1] = "AllSegment", n[n.AllArray = 2] = "AllArray", n[n.AllString = 3] = "AllString", n[n.PinyinSegment = 4] = "PinyinSegment", n[n.PinyinArray = 5] = "PinyinArray", n[n.PinyinString = 6] = "PinyinString", n[n.ZhSegment = 7] = "ZhSegment", n[n.ZhArray = 8] = "ZhArray", n[n.ZhString = 9] = "ZhString";
      })(vC || (vC = {})), vC.AllSegment;
      const yC = [{ name: "", longitude: 116.405285, latitude: 39.904989 }, { name: "", longitude: 117.190182, latitude: 39.125596 }, { name: "", longitude: 114.502461, latitude: 38.045474 }, { name: "", longitude: 118.175393, latitude: 39.635113 }, { name: "", longitude: 119.586579, latitude: 39.942531 }, { name: "", longitude: 114.490686, latitude: 36.612273 }, { name: "", longitude: 114.508851, latitude: 37.0682 }, { name: "", longitude: 115.482331, latitude: 38.867657 }, { name: "", longitude: 114.884091, latitude: 40.811901 }, { name: "", longitude: 117.939152, latitude: 40.976204 }, { name: "", longitude: 116.857461, latitude: 38.310582 }, { name: "", longitude: 116.704441, latitude: 39.523927 }, { name: "", longitude: 115.665993, latitude: 37.735097 }, { name: "", longitude: 112.549248, latitude: 37.857014 }, { name: "", longitude: 113.295259, latitude: 40.09031 }, { name: "", longitude: 113.583285, latitude: 37.861188 }, { name: "", longitude: 113.113556, latitude: 36.191112 }, { name: "", longitude: 112.851274, latitude: 35.497553 }, { name: "", longitude: 112.433387, latitude: 39.331261 }, { name: "", longitude: 112.736465, latitude: 37.696495 }, { name: "", longitude: 111.003957, latitude: 35.022778 }, { name: "", longitude: 112.733538, latitude: 38.41769 }, { name: "", longitude: 111.517973, latitude: 36.08415 }, { name: "", longitude: 111.134335, latitude: 37.524366 }, { name: "", longitude: 111.670801, latitude: 40.818311 }, { name: "", longitude: 109.840405, latitude: 40.658168 }, { name: "", longitude: 106.825563, latitude: 39.673734 }, { name: "", longitude: 118.956806, latitude: 42.275317 }, { name: "", longitude: 122.263119, latitude: 43.617429 }, { name: "", longitude: 109.99029, latitude: 39.817179 }, { name: "", longitude: 119.758168, latitude: 49.215333 }, { name: "", longitude: 107.416959, latitude: 40.757402 }, { name: "", longitude: 113.114543, latitude: 41.034126 }, { name: "", longitude: 122.070317, latitude: 46.076268 }, { name: "", longitude: 116.090996, latitude: 43.944018 }, { name: "", longitude: 105.706422, latitude: 38.844814 }, { name: "", longitude: 123.429096, latitude: 41.796767 }, { name: "", longitude: 121.618622, latitude: 38.91459 }, { name: "", longitude: 122.995632, latitude: 41.110626 }, { name: "", longitude: 123.921109, latitude: 41.875956 }, { name: "", longitude: 123.770519, latitude: 41.297909 }, { name: "", longitude: 124.383044, latitude: 40.124296 }, { name: "", longitude: 121.135742, latitude: 41.119269 }, { name: "", longitude: 122.235151, latitude: 40.667432 }, { name: "", longitude: 121.648962, latitude: 42.011796 }, { name: "", longitude: 123.18152, latitude: 41.269402 }, { name: "", longitude: 122.06957, latitude: 41.124484 }, { name: "", longitude: 123.844279, latitude: 42.290585 }, { name: "", longitude: 120.451176, latitude: 41.576758 }, { name: "", longitude: 120.856394, latitude: 40.755572 }, { name: "", longitude: 125.3245, latitude: 43.886841 }, { name: "", longitude: 126.55302, latitude: 43.843577 }, { name: "", longitude: 124.370785, latitude: 43.170344 }, { name: "", longitude: 125.145349, latitude: 42.902692 }, { name: "", longitude: 125.936501, latitude: 41.721177 }, { name: "", longitude: 126.427839, latitude: 41.942505 }, { name: "", longitude: 124.823608, latitude: 45.118243 }, { name: "", longitude: 122.841114, latitude: 45.619026 }, { name: "", longitude: 129.513228, latitude: 42.904823 }, { name: "", longitude: 126.642464, latitude: 45.756967 }, { name: "", longitude: 123.95792, latitude: 47.342081 }, { name: "", longitude: 130.975966, latitude: 45.300046 }, { name: "", longitude: 130.277487, latitude: 47.332085 }, { name: "", longitude: 131.157304, latitude: 46.643442 }, { name: "", longitude: 125.11272, latitude: 46.590734 }, { name: "", longitude: 128.899396, latitude: 47.724775 }, { name: "", longitude: 130.361634, latitude: 46.809606 }, { name: "", longitude: 131.015584, latitude: 45.771266 }, { name: "", longitude: 129.618602, latitude: 44.582962 }, { name: "", longitude: 127.499023, latitude: 50.249585 }, { name: "", longitude: 126.99293, latitude: 46.637393 }, { name: "", longitude: 124.711526, latitude: 52.335262 }, { name: "", longitude: 121.472644, latitude: 31.231706 }, { name: "", longitude: 118.767413, latitude: 32.041544 }, { name: "", longitude: 120.301663, latitude: 31.574729 }, { name: "", longitude: 117.184811, latitude: 34.261792 }, { name: "", longitude: 119.946973, latitude: 31.772752 }, { name: "", longitude: 120.619585, latitude: 31.299379 }, { name: "", longitude: 120.864608, latitude: 32.016212 }, { name: "", longitude: 119.178821, latitude: 34.600018 }, { name: "", longitude: 119.021265, latitude: 33.597506 }, { name: "", longitude: 120.139998, latitude: 33.377631 }, { name: "", longitude: 119.421003, latitude: 32.393159 }, { name: "", longitude: 119.452753, latitude: 32.204402 }, { name: "", longitude: 119.915176, latitude: 32.484882 }, { name: "", longitude: 118.275162, latitude: 33.963008 }, { name: "", longitude: 120.153576, latitude: 30.287459 }, { name: "", longitude: 121.549792, latitude: 29.868388 }, { name: "", longitude: 120.672111, latitude: 28.000575 }, { name: "", longitude: 120.750865, latitude: 30.762653 }, { name: "", longitude: 120.102398, latitude: 30.867198 }, { name: "", longitude: 120.582112, latitude: 29.997117 }, { name: "", longitude: 119.649506, latitude: 29.089524 }, { name: "", longitude: 118.87263, latitude: 28.941708 }, { name: "", longitude: 122.106863, latitude: 30.016028 }, { name: "", longitude: 121.428599, latitude: 28.661378 }, { name: "", longitude: 119.921786, latitude: 28.451993 }, { name: "", longitude: 117.283042, latitude: 31.86119 }, { name: "", longitude: 118.376451, latitude: 31.326319 }, { name: "", longitude: 117.363228, latitude: 32.939667 }, { name: "", longitude: 117.018329, latitude: 32.647574 }, { name: "", longitude: 118.507906, latitude: 31.689362 }, { name: "", longitude: 116.794664, latitude: 33.971707 }, { name: "", longitude: 117.816576, latitude: 30.929935 }, { name: "", longitude: 117.043551, latitude: 30.50883 }, { name: "", longitude: 118.317325, latitude: 29.709239 }, { name: "", longitude: 118.316264, latitude: 32.303627 }, { name: "", longitude: 115.819729, latitude: 32.896969 }, { name: "", longitude: 116.984084, latitude: 33.633891 }, { name: "", longitude: 116.507676, latitude: 31.752889 }, { name: "", longitude: 115.782939, latitude: 33.869338 }, { name: "", longitude: 117.489157, latitude: 30.656037 }, { name: "", longitude: 118.757995, latitude: 30.945667 }, { name: "", longitude: 119.306239, latitude: 26.075302 }, { name: "", longitude: 118.11022, latitude: 24.490474 }, { name: "", longitude: 119.007558, latitude: 25.431011 }, { name: "", longitude: 117.635001, latitude: 26.265444 }, { name: "", longitude: 118.589421, latitude: 24.908853 }, { name: "", longitude: 117.661801, latitude: 24.510897 }, { name: "", longitude: 118.178459, latitude: 26.635627 }, { name: "", longitude: 117.02978, latitude: 25.091603 }, { name: "", longitude: 119.527082, latitude: 26.65924 }, { name: "", longitude: 115.892151, latitude: 28.676493 }, { name: "", longitude: 117.214664, latitude: 29.29256 }, { name: "", longitude: 113.852186, latitude: 27.622946 }, { name: "", longitude: 115.992811, latitude: 29.712034 }, { name: "", longitude: 114.930835, latitude: 27.810834 }, { name: "", longitude: 117.033838, latitude: 28.238638 }, { name: "", longitude: 114.940278, latitude: 25.85097 }, { name: "", longitude: 114.986373, latitude: 27.111699 }, { name: "", longitude: 114.391136, latitude: 27.8043 }, { name: "", longitude: 116.358351, latitude: 27.98385 }, { name: "", longitude: 117.971185, latitude: 28.44442 }, { name: "", longitude: 117.000923, latitude: 36.675807 }, { name: "", longitude: 120.355173, latitude: 36.082982 }, { name: "", longitude: 118.047648, latitude: 36.814939 }, { name: "", longitude: 117.557964, latitude: 34.856424 }, { name: "", longitude: 118.66471, latitude: 37.434564 }, { name: "", longitude: 121.391382, latitude: 37.539297 }, { name: "", longitude: 119.107078, latitude: 36.70925 }, { name: "", longitude: 116.587245, latitude: 35.415393 }, { name: "", longitude: 117.129063, latitude: 36.194968 }, { name: "", longitude: 122.116394, latitude: 37.509691 }, { name: "", longitude: 119.461208, latitude: 35.428588 }, { name: "", longitude: 118.326443, latitude: 35.065282 }, { name: "", longitude: 116.307428, latitude: 37.453968 }, { name: "", longitude: 115.980367, latitude: 36.456013 }, { name: "", longitude: 118.016974, latitude: 37.383542 }, { name: "", longitude: 115.469381, latitude: 35.246531 }, { name: "", longitude: 113.665412, latitude: 34.757975 }, { name: "", longitude: 114.341447, latitude: 34.797049 }, { name: "", longitude: 112.434468, latitude: 34.663041 }, { name: "", longitude: 113.307718, latitude: 33.735241 }, { name: "", longitude: 114.352482, latitude: 36.103442 }, { name: "", longitude: 114.295444, latitude: 35.748236 }, { name: "", longitude: 113.883991, latitude: 35.302616 }, { name: "", longitude: 113.238266, latitude: 35.23904 }, { name: "", longitude: 115.041299, latitude: 35.768234 }, { name: "", longitude: 113.826063, latitude: 34.022956 }, { name: "", longitude: 114.026405, latitude: 33.575855 }, { name: "", longitude: 111.194099, latitude: 34.777338 }, { name: "", longitude: 112.540918, latitude: 32.999082 }, { name: "", longitude: 115.650497, latitude: 34.437054 }, { name: "", longitude: 114.075031, latitude: 32.123274 }, { name: "", longitude: 114.649653, latitude: 33.620357 }, { name: "", longitude: 114.024736, latitude: 32.980169 }, { name: "", longitude: 112.590047, latitude: 35.090378 }, { name: "", longitude: 114.298572, latitude: 30.584355 }, { name: "", longitude: 115.077048, latitude: 30.220074 }, { name: "", longitude: 110.787916, latitude: 32.646907 }, { name: "", longitude: 111.290843, latitude: 30.702636 }, { name: "", longitude: 112.144146, latitude: 32.042426 }, { name: "", longitude: 114.890593, latitude: 30.396536 }, { name: "", longitude: 112.204251, latitude: 31.03542 }, { name: "", longitude: 113.926655, latitude: 30.926423 }, { name: "", longitude: 112.23813, latitude: 30.326857 }, { name: "", longitude: 114.879365, latitude: 30.447711 }, { name: "", longitude: 114.328963, latitude: 29.832798 }, { name: "", longitude: 113.37377, latitude: 31.717497 }, { name: "", longitude: 109.48699, latitude: 30.283114 }, { name: "", longitude: 113.453974, latitude: 30.364953 }, { name: "", longitude: 112.896866, latitude: 30.421215 }, { name: "", longitude: 113.165862, latitude: 30.653061 }, { name: "", longitude: 110.671525, latitude: 31.744449 }, { name: "", longitude: 112.982279, latitude: 28.19409 }, { name: "", longitude: 113.151737, latitude: 27.835806 }, { name: "", longitude: 112.944052, latitude: 27.82973 }, { name: "", longitude: 112.607693, latitude: 26.900358 }, { name: "", longitude: 111.46923, latitude: 27.237842 }, { name: "", longitude: 113.132855, latitude: 29.37029 }, { name: "", longitude: 111.691347, latitude: 29.040225 }, { name: "", longitude: 110.479921, latitude: 29.127401 }, { name: "", longitude: 112.355042, latitude: 28.570066 }, { name: "", longitude: 113.032067, latitude: 25.793589 }, { name: "", longitude: 111.608019, latitude: 26.434516 }, { name: "", longitude: 109.97824, latitude: 27.550082 }, { name: "", longitude: 112.008497, latitude: 27.728136 }, { name: "", longitude: 109.739735, latitude: 28.314296 }, { name: "", longitude: 113.280637, latitude: 23.125178 }, { name: "", longitude: 113.591544, latitude: 24.801322 }, { name: "", longitude: 114.085947, latitude: 22.547 }, { name: "", longitude: 113.553986, latitude: 22.224979 }, { name: "", longitude: 116.708463, latitude: 23.37102 }, { name: "", longitude: 113.122717, latitude: 23.028762 }, { name: "", longitude: 113.094942, latitude: 22.590431 }, { name: "", longitude: 110.364977, latitude: 21.274898 }, { name: "", longitude: 110.919229, latitude: 21.659751 }, { name: "", longitude: 112.472529, latitude: 23.051546 }, { name: "", longitude: 114.412599, latitude: 23.079404 }, { name: "", longitude: 116.117582, latitude: 24.299112 }, { name: "", longitude: 115.364238, latitude: 22.774485 }, { name: "", longitude: 114.697802, latitude: 23.746266 }, { name: "", longitude: 111.975107, latitude: 21.859222 }, { name: "", longitude: 113.051227, latitude: 23.685022 }, { name: "", longitude: 113.746262, latitude: 23.046237 }, { name: "", longitude: 113.382391, latitude: 22.521113 }, { name: "", longitude: 116.632301, latitude: 23.661701 }, { name: "", longitude: 116.355733, latitude: 23.543778 }, { name: "", longitude: 112.044439, latitude: 22.929801 }, { name: "", longitude: 108.320004, latitude: 22.82402 }, { name: "", longitude: 109.411703, latitude: 24.314617 }, { name: "", longitude: 110.299121, latitude: 25.274215 }, { name: "", longitude: 111.297604, latitude: 23.474803 }, { name: "", longitude: 109.119254, latitude: 21.473343 }, { name: "", longitude: 108.345478, latitude: 21.614631 }, { name: "", longitude: 108.624175, latitude: 21.967127 }, { name: "", longitude: 109.602146, latitude: 23.0936 }, { name: "", longitude: 110.154393, latitude: 22.63136 }, { name: "", longitude: 106.616285, latitude: 23.897742 }, { name: "", longitude: 111.552056, latitude: 24.414141 }, { name: "", longitude: 108.062105, latitude: 24.695899 }, { name: "", longitude: 109.229772, latitude: 23.733766 }, { name: "", longitude: 107.353926, latitude: 22.404108 }, { name: "", longitude: 110.33119, latitude: 20.031971 }, { name: "", longitude: 109.508268, latitude: 18.247872 }, { name: "", longitude: 112.34882, latitude: 16.831039 }, { name: "", longitude: 109.576782, latitude: 19.517486 }, { name: "", longitude: 109.516662, latitude: 18.776921 }, { name: "", longitude: 110.466785, latitude: 19.246011 }, { name: "", longitude: 110.753975, latitude: 19.612986 }, { name: "", longitude: 110.388793, latitude: 18.796216 }, { name: "", longitude: 108.653789, latitude: 19.10198 }, { name: "", longitude: 110.349235, latitude: 19.684966 }, { name: "", longitude: 110.102773, latitude: 19.362916 }, { name: "", longitude: 110.007147, latitude: 19.737095 }, { name: "", longitude: 109.687697, latitude: 19.908293 }, { name: "", longitude: 109.452606, latitude: 19.224584 }, { name: "", longitude: 109.053351, latitude: 19.260968 }, { name: "", longitude: 109.175444, latitude: 18.74758 }, { name: "", longitude: 110.037218, latitude: 18.505006 }, { name: "", longitude: 109.70245, latitude: 18.636371 }, { name: "", longitude: 109.839996, latitude: 19.03557 }, { name: "", longitude: 106.504962, latitude: 29.533155 }, { name: "", longitude: 104.065735, latitude: 30.659462 }, { name: "", longitude: 104.773447, latitude: 29.352765 }, { name: "", longitude: 101.716007, latitude: 26.580446 }, { name: "", longitude: 105.443348, latitude: 28.889138 }, { name: "", longitude: 104.398651, latitude: 31.127991 }, { name: "", longitude: 104.741722, latitude: 31.46402 }, { name: "", longitude: 105.829757, latitude: 32.433668 }, { name: "", longitude: 105.571331, latitude: 30.513311 }, { name: "", longitude: 105.066138, latitude: 29.58708 }, { name: "", longitude: 103.761263, latitude: 29.582024 }, { name: "", longitude: 106.082974, latitude: 30.795281 }, { name: "", longitude: 103.831788, latitude: 30.048318 }, { name: "", longitude: 104.630825, latitude: 28.760189 }, { name: "", longitude: 106.633369, latitude: 30.456398 }, { name: "", longitude: 107.502262, latitude: 31.209484 }, { name: "", longitude: 103.001033, latitude: 29.987722 }, { name: "", longitude: 106.753669, latitude: 31.858809 }, { name: "", longitude: 104.641917, latitude: 30.122211 }, { name: "", longitude: 102.221374, latitude: 31.899792 }, { name: "", longitude: 101.963815, latitude: 30.050663 }, { name: "", longitude: 102.258746, latitude: 27.886762 }, { name: "", longitude: 106.713478, latitude: 26.578343 }, { name: "", longitude: 104.846743, latitude: 26.584643 }, { name: "", longitude: 106.937265, latitude: 27.706626 }, { name: "", longitude: 105.932188, latitude: 26.245544 }, { name: "", longitude: 105.28501, latitude: 27.301693 }, { name: "", longitude: 109.191555, latitude: 27.718346 }, { name: "", longitude: 104.897971, latitude: 25.08812 }, { name: "", longitude: 107.977488, latitude: 26.583352 }, { name: "", longitude: 107.517156, latitude: 26.258219 }, { name: "", longitude: 102.712251, latitude: 25.040609 }, { name: "", longitude: 103.797851, latitude: 25.501557 }, { name: "", longitude: 102.543907, latitude: 24.350461 }, { name: "", longitude: 99.167133, latitude: 25.111802 }, { name: "", longitude: 103.717216, latitude: 27.336999 }, { name: "", longitude: 100.233026, latitude: 26.872108 }, { name: "", longitude: 100.972344, latitude: 22.777321 }, { name: "", longitude: 100.08697, latitude: 23.886567 }, { name: "", longitude: 101.546046, latitude: 25.041988 }, { name: "", longitude: 103.384182, latitude: 23.366775 }, { name: "", longitude: 104.24401, latitude: 23.36951 }, { name: "", longitude: 100.797941, latitude: 22.001724 }, { name: "", longitude: 100.225668, latitude: 25.589449 }, { name: "", longitude: 98.578363, latitude: 24.436694 }, { name: "", longitude: 98.854304, latitude: 25.850949 }, { name: "", longitude: 99.706463, latitude: 27.826853 }, { name: "", longitude: 91.132212, latitude: 29.660361 }, { name: "", longitude: 88.885148, latitude: 29.267519 }, { name: "", longitude: 97.178452, latitude: 31.136875 }, { name: "", longitude: 94.362348, latitude: 29.654693 }, { name: "", longitude: 91.766529, latitude: 29.236023 }, { name: "", longitude: 92.060214, latitude: 31.476004 }, { name: "", longitude: 80.105498, latitude: 32.503187 }, { name: "", longitude: 108.948024, latitude: 34.263161 }, { name: "", longitude: 108.979608, latitude: 34.916582 }, { name: "", longitude: 107.14487, latitude: 34.369315 }, { name: "", longitude: 108.705117, latitude: 34.333439 }, { name: "", longitude: 109.502882, latitude: 34.499381 }, { name: "", longitude: 109.49081, latitude: 36.596537 }, { name: "", longitude: 107.028621, latitude: 33.077668 }, { name: "", longitude: 109.741193, latitude: 38.290162 }, { name: "", longitude: 109.029273, latitude: 32.6903 }, { name: "", longitude: 109.939776, latitude: 33.868319 }, { name: "", longitude: 103.823557, latitude: 36.058039 }, { name: "", longitude: 98.277304, latitude: 39.786529 }, { name: "", longitude: 102.187888, latitude: 38.514238 }, { name: "", longitude: 104.173606, latitude: 36.54568 }, { name: "", longitude: 105.724998, latitude: 34.578529 }, { name: "", longitude: 102.634697, latitude: 37.929996 }, { name: "", longitude: 100.455472, latitude: 38.932897 }, { name: "", longitude: 106.684691, latitude: 35.54279 }, { name: "", longitude: 98.510795, latitude: 39.744023 }, { name: "", longitude: 107.638372, latitude: 35.734218 }, { name: "", longitude: 104.626294, latitude: 35.579578 }, { name: "", longitude: 104.929379, latitude: 33.388598 }, { name: "", longitude: 103.212006, latitude: 35.599446 }, { name: "", longitude: 102.911008, latitude: 34.986354 }, { name: "", longitude: 101.778916, latitude: 36.623178 }, { name: "", longitude: 102.10327, latitude: 36.502916 }, { name: "", longitude: 100.901059, latitude: 36.959435 }, { name: "", longitude: 102.019988, latitude: 35.517744 }, { name: "", longitude: 100.619542, latitude: 36.280353 }, { name: "", longitude: 100.242143, latitude: 34.4736 }, { name: "", longitude: 97.008522, latitude: 33.004049 }, { name: "", longitude: 97.370785, latitude: 37.374663 }, { name: "", longitude: 106.278179, latitude: 38.46637 }, { name: "", longitude: 106.376173, latitude: 39.01333 }, { name: "", longitude: 106.199409, latitude: 37.986165 }, { name: "", longitude: 106.285241, latitude: 36.004561 }, { name: "", longitude: 105.189568, latitude: 37.514951 }, { name: "", longitude: 87.617733, latitude: 43.792818 }, { name: "", longitude: 84.873946, latitude: 45.595886 }, { name: "", longitude: 89.184078, latitude: 42.947613 }, { name: "", longitude: 93.51316, latitude: 42.833248 }, { name: "", longitude: 87.304012, latitude: 44.014577 }, { name: "", longitude: 82.074778, latitude: 44.903258 }, { name: "", longitude: 86.150969, latitude: 41.768552 }, { name: "", longitude: 80.265068, latitude: 41.170712 }, { name: "", longitude: 76.172825, latitude: 39.713431 }, { name: "", longitude: 75.989138, latitude: 39.467664 }, { name: "", longitude: 79.92533, latitude: 37.110687 }, { name: "", longitude: 81.317946, latitude: 43.92186 }, { name: "", longitude: 82.985732, latitude: 46.746301 }, { name: "", longitude: 88.13963, latitude: 47.848393 }, { name: "", longitude: 86.041075, latitude: 44.305886 }, { name: "", longitude: 81.285884, latitude: 40.541914 }, { name: "", longitude: 79.077978, latitude: 39.867316 }, { name: "", longitude: 87.526884, latitude: 44.167401 }, { name: "", longitude: 87.824932, latitude: 47.353177 }, { name: "", longitude: 85.501218, latitude: 41.827251 }, { name: "", longitude: 82.353656, latitude: 44.840524 }, { name: "", longitude: 80.63579, latitude: 43.6832 }, { name: "", longitude: 79.287372, latitude: 37.207994 }, { name: "", longitude: 84.8275959, latitude: 44.69288853 }, { name: "", longitude: 121.509062, latitude: 25.044332 }, { name: "", longitude: 114.173355, latitude: 22.320048 }, { name: "", longitude: 114.173355, latitude: 22.320048 }, { name: "", longitude: 113.54909, latitude: 22.198951 }, { name: "", longitude: 113.54909, latitude: 22.198951 }], Qst = (n) => {
        const t = yC.findIndex((e) => e.name === n || e.name === `${n}` || Ost(e.name.split("")[0], { toneType: "none", type: "array" }).join("") === n.toLowerCase());
        return t > -1 ? [yC[t].longitude, yC[t].latitude] : false;
      };
      class zst {
        constructor(t) {
          Jt(this, "map");
          $ot();
          const e = { center: [108.5525, 34.3227], zoom: 5, constrainResolution: false, projection: "EPSG:4326" };
          let i = rt(rt({}, e), t.view);
          i != null && i.city && (i.center = Qst(i.city) || i.center || e.center);
          const r = new Qa(i);
          this.map = new qw({ target: t.target, view: r, controls: QF(rt({ zoom: false, rotate: false, attribution: false }, t.controls)), interactions: jF(rt({ doubleClickZoom: false }, t.interactions)) });
        }
      }
      const Nn = (n, t) => n && Object.prototype.hasOwnProperty.call(n, t) ? typeof n[t] == "object" ? Object.keys(n[t]).length > 0 : typeof n[t] == "boolean" ? n[t] : true : false, RO = (n) => {
        if (!n) return { center: [0, 0], coordinates: void 0, minRadius: 0, sqDistances: void 0, topCenter: [0, 0] };
        let t, e, i, r, a;
        ur(n.getExtent())[1] >= _l(n.getExtent())[1] ? a = ur(n.getExtent())[1] : a = _l(n.getExtent())[1], r = [(ur(n.getExtent())[0] + _l(n.getExtent())[0]) / 2, a];
        const s = n.getType();
        if (s === "Polygon") {
          let u = 0, h = 0, c = 0;
          e = n.getCoordinates()[0].slice(1), e.forEach(function(f) {
            u += f[0], h += f[1], c++;
          }), t = [u / c, h / c];
        } else s === "LineString" ? (t = n.getCoordinateAt(0.5), e = n.getCoordinates()) : s === "Circle" ? t = n.getCenter() : t = Nr(n.getExtent());
        let l;
        return e ? (l = e.map(function(u) {
          const h = u[0] - t[0], c = u[1] - t[1];
          return h * h + c * c;
        }), i = Math.sqrt(Math.max.apply(Math, l)) / 3) : i = Math.max(he(n.getExtent()), dn(n.getExtent())) / 3, { center: t, coordinates: e, minRadius: i, sqDistances: l, topCenter: r };
      }, LO = (n, t) => {
        n.getView().animate(t);
      }, Gst = Object.freeze(Object.defineProperty({ __proto__: null, calculateCenter: RO, flyTo: (n, t) => {
        const e = t.duration || 2e3, i = n.getView(), r = t.zoom || i.getZoom() || 0;
        let a = 2, o = false;
        function s() {
          --a, !o && a === 0 && (o = true);
        }
        i.animate({ center: t.center, duration: e }, s), i.animate({ zoom: t.flyZoom || r - 1, duration: e / 2 }, { zoom: r, duration: e / 2 }, s);
      }, panTo: LO, validObjKey: Nn }, Symbol.toStringTag, { value: "Module" })), Ust = ["id"], mC = P.defineComponent({ name: "OlMap", __name: "index", props: { width: { default: "100%" }, height: { default: "100%" }, controls: {}, interactions: {}, view: {}, pixelRatio: {}, keyboardEventTarget: {}, layers: {}, maxTilesLoading: {}, moveTolerance: {}, overlays: {}, target: { default: "map" } }, emits: ["load", "changeZoom", "singleclick", "click", "dblclick", "pointerdrag", "contextmenu", "precompose", "postrender", "loadend", "loadstart", "moveend", "movestart"], setup(n, { expose: t, emit: e }) {
        const r = P.inject("ConfigProvide") || P.inject("$OlMapConfig"), a = n, o = P.computed(() => typeof a.target == "string" ? a.target : a.target.id), s = P.ref(false);
        let l = P.shallowRef();
        const u = P.computed(() => typeof a.width == "number" ? `${a.width}px` : a.width), h = P.computed(() => typeof a.height == "number" ? `${a.height}px` : a.height), c = ["singleclick", "click", "dblclick", "pointerdrag", "contextmenu", "precompose", "postrender", "loadend", "loadstart", "moveend", "movestart"], f = e, g = () => new Promise((x, w) => {
          var B, R, M;
          const C = rt({}, (B = r.map) == null ? void 0 : B.view), S = rt({}, (R = r.map) == null ? void 0 : R.controls), b = rt({}, (M = r.map) == null ? void 0 : M.interactions);
          let T = rt({}, a);
          C && Object.keys(C).length > 0 && (!T.view || Object.keys(T.view).length <= 0) && (T.view = C), S && Object.keys(S).length > 0 && (!T.controls || Object.keys(T.controls).length <= 0) && (T.controls = S), b && Object.keys(b).length > 0 && (!T.interactions || Object.keys(T.interactions).length <= 0) && (T.interactions = b), l.value = new zst(rt({}, T)), l.value.map ? (x("success"), s.value = true, f("load")) : w(new Error("fail"));
        });
        let d = P.ref(""), A = P.ref("");
        const p = (x) => {
          A.value = x;
        }, v = () => {
          var x, w;
          (x = l.value) == null || x.map.on("pointermove", (C) => {
            var b, T, B, R;
            if (A.value) {
              d.value = A.value;
              return;
            }
            if (C.dragging) {
              d.value = "";
              return;
            }
            const S = (b = l.value) == null ? void 0 : b.map.getEventPixel(C.originalEvent);
            if (S) {
              const M = (T = l.value) == null ? void 0 : T.map.hasFeatureAtPixel(S);
              ((R = (B = l.value) == null ? void 0 : B.map) == null ? void 0 : R.getTargetElement()) && (d.value = M ? "pointer" : "");
            }
          }), (w = l.value) == null || w.map.getView().once("change:resolution", () => {
            var C;
            (C = l.value) == null || C.map.once("moveend", (S) => {
              y(S);
            });
          }), c.forEach((C) => {
            var S;
            (S = l.value) == null || S.map.on(C, (b) => {
              var T;
              f(C, b, (T = l.value) == null ? void 0 : T.map);
            });
          });
        }, y = (x) => {
          var C, S, b;
          const w = Qt(rt({}, x), { zoom: (C = l.value) == null ? void 0 : C.map.getView().getZoom() });
          f("changeZoom", w, (S = l.value) == null ? void 0 : S.map), (b = l.value) == null || b.map.once("moveend", (T) => {
            y(T);
          });
        }, m = () => {
          c.forEach((x) => {
            yl(x);
          });
        }, _ = (x) => {
          var C;
          const w = (C = l.value) == null ? void 0 : C.map.getLayers().getArray();
          return w == null ? void 0 : w.find((S) => S.get("id") === x);
        }, I = () => {
          var x;
          return (x = l.value) == null ? void 0 : x.map;
        }, E = (x) => {
          var w, C;
          (w = l.value) != null && w.map && LO((C = l.value) == null ? void 0 : C.map, x);
        };
        return P.onMounted(() => {
          g().then(() => {
            v();
          });
        }), P.onBeforeUnmount(() => {
          m();
        }), t({ map: () => {
          var x;
          return (x = l.value) == null ? void 0 : x.map;
        }, getMap: I, getLayerById: _, panTo: E, setCursor: p }), P.provide("VMap", l), (x, w) => (P.openBlock(), P.createElementBlock("div", { id: o.value, style: P.normalizeStyle({ width: u.value, height: h.value, cursor: P.unref(d) }) }, [s.value ? P.renderSlot(x.$slots, "default", { key: 0 }) : P.createCommentVNode("", true)], 12, Ust));
      } }), Vst = (n) => n.component(mC.name || "OlMap", mC), T0 = { PRELOAD: "preload", USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError" };
      class PO extends Zu {
        constructor(t) {
          t = t || {};
          const e = Object.assign({}, t), i = t.cacheSize;
          delete t.cacheSize, delete e.preload, delete e.useInterimTilesOnError, super(e), this.on, this.once, this.un, this.cacheSize_ = i, this.setPreload(t.preload !== void 0 ? t.preload : 0), this.setUseInterimTilesOnError(t.useInterimTilesOnError !== void 0 ? t.useInterimTilesOnError : true);
        }
        getCacheSize() {
          return this.cacheSize_;
        }
        getPreload() {
          return this.get(T0.PRELOAD);
        }
        setPreload(t) {
          this.set(T0.PRELOAD, t);
        }
        getUseInterimTilesOnError() {
          return this.get(T0.USE_INTERIM_TILES_ON_ERROR);
        }
        setUseInterimTilesOnError(t) {
          this.set(T0.USE_INTERIM_TILES_ON_ERROR, t);
        }
        getData(t) {
          return super.getData(t);
        }
      }
      function Qf(n) {
        return n instanceof Image || n instanceof HTMLCanvasElement || n instanceof HTMLVideoElement || n instanceof ImageBitmap ? n : null;
      }
      function _C(n) {
        return n instanceof Uint8Array || n instanceof Uint8ClampedArray || n instanceof Float32Array || n instanceof DataView ? n : null;
      }
      const jst = new Error("disposed");
      let zf = null;
      function qst(n) {
        zf || (zf = In(n.width, n.height, void 0, { willReadFrequently: true }));
        const t = zf.canvas, e = n.width;
        t.width !== e && (t.width = e);
        const i = n.height;
        return t.height !== i && (t.height = i), zf.clearRect(0, 0, e, i), zf.drawImage(n, 0, 0), zf.getImageData(0, 0, e, i).data;
      }
      const Hst = [256, 256];
      class ep extends kw {
        constructor(t) {
          const e = At.IDLE;
          super(t.tileCoord, e, { transition: t.transition, interpolate: t.interpolate }), this.loader_ = t.loader, this.data_ = null, this.error_ = null, this.size_ = t.size || null, this.controller_ = t.controller || null;
        }
        getSize() {
          if (this.size_) return this.size_;
          const t = Qf(this.data_);
          return t ? [t.width, t.height] : Hst;
        }
        getData() {
          return this.data_;
        }
        getError() {
          return this.error_;
        }
        load() {
          if (this.state !== At.IDLE && this.state !== At.ERROR) return;
          this.state = At.LOADING, this.changed();
          const t = this;
          this.loader_().then(function(e) {
            t.data_ = e, t.state = At.LOADED, t.changed();
          }).catch(function(e) {
            t.error_ = e, t.state = At.ERROR, t.changed();
          });
        }
        disposeInternal() {
          this.controller_ && (this.controller_.abort(jst), this.controller_ = null), super.disposeInternal();
        }
      }
      const EC = 0.5, Yst = 10, NO = 0.25;
      class IC {
        constructor(t, e, i, r, a, o, s) {
          this.sourceProj_ = t, this.targetProj_ = e;
          let l = {};
          const u = s ? Im((m) => nn(s, po(m, this.targetProj_, this.sourceProj_))) : rf(this.targetProj_, this.sourceProj_);
          this.transformInv_ = function(m) {
            const _ = m[0] + "/" + m[1];
            return l[_] || (l[_] = u(m)), l[_];
          }, this.maxSourceExtent_ = r, this.errorThresholdSquared_ = a * a, this.triangles_ = [], this.wrapsXInSource_ = false, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!r && !!this.sourceProj_.getExtent() && he(r) >= he(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? he(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? he(this.targetProj_.getExtent()) : null;
          const h = ur(i), c = _l(i), f = Xc(i), g = Wc(i), d = this.transformInv_(h), A = this.transformInv_(c), p = this.transformInv_(f), v = this.transformInv_(g), y = Yst + (o ? Math.max(0, Math.ceil(Math.log2(eA(i) / (o * o * 256 * 256)))) : 0);
          if (this.addQuad_(h, c, f, g, d, A, p, v, y), this.wrapsXInSource_) {
            let m = 1 / 0;
            this.triangles_.forEach(function(_, I, E) {
              m = Math.min(m, _.source[0][0], _.source[1][0], _.source[2][0]);
            }), this.triangles_.forEach((_) => {
              if (Math.max(_.source[0][0], _.source[1][0], _.source[2][0]) - m > this.sourceWorldWidth_ / 2) {
                const I = [[_.source[0][0], _.source[0][1]], [_.source[1][0], _.source[1][1]], [_.source[2][0], _.source[2][1]]];
                I[0][0] - m > this.sourceWorldWidth_ / 2 && (I[0][0] -= this.sourceWorldWidth_), I[1][0] - m > this.sourceWorldWidth_ / 2 && (I[1][0] -= this.sourceWorldWidth_), I[2][0] - m > this.sourceWorldWidth_ / 2 && (I[2][0] -= this.sourceWorldWidth_);
                const E = Math.min(I[0][0], I[1][0], I[2][0]);
                Math.max(I[0][0], I[1][0], I[2][0]) - E < this.sourceWorldWidth_ / 2 && (_.source = I);
              }
            });
          }
          l = {};
        }
        addTriangle_(t, e, i, r, a, o) {
          this.triangles_.push({ source: [r, a, o], target: [t, e, i] });
        }
        addQuad_(t, e, i, r, a, o, s, l, u) {
          const h = Mn([a, o, s, l]), c = this.sourceWorldWidth_ ? he(h) / this.sourceWorldWidth_ : null, f = this.sourceWorldWidth_, g = this.sourceProj_.canWrapX() && c > 0.5 && c < 1;
          let d = false;
          if (u > 0) {
            if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
              const p = Mn([t, e, i, r]);
              d = he(p) / this.targetWorldWidth_ > NO || d;
            }
            !g && this.sourceProj_.isGlobal() && c && (d = c > NO || d);
          }
          if (!d && this.maxSourceExtent_ && isFinite(h[0]) && isFinite(h[1]) && isFinite(h[2]) && isFinite(h[3]) && !Ai(h, this.maxSourceExtent_)) return;
          let A = 0;
          if (!d && (!isFinite(a[0]) || !isFinite(a[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(s[0]) || !isFinite(s[1]) || !isFinite(l[0]) || !isFinite(l[1]))) {
            if (u > 0) d = true;
            else if (A = (!isFinite(a[0]) || !isFinite(a[1]) ? 8 : 0) + (!isFinite(o[0]) || !isFinite(o[1]) ? 4 : 0) + (!isFinite(s[0]) || !isFinite(s[1]) ? 2 : 0) + (!isFinite(l[0]) || !isFinite(l[1]) ? 1 : 0), A != 1 && A != 2 && A != 4 && A != 8) return;
          }
          if (u > 0) {
            if (!d) {
              const p = [(t[0] + i[0]) / 2, (t[1] + i[1]) / 2], v = this.transformInv_(p);
              let y;
              g ? y = (ys(a[0], f) + ys(s[0], f)) / 2 - ys(v[0], f) : y = (a[0] + s[0]) / 2 - v[0];
              const m = (a[1] + s[1]) / 2 - v[1];
              d = y * y + m * m > this.errorThresholdSquared_;
            }
            if (d) {
              if (Math.abs(t[0] - i[0]) <= Math.abs(t[1] - i[1])) {
                const p = [(e[0] + i[0]) / 2, (e[1] + i[1]) / 2], v = this.transformInv_(p), y = [(r[0] + t[0]) / 2, (r[1] + t[1]) / 2], m = this.transformInv_(y);
                this.addQuad_(t, e, p, y, a, o, v, m, u - 1), this.addQuad_(y, p, i, r, m, v, s, l, u - 1);
              } else {
                const p = [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2], v = this.transformInv_(p), y = [(i[0] + r[0]) / 2, (i[1] + r[1]) / 2], m = this.transformInv_(y);
                this.addQuad_(t, p, y, r, a, v, m, l, u - 1), this.addQuad_(p, e, i, y, v, o, s, m, u - 1);
              }
              return;
            }
          }
          if (g) {
            if (!this.canWrapXInSource_) return;
            this.wrapsXInSource_ = true;
          }
          A & 11 || this.addTriangle_(t, i, r, a, s, l), A & 14 || this.addTriangle_(t, i, e, a, s, o), A && (A & 13 || this.addTriangle_(e, r, t, o, l, a), A & 7 || this.addTriangle_(e, r, i, o, l, s));
        }
        calculateSourceExtent() {
          const t = ai();
          return this.triangles_.forEach(function(e, i, r) {
            const a = e.source;
            tA(t, a[0]), tA(t, a[1]), tA(t, a[2]);
          }), t;
        }
        getTriangles() {
          return this.triangles_;
        }
      }
      let xC;
      const Gf = [];
      function FO(n, t, e, i, r) {
        n.beginPath(), n.moveTo(0, 0), n.lineTo(t, e), n.lineTo(i, r), n.closePath(), n.save(), n.clip(), n.fillRect(0, 0, Math.max(t, i) + 1, Math.max(e, r)), n.restore();
      }
      function wC(n, t) {
        return Math.abs(n[t * 4] - 210) > 2 || Math.abs(n[t * 4 + 3] - 0.75 * 255) > 2;
      }
      function Wst() {
        if (xC === void 0) {
          const n = In(6, 6, Gf);
          n.globalCompositeOperation = "lighter", n.fillStyle = "rgba(210, 0, 0, 0.75)", FO(n, 4, 5, 4, 0), FO(n, 4, 5, 0, 5);
          const t = n.getImageData(0, 0, 3, 3).data;
          xC = wC(t, 0) || wC(t, 4) || wC(t, 8), Mm(n), Gf.push(n.canvas);
        }
        return xC;
      }
      function np(n, t, e, i) {
        const r = po(e, t, n);
        let a = Em(t, i, e);
        const o = t.getMetersPerUnit();
        o !== void 0 && (a *= o);
        const s = n.getMetersPerUnit();
        s !== void 0 && (a /= s);
        const l = n.getExtent();
        if (!l || Jr(l, r)) {
          const u = Em(n, a, r) / a;
          isFinite(u) && u > 0 && (a /= u);
        }
        return a;
      }
      function kO(n, t, e, i) {
        const r = Nr(e);
        let a = np(n, t, r, i);
        return (!isFinite(a) || a <= 0) && Tx(e, function(o) {
          return a = np(n, t, o, i), isFinite(a) && a > 0;
        }), a;
      }
      function OO(n, t, e, i, r, a, o, s, l, u, h, c, f, g) {
        const d = In(Math.round(e * n), Math.round(e * t), Gf);
        if (c || (d.imageSmoothingEnabled = false), l.length === 0) return d.canvas;
        d.scale(e, e);
        function A(I) {
          return Math.round(I * e) / e;
        }
        d.globalCompositeOperation = "lighter";
        const p = ai();
        l.forEach(function(I, E, x) {
          bx(p, I.extent);
        });
        let v;
        const y = e / i, m = (c ? 1 : 1 + Math.pow(2, -24)) / y;
        if (!f || l.length !== 1 || u !== 0) {
          if (v = In(Math.round(he(p) * y), Math.round(dn(p) * y), Gf), c || (v.imageSmoothingEnabled = false), r && g) {
            const I = (r[0] - p[0]) * y, E = -(r[3] - p[3]) * y, x = he(r) * y, w = dn(r) * y;
            v.rect(I, E, x, w), v.clip();
          }
          l.forEach(function(I, E, x) {
            if (I.image.width > 0 && I.image.height > 0) {
              if (I.clipExtent) {
                v.save();
                const T = (I.clipExtent[0] - p[0]) * y, B = -(I.clipExtent[3] - p[3]) * y, R = he(I.clipExtent) * y, M = dn(I.clipExtent) * y;
                v.rect(c ? T : Math.round(T), c ? B : Math.round(B), c ? R : Math.round(T + R) - Math.round(T), c ? M : Math.round(B + M) - Math.round(B)), v.clip();
              }
              const w = (I.extent[0] - p[0]) * y, C = -(I.extent[3] - p[3]) * y, S = he(I.extent) * y, b = dn(I.extent) * y;
              v.drawImage(I.image, u, u, I.image.width - 2 * u, I.image.height - 2 * u, c ? w : Math.round(w), c ? C : Math.round(C), c ? S : Math.round(w + S) - Math.round(w), c ? b : Math.round(C + b) - Math.round(C)), I.clipExtent && v.restore();
            }
          });
        }
        const _ = ur(o);
        return s.getTriangles().forEach(function(I, E, x) {
          const w = I.source, C = I.target;
          let S = w[0][0], b = w[0][1], T = w[1][0], B = w[1][1], R = w[2][0], M = w[2][1];
          const L = A((C[0][0] - _[0]) / a), N = A(-(C[0][1] - _[1]) / a), F = A((C[1][0] - _[0]) / a), k = A(-(C[1][1] - _[1]) / a), O = A((C[2][0] - _[0]) / a), Q = A(-(C[2][1] - _[1]) / a), j = S, Y = b;
          S = 0, b = 0, T -= j, B -= Y, R -= j, M -= Y;
          const G = [[T, B, 0, 0, F - L], [R, M, 0, 0, O - L], [0, 0, T, B, k - N], [0, 0, R, M, Q - N]], $ = KZ(G);
          if (!$) return;
          if (d.save(), d.beginPath(), Wst() || !c) {
            d.moveTo(F, k);
            const et = 4, nt = L - F, gt = N - k;
            for (let q = 0; q < et; q++) d.lineTo(F + A((q + 1) * nt / et), k + A(q * gt / (et - 1))), q != et - 1 && d.lineTo(F + A((q + 1) * nt / et), k + A((q + 1) * gt / (et - 1)));
            d.lineTo(O, Q);
          } else d.moveTo(F, k), d.lineTo(L, N), d.lineTo(O, Q);
          d.clip(), d.transform($[0], $[2], $[1], $[3], L, N), d.translate(p[0] - j, p[3] - Y);
          let J;
          if (v) J = v.canvas, d.scale(m, -m);
          else {
            const et = l[0], nt = et.extent;
            J = et.image, d.scale(he(nt) / J.width, -dn(nt) / J.height);
          }
          d.drawImage(J, 0, 0), d.restore();
        }), v && (Mm(v), Gf.push(v.canvas)), h && (d.save(), d.globalCompositeOperation = "source-over", d.strokeStyle = "black", d.lineWidth = 1, s.getTriangles().forEach(function(I, E, x) {
          const w = I.target, C = (w[0][0] - _[0]) / a, S = -(w[0][1] - _[1]) / a, b = (w[1][0] - _[0]) / a, T = -(w[1][1] - _[1]) / a, B = (w[2][0] - _[0]) / a, R = -(w[2][1] - _[1]) / a;
          d.beginPath(), d.moveTo(b, T), d.lineTo(C, S), d.lineTo(B, R), d.closePath(), d.stroke();
        }), d.restore()), d.canvas;
      }
      function ih() {
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }
      function B0(n, t) {
        return n[0] = t[0], n[1] = t[1], n[4] = t[2], n[5] = t[3], n[12] = t[4], n[13] = t[5], n;
      }
      function CC(n, t, e, i, r, a, o) {
        o = o != null ? o : ih();
        const s = 1 / (n - t), l = 1 / (e - i), u = 1 / (r - a);
        return o[0] = -2 * s, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * l, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * u, o[11] = 0, o[12] = (n + t) * s, o[13] = (i + e) * l, o[14] = (a + r) * u, o[15] = 1, o;
      }
      function QO(n, t, e, i, r) {
        return r = r != null ? r : ih(), r[0] = n[0] * t, r[1] = n[1] * t, r[2] = n[2] * t, r[3] = n[3] * t, r[4] = n[4] * e, r[5] = n[5] * e, r[6] = n[6] * e, r[7] = n[7] * e, r[8] = n[8] * i, r[9] = n[9] * i, r[10] = n[10] * i, r[11] = n[11] * i, r[12] = n[12], r[13] = n[13], r[14] = n[14], r[15] = n[15], r;
      }
      function Xst(n, t, e, i, r) {
        r = r != null ? r : ih();
        let a, o, s, l, u, h, c, f, g, d, A, p;
        return n === r ? (r[12] = n[0] * t + n[4] * e + n[8] * i + n[12], r[13] = n[1] * t + n[5] * e + n[9] * i + n[13], r[14] = n[2] * t + n[6] * e + n[10] * i + n[14], r[15] = n[3] * t + n[7] * e + n[11] * i + n[15]) : (a = n[0], o = n[1], s = n[2], l = n[3], u = n[4], h = n[5], c = n[6], f = n[7], g = n[8], d = n[9], A = n[10], p = n[11], r[0] = a, r[1] = o, r[2] = s, r[3] = l, r[4] = u, r[5] = h, r[6] = c, r[7] = f, r[8] = g, r[9] = d, r[10] = A, r[11] = p, r[12] = a * t + u * e + g * i + n[12], r[13] = o * t + h * e + d * i + n[13], r[14] = s * t + c * e + A * i + n[14], r[15] = l * t + f * e + p * i + n[15]), r;
      }
      function $st(n, t, e, i) {
        return i = i != null ? i : ih(), i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = n, i[13] = t, i[14] = e, i[15] = 1, i;
      }
      const Zst = `
  attribute vec4 a_position;
  attribute vec4 a_texcoord;

  uniform mat4 u_matrix;
  uniform mat4 u_textureMatrix;

  varying vec2 v_texcoord;

  void main() {
    gl_Position = u_matrix * a_position;
    vec2 texcoord = (u_textureMatrix * a_texcoord).xy;
    v_texcoord = texcoord;
  }
`, Kst = `
  precision mediump float;

  varying vec2 v_texcoord;

  uniform sampler2D u_texture;

  void main() {
    if (
      v_texcoord.x < 0.0 ||
      v_texcoord.y < 0.0 ||
      v_texcoord.x > 1.0 ||
      v_texcoord.y > 1.0
    ) {
      discard;
    }
    gl_FragColor = texture2D(u_texture, v_texcoord);
  }
`;
      class Jst {
        constructor(t) {
          this.gl_ = t, this.program_ = SC(t, Kst, Zst), this.positionLocation = t.getAttribLocation(this.program_, "a_position"), this.texcoordLocation = t.getAttribLocation(this.program_, "a_texcoord"), this.matrixLocation = t.getUniformLocation(this.program_, "u_matrix"), this.textureMatrixLocation = t.getUniformLocation(this.program_, "u_textureMatrix"), this.textureLocation = t.getUniformLocation(this.program_, "u_texture"), this.positionBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this.positionBuffer), this.positions = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], t.bufferData(t.ARRAY_BUFFER, new Float32Array(this.positions), t.STATIC_DRAW), this.texcoordBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this.texcoordBuffer), this.texcoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], t.bufferData(t.ARRAY_BUFFER, new Float32Array(this.texcoords), t.STATIC_DRAW);
        }
        drawImage(t, e, i, r, a, o, s, l, u, h, c, f, g) {
          const d = this.gl_;
          l === void 0 && (l = r), u === void 0 && (u = a), o === void 0 && (o = e), s === void 0 && (s = i), h === void 0 && (h = o), c === void 0 && (c = s), f === void 0 && (f = d.canvas.width), g === void 0 && (g = d.canvas.height), d.bindTexture(d.TEXTURE_2D, t), d.useProgram(this.program_), d.bindBuffer(d.ARRAY_BUFFER, this.positionBuffer), d.enableVertexAttribArray(this.positionLocation), d.vertexAttribPointer(this.positionLocation, 2, d.FLOAT, false, 0, 0), d.bindBuffer(d.ARRAY_BUFFER, this.texcoordBuffer), d.enableVertexAttribArray(this.texcoordLocation), d.vertexAttribPointer(this.texcoordLocation, 2, d.FLOAT, false, 0, 0);
          let A = CC(0, f, 0, g, -1, 1);
          A = Xst(A, l, u, 0), A = QO(A, h, c, 1), d.uniformMatrix4fv(this.matrixLocation, false, A);
          let p = $st(r / e, a / i, 0);
          p = QO(p, o / e, s / i, 1), d.uniformMatrix4fv(this.textureMatrixLocation, false, p), d.uniform1i(this.textureLocation, 0), d.drawArrays(d.TRIANGLES, 0, this.positions.length / 2);
        }
      }
      function zO(n, t, e) {
        const i = n.createShader(t);
        if (i === null) throw new Error("Shader compilation failed");
        if (n.shaderSource(i, e), n.compileShader(i), !n.getShaderParameter(i, n.COMPILE_STATUS)) {
          const r = n.getShaderInfoLog(i);
          throw r === null ? new Error("Shader info log creation failed") : new Error(r);
        }
        return i;
      }
      function SC(n, t, e) {
        const i = n.createProgram(), r = zO(n, n.VERTEX_SHADER, e), a = zO(n, n.FRAGMENT_SHADER, t);
        if (i === null) throw new Error("Program creation failed");
        if (n.attachShader(i, r), n.attachShader(i, a), n.linkProgram(i), !n.getProgramParameter(i, n.LINK_STATUS)) throw n.getProgramInfoLog(i) === null ? new Error("Program info log creation failed") : new Error();
        return i;
      }
      const tlt = `
  attribute vec4 a_position;

  uniform mat4 u_matrix;

  void main() {
     gl_Position = u_matrix * a_position;
  }
`, elt = `
  precision mediump float;

  uniform vec4 u_val;
  void main() {
     gl_FragColor = u_val;
  }
`, nlt = `
  attribute vec4 a_position;
  attribute vec2 a_texcoord;

  varying vec2 v_texcoord;

  uniform mat4 u_matrix;

  void main() {
     gl_Position = u_matrix * a_position;
     v_texcoord = a_texcoord;
  }
`, ilt = `
  precision mediump float;

  varying vec2 v_texcoord;

  uniform sampler2D u_texture;

  void main() {
    if (v_texcoord.x < 0.0 || v_texcoord.x > 1.0 || v_texcoord.y < 0.0 || v_texcoord.y > 1.0) {
      discard;
    }
    gl_FragColor = texture2D(u_texture, v_texcoord);
  }
`;
      function rlt(n, t, e, i) {
        let r;
        return e && e.length ? r = e.shift() : uw ? r = new OffscreenCanvas(n || 300, t || 300) : r = document.createElement("canvas"), n && (r.width = n), t && (r.height = t), r.getContext("webgl", i);
      }
      function alt(n) {
        const t = n.canvas;
        t.width = 1, t.height = 1, n.clear(n.COLOR_BUFFER_BIT | n.DEPTH_BUFFER_BIT | n.STENCIL_BUFFER_BIT);
      }
      const GO = [];
      function olt(n, t, e, i, r, a, o, s, l, u, h, c, f, g) {
        const d = Math.round(i * t), A = Math.round(i * e);
        n.canvas.width = d, n.canvas.height = A;
        let p, v;
        if (v = n.createTexture(), n.bindTexture(n.TEXTURE_2D, v), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), f ? (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR)) : (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST)), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, d, A, 0, n.RGBA, h, null), p = n.createFramebuffer(), n.bindFramebuffer(n.FRAMEBUFFER, p), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, v, 0), p === null) throw new Error("Could not create framebuffer");
        if (v === null) throw new Error("Could not create texture");
        if (l.length === 0) return { width: d, height: A, framebuffer: p, texture: v };
        const y = ai();
        l.forEach(function(S, b, T) {
          bx(y, S.extent);
        });
        let m, _, I;
        const E = 1 / r;
        {
          if (m = n.createTexture(), v === null) throw new Error("Could not create texture");
          _ = Math.round(he(y) * E), I = Math.round(dn(y) * E);
          const S = n.getParameter(n.MAX_TEXTURE_SIZE), b = Math.max(_, I), T = b > S ? S / b : 1, B = Math.round(_ * T), R = Math.round(I * T);
          n.bindTexture(n.TEXTURE_2D, m), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), f ? (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR)) : (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST)), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, B, R, 0, n.RGBA, h, null);
          const M = n.createFramebuffer();
          n.bindFramebuffer(n.FRAMEBUFFER, M), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, m, 0);
          const L = new Jst(n);
          l.forEach(function(N, F, k) {
            const O = (N.extent[0] - y[0]) * E * T, Q = -(N.extent[3] - y[3]) * E * T, j = he(N.extent) * E * T, Y = dn(N.extent) * E * T;
            if (n.bindFramebuffer(n.FRAMEBUFFER, M), n.viewport(0, 0, B, R), N.clipExtent) {
              const G = (N.clipExtent[0] - y[0]) * E * T, $ = -(N.clipExtent[3] - y[3]) * E * T, J = he(N.clipExtent) * E * T, et = dn(N.clipExtent) * E * T;
              n.enable(n.SCISSOR_TEST), n.scissor(f ? G : Math.round(G), f ? $ : Math.round($), f ? J : Math.round(G + J) - Math.round(G), f ? et : Math.round($ + et) - Math.round($));
            }
            L.drawImage(N.texture, N.width, N.height, u, u, N.width - 2 * u, N.height - 2 * u, f ? O : Math.round(O), f ? Q : Math.round(Q), f ? j : Math.round(O + j) - Math.round(O), f ? Y : Math.round(Q + Y) - Math.round(Q), B, R), n.disable(n.SCISSOR_TEST);
          }), n.deleteFramebuffer(M);
        }
        const x = ur(o), w = ur(y), C = (S) => {
          const b = (S[0][0] - x[0]) / a * i, T = -(S[0][1] - x[1]) / a * i, B = (S[1][0] - x[0]) / a * i, R = -(S[1][1] - x[1]) / a * i, M = (S[2][0] - x[0]) / a * i, L = -(S[2][1] - x[1]) / a * i;
          return { u1: B, v1: R, u0: b, v0: T, u2: M, v2: L };
        };
        n.bindFramebuffer(n.FRAMEBUFFER, p), n.viewport(0, 0, d, A);
        {
          const S = [], b = [], T = SC(n, ilt, nlt);
          n.useProgram(T);
          const B = n.getUniformLocation(T, "u_texture");
          n.bindTexture(n.TEXTURE_2D, m), n.uniform1i(B, 0), s.getTriangles().forEach(function(O, Q, j) {
            const Y = O.source, G = O.target, { u1: $, v1: J, u0: et, v0: nt, u2: gt, v2: q } = C(G), W = (Y[0][0] - w[0]) / r / _, it = -(Y[0][1] - w[1]) / r / I, Ot = (Y[1][0] - w[0]) / r / _, pt = -(Y[1][1] - w[1]) / r / I, St = (Y[2][0] - w[0]) / r / _, bt = -(Y[2][1] - w[1]) / r / I;
            S.push($, J, et, nt, gt, q), b.push(Ot, pt, W, it, St, bt);
          });
          const R = CC(0, d, A, 0, -1, 1), M = n.getUniformLocation(T, "u_matrix");
          n.uniformMatrix4fv(M, false, R);
          const L = n.getAttribLocation(T, "a_position"), N = n.createBuffer();
          n.bindBuffer(n.ARRAY_BUFFER, N), n.bufferData(n.ARRAY_BUFFER, new Float32Array(S), n.STATIC_DRAW), n.vertexAttribPointer(L, 2, n.FLOAT, false, 0, 0), n.enableVertexAttribArray(L);
          const F = n.getAttribLocation(T, "a_texcoord"), k = n.createBuffer();
          n.bindBuffer(n.ARRAY_BUFFER, k), n.bufferData(n.ARRAY_BUFFER, new Float32Array(b), n.STATIC_DRAW), n.vertexAttribPointer(F, 2, n.FLOAT, false, 0, 0), n.enableVertexAttribArray(F), n.drawArrays(n.TRIANGLES, 0, S.length / 2);
        }
        if (c) {
          const S = SC(n, elt, tlt);
          n.useProgram(S);
          const b = CC(0, d, A, 0, -1, 1), T = n.getUniformLocation(S, "u_matrix");
          n.uniformMatrix4fv(T, false, b);
          const B = Array.isArray(c) ? c : [0, 0, 0, 255], R = n.getUniformLocation(S, "u_val");
          n.uniform4fv(R, B);
          const M = n.getAttribLocation(S, "a_position"), L = n.createBuffer();
          n.bindBuffer(n.ARRAY_BUFFER, L), n.vertexAttribPointer(M, 2, n.FLOAT, false, 0, 0), n.enableVertexAttribArray(M);
          const N = s.getTriangles().reduce(function(F, k) {
            const O = k.target, { u1: Q, v1: j, u0: Y, v0: G, u2: $, v2: J } = C(O);
            return F.concat([Q, j, Y, G, Y, G, $, J, $, J, Q, j]);
          }, []);
          n.bufferData(n.ARRAY_BUFFER, new Float32Array(N), n.STATIC_DRAW), n.drawArrays(n.LINES, 0, N.length / 2);
        }
        return { width: d, height: A, framebuffer: p, texture: v };
      }
      class M0 extends ep {
        constructor(t) {
          super({ tileCoord: t.tileCoord, loader: () => Promise.resolve(new Uint8ClampedArray(4)), interpolate: t.interpolate, transition: t.transition }), this.renderEdges_ = t.renderEdges !== void 0 ? t.renderEdges : false, this.pixelRatio_ = t.pixelRatio, this.gutter_ = t.gutter, this.reprojData_ = null, this.reprojError_ = null, this.reprojSize_ = void 0, this.sourceTileGrid_ = t.sourceTileGrid, this.targetTileGrid_ = t.targetTileGrid, this.wrappedTileCoord_ = t.wrappedTileCoord || t.tileCoord, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0;
          const e = t.sourceProj, i = e.getExtent(), r = t.sourceTileGrid.getExtent();
          this.clipExtent_ = e.canWrapX() ? r ? oi(i, r) : i : r;
          const a = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_), o = this.targetTileGrid_.getExtent();
          let s = this.sourceTileGrid_.getExtent();
          const l = o ? oi(a, o) : a;
          if (eA(l) === 0) {
            this.state = At.EMPTY;
            return;
          }
          i && (s ? s = oi(s, i) : s = i);
          const u = this.targetTileGrid_.getResolution(this.wrappedTileCoord_[0]), h = t.targetProj, c = kO(e, h, l, u);
          if (!isFinite(c) || c <= 0) {
            this.state = At.EMPTY;
            return;
          }
          const f = t.errorThreshold !== void 0 ? t.errorThreshold : EC;
          if (this.triangulation_ = new IC(e, h, l, s, c * f, u, t.transformMatrix), this.triangulation_.getTriangles().length === 0) {
            this.state = At.EMPTY;
            return;
          }
          this.sourceZ_ = this.sourceTileGrid_.getZForResolution(c);
          let g = this.triangulation_.calculateSourceExtent();
          if (s && (e.canWrapX() ? (g[1] = Ze(g[1], s[1], s[3]), g[3] = Ze(g[3], s[1], s[3])) : g = oi(g, s)), !eA(g)) this.state = At.EMPTY;
          else {
            let d = 0, A = 0;
            e.canWrapX() && (d = he(i), A = Math.floor((g[0] - i[0]) / d)), Bx(g.slice(), e, true).forEach((v) => {
              const y = this.sourceTileGrid_.getTileRangeForExtentAndZ(v, this.sourceZ_), m = t.getTileFunction;
              for (let _ = y.minX; _ <= y.maxX; _++) for (let I = y.minY; I <= y.maxY; I++) {
                const E = m(this.sourceZ_, _, I, this.pixelRatio_);
                if (E) {
                  const x = A * d;
                  this.sourceTiles_.push({ tile: E, offset: x });
                }
              }
              ++A;
            }), this.sourceTiles_.length === 0 && (this.state = At.EMPTY);
          }
        }
        getSize() {
          return this.reprojSize_;
        }
        getData() {
          return this.reprojData_;
        }
        getError() {
          return this.reprojError_;
        }
        reproject_() {
          const t = [];
          let e = false;
          if (this.sourceTiles_.forEach((_) => {
            var Q;
            const I = _.tile;
            if (!I || I.getState() !== At.LOADED) return;
            const E = I.getSize(), x = this.gutter_;
            let w;
            const C = _C(I.getData());
            C ? w = C : (e = true, w = qst(Qf(I.getData())));
            const S = [E[0] + 2 * x, E[1] + 2 * x], b = w instanceof Float32Array, T = S[0] * S[1], B = b ? Float32Array : Uint8ClampedArray, R = new B(w.buffer), M = B.BYTES_PER_ELEMENT, L = M * R.length / T, N = R.byteLength / S[1], F = Math.floor(N / M / S[0]), k = this.sourceTileGrid_.getTileCoordExtent(I.tileCoord);
            k[0] += _.offset, k[2] += _.offset;
            const O = (Q = this.clipExtent_) == null ? void 0 : Q.slice();
            O && (O[0] += _.offset, O[2] += _.offset), t.push({ extent: k, clipExtent: O, data: R, dataType: B, bytesPerPixel: L, pixelSize: S, bandCount: F });
          }), this.sourceTiles_.length = 0, t.length === 0) {
            this.state = At.ERROR, this.changed();
            return;
          }
          const i = this.wrappedTileCoord_[0], r = this.targetTileGrid_.getTileSize(i), a = typeof r == "number" ? r : r[0], o = typeof r == "number" ? r : r[1], s = a * this.pixelRatio_, l = o * this.pixelRatio_, u = this.targetTileGrid_.getResolution(i), h = this.sourceTileGrid_.getResolution(this.sourceZ_), c = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_), f = t[0].bandCount, g = new t[0].dataType(f * s * l), d = rlt(s, l, GO, { premultipliedAlpha: false, antialias: false });
          let A;
          const p = d.RGBA;
          let v;
          t[0].dataType == Float32Array ? (v = d.FLOAT, d.getExtension("WEBGL_color_buffer_float"), d.getExtension("OES_texture_float"), d.getExtension("EXT_float_blend"), A = d.getExtension("OES_texture_float_linear") !== null && this.interpolate) : (v = d.UNSIGNED_BYTE, A = this.interpolate);
          const y = 4, m = Math.ceil(f / y);
          for (let _ = m - 1; _ >= 0; --_) {
            const I = [];
            for (let B = 0, R = t.length; B < R; ++B) {
              const M = t[B], L = M.pixelSize, N = L[0], F = L[1], k = new M.dataType(y * N * F), O = M.data;
              let Q = _ * y;
              for (let Y = 0, G = k.length; Y < G; Y += y) k[Y] = O[Q], k[Y + 1] = O[Q + 1], k[Y + 2] = O[Q + 2], k[Y + 3] = O[Q + 3], Q += f;
              const j = d.createTexture();
              d.bindTexture(d.TEXTURE_2D, j), A ? (d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.LINEAR)) : (d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.NEAREST), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.NEAREST)), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), d.texImage2D(d.TEXTURE_2D, 0, p, N, F, 0, p, v, k), I.push({ extent: M.extent, clipExtent: M.clipExtent, texture: j, width: N, height: F });
            }
            const { framebuffer: E, width: x, height: w } = olt(d, a, o, this.pixelRatio_, h, u, c, this.triangulation_, I, this.gutter_, v, this.renderEdges_, A), C = x, S = w * y, b = new t[0].dataType(C * S);
            d.bindFramebuffer(d.FRAMEBUFFER, E), d.readPixels(0, 0, x, w, d.RGBA, v, b);
            let T = _ * y;
            for (let B = 0, R = b.length; B < R; B += y) {
              const M = (C - 1 - (B / S | 0)) * S + B % S;
              g[T] = b[M], g[T + 1] = b[M + 1], g[T + 2] = b[M + 2], g[T + 3] = b[M + 3], T += f;
            }
          }
          if (alt(d), GO.push(d.canvas), e) {
            const _ = In(a, o), I = new ImageData(g, a);
            _.putImageData(I, 0, 0), this.reprojData_ = _.canvas;
          } else this.reprojData_ = g;
          this.reprojSize_ = [Math.round(s), Math.round(l)], this.state = At.LOADED, this.changed();
        }
        load() {
          if (this.state !== At.IDLE && this.state !== At.ERROR) return;
          this.state = At.LOADING, this.changed();
          let t = 0;
          this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: e }) => {
            const i = e.getState();
            if (i !== At.IDLE && i !== At.LOADING) return;
            t++;
            const r = Ut(e, Rt.CHANGE, () => {
              const a = e.getState();
              (a == At.LOADED || a == At.ERROR || a == At.EMPTY) && (we(r), t--, t === 0 && (this.unlistenSources_(), this.reproject_()));
            });
            this.sourcesListenerKeys_.push(r);
          }), t === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: e }) {
            e.getState() == At.IDLE && e.load();
          });
        }
        unlistenSources_() {
          this.sourcesListenerKeys_.forEach(we), this.sourcesListenerKeys_ = null;
        }
      }
      class Uf extends kw {
        constructor(t, e, i, r, a, o, s, l, u, h, c, f) {
          super(a, At.IDLE, f), this.renderEdges_ = c !== void 0 ? c : false, this.pixelRatio_ = s, this.gutter_ = l, this.canvas_ = null, this.sourceTileGrid_ = e, this.targetTileGrid_ = r, this.wrappedTileCoord_ = o || a, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0, this.clipExtent_ = t.canWrapX() ? t.getExtent() : void 0;
          const g = r.getTileCoordExtent(this.wrappedTileCoord_), d = this.targetTileGrid_.getExtent();
          let A = this.sourceTileGrid_.getExtent();
          const p = d ? oi(g, d) : g;
          if (eA(p) === 0) {
            this.state = At.EMPTY;
            return;
          }
          const v = t.getExtent();
          v && (A ? A = oi(A, v) : A = v);
          const y = r.getResolution(this.wrappedTileCoord_[0]), m = kO(t, i, p, y);
          if (!isFinite(m) || m <= 0) {
            this.state = At.EMPTY;
            return;
          }
          const _ = h !== void 0 ? h : EC;
          if (this.triangulation_ = new IC(t, i, p, A, m * _, y), this.triangulation_.getTriangles().length === 0) {
            this.state = At.EMPTY;
            return;
          }
          this.sourceZ_ = e.getZForResolution(m);
          let I = this.triangulation_.calculateSourceExtent();
          if (A && (t.canWrapX() ? (I[1] = Ze(I[1], A[1], A[3]), I[3] = Ze(I[3], A[1], A[3])) : I = oi(I, A)), !eA(I)) this.state = At.EMPTY;
          else {
            let E = 0, x = 0;
            t.canWrapX() && (E = he(v), x = Math.floor((I[0] - v[0]) / E)), Bx(I.slice(), t, true).forEach((C) => {
              const S = e.getTileRangeForExtentAndZ(C, this.sourceZ_);
              for (let b = S.minX; b <= S.maxX; b++) for (let T = S.minY; T <= S.maxY; T++) {
                const B = u(this.sourceZ_, b, T, s);
                if (B) {
                  const R = x * E;
                  this.sourceTiles_.push({ tile: B, offset: R });
                }
              }
              ++x;
            }), this.sourceTiles_.length === 0 && (this.state = At.EMPTY);
          }
        }
        getImage() {
          return this.canvas_;
        }
        reproject_() {
          const t = [];
          if (this.sourceTiles_.forEach((e) => {
            var r;
            const i = e.tile;
            if (i && i.getState() == At.LOADED) {
              const a = this.sourceTileGrid_.getTileCoordExtent(i.tileCoord);
              a[0] += e.offset, a[2] += e.offset;
              const o = (r = this.clipExtent_) == null ? void 0 : r.slice();
              o && (o[0] += e.offset, o[2] += e.offset), t.push({ extent: a, clipExtent: o, image: i.getImage() });
            }
          }), this.sourceTiles_.length = 0, t.length === 0) this.state = At.ERROR;
          else {
            const e = this.wrappedTileCoord_[0], i = this.targetTileGrid_.getTileSize(e), r = typeof i == "number" ? i : i[0], a = typeof i == "number" ? i : i[1], o = this.targetTileGrid_.getResolution(e), s = this.sourceTileGrid_.getResolution(this.sourceZ_), l = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
            this.canvas_ = OO(r, a, this.pixelRatio_, s, this.sourceTileGrid_.getExtent(), o, l, this.triangulation_, t, this.gutter_, this.renderEdges_, this.interpolate), this.state = At.LOADED;
          }
          this.changed();
        }
        load() {
          if (this.state == At.IDLE) {
            this.state = At.LOADING, this.changed();
            let t = 0;
            this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: e }) => {
              const i = e.getState();
              if (i == At.IDLE || i == At.LOADING) {
                t++;
                const r = Ut(e, Rt.CHANGE, (a) => {
                  const o = e.getState();
                  (o == At.LOADED || o == At.ERROR || o == At.EMPTY) && (we(r), t--, t === 0 && (this.unlistenSources_(), this.reproject_()));
                });
                this.sourcesListenerKeys_.push(r);
              }
            }), t === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: e }, i, r) {
              e.getState() == At.IDLE && e.load();
            });
          }
        }
        unlistenSources_() {
          this.sourcesListenerKeys_.forEach(we), this.sourcesListenerKeys_ = null;
        }
        release() {
          this.canvas_ && (Mm(this.canvas_.getContext("2d")), Gf.push(this.canvas_), this.canvas_ = null), super.release();
        }
      }
      function bC(n, t, e, i) {
        return `${n},${XF(t, e, i)}`;
      }
      function TC(n, t, e) {
        if (!(e in n)) return n[e] = /* @__PURE__ */ new Set([t]), true;
        const i = n[e], r = i.has(t);
        return r || i.add(t), !r;
      }
      function slt(n, t, e) {
        const i = n[e];
        return i ? i.delete(t) : false;
      }
      function UO(n, t) {
        const e = n.layerStatesArray[n.layerIndex];
        e.extent && (t = oi(t, zi(e.extent, n.viewState.projection)));
        const i = e.layer.getRenderSource();
        if (!i.getWrapX()) {
          const r = i.getTileGridForProjection(n.viewState.projection).getExtent();
          r && (t = oi(t, r));
        }
        return t;
      }
      class llt extends Ym {
        constructor(t, e) {
          super(t), e = e || {}, this.extentChanged = true, this.renderComplete = false, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedRevision, this.renderedTiles = [], this.renderedSourceKey_, this.renderedSourceRevision_, this.tempExtent = ai(), this.tempTileRange_ = new Jm(0, 0, 0, 0), this.tempTileCoord_ = Ef(0, 0, 0);
          const i = e.cacheSize !== void 0 ? e.cacheSize : 512;
          this.tileCache_ = new WF(i), this.maxStaleKeys = i * 0.5;
        }
        getTileCache() {
          return this.tileCache_;
        }
        getOrCreateTile(t, e, i, r) {
          const a = this.tileCache_, s = this.getLayer().getSource(), l = bC(s.getKey(), t, e, i);
          let u;
          if (a.containsKey(l)) u = a.get(l);
          else {
            if (u = s.getTile(t, e, i, r.pixelRatio, r.viewState.projection), !u) return null;
            a.set(l, u);
          }
          return u;
        }
        getTile(t, e, i, r) {
          const a = this.getOrCreateTile(t, e, i, r);
          return a || null;
        }
        getData(t) {
          const e = this.frameState;
          if (!e) return null;
          const i = this.getLayer(), r = nn(e.pixelToCoordinateTransform, t.slice()), a = i.getExtent();
          if (a && !Jr(a, r)) return null;
          const o = e.viewState, s = i.getRenderSource(), l = s.getTileGridForProjection(o.projection), u = s.getTilePixelRatio(e.pixelRatio);
          for (let h = l.getZForResolution(o.resolution); h >= l.getMinZoom(); --h) {
            const c = l.getTileCoordForCoordAndZ(r, h), f = this.getTile(h, c[1], c[2], e);
            if (!f || f.getState() !== At.LOADED) continue;
            const g = l.getOrigin(h), d = Rn(l.getTileSize(h)), A = l.getResolution(h);
            let p;
            if (f instanceof $m || f instanceof Uf) p = f.getImage();
            else if (f instanceof ep) {
              if (p = Qf(f.getData()), !p) continue;
            } else continue;
            const v = Math.floor(u * ((r[0] - g[0]) / A - c[1] * d[0])), y = Math.floor(u * ((g[1] - r[1]) / A - c[2] * d[1])), m = Math.round(u * s.getGutterForProjection(o.projection));
            return this.getImageData(p, v + m, y + m);
          }
          return null;
        }
        prepareFrame(t) {
          this.renderedProjection ? t.viewState.projection !== this.renderedProjection && (this.tileCache_.clear(), this.renderedProjection = t.viewState.projection) : this.renderedProjection = t.viewState.projection;
          const e = this.getLayer().getSource();
          if (!e) return false;
          const i = e.getRevision();
          return this.renderedRevision_ ? this.renderedRevision_ !== i && (this.renderedRevision_ = i, this.renderedSourceKey_ === e.getKey() && this.tileCache_.clear()) : this.renderedRevision_ = i, true;
        }
        enqueueTiles(t, e, i, r, a) {
          const o = t.viewState, s = this.getLayer(), l = s.getRenderSource(), u = l.getTileGridForProjection(o.projection), h = xt(l);
          h in t.wantedTiles || (t.wantedTiles[h] = {});
          const c = t.wantedTiles[h], f = s.getMapInternal(), g = Math.max(i - a, u.getMinZoom(), u.getZForResolution(Math.min(s.getMaxResolution(), f ? f.getView().getResolutionForZoom(Math.max(s.getMinZoom(), 0)) : u.getResolution(0)), l.zDirection));
          for (let d = i; d >= g; --d) {
            const A = u.getTileRangeForExtentAndZ(e, d, this.tempTileRange_), p = u.getResolution(d);
            for (let v = A.minX; v <= A.maxX; ++v) for (let y = A.minY; y <= A.maxY; ++y) {
              const m = this.getTile(d, v, y, t);
              if (!m || !TC(r, m, d)) continue;
              const I = m.getKey();
              if (c[I] = true, m.getState() === At.IDLE && !t.tileQueue.isKeyQueued(I)) {
                const E = Ef(d, v, y, this.tempTileCoord_);
                t.tileQueue.enqueue([m, h, u.getTileCoordCenter(E), p]);
              }
            }
          }
        }
        findStaleTile_(t, e) {
          const i = this.tileCache_, r = t[0], a = t[1], o = t[2], s = this.getStaleKeys();
          for (let l = 0; l < s.length; ++l) {
            const u = bC(s[l], r, a, o);
            if (i.containsKey(u)) {
              const h = i.get(u);
              if (h.getState() === At.LOADED) return h.endTransition(xt(this)), TC(e, h, r), true;
            }
          }
          return false;
        }
        findAltTiles_(t, e, i, r) {
          const a = t.getTileRangeForTileCoordAndZ(e, i, this.tempTileRange_);
          if (!a) return false;
          let o = true;
          const s = this.tileCache_, u = this.getLayer().getRenderSource().getKey();
          for (let h = a.minX; h <= a.maxX; ++h) for (let c = a.minY; c <= a.maxY; ++c) {
            const f = bC(u, i, h, c);
            let g = false;
            if (s.containsKey(f)) {
              const d = s.get(f);
              d.getState() === At.LOADED && (TC(r, d, i), g = true);
            }
            g || (o = false);
          }
          return o;
        }
        renderFrame(t, e) {
          let i = true;
          this.renderComplete = true;
          const r = t.layerStatesArray[t.layerIndex], a = t.viewState, o = a.projection, s = a.resolution, l = a.center, u = t.pixelRatio, h = this.getLayer(), c = h.getSource(), f = c.getRevision(), g = c.getTileGridForProjection(o), d = g.getZForResolution(s, c.zDirection), A = g.getResolution(d), p = c.getKey();
          this.renderedSourceKey_ ? this.renderedSourceKey_ !== p && (this.prependStaleKey(this.renderedSourceKey_), this.renderedSourceKey_ = p) : this.renderedSourceKey_ = p;
          let v = t.extent;
          const y = c.getTilePixelRatio(u);
          this.prepareContainer(t, e);
          const m = this.context.canvas.width, _ = this.context.canvas.height, I = r.extent && zi(r.extent);
          I && (v = oi(v, zi(r.extent)));
          const E = A * m / 2 / y, x = A * _ / 2 / y, w = [l[0] - E, l[1] - x, l[0] + E, l[1] + x], C = {};
          this.renderedTiles.length = 0;
          const S = h.getPreload();
          if (t.nextExtent) {
            const O = g.getZForResolution(a.nextResolution, c.zDirection), Q = UO(t, t.nextExtent);
            this.enqueueTiles(t, Q, O, C, S);
          }
          const b = UO(t, v);
          if (this.enqueueTiles(t, b, d, C, 0), S > 0 && setTimeout(() => {
            this.enqueueTiles(t, b, d - 1, C, S - 1);
          }, 0), !(d in C)) return this.container;
          const T = xt(this), B = t.time;
          for (const O of C[d]) {
            const Q = O.getState();
            if ((O instanceof Uf || O instanceof M0) && Q === At.EMPTY) continue;
            const j = O.tileCoord;
            if (Q === At.LOADED && O.getAlpha(T, B) === 1) {
              O.endTransition(T);
              continue;
            }
            if (Q !== At.IDLE && (i = false), Q !== At.ERROR && (this.renderComplete = false), this.findStaleTile_(j, C)) {
              slt(C, O, d), t.animate = true;
              continue;
            }
            if (this.findAltTiles_(g, j, d + 1, C)) continue;
            const $ = g.getMinZoom();
            for (let J = d - 1; J >= $ && !this.findAltTiles_(g, j, J, C); --J) ;
          }
          const R = A / s * u / y, M = this.getRenderContext(t);
          Lr(this.tempTransform, m / 2, _ / 2, R, R, 0, -m / 2, -_ / 2), r.extent && this.clipUnrotated(M, t, I), c.getInterpolate() || (M.imageSmoothingEnabled = false), this.preRender(M, t);
          const L = Object.keys(C).map(Number);
          L.sort(Rr);
          let N;
          const F = [], k = [];
          for (let O = L.length - 1; O >= 0; --O) {
            const Q = L[O], j = c.getTilePixelSize(Q, u, o), G = g.getResolution(Q) / A, $ = j[0] * G * R, J = j[1] * G * R, et = g.getTileCoordForCoordAndZ(ur(w), Q), nt = g.getTileCoordExtent(et), gt = nn(this.tempTransform, [y * (nt[0] - w[0]) / A, y * (w[3] - nt[3]) / A]), q = y * c.getGutterForProjection(o);
            for (const W of C[Q]) {
              if (W.getState() !== At.LOADED) continue;
              const it = W.tileCoord, Ot = et[1] - it[1], pt = Math.round(gt[0] - (Ot - 1) * $), St = et[2] - it[2], bt = Math.round(gt[1] - (St - 1) * J), xe = Math.round(gt[0] - Ot * $), sn = Math.round(gt[1] - St * J), Ie = pt - xe, yn = bt - sn, ln = L.length === 1;
              let Br = false;
              N = [xe, sn, xe + Ie, sn, xe + Ie, sn + yn, xe, sn + yn];
              for (let Mr = 0, gs = F.length; Mr < gs; ++Mr) if (!ln && Q < k[Mr]) {
                const Vn = F[Mr];
                Ai([xe, sn, xe + Ie, sn + yn], [Vn[0], Vn[3], Vn[4], Vn[7]]) && (Br || (M.save(), Br = true), M.beginPath(), M.moveTo(N[0], N[1]), M.lineTo(N[2], N[3]), M.lineTo(N[4], N[5]), M.lineTo(N[6], N[7]), M.moveTo(Vn[6], Vn[7]), M.lineTo(Vn[4], Vn[5]), M.lineTo(Vn[2], Vn[3]), M.lineTo(Vn[0], Vn[1]), M.clip());
              }
              F.push(N), k.push(Q), this.drawTile(W, t, xe, sn, Ie, yn, q, ln), Br && M.restore(), this.renderedTiles.unshift(W), this.updateUsedTiles(t.usedTiles, c, W);
            }
          }
          if (this.renderedRevision = f, this.renderedResolution = A, this.extentChanged = !this.renderedExtent_ || !As(this.renderedExtent_, w), this.renderedExtent_ = w, this.renderedPixelRatio = u, this.postRender(this.context, t), r.extent && M.restore(), M.imageSmoothingEnabled = true, this.renderComplete) {
            const O = (Q, j) => {
              const Y = xt(c), G = j.wantedTiles[Y], $ = G ? Object.keys(G).length : 0;
              this.updateCacheSize($), this.tileCache_.expireCache();
            };
            t.postRenderFunctions.push(O);
          }
          return !this.renderComplete && !i && (t.animate = true), this.container;
        }
        updateCacheSize(t) {
          this.tileCache_.highWaterMark = Math.max(this.tileCache_.highWaterMark, t * 2);
        }
        drawTile(t, e, i, r, a, o, s, l) {
          let u;
          if (t instanceof ep) {
            if (u = Qf(t.getData()), !u) throw new Error("Rendering array data is not yet supported");
          } else u = this.getTileImage(t);
          if (!u) return;
          const h = this.getRenderContext(e), c = xt(this), f = e.layerStatesArray[e.layerIndex], g = f.opacity * (l ? t.getAlpha(c, e.time) : 1), d = g !== h.globalAlpha;
          d && (h.save(), h.globalAlpha = g), h.drawImage(u, s, s, u.width - 2 * s, u.height - 2 * s, i, r, a, o), d && h.restore(), g !== f.opacity ? e.animate = true : l && t.endTransition(c);
        }
        getImage() {
          const t = this.context;
          return t ? t.canvas : null;
        }
        getTileImage(t) {
          return t.getImage();
        }
        updateUsedTiles(t, e, i) {
          const r = xt(e);
          r in t || (t[r] = {}), t[r][i.getKey()] = true;
        }
      }
      class D0 extends PO {
        constructor(t) {
          super(t);
        }
        createRenderer() {
          return new llt(this, { cacheSize: this.getCacheSize() });
        }
      }
      class ult extends qc {
        constructor(t) {
          super(), this.tile, this.handleTileChange_ = this.handleTileChange_.bind(this), this.gutter = t.gutter || 0, this.helper = t.helper, this.loaded = false, this.ready = false;
        }
        setTile(t) {
          if (t !== this.tile) if (this.tile && this.tile.removeEventListener(Rt.CHANGE, this.handleTileChange_), this.tile = t, this.loaded = t.getState() === At.LOADED, this.loaded) this.uploadTile();
          else {
            if (t instanceof $m) {
              const e = t.getImage();
              e instanceof Image && !e.crossOrigin && (e.crossOrigin = "anonymous");
            }
            t.addEventListener(Rt.CHANGE, this.handleTileChange_);
          }
        }
        uploadTile() {
          zt();
        }
        setReady() {
          this.ready = true, this.dispatchEvent(Rt.CHANGE);
        }
        handleTileChange_() {
          this.tile.getState() === At.LOADED && (this.loaded = true, this.uploadTile());
        }
        setHelper(t) {
          this.helper = t, this.helper && this.loaded && this.uploadTile();
        }
        disposeInternal() {
          this.setHelper(null), this.tile.removeEventListener(Rt.CHANGE, this.handleTileChange_);
        }
      }
      const ip = 34962, rp = 34963, hlt = 35040, BC = 35044, ap = 35048, clt = 5121, flt = 5123, glt = 5125, VO = 5126, jO = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
      function dlt(n, t) {
        t = Object.assign({ preserveDrawingBuffer: true, antialias: !jK }, t);
        const e = jO.length;
        for (let i = 0; i < e; ++i) try {
          const r = n.getContext(jO[i], t);
          if (r) return r;
        } catch (r) {
        }
        return null;
      }
      const Alt = { STATIC_DRAW: BC, STREAM_DRAW: hlt, DYNAMIC_DRAW: ap };
      class Vf {
        constructor(t, e) {
          this.array_ = null, this.type_ = t, ue(t === ip || t === rp, "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`"), this.usage_ = e !== void 0 ? e : Alt.STATIC_DRAW;
        }
        ofSize(t) {
          return this.array_ = new (R0(this.type_))(t), this;
        }
        fromArray(t) {
          return this.array_ = R0(this.type_).from(t), this;
        }
        fromArrayBuffer(t) {
          return this.array_ = new (R0(this.type_))(t), this;
        }
        getType() {
          return this.type_;
        }
        getArray() {
          return this.array_;
        }
        setArray(t) {
          const e = R0(this.type_);
          if (!(t instanceof e)) throw new Error(`Expected ${e}`);
          this.array_ = t;
        }
        getUsage() {
          return this.usage_;
        }
        getSize() {
          return this.array_ ? this.array_.length : 0;
        }
      }
      function R0(n) {
        switch (n) {
          case ip:
            return Float32Array;
          case rp:
            return Uint32Array;
          default:
            return Float32Array;
        }
      }
      function qO(n, t, e) {
        const i = e ? n.LINEAR : n.NEAREST;
        n.bindTexture(n.TEXTURE_2D, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, i), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, i);
      }
      function plt(n, t, e, i) {
        qO(n, t, i), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, e);
      }
      function HO(n, t, e, i, r, a) {
        const o = n.getGL();
        let s, l;
        e instanceof Float32Array ? (s = o.FLOAT, n.getExtension("OES_texture_float"), l = n.getExtension("OES_texture_float_linear") !== null) : (s = o.UNSIGNED_BYTE, l = true), qO(o, t, a && l);
        const u = e.byteLength / i[1];
        let h = 1;
        u % 8 === 0 ? h = 8 : u % 4 === 0 ? h = 4 : u % 2 === 0 && (h = 2);
        let c;
        switch (r) {
          case 1: {
            c = o.LUMINANCE;
            break;
          }
          case 2: {
            c = o.LUMINANCE_ALPHA;
            break;
          }
          case 3: {
            c = o.RGB;
            break;
          }
          case 4: {
            c = o.RGBA;
            break;
          }
          default:
            throw new Error(`Unsupported number of bands: ${r}`);
        }
        const f = o.getParameter(o.UNPACK_ALIGNMENT);
        o.pixelStorei(o.UNPACK_ALIGNMENT, h), o.texImage2D(o.TEXTURE_2D, 0, c, i[0], i[1], 0, c, s, e), o.pixelStorei(o.UNPACK_ALIGNMENT, f);
      }
      let jf = null;
      function vlt() {
        jf = In(1, 1, void 0, { willReadFrequently: true });
      }
      class ylt extends ult {
        constructor(t) {
          super(t), this.textures = [], this.renderSize_ = Rn(t.grid.getTileSize(t.tile.tileCoord[0])), this.bandCount = NaN;
          const e = new Vf(ip, BC);
          e.fromArray([0, 1, 1, 1, 1, 0, 0, 0]), this.helper.flushBufferData(e), this.coords = e, this.setTile(t.tile);
        }
        setHelper(t) {
          var i;
          const e = (i = this.helper) == null ? void 0 : i.getGL();
          if (e) {
            this.helper.deleteBuffer(this.coords);
            for (let r = 0; r < this.textures.length; ++r) e.deleteTexture(this.textures[r]);
          }
          super.setHelper(t), t && t.flushBufferData(this.coords);
        }
        uploadTile() {
          const t = this.helper, e = t.getGL(), i = this.tile;
          this.textures.length = 0;
          let r;
          i instanceof $m || i instanceof Uf ? r = i.getImage() : r = i.getData();
          const a = Qf(r);
          if (a) {
            const y = e.createTexture();
            this.textures.push(y), this.bandCount = 4, plt(e, y, a, i.interpolate), this.setReady();
            return;
          }
          r = _C(r);
          const o = i.getSize(), s = [o[0] + 2 * this.gutter, o[1] + 2 * this.gutter], l = r instanceof Float32Array, u = s[0] * s[1], h = l ? Float32Array : Uint8Array, c = h.BYTES_PER_ELEMENT, f = r.byteLength / s[1];
          this.bandCount = Math.floor(f / c / s[0]);
          const g = Math.ceil(this.bandCount / 4);
          if (g === 1) {
            const y = e.createTexture();
            this.textures.push(y), HO(t, y, r, s, this.bandCount, i.interpolate), this.setReady();
            return;
          }
          const d = new Array(g);
          for (let y = 0; y < g; ++y) {
            const m = e.createTexture();
            this.textures.push(m);
            const _ = y < g - 1 ? 4 : (this.bandCount - 1) % 4 + 1;
            d[y] = new h(u * _);
          }
          let A = 0, p = 0;
          const v = s[0] * this.bandCount;
          for (let y = 0; y < s[1]; ++y) {
            for (let m = 0; m < v; ++m) {
              const _ = r[p + m], I = Math.floor(A / this.bandCount), E = m % this.bandCount, x = Math.floor(E / 4), w = d[x], C = w.length / u, S = E % 4;
              w[I * C + S] = _, ++A;
            }
            p += f / c;
          }
          for (let y = 0; y < g; ++y) {
            const m = this.textures[y], _ = d[y], I = _.length / u;
            HO(t, m, _, s, I, i.interpolate);
          }
          this.setReady();
        }
        getImagePixelData_(t, e, i) {
          const r = this.gutter, a = this.renderSize_[0], o = this.renderSize_[1];
          jf || vlt(), jf.clearRect(0, 0, 1, 1);
          const s = t.width, l = t.height, u = s - 2 * r, h = l - 2 * r, c = r + Math.floor(u * (e / a)), f = r + Math.floor(h * (i / o));
          let g;
          try {
            jf.drawImage(t, c, f, 1, 1, 0, 0, 1, 1), g = jf.getImageData(0, 0, 1, 1).data;
          } catch (d) {
            return jf = null, null;
          }
          return g;
        }
        getArrayPixelData_(t, e, i, r) {
          const a = this.gutter, o = this.renderSize_[0], s = this.renderSize_[1], l = e[0], u = e[1], h = l + 2 * a, c = u + 2 * a, f = a + Math.floor(l * (i / o)), g = a + Math.floor(u * (r / s));
          if (t instanceof DataView) {
            const A = t.byteLength / (h * c), p = A * (g * h + f), v = t.buffer.slice(p, p + A);
            return new DataView(v);
          }
          const d = this.bandCount * (g * h + f);
          return t.slice(d, d + this.bandCount);
        }
        getPixelData(t, e) {
          if (!this.loaded) return null;
          if (this.tile instanceof ep) {
            const i = this.tile.getData(), r = _C(i);
            if (r) {
              const a = this.tile.getSize();
              return this.getArrayPixelData_(r, a, t, e);
            }
            return this.getImagePixelData_(Qf(i), t, e);
          }
          return this.getImagePixelData_(this.tile.getImage(), t, e);
        }
      }
      const L0 = { LOST: "webglcontextlost", RESTORED: "webglcontextrestored" }, mlt = `
  precision mediump float;

  attribute vec2 a_position;
  varying vec2 v_texCoord;
  varying vec2 v_screenCoord;

  uniform vec2 u_screenSize;

  void main() {
    v_texCoord = a_position * 0.5 + 0.5;
    v_screenCoord = v_texCoord * u_screenSize;
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`, _lt = `
  precision mediump float;

  uniform sampler2D u_image;
  uniform float u_opacity;

  varying vec2 v_texCoord;

  void main() {
    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
  }
`;
      class YO {
        constructor(t) {
          this.gl_ = t.webGlContext;
          const e = this.gl_;
          this.scaleRatio_ = t.scaleRatio || 1, this.renderTargetTexture_ = e.createTexture(), this.renderTargetTextureSize_ = null, this.frameBuffer_ = e.createFramebuffer(), this.depthBuffer_ = e.createRenderbuffer();
          const i = e.createShader(e.VERTEX_SHADER);
          e.shaderSource(i, t.vertexShader || mlt), e.compileShader(i);
          const r = e.createShader(e.FRAGMENT_SHADER);
          e.shaderSource(r, t.fragmentShader || _lt), e.compileShader(r), this.renderTargetProgram_ = e.createProgram(), e.attachShader(this.renderTargetProgram_, i), e.attachShader(this.renderTargetProgram_, r), e.linkProgram(this.renderTargetProgram_), this.renderTargetVerticesBuffer_ = e.createBuffer();
          const a = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
          e.bindBuffer(e.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), e.bufferData(e.ARRAY_BUFFER, new Float32Array(a), e.STATIC_DRAW), this.renderTargetAttribLocation_ = e.getAttribLocation(this.renderTargetProgram_, "a_position"), this.renderTargetUniformLocation_ = e.getUniformLocation(this.renderTargetProgram_, "u_screenSize"), this.renderTargetOpacityLocation_ = e.getUniformLocation(this.renderTargetProgram_, "u_opacity"), this.renderTargetTextureLocation_ = e.getUniformLocation(this.renderTargetProgram_, "u_image"), this.uniforms_ = [], t.uniforms && Object.keys(t.uniforms).forEach((o) => {
            this.uniforms_.push({ value: t.uniforms[o], location: e.getUniformLocation(this.renderTargetProgram_, o) });
          });
        }
        getRenderTargetTexture() {
          return this.renderTargetTexture_;
        }
        getGL() {
          return this.gl_;
        }
        init(t) {
          const e = this.getGL(), i = [e.drawingBufferWidth * this.scaleRatio_, e.drawingBufferHeight * this.scaleRatio_];
          if (e.bindFramebuffer(e.FRAMEBUFFER, this.getFrameBuffer()), e.bindRenderbuffer(e.RENDERBUFFER, this.getDepthBuffer()), e.viewport(0, 0, i[0], i[1]), !this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== i[0] || this.renderTargetTextureSize_[1] !== i[1]) {
            this.renderTargetTextureSize_ = i;
            const r = 0, a = e.RGBA, o = 0, s = e.RGBA, l = e.UNSIGNED_BYTE, u = null;
            e.bindTexture(e.TEXTURE_2D, this.renderTargetTexture_), e.texImage2D(e.TEXTURE_2D, r, a, i[0], i[1], o, s, l, u), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.renderTargetTexture_, 0), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, i[0], i[1]), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, this.depthBuffer_);
          }
        }
        apply(t, e, i, r) {
          const a = this.getGL(), o = t.size;
          if (a.bindFramebuffer(a.FRAMEBUFFER, e ? e.getFrameBuffer() : null), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, this.renderTargetTexture_), !e) {
            const l = xt(a.canvas);
            if (!t.renderTargets[l]) {
              const u = a.getContextAttributes();
              u && u.preserveDrawingBuffer && (a.clearColor(0, 0, 0, 0), a.clearDepth(1), a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)), t.renderTargets[l] = true;
            }
          }
          a.disable(a.DEPTH_TEST), a.enable(a.BLEND), a.blendFunc(a.ONE, a.ONE_MINUS_SRC_ALPHA), a.viewport(0, 0, a.drawingBufferWidth, a.drawingBufferHeight), a.bindBuffer(a.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), a.useProgram(this.renderTargetProgram_), a.enableVertexAttribArray(this.renderTargetAttribLocation_), a.vertexAttribPointer(this.renderTargetAttribLocation_, 2, a.FLOAT, false, 0, 0), a.uniform2f(this.renderTargetUniformLocation_, o[0], o[1]), a.uniform1i(this.renderTargetTextureLocation_, 0);
          const s = t.layerStatesArray[t.layerIndex].opacity;
          a.uniform1f(this.renderTargetOpacityLocation_, s), this.applyUniforms(t), i && i(a, t), a.drawArrays(a.TRIANGLES, 0, 6), r && r(a, t);
        }
        getFrameBuffer() {
          return this.frameBuffer_;
        }
        getDepthBuffer() {
          return this.depthBuffer_;
        }
        applyUniforms(t) {
          const e = this.getGL();
          let i, r = 1;
          this.uniforms_.forEach(function(a) {
            if (i = typeof a.value == "function" ? a.value(t) : a.value, i instanceof HTMLCanvasElement || i instanceof ImageData) a.texture || (a.texture = e.createTexture()), e.activeTexture(e[`TEXTURE${r}`]), e.bindTexture(e.TEXTURE_2D, a.texture), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), i instanceof ImageData ? e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, i.width, i.height, 0, e.UNSIGNED_BYTE, new Uint8Array(i.data)) : e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, i), e.uniform1i(a.location, r++);
            else if (Array.isArray(i)) switch (i.length) {
              case 2:
                e.uniform2f(a.location, i[0], i[1]);
                return;
              case 3:
                e.uniform3f(a.location, i[0], i[1], i[2]);
                return;
              case 4:
                e.uniform4f(a.location, i[0], i[1], i[2], i[3]);
                return;
              default:
                return;
            }
            else typeof i == "number" && e.uniform1f(a.location, i);
          });
        }
      }
      const To = { PROJECTION_MATRIX: "u_projectionMatrix", SCREEN_TO_WORLD_MATRIX: "u_screenToWorldMatrix", TIME: "u_time", ZOOM: "u_zoom", RESOLUTION: "u_resolution", ROTATION: "u_rotation", VIEWPORT_SIZE_PX: "u_viewportSizePx", PIXEL_RATIO: "u_pixelRatio", HIT_DETECTION: "u_hitDetection" }, Fn = { UNSIGNED_BYTE: clt, UNSIGNED_SHORT: flt, UNSIGNED_INT: glt, FLOAT: VO }, P0 = {};
      function WO(n) {
        return "shared/" + n;
      }
      let XO = 0;
      function Elt() {
        const n = "unique/" + XO;
        return XO += 1, n;
      }
      function Ilt(n) {
        let t = P0[n];
        if (!t) {
          const e = document.createElement("canvas");
          e.width = 1, e.height = 1, e.style.position = "absolute", e.style.left = "0", t = { users: 0, context: dlt(e) }, P0[n] = t;
        }
        return t.users += 1, t.context;
      }
      function xlt(n) {
        const t = P0[n];
        if (!t || (t.users -= 1, t.users > 0)) return;
        const e = t.context, i = e.getExtension("WEBGL_lose_context");
        i && i.loseContext();
        const r = e.canvas;
        r.width = 1, r.height = 1, delete P0[n];
      }
      class wlt extends Nu {
        constructor(t) {
          super(), t = t || {}, this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this), this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(this), this.canvasCacheKey_ = t.canvasCacheKey ? WO(t.canvasCacheKey) : Elt(), this.gl_ = Ilt(this.canvasCacheKey_), this.bufferCache_ = {}, this.extensionCache_ = {}, this.currentProgram_ = null, this.needsToBeRecreated_ = false;
          const e = this.gl_.canvas;
          e.addEventListener(L0.LOST, this.boundHandleWebGLContextLost_), e.addEventListener(L0.RESTORED, this.boundHandleWebGLContextRestored_), this.offsetRotateMatrix_ = an(), this.offsetScaleMatrix_ = an(), this.tmpMat4_ = ih(), this.uniformLocationsByProgram_ = {}, this.attribLocationsByProgram_ = {}, this.uniforms_ = [], t.uniforms && this.setUniforms(t.uniforms), this.postProcessPasses_ = t.postProcesses ? t.postProcesses.map((i) => new YO({ webGlContext: this.gl_, scaleRatio: i.scaleRatio, vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, uniforms: i.uniforms })) : [new YO({ webGlContext: this.gl_ })], this.shaderCompileErrors_ = null, this.startTime_ = Date.now();
        }
        setUniforms(t) {
          this.uniforms_ = [], this.addUniforms(t);
        }
        addUniforms(t) {
          for (const e in t) this.uniforms_.push({ name: e, value: t[e] });
        }
        canvasCacheKeyMatches(t) {
          return this.canvasCacheKey_ === WO(t);
        }
        getExtension(t) {
          if (t in this.extensionCache_) return this.extensionCache_[t];
          const e = this.gl_.getExtension(t);
          return this.extensionCache_[t] = e, e;
        }
        bindBuffer(t) {
          const e = this.gl_, i = xt(t);
          let r = this.bufferCache_[i];
          if (!r) {
            const a = e.createBuffer();
            r = { buffer: t, webGlBuffer: a }, this.bufferCache_[i] = r;
          }
          e.bindBuffer(t.getType(), r.webGlBuffer);
        }
        flushBufferData(t) {
          const e = this.gl_;
          this.bindBuffer(t), e.bufferData(t.getType(), t.getArray(), t.getUsage());
        }
        deleteBuffer(t) {
          const e = xt(t);
          delete this.bufferCache_[e];
        }
        disposeInternal() {
          const t = this.gl_.canvas;
          t.removeEventListener(L0.LOST, this.boundHandleWebGLContextLost_), t.removeEventListener(L0.RESTORED, this.boundHandleWebGLContextRestored_), xlt(this.canvasCacheKey_), delete this.gl_;
        }
        prepareDraw(t, e, i) {
          const r = this.gl_, a = this.getCanvas(), o = t.size, s = t.pixelRatio;
          (a.width !== o[0] * s || a.height !== o[1] * s) && (a.width = o[0] * s, a.height = o[1] * s, a.style.width = o[0] + "px", a.style.height = o[1] + "px");
          for (let l = this.postProcessPasses_.length - 1; l >= 0; l--) this.postProcessPasses_[l].init(t);
          r.bindTexture(r.TEXTURE_2D, null), r.clearColor(0, 0, 0, 0), r.depthRange(0, 1), r.clearDepth(1), r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT), r.enable(r.BLEND), r.blendFunc(r.ONE, e ? r.ZERO : r.ONE_MINUS_SRC_ALPHA), i ? (r.enable(r.DEPTH_TEST), r.depthFunc(r.LEQUAL)) : r.disable(r.DEPTH_TEST);
        }
        bindFrameBuffer(t, e) {
          const i = this.getGL();
          i.bindFramebuffer(i.FRAMEBUFFER, t), e && i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0);
        }
        bindInitialFrameBuffer() {
          const t = this.getGL(), e = this.postProcessPasses_[0].getFrameBuffer();
          t.bindFramebuffer(t.FRAMEBUFFER, e);
          const i = this.postProcessPasses_[0].getRenderTargetTexture();
          t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, i, 0);
        }
        bindTexture(t, e, i) {
          const r = this.gl_;
          r.activeTexture(r.TEXTURE0 + e), r.bindTexture(r.TEXTURE_2D, t), r.uniform1i(this.getUniformLocation(i), e);
        }
        bindAttribute(t, e, i) {
          const r = this.getGL();
          this.bindBuffer(t);
          const a = this.getAttributeLocation(e);
          r.enableVertexAttribArray(a), r.vertexAttribPointer(a, i, r.FLOAT, false, 0, 0);
        }
        prepareDrawToRenderTarget(t, e, i, r) {
          const a = this.gl_, o = e.getSize();
          a.bindFramebuffer(a.FRAMEBUFFER, e.getFramebuffer()), a.bindRenderbuffer(a.RENDERBUFFER, e.getDepthbuffer()), a.viewport(0, 0, o[0], o[1]), a.bindTexture(a.TEXTURE_2D, e.getTexture()), a.clearColor(0, 0, 0, 0), a.depthRange(0, 1), a.clearDepth(1), a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT), a.enable(a.BLEND), a.blendFunc(a.ONE, i ? a.ZERO : a.ONE_MINUS_SRC_ALPHA), r ? (a.enable(a.DEPTH_TEST), a.depthFunc(a.LEQUAL)) : a.disable(a.DEPTH_TEST);
        }
        drawElements(t, e) {
          const i = this.gl_;
          this.getExtension("OES_element_index_uint");
          const r = i.UNSIGNED_INT, a = 4, o = e - t, s = t * a;
          i.drawElements(i.TRIANGLES, o, r, s);
        }
        finalizeDraw(t, e, i) {
          for (let r = 0, a = this.postProcessPasses_.length; r < a; r++) r === a - 1 ? this.postProcessPasses_[r].apply(t, null, e, i) : this.postProcessPasses_[r].apply(t, this.postProcessPasses_[r + 1]);
        }
        getCanvas() {
          return this.gl_.canvas;
        }
        getGL() {
          return this.gl_;
        }
        applyFrameState(t) {
          const e = t.size, i = t.viewState.rotation, r = t.pixelRatio;
          this.setUniformFloatValue(To.TIME, (Date.now() - this.startTime_) * 1e-3), this.setUniformFloatValue(To.ZOOM, t.viewState.zoom), this.setUniformFloatValue(To.RESOLUTION, t.viewState.resolution), this.setUniformFloatValue(To.PIXEL_RATIO, r), this.setUniformFloatVec2(To.VIEWPORT_SIZE_PX, [e[0], e[1]]), this.setUniformFloatValue(To.ROTATION, i);
        }
        applyHitDetectionUniform(t) {
          const e = this.getUniformLocation(To.HIT_DETECTION);
          this.getGL().uniform1i(e, t ? 1 : 0), t && this.setUniformFloatValue(To.PIXEL_RATIO, 0.5);
        }
        applyUniforms(t) {
          const e = this.gl_;
          let i, r = 0;
          this.uniforms_.forEach((a) => {
            if (i = typeof a.value == "function" ? a.value(t) : a.value, i instanceof HTMLCanvasElement || i instanceof HTMLImageElement || i instanceof ImageData || i instanceof WebGLTexture) {
              i instanceof WebGLTexture && !a.texture ? (a.prevValue = void 0, a.texture = i) : a.texture || (a.prevValue = void 0, a.texture = e.createTexture()), this.bindTexture(a.texture, r, a.name), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE);
              const o = !(i instanceof HTMLImageElement) || i.complete;
              !(i instanceof WebGLTexture) && o && a.prevValue !== i && (a.prevValue = i, e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, i)), r++;
            } else if (Array.isArray(i) && i.length === 6) this.setUniformMatrixValue(a.name, B0(this.tmpMat4_, i));
            else if (Array.isArray(i) && i.length <= 4) switch (i.length) {
              case 2:
                e.uniform2f(this.getUniformLocation(a.name), i[0], i[1]);
                return;
              case 3:
                e.uniform3f(this.getUniformLocation(a.name), i[0], i[1], i[2]);
                return;
              case 4:
                e.uniform4f(this.getUniformLocation(a.name), i[0], i[1], i[2], i[3]);
                return;
              default:
                return;
            }
            else typeof i == "number" && e.uniform1f(this.getUniformLocation(a.name), i);
          });
        }
        useProgram(t, e) {
          this.gl_.useProgram(t), this.currentProgram_ = t, e && (this.applyFrameState(e), this.applyUniforms(e));
        }
        compileShader(t, e) {
          const i = this.gl_, r = i.createShader(e);
          return i.shaderSource(r, t), i.compileShader(r), r;
        }
        getProgram(t, e) {
          const i = this.gl_, r = this.compileShader(t, i.FRAGMENT_SHADER), a = this.compileShader(e, i.VERTEX_SHADER), o = i.createProgram();
          if (i.attachShader(o, r), i.attachShader(o, a), i.linkProgram(o), !i.getShaderParameter(r, i.COMPILE_STATUS)) {
            const s = `Fragment shader compilation failed: ${i.getShaderInfoLog(r)}`;
            throw new Error(s);
          }
          if (i.deleteShader(r), !i.getShaderParameter(a, i.COMPILE_STATUS)) {
            const s = `Vertex shader compilation failed: ${i.getShaderInfoLog(a)}`;
            throw new Error(s);
          }
          if (i.deleteShader(a), !i.getProgramParameter(o, i.LINK_STATUS)) {
            const s = `GL program linking failed: ${i.getProgramInfoLog(o)}`;
            throw new Error(s);
          }
          return o;
        }
        getUniformLocation(t) {
          const e = xt(this.currentProgram_);
          return this.uniformLocationsByProgram_[e] === void 0 && (this.uniformLocationsByProgram_[e] = {}), this.uniformLocationsByProgram_[e][t] === void 0 && (this.uniformLocationsByProgram_[e][t] = this.gl_.getUniformLocation(this.currentProgram_, t)), this.uniformLocationsByProgram_[e][t];
        }
        getAttributeLocation(t) {
          const e = xt(this.currentProgram_);
          return this.attribLocationsByProgram_[e] === void 0 && (this.attribLocationsByProgram_[e] = {}), this.attribLocationsByProgram_[e][t] === void 0 && (this.attribLocationsByProgram_[e][t] = this.gl_.getAttribLocation(this.currentProgram_, t)), this.attribLocationsByProgram_[e][t];
        }
        makeProjectionTransform(t, e) {
          const i = t.size, r = t.viewState.rotation, a = t.viewState.resolution, o = t.viewState.center;
          return Lr(e, 0, 0, 2 / (a * i[0]), 2 / (a * i[1]), -r, -o[0], -o[1]), e;
        }
        setUniformFloatValue(t, e) {
          this.gl_.uniform1f(this.getUniformLocation(t), e);
        }
        setUniformFloatVec2(t, e) {
          this.gl_.uniform2fv(this.getUniformLocation(t), e);
        }
        setUniformFloatVec4(t, e) {
          this.gl_.uniform4fv(this.getUniformLocation(t), e);
        }
        setUniformMatrixValue(t, e) {
          this.gl_.uniformMatrix4fv(this.getUniformLocation(t), false, e);
        }
        enableAttributeArray_(t, e, i, r, a) {
          const o = this.getAttributeLocation(t);
          o < 0 || (this.gl_.enableVertexAttribArray(o), this.gl_.vertexAttribPointer(o, e, i, false, r, a));
        }
        enableAttributes(t) {
          const e = Clt(t);
          let i = 0;
          for (let r = 0; r < t.length; r++) {
            const a = t[r];
            this.enableAttributeArray_(a.name, a.size, a.type || VO, e, i), i += a.size * $O(a.type);
          }
        }
        handleWebGLContextLost(t) {
          jc(this.bufferCache_), this.currentProgram_ = null, t.preventDefault();
        }
        handleWebGLContextRestored() {
          this.needsToBeRecreated_ = true;
        }
        needsToBeRecreated() {
          return this.needsToBeRecreated_;
        }
        createTexture(t, e, i, r) {
          const a = this.gl_;
          i = i || a.createTexture();
          const o = r ? a.NEAREST : a.LINEAR;
          a.bindTexture(a.TEXTURE_2D, i), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, o), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, o), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);
          const s = 0, l = a.RGBA, u = 0, h = a.RGBA, c = a.UNSIGNED_BYTE;
          return e instanceof Uint8Array ? a.texImage2D(a.TEXTURE_2D, s, l, t[0], t[1], u, h, c, e) : e ? a.texImage2D(a.TEXTURE_2D, s, l, h, c, e) : a.texImage2D(a.TEXTURE_2D, s, l, t[0], t[1], u, h, c, null), i;
        }
      }
      function Clt(n) {
        let t = 0;
        for (let e = 0; e < n.length; e++) {
          const i = n[e];
          t += i.size * $O(i.type);
        }
        return t;
      }
      function $O(n) {
        switch (n) {
          case Fn.UNSIGNED_BYTE:
            return Uint8Array.BYTES_PER_ELEMENT;
          case Fn.UNSIGNED_SHORT:
            return Uint16Array.BYTES_PER_ELEMENT;
          case Fn.UNSIGNED_INT:
            return Uint32Array.BYTES_PER_ELEMENT;
          case Fn.FLOAT:
          default:
            return Float32Array.BYTES_PER_ELEMENT;
        }
      }
      class op extends wF {
        constructor(t, e) {
          super(t), e = e || {}, this.inversePixelTransform_ = an(), this.postProcesses_ = e.postProcesses, this.uniforms_ = e.uniforms, this.helper, this.onMapChanged_ = () => {
            this.clearCache(), this.removeHelper();
          }, t.addChangeListener(Oe.MAP, this.onMapChanged_), this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this), this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);
        }
        dispatchPreComposeEvent(t, e) {
          const i = this.getLayer();
          if (i.hasListener(si.PRECOMPOSE)) {
            const r = new BA(si.PRECOMPOSE, void 0, e, t);
            i.dispatchEvent(r);
          }
        }
        dispatchPostComposeEvent(t, e) {
          const i = this.getLayer();
          if (i.hasListener(si.POSTCOMPOSE)) {
            const r = new BA(si.POSTCOMPOSE, void 0, e, t);
            i.dispatchEvent(r);
          }
        }
        reset(t) {
          this.uniforms_ = t.uniforms, this.helper && this.helper.setUniforms(this.uniforms_);
        }
        removeHelper() {
          this.helper && (this.helper.dispose(), delete this.helper);
        }
        prepareFrame(t) {
          if (this.getLayer().getRenderSource()) {
            let e = true, i = -1, r;
            for (let o = 0, s = t.layerStatesArray.length; o < s; o++) {
              const l = t.layerStatesArray[o].layer, u = l.getRenderer();
              if (!(u instanceof op)) {
                e = true;
                continue;
              }
              const h = l.getClassName();
              if ((e || h !== r) && (i += 1, e = false), r = h, u === this) break;
            }
            const a = "map/" + t.mapId + "/group/" + i;
            (!this.helper || !this.helper.canvasCacheKeyMatches(a) || this.helper.needsToBeRecreated()) && (this.removeHelper(), this.helper = new wlt({ postProcesses: this.postProcesses_, uniforms: this.uniforms_, canvasCacheKey: a }), r && (this.helper.getCanvas().className = r), this.afterHelperCreated());
          }
          return this.prepareFrameInternal(t);
        }
        afterHelperCreated() {
        }
        prepareFrameInternal(t) {
          return true;
        }
        clearCache() {
        }
        disposeInternal() {
          var t;
          this.clearCache(), this.removeHelper(), (t = this.getLayer()) == null || t.removeChangeListener(Oe.MAP, this.onMapChanged_), super.disposeInternal();
        }
        dispatchRenderEvent_(t, e, i) {
          const r = this.getLayer();
          if (r.hasListener(t)) {
            Lr(this.inversePixelTransform_, 0, 0, i.pixelRatio, -i.pixelRatio, 0, 0, -i.size[1]);
            const a = new BA(t, this.inversePixelTransform_, i, e);
            r.dispatchEvent(a);
          }
        }
        preRender(t, e) {
          this.dispatchRenderEvent_(si.PRERENDER, t, e);
        }
        postRender(t, e) {
          this.dispatchRenderEvent_(si.POSTRENDER, t, e);
        }
      }
      const Slt = { TILE_TRANSFORM: "u_tileTransform", TRANSITION_ALPHA: "u_transitionAlpha", DEPTH: "u_depth", RENDER_EXTENT: "u_renderExtent", PATTERN_ORIGIN: "u_patternOrigin", RESOLUTION: "u_resolution", ZOOM: "u_zoom", GLOBAL_ALPHA: "u_globalAlpha", PROJECTION_MATRIX: "u_projectionMatrix", SCREEN_TO_WORLD_MATRIX: "u_screenToWorldMatrix" };
      function ZO(n) {
        return 1 / (n + 2);
      }
      function blt() {
        return { tileIds: /* @__PURE__ */ new Set(), representationsByZ: {} };
      }
      function KO(n, t) {
        return n.tileIds.has(xt(t));
      }
      function JO(n, t, e) {
        const i = n.representationsByZ;
        e in i || (i[e] = /* @__PURE__ */ new Set()), i[e].add(t), n.tileIds.add(xt(t.tile));
      }
      function MC(n, t) {
        const e = n.layerStatesArray[n.layerIndex];
        e.extent && (t = oi(t, zi(e.extent, n.viewState.projection)));
        const i = e.layer.getRenderSource();
        if (!i.getWrapX()) {
          const r = i.getTileGridForProjection(n.viewState.projection).getExtent();
          r && (t = oi(t, r));
        }
        return t;
      }
      function DC(n, t) {
        return `${n.getKey()},${n.getRevision()},${If(t)}`;
      }
      class Tlt extends op {
        constructor(t, e) {
          super(t, { uniforms: e.uniforms, postProcesses: e.postProcesses }), this.renderComplete = false, this.tileTransform_ = an(), this.tempMat4 = ih(), this.tempTileRange_ = new Jm(0, 0, 0, 0), this.tempTileCoord_ = Ef(0, 0, 0), this.tempSize_ = [0, 0];
          const i = e.cacheSize !== void 0 ? e.cacheSize : 512;
          this.tileRepresentationCache = new WF(i), this.frameState = null, this.renderedProjection_ = void 0;
        }
        reset(t) {
          super.reset({ uniforms: t.uniforms });
        }
        prepareFrameInternal(t) {
          this.renderedProjection_ ? t.viewState.projection !== this.renderedProjection_ && (this.clearCache(), this.renderedProjection_ = t.viewState.projection) : this.renderedProjection_ = t.viewState.projection;
          const i = this.getLayer().getRenderSource();
          return !i || ps(MC(t, t.extent)) ? false : i.getState() === "ready";
        }
        createTileRepresentation(t) {
          return zt();
        }
        enqueueTiles(t, e, i, r, a) {
          const o = t.viewState, s = this.getLayer(), l = s.getRenderSource(), u = l.getTileGridForProjection(o.projection), h = l.getGutterForProjection(o.projection), c = xt(l);
          c in t.wantedTiles || (t.wantedTiles[c] = {});
          const f = t.wantedTiles[c], g = this.tileRepresentationCache, d = s.getMapInternal(), A = Math.max(i - a, u.getMinZoom(), u.getZForResolution(Math.min(s.getMaxResolution(), d ? d.getView().getResolutionForZoom(Math.max(s.getMinZoom(), 0)) : u.getResolution(0)), l.zDirection));
          for (let p = i; p >= A; --p) {
            const v = u.getTileRangeForExtentAndZ(e, p, this.tempTileRange_), y = u.getResolution(p);
            for (let m = v.minX; m <= v.maxX; ++m) for (let _ = v.minY; _ <= v.maxY; ++_) {
              const I = Ef(p, m, _, this.tempTileCoord_), E = DC(l, I);
              let x, w;
              if (g.containsKey(E) && (x = g.get(E), w = x.tile), (!x || x.tile.key !== l.getKey()) && (w = l.getTile(p, m, _, t.pixelRatio, o.projection), !w) || KO(r, w)) continue;
              x ? x.setTile(w) : (x = this.createTileRepresentation({ tile: w, grid: u, helper: this.helper, gutter: h }), g.set(E, x)), JO(r, x, p);
              const C = w.getKey();
              f[C] = true, w.getState() === At.IDLE && (t.tileQueue.isKeyQueued(C) || t.tileQueue.enqueue([w, c, u.getTileCoordCenter(I), y]));
            }
          }
        }
        beforeTilesRender(t, e) {
          this.helper.prepareDraw(this.frameState, !e, true);
        }
        beforeTilesMaskRender(t) {
          return false;
        }
        renderTile(t, e, i, r, a, o, s, l, u, h, c) {
        }
        renderTileMask(t, e, i, r) {
        }
        drawTile_(t, e, i, r, a, o, s) {
          if (!e.ready) return;
          const u = e.tile.tileCoord, h = If(u), c = h in o ? o[h] : 1, f = s.getResolution(i), g = Rn(s.getTileSize(i), this.tempSize_), d = s.getOrigin(i), A = s.getTileCoordExtent(u), p = c < 1 ? -1 : ZO(i);
          c < 1 && (t.animate = true);
          const v = t.viewState, y = v.center[0], m = v.center[1], _ = g[0] + 2 * r, I = g[1] + 2 * r, E = _ / I, x = (y - d[0]) / (g[0] * f), w = (d[1] - m) / (g[1] * f), C = v.resolution / f, S = u[1], b = u[2];
          LZ(this.tileTransform_), kP(this.tileTransform_, 2 / (t.size[0] * C / _), -2 / (t.size[1] * C / _)), PZ(this.tileTransform_, v.rotation), kP(this.tileTransform_, 1, 1 / E), Ix(this.tileTransform_, (g[0] * (S - x) - r) / _, (g[1] * (b - w) - r) / I), this.renderTile(e, this.tileTransform_, t, a, f, g, d, A, p, r, c);
        }
        renderFrame(t) {
          this.frameState = t, this.renderComplete = true;
          const e = this.helper.getGL();
          this.preRender(e, t);
          const i = t.viewState, r = this.getLayer(), a = r.getRenderSource(), o = a.getTileGridForProjection(i.projection), s = a.getGutterForProjection(i.projection), l = MC(t, t.extent), u = o.getZForResolution(i.resolution, a.zDirection), h = blt(), c = r.getPreload();
          if (t.nextExtent) {
            const m = o.getZForResolution(i.nextResolution, a.zDirection), _ = MC(t, t.nextExtent);
            this.enqueueTiles(t, _, m, h, c);
          }
          this.enqueueTiles(t, l, u, h, 0), c > 0 && setTimeout(() => {
            this.enqueueTiles(t, l, u - 1, h, c - 1);
          }, 0);
          const f = {};
          let g = false;
          const d = h.representationsByZ;
          if (u in d) {
            const m = xt(this), _ = t.time;
            for (const I of d[u]) {
              const E = I.tile;
              if ((E instanceof Uf || E instanceof M0) && E.getState() === At.EMPTY) continue;
              const x = E.tileCoord;
              if (I.ready) {
                const S = E.getAlpha(m, _);
                if (S === 1) {
                  E.endTransition(m);
                  continue;
                }
                g = true;
                const b = If(x);
                f[b] = S;
              }
              if (this.renderComplete = false, this.findAltTiles_(o, x, u + 1, h)) continue;
              const C = o.getMinZoom();
              for (let S = u - 1; S >= C && !this.findAltTiles_(o, x, S, h); --S) ;
            }
          }
          const A = Object.keys(d).map(Number).sort(ho);
          if (this.beforeTilesMaskRender(t)) for (let m = 0, _ = A.length; m < _; ++m) {
            const I = A[m];
            for (const E of d[I]) {
              const x = E.tile.tileCoord;
              if (If(x) in f) continue;
              const C = o.getTileCoordExtent(x);
              this.renderTileMask(E, I, C, ZO(I));
            }
          }
          this.beforeTilesRender(t, g);
          for (let m = 0, _ = A.length; m < _; ++m) {
            const I = A[m];
            for (const E of d[I]) {
              const x = E.tile.tileCoord;
              If(x) in f || this.drawTile_(t, E, I, s, l, f, o);
            }
          }
          if (u in d) for (const m of d[u]) {
            const _ = m.tile.tileCoord;
            If(_) in f && this.drawTile_(t, m, u, s, l, f, o);
          }
          this.beforeFinalize(t), this.helper.finalizeDraw(t, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
          const v = this.helper.getCanvas(), y = this.tileRepresentationCache;
          for (; y.canExpireCache(); ) y.pop().dispose();
          return this.postRender(e, t), v;
        }
        beforeFinalize(t) {
        }
        findAltTiles_(t, e, i, r) {
          const a = t.getTileRangeForTileCoordAndZ(e, i, this.tempTileRange_);
          if (!a) return false;
          let o = true;
          const s = this.tileRepresentationCache, l = this.getLayer().getRenderSource();
          for (let u = a.minX; u <= a.maxX; ++u) for (let h = a.minY; h <= a.maxY; ++h) {
            const c = DC(l, [i, u, h]);
            let f = false;
            if (s.containsKey(c)) {
              const g = s.get(c);
              g.ready && !KO(r, g.tile) && (JO(r, g, i), f = true);
            }
            f || (o = false);
          }
          return o;
        }
        clearCache() {
          super.clearCache();
          const t = this.tileRepresentationCache;
          t.forEach((e) => e.dispose()), t.clear();
        }
        afterHelperCreated() {
          super.afterHelperCreated(), this.tileRepresentationCache.forEach((t) => t.setHelper(this.helper));
        }
        disposeInternal() {
          super.disposeInternal(), delete this.frameState;
        }
      }
      const le = Qt(rt({}, Slt), { TILE_TEXTURE_ARRAY: "u_tileTextures", TEXTURE_PIXEL_WIDTH: "u_texturePixelWidth", TEXTURE_PIXEL_HEIGHT: "u_texturePixelHeight", TEXTURE_RESOLUTION: "u_textureResolution", TEXTURE_ORIGIN_X: "u_textureOriginX", TEXTURE_ORIGIN_Y: "u_textureOriginY" }), N0 = { TEXTURE_COORD: "a_textureCoord" }, Blt = [{ name: N0.TEXTURE_COORD, size: 2, type: Fn.FLOAT }];
      class Mlt extends Tlt {
        constructor(t, e) {
          super(t, e), this.program_, this.vertexShader_ = e.vertexShader, this.fragmentShader_ = e.fragmentShader, this.indices_ = new Vf(rp, BC), this.indices_.fromArray([0, 1, 3, 1, 2, 3]), this.paletteTextures_ = e.paletteTextures || [];
        }
        reset(t) {
          if (super.reset(t), this.helper) {
            const e = this.helper.getGL();
            for (const i of this.paletteTextures_) i.delete(e);
          }
          if (this.vertexShader_ = t.vertexShader, this.fragmentShader_ = t.fragmentShader, this.paletteTextures_ = t.paletteTextures || [], this.helper) {
            this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
            const e = this.helper.getGL();
            for (const i of this.paletteTextures_) i.getTexture(e);
          }
        }
        afterHelperCreated() {
          super.afterHelperCreated();
          const t = this.helper.getGL();
          for (const e of this.paletteTextures_) e.getTexture(t);
          this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_), this.helper.flushBufferData(this.indices_);
        }
        removeHelper() {
          if (this.helper) {
            const t = this.helper.getGL();
            for (const e of this.paletteTextures_) e.delete(t);
          }
          super.removeHelper();
        }
        createTileRepresentation(t) {
          return new ylt(t);
        }
        beforeTilesRender(t, e) {
          super.beforeTilesRender(t, e), this.helper.useProgram(this.program_, t);
        }
        renderTile(t, e, i, r, a, o, s, l, u, h, c) {
          const f = this.helper.getGL();
          this.helper.bindBuffer(t.coords), this.helper.bindBuffer(this.indices_), this.helper.enableAttributes(Blt);
          let g = 0;
          for (; g < t.textures.length; ) {
            const E = `${le.TILE_TEXTURE_ARRAY}[${g}]`;
            this.helper.bindTexture(t.textures[g], g, E), ++g;
          }
          for (let E = 0; E < this.paletteTextures_.length; ++E) {
            const x = this.paletteTextures_[E], w = x.getTexture(f);
            this.helper.bindTexture(w, g, x.name), ++g;
          }
          const d = i.viewState, A = o[0] + 2 * h, p = o[1] + 2 * h, y = t.tile.tileCoord, m = y[1], _ = y[2];
          this.helper.setUniformMatrixValue(le.TILE_TRANSFORM, B0(this.tempMat4, e)), this.helper.setUniformFloatValue(le.TRANSITION_ALPHA, c), this.helper.setUniformFloatValue(le.DEPTH, u);
          let I = r;
          h > 0 && (I = l, oi(I, r, I)), this.helper.setUniformFloatVec4(le.RENDER_EXTENT, I), this.helper.setUniformFloatValue(le.RESOLUTION, d.resolution), this.helper.setUniformFloatValue(le.ZOOM, d.zoom), this.helper.setUniformFloatValue(le.TEXTURE_PIXEL_WIDTH, A), this.helper.setUniformFloatValue(le.TEXTURE_PIXEL_HEIGHT, p), this.helper.setUniformFloatValue(le.TEXTURE_RESOLUTION, a), this.helper.setUniformFloatValue(le.TEXTURE_ORIGIN_X, s[0] + m * o[0] * a - h * a), this.helper.setUniformFloatValue(le.TEXTURE_ORIGIN_Y, s[1] - _ * o[1] * a + h * a), this.helper.drawElements(0, this.indices_.getSize());
        }
        getData(t) {
          if (!this.helper.getGL()) return null;
          const i = this.frameState;
          if (!i) return null;
          const r = this.getLayer(), a = nn(i.pixelToCoordinateTransform, t.slice()), o = i.viewState, s = r.getExtent();
          if (s && !Jr(zi(s, o.projection), a)) return null;
          const l = r.getSources(Mn([a]), o.resolution);
          let u, h, c;
          for (u = l.length - 1; u >= 0; --u) if (h = l[u], h.getState() === "ready") {
            if (c = h.getTileGridForProjection(o.projection), h.getWrapX()) break;
            const g = c.getExtent();
            if (!g || Jr(g, a)) break;
          }
          if (u < 0) return null;
          const f = this.tileRepresentationCache;
          for (let g = c.getZForResolution(o.resolution); g >= c.getMinZoom(); --g) {
            const d = c.getTileCoordForCoordAndZ(a, g), A = DC(h, d);
            if (!f.containsKey(A)) continue;
            const p = f.get(A), v = p.tile;
            if ((v instanceof Uf || v instanceof M0) && v.getState() === At.EMPTY) return null;
            if (!p.loaded) continue;
            const y = c.getOrigin(g), m = Rn(c.getTileSize(g)), _ = c.getResolution(g), I = (a[0] - y[0]) / _ - d[1] * m[0], E = (y[1] - a[1]) / _ - d[2] * m[1];
            return p.getPixelData(I, E);
          }
          return null;
        }
        disposeInternal() {
          const t = this.helper;
          if (t) {
            const e = t.getGL();
            for (const i of this.paletteTextures_) i.delete(e);
            this.paletteTextures_.length = 0, e.deleteProgram(this.program_), delete this.program_, t.deleteBuffer(this.indices_);
          }
          super.disposeInternal(), delete this.indices_;
        }
      }
      class Dlt {
        constructor(t, e) {
          this.name = t, this.data = e, this.texture_ = null;
        }
        getTexture(t) {
          if (!this.texture_) {
            const e = t.createTexture();
            t.bindTexture(t.TEXTURE_2D, e), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, this.data.length / 4, 1, 0, t.RGBA, t.UNSIGNED_BYTE, this.data), this.texture_ = e;
          }
          return this.texture_;
        }
        delete(t) {
          this.texture_ && t.deleteTexture(this.texture_), this.texture_ = null;
        }
      }
      function Rlt(n, t) {
        return `operator_${n}_${Object.keys(t.functions).length}`;
      }
      function rh(n) {
        const t = n.toString();
        return t.includes(".") ? t : t + ".0";
      }
      function RC(n) {
        if (n.length < 2 || n.length > 4) throw new Error("`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.");
        return `vec${n.length}(${n.map(rh).join(", ")})`;
      }
      function F0(n) {
        const t = ia(n), e = t.length > 3 ? t[3] : 1;
        return RC([t[0] / 255, t[1] / 255, t[2] / 255, e]);
      }
      function Llt(n) {
        const t = Rn(n);
        return RC(t);
      }
      const LC = {};
      let Plt = 0;
      function qf(n) {
        return n in LC || (LC[n] = Plt++), LC[n];
      }
      function Ds(n) {
        return rh(qf(n));
      }
      function PC(n) {
        return "u_var_" + n;
      }
      function NC() {
        return { inFragmentShader: false, variables: {}, properties: {}, functions: {}, bandCount: 0, featureId: false, geometryType: false };
      }
      const FC = "getBandValue", tQ = "u_paletteTextures", eQ = "featureId", nQ = "geometryType";
      function Nlt(n, t, e, i) {
        const r = li(n, t, e);
        return kC(r, t, i);
      }
      function Qe(n) {
        return (t, e, i) => {
          const r = e.args.length, a = new Array(r);
          for (let o = 0; o < r; ++o) a[o] = kC(e.args[o], i, t);
          return n(a, t);
        };
      }
      const Flt = { [H.Get]: (n, t) => {
        const i = t.args[0].value;
        return i in n.properties || (n.properties[i] = { name: i, type: t.type }), (n.inFragmentShader ? "v_prop_" : "a_prop_") + i;
      }, [H.Id]: (n) => (n.featureId = true, (n.inFragmentShader ? "v_" : "a_") + eQ), [H.GeometryType]: (n) => (n.geometryType = true, (n.inFragmentShader ? "v_" : "a_") + nQ), [H.LineMetric]: () => "currentLineMetric", [H.Var]: (n, t) => {
        const i = t.args[0].value;
        return i in n.variables || (n.variables[i] = { name: i, type: t.type }), PC(i);
      }, [H.Resolution]: () => "u_resolution", [H.Zoom]: () => "u_zoom", [H.Time]: () => "u_time", [H.Any]: Qe((n) => `(${n.join(" || ")})`), [H.All]: Qe((n) => `(${n.join(" && ")})`), [H.Not]: Qe(([n]) => `(!${n})`), [H.Equal]: Qe(([n, t]) => `(${n} == ${t})`), [H.NotEqual]: Qe(([n, t]) => `(${n} != ${t})`), [H.GreaterThan]: Qe(([n, t]) => `(${n} > ${t})`), [H.GreaterThanOrEqualTo]: Qe(([n, t]) => `(${n} >= ${t})`), [H.LessThan]: Qe(([n, t]) => `(${n} < ${t})`), [H.LessThanOrEqualTo]: Qe(([n, t]) => `(${n} <= ${t})`), [H.Multiply]: Qe((n) => `(${n.join(" * ")})`), [H.Divide]: Qe(([n, t]) => `(${n} / ${t})`), [H.Add]: Qe((n) => `(${n.join(" + ")})`), [H.Subtract]: Qe(([n, t]) => `(${n} - ${t})`), [H.Clamp]: Qe(([n, t, e]) => `clamp(${n}, ${t}, ${e})`), [H.Mod]: Qe(([n, t]) => `mod(${n}, ${t})`), [H.Pow]: Qe(([n, t]) => `pow(${n}, ${t})`), [H.Abs]: Qe(([n]) => `abs(${n})`), [H.Floor]: Qe(([n]) => `floor(${n})`), [H.Ceil]: Qe(([n]) => `ceil(${n})`), [H.Round]: Qe(([n]) => `floor(${n} + 0.5)`), [H.Sin]: Qe(([n]) => `sin(${n})`), [H.Cos]: Qe(([n]) => `cos(${n})`), [H.Atan]: Qe(([n, t]) => t !== void 0 ? `atan(${n}, ${t})` : `atan(${n})`), [H.Sqrt]: Qe(([n]) => `sqrt(${n})`), [H.Match]: Qe((n) => {
        const t = n[0], e = n[n.length - 1];
        let i = null;
        for (let r = n.length - 3; r >= 1; r -= 2) {
          const a = n[r], o = n[r + 1];
          i = `(${t} == ${a} ? ${o} : ${i || e})`;
        }
        return i;
      }), [H.Between]: Qe(([n, t, e]) => `(${n} >= ${t} && ${n} <= ${e})`), [H.Interpolate]: Qe(([n, t, ...e]) => {
        let i = "";
        for (let r = 0; r < e.length - 2; r += 2) {
          const a = e[r], o = i || e[r + 1], s = e[r + 2], l = e[r + 3];
          let u;
          n === rh(1) ? u = `(${t} - ${a}) / (${s} - ${a})` : u = `(pow(${n}, (${t} - ${a})) - 1.0) / (pow(${n}, (${s} - ${a})) - 1.0)`, i = `mix(${o}, ${l}, clamp(${u}, 0.0, 1.0))`;
        }
        return i;
      }), [H.Case]: Qe((n) => {
        const t = n[n.length - 1];
        let e = null;
        for (let i = n.length - 3; i >= 0; i -= 2) {
          const r = n[i], a = n[i + 1];
          e = `(${r} ? ${a} : ${e || t})`;
        }
        return e;
      }), [H.In]: Qe(([n, ...t], e) => {
        const i = Rlt("in", e), r = [];
        for (let a = 0; a < t.length; a += 1) r.push(`  if (inputValue == ${t[a]}) { return true; }`);
        return e.functions[i] = `bool ${i}(float inputValue) {
${r.join(`
`)}
  return false;
}`, `${i}(${n})`;
      }), [H.Array]: Qe((n) => `vec${n.length}(${n.join(", ")})`), [H.Color]: Qe((n) => {
        if (n.length === 1) return `vec4(vec3(${n[0]} / 255.0), 1.0)`;
        if (n.length === 2) return `vec4(vec3(${n[0]} / 255.0), ${n[1]})`;
        const t = n.slice(0, 3).map((i) => `${i} / 255.0`);
        if (n.length === 3) return `vec4(${t.join(", ")}, 1.0)`;
        const e = n[3];
        return `vec4(${t.join(", ")}, ${e})`;
      }), [H.Band]: Qe(([n, t, e], i) => {
        if (!(FC in i.functions)) {
          let r = "";
          const a = i.bandCount || 1;
          for (let o = 0; o < a; o++) {
            const s = Math.floor(o / 4);
            let l = o % 4;
            o === a - 1 && l === 1 && (l = 3);
            const u = `${le.TILE_TEXTURE_ARRAY}[${s}]`;
            r += `  if (band == ${o + 1}.0) {
    return texture2D(${u}, v_textureCoord + vec2(dx, dy))[${l}];
  }
`;
          }
          i.functions[FC] = `float getBandValue(float band, float xOffset, float yOffset) {
  float dx = xOffset / ${le.TEXTURE_PIXEL_WIDTH};
  float dy = yOffset / ${le.TEXTURE_PIXEL_HEIGHT};
${r}
}`;
        }
        return `${FC}(${n}, ${t != null ? t : "0.0"}, ${e != null ? e : "0.0"})`;
      }), [H.Palette]: (n, t) => {
        const [e, ...i] = t.args, r = i.length, a = new Uint8Array(r * 4);
        for (let u = 0; u < i.length; u++) {
          const h = i[u].value, c = ia(h), f = u * 4;
          a[f] = c[0], a[f + 1] = c[1], a[f + 2] = c[2], a[f + 3] = c[3] * 255;
        }
        n.paletteTextures || (n.paletteTextures = []);
        const o = `${tQ}[${n.paletteTextures.length}]`, s = new Dlt(o, a);
        n.paletteTextures.push(s);
        const l = kC(e, Bt, n);
        return `texture2D(${o}, vec2((${l} + 0.5) / ${r}.0, 0.5))`;
      } };
      function kC(n, t, e) {
        if (n instanceof sF) {
          const i = Flt[n.operator];
          if (i === void 0) throw new Error(`No compiler defined for this operator: ${JSON.stringify(n.operator)}`);
          return i(e, n, t);
        }
        if ((n.type & Bt) > 0) return rh(n.value);
        if ((n.type & vi) > 0) return n.value.toString();
        if ((n.type & Wn) > 0) return Ds(n.value.toString());
        if ((n.type & hn) > 0) return F0(n.value);
        if ((n.type & Gi) > 0) return RC(n.value);
        if ((n.type & za) > 0) return Llt(n.value);
        throw new Error(`Unexpected expression ${n.value} (expected type ${ff(t)})`);
      }
      const iQ = 0.985;
      function rQ(n, t) {
        t = t || [];
        const e = 256, i = e - 1;
        return t[0] = Math.floor(n / e / e / e) / i, t[1] = Math.floor(n / e / e) % e / i, t[2] = Math.floor(n / e) % e / i, t[3] = n % e / i, t;
      }
      function aQ(n) {
        let t = 0;
        const e = 256, i = e - 1;
        return t += Math.round(n[0] * e * e * e * i), t += Math.round(n[1] * e * e * i), t += Math.round(n[2] * e * i), t += Math.round(n[3] * i), t;
      }
      function OC() {
        return { "fill-color": "rgba(255,255,255,0.4)", "stroke-color": "#3399CC", "stroke-width": 1.25, "circle-radius": 5, "circle-fill-color": "rgba(255,255,255,0.4)", "circle-stroke-width": 1.25, "circle-stroke-color": "#3399CC" };
      }
      const Hf = `#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform mat4 u_projectionMatrix;
uniform mat4 u_screenToWorldMatrix;
uniform vec2 u_viewportSizePx;
uniform float u_pixelRatio;
uniform float u_globalAlpha;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
uniform float u_rotation;
uniform vec4 u_renderExtent;
uniform vec2 u_patternOrigin;
uniform float u_depth;
uniform mediump int u_hitDetection;

const float PI = 3.141592653589793238;
const float TWO_PI = 2.0 * PI;
float currentLineMetric = 0.; // an actual value will be used in the stroke shaders
`, Yf = OC();
      class oQ {
        constructor() {
          this.uniforms_ = [], this.attributes_ = [], this.varyings_ = [], this.hasSymbol_ = false, this.symbolSizeExpression_ = `vec2(${rh(Yf["circle-radius"])} + ${rh(Yf["circle-stroke-width"] * 0.5)})`, this.symbolRotationExpression_ = "0.0", this.symbolOffsetExpression_ = "vec2(0.0)", this.symbolColorExpression_ = F0(Yf["circle-fill-color"]), this.texCoordExpression_ = "vec4(0.0, 0.0, 1.0, 1.0)", this.discardExpression_ = "false", this.symbolRotateWithView_ = false, this.hasStroke_ = false, this.strokeWidthExpression_ = rh(Yf["stroke-width"]), this.strokeColorExpression_ = F0(Yf["stroke-color"]), this.strokeOffsetExpression_ = "0.", this.strokeCapExpression_ = Ds("round"), this.strokeJoinExpression_ = Ds("round"), this.strokeMiterLimitExpression_ = "10.", this.strokeDistanceFieldExpression_ = "-1000.", this.hasFill_ = false, this.fillColorExpression_ = F0(Yf["fill-color"]), this.vertexShaderFunctions_ = [], this.fragmentShaderFunctions_ = [];
        }
        addUniform(t) {
          return this.uniforms_.push(t), this;
        }
        addAttribute(t) {
          return this.attributes_.push(t), this;
        }
        addVarying(t, e, i) {
          return this.varyings_.push({ name: t, type: e, expression: i }), this;
        }
        setSymbolSizeExpression(t) {
          return this.hasSymbol_ = true, this.symbolSizeExpression_ = t, this;
        }
        getSymbolSizeExpression() {
          return this.symbolSizeExpression_;
        }
        setSymbolRotationExpression(t) {
          return this.symbolRotationExpression_ = t, this;
        }
        setSymbolOffsetExpression(t) {
          return this.symbolOffsetExpression_ = t, this;
        }
        getSymbolOffsetExpression() {
          return this.symbolOffsetExpression_;
        }
        setSymbolColorExpression(t) {
          return this.hasSymbol_ = true, this.symbolColorExpression_ = t, this;
        }
        getSymbolColorExpression() {
          return this.symbolColorExpression_;
        }
        setTextureCoordinateExpression(t) {
          return this.texCoordExpression_ = t, this;
        }
        setFragmentDiscardExpression(t) {
          return this.discardExpression_ = t, this;
        }
        getFragmentDiscardExpression() {
          return this.discardExpression_;
        }
        setSymbolRotateWithView(t) {
          return this.symbolRotateWithView_ = t, this;
        }
        setStrokeWidthExpression(t) {
          return this.hasStroke_ = true, this.strokeWidthExpression_ = t, this;
        }
        setStrokeColorExpression(t) {
          return this.hasStroke_ = true, this.strokeColorExpression_ = t, this;
        }
        getStrokeColorExpression() {
          return this.strokeColorExpression_;
        }
        setStrokeOffsetExpression(t) {
          return this.strokeOffsetExpression_ = t, this;
        }
        setStrokeCapExpression(t) {
          return this.strokeCapExpression_ = t, this;
        }
        setStrokeJoinExpression(t) {
          return this.strokeJoinExpression_ = t, this;
        }
        setStrokeMiterLimitExpression(t) {
          return this.strokeMiterLimitExpression_ = t, this;
        }
        setStrokeDistanceFieldExpression(t) {
          return this.strokeDistanceFieldExpression_ = t, this;
        }
        setFillColorExpression(t) {
          return this.hasFill_ = true, this.fillColorExpression_ = t, this;
        }
        getFillColorExpression() {
          return this.fillColorExpression_;
        }
        addVertexShaderFunction(t) {
          this.vertexShaderFunctions_.includes(t) || this.vertexShaderFunctions_.push(t);
        }
        addFragmentShaderFunction(t) {
          this.fragmentShaderFunctions_.includes(t) || this.fragmentShaderFunctions_.push(t);
        }
        getSymbolVertexShader() {
          return this.hasSymbol_ ? `${Hf}
${this.uniforms_.map(function(t) {
            return "uniform " + t + ";";
          }).join(`
`)}
attribute vec2 a_position;
attribute float a_index;
attribute vec4 a_hitColor;
${this.attributes_.map(function(t) {
            return "attribute " + t + ";";
          }).join(`
`)}
varying vec2 v_texCoord;
varying vec2 v_quadCoord;
varying vec4 v_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;
${this.varyings_.map(function(t) {
            return "varying " + t.type + " " + t.name + ";";
          }).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
vec2 pxToScreen(vec2 coordPx) {
  vec2 scaled = coordPx / u_viewportSizePx / 0.5;
  return scaled;
}

vec2 screenToPx(vec2 coordScreen) {
  return (coordScreen * 0.5 + 0.5) * u_viewportSizePx;
}

void main(void) {
  v_quadSizePx = ${this.symbolSizeExpression_};
  vec2 halfSizePx = v_quadSizePx * 0.5;
  vec2 centerOffsetPx = ${this.symbolOffsetExpression_};
  vec2 offsetPx = centerOffsetPx;
  if (a_index == 0.0) {
    offsetPx -= halfSizePx;
  } else if (a_index == 1.0) {
    offsetPx += halfSizePx * vec2(1., -1.);
  } else if (a_index == 2.0) {
    offsetPx += halfSizePx;
  } else {
    offsetPx += halfSizePx * vec2(-1., 1.);
  }
  float angle = ${this.symbolRotationExpression_};
  ${this.symbolRotateWithView_ ? "angle += u_rotation;" : ""}
  float c = cos(-angle);
  float s = sin(-angle);
  offsetPx = vec2(c * offsetPx.x - s * offsetPx.y, s * offsetPx.x + c * offsetPx.y);
  vec4 center = u_projectionMatrix * vec4(a_position, 0.0, 1.0);
  gl_Position = center + vec4(pxToScreen(offsetPx), u_depth, 0.);
  vec4 texCoord = ${this.texCoordExpression_};
  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;
  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;
  v_texCoord = vec2(u, v);
  v_hitColor = a_hitColor;
  v_angle = angle;
  c = cos(-v_angle);
  s = sin(-v_angle);
  centerOffsetPx = vec2(c * centerOffsetPx.x - s * centerOffsetPx.y, s * centerOffsetPx.x + c * centerOffsetPx.y); 
  v_centerPx = screenToPx(center.xy) + centerOffsetPx;
${this.varyings_.map(function(t) {
            return "  " + t.name + " = " + t.expression + ";";
          }).join(`
`)}
}` : null;
        }
        getSymbolFragmentShader() {
          return this.hasSymbol_ ? `${Hf}
${this.uniforms_.map(function(t) {
            return "uniform " + t + ";";
          }).join(`
`)}
varying vec2 v_texCoord;
varying vec4 v_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;
${this.varyings_.map(function(t) {
            return "varying " + t.type + " " + t.name + ";";
          }).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}

void main(void) {
  if (${this.discardExpression_}) { discard; }
  vec2 coordsPx = gl_FragCoord.xy / u_pixelRatio - v_centerPx; // relative to center
  float c = cos(v_angle);
  float s = sin(v_angle);
  coordsPx = vec2(c * coordsPx.x - s * coordsPx.y, s * coordsPx.x + c * coordsPx.y);
  gl_FragColor = ${this.symbolColorExpression_};
  gl_FragColor.rgb *= gl_FragColor.a;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.05) { discard; };
    gl_FragColor = v_hitColor;
  }
}` : null;
        }
        getStrokeVertexShader() {
          return this.hasStroke_ ? `${Hf}
${this.uniforms_.map(function(t) {
            return "uniform " + t + ";";
          }).join(`
`)}
attribute vec2 a_segmentStart;
attribute vec2 a_segmentEnd;
attribute float a_measureStart;
attribute float a_measureEnd;
attribute float a_parameters;
attribute float a_distance;
attribute vec2 a_joinAngles;
attribute vec4 a_hitColor;
${this.attributes_.map(function(t) {
            return "attribute " + t + ";";
          }).join(`
`)}
varying vec2 v_segmentStart;
varying vec2 v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_hitColor;
varying float v_distanceOffsetPx;
varying float v_measureStart;
varying float v_measureEnd;
${this.varyings_.map(function(t) {
            return "varying " + t.type + " " + t.name + ";";
          }).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

vec4 pxToScreen(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return vec4(screenPos, u_depth, 1.0);
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

vec2 getJoinOffsetDirection(vec2 normalPx, float joinAngle) {
  float halfAngle = joinAngle / 2.0;
  float c = cos(halfAngle);
  float s = sin(halfAngle);
  vec2 angleBisectorNormal = vec2(s * normalPx.x + c * normalPx.y, -c * normalPx.x + s * normalPx.y);
  float length = 1.0 / s;
  return angleBisectorNormal * length;
}

vec2 getOffsetPoint(vec2 point, vec2 normal, float joinAngle, float offsetPx) {
  // if on a cap or the join angle is too high, offset the line along the segment normal
  if (cos(joinAngle) > 0.998 || isCap(joinAngle)) {
    return point - normal * offsetPx;
  }
  // offset is applied along the inverted normal (positive offset goes "right" relative to line direction)
  return point - getJoinOffsetDirection(normal, joinAngle) * offsetPx;
}

void main(void) {
  v_angleStart = a_joinAngles.x;
  v_angleEnd = a_joinAngles.y;
  float vertexNumber = floor(abs(a_parameters) / 10000. + 0.5);
  currentLineMetric = vertexNumber < 1.5 ? a_measureStart : a_measureEnd;
  // we're reading the fractional part while keeping the sign (so -4.12 gives -0.12, 3.45 gives 0.45)
  float angleTangentSum = fract(abs(a_parameters) / 10000.) * 10000. * sign(a_parameters);

  float lineWidth = ${this.strokeWidthExpression_};
  float lineOffsetPx = ${this.strokeOffsetExpression_};

  // compute segment start/end in px with offset
  vec2 segmentStartPx = worldToPx(a_segmentStart);
  vec2 segmentEndPx = worldToPx(a_segmentEnd);
  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);
  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);
  segmentStartPx = getOffsetPoint(segmentStartPx, normalPx, v_angleStart, lineOffsetPx),
  segmentEndPx = getOffsetPoint(segmentEndPx, normalPx, v_angleEnd, lineOffsetPx);
  
  // compute current vertex position
  float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;
  float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;
  float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;
  vec2 joinDirection;
  vec2 positionPx = vertexNumber < 1.5 ? segmentStartPx : segmentEndPx;
  // if angle is too high, do not make a proper join
  if (cos(angle) > ${iQ} || isCap(angle)) {
    joinDirection = normalPx * normalDir - tangentPx * tangentDir;
  } else {
    joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);
  }
  positionPx = positionPx + joinDirection * (lineWidth * 0.5 + 1.); // adding 1 pixel for antialiasing
  gl_Position = pxToScreen(positionPx);

  v_segmentStart = segmentStartPx;
  v_segmentEnd = segmentEndPx;
  v_width = lineWidth;
  v_hitColor = a_hitColor;
  v_distanceOffsetPx = a_distance / u_resolution - (lineOffsetPx * angleTangentSum);
  v_measureStart = a_measureStart;
  v_measureEnd = a_measureEnd;
${this.varyings_.map(function(t) {
            return "  " + t.name + " = " + t.expression + ";";
          }).join(`
`)}
}` : null;
        }
        getStrokeFragmentShader() {
          return this.hasStroke_ ? `${Hf}
${this.uniforms_.map(function(t) {
            return "uniform " + t + ";";
          }).join(`
`)}
varying vec2 v_segmentStart;
varying vec2 v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_hitColor;
varying float v_distanceOffsetPx;
varying float v_measureStart;
varying float v_measureEnd;
${this.varyings_.map(function(t) {
            return "varying " + t.type + " " + t.name + ";";
          }).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}

vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

float segmentDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  vec2 tangent = normalize(end - start);
  vec2 normal = vec2(-tangent.y, tangent.x);
  vec2 startToPoint = point - start;
  return abs(dot(startToPoint, normal)) - width * 0.5;
}

float buttCapDistanceField(vec2 point, vec2 start, vec2 end) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  return dot(startToPoint, -tangent);
}

float squareCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return buttCapDistanceField(point, start, end) - width * 0.5;
}

float roundCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  float onSegment = max(0., 1000. * dot(point - start, end - start)); // this is very high when inside the segment
  return length(point - start) - width * 0.5 - onSegment;
}

float roundJoinDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return roundCapDistanceField(point, start, end, width);
}

float bevelJoinField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  float c = cos(joinAngle * 0.5);
  float s = sin(joinAngle * 0.5);
  float direction = -sign(sin(joinAngle));
  vec2 bisector = vec2(c * tangent.x - s * tangent.y, s * tangent.x + c * tangent.y);
  float radius = width * 0.5 * s;
  return dot(startToPoint, bisector * direction) - radius;
}

float miterJoinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  if (cos(joinAngle) > ${iQ}) { // avoid risking a division by zero
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  float miterLength = 1. / sin(joinAngle * 0.5);
  float miterLimit = ${this.strokeMiterLimitExpression_};
  if (miterLength > miterLimit) {
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  return -1000.;
}

float capDistanceField(vec2 point, vec2 start, vec2 end, float width, float capType) {
   if (capType == ${Ds("butt")}) {
    return buttCapDistanceField(point, start, end);
  } else if (capType == ${Ds("square")}) {
    return squareCapDistanceField(point, start, end, width);
  }
  return roundCapDistanceField(point, start, end, width);
}

float joinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float joinType) {
  if (joinType == ${Ds("bevel")}) {
    return bevelJoinField(point, start, end, width, joinAngle);
  } else if (joinType == ${Ds("miter")}) {
    return miterJoinDistanceField(point, start, end, width, joinAngle);
  }
  return roundJoinDistanceField(point, start, end, width);
}

float computeSegmentPointDistance(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float capType, float joinType) {
  if (isCap(joinAngle)) {
    return capDistanceField(point, start, end, width, capType);
  }
  return joinDistanceField(point, start, end, width, joinAngle, joinType);
}

void main(void) {
  vec2 currentPoint = gl_FragCoord.xy / u_pixelRatio;
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(currentPoint);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif

  float segmentLength = length(v_segmentEnd - v_segmentStart);
  vec2 segmentTangent = (v_segmentEnd - v_segmentStart) / segmentLength;
  vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);
  vec2 startToPoint = currentPoint - v_segmentStart;
  float lengthToPoint = max(0., min(dot(segmentTangent, startToPoint), segmentLength));
  float currentLengthPx = lengthToPoint + v_distanceOffsetPx; 
  float currentRadiusPx = abs(dot(segmentNormal, startToPoint));
  float currentRadiusRatio = dot(segmentNormal, startToPoint) * 2. / v_width;
  currentLineMetric = mix(v_measureStart, v_measureEnd, lengthToPoint / segmentLength);

  if (${this.discardExpression_}) { discard; }

  vec4 color = ${this.strokeColorExpression_};
  float capType = ${this.strokeCapExpression_};
  float joinType = ${this.strokeJoinExpression_};
  float segmentStartDistance = computeSegmentPointDistance(currentPoint, v_segmentStart, v_segmentEnd, v_width, v_angleStart, capType, joinType);
  float segmentEndDistance = computeSegmentPointDistance(currentPoint, v_segmentEnd, v_segmentStart, v_width, v_angleEnd, capType, joinType);
  float distance = max(
    segmentDistanceField(currentPoint, v_segmentStart, v_segmentEnd, v_width),
    max(segmentStartDistance, segmentEndDistance)
  );
  distance = max(distance, ${this.strokeDistanceFieldExpression_});
  color.a *= smoothstep(0.5, -0.5, distance);
  gl_FragColor = color;
  gl_FragColor.a *= u_globalAlpha;
  gl_FragColor.rgb *= gl_FragColor.a;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_hitColor;
  }
}` : null;
        }
        getFillVertexShader() {
          return this.hasFill_ ? `${Hf}
${this.uniforms_.map(function(t) {
            return "uniform " + t + ";";
          }).join(`
`)}
attribute vec2 a_position;
attribute vec4 a_hitColor;
${this.attributes_.map(function(t) {
            return "attribute " + t + ";";
          }).join(`
`)}
varying vec4 v_hitColor;
${this.varyings_.map(function(t) {
            return "varying " + t.type + " " + t.name + ";";
          }).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
void main(void) {
  gl_Position = u_projectionMatrix * vec4(a_position, u_depth, 1.0);
  v_hitColor = a_hitColor;
${this.varyings_.map(function(t) {
            return "  " + t.name + " = " + t.expression + ";";
          }).join(`
`)}
}` : null;
        }
        getFillFragmentShader() {
          return this.hasFill_ ? `${Hf}
${this.uniforms_.map(function(t) {
            return "uniform " + t + ";";
          }).join(`
`)}
varying vec4 v_hitColor;
${this.varyings_.map(function(t) {
            return "varying " + t.type + " " + t.name + ";";
          }).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}
vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

void main(void) {
  vec2 pxPos = gl_FragCoord.xy / u_pixelRatio;
  vec2 pxOrigin = worldToPx(u_patternOrigin);
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(pxPos);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif
  if (${this.discardExpression_}) { discard; }
  gl_FragColor = ${this.fillColorExpression_};
  gl_FragColor.a *= u_globalAlpha;
  gl_FragColor.rgb *= gl_FragColor.a;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_hitColor;
  }
}` : null;
        }
      }
      function te(n, t, e) {
        const i = Tw();
        return Nlt(t, e, i, n);
      }
      function klt(n) {
        const t = ia(n), e = t[0] * 256, i = t[1], r = t[2] * 256, a = Math.round(t[3] * 255);
        return [e + i, r + a];
      }
      const Olt = `vec4 unpackColor(vec2 packedColor) {
  return vec4(
    fract(floor(packedColor[0] / 256.0) / 256.0),
    fract(packedColor[0] / 256.0),
    fract(floor(packedColor[1] / 256.0) / 256.0),
    fract(packedColor[1] / 256.0)
  );
}`;
      function QC(n) {
        return n === hn || n === za ? 2 : n === Gi ? 4 : 1;
      }
      function k0(n) {
        const t = QC(n);
        return t > 1 ? `vec${t}` : "float";
      }
      function O0(n) {
        return (JSON.stringify(n).split("").reduce((e, i) => (e << 5) - e + i.charCodeAt(0), 0) >>> 0).toString();
      }
      function zC(n, t, e, i) {
        if (`${i}radius` in n && i !== "icon-") {
          let r = te(e, n[`${i}radius`], Bt);
          if (`${i}radius2` in n) {
            const a = te(e, n[`${i}radius2`], Bt);
            r = `max(${r}, ${a})`;
          }
          `${i}stroke-width` in n && (r = `(${r} + ${te(e, n[`${i}stroke-width`], Bt)} * 0.5)`), t.setSymbolSizeExpression(`vec2(${r} * 2. + 0.5)`);
        }
        if (`${i}scale` in n) {
          const r = te(e, n[`${i}scale`], za);
          t.setSymbolSizeExpression(`${t.getSymbolSizeExpression()} * ${r}`);
        }
        `${i}displacement` in n && t.setSymbolOffsetExpression(te(e, n[`${i}displacement`], Gi)), `${i}rotation` in n && t.setSymbolRotationExpression(te(e, n[`${i}rotation`], Bt)), `${i}rotate-with-view` in n && t.setSymbolRotateWithView(!!n[`${i}rotate-with-view`]);
      }
      function sQ(n, t, e, i, r) {
        let a = "vec4(0.)";
        if (t !== null && (a = t), e !== null && i !== null) {
          const l = `smoothstep(-${i} + 0.63, -${i} - 0.58, ${n})`;
          a = `mix(${e}, ${a}, ${l})`;
        }
        const o = `(1.0 - smoothstep(-0.63, 0.58, ${n}))`;
        let s = `${a} * vec4(1.0, 1.0, 1.0, ${o})`;
        return r !== null && (s = `${s} * vec4(1.0, 1.0, 1.0, ${r})`), s;
      }
      function GC(n, t, e, i, r) {
        const a = new Image();
        a.crossOrigin = n[`${i}cross-origin`] === void 0 ? "anonymous" : n[`${i}cross-origin`], a.src = n[`${i}src`], e[`u_texture${r}_size`] = () => a.complete ? [a.width, a.height] : [0, 0], t.addUniform(`vec2 u_texture${r}_size`);
        const o = `u_texture${r}_size`;
        return e[`u_texture${r}`] = a, t.addUniform(`sampler2D u_texture${r}`), o;
      }
      function UC(n, t, e, i, r) {
        let a = te(e, n[`${t}offset`], Gi);
        if (`${t}offset-origin` in n) switch (n[`${t}offset-origin`]) {
          case "top-right":
            a = `vec2(${i}.x, 0.) + ${r} * vec2(-1., 0.) + ${a} * vec2(-1., 1.)`;
            break;
          case "bottom-left":
            a = `vec2(0., ${i}.y) + ${r} * vec2(0., -1.) + ${a} * vec2(1., -1.)`;
            break;
          case "bottom-right":
            a = `${i} - ${r} - ${a}`;
            break;
        }
        return a;
      }
      function Qlt(n, t, e, i, r) {
        r.functions.circleDistanceField = `float circleDistanceField(vec2 point, float radius) {
  return length(point) - radius;
}`, zC(n, t, i, "circle-");
        let a = null;
        "circle-opacity" in n && (a = te(r, n["circle-opacity"], Bt));
        let o = "coordsPx";
        "circle-scale" in n && (o = `coordsPx / ${te(r, n["circle-scale"], za)}`);
        let s = null;
        "circle-fill-color" in n && (s = te(r, n["circle-fill-color"], hn));
        let l = null;
        "circle-stroke-color" in n && (l = te(r, n["circle-stroke-color"], hn));
        let u = te(r, n["circle-radius"], Bt), h = null;
        "circle-stroke-width" in n && (h = te(r, n["circle-stroke-width"], Bt), u = `(${u} + ${h} * 0.5)`);
        const c = `circleDistanceField(${o}, ${u})`, f = sQ(c, s, l, h, a);
        t.setSymbolColorExpression(f);
      }
      function zlt(n, t, e, i, r) {
        r.functions.round = `float round(float v) {
  return sign(v) * floor(abs(v) + 0.5);
}`, r.functions.starDistanceField = `float starDistanceField(vec2 point, float numPoints, float radius, float radius2, float angle) {
  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle
  float c = cos(startAngle);
  float s = sin(startAngle);
  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);
  float alpha = TWO_PI / numPoints; // the angle of one sector
  float beta = atan(pointRotated.y, pointRotated.x);
  float gamma = round(beta / alpha) * alpha; // angle in sector
  c = cos(-gamma);
  s = sin(-gamma);
  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));
  vec2 tipToPoint = inSector + vec2(-radius, 0.);
  vec2 edgeNormal = vec2(radius2 * sin(alpha * 0.5), -radius2 * cos(alpha * 0.5) + radius);
  return dot(normalize(edgeNormal), tipToPoint);
}`, r.functions.regularDistanceField = `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {
  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle
  float c = cos(startAngle);
  float s = sin(startAngle);
  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);
  float alpha = TWO_PI / numPoints; // the angle of one sector
  float radiusIn = radius * cos(PI / numPoints);
  float beta = atan(pointRotated.y, pointRotated.x);
  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid
  c = cos(-gamma);
  s = sin(-gamma);
  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));
  return inSector.x - radiusIn;
}`, zC(n, t, i, "shape-");
        let a = null;
        "shape-opacity" in n && (a = te(r, n["shape-opacity"], Bt));
        let o = "coordsPx";
        "shape-scale" in n && (o = `coordsPx / ${te(r, n["shape-scale"], za)}`);
        let s = null;
        "shape-fill-color" in n && (s = te(r, n["shape-fill-color"], hn));
        let l = null;
        "shape-stroke-color" in n && (l = te(r, n["shape-stroke-color"], hn));
        let u = null;
        "shape-stroke-width" in n && (u = te(r, n["shape-stroke-width"], Bt));
        const h = te(r, n["shape-points"], Bt);
        let c = "0.";
        "shape-angle" in n && (c = te(r, n["shape-angle"], Bt));
        let f, g = te(r, n["shape-radius"], Bt);
        if (u !== null && (g = `${g} + ${u} * 0.5`), "shape-radius2" in n) {
          let A = te(r, n["shape-radius2"], Bt);
          u !== null && (A = `${A} + ${u} * 0.5`), f = `starDistanceField(${o}, ${h}, ${g}, ${A}, ${c})`;
        } else f = `regularDistanceField(${o}, ${h}, ${g}, ${c})`;
        const d = sQ(f, s, l, u, a);
        t.setSymbolColorExpression(d);
      }
      function Glt(n, t, e, i, r) {
        let a = "vec4(1.0)";
        "icon-color" in n && (a = te(r, n["icon-color"], hn)), "icon-opacity" in n && (a = `${a} * vec4(1.0, 1.0, 1.0, ${te(r, n["icon-opacity"], Bt)})`);
        const o = O0(n["icon-src"]), s = GC(n, t, e, "icon-", o);
        if (t.setSymbolColorExpression(`${a} * texture2D(u_texture${o}, v_texCoord)`).setSymbolSizeExpression(s), "icon-width" in n && "icon-height" in n && t.setSymbolSizeExpression(`vec2(${te(i, n["icon-width"], Bt)}, ${te(i, n["icon-height"], Bt)})`), "icon-offset" in n && "icon-size" in n) {
          const l = te(i, n["icon-size"], Gi), u = t.getSymbolSizeExpression();
          t.setSymbolSizeExpression(l);
          const h = UC(n, "icon-", i, "v_quadSizePx", l);
          t.setTextureCoordinateExpression(`(vec4((${h}).xyxy) + vec4(0., 0., ${l})) / (${u}).xyxy`);
        }
        if (zC(n, t, i, "icon-"), "icon-anchor" in n) {
          const l = te(i, n["icon-anchor"], Gi);
          let u = "1.0";
          "icon-scale" in n && (u = te(i, n["icon-scale"], za));
          let h;
          n["icon-anchor-x-units"] === "pixels" && n["icon-anchor-y-units"] === "pixels" ? h = `${l} * ${u}` : n["icon-anchor-x-units"] === "pixels" ? h = `${l} * vec2(vec2(${u}).x, v_quadSizePx.y)` : n["icon-anchor-y-units"] === "pixels" ? h = `${l} * vec2(v_quadSizePx.x, vec2(${u}).x)` : h = `${l} * v_quadSizePx`;
          let c = `v_quadSizePx * vec2(0.5, -0.5) + ${h} * vec2(-1., 1.)`;
          if ("icon-anchor-origin" in n) switch (n["icon-anchor-origin"]) {
            case "top-right":
              c = `v_quadSizePx * -0.5 + ${h}`;
              break;
            case "bottom-left":
              c = `v_quadSizePx * 0.5 - ${h}`;
              break;
            case "bottom-right":
              c = `v_quadSizePx * vec2(-0.5, 0.5) + ${h} * vec2(1., -1.)`;
              break;
          }
          t.setSymbolOffsetExpression(`${t.getSymbolOffsetExpression()} + ${c}`);
        }
      }
      function Ult(n, t, e, i, r) {
        if ("stroke-color" in n && t.setStrokeColorExpression(te(r, n["stroke-color"], hn)), "stroke-pattern-src" in n) {
          const a = O0(n["stroke-pattern-src"]), o = GC(n, t, e, "stroke-pattern-", a);
          let s = o, l = "vec2(0.)";
          "stroke-pattern-offset" in n && "stroke-pattern-size" in n && (s = te(r, n["stroke-pattern-size"], Gi), l = UC(n, "stroke-pattern-", r, o, s));
          let u = "0.";
          "stroke-pattern-spacing" in n && (u = te(r, n["stroke-pattern-spacing"], Bt)), r.functions.sampleStrokePattern = `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {
  float currentLengthScaled = currentLengthPx * sampleSize.y / lineWidth;
  float spacingScaled = spacingPx * sampleSize.y / lineWidth;
  float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));
  // make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels
  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);
  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;
  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;
  return texture2D(texture, texCoord);
}`;
          const h = `u_texture${a}`;
          let c = "1.";
          "stroke-color" in n && (c = t.getStrokeColorExpression()), t.setStrokeColorExpression(`${c} * sampleStrokePattern(${h}, ${o}, ${l}, ${s}, ${u}, currentLengthPx, currentRadiusRatio, v_width)`);
        }
        if ("stroke-width" in n && t.setStrokeWidthExpression(te(i, n["stroke-width"], Bt)), "stroke-offset" in n && t.setStrokeOffsetExpression(te(i, n["stroke-offset"], Bt)), "stroke-line-cap" in n && t.setStrokeCapExpression(te(i, n["stroke-line-cap"], Wn)), "stroke-line-join" in n && t.setStrokeJoinExpression(te(i, n["stroke-line-join"], Wn)), "stroke-miter-limit" in n && t.setStrokeMiterLimitExpression(te(i, n["stroke-miter-limit"], Bt)), "stroke-line-dash" in n) {
          r.functions.getSingleDashDistance = `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {
  float localDistance = mod(distance, dashLengthTotal);
  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;
  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);
  if (capType == ${Ds("square")}) {
    distanceSegment -= v_width * 0.5;
  } else if (capType == ${Ds("round")}) {
    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);
  }
  return distanceSegment;
}`;
          let a = n["stroke-line-dash"].map((g) => te(r, g, Bt));
          a.length % 2 === 1 && (a = [...a, ...a]);
          let o = "0.";
          "stroke-line-dash-offset" in n && (o = te(i, n["stroke-line-dash-offset"], Bt));
          const l = `dashDistanceField_${O0(n["stroke-line-dash"])}`, u = a.map((g, d) => `float dashLength${d} = ${g};`), h = a.map((g, d) => `dashLength${d}`).join(" + ");
          let c = "0.", f = `getSingleDashDistance(distance, radius, ${c}, dashLength0, totalDashLength, capType)`;
          for (let g = 2; g < a.length; g += 2) c = `${c} + dashLength${g - 2} + dashLength${g - 1}`, f = `min(${f}, getSingleDashDistance(distance, radius, ${c}, dashLength${g}, totalDashLength, capType))`;
          r.functions[l] = `float ${l}(float distance, float radius, float capType) {
  ${u.join(`
  `)}
  float totalDashLength = ${h};
  return ${f};
}`, t.setStrokeDistanceFieldExpression(`${l}(currentLengthPx + ${o}, currentRadiusPx, capType)`);
        }
      }
      function Vlt(n, t, e, i, r) {
        if ("fill-color" in n && t.setFillColorExpression(te(r, n["fill-color"], hn)), "fill-pattern-src" in n) {
          const a = O0(n["fill-pattern-src"]), o = GC(n, t, e, "fill-pattern-", a);
          let s = o, l = "vec2(0.)";
          "fill-pattern-offset" in n && "fill-pattern-size" in n && (s = te(r, n["fill-pattern-size"], Gi), l = UC(n, "fill-pattern-", r, o, s)), r.functions.sampleFillPattern = `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {
  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);
  vec2 pxRelativePos = pxPosition - pxOrigin;
  // rotate the relative position from origin by the current view rotation
  pxRelativePos = vec2(pxRelativePos.x * cos(u_rotation) - pxRelativePos.y * sin(u_rotation), pxRelativePos.x * sin(u_rotation) + pxRelativePos.y * cos(u_rotation));
  // sample position is computed according to the sample offset & size
  vec2 samplePos = mod(pxRelativePos / scaleRatio, sampleSize);
  // also make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels
  samplePos = clamp(samplePos, vec2(0.5), sampleSize - vec2(0.5));
  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright
  return texture2D(texture, (samplePos + textureOffset) / textureSize);
}`;
          const u = `u_texture${a}`;
          let h = "1.";
          "fill-color" in n && (h = t.getFillColorExpression()), t.setFillColorExpression(`${h} * sampleFillPattern(${u}, ${o}, ${l}, ${s}, pxOrigin, pxPos)`);
        }
      }
      function jlt(n, t) {
        const e = NC(), i = Qt(rt({}, NC()), { inFragmentShader: true, variables: e.variables }), r = new oQ(), a = {};
        if ("icon-src" in n ? Glt(n, r, a, e, i) : "shape-points" in n ? zlt(n, r, a, e, i) : "circle-radius" in n && Qlt(n, r, a, e, i), Ult(n, r, a, e, i), Vlt(n, r, a, e, i), n.filter) {
          const l = te(i, n.filter, vi);
          r.setFragmentDiscardExpression(`!${l}`);
        }
        for (const l in i.variables) {
          const u = i.variables[l], h = PC(u.name);
          let c = k0(u.type);
          u.type === hn && (c = "vec4"), r.addUniform(`${c} ${h}`), a[h] = () => {
            const f = t[u.name];
            return typeof f == "number" ? f : typeof f == "boolean" ? f ? 1 : 0 : u.type === hn ? ia(f || "#eee") : typeof f == "string" ? qf(f) : f;
          };
        }
        for (const l in i.properties) {
          const u = i.properties[l];
          e.properties[l] || (e.properties[l] = u);
          let h = k0(u.type), c = `a_prop_${u.name}`;
          u.type === hn && (h = "vec4", c = `unpackColor(${c})`, r.addVertexShaderFunction(Olt)), r.addVarying(`v_prop_${u.name}`, h, c);
        }
        for (const l in e.properties) {
          const u = e.properties[l];
          r.addAttribute(`${k0(u.type)} a_prop_${u.name}`);
        }
        for (const l in e.functions) r.addVertexShaderFunction(e.functions[l]);
        for (const l in i.functions) r.addFragmentShaderFunction(i.functions[l]);
        const o = {};
        for (const l in e.properties) {
          const u = e.properties[l], h = (c) => {
            const f = c.get(u.name);
            return u.type === hn ? klt([...ia(f || "#eee")]) : typeof f == "string" ? qf(f) : typeof f == "boolean" ? f ? 1 : 0 : f;
          };
          o[`prop_${u.name}`] = { size: QC(u.type), callback: h };
        }
        function s(l, u, h, c) {
          const f = e[l], g = i[l];
          if (!f && !g) return;
          const d = k0(h), A = QC(h);
          r.addAttribute(`${d} a_${u}`), g && r.addVarying(`v_${u}`, d, `a_${u}`), o[u] = { size: A, callback: c };
        }
        return s("geometryType", nQ, Wn, (l) => qf(Bw(l.getGeometry()))), s("featureId", eQ, Wn | Bt, (l) => {
          var h;
          const u = (h = l.getId()) != null ? h : null;
          return typeof u == "string" ? qf(u) : u;
        }), { builder: r, attributes: o, uniforms: a };
      }
      function lQ(n, t) {
        const e = `
    attribute vec2 ${N0.TEXTURE_COORD};
    uniform mat4 ${le.TILE_TRANSFORM};
    uniform float ${le.TEXTURE_PIXEL_WIDTH};
    uniform float ${le.TEXTURE_PIXEL_HEIGHT};
    uniform float ${le.TEXTURE_RESOLUTION};
    uniform float ${le.TEXTURE_ORIGIN_X};
    uniform float ${le.TEXTURE_ORIGIN_Y};
    uniform float ${le.DEPTH};

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;

    void main() {
      v_textureCoord = ${N0.TEXTURE_COORD};
      v_mapCoord = vec2(
        ${le.TEXTURE_ORIGIN_X} + ${le.TEXTURE_RESOLUTION} * ${le.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],
        ${le.TEXTURE_ORIGIN_Y} - ${le.TEXTURE_RESOLUTION} * ${le.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]
      );
      gl_Position = ${le.TILE_TRANSFORM} * vec4(${N0.TEXTURE_COORD}, ${le.DEPTH}, 1.0);
    }
  `, i = Qt(rt({}, NC()), { inFragmentShader: true, bandCount: t }), r = [];
        if (n.color !== void 0) {
          const c = te(i, n.color, hn);
          r.push(`color = ${c};`);
        }
        if (n.contrast !== void 0) {
          const c = te(i, n.contrast, Bt);
          r.push(`color.rgb = clamp((${c} + 1.0) * color.rgb - (${c} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);
        }
        if (n.exposure !== void 0) {
          const c = te(i, n.exposure, Bt);
          r.push(`color.rgb = clamp((${c} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);
        }
        if (n.saturation !== void 0) {
          const c = te(i, n.saturation, Bt);
          r.push(`
      float saturation = ${c} + 1.0;
      float sr = (1.0 - saturation) * 0.2126;
      float sg = (1.0 - saturation) * 0.7152;
      float sb = (1.0 - saturation) * 0.0722;
      mat3 saturationMatrix = mat3(
        sr + saturation, sr, sr,
        sg, sg + saturation, sg,
        sb, sb, sb + saturation
      );
      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
    `);
        }
        if (n.gamma !== void 0) {
          const c = te(i, n.gamma, Bt);
          r.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${c}));`);
        }
        if (n.brightness !== void 0) {
          const c = te(i, n.brightness, Bt);
          r.push(`color.rgb = clamp(color.rgb + ${c}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);
        }
        const a = {}, o = Object.keys(i.variables).length;
        if (o > 1 && !n.variables) throw new Error(`Missing variables in style (expected ${i.variables})`);
        for (let c = 0; c < o; ++c) {
          const f = i.variables[Object.keys(i.variables)[c]];
          if (!(f.name in n.variables)) throw new Error(`Missing '${f.name}' in style variables`);
          const g = PC(f.name);
          a[g] = function() {
            let d = n.variables[f.name];
            return typeof d == "string" && (d = qf(d)), d !== void 0 ? d : -9999999;
          };
        }
        const s = Object.keys(a).map(function(c) {
          return `uniform float ${c};`;
        }), l = Math.ceil(t / 4);
        s.push(`uniform sampler2D ${le.TILE_TEXTURE_ARRAY}[${l}];`), i.paletteTextures && s.push(`uniform sampler2D ${tQ}[${i.paletteTextures.length}];`);
        const u = Object.keys(i.functions).map(function(c) {
          return i.functions[c];
        }), h = `
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;
    uniform vec4 ${le.RENDER_EXTENT};
    uniform float ${le.TRANSITION_ALPHA};
    uniform float ${le.TEXTURE_PIXEL_WIDTH};
    uniform float ${le.TEXTURE_PIXEL_HEIGHT};
    uniform float ${le.RESOLUTION};
    uniform float ${le.ZOOM};

    ${s.join(`
`)}

    ${u.join(`
`)}

    void main() {
      if (
        v_mapCoord[0] < ${le.RENDER_EXTENT}[0] ||
        v_mapCoord[1] < ${le.RENDER_EXTENT}[1] ||
        v_mapCoord[0] > ${le.RENDER_EXTENT}[2] ||
        v_mapCoord[1] > ${le.RENDER_EXTENT}[3]
      ) {
        discard;
      }

      vec4 color = texture2D(${le.TILE_TEXTURE_ARRAY}[0],  v_textureCoord);

      ${r.join(`
`)}

      gl_FragColor = color;
      gl_FragColor.rgb *= gl_FragColor.a;
      gl_FragColor *= ${le.TRANSITION_ALPHA};
    }`;
        return { vertexShader: e, fragmentShader: h, uniforms: a, paletteTextures: i.paletteTextures };
      }
      class VC extends PO {
        constructor(t) {
          t = t ? Object.assign({}, t) : {};
          const e = t.style || {};
          delete t.style, super(t), this.sources_ = t.sources, this.renderedSource_ = null, this.renderedResolution_ = NaN, this.style_ = e, this.styleVariables_ = this.style_.variables || {}, this.addChangeListener(Oe.SOURCE, this.handleSourceUpdate_);
        }
        getSources(t, e) {
          const i = this.getSource();
          return this.sources_ ? typeof this.sources_ == "function" ? this.sources_(t, e) : this.sources_ : i ? [i] : [];
        }
        getRenderSource() {
          return this.renderedSource_ || this.getSource();
        }
        getSourceState() {
          const t = this.getRenderSource();
          return t ? t.getState() : "undefined";
        }
        handleSourceUpdate_() {
          this.hasRenderer() && this.getRenderer().clearCache();
          const t = this.getSource();
          if (t) if (t.getState() === "loading") {
            const e = () => {
              t.getState() === "ready" && (t.removeEventListener("change", e), this.setStyle(this.style_));
            };
            t.addEventListener("change", e);
          } else this.setStyle(this.style_);
        }
        getSourceBandCount_() {
          const t = Number.MAX_SAFE_INTEGER, e = this.getSources([-t, -t, t, t], t);
          return e && e.length && "bandCount" in e[0] ? e[0].bandCount : 4;
        }
        createRenderer() {
          const t = lQ(this.style_, this.getSourceBandCount_());
          return new Mlt(this, { vertexShader: t.vertexShader, fragmentShader: t.fragmentShader, uniforms: t.uniforms, cacheSize: this.getCacheSize(), paletteTextures: t.paletteTextures });
        }
        renderSources(t, e) {
          const i = this.getRenderer();
          let r;
          for (let a = 0, o = e.length; a < o; ++a) this.renderedSource_ = e[a], i.prepareFrame(t) && (r = i.renderFrame(t));
          return r;
        }
        render(t, e) {
          this.rendered = true;
          const i = t.viewState, r = this.getSources(t.extent, i.resolution);
          let a = true;
          for (let s = 0, l = r.length; s < l; ++s) {
            const u = r[s], h = u.getState();
            if (h == "loading") {
              const c = () => {
                u.getState() == "ready" && (u.removeEventListener("change", c), this.changed());
              };
              u.addEventListener("change", c);
            }
            a = a && h == "ready";
          }
          const o = this.renderSources(t, r);
          if (this.getRenderer().renderComplete && a) return this.renderedResolution_ = i.resolution, o;
          if (this.renderedResolution_ > 0.5 * i.resolution) {
            const s = this.getSources(t.extent, this.renderedResolution_).filter((l) => !r.includes(l));
            if (s.length > 0) return this.renderSources(t, s);
          }
          return o;
        }
        setStyle(t) {
          if (this.styleVariables_ = t.variables || {}, this.style_ = t, this.hasRenderer()) {
            const e = lQ(this.style_, this.getSourceBandCount_());
            this.getRenderer().reset({ vertexShader: e.vertexShader, fragmentShader: e.fragmentShader, uniforms: e.uniforms, paletteTextures: e.paletteTextures }), this.changed();
          }
        }
        updateStyleVariables(t) {
          Object.assign(this.styleVariables_, t), this.changed();
        }
      }
      VC.prototype.dispose;
      const Wf = { TILELOADSTART: "tileloadstart", TILELOADEND: "tileloadend", TILELOADERROR: "tileloaderror" }, Xf = [0, 0, 0], Ol = 5;
      class $f {
        constructor(t) {
          this.minZoom = t.minZoom !== void 0 ? t.minZoom : 0, this.resolutions_ = t.resolutions, ue(MZ(this.resolutions_, (r, a) => a - r), "`resolutions` must be sorted in descending order");
          let e;
          if (!t.origins) {
            for (let r = 0, a = this.resolutions_.length - 1; r < a; ++r) if (!e) e = this.resolutions_[r] / this.resolutions_[r + 1];
            else if (this.resolutions_[r] / this.resolutions_[r + 1] !== e) {
              e = void 0;
              break;
            }
          }
          this.zoomFactor_ = e, this.maxZoom = this.resolutions_.length - 1, this.origin_ = t.origin !== void 0 ? t.origin : null, this.origins_ = null, t.origins !== void 0 && (this.origins_ = t.origins, ue(this.origins_.length == this.resolutions_.length, "Number of `origins` and `resolutions` must be equal"));
          const i = t.extent;
          i !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = ur(i)), ue(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, "Either `origin` or `origins` must be configured, never both"), this.tileSizes_ = null, t.tileSizes !== void 0 && (this.tileSizes_ = t.tileSizes, ue(this.tileSizes_.length == this.resolutions_.length, "Number of `tileSizes` and `resolutions` must be equal")), this.tileSize_ = t.tileSize !== void 0 ? t.tileSize : this.tileSizes_ ? null : yw, ue(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, "Either `tileSize` or `tileSizes` must be configured, never both"), this.extent_ = i !== void 0 ? i : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], t.sizes !== void 0 ? this.fullTileRanges_ = t.sizes.map((r, a) => {
            const o = new Jm(Math.min(0, r[0]), Math.max(r[0] - 1, -1), Math.min(0, r[1]), Math.max(r[1] - 1, -1));
            if (i) {
              const s = this.getTileRangeForExtentAndZ(i, a);
              o.minX = Math.max(s.minX, o.minX), o.maxX = Math.min(s.maxX, o.maxX), o.minY = Math.max(s.minY, o.minY), o.maxY = Math.min(s.maxY, o.maxY);
            }
            return o;
          }) : i && this.calculateTileRanges_(i);
        }
        forEachTileCoord(t, e, i) {
          const r = this.getTileRangeForExtentAndZ(t, e);
          for (let a = r.minX, o = r.maxX; a <= o; ++a) for (let s = r.minY, l = r.maxY; s <= l; ++s) i([e, a, s]);
        }
        forEachTileCoordParentTileRange(t, e, i, r) {
          let a, o, s, l = null, u = t[0] - 1;
          for (this.zoomFactor_ === 2 ? (o = t[1], s = t[2]) : l = this.getTileCoordExtent(t, r); u >= this.minZoom; ) {
            if (o !== void 0 && s !== void 0 ? (o = Math.floor(o / 2), s = Math.floor(s / 2), a = xf(o, o, s, s, i)) : a = this.getTileRangeForExtentAndZ(l, u, i), e(u, a)) return true;
            --u;
          }
          return false;
        }
        getExtent() {
          return this.extent_;
        }
        getMaxZoom() {
          return this.maxZoom;
        }
        getMinZoom() {
          return this.minZoom;
        }
        getOrigin(t) {
          return this.origin_ ? this.origin_ : this.origins_[t];
        }
        getResolution(t) {
          return this.resolutions_[t];
        }
        getResolutions() {
          return this.resolutions_;
        }
        getTileCoordChildTileRange(t, e, i) {
          if (t[0] < this.maxZoom) {
            if (this.zoomFactor_ === 2) {
              const a = t[1] * 2, o = t[2] * 2;
              return xf(a, a + 1, o, o + 1, e);
            }
            const r = this.getTileCoordExtent(t, i || this.tmpExtent_);
            return this.getTileRangeForExtentAndZ(r, t[0] + 1, e);
          }
          return null;
        }
        getTileRangeForTileCoordAndZ(t, e, i) {
          if (e > this.maxZoom || e < this.minZoom) return null;
          const r = t[0], a = t[1], o = t[2];
          if (e === r) return xf(a, o, a, o, i);
          if (this.zoomFactor_) {
            const l = Math.pow(this.zoomFactor_, e - r), u = Math.floor(a * l), h = Math.floor(o * l);
            if (e < r) return xf(u, u, h, h, i);
            const c = Math.floor(l * (a + 1)) - 1, f = Math.floor(l * (o + 1)) - 1;
            return xf(u, c, h, f, i);
          }
          const s = this.getTileCoordExtent(t, this.tmpExtent_);
          return this.getTileRangeForExtentAndZ(s, e, i);
        }
        getTileRangeForExtentAndZ(t, e, i) {
          this.getTileCoordForXYAndZ_(t[0], t[3], e, false, Xf);
          const r = Xf[1], a = Xf[2];
          this.getTileCoordForXYAndZ_(t[2], t[1], e, true, Xf);
          const o = Xf[1], s = Xf[2];
          return xf(r, o, a, s, i);
        }
        getTileCoordCenter(t) {
          const e = this.getOrigin(t[0]), i = this.getResolution(t[0]), r = Rn(this.getTileSize(t[0]), this.tmpSize_);
          return [e[0] + (t[1] + 0.5) * r[0] * i, e[1] - (t[2] + 0.5) * r[1] * i];
        }
        getTileCoordExtent(t, e) {
          const i = this.getOrigin(t[0]), r = this.getResolution(t[0]), a = Rn(this.getTileSize(t[0]), this.tmpSize_), o = i[0] + t[1] * a[0] * r, s = i[1] - (t[2] + 1) * a[1] * r, l = o + a[0] * r, u = s + a[1] * r;
          return ta(o, s, l, u, e);
        }
        getTileCoordForCoordAndResolution(t, e, i) {
          return this.getTileCoordForXYAndResolution_(t[0], t[1], e, false, i);
        }
        getTileCoordForXYAndResolution_(t, e, i, r, a) {
          const o = this.getZForResolution(i), s = i / this.getResolution(o), l = this.getOrigin(o), u = Rn(this.getTileSize(o), this.tmpSize_);
          let h = s * (t - l[0]) / i / u[0], c = s * (l[1] - e) / i / u[1];
          return r ? (h = El(h, Ol) - 1, c = El(c, Ol) - 1) : (h = tf(h, Ol), c = tf(c, Ol)), Ef(o, h, c, a);
        }
        getTileCoordForXYAndZ_(t, e, i, r, a) {
          const o = this.getOrigin(i), s = this.getResolution(i), l = Rn(this.getTileSize(i), this.tmpSize_);
          let u = (t - o[0]) / s / l[0], h = (o[1] - e) / s / l[1];
          return r ? (u = El(u, Ol) - 1, h = El(h, Ol) - 1) : (u = tf(u, Ol), h = tf(h, Ol)), Ef(i, u, h, a);
        }
        getTileCoordForCoordAndZ(t, e, i) {
          return this.getTileCoordForXYAndZ_(t[0], t[1], e, false, i);
        }
        getTileCoordResolution(t) {
          return this.resolutions_[t[0]];
        }
        getTileSize(t) {
          return this.tileSize_ ? this.tileSize_ : this.tileSizes_[t];
        }
        getFullTileRange(t) {
          return this.fullTileRanges_ ? this.fullTileRanges_[t] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, t) : null;
        }
        getZForResolution(t, e) {
          const i = pl(this.resolutions_, t, e || 0);
          return Ze(i, this.minZoom, this.maxZoom);
        }
        tileCoordIntersectsViewport(t, e) {
          return xN(e, 0, e.length, 2, this.getTileCoordExtent(t));
        }
        calculateTileRanges_(t) {
          const e = this.resolutions_.length, i = new Array(e);
          for (let r = this.minZoom; r < e; ++r) i[r] = this.getTileRangeForExtentAndZ(t, r);
          this.fullTileRanges_ = i;
        }
      }
      function jC(n) {
        let t = n.getDefaultTileGrid();
        return t || (t = Ylt(n), n.setDefaultTileGrid(t)), t;
      }
      function qlt(n, t, e) {
        const i = t[0], r = n.getTileCoordCenter(t), a = Q0(e);
        if (!Jr(a, r)) {
          const o = he(a), s = Math.ceil((a[0] - r[0]) / o);
          return r[0] += o * s, n.getTileCoordForCoordAndZ(r, i);
        }
        return t;
      }
      function Hlt(n, t, e, i) {
        i = i !== void 0 ? i : "top-left";
        const r = hQ(n, t, e);
        return new $f({ extent: n, origin: OZ(n, i), resolutions: r, tileSize: e });
      }
      function uQ(n) {
        const t = n || {}, e = t.extent || qt("EPSG:3857").getExtent(), i = { extent: e, minZoom: t.minZoom, tileSize: t.tileSize, resolutions: hQ(e, t.maxZoom, t.tileSize, t.maxResolution) };
        return new $f(i);
      }
      function hQ(n, t, e, i) {
        t = t !== void 0 ? t : cJ, e = Rn(e !== void 0 ? e : yw);
        const r = dn(n), a = he(n);
        i = i > 0 ? i : Math.max(a / e[0], r / e[1]);
        const o = t + 1, s = new Array(o);
        for (let l = 0; l < o; ++l) s[l] = i / Math.pow(2, l);
        return s;
      }
      function Ylt(n, t, e, i) {
        const r = Q0(n);
        return Hlt(r, t, e, i);
      }
      function Q0(n) {
        n = qt(n);
        let t = n.getExtent();
        if (!t) {
          const e = 180 * $c.degrees / n.getMetersPerUnit();
          t = ta(-e, -e, e, e);
        }
        return t;
      }
      class cQ extends Fw {
        constructor(t) {
          super({ attributions: t.attributions, attributionsCollapsible: t.attributionsCollapsible, projection: t.projection, state: t.state, wrapX: t.wrapX, interpolate: t.interpolate }), this.on, this.once, this.un, this.tilePixelRatio_ = t.tilePixelRatio !== void 0 ? t.tilePixelRatio : 1, this.tileGrid = t.tileGrid !== void 0 ? t.tileGrid : null;
          const e = [256, 256];
          this.tileGrid && Rn(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), e), this.tmpSize = [0, 0], this.key_ = t.key || xt(this), this.tileOptions = { transition: t.transition, interpolate: t.interpolate }, this.zDirection = t.zDirection ? t.zDirection : 0;
        }
        getGutterForProjection(t) {
          return 0;
        }
        getKey() {
          return this.key_;
        }
        setKey(t) {
          this.key_ !== t && (this.key_ = t, this.changed());
        }
        getResolutions(t) {
          const e = t ? this.getTileGridForProjection(t) : this.tileGrid;
          return e ? e.getResolutions() : null;
        }
        getTile(t, e, i, r, a) {
          return zt();
        }
        getTileGrid() {
          return this.tileGrid;
        }
        getTileGridForProjection(t) {
          return this.tileGrid ? this.tileGrid : jC(t);
        }
        getTilePixelRatio(t) {
          return this.tilePixelRatio_;
        }
        getTilePixelSize(t, e, i) {
          const r = this.getTileGridForProjection(i), a = this.getTilePixelRatio(e), o = Rn(r.getTileSize(t), this.tmpSize);
          return a == 1 ? o : tJ(o, a, this.tmpSize);
        }
        getTileCoordForTileUrlFunction(t, e) {
          const i = e !== void 0 ? e : this.getProjection(), r = e !== void 0 ? this.getTileGridForProjection(i) : this.tileGrid || this.getTileGridForProjection(i);
          return this.getWrapX() && i.isGlobal() && (t = qlt(r, t, i)), Cet(t, r) ? t : null;
        }
        clear() {
        }
        refresh() {
          this.clear(), super.refresh();
        }
      }
      class fQ extends Te {
        constructor(t, e) {
          super(t), this.tile = e;
        }
      }
      function qC(n, t) {
        const e = [];
        Object.keys(t).forEach(function(r) {
          t[r] !== null && t[r] !== void 0 && e.push(r + "=" + encodeURIComponent(t[r]));
        });
        const i = e.join("&");
        return n = n.replace(/[?&]$/, ""), n += n.includes("?") ? "&" : "?", n + i;
      }
      const Wlt = /\{z\}/g, Xlt = /\{x\}/g, $lt = /\{y\}/g, Zlt = /\{-y\}/g;
      function Klt(n, t, e, i, r) {
        return n.replace(Wlt, t.toString()).replace(Xlt, e.toString()).replace($lt, i.toString()).replace(Zlt, function() {
          if (r === void 0) throw new Error("If the URL template has a {-y} placeholder, the grid extent must be known");
          return (r - i).toString();
        });
      }
      function Jlt(n) {
        const t = [];
        let e = /\{([a-z])-([a-z])\}/.exec(n);
        if (e) {
          const i = e[1].charCodeAt(0), r = e[2].charCodeAt(0);
          let a;
          for (a = i; a <= r; ++a) t.push(n.replace(e[0], String.fromCharCode(a)));
          return t;
        }
        if (e = /\{(\d+)-(\d+)\}/.exec(n), e) {
          const i = parseInt(e[2], 10);
          for (let r = parseInt(e[1], 10); r <= i; r++) t.push(n.replace(e[0], r.toString()));
          return t;
        }
        return t.push(n), t;
      }
      function tut(n, t) {
        return function(e, i, r) {
          if (!e) return;
          let a;
          const o = e[0];
          if (t) {
            const s = t.getFullTileRange(o);
            s && (a = s.getHeight() - 1);
          }
          return Klt(n, o, e[1], e[2], a);
        };
      }
      function eut(n, t) {
        const e = n.length, i = new Array(e);
        for (let r = 0; r < e; ++r) i[r] = tut(n[r], t);
        return nut(i);
      }
      function nut(n) {
        return n.length === 1 ? n[0] : function(t, e, i) {
          if (!t) return;
          const r = $F(t), a = ys(r, n.length);
          return n[a](t, e, i);
        };
      }
      class HC extends cQ {
        constructor(t) {
          super({ attributions: t.attributions, cacheSize: t.cacheSize, projection: t.projection, state: t.state, tileGrid: t.tileGrid, tilePixelRatio: t.tilePixelRatio, wrapX: t.wrapX, transition: t.transition, interpolate: t.interpolate, key: t.key, attributionsCollapsible: t.attributionsCollapsible, zDirection: t.zDirection }), this.generateTileUrlFunction_ = this.tileUrlFunction === HC.prototype.tileUrlFunction, this.tileLoadFunction = t.tileLoadFunction, t.tileUrlFunction && (this.tileUrlFunction = t.tileUrlFunction), this.urls = null, t.urls ? this.setUrls(t.urls) : t.url && this.setUrl(t.url), this.tileLoadingKeys_ = {};
        }
        getTileLoadFunction() {
          return this.tileLoadFunction;
        }
        getTileUrlFunction() {
          return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
        }
        getUrls() {
          return this.urls;
        }
        handleTileChange(t) {
          const e = t.target, i = xt(e), r = e.getState();
          let a;
          r == At.LOADING ? (this.tileLoadingKeys_[i] = true, a = Wf.TILELOADSTART) : i in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[i], a = r == At.ERROR ? Wf.TILELOADERROR : r == At.LOADED ? Wf.TILELOADEND : void 0), a != null && this.dispatchEvent(new fQ(a, e));
        }
        setTileLoadFunction(t) {
          this.tileLoadFunction = t, this.changed();
        }
        setTileUrlFunction(t, e) {
          this.tileUrlFunction = t, typeof e != "undefined" ? this.setKey(e) : this.changed();
        }
        setUrl(t) {
          const e = Jlt(t);
          this.urls = e, this.setUrls(e);
        }
        setUrls(t) {
          this.urls = t;
          const e = t.join(`
`);
          this.generateTileUrlFunction_ ? this.setTileUrlFunction(eut(t, this.tileGrid), e) : this.setKey(e);
        }
        tileUrlFunction(t, e, i) {
        }
      }
      class gQ extends HC {
        constructor(t) {
          super({ attributions: t.attributions, cacheSize: t.cacheSize, projection: t.projection, state: t.state, tileGrid: t.tileGrid, tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : iut, tilePixelRatio: t.tilePixelRatio, tileUrlFunction: t.tileUrlFunction, url: t.url, urls: t.urls, wrapX: t.wrapX, transition: t.transition, interpolate: t.interpolate !== void 0 ? t.interpolate : true, key: t.key, attributionsCollapsible: t.attributionsCollapsible, zDirection: t.zDirection }), this.crossOrigin = t.crossOrigin !== void 0 ? t.crossOrigin : null, this.tileClass = t.tileClass !== void 0 ? t.tileClass : $m, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = t.reprojectionErrorThreshold, this.renderReprojectionEdges_ = false;
        }
        getGutterForProjection(t) {
          return this.getProjection() && t && !Ao(this.getProjection(), t) ? 0 : this.getGutter();
        }
        getGutter() {
          return 0;
        }
        getKey() {
          let t = super.getKey();
          return this.getInterpolate() || (t += ":disable-interpolation"), t;
        }
        getTileGridForProjection(t) {
          const e = this.getProjection();
          if (this.tileGrid && (!e || Ao(e, t))) return this.tileGrid;
          const i = xt(t);
          return i in this.tileGridForProjection || (this.tileGridForProjection[i] = jC(t)), this.tileGridForProjection[i];
        }
        createTile_(t, e, i, r, a, o) {
          const s = [t, e, i], l = this.getTileCoordForTileUrlFunction(s, a), u = l ? this.tileUrlFunction(l, r, a) : void 0, h = new this.tileClass(s, u !== void 0 ? At.IDLE : At.EMPTY, u !== void 0 ? u : "", this.crossOrigin, this.tileLoadFunction, this.tileOptions);
          return h.key = o, h.addEventListener(Rt.CHANGE, this.handleTileChange.bind(this)), h;
        }
        getTile(t, e, i, r, a) {
          const o = this.getProjection();
          if (!o || !a || Ao(o, a)) return this.getTileInternal(t, e, i, r, o || a);
          const s = [t, e, i], l = this.getKey(), u = this.getTileGridForProjection(o), h = this.getTileGridForProjection(a), c = this.getTileCoordForTileUrlFunction(s, a), f = new Uf(o, u, a, h, s, c, this.getTilePixelRatio(r), this.getGutter(), (g, d, A, p) => this.getTileInternal(g, d, A, p, o), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.tileOptions);
          return f.key = l, f;
        }
        getTileInternal(t, e, i, r, a) {
          const o = this.getKey();
          return this.createTile_(t, e, i, r, a, o);
        }
        setRenderReprojectionEdges(t) {
          this.renderReprojectionEdges_ != t && (this.renderReprojectionEdges_ = t, this.changed());
        }
        setTileGridForProjection(t, e) {
          const i = qt(t);
          if (i) {
            const r = xt(i);
            r in this.tileGridForProjection || (this.tileGridForProjection[r] = e);
          }
        }
      }
      function iut(n, t) {
        n.getImage().src = t;
      }
      class YC extends gQ {
        constructor(t) {
          t = t || {};
          const e = t.projection !== void 0 ? t.projection : "EPSG:3857", i = t.tileGrid !== void 0 ? t.tileGrid : uQ({ extent: Q0(e), maxResolution: t.maxResolution, maxZoom: t.maxZoom, minZoom: t.minZoom, tileSize: t.tileSize });
          super({ attributions: t.attributions, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, interpolate: t.interpolate, projection: e, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileGrid: i, tileLoadFunction: t.tileLoadFunction, tilePixelRatio: t.tilePixelRatio, tileUrlFunction: t.tileUrlFunction, url: t.url, urls: t.urls, wrapX: t.wrapX !== void 0 ? t.wrapX : true, transition: t.transition, attributionsCollapsible: t.attributionsCollapsible, zDirection: t.zDirection }), this.gutter_ = t.gutter !== void 0 ? t.gutter : 0;
        }
        getGutter() {
          return this.gutter_;
        }
      }
      class rut extends oa {
        constructor(t) {
          t = t || {}, super({ attributions: t.attributions, wrapX: t.wrapX }), this.resolution = void 0, this.distance = t.distance !== void 0 ? t.distance : 20, this.minDistance = t.minDistance || 0, this.interpolationRatio = 0, this.features = [], this.geometryFunction = t.geometryFunction || function(e) {
            const i = e.getGeometry();
            return ue(!i || i.getType() === "Point", "The default `geometryFunction` can only handle `Point` or null geometries"), i;
          }, this.createCustomCluster_ = t.createCluster, this.source = null, this.boundRefresh_ = this.refresh.bind(this), this.updateDistance(this.distance, this.minDistance), this.setSource(t.source || null);
        }
        clear(t) {
          this.features.length = 0, super.clear(t);
        }
        getDistance() {
          return this.distance;
        }
        getSource() {
          return this.source;
        }
        loadFeatures(t, e, i) {
          var r;
          (r = this.source) == null || r.loadFeatures(t, e, i), e !== this.resolution && (this.resolution = e, this.refresh());
        }
        setDistance(t) {
          this.updateDistance(t, this.minDistance);
        }
        setMinDistance(t) {
          this.updateDistance(this.distance, t);
        }
        getMinDistance() {
          return this.minDistance;
        }
        setSource(t) {
          this.source && this.source.removeEventListener(Rt.CHANGE, this.boundRefresh_), this.source = t, t && t.addEventListener(Rt.CHANGE, this.boundRefresh_), this.refresh();
        }
        refresh() {
          this.clear(), this.cluster(), this.addFeatures(this.features);
        }
        updateDistance(t, e) {
          const i = t === 0 ? 0 : Math.min(e, t) / t, r = t !== this.distance || this.interpolationRatio !== i;
          this.distance = t, this.minDistance = e, this.interpolationRatio = i, r && this.refresh();
        }
        cluster() {
          if (this.resolution === void 0 || !this.source) return;
          const t = ai(), e = this.distance * this.resolution, i = this.source.getFeatures(), r = {};
          for (let a = 0, o = i.length; a < o; a++) {
            const s = i[a];
            if (!(xt(s) in r)) {
              const l = this.geometryFunction(s);
              if (l) {
                const u = l.getCoordinates();
                Yc(u, t), fo(t, e, t);
                const h = this.source.getFeaturesInExtent(t).filter(function(c) {
                  const f = xt(c);
                  return f in r ? false : (r[f] = true, true);
                });
                this.features.push(this.createCluster(h, t));
              }
            }
          }
        }
        createCluster(t, e) {
          const i = [0, 0];
          for (let s = t.length - 1; s >= 0; --s) {
            const l = this.geometryFunction(t[s]);
            l ? WP(i, l.getCoordinates()) : t.splice(s, 1);
          }
          XP(i, 1 / t.length);
          const r = Nr(e), a = this.interpolationRatio, o = new Ge([i[0] * (1 - a) + r[0] * a, i[1] * (1 - a) + r[1] * a]);
          return this.createCustomCluster_ ? this.createCustomCluster_(o, t) : new Ce({ geometry: o, features: t });
        }
      }
      class aut extends cQ {
        constructor(t) {
          const e = t.projection === void 0 ? "EPSG:3857" : t.projection;
          let i = t.tileGrid;
          i === void 0 && e && (i = uQ({ extent: Q0(e), maxResolution: t.maxResolution, maxZoom: t.maxZoom, minZoom: t.minZoom, tileSize: t.tileSize })), super({ cacheSize: 0.1, attributions: t.attributions, attributionsCollapsible: t.attributionsCollapsible, projection: e, tileGrid: i, state: t.state, wrapX: t.wrapX, transition: t.transition, interpolate: t.interpolate, key: t.key, zDirection: t.zDirection }), this.gutter_ = t.gutter !== void 0 ? t.gutter : 0, this.tileSize_ = t.tileSize ? Rn(t.tileSize) : null, this.tileSizes_ = null, this.tileLoadingKeys_ = {}, this.loader_ = t.loader, this.handleTileChange_ = this.handleTileChange_.bind(this), this.bandCount = t.bandCount === void 0 ? 4 : t.bandCount, this.tileGridForProjection_ = {}, this.crossOrigin_ = t.crossOrigin || "anonymous", this.transformMatrix = null;
        }
        setTileSizes(t) {
          this.tileSizes_ = t;
        }
        getTileSize(t) {
          if (this.tileSizes_) return this.tileSizes_[t];
          if (this.tileSize_) return this.tileSize_;
          const e = this.getTileGrid();
          return e ? Rn(e.getTileSize(t)) : [256, 256];
        }
        getGutterForProjection(t) {
          const e = this.getProjection();
          return (!e || Ao(e, t)) && !this.transformMatrix ? this.gutter_ : 0;
        }
        setLoader(t) {
          this.loader_ = t;
        }
        getReprojTile_(t, e, i, r, a) {
          const o = this.tileGrid || this.getTileGridForProjection(a || r), s = Math.max.apply(null, o.getResolutions().map((g, d) => {
            const A = Rn(o.getTileSize(d)), p = this.getTileSize(d);
            return Math.max(p[0] / A[0], p[1] / A[1]);
          })), l = this.getTileGridForProjection(r), u = [t, e, i], h = this.getTileCoordForTileUrlFunction(u, r), c = Object.assign({ sourceProj: a || r, sourceTileGrid: o, targetProj: r, targetTileGrid: l, tileCoord: u, wrappedTileCoord: h, pixelRatio: s, gutter: this.gutter_, getTileFunction: (g, d, A, p) => this.getTile(g, d, A, p), transformMatrix: this.transformMatrix }, this.tileOptions), f = new M0(c);
          return f.key = this.getKey(), f;
        }
        getTile(t, e, i, r, a) {
          var m;
          const o = this.getProjection();
          if (a && (o && !Ao(o, a) || this.transformMatrix)) return this.getReprojTile_(t, e, i, a, o);
          const s = this.getTileSize(t), l = this.loader_, u = new AbortController(), h = { signal: u.signal, crossOrigin: this.crossOrigin_ }, c = this.getTileCoordForTileUrlFunction([t, e, i]);
          if (!c) return null;
          const f = c[0], g = c[1], d = c[2], A = (m = this.getTileGrid()) == null ? void 0 : m.getFullTileRange(f);
          A && (h.maxY = A.getHeight() - 1);
          function p() {
            return _x(function() {
              return l(f, g, d, h);
            });
          }
          const v = Object.assign({ tileCoord: [t, e, i], loader: p, size: s, controller: u }, this.tileOptions), y = new ep(v);
          return y.key = this.getKey(), y.addEventListener(Rt.CHANGE, this.handleTileChange_), y;
        }
        handleTileChange_(t) {
          const e = t.target, i = xt(e), r = e.getState();
          let a;
          r == At.LOADING ? (this.tileLoadingKeys_[i] = true, a = Wf.TILELOADSTART) : i in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[i], a = r == At.ERROR ? Wf.TILELOADERROR : r == At.LOADED ? Wf.TILELOADEND : void 0), a && this.dispatchEvent(new fQ(a, e));
        }
        getTileGridForProjection(t) {
          const e = this.getProjection();
          if (this.tileGrid && (!e || Ao(e, t)) && !this.transformMatrix) return this.tileGrid;
          const i = xt(t);
          return i in this.tileGridForProjection_ || (this.tileGridForProjection_[i] = jC(t)), this.tileGridForProjection_[i];
        }
        setTileGridForProjection(t, e) {
          const i = qt(t);
          if (i) {
            const r = xt(i);
            r in this.tileGridForProjection_ || (this.tileGridForProjection_[r] = e);
          }
        }
      }
      function mi(n) {
        return (t, ...e) => out(n, t, e);
      }
      function Zf(n, t) {
        return mi(dQ(n, t).get);
      }
      const { apply: out, construct: U5t, defineProperty: V5t, get: j5t, getOwnPropertyDescriptor: dQ, getPrototypeOf: WC, has: q5t, ownKeys: sut, set: H5t, setPrototypeOf: Y5t } = Reflect, { iterator: sp, species: W5t, toStringTag: lut, for: X5t } = Symbol, uut = Object, { create: XC, defineProperty: hut, freeze: $5t, is: Z5t } = uut, AQ = Array.prototype[sp], cut = mi(AQ), pQ = ArrayBuffer, fut = pQ.prototype;
      Zf(fut, "byteLength");
      const vQ = typeof SharedArrayBuffer != "undefined" ? SharedArrayBuffer : null;
      vQ && Zf(vQ.prototype, "byteLength");
      const yQ = WC(Uint8Array);
      yQ.from;
      const ji = yQ.prototype;
      ji[sp], mi(ji.keys), mi(ji.values), mi(ji.entries), mi(ji.set), mi(ji.reverse), mi(ji.fill), mi(ji.copyWithin), mi(ji.sort), mi(ji.slice), mi(ji.subarray), Zf(ji, "buffer"), Zf(ji, "byteOffset"), Zf(ji, "length"), Zf(ji, lut);
      const gut = Uint8Array, mQ = Uint16Array, $C = Uint32Array, dut = Float32Array, lp = WC([][sp]()), _Q = mi(lp.next), Aut = mi(function* () {
      }().next), put = WC(lp), vut = DataView.prototype, yut = mi(vut.getUint16), ZC = WeakMap, EQ = ZC.prototype, IQ = mi(EQ.get), mut = mi(EQ.set), xQ = new ZC(), _ut = XC(null, { next: { value: function() {
        const t = IQ(xQ, this);
        return _Q(t);
      } }, [sp]: { value: function() {
        return this;
      } } });
      function Eut(n) {
        if (n[sp] === AQ && lp.next === _Q) return n;
        const t = XC(_ut);
        return mut(xQ, t, cut(n)), t;
      }
      const Iut = new ZC(), xut = XC(put, { next: { value: function() {
        const t = IQ(Iut, this);
        return Aut(t);
      }, writable: true, configurable: true } });
      for (const n of sut(lp)) n !== "next" && hut(xut, n, dQ(lp, n));
      const wQ = new pQ(4), wut = new dut(wQ), Cut = new $C(wQ), Bo = new mQ(512), Mo = new gut(512);
      for (let n = 0; n < 256; ++n) {
        const t = n - 127;
        t < -24 ? (Bo[n] = 0, Bo[n | 256] = 32768, Mo[n] = 24, Mo[n | 256] = 24) : t < -14 ? (Bo[n] = 1024 >> -t - 14, Bo[n | 256] = 1024 >> -t - 14 | 32768, Mo[n] = -t - 1, Mo[n | 256] = -t - 1) : t <= 15 ? (Bo[n] = t + 15 << 10, Bo[n | 256] = t + 15 << 10 | 32768, Mo[n] = 13, Mo[n | 256] = 13) : t < 128 ? (Bo[n] = 31744, Bo[n | 256] = 64512, Mo[n] = 24, Mo[n | 256] = 24) : (Bo[n] = 31744, Bo[n | 256] = 64512, Mo[n] = 13, Mo[n | 256] = 13);
      }
      const KC = new $C(2048);
      for (let n = 1; n < 1024; ++n) {
        let t = n << 13, e = 0;
        for (; !(t & 8388608); ) t <<= 1, e -= 8388608;
        t &= -8388609, e += 947912704, KC[n] = t | e;
      }
      for (let n = 1024; n < 2048; ++n) KC[n] = 939524096 + (n - 1024 << 13);
      const Kf = new $C(64);
      for (let n = 1; n < 31; ++n) Kf[n] = n << 23;
      Kf[31] = 1199570944, Kf[32] = 2147483648;
      for (let n = 33; n < 63; ++n) Kf[n] = 2147483648 + (n - 32 << 23);
      Kf[63] = 3347054592;
      const CQ = new mQ(64);
      for (let n = 1; n < 64; ++n) n !== 32 && (CQ[n] = 1024);
      function Sut(n) {
        const t = n >> 10;
        return Cut[0] = KC[CQ[t] + (n & 1023)] + Kf[t], wut[0];
      }
      function SQ(n, t, ...e) {
        return Sut(yut(n, t, ...Eut(e)));
      }
      var bQ = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
      function up(n) {
        return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
      }
      function but(n) {
        if (n.__esModule) return n;
        var t = n.default;
        if (typeof t == "function") {
          var e = function i() {
            return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
          };
          e.prototype = t.prototype;
        } else e = {};
        return Object.defineProperty(e, "__esModule", { value: true }), Object.keys(n).forEach(function(i) {
          var r = Object.getOwnPropertyDescriptor(n, i);
          Object.defineProperty(e, i, r.get ? r : { enumerable: true, get: function() {
            return n[i];
          } });
        }), e;
      }
      var JC = { exports: {} };
      function TQ(n, t, e) {
        const i = e && e.debug || false, r = typeof n == "object" ? n.outer : n, a = r.slice(0, r.indexOf(">") + 1), o = ['"', "'"];
        for (let s = 0; s < o.length; s++) {
          const l = o[s], u = t + "\\=" + l + "([^" + l + "]*)" + l, c = new RegExp(u).exec(a);
          if (c) return c[1];
        }
      }
      JC.exports = TQ, JC.exports.default = TQ;
      var Tut = JC.exports;
      const tS = up(Tut);
      var eS = { exports: {} }, nS = { exports: {} }, iS = { exports: {} };
      function BQ(n, t, e) {
        const r = new RegExp(t).exec(n.slice(e));
        return r ? e + r.index : -1;
      }
      iS.exports = BQ, iS.exports.default = BQ;
      var But = iS.exports, rS = { exports: {} };
      function MQ(n, t, e) {
        const r = new RegExp(t).exec(n.slice(e));
        return r ? e + r.index + r[0].length - 1 : -1;
      }
      rS.exports = MQ, rS.exports.default = MQ;
      var Mut = rS.exports, aS = { exports: {} };
      function DQ(n, t) {
        const e = new RegExp(t, "g"), i = n.match(e);
        return i ? i.length : 0;
      }
      aS.exports = DQ, aS.exports.default = DQ;
      var Dut = aS.exports;
      const Rut = But, oS = Mut, RQ = Dut;
      function LQ(n, t, e) {
        const i = e && e.debug || false, r = !(e && typeof e.nested === false), a = e && e.startIndex || 0, o = Rut(n, `<${t}[ 
>/]`, a);
        if (o === -1) return;
        const s = n.slice(o + t.length);
        let l = oS(s, "^[^<]*[ /]>", 0);
        const u = l !== -1 && s[l - 1] === "/";
        if (u === false) if (r) {
          let g = 0, d = 1, A = 0;
          for (; (l = oS(s, "[ /]" + t + ">", g)) !== -1; ) {
            const p = s.substring(g, l + 1);
            if (d += RQ(p, "<" + t + `[ 
	>]`), A += RQ(p, "</" + t + ">"), A >= d) break;
            g = l;
          }
        } else l = oS(s, "[ /]" + t + ">", 0);
        const h = o + t.length + l + 1;
        if (h === -1) return;
        const c = n.slice(o, h);
        let f;
        return u ? f = null : f = c.slice(c.indexOf(">") + 1, c.lastIndexOf("<")), { inner: f, outer: c, start: o, end: h };
      }
      nS.exports = LQ, nS.exports.default = LQ;
      var Lut = nS.exports;
      const Put = Lut;
      function PQ(n, t, e) {
        const i = [], r = e && e.debug || false, a = e && typeof e.nested == "boolean" ? e.nested : true;
        let o = e && e.startIndex || 0, s;
        for (; s = Put(n, t, { debug: r, startIndex: o }); ) a ? o = s.start + 1 + t.length : o = s.end, i.push(s);
        return i;
      }
      eS.exports = PQ, eS.exports.default = PQ;
      var Nut = eS.exports;
      const Fut = up(Nut), hp = { 315: "Artist", 258: "BitsPerSample", 265: "CellLength", 264: "CellWidth", 320: "ColorMap", 259: "Compression", 33432: "Copyright", 306: "DateTime", 338: "ExtraSamples", 266: "FillOrder", 289: "FreeByteCounts", 288: "FreeOffsets", 291: "GrayResponseCurve", 290: "GrayResponseUnit", 316: "HostComputer", 270: "ImageDescription", 257: "ImageLength", 256: "ImageWidth", 271: "Make", 281: "MaxSampleValue", 280: "MinSampleValue", 272: "Model", 254: "NewSubfileType", 274: "Orientation", 262: "PhotometricInterpretation", 284: "PlanarConfiguration", 296: "ResolutionUnit", 278: "RowsPerStrip", 277: "SamplesPerPixel", 305: "Software", 279: "StripByteCounts", 273: "StripOffsets", 255: "SubfileType", 263: "Threshholding", 282: "XResolution", 283: "YResolution", 326: "BadFaxLines", 327: "CleanFaxData", 343: "ClipPath", 328: "ConsecutiveBadFaxLines", 433: "Decode", 434: "DefaultImageColor", 269: "DocumentName", 336: "DotRange", 321: "HalftoneHints", 346: "Indexed", 347: "JPEGTables", 285: "PageName", 297: "PageNumber", 317: "Predictor", 319: "PrimaryChromaticities", 532: "ReferenceBlackWhite", 339: "SampleFormat", 340: "SMinSampleValue", 341: "SMaxSampleValue", 559: "StripRowCounts", 330: "SubIFDs", 292: "T4Options", 293: "T6Options", 325: "TileByteCounts", 323: "TileLength", 324: "TileOffsets", 322: "TileWidth", 301: "TransferFunction", 318: "WhitePoint", 344: "XClipPathUnits", 286: "XPosition", 529: "YCbCrCoefficients", 531: "YCbCrPositioning", 530: "YCbCrSubSampling", 345: "YClipPathUnits", 287: "YPosition", 37378: "ApertureValue", 40961: "ColorSpace", 36868: "DateTimeDigitized", 36867: "DateTimeOriginal", 34665: "Exif IFD", 36864: "ExifVersion", 33434: "ExposureTime", 41728: "FileSource", 37385: "Flash", 40960: "FlashpixVersion", 33437: "FNumber", 42016: "ImageUniqueID", 37384: "LightSource", 37500: "MakerNote", 37377: "ShutterSpeedValue", 37510: "UserComment", 33723: "IPTC", 34675: "ICC Profile", 700: "XMP", 42112: "GDAL_METADATA", 42113: "GDAL_NODATA", 34377: "Photoshop", 33550: "ModelPixelScale", 33922: "ModelTiepoint", 34264: "ModelTransformation", 34735: "GeoKeyDirectory", 34736: "GeoDoubleParams", 34737: "GeoAsciiParams", 50674: "LercParameters" }, Do = {};
      for (const n in hp) hp.hasOwnProperty(n) && (Do[hp[n]] = parseInt(n, 10));
      const kut = [Do.BitsPerSample, Do.ExtraSamples, Do.SampleFormat, Do.StripByteCounts, Do.StripOffsets, Do.StripRowCounts, Do.TileByteCounts, Do.TileOffsets, Do.SubIFDs], sS = { 1: "BYTE", 2: "ASCII", 3: "SHORT", 4: "LONG", 5: "RATIONAL", 6: "SBYTE", 7: "UNDEFINED", 8: "SSHORT", 9: "SLONG", 10: "SRATIONAL", 11: "FLOAT", 12: "DOUBLE", 13: "IFD", 16: "LONG8", 17: "SLONG8", 18: "IFD8" }, de = {};
      for (const n in sS) sS.hasOwnProperty(n) && (de[sS[n]] = parseInt(n, 10));
      const pr = { WhiteIsZero: 0, BlackIsZero: 1, RGB: 2, Palette: 3, TransparencyMask: 4, CMYK: 5, YCbCr: 6, CIELab: 8, ICCLab: 9 }, Out = { Unspecified: 0, Assocalpha: 1, Unassalpha: 2 }, Qut = { Version: 0, AddCompression: 1 }, lS = { None: 0, Deflate: 1, Zstandard: 2 }, zut = { 1024: "GTModelTypeGeoKey", 1025: "GTRasterTypeGeoKey", 1026: "GTCitationGeoKey", 2048: "GeographicTypeGeoKey", 2049: "GeogCitationGeoKey", 2050: "GeogGeodeticDatumGeoKey", 2051: "GeogPrimeMeridianGeoKey", 2052: "GeogLinearUnitsGeoKey", 2053: "GeogLinearUnitSizeGeoKey", 2054: "GeogAngularUnitsGeoKey", 2055: "GeogAngularUnitSizeGeoKey", 2056: "GeogEllipsoidGeoKey", 2057: "GeogSemiMajorAxisGeoKey", 2058: "GeogSemiMinorAxisGeoKey", 2059: "GeogInvFlatteningGeoKey", 2060: "GeogAzimuthUnitsGeoKey", 2061: "GeogPrimeMeridianLongGeoKey", 2062: "GeogTOWGS84GeoKey", 3072: "ProjectedCSTypeGeoKey", 3073: "PCSCitationGeoKey", 3074: "ProjectionGeoKey", 3075: "ProjCoordTransGeoKey", 3076: "ProjLinearUnitsGeoKey", 3077: "ProjLinearUnitSizeGeoKey", 3078: "ProjStdParallel1GeoKey", 3079: "ProjStdParallel2GeoKey", 3080: "ProjNatOriginLongGeoKey", 3081: "ProjNatOriginLatGeoKey", 3082: "ProjFalseEastingGeoKey", 3083: "ProjFalseNorthingGeoKey", 3084: "ProjFalseOriginLongGeoKey", 3085: "ProjFalseOriginLatGeoKey", 3086: "ProjFalseOriginEastingGeoKey", 3087: "ProjFalseOriginNorthingGeoKey", 3088: "ProjCenterLongGeoKey", 3089: "ProjCenterLatGeoKey", 3090: "ProjCenterEastingGeoKey", 3091: "ProjCenterNorthingGeoKey", 3092: "ProjScaleAtNatOriginGeoKey", 3093: "ProjScaleAtCenterGeoKey", 3094: "ProjAzimuthAngleGeoKey", 3095: "ProjStraightVertPoleLongGeoKey", 3096: "ProjRectifiedGridAngleGeoKey", 4096: "VerticalCSTypeGeoKey", 4097: "VerticalCitationGeoKey", 4098: "VerticalDatumGeoKey", 4099: "VerticalUnitsGeoKey" };
      function Gut(n, t) {
        const { width: e, height: i } = n, r = new Uint8Array(e * i * 3);
        let a;
        for (let o = 0, s = 0; o < n.length; ++o, s += 3) a = 256 - n[o] / t * 256, r[s] = a, r[s + 1] = a, r[s + 2] = a;
        return r;
      }
      function Uut(n, t) {
        const { width: e, height: i } = n, r = new Uint8Array(e * i * 3);
        let a;
        for (let o = 0, s = 0; o < n.length; ++o, s += 3) a = n[o] / t * 256, r[s] = a, r[s + 1] = a, r[s + 2] = a;
        return r;
      }
      function Vut(n, t) {
        const { width: e, height: i } = n, r = new Uint8Array(e * i * 3), a = t.length / 3, o = t.length / 3 * 2;
        for (let s = 0, l = 0; s < n.length; ++s, l += 3) {
          const u = n[s];
          r[l] = t[u] / 65536 * 256, r[l + 1] = t[u + a] / 65536 * 256, r[l + 2] = t[u + o] / 65536 * 256;
        }
        return r;
      }
      function jut(n) {
        const { width: t, height: e } = n, i = new Uint8Array(t * e * 3);
        for (let r = 0, a = 0; r < n.length; r += 4, a += 3) {
          const o = n[r], s = n[r + 1], l = n[r + 2], u = n[r + 3];
          i[a] = 255 * ((255 - o) / 256) * ((255 - u) / 256), i[a + 1] = 255 * ((255 - s) / 256) * ((255 - u) / 256), i[a + 2] = 255 * ((255 - l) / 256) * ((255 - u) / 256);
        }
        return i;
      }
      function qut(n) {
        const { width: t, height: e } = n, i = new Uint8ClampedArray(t * e * 3);
        for (let r = 0, a = 0; r < n.length; r += 3, a += 3) {
          const o = n[r], s = n[r + 1], l = n[r + 2];
          i[a] = o + 1.402 * (l - 128), i[a + 1] = o - 0.34414 * (s - 128) - 0.71414 * (l - 128), i[a + 2] = o + 1.772 * (s - 128);
        }
        return i;
      }
      const Hut = 0.95047, Yut = 1, Wut = 1.08883;
      function Xut(n) {
        const { width: t, height: e } = n, i = new Uint8Array(t * e * 3);
        for (let r = 0, a = 0; r < n.length; r += 3, a += 3) {
          const o = n[r + 0], s = n[r + 1] << 24 >> 24, l = n[r + 2] << 24 >> 24;
          let u = (o + 16) / 116, h = s / 500 + u, c = u - l / 200, f, g, d;
          h = Hut * (h * h * h > 8856e-6 ? h * h * h : (h - 16 / 116) / 7.787), u = Yut * (u * u * u > 8856e-6 ? u * u * u : (u - 16 / 116) / 7.787), c = Wut * (c * c * c > 8856e-6 ? c * c * c : (c - 16 / 116) / 7.787), f = h * 3.2406 + u * -1.5372 + c * -0.4986, g = h * -0.9689 + u * 1.8758 + c * 0.0415, d = h * 0.0557 + u * -0.204 + c * 1.057, f = f > 31308e-7 ? 1.055 * jn(f, 1 / 2.4) - 0.055 : 12.92 * f, g = g > 31308e-7 ? 1.055 * jn(g, 1 / 2.4) - 0.055 : 12.92 * g, d = d > 31308e-7 ? 1.055 * jn(d, 1 / 2.4) - 0.055 : 12.92 * d, i[a] = Math.max(0, Math.min(1, f)) * 255, i[a + 1] = Math.max(0, Math.min(1, g)) * 255, i[a + 2] = Math.max(0, Math.min(1, d)) * 255;
        }
        return i;
      }
      const NQ = /* @__PURE__ */ new Map();
      function Ql(n, t) {
        Array.isArray(n) || (n = [n]), n.forEach((e) => NQ.set(e, t));
      }
      function FQ(n) {
        return Tt(this, null, function* () {
          const t = NQ.get(n.Compression);
          if (!t) throw new Error(`Unknown compression method identifier: ${n.Compression}`);
          const e = yield t();
          return new e(n);
        });
      }
      Ql([void 0, 1], () => Promise.resolve().then(() => V3t).then((n) => n.default)), Ql(5, () => Promise.resolve().then(() => W3t).then((n) => n.default)), Ql(6, () => {
        throw new Error("old style JPEG compression is not supported.");
      }), Ql(7, () => Promise.resolve().then(() => J3t).then((n) => n.default)), Ql([8, 32946], () => Promise.resolve().then(() => E5t).then((n) => n.default)), Ql(32773, () => Promise.resolve().then(() => x5t).then((n) => n.default)), Ql(34887, () => Promise.resolve().then(() => T5t).then((n) => Tt(this, null, function* () {
        return yield n.zstd.init(), n;
      })).then((n) => n.default)), Ql(50001, () => Promise.resolve().then(() => M5t).then((n) => n.default));
      function z0(n, t, e, i = 1) {
        return new (Object.getPrototypeOf(n)).constructor(t * e * i);
      }
      function $ut(n, t, e, i, r) {
        const a = t / i, o = e / r;
        return n.map((s) => {
          const l = z0(s, i, r);
          for (let u = 0; u < r; ++u) {
            const h = Math.min(Math.round(o * u), e - 1);
            for (let c = 0; c < i; ++c) {
              const f = Math.min(Math.round(a * c), t - 1), g = s[h * t + f];
              l[u * i + c] = g;
            }
          }
          return l;
        });
      }
      function Jf(n, t, e) {
        return (1 - e) * n + e * t;
      }
      function Zut(n, t, e, i, r) {
        const a = t / i, o = e / r;
        return n.map((s) => {
          const l = z0(s, i, r);
          for (let u = 0; u < r; ++u) {
            const h = o * u, c = Math.floor(h), f = Math.min(Math.ceil(h), e - 1);
            for (let g = 0; g < i; ++g) {
              const d = a * g, A = d % 1, p = Math.floor(d), v = Math.min(Math.ceil(d), t - 1), y = s[c * t + p], m = s[c * t + v], _ = s[f * t + p], I = s[f * t + v], E = Jf(Jf(y, m, A), Jf(_, I, A), h % 1);
              l[u * i + g] = E;
            }
          }
          return l;
        });
      }
      function Kut(n, t, e, i, r, a = "nearest") {
        switch (a.toLowerCase()) {
          case "nearest":
            return $ut(n, t, e, i, r);
          case "bilinear":
          case "linear":
            return Zut(n, t, e, i, r);
          default:
            throw new Error(`Unsupported resampling method: '${a}'`);
        }
      }
      function Jut(n, t, e, i, r, a) {
        const o = t / i, s = e / r, l = z0(n, i, r, a);
        for (let u = 0; u < r; ++u) {
          const h = Math.min(Math.round(s * u), e - 1);
          for (let c = 0; c < i; ++c) {
            const f = Math.min(Math.round(o * c), t - 1);
            for (let g = 0; g < a; ++g) {
              const d = n[h * t * a + f * a + g];
              l[u * i * a + c * a + g] = d;
            }
          }
        }
        return l;
      }
      function tht(n, t, e, i, r, a) {
        const o = t / i, s = e / r, l = z0(n, i, r, a);
        for (let u = 0; u < r; ++u) {
          const h = s * u, c = Math.floor(h), f = Math.min(Math.ceil(h), e - 1);
          for (let g = 0; g < i; ++g) {
            const d = o * g, A = d % 1, p = Math.floor(d), v = Math.min(Math.ceil(d), t - 1);
            for (let y = 0; y < a; ++y) {
              const m = n[c * t * a + p * a + y], _ = n[c * t * a + v * a + y], I = n[f * t * a + p * a + y], E = n[f * t * a + v * a + y], x = Jf(Jf(m, _, A), Jf(I, E, A), h % 1);
              l[u * i * a + g * a + y] = x;
            }
          }
        }
        return l;
      }
      function eht(n, t, e, i, r, a, o = "nearest") {
        switch (o.toLowerCase()) {
          case "nearest":
            return Jut(n, t, e, i, r, a);
          case "bilinear":
          case "linear":
            return tht(n, t, e, i, r, a);
          default:
            throw new Error(`Unsupported resampling method: '${o}'`);
        }
      }
      function nht(n, t, e) {
        let i = 0;
        for (let r = t; r < e; ++r) i += n[r];
        return i;
      }
      function uS(n, t, e) {
        switch (n) {
          case 1:
            if (t <= 8) return new Uint8Array(e);
            if (t <= 16) return new Uint16Array(e);
            if (t <= 32) return new Uint32Array(e);
            break;
          case 2:
            if (t === 8) return new Int8Array(e);
            if (t === 16) return new Int16Array(e);
            if (t === 32) return new Int32Array(e);
            break;
          case 3:
            switch (t) {
              case 16:
              case 32:
                return new Float32Array(e);
              case 64:
                return new Float64Array(e);
            }
            break;
        }
        throw Error("Unsupported data format/bitsPerSample");
      }
      function iht(n, t) {
        return (n === 1 || n === 2) && t <= 32 && t % 8 === 0 ? false : !(n === 3 && (t === 16 || t === 32 || t === 64));
      }
      function rht(n, t, e, i, r, a, o) {
        const s = new DataView(n), l = e === 2 ? o * a : o * a * i, u = e === 2 ? 1 : i, h = uS(t, r, l), c = parseInt("1".repeat(r), 2);
        if (t === 1) {
          let f;
          e === 1 ? f = i * r : f = r;
          let g = a * f;
          g & 7 && (g = g + 7 & -8);
          for (let d = 0; d < o; ++d) {
            const A = d * g;
            for (let p = 0; p < a; ++p) {
              const v = A + p * u * r;
              for (let y = 0; y < u; ++y) {
                const m = v + y * r, _ = (d * a + p) * u + y, I = Math.floor(m / 8), E = m % 8;
                if (E + r <= 8) h[_] = s.getUint8(I) >> 8 - r - E & c;
                else if (E + r <= 16) h[_] = s.getUint16(I) >> 16 - r - E & c;
                else if (E + r <= 24) {
                  const x = s.getUint16(I) << 8 | s.getUint8(I + 2);
                  h[_] = x >> 24 - r - E & c;
                } else h[_] = s.getUint32(I) >> 32 - r - E & c;
              }
            }
          }
        }
        return h.buffer;
      }
      class kQ {
        constructor(t, e, i, r, a, o) {
          this.fileDirectory = t, this.geoKeys = e, this.dataView = i, this.littleEndian = r, this.tiles = a ? {} : null, this.isTiled = !t.StripOffsets;
          const s = t.PlanarConfiguration;
          if (this.planarConfiguration = typeof s == "undefined" ? 1 : s, this.planarConfiguration !== 1 && this.planarConfiguration !== 2) throw new Error("Invalid planar configuration.");
          this.source = o;
        }
        getFileDirectory() {
          return this.fileDirectory;
        }
        getGeoKeys() {
          return this.geoKeys;
        }
        getWidth() {
          return this.fileDirectory.ImageWidth;
        }
        getHeight() {
          return this.fileDirectory.ImageLength;
        }
        getSamplesPerPixel() {
          return typeof this.fileDirectory.SamplesPerPixel != "undefined" ? this.fileDirectory.SamplesPerPixel : 1;
        }
        getTileWidth() {
          return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();
        }
        getTileHeight() {
          return this.isTiled ? this.fileDirectory.TileLength : typeof this.fileDirectory.RowsPerStrip != "undefined" ? Math.min(this.fileDirectory.RowsPerStrip, this.getHeight()) : this.getHeight();
        }
        getBlockWidth() {
          return this.getTileWidth();
        }
        getBlockHeight(t) {
          return this.isTiled || (t + 1) * this.getTileHeight() <= this.getHeight() ? this.getTileHeight() : this.getHeight() - t * this.getTileHeight();
        }
        getBytesPerPixel() {
          let t = 0;
          for (let e = 0; e < this.fileDirectory.BitsPerSample.length; ++e) t += this.getSampleByteSize(e);
          return t;
        }
        getSampleByteSize(t) {
          if (t >= this.fileDirectory.BitsPerSample.length) throw new RangeError(`Sample index ${t} is out of range.`);
          return Math.ceil(this.fileDirectory.BitsPerSample[t] / 8);
        }
        getReaderForSample(t) {
          const e = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[t] : 1, i = this.fileDirectory.BitsPerSample[t];
          switch (e) {
            case 1:
              if (i <= 8) return DataView.prototype.getUint8;
              if (i <= 16) return DataView.prototype.getUint16;
              if (i <= 32) return DataView.prototype.getUint32;
              break;
            case 2:
              if (i <= 8) return DataView.prototype.getInt8;
              if (i <= 16) return DataView.prototype.getInt16;
              if (i <= 32) return DataView.prototype.getInt32;
              break;
            case 3:
              switch (i) {
                case 16:
                  return function(r, a) {
                    return SQ(this, r, a);
                  };
                case 32:
                  return DataView.prototype.getFloat32;
                case 64:
                  return DataView.prototype.getFloat64;
              }
              break;
          }
          throw Error("Unsupported data format/bitsPerSample");
        }
        getSampleFormat(t = 0) {
          return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[t] : 1;
        }
        getBitsPerSample(t = 0) {
          return this.fileDirectory.BitsPerSample[t];
        }
        getArrayForSample(t, e) {
          const i = this.getSampleFormat(t), r = this.getBitsPerSample(t);
          return uS(i, r, e);
        }
        getTileOrStrip(t, e, i, r, a) {
          return Tt(this, null, function* () {
            const o = Math.ceil(this.getWidth() / this.getTileWidth()), s = Math.ceil(this.getHeight() / this.getTileHeight());
            let l;
            const { tiles: u } = this;
            this.planarConfiguration === 1 ? l = e * o + t : this.planarConfiguration === 2 && (l = i * o * s + e * o + t);
            let h, c;
            this.isTiled ? (h = this.fileDirectory.TileOffsets[l], c = this.fileDirectory.TileByteCounts[l]) : (h = this.fileDirectory.StripOffsets[l], c = this.fileDirectory.StripByteCounts[l]);
            const f = (yield this.source.fetch([{ offset: h, length: c }], a))[0];
            let g;
            return u === null || !u[l] ? (g = Tt(this, null, function* () {
              let d = yield r.decode(this.fileDirectory, f);
              const A = this.getSampleFormat(), p = this.getBitsPerSample();
              return iht(A, p) && (d = rht(d, A, this.planarConfiguration, this.getSamplesPerPixel(), p, this.getTileWidth(), this.getBlockHeight(e))), d;
            }), u !== null && (u[l] = g)) : g = u[l], { x: t, y: e, sample: i, data: yield g };
          });
        }
        _readRaster(t, e, i, r, a, o, s, l, u) {
          return Tt(this, null, function* () {
            const h = this.getTileWidth(), c = this.getTileHeight(), f = this.getWidth(), g = this.getHeight(), d = Math.max(Math.floor(t[0] / h), 0), A = Math.min(Math.ceil(t[2] / h), Math.ceil(f / h)), p = Math.max(Math.floor(t[1] / c), 0), v = Math.min(Math.ceil(t[3] / c), Math.ceil(g / c)), y = t[2] - t[0];
            let m = this.getBytesPerPixel();
            const _ = [], I = [];
            for (let w = 0; w < e.length; ++w) this.planarConfiguration === 1 ? _.push(nht(this.fileDirectory.BitsPerSample, 0, e[w]) / 8) : _.push(0), I.push(this.getReaderForSample(e[w]));
            const E = [], { littleEndian: x } = this;
            for (let w = p; w < v; ++w) for (let C = d; C < A; ++C) {
              let S;
              this.planarConfiguration === 1 && (S = this.getTileOrStrip(C, w, 0, a, u));
              for (let b = 0; b < e.length; ++b) {
                const T = b, B = e[b];
                this.planarConfiguration === 2 && (m = this.getSampleByteSize(B), S = this.getTileOrStrip(C, w, B, a, u));
                const R = S.then((M) => {
                  const L = M.data, N = new DataView(L), F = this.getBlockHeight(M.y), k = M.y * c, O = M.x * h, Q = k + F, j = (M.x + 1) * h, Y = I[T], G = Math.min(F, F - (Q - t[3]), g - k), $ = Math.min(h, h - (j - t[2]), f - O);
                  for (let J = Math.max(0, t[1] - k); J < G; ++J) for (let et = Math.max(0, t[0] - O); et < $; ++et) {
                    const nt = (J * h + et) * m, gt = Y.call(N, nt + _[T], x);
                    let q;
                    r ? (q = (J + k - t[1]) * y * e.length + (et + O - t[0]) * e.length + T, i[q] = gt) : (q = (J + k - t[1]) * y + et + O - t[0], i[T][q] = gt);
                  }
                });
                E.push(R);
              }
            }
            if (yield Promise.all(E), o && t[2] - t[0] !== o || s && t[3] - t[1] !== s) {
              let w;
              return r ? w = eht(i, t[2] - t[0], t[3] - t[1], o, s, e.length, l) : w = Kut(i, t[2] - t[0], t[3] - t[1], o, s, l), w.width = o, w.height = s, w;
            }
            return i.width = o || t[2] - t[0], i.height = s || t[3] - t[1], i;
          });
        }
        readRasters() {
          return Tt(this, arguments, function* ({ window: t, samples: e = [], interleave: i, pool: r = null, width: a, height: o, resampleMethod: s, fillValue: l, signal: u } = {}) {
            const h = t || [0, 0, this.getWidth(), this.getHeight()];
            if (h[0] > h[2] || h[1] > h[3]) throw new Error("Invalid subsets");
            const c = h[2] - h[0], f = h[3] - h[1], g = c * f, d = this.getSamplesPerPixel();
            if (!e || !e.length) for (let y = 0; y < d; ++y) e.push(y);
            else for (let y = 0; y < e.length; ++y) if (e[y] >= d) return Promise.reject(new RangeError(`Invalid sample index '${e[y]}'.`));
            let A;
            if (i) {
              const y = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1, m = Math.max.apply(null, this.fileDirectory.BitsPerSample);
              A = uS(y, m, g * e.length), l && A.fill(l);
            } else {
              A = [];
              for (let y = 0; y < e.length; ++y) {
                const m = this.getArrayForSample(e[y], g);
                Array.isArray(l) && y < l.length ? m.fill(l[y]) : l && !Array.isArray(l) && m.fill(l), A.push(m);
              }
            }
            const p = r || (yield FQ(this.fileDirectory));
            return yield this._readRaster(h, e, A, i, p, a, o, s, u);
          });
        }
        readRGB() {
          return Tt(this, arguments, function* ({ window: t, interleave: e = true, pool: i = null, width: r, height: a, resampleMethod: o, enableAlpha: s = false, signal: l } = {}) {
            const u = t || [0, 0, this.getWidth(), this.getHeight()];
            if (u[0] > u[2] || u[1] > u[3]) throw new Error("Invalid subsets");
            const h = this.fileDirectory.PhotometricInterpretation;
            if (h === pr.RGB) {
              let v = [0, 1, 2];
              if (this.fileDirectory.ExtraSamples !== Out.Unspecified && s) {
                v = [];
                for (let y = 0; y < this.fileDirectory.BitsPerSample.length; y += 1) v.push(y);
              }
              return this.readRasters({ window: t, interleave: e, samples: v, pool: i, width: r, height: a, resampleMethod: o, signal: l });
            }
            let c;
            switch (h) {
              case pr.WhiteIsZero:
              case pr.BlackIsZero:
              case pr.Palette:
                c = [0];
                break;
              case pr.CMYK:
                c = [0, 1, 2, 3];
                break;
              case pr.YCbCr:
              case pr.CIELab:
                c = [0, 1, 2];
                break;
              default:
                throw new Error("Invalid or unsupported photometric interpretation.");
            }
            const f = { window: u, interleave: true, samples: c, pool: i, width: r, height: a, resampleMethod: o, signal: l }, { fileDirectory: g } = this, d = yield this.readRasters(f), A = jn(2, this.fileDirectory.BitsPerSample[0]);
            let p;
            switch (h) {
              case pr.WhiteIsZero:
                p = Gut(d, A);
                break;
              case pr.BlackIsZero:
                p = Uut(d, A);
                break;
              case pr.Palette:
                p = Vut(d, g.ColorMap);
                break;
              case pr.CMYK:
                p = jut(d);
                break;
              case pr.YCbCr:
                p = qut(d);
                break;
              case pr.CIELab:
                p = Xut(d);
                break;
              default:
                throw new Error("Unsupported photometric interpretation.");
            }
            if (!e) {
              const v = new Uint8Array(p.length / 3), y = new Uint8Array(p.length / 3), m = new Uint8Array(p.length / 3);
              for (let _ = 0, I = 0; _ < p.length; _ += 3, ++I) v[I] = p[_], y[I] = p[_ + 1], m[I] = p[_ + 2];
              p = [v, y, m];
            }
            return p.width = d.width, p.height = d.height, p;
          });
        }
        getTiePoints() {
          if (!this.fileDirectory.ModelTiepoint) return [];
          const t = [];
          for (let e = 0; e < this.fileDirectory.ModelTiepoint.length; e += 6) t.push({ i: this.fileDirectory.ModelTiepoint[e], j: this.fileDirectory.ModelTiepoint[e + 1], k: this.fileDirectory.ModelTiepoint[e + 2], x: this.fileDirectory.ModelTiepoint[e + 3], y: this.fileDirectory.ModelTiepoint[e + 4], z: this.fileDirectory.ModelTiepoint[e + 5] });
          return t;
        }
        getGDALMetadata(t = null) {
          const e = {};
          if (!this.fileDirectory.GDAL_METADATA) return null;
          const i = this.fileDirectory.GDAL_METADATA;
          let r = Fut(i, "Item");
          t === null ? r = r.filter((a) => tS(a, "sample") === void 0) : r = r.filter((a) => Number(tS(a, "sample")) === t);
          for (let a = 0; a < r.length; ++a) {
            const o = r[a];
            e[tS(o, "name")] = o.inner;
          }
          return e;
        }
        getGDALNoData() {
          if (!this.fileDirectory.GDAL_NODATA) return null;
          const t = this.fileDirectory.GDAL_NODATA;
          return Number(t.substring(0, t.length - 1));
        }
        getOrigin() {
          const t = this.fileDirectory.ModelTiepoint, e = this.fileDirectory.ModelTransformation;
          if (t && t.length === 6) return [t[3], t[4], t[5]];
          if (e) return [e[3], e[7], e[11]];
          throw new Error("The image does not have an affine transformation.");
        }
        getResolution(t = null) {
          const e = this.fileDirectory.ModelPixelScale, i = this.fileDirectory.ModelTransformation;
          if (e) return [e[0], -e[1], e[2]];
          if (i) return i[1] === 0 && i[4] === 0 ? [i[0], -i[5], i[10]] : [Math.sqrt(i[0] * i[0] + i[4] * i[4]), -Math.sqrt(i[1] * i[1] + i[5] * i[5]), i[10]];
          if (t) {
            const [r, a, o] = t.getResolution();
            return [r * t.getWidth() / this.getWidth(), a * t.getHeight() / this.getHeight(), o * t.getWidth() / this.getWidth()];
          }
          throw new Error("The image does not have an affine transformation.");
        }
        pixelIsArea() {
          return this.geoKeys.GTRasterTypeGeoKey === 1;
        }
        getBoundingBox(t = false) {
          const e = this.getHeight(), i = this.getWidth();
          if (this.fileDirectory.ModelTransformation && !t) {
            const [r, a, o, s, l, u, h, c] = this.fileDirectory.ModelTransformation, g = [[0, 0], [0, e], [i, 0], [i, e]].map(([p, v]) => [s + r * p + a * v, c + l * p + u * v]), d = g.map((p) => p[0]), A = g.map((p) => p[1]);
            return [Math.min(...d), Math.min(...A), Math.max(...d), Math.max(...A)];
          } else {
            const r = this.getOrigin(), a = this.getResolution(), o = r[0], s = r[1], l = o + a[0] * i, u = s + a[1] * e;
            return [Math.min(o, l), Math.min(s, u), Math.max(o, l), Math.max(s, u)];
          }
        }
      }
      class aht {
        constructor(t) {
          this._dataView = new DataView(t);
        }
        get buffer() {
          return this._dataView.buffer;
        }
        getUint64(t, e) {
          const i = this.getUint32(t, e), r = this.getUint32(t + 4, e);
          let a;
          if (e) {
            if (a = i + jn(2, 32) * r, !Number.isSafeInteger(a)) throw new Error(`${a} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
            return a;
          }
          if (a = jn(2, 32) * i + r, !Number.isSafeInteger(a)) throw new Error(`${a} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
          return a;
        }
        getInt64(t, e) {
          let i = 0;
          const r = (this._dataView.getUint8(t + (e ? 7 : 0)) & 128) > 0;
          let a = true;
          for (let o = 0; o < 8; o++) {
            let s = this._dataView.getUint8(t + (e ? o : 7 - o));
            r && (a ? s !== 0 && (s = ~(s - 1) & 255, a = false) : s = ~s & 255), i += s * jn(256, o);
          }
          return r && (i = -i), i;
        }
        getUint8(t, e) {
          return this._dataView.getUint8(t, e);
        }
        getInt8(t, e) {
          return this._dataView.getInt8(t, e);
        }
        getUint16(t, e) {
          return this._dataView.getUint16(t, e);
        }
        getInt16(t, e) {
          return this._dataView.getInt16(t, e);
        }
        getUint32(t, e) {
          return this._dataView.getUint32(t, e);
        }
        getInt32(t, e) {
          return this._dataView.getInt32(t, e);
        }
        getFloat16(t, e) {
          return SQ(this._dataView, t, e);
        }
        getFloat32(t, e) {
          return this._dataView.getFloat32(t, e);
        }
        getFloat64(t, e) {
          return this._dataView.getFloat64(t, e);
        }
      }
      class oht {
        constructor(t, e, i, r) {
          this._dataView = new DataView(t), this._sliceOffset = e, this._littleEndian = i, this._bigTiff = r;
        }
        get sliceOffset() {
          return this._sliceOffset;
        }
        get sliceTop() {
          return this._sliceOffset + this.buffer.byteLength;
        }
        get littleEndian() {
          return this._littleEndian;
        }
        get bigTiff() {
          return this._bigTiff;
        }
        get buffer() {
          return this._dataView.buffer;
        }
        covers(t, e) {
          return this.sliceOffset <= t && this.sliceTop >= t + e;
        }
        readUint8(t) {
          return this._dataView.getUint8(t - this._sliceOffset, this._littleEndian);
        }
        readInt8(t) {
          return this._dataView.getInt8(t - this._sliceOffset, this._littleEndian);
        }
        readUint16(t) {
          return this._dataView.getUint16(t - this._sliceOffset, this._littleEndian);
        }
        readInt16(t) {
          return this._dataView.getInt16(t - this._sliceOffset, this._littleEndian);
        }
        readUint32(t) {
          return this._dataView.getUint32(t - this._sliceOffset, this._littleEndian);
        }
        readInt32(t) {
          return this._dataView.getInt32(t - this._sliceOffset, this._littleEndian);
        }
        readFloat32(t) {
          return this._dataView.getFloat32(t - this._sliceOffset, this._littleEndian);
        }
        readFloat64(t) {
          return this._dataView.getFloat64(t - this._sliceOffset, this._littleEndian);
        }
        readUint64(t) {
          const e = this.readUint32(t), i = this.readUint32(t + 4);
          let r;
          if (this._littleEndian) {
            if (r = e + jn(2, 32) * i, !Number.isSafeInteger(r)) throw new Error(`${r} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
            return r;
          }
          if (r = jn(2, 32) * e + i, !Number.isSafeInteger(r)) throw new Error(`${r} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
          return r;
        }
        readInt64(t) {
          let e = 0;
          const i = (this._dataView.getUint8(t + (this._littleEndian ? 7 : 0)) & 128) > 0;
          let r = true;
          for (let a = 0; a < 8; a++) {
            let o = this._dataView.getUint8(t + (this._littleEndian ? a : 7 - a));
            i && (r ? o !== 0 && (o = ~(o - 1) & 255, r = false) : o = ~o & 255), e += o * jn(256, a);
          }
          return i && (e = -e), e;
        }
        readOffset(t) {
          return this._bigTiff ? this.readUint64(t) : this.readUint32(t);
        }
      }
      const sht = typeof navigator != "undefined" && navigator.hardwareConcurrency || 2;
      class lht {
        constructor(t = sht, e) {
          this.workers = null, this._awaitingDecoder = null, this.size = t, this.messageId = 0, t && (this._awaitingDecoder = e ? Promise.resolve(e) : new Promise((i) => {
            Promise.resolve().then(() => L5t).then((r) => {
              i(r.create);
            });
          }), this._awaitingDecoder.then((i) => {
            this._awaitingDecoder = null, this.workers = [];
            for (let r = 0; r < t; r++) this.workers.push({ worker: i(), idle: true });
          }));
        }
        decode(t, e) {
          return Tt(this, null, function* () {
            return this._awaitingDecoder && (yield this._awaitingDecoder), this.size === 0 ? FQ(t).then((i) => i.decode(t, e)) : new Promise((i) => {
              const r = this.workers.find((s) => s.idle) || this.workers[Math.floor(Math.random() * this.size)];
              r.idle = false;
              const a = this.messageId++, o = (s) => {
                s.data.id === a && (r.idle = true, i(s.data.decoded), r.worker.removeEventListener("message", o));
              };
              r.worker.addEventListener("message", o), r.worker.postMessage({ fileDirectory: t, buffer: e, id: a }, [e]);
            });
          });
        }
        destroy() {
          this.workers && (this.workers.forEach((t) => {
            t.worker.terminate();
          }), this.workers = null);
        }
      }
      const OQ = `\r
\r
`;
      function QQ(n) {
        if (typeof Object.fromEntries != "undefined") return Object.fromEntries(n);
        const t = {};
        for (const [e, i] of n) t[e.toLowerCase()] = i;
        return t;
      }
      function uht(n) {
        const t = n.split(`\r
`).map((e) => {
          const i = e.split(":").map((r) => r.trim());
          return i[0] = i[0].toLowerCase(), i;
        });
        return QQ(t);
      }
      function hht(n) {
        const [t, ...e] = n.split(";").map((r) => r.trim()), i = e.map((r) => r.split("="));
        return { type: t, params: QQ(i) };
      }
      function hS(n) {
        let t, e, i;
        return n && ([, t, e, i] = n.match(/bytes (\d+)-(\d+)\/(\d+)/), t = parseInt(t, 10), e = parseInt(e, 10), i = parseInt(i, 10)), { start: t, end: e, total: i };
      }
      function cht(n, t) {
        let e = null;
        const i = new TextDecoder("ascii"), r = [], a = `--${t}`, o = `${a}--`;
        for (let s = 0; s < 10; ++s) i.decode(new Uint8Array(n, s, a.length)) === a && (e = s);
        if (e === null) throw new Error("Could not find initial boundary");
        for (; e < n.byteLength; ) {
          const s = i.decode(new Uint8Array(n, e, Math.min(a.length + 1024, n.byteLength - e)));
          if (s.length === 0 || s.startsWith(o)) break;
          if (!s.startsWith(a)) throw new Error("Part does not start with boundary");
          const l = s.substr(a.length + 2);
          if (l.length === 0) break;
          const u = l.indexOf(OQ), h = uht(l.substr(0, u)), { start: c, end: f, total: g } = hS(h["content-range"]), d = e + a.length + u + OQ.length, A = parseInt(f, 10) + 1 - parseInt(c, 10);
          r.push({ headers: h, data: n.slice(d, d + A), offset: c, length: A, fileSize: g }), e = d + A + 4;
        }
        return r;
      }
      class cS {
        fetch(t, e = void 0) {
          return Tt(this, null, function* () {
            return Promise.all(t.map((i) => this.fetchSlice(i, e)));
          });
        }
        fetchSlice(t) {
          return Tt(this, null, function* () {
            throw new Error(`fetching of slice ${t} not possible, not implemented`);
          });
        }
        get fileSize() {
          return null;
        }
        close() {
          return Tt(this, null, function* () {
          });
        }
      }
      class fht extends Map {
        constructor(t = {}) {
          if (super(), !(t.maxSize && t.maxSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
          if (typeof t.maxAge == "number" && t.maxAge === 0) throw new TypeError("`maxAge` must be a number greater than 0");
          this.maxSize = t.maxSize, this.maxAge = t.maxAge || Number.POSITIVE_INFINITY, this.onEviction = t.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
        }
        _emitEvictions(t) {
          if (typeof this.onEviction == "function") for (const [e, i] of t) this.onEviction(e, i.value);
        }
        _deleteIfExpired(t, e) {
          return typeof e.expiry == "number" && e.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(t, e.value), this.delete(t)) : false;
        }
        _getOrDeleteIfExpired(t, e) {
          if (this._deleteIfExpired(t, e) === false) return e.value;
        }
        _getItemValue(t, e) {
          return e.expiry ? this._getOrDeleteIfExpired(t, e) : e.value;
        }
        _peek(t, e) {
          const i = e.get(t);
          return this._getItemValue(t, i);
        }
        _set(t, e) {
          this.cache.set(t, e), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
        }
        _moveToRecent(t, e) {
          this.oldCache.delete(t), this._set(t, e);
        }
        *_entriesAscending() {
          for (const t of this.oldCache) {
            const [e, i] = t;
            this.cache.has(e) || this._deleteIfExpired(e, i) === false && (yield t);
          }
          for (const t of this.cache) {
            const [e, i] = t;
            this._deleteIfExpired(e, i) === false && (yield t);
          }
        }
        get(t) {
          if (this.cache.has(t)) {
            const e = this.cache.get(t);
            return this._getItemValue(t, e);
          }
          if (this.oldCache.has(t)) {
            const e = this.oldCache.get(t);
            if (this._deleteIfExpired(t, e) === false) return this._moveToRecent(t, e), e.value;
          }
        }
        set(t, e, { maxAge: i = this.maxAge } = {}) {
          const r = typeof i == "number" && i !== Number.POSITIVE_INFINITY ? Date.now() + i : void 0;
          return this.cache.has(t) ? this.cache.set(t, { value: e, expiry: r }) : this._set(t, { value: e, expiry: r }), this;
        }
        has(t) {
          return this.cache.has(t) ? !this._deleteIfExpired(t, this.cache.get(t)) : this.oldCache.has(t) ? !this._deleteIfExpired(t, this.oldCache.get(t)) : false;
        }
        peek(t) {
          if (this.cache.has(t)) return this._peek(t, this.cache);
          if (this.oldCache.has(t)) return this._peek(t, this.oldCache);
        }
        delete(t) {
          const e = this.cache.delete(t);
          return e && this._size--, this.oldCache.delete(t) || e;
        }
        clear() {
          this.cache.clear(), this.oldCache.clear(), this._size = 0;
        }
        resize(t) {
          if (!(t && t > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
          const e = [...this._entriesAscending()], i = e.length - t;
          i < 0 ? (this.cache = new Map(e), this.oldCache = /* @__PURE__ */ new Map(), this._size = e.length) : (i > 0 && this._emitEvictions(e.slice(0, i)), this.oldCache = new Map(e.slice(i)), this.cache = /* @__PURE__ */ new Map(), this._size = 0), this.maxSize = t;
        }
        *keys() {
          for (const [t] of this) yield t;
        }
        *values() {
          for (const [, t] of this) yield t;
        }
        *[Symbol.iterator]() {
          for (const t of this.cache) {
            const [e, i] = t;
            this._deleteIfExpired(e, i) === false && (yield [e, i.value]);
          }
          for (const t of this.oldCache) {
            const [e, i] = t;
            this.cache.has(e) || this._deleteIfExpired(e, i) === false && (yield [e, i.value]);
          }
        }
        *entriesDescending() {
          let t = [...this.cache];
          for (let e = t.length - 1; e >= 0; --e) {
            const i = t[e], [r, a] = i;
            this._deleteIfExpired(r, a) === false && (yield [r, a.value]);
          }
          t = [...this.oldCache];
          for (let e = t.length - 1; e >= 0; --e) {
            const i = t[e], [r, a] = i;
            this.cache.has(r) || this._deleteIfExpired(r, a) === false && (yield [r, a.value]);
          }
        }
        *entriesAscending() {
          for (const [t, e] of this._entriesAscending()) yield [t, e.value];
        }
        get size() {
          if (!this._size) return this.oldCache.size;
          let t = 0;
          for (const e of this.oldCache.keys()) this.cache.has(e) || t++;
          return Math.min(this._size + t, this.maxSize);
        }
        entries() {
          return this.entriesAscending();
        }
        forEach(t, e = this) {
          for (const [i, r] of this.entriesAscending()) t.call(e, r, i, this);
        }
        get [Symbol.toStringTag]() {
          return JSON.stringify([...this.entriesAscending()]);
        }
      }
      function ght(n) {
        return Tt(this, null, function* () {
          return new Promise((t) => setTimeout(t, n));
        });
      }
      function dht(n, t) {
        const e = Array.isArray(n) ? n : Array.from(n), i = Array.isArray(t) ? t : Array.from(t);
        return e.map((r, a) => [r, i[a]]);
      }
      class tg extends Error {
        constructor(t) {
          super(t), Error.captureStackTrace && Error.captureStackTrace(this, tg), this.name = "AbortError";
        }
      }
      class Aht extends Error {
        constructor(t, e) {
          super(e), this.errors = t, this.message = e, this.name = "AggregateError";
        }
      }
      const pht = Aht;
      class vht {
        constructor(t, e, i = null) {
          this.offset = t, this.length = e, this.data = i;
        }
        get top() {
          return this.offset + this.length;
        }
      }
      class zQ {
        constructor(t, e, i) {
          this.offset = t, this.length = e, this.blockIds = i;
        }
      }
      class yht extends cS {
        constructor(t, { blockSize: e = 65536, cacheSize: i = 100 } = {}) {
          super(), this.source = t, this.blockSize = e, this.blockCache = new fht({ maxSize: i, onEviction: (r, a) => {
            this.evictedBlocks.set(r, a);
          } }), this.evictedBlocks = /* @__PURE__ */ new Map(), this.blockRequests = /* @__PURE__ */ new Map(), this.blockIdsToFetch = /* @__PURE__ */ new Set(), this.abortedBlockIds = /* @__PURE__ */ new Set();
        }
        get fileSize() {
          return this.source.fileSize;
        }
        fetch(t, e) {
          return Tt(this, null, function* () {
            const i = [], r = [], a = [];
            this.evictedBlocks.clear();
            for (const { offset: f, length: g } of t) {
              let d = f + g;
              const { fileSize: A } = this;
              A !== null && (d = Math.min(d, A));
              const p = Math.floor(f / this.blockSize) * this.blockSize;
              for (let v = p; v < d; v += this.blockSize) {
                const y = Math.floor(v / this.blockSize);
                !this.blockCache.has(y) && !this.blockRequests.has(y) && (this.blockIdsToFetch.add(y), r.push(y)), this.blockRequests.has(y) && i.push(this.blockRequests.get(y)), a.push(y);
              }
            }
            yield ght(), this.fetchBlocks(e);
            const o = [];
            for (const f of r) this.blockRequests.has(f) && o.push(this.blockRequests.get(f));
            yield Promise.allSettled(i), yield Promise.allSettled(o);
            const s = [], l = a.filter((f) => this.abortedBlockIds.has(f) || !this.blockCache.has(f));
            if (l.forEach((f) => this.blockIdsToFetch.add(f)), l.length > 0 && e && !e.aborted) {
              this.fetchBlocks(null);
              for (const f of l) {
                const g = this.blockRequests.get(f);
                if (!g) throw new Error(`Block ${f} is not in the block requests`);
                s.push(g);
              }
              yield Promise.allSettled(s);
            }
            if (e && e.aborted) throw new tg("Request was aborted");
            const u = a.map((f) => this.blockCache.get(f) || this.evictedBlocks.get(f)), h = u.filter((f) => !f);
            if (h.length) throw new pht(h, "Request failed");
            const c = new Map(dht(a, u));
            return this.readSliceData(t, c);
          });
        }
        fetchBlocks(t) {
          if (this.blockIdsToFetch.size > 0) {
            const e = this.groupBlocks(this.blockIdsToFetch), i = this.source.fetch(e, t);
            for (let r = 0; r < e.length; ++r) {
              const a = e[r];
              for (const o of a.blockIds) this.blockRequests.set(o, Tt(this, null, function* () {
                try {
                  const s = (yield i)[r], l = o * this.blockSize, u = l - s.offset, h = Math.min(u + this.blockSize, s.data.byteLength), c = s.data.slice(u, h), f = new vht(l, c.byteLength, c, o);
                  this.blockCache.set(o, f), this.abortedBlockIds.delete(o);
                } catch (s) {
                  if (s.name === "AbortError") s.signal = t, this.blockCache.delete(o), this.abortedBlockIds.add(o);
                  else throw s;
                } finally {
                  this.blockRequests.delete(o);
                }
              }));
            }
            this.blockIdsToFetch.clear();
          }
        }
        groupBlocks(t) {
          const e = Array.from(t).sort((o, s) => o - s);
          if (e.length === 0) return [];
          let i = [], r = null;
          const a = [];
          for (const o of e) r === null || r + 1 === o ? (i.push(o), r = o) : (a.push(new zQ(i[0] * this.blockSize, i.length * this.blockSize, i)), i = [o], r = o);
          return a.push(new zQ(i[0] * this.blockSize, i.length * this.blockSize, i)), a;
        }
        readSliceData(t, e) {
          return t.map((i) => {
            let r = i.offset + i.length;
            this.fileSize !== null && (r = Math.min(this.fileSize, r));
            const a = Math.floor(i.offset / this.blockSize), o = Math.floor(r / this.blockSize), s = new ArrayBuffer(i.length), l = new Uint8Array(s);
            for (let u = a; u <= o; ++u) {
              const h = e.get(u), c = h.offset - i.offset, f = h.top - r;
              let g = 0, d = 0, A;
              c < 0 ? g = -c : c > 0 && (d = c), f < 0 ? A = h.length - g : A = r - h.offset - g;
              const p = new Uint8Array(h.data, g, A);
              l.set(p, d);
            }
            return s;
          });
        }
      }
      class fS {
        get ok() {
          return this.status >= 200 && this.status <= 299;
        }
        get status() {
          throw new Error("not implemented");
        }
        getHeader(t) {
          throw new Error("not implemented");
        }
        getData() {
          return Tt(this, null, function* () {
            throw new Error("not implemented");
          });
        }
      }
      class gS {
        constructor(t) {
          this.url = t;
        }
        request() {
          return Tt(this, arguments, function* ({ headers: t, signal: e } = {}) {
            throw new Error("request is not implemented");
          });
        }
      }
      class mht extends fS {
        constructor(t) {
          super(), this.response = t;
        }
        get status() {
          return this.response.status;
        }
        getHeader(t) {
          return this.response.headers.get(t);
        }
        getData() {
          return Tt(this, null, function* () {
            return this.response.arrayBuffer ? yield this.response.arrayBuffer() : (yield this.response.buffer()).buffer;
          });
        }
      }
      class _ht extends gS {
        constructor(t, e) {
          super(t), this.credentials = e;
        }
        request() {
          return Tt(this, arguments, function* ({ headers: t, signal: e } = {}) {
            const i = yield fetch(this.url, { headers: t, credentials: this.credentials, signal: e });
            return new mht(i);
          });
        }
      }
      class Eht extends fS {
        constructor(t, e) {
          super(), this.xhr = t, this.data = e;
        }
        get status() {
          return this.xhr.status;
        }
        getHeader(t) {
          return this.xhr.getResponseHeader(t);
        }
        getData() {
          return Tt(this, null, function* () {
            return this.data;
          });
        }
      }
      class Iht extends gS {
        constructRequest(t, e) {
          return new Promise((i, r) => {
            const a = new XMLHttpRequest();
            a.open("GET", this.url), a.responseType = "arraybuffer";
            for (const [o, s] of Object.entries(t)) a.setRequestHeader(o, s);
            a.onload = () => {
              const o = a.response;
              i(new Eht(a, o));
            }, a.onerror = r, a.onabort = () => r(new tg("Request aborted")), a.send(), e && (e.aborted && a.abort(), e.addEventListener("abort", () => a.abort()));
          });
        }
        request() {
          return Tt(this, arguments, function* ({ headers: t, signal: e } = {}) {
            return yield this.constructRequest(t, e);
          });
        }
      }
      const G0 = {}, xht = Object.freeze(Object.defineProperty({ __proto__: null, default: G0 }, Symbol.toStringTag, { value: "Module" }));
      class wht extends fS {
        constructor(t, e) {
          super(), this.response = t, this.dataPromise = e;
        }
        get status() {
          return this.response.statusCode;
        }
        getHeader(t) {
          return this.response.headers[t];
        }
        getData() {
          return Tt(this, null, function* () {
            return yield this.dataPromise;
          });
        }
      }
      class Cht extends gS {
        constructor(t) {
          super(t), this.parsedUrl = G0.parse(this.url), this.httpApi = (this.parsedUrl.protocol === "http:", G0);
        }
        constructRequest(t, e) {
          return new Promise((i, r) => {
            const a = this.httpApi.get(Qt(rt({}, this.parsedUrl), { headers: t }), (o) => {
              const s = new Promise((l) => {
                const u = [];
                o.on("data", (h) => {
                  u.push(h);
                }), o.on("end", () => {
                  const h = Buffer.concat(u).buffer;
                  l(h);
                }), o.on("error", r);
              });
              i(new wht(o, s));
            });
            a.on("error", r), e && (e.aborted && a.destroy(new tg("Request aborted")), e.addEventListener("abort", () => a.destroy(new tg("Request aborted"))));
          });
        }
        request() {
          return Tt(this, arguments, function* ({ headers: t, signal: e } = {}) {
            return yield this.constructRequest(t, e);
          });
        }
      }
      class dS extends cS {
        constructor(t, e, i, r) {
          super(), this.client = t, this.headers = e, this.maxRanges = i, this.allowFullFile = r, this._fileSize = null;
        }
        fetch(t, e) {
          return Tt(this, null, function* () {
            return this.maxRanges >= t.length ? this.fetchSlices(t, e) : (this.maxRanges > 0 && t.length > 1, Promise.all(t.map((i) => this.fetchSlice(i, e))));
          });
        }
        fetchSlices(t, e) {
          return Tt(this, null, function* () {
            const i = yield this.client.request({ headers: Qt(rt({}, this.headers), { Range: `bytes=${t.map(({ offset: r, length: a }) => `${r}-${r + a}`).join(",")}` }), signal: e });
            if (i.ok) if (i.status === 206) {
              const { type: r, params: a } = hht(i.getHeader("content-type"));
              if (r === "multipart/byteranges") {
                const c = cht(yield i.getData(), a.boundary);
                return this._fileSize = c[0].fileSize || null, c;
              }
              const o = yield i.getData(), { start: s, end: l, total: u } = hS(i.getHeader("content-range"));
              this._fileSize = u || null;
              const h = [{ data: o, offset: s, length: l - s }];
              if (t.length > 1) {
                const c = yield Promise.all(t.slice(1).map((f) => this.fetchSlice(f, e)));
                return h.concat(c);
              }
              return h;
            } else {
              if (!this.allowFullFile) throw new Error("Server responded with full file");
              const r = yield i.getData();
              return this._fileSize = r.byteLength, [{ data: r, offset: 0, length: r.byteLength }];
            }
            else throw new Error("Error fetching data.");
          });
        }
        fetchSlice(t, e) {
          return Tt(this, null, function* () {
            const { offset: i, length: r } = t, a = yield this.client.request({ headers: Qt(rt({}, this.headers), { Range: `bytes=${i}-${i + r}` }), signal: e });
            if (a.ok) if (a.status === 206) {
              const o = yield a.getData(), { total: s } = hS(a.getHeader("content-range"));
              return this._fileSize = s || null, { data: o, offset: i, length: r };
            } else {
              if (!this.allowFullFile) throw new Error("Server responded with full file");
              const o = yield a.getData();
              return this._fileSize = o.byteLength, { data: o, offset: 0, length: o.byteLength };
            }
            else throw new Error("Error fetching data.");
          });
        }
        get fileSize() {
          return this._fileSize;
        }
      }
      function AS(n, { blockSize: t, cacheSize: e }) {
        return t === null ? n : new yht(n, { blockSize: t, cacheSize: e });
      }
      function Sht(n, o = {}) {
        var s = o, { headers: t = {}, credentials: e, maxRanges: i = 0, allowFullFile: r = false } = s, a = om(s, ["headers", "credentials", "maxRanges", "allowFullFile"]);
        const l = new _ht(n, e), u = new dS(l, t, i, r);
        return AS(u, a);
      }
      function bht(n, a = {}) {
        var o = a, { headers: t = {}, maxRanges: e = 0, allowFullFile: i = false } = o, r = om(o, ["headers", "maxRanges", "allowFullFile"]);
        const s = new Iht(n), l = new dS(s, t, e, i);
        return AS(l, r);
      }
      function Tht(n, a = {}) {
        var o = a, { headers: t = {}, maxRanges: e = 0, allowFullFile: i = false } = o, r = om(o, ["headers", "maxRanges", "allowFullFile"]);
        const s = new Cht(n), l = new dS(s, t, e, i);
        return AS(l, r);
      }
      function pS(n, i = {}) {
        var r = i, { forceXHR: t = false } = r, e = om(r, ["forceXHR"]);
        return typeof fetch == "function" && !t ? Sht(n, e) : typeof XMLHttpRequest != "undefined" ? bht(n, e) : Tht(n, e);
      }
      class Bht extends cS {
        constructor(t) {
          super(), this.file = t;
        }
        fetchSlice(t, e) {
          return Tt(this, null, function* () {
            return new Promise((i, r) => {
              const a = this.file.slice(t.offset, t.offset + t.length), o = new FileReader();
              o.onload = (s) => i(s.target.result), o.onerror = r, o.onabort = r, o.readAsArrayBuffer(a), e && e.addEventListener("abort", () => o.abort());
            });
          });
        }
      }
      function Mht(n) {
        return new Bht(n);
      }
      function Dht(n, t) {
        let e = n.length - t, i = 0;
        do {
          for (let r = t; r > 0; r--) n[i + t] += n[i], i++;
          e -= t;
        } while (e > 0);
      }
      function Rht(n, t, e) {
        let i = 0, r = n.length;
        const a = r / e;
        for (; r > t; ) {
          for (let s = t; s > 0; --s) n[i + t] += n[i], ++i;
          r -= t;
        }
        const o = n.slice();
        for (let s = 0; s < a; ++s) for (let l = 0; l < e; ++l) n[e * s + l] = o[(e - l - 1) * a + s];
      }
      function Lht(n, t, e, i, r, a) {
        if (!t || t === 1) return n;
        for (let l = 0; l < r.length; ++l) {
          if (r[l] % 8 !== 0) throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");
          if (r[l] !== r[0]) throw new Error("When decoding with predictor, all samples must have the same size.");
        }
        const o = r[0] / 8, s = a === 2 ? 1 : r.length;
        for (let l = 0; l < i && !(l * s * e * o >= n.byteLength); ++l) {
          let u;
          if (t === 2) {
            switch (r[0]) {
              case 8:
                u = new Uint8Array(n, l * s * e * o, s * e * o);
                break;
              case 16:
                u = new Uint16Array(n, l * s * e * o, s * e * o / 2);
                break;
              case 32:
                u = new Uint32Array(n, l * s * e * o, s * e * o / 4);
                break;
              default:
                throw new Error(`Predictor 2 not allowed with ${r[0]} bits per sample.`);
            }
            Dht(u, s);
          } else t === 3 && (u = new Uint8Array(n, l * s * e * o, s * e * o), Rht(u, s, o));
        }
        return n;
      }
      class ah {
        decode(t, e) {
          return Tt(this, null, function* () {
            const i = yield this.decodeBlock(e), r = t.Predictor || 1;
            if (r !== 1) {
              const a = !t.StripOffsets, o = a ? t.TileWidth : t.ImageWidth, s = a ? t.TileLength : t.RowsPerStrip || t.ImageLength;
              return Lht(i, r, o, s, t.BitsPerSample, t.PlanarConfiguration);
            }
            return i;
          });
        }
      }
      function vS(n) {
        switch (n) {
          case de.BYTE:
          case de.ASCII:
          case de.SBYTE:
          case de.UNDEFINED:
            return 1;
          case de.SHORT:
          case de.SSHORT:
            return 2;
          case de.LONG:
          case de.SLONG:
          case de.FLOAT:
          case de.IFD:
            return 4;
          case de.RATIONAL:
          case de.SRATIONAL:
          case de.DOUBLE:
          case de.LONG8:
          case de.SLONG8:
          case de.IFD8:
            return 8;
          default:
            throw new RangeError(`Invalid field type: ${n}`);
        }
      }
      function Pht(n) {
        const t = n.GeoKeyDirectory;
        if (!t) return null;
        const e = {};
        for (let i = 4; i <= t[3] * 4; i += 4) {
          const r = zut[t[i]], a = t[i + 1] ? hp[t[i + 1]] : null, o = t[i + 2], s = t[i + 3];
          let l = null;
          if (!a) l = s;
          else {
            if (l = n[a], typeof l == "undefined" || l === null) throw new Error(`Could not get value of geoKey '${r}'.`);
            typeof l == "string" ? l = l.substring(s, s + o - 1) : l.subarray && (l = l.subarray(s, s + o), o === 1 && (l = l[0]));
          }
          e[r] = l;
        }
        return e;
      }
      function eg(n, t, e, i) {
        let r = null, a = null;
        const o = vS(t);
        switch (t) {
          case de.BYTE:
          case de.ASCII:
          case de.UNDEFINED:
            r = new Uint8Array(e), a = n.readUint8;
            break;
          case de.SBYTE:
            r = new Int8Array(e), a = n.readInt8;
            break;
          case de.SHORT:
            r = new Uint16Array(e), a = n.readUint16;
            break;
          case de.SSHORT:
            r = new Int16Array(e), a = n.readInt16;
            break;
          case de.LONG:
          case de.IFD:
            r = new Uint32Array(e), a = n.readUint32;
            break;
          case de.SLONG:
            r = new Int32Array(e), a = n.readInt32;
            break;
          case de.LONG8:
          case de.IFD8:
            r = new Array(e), a = n.readUint64;
            break;
          case de.SLONG8:
            r = new Array(e), a = n.readInt64;
            break;
          case de.RATIONAL:
            r = new Uint32Array(e * 2), a = n.readUint32;
            break;
          case de.SRATIONAL:
            r = new Int32Array(e * 2), a = n.readInt32;
            break;
          case de.FLOAT:
            r = new Float32Array(e), a = n.readFloat32;
            break;
          case de.DOUBLE:
            r = new Float64Array(e), a = n.readFloat64;
            break;
          default:
            throw new RangeError(`Invalid field type: ${t}`);
        }
        if (t === de.RATIONAL || t === de.SRATIONAL) for (let s = 0; s < e; s += 2) r[s] = a.call(n, i + s * o), r[s + 1] = a.call(n, i + (s * o + 4));
        else for (let s = 0; s < e; ++s) r[s] = a.call(n, i + s * o);
        return t === de.ASCII ? new TextDecoder("utf-8").decode(r) : r;
      }
      class Nht {
        constructor(t, e, i) {
          this.fileDirectory = t, this.geoKeyDirectory = e, this.nextIFDByteOffset = i;
        }
      }
      class U0 extends Error {
        constructor(t) {
          super(`No image at index ${t}`), this.index = t;
        }
      }
      class GQ {
        readRasters() {
          return Tt(this, arguments, function* (t = {}) {
            const { window: e, width: i, height: r } = t;
            let { resX: a, resY: o, bbox: s } = t;
            const l = yield this.getImage();
            let u = l;
            const h = yield this.getImageCount(), c = l.getBoundingBox();
            if (e && s) throw new Error('Both "bbox" and "window" passed.');
            if (i || r) {
              if (e) {
                const [d, A] = l.getOrigin(), [p, v] = l.getResolution();
                s = [d + e[0] * p, A + e[1] * v, d + e[2] * p, A + e[3] * v];
              }
              const g = s || c;
              if (i) {
                if (a) throw new Error("Both width and resX passed");
                a = (g[2] - g[0]) / i;
              }
              if (r) {
                if (o) throw new Error("Both width and resY passed");
                o = (g[3] - g[1]) / r;
              }
            }
            if (a || o) {
              const g = [];
              for (let d = 0; d < h; ++d) {
                const A = yield this.getImage(d), { SubfileType: p, NewSubfileType: v } = A.fileDirectory;
                (d === 0 || p === 2 || v & 1) && g.push(A);
              }
              g.sort((d, A) => d.getWidth() - A.getWidth());
              for (let d = 0; d < g.length; ++d) {
                const A = g[d], p = (c[2] - c[0]) / A.getWidth(), v = (c[3] - c[1]) / A.getHeight();
                if (u = A, a && a > p || o && o > v) break;
              }
            }
            let f = e;
            if (s) {
              const [g, d] = l.getOrigin(), [A, p] = u.getResolution(l);
              f = [Math.round((s[0] - g) / A), Math.round((s[1] - d) / p), Math.round((s[2] - g) / A), Math.round((s[3] - d) / p)], f = [Math.min(f[0], f[2]), Math.min(f[1], f[3]), Math.max(f[0], f[2]), Math.max(f[1], f[3])];
            }
            return u.readRasters(Qt(rt({}, t), { window: f }));
          });
        }
      }
      class ng extends GQ {
        constructor(t, e, i, r, a = {}) {
          super(), this.source = t, this.littleEndian = e, this.bigTiff = i, this.firstIFDOffset = r, this.cache = a.cache || false, this.ifdRequests = [], this.ghostValues = null;
        }
        getSlice(t, e) {
          return Tt(this, null, function* () {
            const i = this.bigTiff ? 4048 : 1024;
            return new oht((yield this.source.fetch([{ offset: t, length: typeof e != "undefined" ? e : i }]))[0], t, this.littleEndian, this.bigTiff);
          });
        }
        parseFileDirectoryAt(t) {
          return Tt(this, null, function* () {
            const e = this.bigTiff ? 20 : 12, i = this.bigTiff ? 8 : 2;
            let r = yield this.getSlice(t);
            const a = this.bigTiff ? r.readUint64(t) : r.readUint16(t), o = a * e + (this.bigTiff ? 16 : 6);
            r.covers(t, o) || (r = yield this.getSlice(t, o));
            const s = {};
            let l = t + (this.bigTiff ? 8 : 2);
            for (let c = 0; c < a; l += e, ++c) {
              const f = r.readUint16(l), g = r.readUint16(l + 2), d = this.bigTiff ? r.readUint64(l + 4) : r.readUint32(l + 4);
              let A, p;
              const v = vS(g), y = l + (this.bigTiff ? 12 : 8);
              if (v * d <= (this.bigTiff ? 8 : 4)) A = eg(r, g, d, y);
              else {
                const m = r.readOffset(y), _ = vS(g) * d;
                if (r.covers(m, _)) A = eg(r, g, d, m);
                else {
                  const I = yield this.getSlice(m, _);
                  A = eg(I, g, d, m);
                }
              }
              d === 1 && kut.indexOf(f) === -1 && !(g === de.RATIONAL || g === de.SRATIONAL) ? p = A[0] : p = A, s[hp[f]] = p;
            }
            const u = Pht(s), h = r.readOffset(t + i + e * a);
            return new Nht(s, u, h);
          });
        }
        requestIFD(t) {
          return Tt(this, null, function* () {
            if (this.ifdRequests[t]) return this.ifdRequests[t];
            if (t === 0) return this.ifdRequests[t] = this.parseFileDirectoryAt(this.firstIFDOffset), this.ifdRequests[t];
            if (!this.ifdRequests[t - 1]) try {
              this.ifdRequests[t - 1] = this.requestIFD(t - 1);
            } catch (e) {
              throw e instanceof U0 ? new U0(t) : e;
            }
            return this.ifdRequests[t] = Tt(this, null, function* () {
              const e = yield this.ifdRequests[t - 1];
              if (e.nextIFDByteOffset === 0) throw new U0(t);
              return this.parseFileDirectoryAt(e.nextIFDByteOffset);
            }), this.ifdRequests[t];
          });
        }
        getImage(t = 0) {
          return Tt(this, null, function* () {
            const e = yield this.requestIFD(t);
            return new kQ(e.fileDirectory, e.geoKeyDirectory, this.dataView, this.littleEndian, this.cache, this.source);
          });
        }
        getImageCount() {
          return Tt(this, null, function* () {
            let t = 0, e = true;
            for (; e; ) try {
              yield this.requestIFD(t), ++t;
            } catch (i) {
              if (i instanceof U0) e = false;
              else throw i;
            }
            return t;
          });
        }
        getGhostValues() {
          return Tt(this, null, function* () {
            const t = this.bigTiff ? 16 : 8;
            if (this.ghostValues) return this.ghostValues;
            const e = "GDAL_STRUCTURAL_METADATA_SIZE=", i = e.length + 100;
            let r = yield this.getSlice(t, i);
            if (e === eg(r, de.ASCII, e.length, t)) {
              const o = eg(r, de.ASCII, i, t).split(`
`)[0], s = Number(o.split("=")[1].split(" ")[0]) + o.length;
              s > i && (r = yield this.getSlice(t, s));
              const l = eg(r, de.ASCII, s, t);
              this.ghostValues = {}, l.split(`
`).filter((u) => u.length > 0).map((u) => u.split("=")).forEach(([u, h]) => {
                this.ghostValues[u] = h;
              });
            }
            return this.ghostValues;
          });
        }
        static fromSource(t, e, i) {
          return Tt(this, null, function* () {
            const r = (yield t.fetch([{ offset: 0, length: 1024 }], i))[0], a = new aht(r), o = a.getUint16(0, 0);
            let s;
            if (o === 18761) s = true;
            else if (o === 19789) s = false;
            else throw new TypeError("Invalid byte order value.");
            const l = a.getUint16(2, s);
            let u;
            if (l === 42) u = false;
            else if (l === 43) {
              if (u = true, a.getUint16(4, s) !== 8) throw new Error("Unsupported offset byte-size.");
            } else throw new TypeError("Invalid magic number.");
            const h = u ? a.getUint64(8, s) : a.getUint32(4, s);
            return new ng(t, s, u, h, e);
          });
        }
        close() {
          return typeof this.source.close == "function" ? this.source.close() : false;
        }
      }
      class Fht extends GQ {
        constructor(t, e) {
          super(), this.mainFile = t, this.overviewFiles = e, this.imageFiles = [t].concat(e), this.fileDirectoriesPerFile = null, this.fileDirectoriesPerFileParsing = null, this.imageCount = null;
        }
        parseFileDirectoriesPerFile() {
          return Tt(this, null, function* () {
            const t = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map((e) => e.parseFileDirectoryAt(e.firstIFDOffset)));
            return this.fileDirectoriesPerFile = yield Promise.all(t), this.fileDirectoriesPerFile;
          });
        }
        getImage(t = 0) {
          return Tt(this, null, function* () {
            yield this.getImageCount(), yield this.parseFileDirectoriesPerFile();
            let e = 0, i = 0;
            for (let r = 0; r < this.imageFiles.length; r++) {
              const a = this.imageFiles[r];
              for (let o = 0; o < this.imageCounts[r]; o++) {
                if (t === e) {
                  const s = yield a.requestIFD(i);
                  return new kQ(s.fileDirectory, s.geoKeyDirectory, a.dataView, a.littleEndian, a.cache, a.source);
                }
                e++, i++;
              }
              i = 0;
            }
            throw new RangeError("Invalid image index");
          });
        }
        getImageCount() {
          return Tt(this, null, function* () {
            if (this.imageCount !== null) return this.imageCount;
            const t = [this.mainFile.getImageCount()].concat(this.overviewFiles.map((e) => e.getImageCount()));
            return this.imageCounts = yield Promise.all(t), this.imageCount = this.imageCounts.reduce((e, i) => e + i, 0), this.imageCount;
          });
        }
      }
      function kht(i) {
        return Tt(this, arguments, function* (n, t = {}, e) {
          return ng.fromSource(pS(n, t), e);
        });
      }
      function Oht(n, t) {
        return Tt(this, null, function* () {
          return ng.fromSource(Mht(n), t);
        });
      }
      function Qht(r) {
        return Tt(this, arguments, function* (n, t = [], e = {}, i) {
          const a = yield ng.fromSource(pS(n, e), i), o = yield Promise.all(t.map((s) => ng.fromSource(pS(s, e))));
          return new Fht(a, o);
        });
      }
      function zht(n) {
        return ((n.fileDirectory.NewSubfileType || 0) & 4) === 4;
      }
      function Ght(n, t) {
        if (!n) return false;
        if (n === true) return true;
        if (t.getSamplesPerPixel() !== 3) return false;
        const e = t.fileDirectory.PhotometricInterpretation, i = pr;
        return e === i.CMYK || e === i.YCbCr || e === i.CIELab || e === i.ICCLab;
      }
      const UQ = "STATISTICS_MAXIMUM", VQ = "STATISTICS_MINIMUM", yS = 256;
      let mS;
      function Uht() {
        return mS || (mS = new lht()), mS;
      }
      function Vht(n) {
        try {
          return n.getBoundingBox(true);
        } catch (t) {
          return [0, 0, n.getWidth(), n.getHeight()];
        }
      }
      function jht(n) {
        try {
          return n.getOrigin().slice(0, 2);
        } catch (t) {
          return [0, n.getHeight()];
        }
      }
      function qht(n, t) {
        try {
          return n.getResolution(t);
        } catch (e) {
          return [t.getWidth() / n.getWidth(), t.getHeight() / n.getHeight()];
        }
      }
      function Hht(n) {
        const t = n.geoKeys;
        if (!t) return null;
        if (t.ProjectedCSTypeGeoKey && t.ProjectedCSTypeGeoKey !== 32767) {
          const e = "EPSG:" + t.ProjectedCSTypeGeoKey;
          let i = qt(e);
          if (!i) {
            const r = jP(t.ProjLinearUnitsGeoKey);
            r && (i = new Oi({ code: e, units: r }));
          }
          return i;
        }
        if (t.GeographicTypeGeoKey && t.GeographicTypeGeoKey !== 32767) {
          const e = "EPSG:" + t.GeographicTypeGeoKey;
          let i = qt(e);
          if (!i) {
            const r = jP(t.GeogAngularUnitsGeoKey);
            r && (i = new Oi({ code: e, units: r }));
          }
          return i;
        }
        return null;
      }
      function Yht(n) {
        return n.getImageCount().then(function(t) {
          const e = new Array(t);
          for (let i = 0; i < t; ++i) e[i] = n.getImage(i);
          return Promise.all(e);
        });
      }
      function Wht(n, t) {
        let e;
        return n.blob ? e = Oht(n.blob) : n.overviews ? e = Qht(n.url, n.overviews, t) : e = kht(n.url, t), e.then(Yht);
      }
      function cp(n, t, e, i, r) {
        if (Array.isArray(n)) {
          const a = n.length;
          if (!Array.isArray(t) || a != t.length) {
            const o = new Error(i);
            throw r(o), o;
          }
          for (let o = 0; o < a; ++o) cp(n[o], t[o], e, i, r);
          return;
        }
        if (t = t, Math.abs(n - t) > e * n) throw new Error(i);
      }
      function Xht(n) {
        return n instanceof Int8Array ? -128 : n instanceof Int16Array ? -32768 : n instanceof Int32Array ? -2147483648 : n instanceof Float32Array ? 12e-39 : 0;
      }
      function $ht(n) {
        return n instanceof Int8Array ? 127 : n instanceof Uint8Array || n instanceof Uint8ClampedArray ? 255 : n instanceof Int16Array ? 32767 : n instanceof Uint16Array ? 65535 : n instanceof Int32Array ? 2147483647 : n instanceof Uint32Array ? 4294967295 : n instanceof Float32Array ? 34e37 : 255;
      }
      class jQ extends aut {
        constructor(t) {
          super({ state: "loading", tileGrid: null, projection: t.projection || null, transition: t.transition, interpolate: t.interpolate !== false, wrapX: t.wrapX }), this.sourceInfo_ = t.sources;
          const e = this.sourceInfo_.length;
          this.sourceOptions_ = t.sourceOptions, this.sourceImagery_ = new Array(e), this.sourceMasks_ = new Array(e), this.resolutionFactors_ = new Array(e), this.samplesPerPixel_, this.nodataValues_, this.metadata_, this.normalize_ = t.normalize !== false, this.addAlpha_ = false, this.error_ = null, this.convertToRGB_ = t.convertToRGB || false, this.setKey(this.sourceInfo_.map((a) => a.url).join(","));
          const i = this, r = new Array(e);
          for (let a = 0; a < e; ++a) r[a] = Wht(this.sourceInfo_[a], this.sourceOptions_);
          Promise.all(r).then(function(a) {
            i.configure_(a);
          }).catch(function(a) {
            uN(a), i.error_ = a, i.setState("error");
          });
        }
        getError() {
          return this.error_;
        }
        determineProjection(t) {
          const e = t[0];
          for (let i = e.length - 1; i >= 0; --i) {
            const r = e[i], a = Hht(r);
            if (a) {
              this.projection = a;
              break;
            }
          }
        }
        determineTransformMatrix(t) {
          const e = t[0];
          for (let i = e.length - 1; i >= 0; --i) {
            const a = e[i].fileDirectory.ModelTransformation;
            if (a) {
              const [o, s, l, u, h, c, f, g] = a, d = Ou(Ou([1 / Math.sqrt(o * o + h * h), 0, 0, -1 / Math.sqrt(s * s + c * c), u, g], [o, h, s, c, 0, 0]), [1, 0, 0, 1, -u, -g]);
              this.transformMatrix = d, this.addAlpha_ = true;
              break;
            }
          }
        }
        configure_(t) {
          let e, i, r, a, o;
          const s = new Array(t.length), l = new Array(t.length), u = new Array(t.length);
          let h = 0;
          const c = t.length;
          for (let p = 0; p < c; ++p) {
            const v = [], y = [];
            t[p].forEach((C) => {
              zht(C) ? y.push(C) : v.push(C);
            });
            const m = v.length;
            if (y.length > 0 && y.length !== m) throw new Error(`Expected one mask per image found ${y.length} masks and ${m} images`);
            let _, I;
            const E = new Array(m), x = new Array(m), w = new Array(m);
            l[p] = new Array(m), u[p] = new Array(m);
            for (let C = 0; C < m; ++C) {
              const S = v[C], b = S.getGDALNoData();
              u[p][C] = S.getGDALMetadata(0), l[p][C] = b;
              const T = this.sourceInfo_[p].bands;
              s[p] = T ? T.length : S.getSamplesPerPixel();
              const B = m - (C + 1);
              _ || (_ = Vht(S)), I || (I = jht(S));
              const R = qht(S, v[0]);
              w[B] = R[0];
              const M = [S.getTileWidth(), S.getTileHeight()];
              M[0] !== M[1] && M[1] < yS && (M[0] = yS, M[1] = yS), E[B] = M;
              const L = R[0] / Math.abs(R[1]);
              x[B] = [M[0], M[1] / L];
            }
            if (e ? oi(e, _, e) : e = _, !i) i = I;
            else {
              const C = `Origin mismatch for source ${p}, got [${I}] but expected [${i}]`;
              cp(i, I, 0, C, this.viewRejector);
            }
            if (!o) o = w, this.resolutionFactors_[p] = 1;
            else {
              o.length - h > w.length && (h = o.length - w.length);
              const C = o[o.length - 1] / w[w.length - 1];
              this.resolutionFactors_[p] = C;
              const S = w.map((T) => T *= C), b = `Resolution mismatch for source ${p}, got [${S}] but expected [${o}]`;
              cp(o.slice(h, o.length), S, 0.02, b, this.viewRejector);
            }
            r ? cp(r.slice(h, r.length), x, 0.01, `Tile size mismatch for source ${p}`, this.viewRejector) : r = x, a ? cp(a.slice(h, a.length), E, 0, `Tile size mismatch for source ${p}`, this.viewRejector) : a = E, this.sourceImagery_[p] = v.reverse(), this.sourceMasks_[p] = y.reverse();
          }
          for (let p = 0, v = this.sourceImagery_.length; p < v; ++p) {
            const y = this.sourceImagery_[p];
            for (; y.length < o.length; ) y.unshift(void 0);
          }
          this.getProjection() || this.determineProjection(t), this.determineTransformMatrix(t), this.samplesPerPixel_ = s, this.nodataValues_ = l, this.metadata_ = u;
          t: for (let p = 0; p < c; ++p) {
            if (this.sourceInfo_[p].nodata !== void 0) {
              this.addAlpha_ = true;
              break;
            }
            if (this.sourceMasks_[p].length) {
              this.addAlpha_ = true;
              break;
            }
            const v = l[p], y = this.sourceInfo_[p].bands;
            if (y) {
              for (let m = 0; m < y.length; ++m) if (v[y[m] - 1] !== null) {
                this.addAlpha_ = true;
                break t;
              }
              continue;
            }
            for (let m = 0; m < v.length; ++m) if (v[m] !== null) {
              this.addAlpha_ = true;
              break t;
            }
          }
          let f = this.addAlpha_ ? 1 : 0;
          for (let p = 0; p < c; ++p) f += s[p];
          this.bandCount = f;
          const g = new $f({ extent: e, minZoom: h, origin: i, resolutions: o, tileSizes: r });
          this.tileGrid = g, this.setTileSizes(a), this.setLoader(this.loadTile_.bind(this)), this.setState("ready");
          const d = 1;
          o.length === 2 ? o = [o[0], o[1], o[1] / 2] : o.length === 1 && (o = [o[0] * 2, o[0], o[0] / 2]);
          let A = e;
          if (this.transformMatrix) {
            const p = ml(an(), this.transformMatrix.slice()), v = Im((y) => nn(p, y));
            A = UP(e, v);
          }
          this.viewResolver({ showFullExtent: true, projection: this.projection, resolutions: o, center: vo(Nr(A), this.projection), extent: sA(A, this.projection), zoom: d });
        }
        loadTile_(t, e, i, r) {
          const a = this.getTileSize(t), o = this.sourceImagery_.length, s = new Array(o * 2), l = this.nodataValues_, u = this.sourceInfo_, h = Uht();
          for (let c = 0; c < o; ++c) {
            const f = u[c], g = this.resolutionFactors_[c], d = [Math.round(e * (a[0] * g)), Math.round(i * (a[1] * g)), Math.round((e + 1) * (a[0] * g)), Math.round((i + 1) * (a[1] * g))], A = this.sourceImagery_[c][t];
            let p;
            f.bands && (p = f.bands.map(function(I) {
              return I - 1;
            }));
            let v;
            "nodata" in f && f.nodata !== null ? v = f.nodata : p ? v = p.map(function(I) {
              return l[c][I];
            }) : v = l[c];
            const y = { window: d, width: a[0], height: a[1], samples: p, fillValue: v, pool: h, interleave: false, signal: r.signal };
            Ght(this.convertToRGB_, A) ? s[c] = A.readRGB(y) : s[c] = A.readRasters(y);
            const m = o + c, _ = this.sourceMasks_[c][t];
            if (!_) {
              s[m] = Promise.resolve(null);
              continue;
            }
            s[m] = _.readRasters({ window: d, width: a[0], height: a[1], samples: [0], pool: h, interleave: false });
          }
          return Promise.all(s).then(this.composeTile_.bind(this, a)).catch(function(c) {
            throw uN(c), c;
          });
        }
        composeTile_(t, e) {
          const i = this.metadata_, r = this.sourceInfo_, a = this.sourceImagery_.length, o = this.bandCount, s = this.samplesPerPixel_, l = this.nodataValues_, u = this.normalize_, h = this.addAlpha_, c = t[0] * t[1], f = c * o;
          let g;
          u ? g = new Uint8Array(f) : g = new Float32Array(f);
          let d = 0;
          for (let A = 0; A < c; ++A) {
            let p = h;
            for (let v = 0; v < a; ++v) {
              const y = r[v];
              let m = y.min, _ = y.max, I, E;
              if (u) {
                const x = i[v][0];
                m === void 0 && (x && VQ in x ? m = parseFloat(x[VQ]) : m = Xht(e[v][0])), _ === void 0 && (x && UQ in x ? _ = parseFloat(x[UQ]) : _ = $ht(e[v][0])), I = 255 / (_ - m), E = -m * I;
              }
              for (let x = 0; x < s[v]; ++x) {
                const w = e[v][x][A];
                let C;
                if (u ? C = Ze(I * w + E, 0, 255) : C = w, !h) g[d] = C;
                else {
                  let S = y.nodata;
                  if (S === void 0) {
                    let T;
                    y.bands ? T = y.bands[x] - 1 : T = x, S = l[v][T];
                  }
                  const b = isNaN(S);
                  (!b && w !== S || b && !isNaN(w)) && (p = false, g[d] = C);
                }
                d++;
              }
              if (!p) {
                const x = a + v, w = e[x];
                w && !w[0][A] && (p = true);
              }
            }
            h && (p || (g[d] = 255), d++);
          }
          return g;
        }
      }
      const qi = { VERSION1: "version1", VERSION2: "version2", VERSION3: "version3" }, oh = {};
      oh[qi.VERSION1] = { level0: { supports: [], formats: [], qualities: ["native"] }, level1: { supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"], formats: ["jpg"], qualities: ["native"] }, level2: { supports: ["regionByPx", "regionByPct", "sizeByW", "sizeByH", "sizeByPct", "sizeByConfinedWh", "sizeByWh"], formats: ["jpg", "png"], qualities: ["native", "color", "grey", "bitonal"] } }, oh[qi.VERSION2] = { level0: { supports: [], formats: ["jpg"], qualities: ["default"] }, level1: { supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"], formats: ["jpg"], qualities: ["default"] }, level2: { supports: ["regionByPx", "regionByPct", "sizeByW", "sizeByH", "sizeByPct", "sizeByConfinedWh", "sizeByDistortedWh", "sizeByWh"], formats: ["jpg", "png"], qualities: ["default", "bitonal"] } }, oh[qi.VERSION3] = { level0: { supports: [], formats: ["jpg"], qualities: ["default"] }, level1: { supports: ["regionByPx", "regionSquare", "sizeByW", "sizeByH", "sizeByWh"], formats: ["jpg"], qualities: ["default"] }, level2: { supports: ["regionByPx", "regionSquare", "regionByPct", "sizeByW", "sizeByH", "sizeByPct", "sizeByConfinedWh", "sizeByWh"], formats: ["jpg", "png"], qualities: ["default"] } }, oh.none = { none: { supports: [], formats: [], qualities: [] } };
      const Zht = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/, qQ = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/, Kht = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;
      function Jht(n) {
        let t = n.getComplianceLevelSupportedFeatures();
        return t === void 0 && (t = oh[qi.VERSION1].level0), { url: n.imageInfo["@id"] === void 0 ? void 0 : n.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""), supports: t.supports, formats: [...t.formats, n.imageInfo.formats === void 0 ? [] : n.imageInfo.formats], qualities: [...t.qualities, n.imageInfo.qualities === void 0 ? [] : n.imageInfo.qualities], resolutions: n.imageInfo.scale_factors, tileSize: n.imageInfo.tile_width !== void 0 ? n.imageInfo.tile_height !== void 0 ? [n.imageInfo.tile_width, n.imageInfo.tile_height] : [n.imageInfo.tile_width, n.imageInfo.tile_width] : n.imageInfo.tile_height != null ? [n.imageInfo.tile_height, n.imageInfo.tile_height] : void 0 };
      }
      function tct(n) {
        const t = n.getComplianceLevelSupportedFeatures(), e = Array.isArray(n.imageInfo.profile) && n.imageInfo.profile.length > 1, i = e && n.imageInfo.profile[1].supports ? n.imageInfo.profile[1].supports : [], r = e && n.imageInfo.profile[1].formats ? n.imageInfo.profile[1].formats : [], a = e && n.imageInfo.profile[1].qualities ? n.imageInfo.profile[1].qualities : [];
        return { url: n.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""), sizes: n.imageInfo.sizes === void 0 ? void 0 : n.imageInfo.sizes.map(function(o) {
          return [o.width, o.height];
        }), tileSize: n.imageInfo.tiles === void 0 ? void 0 : [n.imageInfo.tiles.map(function(o) {
          return o.width;
        })[0], n.imageInfo.tiles.map(function(o) {
          return o.height === void 0 ? o.width : o.height;
        })[0]], resolutions: n.imageInfo.tiles === void 0 ? void 0 : n.imageInfo.tiles.map(function(o) {
          return o.scaleFactors;
        })[0], supports: [...t.supports, ...i], formats: [...t.formats, ...r], qualities: [...t.qualities, ...a] };
      }
      function ect(n) {
        const t = n.getComplianceLevelSupportedFeatures(), e = n.imageInfo.extraFormats === void 0 ? t.formats : [...t.formats, ...n.imageInfo.extraFormats], i = n.imageInfo.preferredFormats !== void 0 && Array.isArray(n.imageInfo.preferredFormats) && n.imageInfo.preferredFormats.length > 0 ? n.imageInfo.preferredFormats.filter(function(r) {
          return ["jpg", "png", "gif"].includes(r);
        }).reduce(function(r, a) {
          return r === void 0 && e.includes(a) ? a : r;
        }, void 0) : void 0;
        return { url: n.imageInfo.id, sizes: n.imageInfo.sizes === void 0 ? void 0 : n.imageInfo.sizes.map(function(r) {
          return [r.width, r.height];
        }), tileSize: n.imageInfo.tiles === void 0 ? void 0 : [n.imageInfo.tiles.map(function(r) {
          return r.width;
        })[0], n.imageInfo.tiles.map(function(r) {
          return r.height;
        })[0]], resolutions: n.imageInfo.tiles === void 0 ? void 0 : n.imageInfo.tiles.map(function(r) {
          return r.scaleFactors;
        })[0], supports: n.imageInfo.extraFeatures === void 0 ? t.supports : [...t.supports, ...n.imageInfo.extraFeatures], formats: e, qualities: n.imageInfo.extraQualities === void 0 ? t.qualities : [...t.qualities, ...n.imageInfo.extraQualities], preferredFormat: i };
      }
      const V0 = {};
      V0[qi.VERSION1] = Jht, V0[qi.VERSION2] = tct, V0[qi.VERSION3] = ect;
      class nct {
        constructor(t) {
          this.setImageInfo(t);
        }
        setImageInfo(t) {
          typeof t == "string" ? this.imageInfo = JSON.parse(t) : this.imageInfo = t;
        }
        getImageApiVersion() {
          if (this.imageInfo === void 0) return;
          let t = this.imageInfo["@context"] || "ol-no-context";
          typeof t == "string" && (t = [t]);
          for (let e = 0; e < t.length; e++) switch (t[e]) {
            case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
            case "http://iiif.io/api/image/1/context.json":
              return qi.VERSION1;
            case "http://iiif.io/api/image/2/context.json":
              return qi.VERSION2;
            case "http://iiif.io/api/image/3/context.json":
              return qi.VERSION3;
            case "ol-no-context":
              if (this.getComplianceLevelEntryFromProfile(qi.VERSION1) && this.imageInfo.identifier) return qi.VERSION1;
              break;
          }
          ue(false, "Cannot determine IIIF Image API version from provided image information JSON");
        }
        getComplianceLevelEntryFromProfile(t) {
          if (!(this.imageInfo === void 0 || this.imageInfo.profile === void 0)) switch (t === void 0 && (t = this.getImageApiVersion()), t) {
            case qi.VERSION1:
              if (Zht.test(this.imageInfo.profile)) return this.imageInfo.profile;
              break;
            case qi.VERSION3:
              if (Kht.test(this.imageInfo.profile)) return this.imageInfo.profile;
              break;
            case qi.VERSION2:
              if (typeof this.imageInfo.profile == "string" && qQ.test(this.imageInfo.profile)) return this.imageInfo.profile;
              if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && typeof this.imageInfo.profile[0] == "string" && qQ.test(this.imageInfo.profile[0])) return this.imageInfo.profile[0];
              break;
          }
        }
        getComplianceLevelFromProfile(t) {
          const e = this.getComplianceLevelEntryFromProfile(t);
          if (e === void 0) return;
          const i = e.match(/level[0-2](?:\.json)?$/g);
          return Array.isArray(i) ? i[0].replace(".json", "") : void 0;
        }
        getComplianceLevelSupportedFeatures() {
          if (this.imageInfo === void 0) return;
          const t = this.getImageApiVersion(), e = this.getComplianceLevelFromProfile(t);
          return e === void 0 ? oh.none.none : oh[t][e];
        }
        getTileSourceOptions(t) {
          const e = t || {}, i = this.getImageApiVersion();
          if (i === void 0) return;
          const r = i === void 0 ? void 0 : V0[i](this);
          if (r !== void 0) return { url: r.url, version: i, size: [this.imageInfo.width, this.imageInfo.height], sizes: r.sizes, format: e.format !== void 0 && r.formats.includes(e.format) ? e.format : r.preferredFormat !== void 0 ? r.preferredFormat : "jpg", supports: r.supports, quality: e.quality && r.qualities.includes(e.quality) ? e.quality : r.qualities.includes("native") ? "native" : "default", resolutions: Array.isArray(r.resolutions) ? r.resolutions.sort(function(a, o) {
            return o - a;
          }) : void 0, tileSize: r.tileSize };
        }
      }
      function _S(n) {
        return Array.isArray(n) ? Math.min(...n) : n;
      }
      class ict extends kN {
        constructor(t, e, i, r, a, o, s) {
          let l = t.getExtent();
          l && t.canWrapX() && (l = l.slice(), l[0] = -1 / 0, l[2] = 1 / 0);
          let u = e.getExtent();
          u && e.canWrapX() && (u = u.slice(), u[0] = -1 / 0, u[2] = 1 / 0);
          const h = u ? oi(i, u) : i, c = Nr(h), f = np(t, e, c, r), g = EC, d = new IC(t, e, h, l, f * g, r), A = d.calculateSourceExtent(), p = ps(A) ? null : o(A, f, a), v = p ? Mt.IDLE : Mt.EMPTY, y = p ? p.getPixelRatio() : 1;
          super(i, r, y, v), this.targetProj_ = e, this.maxSourceExtent_ = l, this.triangulation_ = d, this.targetResolution_ = r, this.targetExtent_ = i, this.sourceImage_ = p, this.sourcePixelRatio_ = y, this.interpolate_ = s, this.canvas_ = null, this.sourceListenerKey_ = null;
        }
        disposeInternal() {
          this.state == Mt.LOADING && this.unlistenSource_(), super.disposeInternal();
        }
        getImage() {
          return this.canvas_;
        }
        getProjection() {
          return this.targetProj_;
        }
        reproject_() {
          const t = this.sourceImage_.getState();
          if (t == Mt.LOADED) {
            const e = he(this.targetExtent_) / this.targetResolution_, i = dn(this.targetExtent_) / this.targetResolution_;
            this.canvas_ = OO(e, i, this.sourcePixelRatio_, _S(this.sourceImage_.getResolution()), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [{ extent: this.sourceImage_.getExtent(), image: this.sourceImage_.getImage() }], 0, void 0, this.interpolate_, true);
          }
          this.state = t, this.changed();
        }
        load() {
          if (this.state == Mt.IDLE) {
            this.state = Mt.LOADING, this.changed();
            const t = this.sourceImage_.getState();
            t == Mt.LOADED || t == Mt.ERROR ? this.reproject_() : (this.sourceListenerKey_ = Ut(this.sourceImage_, Rt.CHANGE, (e) => {
              const i = this.sourceImage_.getState();
              (i == Mt.LOADED || i == Mt.ERROR) && (this.unlistenSource_(), this.reproject_());
            }), this.sourceImage_.load());
          }
        }
        unlistenSource_() {
          we(this.sourceListenerKey_), this.sourceListenerKey_ = null;
        }
      }
      const zl = 4, ES = { IMAGELOADSTART: "imageloadstart", IMAGELOADEND: "imageloadend", IMAGELOADERROR: "imageloaderror" };
      class rct extends Te {
        constructor(t, e) {
          super(t), this.image = e;
        }
      }
      class act extends Fw {
        constructor(t) {
          super({ attributions: t.attributions, projection: t.projection, state: t.state, interpolate: t.interpolate !== void 0 ? t.interpolate : true }), this.on, this.once, this.un, this.loader = t.loader || null, this.resolutions_ = t.resolutions !== void 0 ? t.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0, this.image = null, this.wantedExtent_, this.wantedResolution_, this.static_ = t.loader ? t.loader.length === 0 : false, this.wantedProjection_ = null;
        }
        getResolutions() {
          return this.resolutions_;
        }
        setResolutions(t) {
          this.resolutions_ = t;
        }
        findNearestResolution(t) {
          const e = this.getResolutions();
          if (e) {
            const i = pl(e, t, 0);
            t = e[i];
          }
          return t;
        }
        getImage(t, e, i, r) {
          const a = this.getProjection();
          if (!a || !r || Ao(a, r)) return a && (r = a), this.getImageInternal(t, e, i, r);
          if (this.reprojectedImage_) {
            if (this.reprojectedRevision_ == this.getRevision() && Ao(this.reprojectedImage_.getProjection(), r) && this.reprojectedImage_.getResolution() == e && As(this.reprojectedImage_.getExtent(), t)) return this.reprojectedImage_;
            this.reprojectedImage_.dispose(), this.reprojectedImage_ = null;
          }
          return this.reprojectedImage_ = new ict(a, r, t, e, i, (o, s, l) => this.getImageInternal(o, s, l, a), this.getInterpolate()), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_;
        }
        getImageInternal(t, e, i, r) {
          if (this.loader) {
            const a = HQ(t, e, i, 1), o = this.findNearestResolution(e);
            if (this.image && (this.static_ || this.wantedProjection_ === r && (this.wantedExtent_ && Pr(this.wantedExtent_, a) || Pr(this.image.getExtent(), a)) && (this.wantedResolution_ && _S(this.wantedResolution_) === o || _S(this.image.getResolution()) === o))) return this.image;
            this.wantedProjection_ = r, this.wantedExtent_ = a, this.wantedResolution_ = o, this.image = new kN(a, o, i, this.loader), this.image.addEventListener(Rt.CHANGE, this.handleImageChange.bind(this));
          }
          return this.image;
        }
        handleImageChange(t) {
          const e = t.target;
          let i;
          switch (e.getState()) {
            case Mt.LOADING:
              this.loading = true, i = ES.IMAGELOADSTART;
              break;
            case Mt.LOADED:
              this.loading = false, i = ES.IMAGELOADEND;
              break;
            case Mt.ERROR:
              this.loading = false, i = ES.IMAGELOADERROR;
              break;
            default:
              return;
          }
          this.hasListener(i) && this.dispatchEvent(new rct(i, e));
        }
      }
      function oct(n, t) {
        n.getImage().src = t;
      }
      function HQ(n, t, e, i) {
        const r = t / e, a = Nr(n), o = El(he(n) / r, zl), s = El(dn(n) / r, zl), l = El((i - 1) * o / 2, zl), u = o + 2 * l, h = El((i - 1) * s / 2, zl), c = s + 2 * h;
        return nA(a, r, 0, [u, c]);
      }
      const j0 = "1.3.0", YQ = [101, 101];
      function WQ(n, t, e, i, r) {
        r.WIDTH = e[0], r.HEIGHT = e[1];
        const a = i.getAxisOrientation(), o = dm(r.VERSION, "1.3") >= 0;
        r[o ? "CRS" : "SRS"] = i.getCode();
        const s = o && a.startsWith("ne") ? [t[1], t[0], t[3], t[2]] : t;
        return r.BBOX = s.join(","), qC(n, r);
      }
      function XQ(n, t, e, i, r, a, o) {
        a = Object.assign({ REQUEST: "GetMap" }, a);
        const s = t / e, l = [YP(he(n) / s, zl), YP(dn(n) / s, zl)];
        if (e != 1) switch (o) {
          case "geoserver":
            const h = 90 * e + 0.5 | 0;
            "FORMAT_OPTIONS" in a ? a.FORMAT_OPTIONS += ";dpi:" + h : a.FORMAT_OPTIONS = "dpi:" + h;
            break;
          case "mapserver":
            a.MAP_RESOLUTION = 90 * e;
            break;
          case "carmentaserver":
          case "qgis":
            a.DPI = 90 * e;
            break;
          default:
            throw new Error("Unknown `serverType` configured");
        }
        return WQ(r, n, l, i, a);
      }
      function q0(n, t) {
        return Object.assign({ REQUEST: t, SERVICE: "WMS", VERSION: j0, FORMAT: "image/png", STYLES: "", TRANSPARENT: true }, n);
      }
      function sct(n) {
        var o;
        const t = n.hidpi === void 0 ? true : n.hidpi, e = qt(n.projection || "EPSG:3857"), i = n.ratio || 1.5, r = n.load || QN, a = (o = n.crossOrigin) != null ? o : null;
        return (s, l, u) => {
          s = HQ(s, l, u, i), u != 1 && (!t || n.serverType === void 0) && (u = 1);
          const h = XQ(s, l, u, e, n.url, q0(n.params, "GetMap"), n.serverType), c = new Image();
          return c.crossOrigin = a, r(c, h).then((f) => ({ image: f, extent: s, pixelRatio: u }));
        };
      }
      function lct(n, t, e) {
        if (n.url === void 0) return;
        const i = qt(n.projection || "EPSG:3857"), r = nA(t, e, 0, YQ), a = { QUERY_LAYERS: n.params.LAYERS, INFO_FORMAT: "application/json" };
        Object.assign(a, q0(n.params, "GetFeatureInfo"), n.params);
        const o = tf((t[0] - r[0]) / e, zl), s = tf((r[3] - t[1]) / e, zl), l = dm(a.VERSION, "1.3") >= 0;
        return a[l ? "I" : "X"] = o, a[l ? "J" : "Y"] = s, WQ(n.url, r, YQ, i, a);
      }
      function uct(n, t) {
        if (n.url === void 0) return;
        const e = { SERVICE: "WMS", VERSION: j0, REQUEST: "GetLegendGraphic", FORMAT: "image/png" };
        if (t !== void 0) {
          const i = qt(n.projection || "EPSG:3857").getMetersPerUnit() || 1, r = 28e-5;
          e.SCALE = t * i / r;
        }
        if (Object.assign(e, n.params), n.params !== void 0 && e.LAYER === void 0) {
          const i = e.LAYERS;
          if (!(!Array.isArray(i) || i.length !== 1)) return;
          e.LAYER = i;
        }
        return qC(n.url, e);
      }
      class hct extends act {
        constructor(t) {
          t = t || {}, super({ attributions: t.attributions, interpolate: t.interpolate, projection: t.projection, resolutions: t.resolutions }), this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : null, this.url_ = t.url, this.imageLoadFunction_ = t.imageLoadFunction !== void 0 ? t.imageLoadFunction : oct, this.params_ = Object.assign({}, t.params), this.serverType_ = t.serverType, this.hidpi_ = t.hidpi !== void 0 ? t.hidpi : true, this.renderedRevision_ = 0, this.ratio_ = t.ratio !== void 0 ? t.ratio : 1.5, this.loaderProjection_ = null;
        }
        getFeatureInfoUrl(t, e, i, r) {
          const a = qt(i), o = this.getProjection();
          o && o !== a && (e = np(o, a, t, e), t = po(t, a, o));
          const s = { url: this.url_, params: rt(rt({}, this.params_), r), projection: o || a };
          return lct(s, t, e);
        }
        getLegendUrl(t, e) {
          return uct({ url: this.url_, params: rt(rt({}, this.params_), e) }, t);
        }
        getParams() {
          return this.params_;
        }
        getImageInternal(t, e, i, r) {
          return this.url_ === void 0 ? null : ((!this.loader || this.loaderProjection_ !== r) && (this.loaderProjection_ = r, this.loader = sct({ crossOrigin: this.crossOrigin_, params: this.params_, projection: r, serverType: this.serverType_, hidpi: this.hidpi_, url: this.url_, ratio: this.ratio_, load: (a, o) => (this.image.setImage(a), this.imageLoadFunction_(this.image, o), QN(a)) })), super.getImageInternal(t, e, i, r));
        }
        getImageLoadFunction() {
          return this.imageLoadFunction_;
        }
        getUrl() {
          return this.url_;
        }
        setImageLoadFunction(t) {
          this.imageLoadFunction_ = t, this.changed();
        }
        setUrl(t) {
          t != this.url_ && (this.url_ = t, this.loader = null, this.changed());
        }
        updateParams(t) {
          Object.assign(this.params_, t), this.changed();
        }
        changed() {
          this.image = null, super.changed();
        }
      }
      const cct = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
      class fct extends YC {
        constructor(t) {
          t = t || {};
          let e;
          t.attributions !== void 0 ? e = t.attributions : e = [cct];
          const i = t.crossOrigin !== void 0 ? t.crossOrigin : "anonymous", r = t.url !== void 0 ? t.url : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
          super({ attributions: e, attributionsCollapsible: false, cacheSize: t.cacheSize, crossOrigin: i, interpolate: t.interpolate, maxZoom: t.maxZoom !== void 0 ? t.maxZoom : 19, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileLoadFunction: t.tileLoadFunction, transition: t.transition, url: r, wrapX: t.wrapX, zDirection: t.zDirection });
        }
      }
      class gct extends Zu {
        constructor(t) {
          t = t || {}, super(t);
        }
      }
      class dct extends Ym {
        constructor(t) {
          super(t), this.image = null;
        }
        getImage() {
          return this.image ? this.image.getImage() : null;
        }
        prepareFrame(t) {
          const e = t.layerStatesArray[t.layerIndex], i = t.pixelRatio, r = t.viewState, a = r.resolution, o = this.getLayer().getSource(), s = t.viewHints;
          let l = t.extent;
          if (e.extent !== void 0 && (l = oi(l, zi(e.extent, r.projection))), !s[xn.ANIMATING] && !s[xn.INTERACTING] && !ps(l)) if (o) {
            const u = r.projection, h = o.getImage(l, a, i, u);
            h && (this.loadImage(h) ? this.image = h : h.getState() === Mt.EMPTY && (this.image = null));
          } else this.image = null;
          return !!this.image;
        }
        getData(t) {
          const e = this.frameState;
          if (!e) return null;
          const i = this.getLayer(), r = nn(e.pixelToCoordinateTransform, t.slice()), a = i.getExtent();
          if (a && !Jr(a, r)) return null;
          const o = this.image.getExtent(), s = this.image.getImage(), l = he(o), u = Math.floor(s.width * ((r[0] - o[0]) / l));
          if (u < 0 || u >= s.width) return null;
          const h = dn(o), c = Math.floor(s.height * ((o[3] - r[1]) / h));
          return c < 0 || c >= s.height ? null : this.getImageData(s, u, c);
        }
        renderFrame(t, e) {
          const i = this.image, r = i.getExtent(), a = i.getResolution(), [o, s] = Array.isArray(a) ? a : [a, a], l = i.getPixelRatio(), u = t.layerStatesArray[t.layerIndex], h = t.pixelRatio, c = t.viewState, f = c.center, g = c.resolution, d = h * o / (g * l), A = h * s / (g * l);
          this.prepareContainer(t, e);
          const p = this.context.canvas.width, v = this.context.canvas.height, y = this.getRenderContext(t);
          let m = false, _ = true;
          if (u.extent) {
            const C = zi(u.extent, c.projection);
            _ = Ai(C, t.extent), m = _ && !Pr(C, t.extent), m && this.clipUnrotated(y, t, C);
          }
          const I = i.getImage(), E = Lr(this.tempTransform, p / 2, v / 2, d, A, 0, l * (r[0] - f[0]) / o, l * (f[1] - r[3]) / s);
          this.renderedResolution = s * h / l;
          const x = I.width * E[0], w = I.height * E[3];
          if (this.getLayer().getSource().getInterpolate() || (y.imageSmoothingEnabled = false), this.preRender(y, t), _ && x >= 0.5 && w >= 0.5) {
            const C = E[4], S = E[5], b = u.opacity;
            b !== 1 && (y.save(), y.globalAlpha = b), y.drawImage(I, 0, 0, +I.width, +I.height, C, S, x, w), b !== 1 && y.restore();
          }
          return this.postRender(this.context, t), m && y.restore(), y.imageSmoothingEnabled = true, this.container;
        }
      }
      class Act extends gct {
        constructor(t) {
          super(t);
        }
        createRenderer() {
          return new dct(this);
        }
        getData(t) {
          return super.getData(t);
        }
      }
      class pct extends gQ {
        constructor(t) {
          t = t || {};
          const e = Object.assign({}, t.params);
          super({ attributions: t.attributions, attributionsCollapsible: t.attributionsCollapsible, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, interpolate: t.interpolate, projection: t.projection, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileClass: t.tileClass, tileGrid: t.tileGrid, tileLoadFunction: t.tileLoadFunction, url: t.url, urls: t.urls, wrapX: t.wrapX !== void 0 ? t.wrapX : true, transition: t.transition, zDirection: t.zDirection }), this.gutter_ = t.gutter !== void 0 ? t.gutter : 0, this.params_ = e, this.v13_ = true, this.serverType_ = t.serverType, this.hidpi_ = t.hidpi !== void 0 ? t.hidpi : true, this.tmpExtent_ = ai(), this.updateV13_(), this.setKey(this.getKeyForParams_());
        }
        getFeatureInfoUrl(t, e, i, r) {
          const a = qt(i), o = this.getProjection() || a;
          let s = this.getTileGrid();
          s || (s = this.getTileGridForProjection(o));
          const l = po(t, a, o), u = np(o, a, t, e), h = s.getZForResolution(u, this.zDirection), c = s.getResolution(h), f = s.getTileCoordForCoordAndZ(l, h);
          if (s.getResolutions().length <= f[0]) return;
          let g = s.getTileCoordExtent(f, this.tmpExtent_);
          const d = this.gutter_;
          d !== 0 && (g = fo(g, c * d, g));
          const A = { QUERY_LAYERS: this.params_.LAYERS };
          Object.assign(A, q0(this.params_, "GetFeatureInfo"), r);
          const p = Math.floor((l[0] - g[0]) / c), v = Math.floor((g[3] - l[1]) / c);
          return A[this.v13_ ? "I" : "X"] = p, A[this.v13_ ? "J" : "Y"] = v, this.getRequestUrl_(f, g, 1, o || a, A);
        }
        getLegendUrl(t, e) {
          if (this.urls[0] === void 0) return;
          const i = { SERVICE: "WMS", VERSION: j0, REQUEST: "GetLegendGraphic", FORMAT: "image/png" };
          if (e === void 0 || e.LAYER === void 0) {
            const r = this.params_.LAYERS;
            if (!(!Array.isArray(r) || r.length === 1)) return;
            i.LAYER = r;
          }
          if (t !== void 0) {
            const r = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, a = 28e-5;
            i.SCALE = t * r / a;
          }
          return Object.assign(i, e), qC(this.urls[0], i);
        }
        getGutter() {
          return this.gutter_;
        }
        getParams() {
          return this.params_;
        }
        getRequestUrl_(t, e, i, r, a) {
          const o = this.urls;
          if (!o) return;
          let s;
          if (o.length == 1) s = o[0];
          else {
            const l = ys($F(t), o.length);
            s = o[l];
          }
          return XQ(e, (this.tileGrid || this.getTileGridForProjection(r)).getResolution(t[0]), i, r, s, a, this.serverType_);
        }
        getTilePixelRatio(t) {
          return !this.hidpi_ || this.serverType_ === void 0 ? 1 : t;
        }
        getKeyForParams_() {
          let t = 0;
          const e = [];
          for (const i in this.params_) e[t++] = i + "-" + this.params_[i];
          return e.join("/");
        }
        updateParams(t) {
          Object.assign(this.params_, t), this.updateV13_(), this.setKey(this.getKeyForParams_());
        }
        updateV13_() {
          const t = this.params_.VERSION || j0;
          this.v13_ = dm(t, "1.3") >= 0;
        }
        tileUrlFunction(t, e, i) {
          let r = this.getTileGrid();
          if (r || (r = this.getTileGridForProjection(i)), r.getResolutions().length <= t[0]) return;
          e != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (e = 1);
          const a = r.getResolution(t[0]);
          let o = r.getTileCoordExtent(t, this.tmpExtent_);
          const s = this.gutter_;
          s !== 0 && (o = fo(o, a * s, o));
          const l = Object.assign({}, q0(this.params_, "GetMap"));
          return this.getRequestUrl_(t, o, e, i, l);
        }
      }
      const vct = (n) => {
        let t;
        if ((n == null ? void 0 : n.tileGrid) !== void 0) return t = n.tileGrid, new $f(t);
      }, Ro = (n, t) => {
        const e = vct(t), i = Qt(rt({}, t), { tileGrid: e });
        return new D0(Qt(rt({}, n), { source: new YC(i) }));
      }, yct = (n) => new D0(Qt(rt({}, n), { source: void 0 })), H0 = (n, t, e) => {
        const i = [];
        for (let s = 0; s < 19; s++) i[s] = Math.pow(2, 18 - s);
        const r = new $f({ origin: [0, 0], resolutions: i }), a = Qt(rt({}, t), { url: "", projection: "BD:09", tileGrid: r, tileUrlFunction: function(s) {
          if (!s) return "";
          const l = s[0], u = s[1], h = -s[2] - 1;
          return e.replace("{x}", u.toString()).replace("{y}", h.toString()).replace("{z}", l.toString());
        }, crossOrigin: "anonymous" }), o = new YC(a);
        return new D0(Qt(rt({}, n), { source: o }));
      }, mct = (n, t) => {
        const e = Qt(rt({}, n), { source: new jQ(t) });
        return new VC(e);
      }, _ct = (n, t) => {
        const e = rt({}, t);
        return new D0(Qt(rt({}, n), { source: new fct(e) }));
      }, Rs = (n, t) => {
        const e = (c) => {
          if (n) {
            const f = !!c;
            n == null || n.setVisible(f);
          }
        };
        P.watch(() => t.visible, (c) => {
          e(c);
        }, { deep: true });
        const i = (c) => {
          n == null || n.setExtent(c);
        };
        P.watch(() => t.extent, (c) => {
          i(c);
        }, { deep: true });
        const r = (c) => {
          (c || c === 0) && (n == null || n.setMaxResolution(c));
        };
        P.watch(() => t.maxResolution, (c) => {
          r(c);
        });
        const a = (c) => {
          (c || c === 0) && (n == null || n.setMinResolution(c));
        };
        P.watch(() => t.minResolution, (c) => {
          a(c);
        });
        const o = (c) => {
          (c || c === 0) && (n == null || n.setOpacity(c));
        };
        P.watch(() => t.opacity, (c) => {
          o(c);
        });
        const s = (c) => {
          (c || c === 0) && (n == null || n.setZIndex(c));
        };
        P.watch(() => t.zIndex, (c) => {
          s(c);
        });
        const l = (c) => {
          (c || c === 0) && (n == null || n.setMaxZoom(c));
        };
        P.watch(() => t.maxZoom, (c) => {
          l(c);
        });
        const u = (c) => {
          (c || c === 0) && (n == null || n.setMinZoom(c));
        };
        return P.watch(() => t.minZoom, (c) => {
          u(c);
        }), { onMounted: () => {
          e(t.visible), i(t.extent), r(t.maxResolution), a(t.minResolution), o(t.opacity), s(t.zIndex), l(t.maxZoom), u(t.minZoom);
        } };
      }, Lo = new Uint8Array(4);
      class $Q {
        constructor(t, e) {
          this.helper_ = t;
          const i = t.getGL();
          this.texture_ = i.createTexture(), this.framebuffer_ = i.createFramebuffer(), this.depthbuffer_ = i.createRenderbuffer(), this.size_ = e || [1, 1], this.data_ = new Uint8Array(0), this.dataCacheDirty_ = true, this.updateSize_();
        }
        setSize(t) {
          co(t, this.size_) || (this.size_[0] = t[0], this.size_[1] = t[1], this.updateSize_());
        }
        getSize() {
          return this.size_;
        }
        clearCachedData() {
          this.dataCacheDirty_ = true;
        }
        readAll() {
          if (this.dataCacheDirty_) {
            const t = this.size_, e = this.helper_.getGL();
            e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer_), e.readPixels(0, 0, t[0], t[1], e.RGBA, e.UNSIGNED_BYTE, this.data_), this.dataCacheDirty_ = false;
          }
          return this.data_;
        }
        readPixel(t, e) {
          if (t < 0 || e < 0 || t > this.size_[0] || e >= this.size_[1]) return Lo[0] = 0, Lo[1] = 0, Lo[2] = 0, Lo[3] = 0, Lo;
          this.readAll();
          const i = Math.floor(t) + (this.size_[1] - Math.floor(e) - 1) * this.size_[0];
          return Lo[0] = this.data_[i * 4], Lo[1] = this.data_[i * 4 + 1], Lo[2] = this.data_[i * 4 + 2], Lo[3] = this.data_[i * 4 + 3], Lo;
        }
        getTexture() {
          return this.texture_;
        }
        getFramebuffer() {
          return this.framebuffer_;
        }
        getDepthbuffer() {
          return this.depthbuffer_;
        }
        updateSize_() {
          const t = this.size_, e = this.helper_.getGL();
          this.texture_ = this.helper_.createTexture(t, null, this.texture_), e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer_), e.viewport(0, 0, t[0], t[1]), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.texture_, 0), e.bindRenderbuffer(e.RENDERBUFFER, this.depthbuffer_), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, t[0], t[1]), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, this.depthbuffer_), this.data_ = new Uint8Array(t[0] * t[1] * 4);
        }
      }
      const fp = { GENERATE_POLYGON_BUFFERS: "GENERATE_POLYGON_BUFFERS", GENERATE_POINT_BUFFERS: "GENERATE_POINT_BUFFERS", GENERATE_LINE_STRING_BUFFERS: "GENERATE_LINE_STRING_BUFFERS" };
      function ZQ() {
        const n = 'const t="GENERATE_POLYGON_BUFFERS",e="GENERATE_POINT_BUFFERS",n="GENERATE_LINE_STRING_BUFFERS";function r(t,e){const n=e[0],r=e[1];return e[0]=t[0]*n+t[2]*r+t[4],e[1]=t[1]*n+t[3]*r+t[5],e}function x(t,e){const n=(r=e)[0]*r[3]-r[1]*r[2];var r;!function(t,e){if(!t)throw new Error(e)}(0!==n,"Transformation matrix cannot be inverted");const x=e[0],o=e[1],u=e[2],i=e[3],f=e[4],s=e[5];return t[0]=i/n,t[1]=-o/n,t[2]=-u/n,t[3]=x/n,t[4]=(u*s-i*f)/n,t[5]=-(x*s-o*f)/n,t}function o(t,e,n=2){const r=e&&e.length,x=r?e[0]*n:t.length;let o=u(t,0,x,n,!0);const i=[];if(!o||o.next===o.prev)return i;let s,l,c;if(r&&(o=function(t,e,n,r){const x=[];for(let n=0,o=e.length;n<o;n++){const i=u(t,e[n]*r,n<o-1?e[n+1]*r:t.length,r,!1);i===i.next&&(i.steiner=!0),x.push(g(i))}x.sort(y);for(let t=0;t<x.length;t++)n=h(x[t],n);return n}(t,e,o,n)),t.length>80*n){s=1/0,l=1/0;let e=-1/0,r=-1/0;for(let o=n;o<x;o+=n){const n=t[o],x=t[o+1];n<s&&(s=n),x<l&&(l=x),n>e&&(e=n),x>r&&(r=x)}c=Math.max(e-s,r-l),c=0!==c?32767/c:0}return f(o,i,n,s,l,c,0),i}function u(t,e,n,r,x){let o;if(x===function(t,e,n,r){let x=0;for(let o=e,u=n-r;o<n;o+=r)x+=(t[u]-t[o])*(t[o+1]+t[u+1]),u=o;return x}(t,e,n,r)>0)for(let x=e;x<n;x+=r)o=z(x/r|0,t[x],t[x+1],o);else for(let x=n-r;x>=e;x-=r)o=z(x/r|0,t[x],t[x+1],o);return o&&M(o,o.next)&&(F(o),o=o.next),o}function i(t,e){if(!t)return t;e||(e=t);let n,r=t;do{if(n=!1,r.steiner||!M(r,r.next)&&0!==d(r.prev,r,r.next))r=r.next;else{if(F(r),r=e=r.prev,r===r.next)break;n=!0}}while(n||r!==e);return e}function f(t,e,n,r,x,o,u){if(!t)return;!u&&o&&function(t,e,n,r){let x=t;do{0===x.z&&(x.z=v(x.x,x.y,e,n,r)),x.prevZ=x.prev,x.nextZ=x.next,x=x.next}while(x!==t);x.prevZ.nextZ=null,x.prevZ=null,function(t){let e,n=1;do{let r,x=t;t=null;let o=null;for(e=0;x;){e++;let u=x,i=0;for(let t=0;t<n&&(i++,u=u.nextZ,u);t++);let f=n;for(;i>0||f>0&&u;)0!==i&&(0===f||!u||x.z<=u.z)?(r=x,x=x.nextZ,i--):(r=u,u=u.nextZ,f--),o?o.nextZ=r:t=r,r.prevZ=o,o=r;x=u}o.nextZ=null,n*=2}while(e>1)}(x)}(t,r,x,o);let y=t;for(;t.prev!==t.next;){const h=t.prev,p=t.next;if(o?l(t,r,x,o):s(t))e.push(h.i,t.i,p.i),F(t),t=p.next,y=p.next;else if((t=p)===y){u?1===u?f(t=c(i(t),e),e,n,r,x,o,2):2===u&&a(t,e,n,r,x,o):f(i(t),e,n,r,x,o,1);break}}}function s(t){const e=t.prev,n=t,r=t.next;if(d(e,n,r)>=0)return!1;const x=e.x,o=n.x,u=r.x,i=e.y,f=n.y,s=r.y,l=x<o?x<u?x:u:o<u?o:u,c=i<f?i<s?i:s:f<s?f:s,a=x>o?x>u?x:u:o>u?o:u,y=i>f?i>s?i:s:f>s?f:s;let h=r.next;for(;h!==e;){if(h.x>=l&&h.x<=a&&h.y>=c&&h.y<=y&&b(x,i,o,f,u,s,h.x,h.y)&&d(h.prev,h,h.next)>=0)return!1;h=h.next}return!0}function l(t,e,n,r){const x=t.prev,o=t,u=t.next;if(d(x,o,u)>=0)return!1;const i=x.x,f=o.x,s=u.x,l=x.y,c=o.y,a=u.y,y=i<f?i<s?i:s:f<s?f:s,h=l<c?l<a?l:a:c<a?c:a,p=i>f?i>s?i:s:f>s?f:s,g=l>c?l>a?l:a:c>a?c:a,Z=v(y,h,e,n,r),M=v(p,g,e,n,r);let w=t.prevZ,m=t.nextZ;for(;w&&w.z>=Z&&m&&m.z<=M;){if(w.x>=y&&w.x<=p&&w.y>=h&&w.y<=g&&w!==x&&w!==u&&b(i,l,f,c,s,a,w.x,w.y)&&d(w.prev,w,w.next)>=0)return!1;if(w=w.prevZ,m.x>=y&&m.x<=p&&m.y>=h&&m.y<=g&&m!==x&&m!==u&&b(i,l,f,c,s,a,m.x,m.y)&&d(m.prev,m,m.next)>=0)return!1;m=m.nextZ}for(;w&&w.z>=Z;){if(w.x>=y&&w.x<=p&&w.y>=h&&w.y<=g&&w!==x&&w!==u&&b(i,l,f,c,s,a,w.x,w.y)&&d(w.prev,w,w.next)>=0)return!1;w=w.prevZ}for(;m&&m.z<=M;){if(m.x>=y&&m.x<=p&&m.y>=h&&m.y<=g&&m!==x&&m!==u&&b(i,l,f,c,s,a,m.x,m.y)&&d(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function c(t,e){let n=t;do{const r=n.prev,x=n.next.next;!M(r,x)&&w(r,n,n.next,x)&&E(r,x)&&E(x,r)&&(e.push(r.i,n.i,x.i),F(n),F(n.next),n=t=x),n=n.next}while(n!==t);return i(n)}function a(t,e,n,r,x,o){let u=t;do{let t=u.next.next;for(;t!==u.prev;){if(u.i!==t.i&&Z(u,t)){let s=I(u,t);return u=i(u,u.next),s=i(s,s.next),f(u,e,n,r,x,o,0),void f(s,e,n,r,x,o,0)}t=t.next}u=u.next}while(u!==t)}function y(t,e){return t.x-e.x}function h(t,e){const n=function(t,e){let n=e;const r=t.x,x=t.y;let o,u=-1/0;do{if(x<=n.y&&x>=n.next.y&&n.next.y!==n.y){const t=n.x+(x-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=r&&t>u&&(u=t,o=n.x<n.next.x?n:n.next,t===r))return o}n=n.next}while(n!==e);if(!o)return null;const i=o,f=o.x,s=o.y;let l=1/0;n=o;do{if(r>=n.x&&n.x>=f&&r!==n.x&&b(x<s?r:u,x,f,s,x<s?u:r,x,n.x,n.y)){const e=Math.abs(x-n.y)/(r-n.x);E(n,t)&&(e<l||e===l&&(n.x>o.x||n.x===o.x&&p(o,n)))&&(o=n,l=e)}n=n.next}while(n!==i);return o}(t,e);if(!n)return e;const r=I(n,t);return i(r,r.next),i(n,n.next)}function p(t,e){return d(t.prev,t,e.prev)<0&&d(e.next,t,t.next)<0}function v(t,e,n,r,x){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-n)*x|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-r)*x|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function g(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function b(t,e,n,r,x,o,u,i){return(x-u)*(e-i)>=(t-u)*(o-i)&&(t-u)*(r-i)>=(n-u)*(e-i)&&(n-u)*(o-i)>=(x-u)*(r-i)}function Z(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&w(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(E(t,e)&&E(e,t)&&function(t,e){let n=t,r=!1;const x=(t.x+e.x)/2,o=(t.y+e.y)/2;do{n.y>o!=n.next.y>o&&n.next.y!==n.y&&x<(n.next.x-n.x)*(o-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==t);return r}(t,e)&&(d(t.prev,t,e.prev)||d(t,e.prev,e))||M(t,e)&&d(t.prev,t,t.next)>0&&d(e.prev,e,e.next)>0)}function d(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function M(t,e){return t.x===e.x&&t.y===e.y}function w(t,e,n,r){const x=A(d(t,e,n)),o=A(d(t,e,r)),u=A(d(n,r,t)),i=A(d(n,r,e));return x!==o&&u!==i||(!(0!==x||!m(t,n,e))||(!(0!==o||!m(t,r,e))||(!(0!==u||!m(n,t,r))||!(0!==i||!m(n,e,r)))))}function m(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function A(t){return t>0?1:t<0?-1:0}function E(t,e){return d(t.prev,t,t.next)<0?d(t,e,t.next)>=0&&d(t,t.prev,e)>=0:d(t,e,t.prev)<0||d(t,t.next,e)<0}function I(t,e){const n=P(t.i,t.x,t.y),r=P(e.i,e.x,e.y),x=t.next,o=e.prev;return t.next=e,e.prev=t,n.next=x,x.prev=n,r.next=n,n.prev=r,o.next=r,r.prev=o,r}function z(t,e,n,r){const x=P(t,e,n);return r?(x.next=r.next,x.prev=r,r.next.prev=x,r.next=x):(x.prev=x,x.next=x),x}function F(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function P(t,e,n){return{i:t,x:e,y:n,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}new Array(6);const B=[],N={vertexPosition:0,indexPosition:0};function R(t,e,n,r,x){t[e+0]=n,t[e+1]=r,t[e+2]=x}function S(t,e,n,r,x,o){const u=3+x,i=t[e+0],f=t[e+1],s=B;s.length=x;for(let n=0;n<s.length;n++)s[n]=t[e+2+n];let l=o?o.vertexPosition:0,c=o?o.indexPosition:0;const a=l/u;return R(n,l,i,f,0),s.length&&n.set(s,l+3),l+=u,R(n,l,i,f,1),s.length&&n.set(s,l+3),l+=u,R(n,l,i,f,2),s.length&&n.set(s,l+3),l+=u,R(n,l,i,f,3),s.length&&n.set(s,l+3),l+=u,r[c++]=a,r[c++]=a+1,r[c++]=a+3,r[c++]=a+1,r[c++]=a+2,r[c++]=a+3,N.vertexPosition=l,N.indexPosition=c,N}function T(t,e,n,x,o,u,i,f,s,l,c){const a=10+f.length,y=u.length/a,h=[t[e+0],t[e+1]],p=[t[n],t[n+1]],v=t[e+2],g=t[n+2],b=r(s,[...h]),Z=r(s,[...p]);function d(t,e,n){const r=Math.sqrt((e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])),x=[(e[0]-t[0])/r,(e[1]-t[1])/r],o=[-x[1],x[0]],u=Math.sqrt((n[0]-t[0])*(n[0]-t[0])+(n[1]-t[1])*(n[1]-t[1])),i=[(n[0]-t[0])/u,(n[1]-t[1])/u],f=0===r||0===u?0:Math.acos((s=i[0]*x[0]+i[1]*x[1],l=-1,c=1,Math.min(Math.max(s,l),c)));var s,l,c;return i[0]*o[0]+i[1]*o[1]>0?f:2*Math.PI-f}let M=-1,w=-1,m=c;const A=null!==o;if(null!==x){M=d(b,Z,r(s,[...[t[x],t[x+1]]])),Math.cos(M)<=.985&&(m+=Math.tan((M-Math.PI)/2))}if(A){w=d(Z,b,r(s,[...[t[o],t[o+1]]])),Math.cos(w)<=.985&&(m+=Math.tan((Math.PI-w)/2))}function E(t,e){return 0===e?1e4*t:Math.sign(e)*(1e4*t+Math.abs(e))}return u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(0,c)),u.push(...f),u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(1,c)),u.push(...f),u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(2,c)),u.push(...f),u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(3,c)),u.push(...f),i.push(y,y+1,y+2,y+1,y+3,y+2),{length:l+Math.sqrt((Z[0]-b[0])*(Z[0]-b[0])+(Z[1]-b[1])*(Z[1]-b[1])),angle:m}}function _(t,e,n,r,x){const u=2+x;let i=e;const f=t.slice(i,i+x);i+=x;const s=t[i++];let l=0;const c=new Array(s-1);for(let e=0;e<s;e++)l+=t[i++],e<s-1&&(c[e]=l);const a=t.slice(i,i+2*l),y=o(a,c,2);for(let t=0;t<y.length;t++)r.push(y[t]+n.length/u);for(let t=0;t<a.length;t+=2)n.push(a[t],a[t+1],...f);return i+2*l}const O=self;O.onmessage=r=>{const o=r.data;switch(o.type){case e:{const t=3,e=2,n=o.customAttributesSize,r=e+n,x=new Float32Array(o.renderInstructions),u=x.length/r,i=4*u*(n+t),f=new Uint32Array(6*u),s=new Float32Array(i);let l;for(let t=0;t<x.length;t+=r)l=S(x,t,s,f,n,l);const c=Object.assign({vertexBuffer:s.buffer,indexBuffer:f.buffer,renderInstructions:x.buffer},o);O.postMessage(c,[s.buffer,f.buffer,x.buffer]);break}case n:{const t=[],e=[],n=o.customAttributesSize,r=3,u=new Float32Array(o.renderInstructions);let i=0;const f=[1,0,0,1,0,0];let s,l;for(x(f,o.renderInstructionsTransform);i<u.length;){l=Array.from(u.slice(i,i+n)),i+=n,s=u[i++];const x=i,o=i+(s-1)*r,c=u[x]===u[o]&&u[x+1]===u[o+1];let a=0,y=0;for(let n=0;n<s-1;n++){let h=null;n>0?h=i+(n-1)*r:c&&(h=o-r);let p=null;n<s-2?p=i+(n+2)*r:c&&(p=x+r);const v=T(u,i+n*r,i+(n+1)*r,h,p,t,e,l,f,a,y);a=v.length,y=v.angle}i+=s*r}const c=Uint32Array.from(e),a=Float32Array.from(t),y=Object.assign({vertexBuffer:a.buffer,indexBuffer:c.buffer,renderInstructions:u.buffer},o);O.postMessage(y,[a.buffer,c.buffer,u.buffer]);break}case t:{const t=[],e=[],n=o.customAttributesSize,r=new Float32Array(o.renderInstructions);let x=0;for(;x<r.length;)x=_(r,x,t,e,n);const u=Uint32Array.from(e),i=Float32Array.from(t),f=Object.assign({vertexBuffer:i.buffer,indexBuffer:u.buffer,renderInstructions:r.buffer},o);O.postMessage(f,[i.buffer,u.buffer,r.buffer]);break}}};';
        return new Worker(typeof Blob == "undefined" ? "data:application/javascript;base64," + Buffer.from(n, "binary").toString("base64") : URL.createObjectURL(new Blob([n], { type: "application/javascript" })));
      }
      function KQ(n, t) {
        const e = n.viewState.projection, r = t.getSource().getWrapX() && e.canWrapX(), a = e.getExtent(), o = n.extent, s = r ? he(a) : null, l = r ? Math.ceil((o[2] - a[2]) / s) + 1 : 1;
        return [r ? Math.floor((o[0] - a[0]) / s) : 0, l, s];
      }
      class Ect extends op {
        constructor(t, e) {
          var s;
          const i = e.uniforms || {}, r = an();
          i[To.PROJECTION_MATRIX] = r, super(t, { uniforms: i, postProcesses: e.postProcesses }), this.sourceRevision_ = -1, this.verticesBuffer_ = new Vf(ip, ap), this.indicesBuffer_ = new Vf(rp, ap), this.vertexShader_ = e.vertexShader, this.fragmentShader_ = e.fragmentShader, this.program_, this.hitDetectionEnabled_ = (s = e.hitDetectionEnabled) != null ? s : true;
          const a = e.attributes ? e.attributes.map(function(l) {
            return { name: "a_" + l.name, size: 1, type: Fn.FLOAT };
          }) : [];
          this.attributes = [{ name: "a_position", size: 2, type: Fn.FLOAT }, { name: "a_index", size: 1, type: Fn.FLOAT }], this.hitDetectionEnabled_ && (this.attributes.push({ name: "a_hitColor", size: 4, type: Fn.FLOAT }), this.attributes.push({ name: "a_featureUid", size: 1, type: Fn.FLOAT })), this.attributes.push(...a), this.customAttributes = e.attributes ? e.attributes : [], this.previousExtent_ = ai(), this.currentTransform_ = r, this.renderTransform_ = an(), this.invertRenderTransform_ = an(), this.renderInstructions_ = new Float32Array(0), this.hitRenderTarget_, this.lastSentId = 0, this.worker_ = ZQ(), this.worker_.addEventListener("message", (l) => {
            const u = l.data;
            if (u.type === fp.GENERATE_POINT_BUFFERS) {
              const h = u.projectionTransform;
              this.verticesBuffer_.fromArrayBuffer(u.vertexBuffer), this.helper.flushBufferData(this.verticesBuffer_), this.indicesBuffer_.fromArrayBuffer(u.indexBuffer), this.helper.flushBufferData(this.indicesBuffer_), this.renderTransform_ = h, ml(this.invertRenderTransform_, this.renderTransform_), this.renderInstructions_ = new Float32Array(l.data.renderInstructions), u.id === this.lastSentId && (this.ready = true), this.getLayer().changed();
            }
          }), this.featureCache_ = {}, this.featureCount_ = 0;
          const o = this.getLayer().getSource();
          this.sourceListenKeys_ = [Ut(o, An.ADDFEATURE, this.handleSourceFeatureAdded_, this), Ut(o, An.CHANGEFEATURE, this.handleSourceFeatureChanged_, this), Ut(o, An.REMOVEFEATURE, this.handleSourceFeatureDelete_, this), Ut(o, An.CLEAR, this.handleSourceFeatureClear_, this)], o.forEachFeature((l) => {
            this.featureCache_[xt(l)] = { feature: l, properties: l.getProperties(), geometry: l.getGeometry() }, this.featureCount_++;
          });
        }
        afterHelperCreated() {
          this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_), this.hitDetectionEnabled_ && (this.hitRenderTarget_ = new $Q(this.helper)), this.verticesBuffer_.getArray() && this.helper.flushBufferData(this.verticesBuffer_), this.indicesBuffer_.getArray() && this.helper.flushBufferData(this.indicesBuffer_);
        }
        handleSourceFeatureAdded_(t) {
          const e = t.feature;
          this.featureCache_[xt(e)] = { feature: e, properties: e.getProperties(), geometry: e.getGeometry() }, this.featureCount_++;
        }
        handleSourceFeatureChanged_(t) {
          const e = t.feature;
          this.featureCache_[xt(e)] = { feature: e, properties: e.getProperties(), geometry: e.getGeometry() };
        }
        handleSourceFeatureDelete_(t) {
          const e = t.feature;
          delete this.featureCache_[xt(e)], this.featureCount_--;
        }
        handleSourceFeatureClear_() {
          this.featureCache_ = {}, this.featureCount_ = 0;
        }
        renderFrame(t) {
          const e = this.helper.getGL();
          this.preRender(e, t);
          const [i, r, a] = KQ(t, this.getLayer());
          return this.renderWorlds(t, false, i, r, a), this.helper.finalizeDraw(t, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent), this.hitDetectionEnabled_ && (this.renderWorlds(t, true, i, r, a), this.hitRenderTarget_.clearCachedData()), this.postRender(e, t), this.helper.getCanvas();
        }
        prepareFrameInternal(t) {
          const e = this.getLayer(), i = e.getSource(), r = t.viewState, a = !t.viewHints[xn.ANIMATING] && !t.viewHints[xn.INTERACTING], o = !As(this.previousExtent_, t.extent), s = this.sourceRevision_ < i.getRevision();
          if (s && (this.sourceRevision_ = i.getRevision()), a && (o || s)) {
            const l = r.projection, u = r.resolution, h = e instanceof bA ? e.getRenderBuffer() : 0, c = fo(t.extent, h * u);
            i.loadFeatures(c, u, l), this.rebuildBuffers_(t), this.previousExtent_ = t.extent.slice();
          }
          return this.helper.useProgram(this.program_, t), this.helper.prepareDraw(t), this.helper.bindBuffer(this.verticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.attributes), true;
        }
        rebuildBuffers_(t) {
          const e = an();
          this.helper.makeProjectionTransform(t, e);
          const r = (this.hitDetectionEnabled_ ? 7 : 2) + this.customAttributes.length, a = r * this.featureCount_;
          (!this.renderInstructions_ || this.renderInstructions_.length !== a) && (this.renderInstructions_ = new Float32Array(a));
          let o, s;
          const l = [], u = [];
          let h = -1;
          for (const f in this.featureCache_) if (o = this.featureCache_[f], s = o.geometry, !(!s || s.getType() !== "Point")) {
            if (l[0] = s.getFlatCoordinates()[0], l[1] = s.getFlatCoordinates()[1], nn(e, l), this.renderInstructions_[++h] = l[0], this.renderInstructions_[++h] = l[1], this.hitDetectionEnabled_) {
              const g = rQ(h + 5, u);
              this.renderInstructions_[++h] = g[0], this.renderInstructions_[++h] = g[1], this.renderInstructions_[++h] = g[2], this.renderInstructions_[++h] = g[3], this.renderInstructions_[++h] = Number(f);
            }
            for (let g = 0; g < this.customAttributes.length; g++) {
              const d = this.customAttributes[g].callback(o.feature, o.properties);
              this.renderInstructions_[++h] = d;
            }
          }
          const c = { id: ++this.lastSentId, type: fp.GENERATE_POINT_BUFFERS, renderInstructions: this.renderInstructions_.buffer, customAttributesSize: r - 2 };
          c.projectionTransform = e, this.ready = false, this.worker_.postMessage(c, [this.renderInstructions_.buffer]), this.renderInstructions_ = null;
        }
        forEachFeatureAtCoordinate(t, e, i, r, a) {
          if (ue(this.hitDetectionEnabled_, "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option."), !this.renderInstructions_ || !this.hitDetectionEnabled_) return;
          const o = nn(e.coordinateToPixelTransform, t.slice()), s = this.hitRenderTarget_.readPixel(o[0] / 2, o[1] / 2), l = [s[0] / 255, s[1] / 255, s[2] / 255, s[3] / 255], u = aQ(l), h = this.renderInstructions_[u], c = Math.floor(h).toString(), g = this.getLayer().getSource().getFeatureByUid(c);
          if (g) return r(g, this.getLayer(), null);
        }
        renderWorlds(t, e, i, r, a) {
          let o = i;
          this.helper.useProgram(this.program_, t), e && (this.hitRenderTarget_.setSize([Math.floor(t.size[0] / 2), Math.floor(t.size[1] / 2)]), this.helper.prepareDrawToRenderTarget(t, this.hitRenderTarget_, true)), this.helper.bindBuffer(this.verticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.attributes);
          do {
            this.helper.makeProjectionTransform(t, this.currentTransform_), Ix(this.currentTransform_, o * a, 0), Ou(this.currentTransform_, this.invertRenderTransform_), this.helper.applyUniforms(t), this.helper.applyHitDetectionUniform(e);
            const s = this.indicesBuffer_.getSize();
            this.helper.drawElements(0, s);
          } while (++o < r);
        }
        disposeInternal() {
          this.worker_.terminate(), this.sourceListenKeys_.forEach(function(t) {
            we(t);
          }), this.sourceListenKeys_ = null, super.disposeInternal();
        }
        renderDeclutter() {
        }
      }
      const ja = { BLUR: "blur", GRADIENT: "gradient", RADIUS: "radius" }, Ict = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
      class xct extends bA {
        constructor(t) {
          t = t || {};
          const e = Object.assign({}, t);
          delete e.gradient, delete e.radius, delete e.blur, delete e.weight, super(e), this.gradient_ = null, this.addChangeListener(ja.GRADIENT, this.handleGradientChanged_), this.setGradient(t.gradient ? t.gradient : Ict), this.setBlur(t.blur !== void 0 ? t.blur : 15), this.setRadius(t.radius !== void 0 ? t.radius : 8);
          const i = t.weight ? t.weight : "weight";
          this.weightFunction_ = typeof i == "string" ? (r) => r.get(i) : i, this.setRenderOrder(null);
        }
        getBlur() {
          return this.get(ja.BLUR);
        }
        getGradient() {
          return this.get(ja.GRADIENT);
        }
        getRadius() {
          return this.get(ja.RADIUS);
        }
        handleGradientChanged_() {
          this.gradient_ = wct(this.getGradient());
        }
        setBlur(t) {
          this.set(ja.BLUR, t);
        }
        setGradient(t) {
          this.set(ja.GRADIENT, t);
        }
        setRadius(t) {
          this.set(ja.RADIUS, t);
        }
        createRenderer() {
          const t = new oQ().addAttribute("float a_weight").addVarying("v_weight", "float", "a_weight").addUniform("float u_size").addUniform("float u_blurSlope").setSymbolSizeExpression("vec2(u_size)").setSymbolColorExpression("vec4(smoothstep(0., 1., (1. - length(coordsPx * 2. / v_quadSizePx)) * u_blurSlope) * v_weight)");
          return new Ect(this, { className: this.getClassName(), attributes: [{ name: "weight", callback: (e) => {
            const i = this.weightFunction_(e);
            return i !== void 0 ? Ze(i, 0, 1) : 1;
          } }], uniforms: { u_size: () => (this.get(ja.RADIUS) + this.get(ja.BLUR)) * 2, u_blurSlope: () => this.get(ja.RADIUS) / Math.max(1, this.get(ja.BLUR)) }, hitDetectionEnabled: true, vertexShader: t.getSymbolVertexShader(), fragmentShader: t.getSymbolFragmentShader(), postProcesses: [{ fragmentShader: `
            precision mediump float;

            uniform sampler2D u_image;
            uniform sampler2D u_gradientTexture;
            uniform float u_opacity;

            varying vec2 v_texCoord;

            void main() {
              vec4 color = texture2D(u_image, v_texCoord);
              gl_FragColor.a = color.a * u_opacity;
              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;
              gl_FragColor.rgb *= gl_FragColor.a;
            }`, uniforms: { u_gradientTexture: () => this.gradient_, u_opacity: () => this.getOpacity() } }] });
        }
        renderDeclutter() {
        }
      }
      function wct(n) {
        const i = In(1, 256), r = i.createLinearGradient(0, 0, 1, 256), a = 1 / (n.length - 1);
        for (let o = 0, s = n.length; o < s; ++o) r.addColorStop(o * a, n[o]);
        return i.fillStyle = r, i.fillRect(0, 0, 1, 256), i.canvas;
      }
      class Cct {
        constructor() {
          this.globalCounter_ = 0, this.refToFeature_ = /* @__PURE__ */ new Map(), this.uidToRef_ = /* @__PURE__ */ new Map(), this.freeGlobalRef_ = [], this.polygonBatch = { entries: {}, geometriesCount: 0, verticesCount: 0, ringsCount: 0 }, this.pointBatch = { entries: {}, geometriesCount: 0 }, this.lineStringBatch = { entries: {}, geometriesCount: 0, verticesCount: 0 };
        }
        addFeatures(t, e) {
          for (let i = 0; i < t.length; i++) this.addFeature(t[i], e);
        }
        addFeature(t, e) {
          let i = t.getGeometry();
          i && (e && (i = i.clone(), i.applyTransform(e)), this.addGeometry_(i, t));
        }
        clearFeatureEntryInPointBatch_(t) {
          const e = xt(t), i = this.pointBatch.entries[e];
          if (i) return this.pointBatch.geometriesCount -= i.flatCoordss.length, delete this.pointBatch.entries[e], i;
        }
        clearFeatureEntryInLineStringBatch_(t) {
          const e = xt(t), i = this.lineStringBatch.entries[e];
          if (i) return this.lineStringBatch.verticesCount -= i.verticesCount, this.lineStringBatch.geometriesCount -= i.flatCoordss.length, delete this.lineStringBatch.entries[e], i;
        }
        clearFeatureEntryInPolygonBatch_(t) {
          const e = xt(t), i = this.polygonBatch.entries[e];
          if (i) return this.polygonBatch.verticesCount -= i.verticesCount, this.polygonBatch.ringsCount -= i.ringsCount, this.polygonBatch.geometriesCount -= i.flatCoordss.length, delete this.polygonBatch.entries[e], i;
        }
        addGeometry_(t, e) {
          var r;
          const i = t.getType();
          switch (i) {
            case "GeometryCollection": {
              const a = t.getGeometriesArray();
              for (const o of a) this.addGeometry_(o, e);
              break;
            }
            case "MultiPolygon": {
              const a = t;
              this.addCoordinates_(i, a.getFlatCoordinates(), a.getEndss(), e, xt(e), a.getStride());
              break;
            }
            case "MultiLineString": {
              const a = t;
              this.addCoordinates_(i, a.getFlatCoordinates(), a.getEnds(), e, xt(e), a.getStride());
              break;
            }
            case "MultiPoint": {
              const a = t;
              this.addCoordinates_(i, a.getFlatCoordinates(), null, e, xt(e), a.getStride());
              break;
            }
            case "Polygon": {
              const a = t;
              this.addCoordinates_(i, a.getFlatCoordinates(), a.getEnds(), e, xt(e), a.getStride());
              break;
            }
            case "Point": {
              const a = t;
              this.addCoordinates_(i, a.getFlatCoordinates(), null, e, xt(e), a.getStride());
              break;
            }
            case "LineString":
            case "LinearRing": {
              const a = t, o = a.getStride();
              this.addCoordinates_(i, a.getFlatCoordinates(), null, e, xt(e), o, (r = a.getLayout) == null ? void 0 : r.call(a));
              break;
            }
          }
        }
        addCoordinates_(t, e, i, r, a, o, s) {
          let l;
          switch (t) {
            case "MultiPolygon": {
              const u = i;
              for (let h = 0, c = u.length; h < c; h++) {
                let f = u[h];
                const g = h > 0 ? u[h - 1] : null, d = g ? g[g.length - 1] : 0, A = f[f.length - 1];
                f = d > 0 ? f.map((p) => p - d) : f, this.addCoordinates_("Polygon", e.slice(d, A), f, r, a, o, s);
              }
              break;
            }
            case "MultiLineString": {
              const u = i;
              for (let h = 0, c = u.length; h < c; h++) {
                const f = h > 0 ? u[h - 1] : 0;
                this.addCoordinates_("LineString", e.slice(f, u[h]), null, r, a, o, s);
              }
              break;
            }
            case "MultiPoint":
              for (let u = 0, h = e.length; u < h; u += o) this.addCoordinates_("Point", e.slice(u, u + 2), null, r, a, null, null);
              break;
            case "Polygon": {
              const u = i;
              if (r instanceof Ti) {
                const f = ew(e, u);
                if (f.length > 1) {
                  this.addCoordinates_("MultiPolygon", e, f, r, a, o, s);
                  return;
                }
              }
              this.polygonBatch.entries[a] || (this.polygonBatch.entries[a] = this.addRefToEntry_(a, { feature: r, flatCoordss: [], verticesCount: 0, ringsCount: 0, ringsVerticesCounts: [] })), l = e.length / o;
              const h = i.length, c = i.map((f, g, d) => g > 0 ? (f - d[g - 1]) / o : f / o);
              this.polygonBatch.verticesCount += l, this.polygonBatch.ringsCount += h, this.polygonBatch.geometriesCount++, this.polygonBatch.entries[a].flatCoordss.push(Sct(e, o)), this.polygonBatch.entries[a].ringsVerticesCounts.push(c), this.polygonBatch.entries[a].verticesCount += l, this.polygonBatch.entries[a].ringsCount += h;
              for (let f = 0, g = u.length; f < g; f++) {
                const d = f > 0 ? u[f - 1] : 0;
                this.addCoordinates_("LinearRing", e.slice(d, u[f]), null, r, a, o, s);
              }
              break;
            }
            case "Point":
              this.pointBatch.entries[a] || (this.pointBatch.entries[a] = this.addRefToEntry_(a, { feature: r, flatCoordss: [] })), this.pointBatch.geometriesCount++, this.pointBatch.entries[a].flatCoordss.push(e);
              break;
            case "LineString":
            case "LinearRing":
              this.lineStringBatch.entries[a] || (this.lineStringBatch.entries[a] = this.addRefToEntry_(a, { feature: r, flatCoordss: [], verticesCount: 0 })), l = e.length / o, this.lineStringBatch.verticesCount += l, this.lineStringBatch.geometriesCount++, this.lineStringBatch.entries[a].flatCoordss.push(bct(e, o, s)), this.lineStringBatch.entries[a].verticesCount += l;
              break;
          }
        }
        addRefToEntry_(t, e) {
          const i = this.uidToRef_.get(t), r = i || this.freeGlobalRef_.pop() || ++this.globalCounter_;
          return e.ref = r, i || (this.refToFeature_.set(r, e.feature), this.uidToRef_.set(t, r)), e;
        }
        returnRef_(t, e) {
          if (!t) throw new Error("This feature has no ref: " + e);
          this.refToFeature_.delete(t), this.uidToRef_.delete(e), this.freeGlobalRef_.push(t);
        }
        changeFeature(t) {
          this.removeFeature(t);
          const e = t.getGeometry();
          e && this.addGeometry_(e, t);
        }
        removeFeature(t) {
          let e;
          e = this.clearFeatureEntryInPointBatch_(t) || e, e = this.clearFeatureEntryInPolygonBatch_(t) || e, e = this.clearFeatureEntryInLineStringBatch_(t) || e, e && this.returnRef_(e.ref, xt(e.feature));
        }
        clear() {
          this.polygonBatch.entries = {}, this.polygonBatch.geometriesCount = 0, this.polygonBatch.verticesCount = 0, this.polygonBatch.ringsCount = 0, this.lineStringBatch.entries = {}, this.lineStringBatch.geometriesCount = 0, this.lineStringBatch.verticesCount = 0, this.pointBatch.entries = {}, this.pointBatch.geometriesCount = 0, this.globalCounter_ = 0, this.freeGlobalRef_ = [], this.refToFeature_.clear(), this.uidToRef_.clear();
        }
        getFeatureFromRef(t) {
          return this.refToFeature_.get(t);
        }
      }
      function Sct(n, t) {
        return t === 2 ? n : n.filter((e, i) => i % t < 2);
      }
      function bct(n, t, e) {
        return t === 3 && e === "XYM" ? n : t === 4 ? n.filter((i, r) => r % t !== 2) : t === 3 ? n.map((i, r) => r % t !== 2 ? i : 0) : new Array(n.length * 1.5).fill(0).map((i, r) => r % 3 === 2 ? 0 : n[Math.round(r / 1.5)]);
      }
      function IS(n, t, e, i) {
        var a;
        let r = 0;
        for (const o in t) {
          const s = t[o], l = s.callback.call(e, e.feature);
          n[i + r++] = (a = l[0]) != null ? a : l, !(!s.size || s.size === 1) && (n[i + r++] = l[1], !(s.size < 3) && (n[i + r++] = l[2], !(s.size < 4) && (n[i + r++] = l[3])));
        }
        return r;
      }
      function Y0(n) {
        return Object.keys(n).reduce((t, e) => t + (n[e].size || 1), 0);
      }
      function Tct(n, t, e, i) {
        const r = (2 + Y0(e)) * n.geometriesCount;
        (!t || t.length !== r) && (t = new Float32Array(r));
        const a = [];
        let o = 0;
        for (const s in n.entries) {
          const l = n.entries[s];
          for (let u = 0, h = l.flatCoordss.length; u < h; u++) a[0] = l.flatCoordss[u][0], a[1] = l.flatCoordss[u][1], nn(i, a), t[o++] = a[0], t[o++] = a[1], o += IS(t, e, l, o);
        }
        return t;
      }
      function Bct(n, t, e, i) {
        const r = 3 * n.verticesCount + (1 + Y0(e)) * n.geometriesCount;
        (!t || t.length !== r) && (t = new Float32Array(r));
        const a = [];
        let o = 0;
        for (const s in n.entries) {
          const l = n.entries[s];
          for (let u = 0, h = l.flatCoordss.length; u < h; u++) {
            a.length = l.flatCoordss[u].length, yo(l.flatCoordss[u], 0, a.length, 3, i, a, 3), o += IS(t, e, l, o), t[o++] = a.length / 3;
            for (let c = 0, f = a.length; c < f; c += 3) t[o++] = a[c], t[o++] = a[c + 1], t[o++] = a[c + 2];
          }
        }
        return t;
      }
      function Mct(n, t, e, i) {
        const r = 2 * n.verticesCount + (1 + Y0(e)) * n.geometriesCount + n.ringsCount;
        (!t || t.length !== r) && (t = new Float32Array(r));
        const a = [];
        let o = 0;
        for (const s in n.entries) {
          const l = n.entries[s];
          for (let u = 0, h = l.flatCoordss.length; u < h; u++) {
            a.length = l.flatCoordss[u].length, yo(l.flatCoordss[u], 0, a.length, 2, i, a), o += IS(t, e, l, o), t[o++] = l.ringsVerticesCounts[u].length;
            for (let c = 0, f = l.ringsVerticesCounts[u].length; c < f; c++) t[o++] = l.ringsVerticesCounts[u][c];
            for (let c = 0, f = a.length; c < f; c += 2) t[o++] = a[c], t[o++] = a[c + 1];
          }
        }
        return t;
      }
      const Dct = [], xS = ZQ();
      let Rct = 0;
      const Po = { POSITION: "a_position", INDEX: "a_index", SEGMENT_START: "a_segmentStart", SEGMENT_END: "a_segmentEnd", MEASURE_START: "a_measureStart", MEASURE_END: "a_measureEnd", PARAMETERS: "a_parameters", JOIN_ANGLES: "a_joinAngles", DISTANCE: "a_distance" };
      class Lct {
        constructor(t, e, i, r) {
          this.helper_, this.hitDetectionEnabled_ = r;
          let a = t;
          if (!("builder" in t)) {
            const u = jlt(t, e);
            a = { builder: u.builder, attributes: u.attributes, uniforms: u.uniforms };
          }
          this.fillProgram_, this.strokeProgram_, this.symbolProgram_, this.hasFill_ = !!a.builder.getFillVertexShader(), this.hasFill_ && (this.fillVertexShader_ = a.builder.getFillVertexShader(), this.fillFragmentShader_ = a.builder.getFillFragmentShader()), this.hasStroke_ = !!a.builder.getStrokeVertexShader(), this.hasStroke_ && (this.strokeVertexShader_ = a.builder.getStrokeVertexShader(), this.strokeFragmentShader_ = a.builder.getStrokeFragmentShader()), this.hasSymbol_ = !!a.builder.getSymbolVertexShader(), this.hasSymbol_ && (this.symbolVertexShader_ = a.builder.getSymbolVertexShader(), this.symbolFragmentShader_ = a.builder.getSymbolFragmentShader());
          const s = this.hitDetectionEnabled_ ? { hitColor: { callback() {
            return rQ(this.ref, Dct);
          }, size: 4 } } : {};
          this.customAttributes_ = Object.assign({}, s, a.attributes), this.uniforms_ = a.uniforms;
          const l = Object.entries(this.customAttributes_).map(([u, h]) => ({ name: `a_${u}`, size: h.size || 1, type: Fn.FLOAT }));
          this.polygonAttributesDesc_ = [{ name: Po.POSITION, size: 2, type: Fn.FLOAT }, ...l], this.lineStringAttributesDesc_ = [{ name: Po.SEGMENT_START, size: 2, type: Fn.FLOAT }, { name: Po.MEASURE_START, size: 1, type: Fn.FLOAT }, { name: Po.SEGMENT_END, size: 2, type: Fn.FLOAT }, { name: Po.MEASURE_END, size: 1, type: Fn.FLOAT }, { name: Po.JOIN_ANGLES, size: 2, type: Fn.FLOAT }, { name: Po.DISTANCE, size: 1, type: Fn.FLOAT }, { name: Po.PARAMETERS, size: 1, type: Fn.FLOAT }, ...l], this.pointAttributesDesc_ = [{ name: Po.POSITION, size: 2, type: Fn.FLOAT }, { name: Po.INDEX, size: 1, type: Fn.FLOAT }, ...l], this.setHelper(i);
        }
        generateBuffers(t, e) {
          return Tt(this, null, function* () {
            const i = this.generateRenderInstructions_(t, e), [r, a, o] = yield Promise.all([this.generateBuffersForType_(i.polygonInstructions, "Polygon", e), this.generateBuffersForType_(i.lineStringInstructions, "LineString", e), this.generateBuffersForType_(i.pointInstructions, "Point", e)]), s = ml(an(), e);
            return { polygonBuffers: r, lineStringBuffers: a, pointBuffers: o, invertVerticesTransform: s };
          });
        }
        generateRenderInstructions_(t, e) {
          const i = this.hasFill_ ? Mct(t.polygonBatch, new Float32Array(0), this.customAttributes_, e) : null, r = this.hasStroke_ ? Bct(t.lineStringBatch, new Float32Array(0), this.customAttributes_, e) : null, a = this.hasSymbol_ ? Tct(t.pointBatch, new Float32Array(0), this.customAttributes_, e) : null;
          return { polygonInstructions: i, lineStringInstructions: r, pointInstructions: a };
        }
        generateBuffersForType_(t, e, i) {
          if (t === null) return null;
          const r = Rct++;
          let a;
          switch (e) {
            case "Polygon":
              a = fp.GENERATE_POLYGON_BUFFERS;
              break;
            case "LineString":
              a = fp.GENERATE_LINE_STRING_BUFFERS;
              break;
            case "Point":
              a = fp.GENERATE_POINT_BUFFERS;
              break;
          }
          const o = { id: r, type: a, renderInstructions: t.buffer, renderInstructionsTransform: i, customAttributesSize: Y0(this.customAttributes_) };
          return xS.postMessage(o, [t.buffer]), t = null, new Promise((s) => {
            const l = (u) => {
              const h = u.data;
              if (h.id !== r || (xS.removeEventListener("message", l), !this.helper_.getGL())) return;
              const c = new Vf(ip, ap).fromArrayBuffer(h.vertexBuffer), f = new Vf(rp, ap).fromArrayBuffer(h.indexBuffer);
              this.helper_.flushBufferData(c), this.helper_.flushBufferData(f), s([f, c]);
            };
            xS.addEventListener("message", l);
          });
        }
        render(t, e, i) {
          this.hasFill_ && this.renderInternal_(t.polygonBuffers[0], t.polygonBuffers[1], this.fillProgram_, this.polygonAttributesDesc_, e, i), this.hasStroke_ && this.renderInternal_(t.lineStringBuffers[0], t.lineStringBuffers[1], this.strokeProgram_, this.lineStringAttributesDesc_, e, i), this.hasSymbol_ && this.renderInternal_(t.pointBuffers[0], t.pointBuffers[1], this.symbolProgram_, this.pointAttributesDesc_, e, i);
        }
        renderInternal_(t, e, i, r, a, o) {
          const s = t.getSize();
          s !== 0 && (this.helper_.useProgram(i, a), this.helper_.bindBuffer(e), this.helper_.bindBuffer(t), this.helper_.enableAttributes(r), o(), this.helper_.drawElements(0, s));
        }
        setHelper(t, e = null) {
          this.helper_ = t, this.hasFill_ && (this.fillProgram_ = this.helper_.getProgram(this.fillFragmentShader_, this.fillVertexShader_)), this.hasStroke_ && (this.strokeProgram_ = this.helper_.getProgram(this.strokeFragmentShader_, this.strokeVertexShader_)), this.hasSymbol_ && (this.symbolProgram_ = this.helper_.getProgram(this.symbolFragmentShader_, this.symbolVertexShader_)), this.helper_.addUniforms(this.uniforms_), e && (e.polygonBuffers && (this.helper_.flushBufferData(e.polygonBuffers[0]), this.helper_.flushBufferData(e.polygonBuffers[1])), e.lineStringBuffers && (this.helper_.flushBufferData(e.lineStringBuffers[0]), this.helper_.flushBufferData(e.lineStringBuffers[1])), e.pointBuffers && (this.helper_.flushBufferData(e.pointBuffers[0]), this.helper_.flushBufferData(e.pointBuffers[1])));
        }
      }
      const ig = Qt(rt({}, To), { RENDER_EXTENT: "u_renderExtent", PATTERN_ORIGIN: "u_patternOrigin", GLOBAL_ALPHA: "u_globalAlpha" });
      class Pct extends op {
        constructor(t, e) {
          const i = { [ig.RENDER_EXTENT]: [0, 0, 0, 0], [ig.PATTERN_ORIGIN]: [0, 0], [ig.GLOBAL_ALPHA]: 1 };
          super(t, { uniforms: i, postProcesses: e.postProcesses }), this.hitDetectionEnabled_ = !e.disableHitDetection, this.hitRenderTarget_, this.sourceRevision_ = -1, this.previousExtent_ = ai(), this.currentTransform_ = an(), this.tmpCoords_ = [0, 0], this.tmpTransform_ = an(), this.tmpMat4_ = ih(), this.currentFrameStateTransform_ = an(), this.styleVariables_ = {}, this.styles_ = [], this.styleRenderers_ = [], this.buffers_ = [], this.applyOptions_(e), this.batch_ = new Cct(), this.initialFeaturesAdded_ = false, this.sourceListenKeys_ = null;
        }
        addInitialFeatures_(t) {
          const e = this.getLayer().getSource();
          let i;
          this.batch_.addFeatures(e.getFeatures(), i), this.sourceListenKeys_ = [Ut(e, An.ADDFEATURE, this.handleSourceFeatureAdded_.bind(this, i)), Ut(e, An.CHANGEFEATURE, this.handleSourceFeatureChanged_, this), Ut(e, An.REMOVEFEATURE, this.handleSourceFeatureDelete_, this), Ut(e, An.CLEAR, this.handleSourceFeatureClear_, this)];
        }
        applyOptions_(t) {
          this.styleVariables_ = t.variables, this.styles_ = Array.isArray(t.style) ? t.style : [t.style];
        }
        createRenderers_() {
          this.buffers_ = [], this.styleRenderers_ = this.styles_.map((t) => new Lct(t, this.styleVariables_, this.helper, this.hitDetectionEnabled_));
        }
        reset(t) {
          this.applyOptions_(t), this.helper && this.createRenderers_(), super.reset(t);
        }
        afterHelperCreated() {
          this.styleRenderers_.length ? this.styleRenderers_.forEach((t, e) => t.setHelper(this.helper, this.buffers_[e])) : this.createRenderers_(), this.hitDetectionEnabled_ && (this.hitRenderTarget_ = new $Q(this.helper));
        }
        handleSourceFeatureAdded_(t, e) {
          const i = e.feature;
          this.batch_.addFeature(i, t);
        }
        handleSourceFeatureChanged_(t) {
          const e = t.feature;
          this.batch_.changeFeature(e);
        }
        handleSourceFeatureDelete_(t) {
          const e = t.feature;
          this.batch_.removeFeature(e);
        }
        handleSourceFeatureClear_() {
          this.batch_.clear();
        }
        applyUniforms_(t) {
          FP(this.tmpTransform_, this.currentFrameStateTransform_), Ou(this.tmpTransform_, t), this.helper.setUniformMatrixValue(ig.PROJECTION_MATRIX, B0(this.tmpMat4_, this.tmpTransform_)), ml(this.tmpTransform_, this.tmpTransform_), this.helper.setUniformMatrixValue(ig.SCREEN_TO_WORLD_MATRIX, B0(this.tmpMat4_, this.tmpTransform_)), this.tmpCoords_[0] = 0, this.tmpCoords_[1] = 0, ml(this.tmpTransform_, t), nn(this.tmpTransform_, this.tmpCoords_), this.helper.setUniformFloatVec2(ig.PATTERN_ORIGIN, this.tmpCoords_);
        }
        renderFrame(t) {
          const e = this.helper.getGL();
          this.preRender(e, t);
          const [i, r, a] = KQ(t, this.getLayer());
          this.helper.prepareDraw(t), this.renderWorlds(t, false, i, r, a), this.helper.finalizeDraw(t, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
          const o = this.helper.getCanvas();
          return this.hitDetectionEnabled_ && (this.renderWorlds(t, true, i, r, a), this.hitRenderTarget_.clearCachedData()), this.postRender(e, t), o;
        }
        prepareFrameInternal(t) {
          this.initialFeaturesAdded_ || (this.addInitialFeatures_(t), this.initialFeaturesAdded_ = true);
          const e = this.getLayer(), i = e.getSource(), r = t.viewState, a = !t.viewHints[xn.ANIMATING] && !t.viewHints[xn.INTERACTING], o = !As(this.previousExtent_, t.extent), s = this.sourceRevision_ < i.getRevision();
          if (s && (this.sourceRevision_ = i.getRevision()), a && (o || s)) {
            const l = r.projection, u = r.resolution, h = e instanceof bA ? e.getRenderBuffer() : 0, c = fo(t.extent, h * u);
            i.loadFeatures(c, u, l), this.ready = false;
            const f = this.helper.makeProjectionTransform(t, an()), g = this.styleRenderers_.map((d, A) => d.generateBuffers(this.batch_, f).then((p) => {
              this.buffers_[A] && this.disposeBuffers(this.buffers_[A]), this.buffers_[A] = p;
            }));
            Promise.all(g).then(() => {
              this.ready = true, this.getLayer().changed();
            }), this.previousExtent_ = t.extent.slice();
          }
          return true;
        }
        renderWorlds(t, e, i, r, a) {
          let o = i;
          e && (this.hitRenderTarget_.setSize([Math.floor(t.size[0] / 2), Math.floor(t.size[1] / 2)]), this.helper.prepareDrawToRenderTarget(t, this.hitRenderTarget_, true));
          do {
            this.helper.makeProjectionTransform(t, this.currentFrameStateTransform_), Ix(this.currentFrameStateTransform_, o * a, 0);
            for (let s = 0, l = this.styleRenderers_.length; s < l; s++) {
              const u = this.styleRenderers_[s], h = this.buffers_[s];
              h && u.render(h, t, () => {
                this.applyUniforms_(h.invertVerticesTransform), this.helper.applyHitDetectionUniform(e);
              });
            }
          } while (++o < r);
        }
        forEachFeatureAtCoordinate(t, e, i, r, a) {
          if (ue(this.hitDetectionEnabled_, "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option."), !this.styleRenderers_.length || !this.hitDetectionEnabled_) return;
          const o = nn(e.coordinateToPixelTransform, t.slice()), s = this.hitRenderTarget_.readPixel(o[0] / 2, o[1] / 2), l = [s[0] / 255, s[1] / 255, s[2] / 255, s[3] / 255], u = aQ(l), h = this.batch_.getFeatureFromRef(u);
          if (h) return r(h, this.getLayer(), null);
        }
        disposeBuffers(t) {
          t.pointBuffers && t.pointBuffers.filter(Boolean).forEach((e) => this.helper.deleteBuffer(e)), t.lineStringBuffers && t.lineStringBuffers.filter(Boolean).forEach((e) => this.helper.deleteBuffer(e)), t.polygonBuffers && t.polygonBuffers.filter(Boolean).forEach((e) => this.helper.deleteBuffer(e));
        }
        disposeInternal() {
          this.buffers_.forEach((t) => {
            this.disposeBuffers(t);
          }), this.sourceListenKeys_ && (this.sourceListenKeys_.forEach(function(t) {
            we(t);
          }), this.sourceListenKeys_ = null), super.disposeInternal();
        }
      }
      class Nct extends Zu {
        constructor(t) {
          const e = Object.assign({}, t);
          super(e), this.styleVariables_ = t.variables || {}, this.style_ = t.style, this.hitDetectionDisabled_ = !!t.disableHitDetection;
        }
        createRenderer() {
          return new Pct(this, { style: this.style_, variables: this.styleVariables_, disableHitDetection: this.hitDetectionDisabled_ });
        }
        updateStyleVariables(t) {
          Object.assign(this.styleVariables_, t), this.changed();
        }
        setStyle(t) {
          this.style = t, this.clearRenderer(), this.changed();
        }
      }
      const JQ = (n) => {
        const t = P.inject("VMap"), e = P.unref(t).map, r = P.inject("ConfigProvide") || P.inject("$OlMapConfig");
        let a = n, o = P.shallowRef(null), s = P.shallowRef(false), l = P.shallowRef(), u = P.ref();
        P.provide("ParentTileLayer", o);
        const h = (b) => Tt(this, null, function* () {
          if (s.value = b, a.tileType) switch (a.tileType.toUpperCase()) {
            case "TDT":
              d();
              break;
            case "OSM":
              A();
              break;
            case "TDT_SATELLITE":
              d("Satellite");
              break;
            case "TDT_TERRAIN":
              d("Terrain");
              break;
            case "BAIDU":
              p();
              break;
            case "BAIDU_SATELLITE":
              p("Satellite");
              break;
            case "BAIDU_MIDNIGHT":
              p("midnight");
              break;
            case "AMAP":
              v();
              break;
            case "AMAP_SATELLITE":
              v("Satellite");
              break;
            case "GEOTIFF":
              y();
              break;
            case "CUSTOMER":
            case "XYZ":
              f();
              break;
            default:
              g();
              break;
          }
          else g();
        }), c = (b) => Tt(this, null, function* () {
          b && b.get("group") ? b.getLayers().getArray().forEach((B) => {
            e.removeLayer(B);
          }) : e.removeLayer(b), yield h();
        }), f = () => {
          o.value = Ro(a, a.source), m();
        }, g = (b = true) => {
          o.value = yct(a), b ? m() : P.unref(t).map.setLayers([o.value]);
        }, d = (b) => {
          const T = rt(rt({}, $I.tdt), r.tdt);
          let { Normal: B, Normal_Label: R, Satellite: M, Satellite_Label: L, Terrain: N, Terrain_Label: F, ak: k } = T;
          try {
            if (!k) throw new Error("ak!");
          } catch (j) {
          }
          const O = rt({}, a), Q = Qt(rt({}, a.source), { projection: "EPSG:3857" });
          if (!b || b === "Normal") {
            const j = Ro(O, Qt(rt({}, Q), { url: (B || "") + k }));
            j.set("base", true);
            const Y = Ro(O, Qt(rt({}, Q), { url: (R || "") + k }));
            Y.set("base", true), o.value = new zr({ layers: [j, Y] });
          } else if (b === "Satellite") {
            const j = Ro(O, Qt(rt({}, Q), { url: (M || "") + k }));
            j.set("base", true);
            const Y = Ro(O, Qt(rt({}, Q), { url: (L || "") + k }));
            Y.set("base", true), o.value = new zr({ layers: [j, Y] });
          } else if (b === "Terrain") {
            const j = Ro(O, Qt(rt({}, Q), { url: (N || "") + k }));
            j.set("base", true);
            const Y = Ro(O, Qt(rt({}, Q), { url: (F || "") + k }));
            Y.set("base", true), o.value = new zr({ layers: [j, Y] });
          }
          m(true);
        }, A = () => {
          const b = rt({}, a), T = Qt(rt({}, a.source), { projection: "EPSG:3857" });
          o.value = _ct(b, T), m();
        }, p = (b) => {
          const T = rt(rt({}, $I.baidu), r.baidu);
          let { Normal: B, Satellite: R, Satellite_Label: M, midnight: L, ak: N } = T;
          if (!b || b === "Normal") B && (o.value = H0(a, a.source, B), m());
          else if (b === "Satellite") {
            if (R && M) {
              const F = H0(a, a.source, R);
              F.set("base", true);
              const k = H0(a, a.source, M);
              k.set("base", true), o.value = new zr({ layers: [F, k] }), m(true);
            }
          } else if (b === "midnight" && L) {
            try {
              if (!N) throw new Error("ak!");
            } catch (F) {
            }
            o.value = H0(a, a.source, L + N), m();
          }
        }, v = (b) => {
          const T = rt(rt({}, $I.amap), r.amap);
          let { Normal: B, Satellite: R, Satellite_Label: M } = T;
          if (!b || b === "Normal") {
            const L = Qt(rt({}, a.source), { url: B, projection: "GCJ:02" });
            o.value = Ro(a, L), m();
          } else if (b === "Satellite") {
            const L = Qt(rt({}, a.source), { url: R, projection: "GCJ:02" }), N = Qt(rt({}, a.source), { url: M, projection: "GCJ:02" }), F = Ro(a, L);
            F.set("base", true);
            const k = Ro(a, N);
            k.set("base", true), o.value = new zr({ layers: [F, k] }), m(true);
          }
        }, y = () => {
          o.value = mct(a, a.source), m();
        }, m = (b) => {
          s.value ? I() : _(b);
        }, _ = (b) => {
          o.value && (o.value.set("layerTypeName", "TileLayer"), o.value.set("base", true), a.zIndex ? o.value.setZIndex(a.zIndex) : o.value.setZIndex(0), b ? (o.value.set("group", true), o.value.getLayers().getArray().forEach((R) => {
            e == null || e.addLayer(R);
          })) : e == null || e.addLayer(o.value));
        }, I = () => {
          o.value && (l.value = new Vet(Qt(rt({}, u.value), { layers: [o.value] })), l.value.setMap(P.unref(t).map));
        }, E = (b) => Tt(this, null, function* () {
          return u.value = b, Promise.resolve();
        }), x = () => {
          l.value && (P.unref(t).map.removeControl(l.value), I());
        }, w = (b) => {
          var T;
          (T = o.value) == null || T.setVisible(b);
        }, C = () => o.value, S = () => {
          var b;
          (b = o.value) != null && b.get("group") ? o.value.getLayers().getArray().forEach((R) => {
            e == null || e.removeLayer(R);
          }) : e == null || e.removeLayer(o.value), o.value = null;
        };
        return P.watchEffect(() => {
          o.value && Rs(o.value, a);
        }), { init: h, resetTile: c, setOverviewMapOptions: E, resetOverviewMap: x, setLayerVisible: w, getLayer: C, clearTile: S };
      }, Fct = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
      let Gl = (n = 21) => {
        let t = "", e = crypto.getRandomValues(new Uint8Array(n |= 0));
        for (; n--; ) t += Fct[e[n] & 63];
        return t;
      };
      const wS = P.defineComponent({ name: "OlTile", __name: "index", props: { tileType: {}, layerId: { default: `tile-layer-${Gl()}` }, source: { default: void 0 }, className: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, preload: {}, map: {}, background: {}, useInterimTilesOnError: { type: Boolean }, properties: {}, cacheSize: {} }, setup(n) {
        const t = n, { init: e, resetTile: i, getLayer: r, clearTile: a } = JQ(t);
        let o = P.ref(false);
        return P.watch(() => t.tileType, (s, l) => {
          if (s && l && s.toUpperCase() !== l.toUpperCase()) {
            const u = r();
            u && i(u);
          }
        }, { deep: true, immediate: false }), P.watch(() => t.source, (s) => {
          if (s && t.tileType) {
            const l = r();
            l && i(l);
          }
        }, { deep: true, immediate: false }), P.onMounted(() => {
          e().then(() => {
            o.value = true;
          });
        }), P.onUnmounted(() => {
          a();
        }), (s, l) => P.unref(o) ? P.renderSlot(s.$slots, "default", { key: 0 }) : P.createCommentVNode("", true);
      } }), kct = (n) => n.component(wS.name || "OlTile", wS), CS = P.defineComponent({ name: "OlImage", __name: "index", props: { source: { default: () => ({ url: "", crossOrigin: "", projection: "EPSG:4326", imageExtent: [0, 0, 180, 90] }) }, className: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, map: {}, properties: {} }, setup(n) {
        const t = n, e = P.inject("VMap"), i = P.unref(e).map;
        let r = P.shallowRef(), a = P.ref(false);
        return P.watchEffect(() => {
          Rs(r.value, t);
        }), P.onMounted(() => {
          r.value = new Act(Qt(rt({}, t), { source: void 0 })), r.value.set("layerTypeName", "ImageLayer"), P.provide("ParentTileLayer", r), i.addLayer(r.value), a.value = true;
        }), (o, s) => P.unref(a) ? P.renderSlot(o.$slots, "default", { key: 0 }) : P.createCommentVNode("", true);
      } }), Oct = (n) => n.component(CS.name || "OlImage", CS);
      class gp {
        constructor() {
          this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.featureClass = Ce, this.supportedMediaTypes = null;
        }
        getReadOptions(t, e) {
          if (e) {
            let i = e.dataProjection ? qt(e.dataProjection) : this.readProjection(t);
            e.extent && i && i.getUnits() === "tile-pixels" && (i = qt(i), i.setWorldExtent(e.extent)), e = { dataProjection: i, featureProjection: e.featureProjection };
          }
          return this.adaptOptions(e);
        }
        adaptOptions(t) {
          return Object.assign({ dataProjection: this.dataProjection, featureProjection: this.defaultFeatureProjection, featureClass: this.featureClass }, t);
        }
        getType() {
          return zt();
        }
        readFeature(t, e) {
          return zt();
        }
        readFeatures(t, e) {
          return zt();
        }
        readGeometry(t, e) {
          return zt();
        }
        readProjection(t) {
          return zt();
        }
        writeFeature(t, e) {
          return zt();
        }
        writeFeatures(t, e) {
          return zt();
        }
        writeGeometry(t, e) {
          return zt();
        }
      }
      function cn(n, t, e) {
        const i = e ? qt(e.featureProjection) : null, r = e ? qt(e.dataProjection) : null;
        let a = n;
        if (i && r && !Ao(i, r)) {
          t && (a = n.clone());
          const o = t ? i : r, s = t ? r : i;
          o.getUnits() === "tile-pixels" ? a.transform(o, s) : a.applyTransform(rf(o, s));
        }
        if (t && e && e.decimals !== void 0) {
          const o = Math.pow(10, e.decimals), s = function(l) {
            for (let u = 0, h = l.length; u < h; ++u) l[u] = Math.round(l[u] * o) / o;
            return l;
          };
          a === n && (a = n.clone()), a.applyTransform(s);
        }
        return a;
      }
      function SS(n, t) {
        const e = t ? qt(t.featureProjection) : null, i = t ? qt(t.dataProjection) : null;
        return e && i && !Ao(e, i) ? IK(n, i, e) : n;
      }
      const Qct = { Point: Ge, LineString: Be, Polygon: Dn, MultiPoint: fr, MultiLineString: ui, MultiPolygon: bi };
      function zct(n, t, e) {
        return Array.isArray(t[0]) ? (CN(n, 0, t, e) || (n = n.slice(), tw(n, 0, t, e)), n) : (Jx(n, 0, t, e) || (n = n.slice(), Tm(n, 0, t, e)), n);
      }
      function t3(n, t) {
        var a;
        const e = n.geometry;
        if (!e) return [];
        if (Array.isArray(e)) return e.map((o) => t3(Qt(rt({}, n), { geometry: o }))).flat();
        const i = e.type === "MultiPolygon" ? "Polygon" : e.type;
        if (i === "GeometryCollection" || i === "Circle") throw new Error("Unsupported geometry type: " + i);
        const r = e.layout.length;
        return cn(new Ti(i, i === "Polygon" ? zct(e.flatCoordinates, e.ends, r) : e.flatCoordinates, (a = e.ends) == null ? void 0 : a.flat(), r, n.properties || {}, n.id).enableSimplifyTransformed(), false, t);
      }
      function bS(n, t) {
        if (!n) return null;
        if (Array.isArray(n)) {
          const i = n.map((r) => bS(r, t));
          return new wn(i);
        }
        const e = Qct[n.type];
        return cn(new e(n.flatCoordinates, n.layout, n.ends), false, t);
      }
      class TS extends gp {
        constructor() {
          super();
        }
        getType() {
          return "json";
        }
        readFeature(t, e) {
          return this.readFeatureFromObject(W0(t), this.getReadOptions(t, e));
        }
        readFeatures(t, e) {
          return this.readFeaturesFromObject(W0(t), this.getReadOptions(t, e));
        }
        readFeatureFromObject(t, e) {
          return zt();
        }
        readFeaturesFromObject(t, e) {
          return zt();
        }
        readGeometry(t, e) {
          return this.readGeometryFromObject(W0(t), this.getReadOptions(t, e));
        }
        readGeometryFromObject(t, e) {
          return zt();
        }
        readProjection(t) {
          return this.readProjectionFromObject(W0(t));
        }
        readProjectionFromObject(t) {
          return zt();
        }
        writeFeature(t, e) {
          return JSON.stringify(this.writeFeatureObject(t, e));
        }
        writeFeatureObject(t, e) {
          return zt();
        }
        writeFeatures(t, e) {
          return JSON.stringify(this.writeFeaturesObject(t, e));
        }
        writeFeaturesObject(t, e) {
          return zt();
        }
        writeGeometry(t, e) {
          return JSON.stringify(this.writeGeometryObject(t, e));
        }
        writeGeometryObject(t, e) {
          return zt();
        }
      }
      function W0(n) {
        if (typeof n == "string") {
          const t = JSON.parse(n);
          return t || null;
        }
        return n !== null ? n : null;
      }
      const Gct = { Point: qct, LineString: Hct, Polygon: $ct, MultiPoint: Wct, MultiLineString: Yct, MultiPolygon: Xct }, Uct = { Point: Zct, LineString: Kct, Polygon: Jct, MultiPoint: eft, MultiLineString: tft, MultiPolygon: nft };
      class Vct extends TS {
        constructor(t) {
          t = t || {}, super(), this.geometryName_ = t.geometryName;
        }
        readFeatureFromObject(t, e, i) {
          const r = t, a = e3(r.geometry, e), o = new Ce();
          if (this.geometryName_ && o.setGeometryName(this.geometryName_), o.setGeometry(a), r.attributes) {
            o.setProperties(r.attributes, true);
            const s = r.attributes[i];
            s !== void 0 && o.setId(s);
          }
          return o;
        }
        readFeaturesFromObject(t, e) {
          if (e = e || {}, t.features) {
            const i = t, r = [], a = i.features;
            for (let o = 0, s = a.length; o < s; ++o) r.push(this.readFeatureFromObject(a[o], e, t.objectIdFieldName));
            return r;
          }
          return [this.readFeatureFromObject(t, e)];
        }
        readGeometryFromObject(t, e) {
          return e3(t, e);
        }
        readProjectionFromObject(t) {
          if (t.spatialReference && t.spatialReference.wkid !== void 0) {
            const i = t.spatialReference.wkid;
            return qt("EPSG:" + i);
          }
          return null;
        }
        writeGeometryObject(t, e) {
          return n3(t, this.adaptOptions(e));
        }
        writeFeatureObject(t, e) {
          e = this.adaptOptions(e);
          const i = {};
          if (!t.hasProperties()) return i.attributes = {}, i;
          const r = t.getProperties(), a = t.getGeometry();
          if (a) {
            i.geometry = n3(a, e);
            const o = e && (e.dataProjection || e.featureProjection);
            o && (i.geometry.spatialReference = { wkid: Number(qt(o).getCode().split(":").pop()) }), delete r[t.getGeometryName()];
          }
          return vl(r) ? i.attributes = {} : i.attributes = r, i;
        }
        writeFeaturesObject(t, e) {
          e = this.adaptOptions(e);
          const i = [];
          for (let r = 0, a = t.length; r < a; ++r) i.push(this.writeFeatureObject(t[r], e));
          return { features: i };
        }
      }
      function e3(n, t) {
        if (!n) return null;
        let e;
        if (typeof n.x == "number" && typeof n.y == "number") e = "Point";
        else if (n.points) e = "MultiPoint";
        else if (n.paths) n.paths.length === 1 ? e = "LineString" : e = "MultiLineString";
        else if (n.rings) {
          const r = n, a = rg(r), o = jct(r.rings, a);
          o.length === 1 ? (e = "Polygon", n = Object.assign({}, n, { rings: o[0] })) : (e = "MultiPolygon", n = Object.assign({}, n, { rings: o }));
        }
        const i = Gct[e];
        return cn(i(n), false, t);
      }
      function jct(n, t) {
        const e = [], i = [], r = [];
        let a, o;
        for (a = 0, o = n.length; a < o; ++a) e.length = 0, uA(e, 0, n[a], t.length), bm(e, 0, e.length, t.length) ? i.push([n[a]]) : r.push(n[a]);
        for (; r.length; ) {
          const s = r.shift();
          let l = false;
          for (a = i.length - 1; a >= 0; a--) {
            const u = i[a][0];
            if (Pr(new mo(u).getExtent(), new mo(s).getExtent())) {
              i[a].push(s), l = true;
              break;
            }
          }
          l || i.push([s.reverse()]);
        }
        return i;
      }
      function qct(n) {
        let t;
        return n.m !== void 0 && n.z !== void 0 ? t = new Ge([n.x, n.y, n.z, n.m], "XYZM") : n.z !== void 0 ? t = new Ge([n.x, n.y, n.z], "XYZ") : n.m !== void 0 ? t = new Ge([n.x, n.y, n.m], "XYM") : t = new Ge([n.x, n.y]), t;
      }
      function Hct(n) {
        const t = rg(n);
        return new Be(n.paths[0], t);
      }
      function Yct(n) {
        const t = rg(n);
        return new ui(n.paths, t);
      }
      function rg(n) {
        let t = "XY";
        return n.hasZ === true && n.hasM === true ? t = "XYZM" : n.hasZ === true ? t = "XYZ" : n.hasM === true && (t = "XYM"), t;
      }
      function Wct(n) {
        const t = rg(n);
        return new fr(n.points, t);
      }
      function Xct(n) {
        const t = rg(n);
        return new bi(n.rings, t);
      }
      function $ct(n) {
        const t = rg(n);
        return new Dn(n.rings, t);
      }
      function Zct(n, t) {
        const e = n.getCoordinates();
        let i;
        const r = n.getLayout();
        if (r === "XYZ") i = { x: e[0], y: e[1], z: e[2] };
        else if (r === "XYM") i = { x: e[0], y: e[1], m: e[2] };
        else if (r === "XYZM") i = { x: e[0], y: e[1], z: e[2], m: e[3] };
        else if (r === "XY") i = { x: e[0], y: e[1] };
        else throw new Error("Invalid geometry layout");
        return i;
      }
      function dp(n) {
        const t = n.getLayout();
        return { hasZ: t === "XYZ" || t === "XYZM", hasM: t === "XYM" || t === "XYZM" };
      }
      function Kct(n, t) {
        const e = dp(n);
        return { hasZ: e.hasZ, hasM: e.hasM, paths: [n.getCoordinates()] };
      }
      function Jct(n, t) {
        const e = dp(n);
        return { hasZ: e.hasZ, hasM: e.hasM, rings: n.getCoordinates(false) };
      }
      function tft(n, t) {
        const e = dp(n);
        return { hasZ: e.hasZ, hasM: e.hasM, paths: n.getCoordinates() };
      }
      function eft(n, t) {
        const e = dp(n);
        return { hasZ: e.hasZ, hasM: e.hasM, points: n.getCoordinates() };
      }
      function nft(n, t) {
        const e = dp(n), i = n.getCoordinates(false), r = [];
        for (let a = 0; a < i.length; a++) for (let o = i[a].length - 1; o >= 0; o--) r.push(i[a][o]);
        return { hasZ: e.hasZ, hasM: e.hasM, rings: r };
      }
      function n3(n, t) {
        const e = Uct[n.getType()];
        return e(cn(n, true, t), t);
      }
      class ag extends TS {
        constructor(t) {
          t = t || {}, super(), this.dataProjection = qt(t.dataProjection ? t.dataProjection : "EPSG:4326"), t.featureProjection && (this.defaultFeatureProjection = qt(t.featureProjection)), t.featureClass && (this.featureClass = t.featureClass), this.geometryName_ = t.geometryName, this.extractGeometryName_ = t.extractGeometryName, this.supportedMediaTypes = ["application/geo+json", "application/vnd.geo+json"];
        }
        readFeatureFromObject(t, e) {
          let i = null;
          t.type === "Feature" ? i = t : i = { type: "Feature", geometry: t, properties: null };
          const r = BS(i.geometry);
          if (this.featureClass === Ti) return t3({ geometry: r, id: i.id, properties: i.properties }, e);
          const a = new Ce();
          return this.geometryName_ ? a.setGeometryName(this.geometryName_) : this.extractGeometryName_ && i.geometry_name && a.setGeometryName(i.geometry_name), a.setGeometry(bS(r, e)), "id" in i && a.setId(i.id), i.properties && a.setProperties(i.properties, true), a;
        }
        readFeaturesFromObject(t, e) {
          const i = t;
          let r = null;
          if (i.type === "FeatureCollection") {
            const a = t;
            r = [];
            const o = a.features;
            for (let s = 0, l = o.length; s < l; ++s) {
              const u = this.readFeatureFromObject(o[s], e);
              u && r.push(u);
            }
          } else r = [this.readFeatureFromObject(t, e)];
          return r.flat();
        }
        readGeometryFromObject(t, e) {
          return ift(t, e);
        }
        readProjectionFromObject(t) {
          const e = t.crs;
          let i;
          if (e) if (e.type == "name") i = qt(e.properties.name);
          else if (e.type === "EPSG") i = qt("EPSG:" + e.properties.code);
          else throw new Error("Unknown SRS type");
          else i = this.dataProjection;
          return i;
        }
        writeFeatureObject(t, e) {
          e = this.adaptOptions(e);
          const i = { type: "Feature", geometry: null, properties: null }, r = t.getId();
          if (r !== void 0 && (i.id = r), !t.hasProperties()) return i;
          const a = t.getProperties(), o = t.getGeometry();
          return o && (i.geometry = MS(o, e), delete a[t.getGeometryName()]), vl(a) || (i.properties = a), i;
        }
        writeFeaturesObject(t, e) {
          e = this.adaptOptions(e);
          const i = [];
          for (let r = 0, a = t.length; r < a; ++r) i.push(this.writeFeatureObject(t[r], e));
          return { type: "FeatureCollection", features: i };
        }
        writeGeometryObject(t, e) {
          return MS(t, this.adaptOptions(e));
        }
      }
      function BS(n, t) {
        if (!n) return null;
        let e;
        switch (n.type) {
          case "Point": {
            e = aft(n);
            break;
          }
          case "LineString": {
            e = oft(n);
            break;
          }
          case "Polygon": {
            e = hft(n);
            break;
          }
          case "MultiPoint": {
            e = lft(n);
            break;
          }
          case "MultiLineString": {
            e = sft(n);
            break;
          }
          case "MultiPolygon": {
            e = uft(n);
            break;
          }
          case "GeometryCollection": {
            e = rft(n);
            break;
          }
          default:
            throw new Error("Unsupported GeoJSON type: " + n.type);
        }
        return e;
      }
      function ift(n, t) {
        const e = BS(n);
        return bS(e, t);
      }
      function rft(n, t) {
        return n.geometries.map(function(i) {
          return BS(i);
        });
      }
      function aft(n) {
        const t = n.coordinates;
        return { type: "Point", flatCoordinates: t, layout: qu(t.length) };
      }
      function oft(n) {
        var i;
        const t = n.coordinates, e = t.flat();
        return { type: "LineString", flatCoordinates: e, ends: [e.length], layout: qu(((i = t[0]) == null ? void 0 : i.length) || 2) };
      }
      function sft(n) {
        var a, o;
        const t = n.coordinates, e = ((o = (a = t[0]) == null ? void 0 : a[0]) == null ? void 0 : o.length) || 2, i = [], r = hA(i, 0, t, e);
        return { type: "MultiLineString", flatCoordinates: i, ends: r, layout: qu(e) };
      }
      function lft(n) {
        var e;
        const t = n.coordinates;
        return { type: "MultiPoint", flatCoordinates: t.flat(), layout: qu(((e = t[0]) == null ? void 0 : e.length) || 2) };
      }
      function uft(n) {
        var a, o;
        const t = n.coordinates, e = [], i = ((o = (a = t[0]) == null ? void 0 : a[0]) == null ? void 0 : o[0].length) || 2, r = vN(e, 0, t, i);
        return { type: "MultiPolygon", flatCoordinates: e, ends: r, layout: qu(i) };
      }
      function hft(n) {
        var a, o;
        const t = n.coordinates, e = [], i = (o = (a = t[0]) == null ? void 0 : a[0]) == null ? void 0 : o.length, r = hA(e, 0, t, i);
        return { type: "Polygon", flatCoordinates: e, ends: r, layout: qu(i) };
      }
      function MS(n, t) {
        n = cn(n, true, t);
        const e = n.getType();
        let i;
        switch (e) {
          case "Point": {
            i = pft(n);
            break;
          }
          case "LineString": {
            i = fft(n);
            break;
          }
          case "Polygon": {
            i = vft(n, t);
            break;
          }
          case "MultiPoint": {
            i = dft(n);
            break;
          }
          case "MultiLineString": {
            i = gft(n);
            break;
          }
          case "MultiPolygon": {
            i = Aft(n, t);
            break;
          }
          case "GeometryCollection": {
            i = cft(n, t);
            break;
          }
          case "Circle": {
            i = { type: "GeometryCollection", geometries: [] };
            break;
          }
          default:
            throw new Error("Unsupported geometry type: " + e);
        }
        return i;
      }
      function cft(n, t) {
        return t = Object.assign({}, t), delete t.featureProjection, { type: "GeometryCollection", geometries: n.getGeometriesArray().map(function(i) {
          return MS(i, t);
        }) };
      }
      function fft(n, t) {
        return { type: "LineString", coordinates: n.getCoordinates() };
      }
      function gft(n, t) {
        return { type: "MultiLineString", coordinates: n.getCoordinates() };
      }
      function dft(n, t) {
        return { type: "MultiPoint", coordinates: n.getCoordinates() };
      }
      function Aft(n, t) {
        let e;
        return t && (e = t.rightHanded), { type: "MultiPolygon", coordinates: n.getCoordinates(e) };
      }
      function pft(n, t) {
        return { type: "Point", coordinates: n.getCoordinates() };
      }
      function vft(n, t) {
        let e;
        return t && (e = t.rightHanded), { type: "Polygon", coordinates: n.getCoordinates(e) };
      }
      const sh = "http://www.w3.org/2001/XMLSchema-instance";
      function ee(n, t) {
        return og().createElementNS(n, t);
      }
      function Hi(n, t) {
        return i3(n, t, []).join("");
      }
      function i3(n, t, e) {
        if (n.nodeType == Node.CDATA_SECTION_NODE || n.nodeType == Node.TEXT_NODE) e.push(n.nodeValue);
        else {
          let i;
          for (i = n.firstChild; i; i = i.nextSibling) i3(i, t, e);
        }
        return e;
      }
      function la(n) {
        return "documentElement" in n;
      }
      function yft(n, t, e) {
        return n.getAttributeNS(t, e) || "";
      }
      function ua(n) {
        return new DOMParser().parseFromString(n, "application/xml");
      }
      function X0(n, t) {
        return function(e, i) {
          const r = n.call(t != null ? t : this, e, i);
          if (r !== void 0) {
            const a = i[i.length - 1];
            Le(a, r);
          }
        };
      }
      function Lt(n, t) {
        return function(e, i) {
          const r = n.call(t != null ? t : this, e, i);
          r !== void 0 && i[i.length - 1].push(r);
        };
      }
      function Vt(n, t) {
        return function(e, i) {
          const r = n.call(t != null ? t : this, e, i);
          r !== void 0 && (i[i.length - 1] = r);
        };
      }
      function Ve(n, t, e) {
        return function(i, r) {
          const a = n.call(this, i, r);
          if (a !== void 0) {
            const o = r[r.length - 1], s = i.localName;
            let l;
            s in o ? l = o[s] : (l = [], o[s] = l), l.push(a);
          }
        };
      }
      function z(n, t, e) {
        return function(i, r) {
          const a = n.call(this, i, r);
          if (a !== void 0) {
            const o = r[r.length - 1], s = t !== void 0 ? t : i.localName;
            o[s] = a;
          }
        };
      }
      function U(n, t) {
        return function(e, i, r) {
          n.call(t != null ? t : this, e, i, r), r[r.length - 1].node.appendChild(e);
        };
      }
      function r3(n, t) {
        let e, i;
        return function(r, a, o) {
          if (e === void 0) {
            e = {};
            const s = {};
            s[r.localName] = n, e[r.namespaceURI] = s, i = _n(r.localName);
          }
          a3(e, i, a, o);
        };
      }
      function _n(n, t) {
        return function(e, i, r) {
          const o = i[i.length - 1].node;
          let s = n;
          s === void 0 && (s = r);
          const l = t !== void 0 ? t : o.namespaceURI;
          return ee(l, s);
        };
      }
      const hi = _n();
      function vr(n, t) {
        const e = t.length, i = new Array(e);
        for (let r = 0; r < e; ++r) i[r] = n[t[r]];
        return i;
      }
      function tt(n, t, e) {
        e = e !== void 0 ? e : {};
        let i, r;
        for (i = 0, r = n.length; i < r; ++i) e[n[i]] = t;
        return e;
      }
      function yr(n, t, e, i) {
        let r;
        for (r = t.firstElementChild; r; r = r.nextElementSibling) {
          const a = n[r.namespaceURI];
          if (a !== void 0) {
            const o = a[r.localName];
            o !== void 0 && o.call(i, r, e);
          }
        }
      }
      function at(n, t, e, i, r) {
        return i.push(n), yr(t, e, i, r), i.pop();
      }
      function a3(n, t, e, i, r, a) {
        const o = (r !== void 0 ? r : e).length;
        let s, l;
        for (let u = 0; u < o; ++u) s = e[u], s !== void 0 && (l = t.call(a, s, i, r !== void 0 ? r[u] : void 0), l !== void 0 && n[l.namespaceURI][l.localName].call(a, l, s, i));
      }
      function Zt(n, t, e, i, r, a, o) {
        return r.push(n), a3(t, e, i, r, a, o), r.pop();
      }
      let DS;
      function mft() {
        return DS === void 0 && typeof XMLSerializer != "undefined" && (DS = new XMLSerializer()), DS;
      }
      let RS;
      function og() {
        return RS === void 0 && typeof document != "undefined" && (RS = document.implementation.createDocument("", "", null)), RS;
      }
      class Ap extends gp {
        constructor() {
          super(), this.xmlSerializer_ = mft();
        }
        getType() {
          return "xml";
        }
        readFeature(t, e) {
          if (!t) return null;
          if (typeof t == "string") {
            const i = ua(t);
            return this.readFeatureFromDocument(i, e);
          }
          return la(t) ? this.readFeatureFromDocument(t, e) : this.readFeatureFromNode(t, e);
        }
        readFeatureFromDocument(t, e) {
          const i = this.readFeaturesFromDocument(t, e);
          return i.length > 0 ? i[0] : null;
        }
        readFeatureFromNode(t, e) {
          return null;
        }
        readFeatures(t, e) {
          if (!t) return [];
          if (typeof t == "string") {
            const i = ua(t);
            return this.readFeaturesFromDocument(i, e);
          }
          return la(t) ? this.readFeaturesFromDocument(t, e) : this.readFeaturesFromNode(t, e);
        }
        readFeaturesFromDocument(t, e) {
          const i = [];
          for (let r = t.firstChild; r; r = r.nextSibling) r.nodeType == Node.ELEMENT_NODE && Le(i, this.readFeaturesFromNode(r, e));
          return i;
        }
        readFeaturesFromNode(t, e) {
          return zt();
        }
        readGeometry(t, e) {
          if (!t) return null;
          if (typeof t == "string") {
            const i = ua(t);
            return this.readGeometryFromDocument(i, e);
          }
          return la(t) ? this.readGeometryFromDocument(t, e) : this.readGeometryFromNode(t, e);
        }
        readGeometryFromDocument(t, e) {
          return null;
        }
        readGeometryFromNode(t, e) {
          return null;
        }
        readProjection(t) {
          if (!t) return null;
          if (typeof t == "string") {
            const e = ua(t);
            return this.readProjectionFromDocument(e);
          }
          return la(t) ? this.readProjectionFromDocument(t) : this.readProjectionFromNode(t);
        }
        readProjectionFromDocument(t) {
          return this.dataProjection;
        }
        readProjectionFromNode(t) {
          return this.dataProjection;
        }
        writeFeature(t, e) {
          const i = this.writeFeatureNode(t, e);
          return this.xmlSerializer_.serializeToString(i);
        }
        writeFeatureNode(t, e) {
          return null;
        }
        writeFeatures(t, e) {
          const i = this.writeFeaturesNode(t, e);
          return this.xmlSerializer_.serializeToString(i);
        }
        writeFeaturesNode(t, e) {
          return null;
        }
        writeGeometry(t, e) {
          const i = this.writeGeometryNode(t, e);
          return this.xmlSerializer_.serializeToString(i);
        }
        writeGeometryNode(t, e) {
          return null;
        }
      }
      const Ls = "http://www.opengis.net/gml", _ft = /^\s*$/;
      class Pt extends Ap {
        constructor(t) {
          super(), t = t || {}, this.featureType = t.featureType, this.featureNS = t.featureNS, this.srsName = t.srsName, this.schemaLocation = "", this.FEATURE_COLLECTION_PARSERS = {}, this.FEATURE_COLLECTION_PARSERS[this.namespace] = { featureMember: Lt(this.readFeaturesInternal), featureMembers: Vt(this.readFeaturesInternal) }, this.supportedMediaTypes = ["application/gml+xml"];
        }
        readFeaturesInternal(t, e) {
          const i = t.localName;
          let r = null;
          if (i == "FeatureCollection") r = at([], this.FEATURE_COLLECTION_PARSERS, t, e, this);
          else if (i == "featureMembers" || i == "featureMember" || i == "member") {
            const a = e[0];
            let o = a.featureType, s = a.featureNS;
            const l = "p", u = "p0";
            if (!o && t.childNodes) {
              o = [], s = {};
              for (let f = 0, g = t.childNodes.length; f < g; ++f) {
                const d = t.childNodes[f];
                if (d.nodeType === 1) {
                  const A = d.nodeName.split(":").pop();
                  if (!o.includes(A)) {
                    let p = "", v = 0;
                    const y = d.namespaceURI;
                    for (const m in s) {
                      if (s[m] === y) {
                        p = m;
                        break;
                      }
                      ++v;
                    }
                    p || (p = l + v, s[p] = y), o.push(p + ":" + A);
                  }
                }
              }
              i != "featureMember" && (a.featureType = o, a.featureNS = s);
            }
            if (typeof s == "string") {
              const f = s;
              s = {}, s[u] = f;
            }
            const h = {}, c = Array.isArray(o) ? o : [o];
            for (const f in s) {
              const g = {};
              for (let d = 0, A = c.length; d < A; ++d) (c[d].includes(":") ? c[d].split(":")[0] : u) === f && (g[c[d].split(":").pop()] = i == "featureMembers" ? Lt(this.readFeatureElement, this) : Vt(this.readFeatureElement, this));
              h[s[f]] = g;
            }
            i == "featureMember" || i == "member" ? r = at(void 0, h, t, e) : r = at([], h, t, e);
          }
          return r === null && (r = []), r;
        }
        readGeometryOrExtent(t, e) {
          const i = e[0];
          return i.srsName = t.firstElementChild.getAttribute("srsName"), i.srsDimension = t.firstElementChild.getAttribute("srsDimension"), at(null, this.GEOMETRY_PARSERS, t, e, this);
        }
        readExtentElement(t, e) {
          const i = e[0], r = this.readGeometryOrExtent(t, e);
          return r ? SS(r, i) : void 0;
        }
        readGeometryElement(t, e) {
          const i = e[0], r = this.readGeometryOrExtent(t, e);
          return r ? cn(r, false, i) : void 0;
        }
        readFeatureElementInternal(t, e, i) {
          let r;
          const a = {};
          for (let l = t.firstElementChild; l; l = l.nextElementSibling) {
            let u;
            const h = l.localName;
            l.childNodes.length === 0 || l.childNodes.length === 1 && (l.firstChild.nodeType === 3 || l.firstChild.nodeType === 4) ? (u = Hi(l, false), _ft.test(u) && (u = void 0)) : (i && (u = h === "boundedBy" ? this.readExtentElement(l, e) : this.readGeometryElement(l, e)), u ? h !== "boundedBy" && (r = h) : u = this.readFeatureElementInternal(l, e, false));
            const c = l.attributes.length;
            if (c > 0 && !(u instanceof wm)) {
              u = { _content_: u };
              for (let f = 0; f < c; f++) {
                const g = l.attributes[f].name;
                u[g] = l.attributes[f].value;
              }
            }
            a[h] ? (a[h] instanceof Array || (a[h] = [a[h]]), a[h].push(u)) : a[h] = u;
          }
          if (!i) return a;
          const o = new Ce(a);
          r && o.setGeometryName(r);
          const s = t.getAttribute("fid") || yft(t, this.namespace, "id");
          return s && o.setId(s), o;
        }
        readFeatureElement(t, e) {
          return this.readFeatureElementInternal(t, e, true);
        }
        readPoint(t, e) {
          const i = this.readFlatCoordinatesFromNode(t, e);
          if (i) return new Ge(i, "XYZ");
        }
        readMultiPoint(t, e) {
          const i = at([], this.MULTIPOINT_PARSERS, t, e, this);
          if (i) return new fr(i);
        }
        readMultiLineString(t, e) {
          const i = at([], this.MULTILINESTRING_PARSERS, t, e, this);
          if (i) return new ui(i);
        }
        readMultiPolygon(t, e) {
          const i = at([], this.MULTIPOLYGON_PARSERS, t, e, this);
          if (i) return new bi(i);
        }
        pointMemberParser(t, e) {
          yr(this.POINTMEMBER_PARSERS, t, e, this);
        }
        lineStringMemberParser(t, e) {
          yr(this.LINESTRINGMEMBER_PARSERS, t, e, this);
        }
        polygonMemberParser(t, e) {
          yr(this.POLYGONMEMBER_PARSERS, t, e, this);
        }
        readLineString(t, e) {
          const i = this.readFlatCoordinatesFromNode(t, e);
          if (i) return new Be(i, "XYZ");
        }
        readFlatLinearRing(t, e) {
          const i = at(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, t, e, this);
          if (i) return i;
        }
        readLinearRing(t, e) {
          const i = this.readFlatCoordinatesFromNode(t, e);
          if (i) return new mo(i, "XYZ");
        }
        readPolygon(t, e) {
          const i = at([null], this.FLAT_LINEAR_RINGS_PARSERS, t, e, this);
          if (i && i[0]) {
            const r = i[0], a = [r.length];
            let o, s;
            for (o = 1, s = i.length; o < s; ++o) Le(r, i[o]), a.push(r.length);
            return new Dn(r, "XYZ", a);
          }
        }
        readFlatCoordinatesFromNode(t, e) {
          return at(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, t, e, this);
        }
        readGeometryFromNode(t, e) {
          const i = this.readGeometryElement(t, [this.getReadOptions(t, e || {})]);
          return i || null;
        }
        readFeaturesFromNode(t, e) {
          const i = { featureType: this.featureType, featureNS: this.featureNS };
          return i && Object.assign(i, this.getReadOptions(t, e)), this.readFeaturesInternal(t, [i]) || [];
        }
        readProjectionFromNode(t) {
          return qt(this.srsName ? this.srsName : t.firstElementChild.getAttribute("srsName"));
        }
      }
      Pt.prototype.namespace = Ls, Pt.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml": {} }, Pt.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml": {} }, Pt.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml": {} }, Pt.prototype.MULTIPOINT_PARSERS = { "http://www.opengis.net/gml": { pointMember: Lt(Pt.prototype.pointMemberParser), pointMembers: Lt(Pt.prototype.pointMemberParser) } }, Pt.prototype.MULTILINESTRING_PARSERS = { "http://www.opengis.net/gml": { lineStringMember: Lt(Pt.prototype.lineStringMemberParser), lineStringMembers: Lt(Pt.prototype.lineStringMemberParser) } }, Pt.prototype.MULTIPOLYGON_PARSERS = { "http://www.opengis.net/gml": { polygonMember: Lt(Pt.prototype.polygonMemberParser), polygonMembers: Lt(Pt.prototype.polygonMemberParser) } }, Pt.prototype.POINTMEMBER_PARSERS = { "http://www.opengis.net/gml": { Point: Lt(Pt.prototype.readFlatCoordinatesFromNode) } }, Pt.prototype.LINESTRINGMEMBER_PARSERS = { "http://www.opengis.net/gml": { LineString: Lt(Pt.prototype.readLineString) } }, Pt.prototype.POLYGONMEMBER_PARSERS = { "http://www.opengis.net/gml": { Polygon: Lt(Pt.prototype.readPolygon) } }, Pt.prototype.RING_PARSERS = { "http://www.opengis.net/gml": { LinearRing: Vt(Pt.prototype.readFlatLinearRing) } };
      function Ul(n) {
        const t = Hi(n, false);
        return ha(t);
      }
      function ha(n) {
        const t = /^\s*(true|1)|(false|0)\s*$/.exec(n);
        if (t) return t[1] !== void 0 || false;
      }
      function $0(n) {
        const t = Hi(n, false), e = Date.parse(t);
        return isNaN(e) ? void 0 : e / 1e3;
      }
      function _e(n) {
        const t = Hi(n, false);
        return qa(t);
      }
      function qa(n) {
        const t = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(n);
        if (t) return parseFloat(t[1]);
      }
      function Cn(n) {
        const t = Hi(n, false);
        return Ps(t);
      }
      function Ps(n) {
        const t = /^\s*(\d+)\s*$/.exec(n);
        if (t) return parseInt(t[1], 10);
      }
      function ot(n) {
        return Hi(n, false).trim();
      }
      function sg(n, t) {
        Xt(n, t ? "1" : "0");
      }
      function Eft(n, t) {
        n.appendChild(og().createCDATASection(t));
      }
      function Ift(n, t) {
        const e = new Date(t * 1e3), i = e.getUTCFullYear() + "-" + aA(e.getUTCMonth() + 1, 2) + "-" + aA(e.getUTCDate(), 2) + "T" + aA(e.getUTCHours(), 2) + ":" + aA(e.getUTCMinutes(), 2) + ":" + aA(e.getUTCSeconds(), 2) + "Z";
        n.appendChild(og().createTextNode(i));
      }
      function mr(n, t) {
        const e = t.toPrecision();
        n.appendChild(og().createTextNode(e));
      }
      function Z0(n, t) {
        const e = t.toString();
        n.appendChild(og().createTextNode(e));
      }
      function Xt(n, t) {
        n.appendChild(og().createTextNode(t));
      }
      const xft = Ls + " http://schemas.opengis.net/gml/2.1.2/feature.xsd", wft = { MultiLineString: "lineStringMember", MultiCurve: "curveMember", MultiPolygon: "polygonMember", MultiSurface: "surfaceMember" };
      class ve extends Pt {
        constructor(t) {
          t = t || {}, super(t), this.FEATURE_COLLECTION_PARSERS[Ls].featureMember = Lt(this.readFeaturesInternal), this.schemaLocation = t.schemaLocation ? t.schemaLocation : xft;
        }
        readFlatCoordinates(t, e) {
          const i = Hi(t, false).replace(/^\s*|\s*$/g, ""), a = e[0].srsName;
          let o = "enu";
          if (a) {
            const u = qt(a);
            u && (o = u.getAxisOrientation());
          }
          const s = i.trim().split(/\s+/), l = [];
          for (let u = 0, h = s.length; u < h; u++) {
            const c = s[u].split(/,+/), f = parseFloat(c[0]), g = parseFloat(c[1]), d = c.length === 3 ? parseFloat(c[2]) : 0;
            o.startsWith("en") ? l.push(f, g, d) : l.push(g, f, d);
          }
          return l;
        }
        readBox(t, e) {
          const i = at([null], this.BOX_PARSERS_, t, e, this);
          return ta(i[1][0], i[1][1], i[1][3], i[1][4]);
        }
        innerBoundaryIsParser(t, e) {
          const i = at(void 0, this.RING_PARSERS, t, e, this);
          i && e[e.length - 1].push(i);
        }
        outerBoundaryIsParser(t, e) {
          const i = at(void 0, this.RING_PARSERS, t, e, this);
          if (i) {
            const r = e[e.length - 1];
            r[0] = i;
          }
        }
        GEOMETRY_NODE_FACTORY_(t, e, i) {
          const r = e[e.length - 1], a = r.multiSurface, o = r.surface, s = r.multiCurve;
          return Array.isArray(t) ? i = "Envelope" : (i = t.getType(), i === "MultiPolygon" && a === true ? i = "MultiSurface" : i === "Polygon" && o === true ? i = "Surface" : i === "MultiLineString" && s === true && (i = "MultiCurve")), ee("http://www.opengis.net/gml", i);
        }
        writeFeatureElement(t, e, i) {
          const r = e.getId();
          r && t.setAttribute("fid", r);
          const a = i[i.length - 1], o = a.featureNS, s = e.getGeometryName();
          a.serializers || (a.serializers = {}, a.serializers[o] = {});
          const l = [], u = [];
          if (e.hasProperties()) {
            const c = e.getProperties();
            for (const f in c) {
              const g = c[f];
              g != null && (l.push(f), u.push(g), f == s || typeof g.getSimplifiedGeometry == "function" ? f in a.serializers[o] || (a.serializers[o][f] = U(this.writeGeometryElement, this)) : f in a.serializers[o] || (a.serializers[o][f] = U(Xt)));
            }
          }
          const h = Object.assign({}, a);
          h.node = t, Zt(h, a.serializers, _n(void 0, o), u, i, l);
        }
        writeCurveOrLineString(t, e, i) {
          const a = i[i.length - 1].srsName;
          if (t.nodeName !== "LineStringSegment" && a && t.setAttribute("srsName", a), t.nodeName === "LineString" || t.nodeName === "LineStringSegment") {
            const o = this.createCoordinatesNode_(t.namespaceURI);
            t.appendChild(o), this.writeCoordinates_(o, e, i);
          } else if (t.nodeName === "Curve") {
            const o = ee(t.namespaceURI, "segments");
            t.appendChild(o), this.writeCurveSegments_(o, e, i);
          }
        }
        writeLineStringOrCurveMember(t, e, i) {
          const r = this.GEOMETRY_NODE_FACTORY_(e, i);
          r && (t.appendChild(r), this.writeCurveOrLineString(r, e, i));
        }
        writeMultiCurveOrLineString(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName, s = r.curve;
          o && t.setAttribute("srsName", o);
          const l = e.getLineStrings();
          Zt({ node: t, hasZ: a, srsName: o, curve: s }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, l, i, void 0, this);
        }
        writeGeometryElement(t, e, i) {
          const r = i[i.length - 1], a = Object.assign({}, r);
          a.node = t;
          let o;
          Array.isArray(e) ? o = SS(e, r) : o = cn(e, true, r), Zt(a, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [o], i, void 0, this);
        }
        createCoordinatesNode_(t) {
          const e = ee(t, "coordinates");
          return e.setAttribute("decimal", "."), e.setAttribute("cs", ","), e.setAttribute("ts", " "), e;
        }
        writeCoordinates_(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName, s = e.getCoordinates(), l = s.length, u = new Array(l);
          for (let h = 0; h < l; ++h) {
            const c = s[h];
            u[h] = this.getCoords_(c, o, a);
          }
          Xt(t, u.join(" "));
        }
        writeCurveSegments_(t, e, i) {
          const r = ee(t.namespaceURI, "LineStringSegment");
          t.appendChild(r), this.writeCurveOrLineString(r, e, i);
        }
        writeSurfaceOrPolygon(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName;
          if (t.nodeName !== "PolygonPatch" && o && t.setAttribute("srsName", o), t.nodeName === "Polygon" || t.nodeName === "PolygonPatch") {
            const s = e.getLinearRings();
            Zt({ node: t, hasZ: a, srsName: o }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, s, i, void 0, this);
          } else if (t.nodeName === "Surface") {
            const s = ee(t.namespaceURI, "patches");
            t.appendChild(s), this.writeSurfacePatches_(s, e, i);
          }
        }
        RING_NODE_FACTORY_(t, e, i) {
          const r = e[e.length - 1], a = r.node, o = r.exteriorWritten;
          return o === void 0 && (r.exteriorWritten = true), ee(a.namespaceURI, o !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs");
        }
        writeSurfacePatches_(t, e, i) {
          const r = ee(t.namespaceURI, "PolygonPatch");
          t.appendChild(r), this.writeSurfaceOrPolygon(r, e, i);
        }
        writeRing(t, e, i) {
          const r = ee(t.namespaceURI, "LinearRing");
          t.appendChild(r), this.writeLinearRing(r, e, i);
        }
        getCoords_(t, e, i) {
          let a = (e ? qt(e).getAxisOrientation() : "enu").startsWith("en") ? t[0] + "," + t[1] : t[1] + "," + t[0];
          if (i) {
            const o = t[2] || 0;
            a += "," + o;
          }
          return a;
        }
        writePoint(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName;
          o && t.setAttribute("srsName", o);
          const s = this.createCoordinatesNode_(t.namespaceURI);
          t.appendChild(s);
          const l = e.getCoordinates(), u = this.getCoords_(l, o, a);
          Xt(s, u);
        }
        writeMultiPoint(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName;
          o && t.setAttribute("srsName", o);
          const s = e.getPoints();
          Zt({ node: t, hasZ: a, srsName: o }, this.POINTMEMBER_SERIALIZERS, _n("pointMember"), s, i, void 0, this);
        }
        writePointMember(t, e, i) {
          const r = ee(t.namespaceURI, "Point");
          t.appendChild(r), this.writePoint(r, e, i);
        }
        writeLinearRing(t, e, i) {
          const a = i[i.length - 1].srsName;
          a && t.setAttribute("srsName", a);
          const o = this.createCoordinatesNode_(t.namespaceURI);
          t.appendChild(o), this.writeCoordinates_(o, e, i);
        }
        writeMultiSurfaceOrPolygon(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName, s = r.surface;
          o && t.setAttribute("srsName", o);
          const l = e.getPolygons();
          Zt({ node: t, hasZ: a, srsName: o, surface: s }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, l, i, void 0, this);
        }
        writeSurfaceOrPolygonMember(t, e, i) {
          const r = this.GEOMETRY_NODE_FACTORY_(e, i);
          r && (t.appendChild(r), this.writeSurfaceOrPolygon(r, e, i));
        }
        writeEnvelope(t, e, i) {
          const a = i[i.length - 1].srsName;
          a && t.setAttribute("srsName", a);
          const o = ["lowerCorner", "upperCorner"], s = [e[0] + " " + e[1], e[2] + " " + e[3]];
          Zt({ node: t }, this.ENVELOPE_SERIALIZERS, hi, s, i, o, this);
        }
        MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, e, i) {
          const r = e[e.length - 1].node;
          return ee("http://www.opengis.net/gml", wft[r.nodeName]);
        }
      }
      ve.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml": { coordinates: Vt(ve.prototype.readFlatCoordinates) } }, ve.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml": { innerBoundaryIs: ve.prototype.innerBoundaryIsParser, outerBoundaryIs: ve.prototype.outerBoundaryIsParser } }, ve.prototype.BOX_PARSERS_ = { "http://www.opengis.net/gml": { coordinates: Lt(ve.prototype.readFlatCoordinates) } }, ve.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml": { Point: Vt(Pt.prototype.readPoint), MultiPoint: Vt(Pt.prototype.readMultiPoint), LineString: Vt(Pt.prototype.readLineString), MultiLineString: Vt(Pt.prototype.readMultiLineString), LinearRing: Vt(Pt.prototype.readLinearRing), Polygon: Vt(Pt.prototype.readPolygon), MultiPolygon: Vt(Pt.prototype.readMultiPolygon), Box: Vt(ve.prototype.readBox) } }, ve.prototype.GEOMETRY_SERIALIZERS = { "http://www.opengis.net/gml": { Curve: U(ve.prototype.writeCurveOrLineString), MultiCurve: U(ve.prototype.writeMultiCurveOrLineString), Point: U(ve.prototype.writePoint), MultiPoint: U(ve.prototype.writeMultiPoint), LineString: U(ve.prototype.writeCurveOrLineString), MultiLineString: U(ve.prototype.writeMultiCurveOrLineString), LinearRing: U(ve.prototype.writeLinearRing), Polygon: U(ve.prototype.writeSurfaceOrPolygon), MultiPolygon: U(ve.prototype.writeMultiSurfaceOrPolygon), Surface: U(ve.prototype.writeSurfaceOrPolygon), MultiSurface: U(ve.prototype.writeMultiSurfaceOrPolygon), Envelope: U(ve.prototype.writeEnvelope) } }, ve.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { lineStringMember: U(ve.prototype.writeLineStringOrCurveMember), curveMember: U(ve.prototype.writeLineStringOrCurveMember) } }, ve.prototype.RING_SERIALIZERS = { "http://www.opengis.net/gml": { outerBoundaryIs: U(ve.prototype.writeRing), innerBoundaryIs: U(ve.prototype.writeRing) } }, ve.prototype.POINTMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { pointMember: U(ve.prototype.writePointMember) } }, ve.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { surfaceMember: U(ve.prototype.writeSurfaceOrPolygonMember), polygonMember: U(ve.prototype.writeSurfaceOrPolygonMember) } }, ve.prototype.ENVELOPE_SERIALIZERS = { "http://www.opengis.net/gml": { lowerCorner: U(Xt), upperCorner: U(Xt) } };
      const Cft = Ls + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd", Sft = { MultiLineString: "lineStringMember", MultiCurve: "curveMember", MultiPolygon: "polygonMember", MultiSurface: "surfaceMember" };
      class lt extends Pt {
        constructor(t) {
          t = t || {}, super(t), this.surface_ = t.surface !== void 0 ? t.surface : false, this.curve_ = t.curve !== void 0 ? t.curve : false, this.multiCurve_ = t.multiCurve !== void 0 ? t.multiCurve : true, this.multiSurface_ = t.multiSurface !== void 0 ? t.multiSurface : true, this.schemaLocation = t.schemaLocation ? t.schemaLocation : Cft, this.hasZ = t.hasZ !== void 0 ? t.hasZ : false;
        }
        readMultiCurve(t, e) {
          const i = at([], this.MULTICURVE_PARSERS, t, e, this);
          if (i) return new ui(i);
        }
        readFlatCurveRing(t, e) {
          const i = at([], this.MULTICURVE_PARSERS, t, e, this), r = [];
          for (let a = 0, o = i.length; a < o; ++a) Le(r, i[a].getFlatCoordinates());
          return r;
        }
        readMultiSurface(t, e) {
          const i = at([], this.MULTISURFACE_PARSERS, t, e, this);
          if (i) return new bi(i);
        }
        curveMemberParser(t, e) {
          yr(this.CURVEMEMBER_PARSERS, t, e, this);
        }
        surfaceMemberParser(t, e) {
          yr(this.SURFACEMEMBER_PARSERS, t, e, this);
        }
        readPatch(t, e) {
          return at([null], this.PATCHES_PARSERS, t, e, this);
        }
        readSegment(t, e) {
          return at([], this.SEGMENTS_PARSERS, t, e, this);
        }
        readPolygonPatch(t, e) {
          return at([null], this.FLAT_LINEAR_RINGS_PARSERS, t, e, this);
        }
        readLineStringSegment(t, e) {
          return at([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS, t, e, this);
        }
        interiorParser(t, e) {
          const i = at(void 0, this.RING_PARSERS, t, e, this);
          i && e[e.length - 1].push(i);
        }
        exteriorParser(t, e) {
          const i = at(void 0, this.RING_PARSERS, t, e, this);
          if (i) {
            const r = e[e.length - 1];
            r[0] = i;
          }
        }
        readSurface(t, e) {
          const i = at([null], this.SURFACE_PARSERS, t, e, this);
          if (i && i[0]) {
            const r = i[0], a = [r.length];
            let o, s;
            for (o = 1, s = i.length; o < s; ++o) Le(r, i[o]), a.push(r.length);
            return new Dn(r, "XYZ", a);
          }
        }
        readCurve(t, e) {
          const i = at([null], this.CURVE_PARSERS, t, e, this);
          if (i) return new Be(i, "XYZ");
        }
        readEnvelope(t, e) {
          const i = at([null], this.ENVELOPE_PARSERS, t, e, this);
          return ta(i[1][0], i[1][1], i[2][0], i[2][1]);
        }
        readFlatPos(t, e) {
          let i = Hi(t, false);
          const r = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/, a = [];
          let o;
          for (; o = r.exec(i); ) a.push(parseFloat(o[1])), i = i.substr(o[0].length);
          if (i !== "") return;
          const l = e[0].srsName;
          if ((l ? qt(l).getAxisOrientation() : "enu") === "neu") for (let c = 0, f = a.length; c < f; c += 3) {
            const g = a[c], d = a[c + 1];
            a[c] = d, a[c + 1] = g;
          }
          const h = a.length;
          if (h == 2 && a.push(0), h !== 0) return a;
        }
        readFlatPosList(t, e) {
          const i = Hi(t, false).replace(/^\s*|\s*$/g, ""), r = e[0], a = r.srsName, o = r.srsDimension, s = a ? qt(a).getAxisOrientation() : "enu", l = i.split(/\s+/);
          let u = 2;
          t.getAttribute("srsDimension") ? u = Ps(t.getAttribute("srsDimension")) : t.getAttribute("dimension") ? u = Ps(t.getAttribute("dimension")) : t.parentNode.getAttribute("srsDimension") ? u = Ps(t.parentNode.getAttribute("srsDimension")) : o && (u = Ps(o));
          const h = s.startsWith("en");
          let c, f, g;
          const d = [];
          for (let A = 0, p = l.length; A < p; A += u) c = parseFloat(l[A]), f = parseFloat(l[A + 1]), g = u === 3 ? parseFloat(l[A + 2]) : 0, h ? d.push(c, f, g) : d.push(f, c, g);
          return d;
        }
        writePos_(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = a ? "3" : "2";
          t.setAttribute("srsDimension", o);
          const s = r.srsName, l = s ? qt(s).getAxisOrientation() : "enu", u = e.getCoordinates();
          let h = l.startsWith("en") ? u[0] + " " + u[1] : u[1] + " " + u[0];
          if (a) {
            const c = u[2] || 0;
            h += " " + c;
          }
          Xt(t, h);
        }
        getCoords_(t, e, i) {
          let a = (e ? qt(e).getAxisOrientation() : "enu").startsWith("en") ? t[0] + " " + t[1] : t[1] + " " + t[0];
          if (i) {
            const o = t[2] || 0;
            a += " " + o;
          }
          return a;
        }
        writePosList_(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = a ? "3" : "2";
          t.setAttribute("srsDimension", o);
          const s = r.srsName, l = e.getCoordinates(), u = l.length, h = new Array(u);
          let c;
          for (let f = 0; f < u; ++f) c = l[f], h[f] = this.getCoords_(c, s, a);
          Xt(t, h.join(" "));
        }
        writePoint(t, e, i) {
          const a = i[i.length - 1].srsName;
          a && t.setAttribute("srsName", a);
          const o = ee(t.namespaceURI, "pos");
          t.appendChild(o), this.writePos_(o, e, i);
        }
        writeEnvelope(t, e, i) {
          const a = i[i.length - 1].srsName;
          a && t.setAttribute("srsName", a);
          const o = ["lowerCorner", "upperCorner"], s = [e[0] + " " + e[1], e[2] + " " + e[3]];
          Zt({ node: t }, this.ENVELOPE_SERIALIZERS, hi, s, i, o, this);
        }
        writeLinearRing(t, e, i) {
          const a = i[i.length - 1].srsName;
          a && t.setAttribute("srsName", a);
          const o = ee(t.namespaceURI, "posList");
          t.appendChild(o), this.writePosList_(o, e, i);
        }
        RING_NODE_FACTORY_(t, e, i) {
          const r = e[e.length - 1], a = r.node, o = r.exteriorWritten;
          return o === void 0 && (r.exteriorWritten = true), ee(a.namespaceURI, o !== void 0 ? "interior" : "exterior");
        }
        writeSurfaceOrPolygon(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName;
          if (t.nodeName !== "PolygonPatch" && o && t.setAttribute("srsName", o), t.nodeName === "Polygon" || t.nodeName === "PolygonPatch") {
            const s = e.getLinearRings();
            Zt({ node: t, hasZ: a, srsName: o }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, s, i, void 0, this);
          } else if (t.nodeName === "Surface") {
            const s = ee(t.namespaceURI, "patches");
            t.appendChild(s), this.writeSurfacePatches_(s, e, i);
          }
        }
        writeCurveOrLineString(t, e, i) {
          const a = i[i.length - 1].srsName;
          if (t.nodeName !== "LineStringSegment" && a && t.setAttribute("srsName", a), t.nodeName === "LineString" || t.nodeName === "LineStringSegment") {
            const o = ee(t.namespaceURI, "posList");
            t.appendChild(o), this.writePosList_(o, e, i);
          } else if (t.nodeName === "Curve") {
            const o = ee(t.namespaceURI, "segments");
            t.appendChild(o), this.writeCurveSegments_(o, e, i);
          }
        }
        writeMultiSurfaceOrPolygon(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName, s = r.surface;
          o && t.setAttribute("srsName", o);
          const l = e.getPolygons();
          Zt({ node: t, hasZ: a, srsName: o, surface: s }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, l, i, void 0, this);
        }
        writeMultiPoint(t, e, i) {
          const r = i[i.length - 1], a = r.srsName, o = r.hasZ;
          a && t.setAttribute("srsName", a);
          const s = e.getPoints();
          Zt({ node: t, hasZ: o, srsName: a }, this.POINTMEMBER_SERIALIZERS, _n("pointMember"), s, i, void 0, this);
        }
        writeMultiCurveOrLineString(t, e, i) {
          const r = i[i.length - 1], a = r.hasZ, o = r.srsName, s = r.curve;
          o && t.setAttribute("srsName", o);
          const l = e.getLineStrings();
          Zt({ node: t, hasZ: a, srsName: o, curve: s }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, l, i, void 0, this);
        }
        writeRing(t, e, i) {
          const r = ee(t.namespaceURI, "LinearRing");
          t.appendChild(r), this.writeLinearRing(r, e, i);
        }
        writeSurfaceOrPolygonMember(t, e, i) {
          const r = this.GEOMETRY_NODE_FACTORY_(e, i);
          r && (t.appendChild(r), this.writeSurfaceOrPolygon(r, e, i));
        }
        writePointMember(t, e, i) {
          const r = ee(t.namespaceURI, "Point");
          t.appendChild(r), this.writePoint(r, e, i);
        }
        writeLineStringOrCurveMember(t, e, i) {
          const r = this.GEOMETRY_NODE_FACTORY_(e, i);
          r && (t.appendChild(r), this.writeCurveOrLineString(r, e, i));
        }
        writeSurfacePatches_(t, e, i) {
          const r = ee(t.namespaceURI, "PolygonPatch");
          t.appendChild(r), this.writeSurfaceOrPolygon(r, e, i);
        }
        writeCurveSegments_(t, e, i) {
          const r = ee(t.namespaceURI, "LineStringSegment");
          t.appendChild(r), this.writeCurveOrLineString(r, e, i);
        }
        writeGeometryElement(t, e, i) {
          const r = i[i.length - 1], a = Object.assign({}, r);
          a.node = t;
          let o;
          Array.isArray(e) ? o = SS(e, r) : o = cn(e, true, r), Zt(a, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [o], i, void 0, this);
        }
        writeFeatureElement(t, e, i) {
          const r = e.getId();
          r && t.setAttribute("fid", r);
          const a = i[i.length - 1], o = a.featureNS, s = e.getGeometryName();
          a.serializers || (a.serializers = {}, a.serializers[o] = {});
          const l = [], u = [];
          if (e.hasProperties()) {
            const c = e.getProperties();
            for (const f in c) {
              const g = c[f];
              g != null && (l.push(f), u.push(g), f == s || typeof g.getSimplifiedGeometry == "function" ? f in a.serializers[o] || (a.serializers[o][f] = U(this.writeGeometryElement, this)) : f in a.serializers[o] || (a.serializers[o][f] = U(Xt)));
            }
          }
          const h = Object.assign({}, a);
          h.node = t, Zt(h, a.serializers, _n(void 0, o), u, i, l);
        }
        writeFeatureMembers_(t, e, i) {
          const r = i[i.length - 1], a = r.featureType, o = r.featureNS, s = {};
          s[o] = {}, s[o][a] = U(this.writeFeatureElement, this);
          const l = Object.assign({}, r);
          l.node = t, Zt(l, s, _n(a, o), e, i);
        }
        MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, e, i) {
          const r = e[e.length - 1].node;
          return ee(this.namespace, Sft[r.nodeName]);
        }
        GEOMETRY_NODE_FACTORY_(t, e, i) {
          const r = e[e.length - 1], a = r.multiSurface, o = r.surface, s = r.curve, l = r.multiCurve;
          return Array.isArray(t) ? i = "Envelope" : (i = t.getType(), i === "MultiPolygon" && a === true ? i = "MultiSurface" : i === "Polygon" && o === true ? i = "Surface" : i === "LineString" && s === true ? i = "Curve" : i === "MultiLineString" && l === true && (i = "MultiCurve")), ee(this.namespace, i);
        }
        writeGeometryNode(t, e) {
          e = this.adaptOptions(e);
          const i = ee(this.namespace, "geom"), r = { node: i, hasZ: this.hasZ, srsName: this.srsName, curve: this.curve_, surface: this.surface_, multiSurface: this.multiSurface_, multiCurve: this.multiCurve_ };
          return e && Object.assign(r, e), this.writeGeometryElement(i, t, [r]), i;
        }
        writeFeaturesNode(t, e) {
          e = this.adaptOptions(e);
          const i = ee(this.namespace, "featureMembers");
          i.setAttributeNS(sh, "xsi:schemaLocation", this.schemaLocation);
          const r = { srsName: this.srsName, hasZ: this.hasZ, curve: this.curve_, surface: this.surface_, multiSurface: this.multiSurface_, multiCurve: this.multiCurve_, featureNS: this.featureNS, featureType: this.featureType };
          return e && Object.assign(r, e), this.writeFeatureMembers_(i, t, [r]), i;
        }
      }
      lt.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml": { pos: Vt(lt.prototype.readFlatPos), posList: Vt(lt.prototype.readFlatPosList), coordinates: Vt(ve.prototype.readFlatCoordinates) } }, lt.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml": { interior: lt.prototype.interiorParser, exterior: lt.prototype.exteriorParser } }, lt.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml": { Point: Vt(Pt.prototype.readPoint), MultiPoint: Vt(Pt.prototype.readMultiPoint), LineString: Vt(Pt.prototype.readLineString), MultiLineString: Vt(Pt.prototype.readMultiLineString), LinearRing: Vt(Pt.prototype.readLinearRing), Polygon: Vt(Pt.prototype.readPolygon), MultiPolygon: Vt(Pt.prototype.readMultiPolygon), Surface: Vt(lt.prototype.readSurface), MultiSurface: Vt(lt.prototype.readMultiSurface), Curve: Vt(lt.prototype.readCurve), MultiCurve: Vt(lt.prototype.readMultiCurve), Envelope: Vt(lt.prototype.readEnvelope) } }, lt.prototype.MULTICURVE_PARSERS = { "http://www.opengis.net/gml": { curveMember: Lt(lt.prototype.curveMemberParser), curveMembers: Lt(lt.prototype.curveMemberParser) } }, lt.prototype.MULTISURFACE_PARSERS = { "http://www.opengis.net/gml": { surfaceMember: Lt(lt.prototype.surfaceMemberParser), surfaceMembers: Lt(lt.prototype.surfaceMemberParser) } }, lt.prototype.CURVEMEMBER_PARSERS = { "http://www.opengis.net/gml": { LineString: Lt(Pt.prototype.readLineString), Curve: Lt(lt.prototype.readCurve) } }, lt.prototype.SURFACEMEMBER_PARSERS = { "http://www.opengis.net/gml": { Polygon: Lt(Pt.prototype.readPolygon), Surface: Lt(lt.prototype.readSurface) } }, lt.prototype.SURFACE_PARSERS = { "http://www.opengis.net/gml": { patches: Vt(lt.prototype.readPatch) } }, lt.prototype.CURVE_PARSERS = { "http://www.opengis.net/gml": { segments: Vt(lt.prototype.readSegment) } }, lt.prototype.ENVELOPE_PARSERS = { "http://www.opengis.net/gml": { lowerCorner: Lt(lt.prototype.readFlatPosList), upperCorner: Lt(lt.prototype.readFlatPosList) } }, lt.prototype.PATCHES_PARSERS = { "http://www.opengis.net/gml": { PolygonPatch: Vt(lt.prototype.readPolygonPatch) } }, lt.prototype.SEGMENTS_PARSERS = { "http://www.opengis.net/gml": { LineStringSegment: X0(lt.prototype.readLineStringSegment) } }, Pt.prototype.RING_PARSERS = { "http://www.opengis.net/gml": { LinearRing: Vt(Pt.prototype.readFlatLinearRing), Ring: Vt(lt.prototype.readFlatCurveRing) } }, lt.prototype.writeFeatures, lt.prototype.RING_SERIALIZERS = { "http://www.opengis.net/gml": { exterior: U(lt.prototype.writeRing), interior: U(lt.prototype.writeRing) } }, lt.prototype.ENVELOPE_SERIALIZERS = { "http://www.opengis.net/gml": { lowerCorner: U(Xt), upperCorner: U(Xt) } }, lt.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { surfaceMember: U(lt.prototype.writeSurfaceOrPolygonMember), polygonMember: U(lt.prototype.writeSurfaceOrPolygonMember) } }, lt.prototype.POINTMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { pointMember: U(lt.prototype.writePointMember) } }, lt.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = { "http://www.opengis.net/gml": { lineStringMember: U(lt.prototype.writeLineStringOrCurveMember), curveMember: U(lt.prototype.writeLineStringOrCurveMember) } }, lt.prototype.GEOMETRY_SERIALIZERS = { "http://www.opengis.net/gml": { Curve: U(lt.prototype.writeCurveOrLineString), MultiCurve: U(lt.prototype.writeMultiCurveOrLineString), Point: U(lt.prototype.writePoint), MultiPoint: U(lt.prototype.writeMultiPoint), LineString: U(lt.prototype.writeCurveOrLineString), MultiLineString: U(lt.prototype.writeMultiCurveOrLineString), LinearRing: U(lt.prototype.writeLinearRing), Polygon: U(lt.prototype.writeSurfaceOrPolygon), MultiPolygon: U(lt.prototype.writeMultiSurfaceOrPolygon), Surface: U(lt.prototype.writeSurfaceOrPolygon), MultiSurface: U(lt.prototype.writeMultiSurfaceOrPolygon), Envelope: U(lt.prototype.writeEnvelope) } };
      const LS = lt;
      LS.prototype.writeFeatures, LS.prototype.writeFeaturesNode;
      const fn = [null, "http://www.topografix.com/GPX/1/0", "http://www.topografix.com/GPX/1/1"], bft = "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd", Tft = { rte: o3, trk: s3, wpt: l3 }, Bft = tt(fn, { rte: Lt(o3), trk: Lt(s3), wpt: Lt(l3) }), Mft = tt(fn, { text: z(ot, "linkText"), type: z(ot, "linkType") }), Dft = tt(fn, { name: z(ot), email: rgt, link: pp }), Rft = tt(fn, { name: z(ot), desc: z(ot), author: z(egt), copyright: z(ngt), link: pp, time: z($0), keywords: z(ot), bounds: igt, extensions: K0 }), Lft = tt(fn, { year: z(Cn), license: z(ot) }), Pft = tt(fn, { rte: U(lgt), trk: U(ugt), wpt: U(cgt) });
      class Nft extends Ap {
        constructor(t) {
          super(), t = t || {}, this.dataProjection = qt("EPSG:4326"), this.readExtensions_ = t.readExtensions;
        }
        handleReadExtensions_(t) {
          t || (t = []);
          for (let e = 0, i = t.length; e < i; ++e) {
            const r = t[e];
            if (this.readExtensions_) {
              const a = r.get("extensionsNode_") || null;
              this.readExtensions_(r, a);
            }
            r.set("extensionsNode_", void 0);
          }
        }
        readMetadata(t) {
          return t ? typeof t == "string" ? this.readMetadataFromDocument(ua(t)) : la(t) ? this.readMetadataFromDocument(t) : this.readMetadataFromNode(t) : null;
        }
        readMetadataFromDocument(t) {
          for (let e = t.firstChild; e; e = e.nextSibling) if (e.nodeType === Node.ELEMENT_NODE) {
            const i = this.readMetadataFromNode(e);
            if (i) return i;
          }
          return null;
        }
        readMetadataFromNode(t) {
          if (!fn.includes(t.namespaceURI)) return null;
          for (let e = t.firstElementChild; e; e = e.nextElementSibling) if (fn.includes(e.namespaceURI) && e.localName === "metadata") return at({}, Rft, e, []);
          return null;
        }
        readFeatureFromNode(t, e) {
          if (!fn.includes(t.namespaceURI)) return null;
          const i = Tft[t.localName];
          if (!i) return null;
          const r = i(t, [this.getReadOptions(t, e)]);
          return r ? (this.handleReadExtensions_([r]), r) : null;
        }
        readFeaturesFromNode(t, e) {
          if (!fn.includes(t.namespaceURI)) return [];
          if (t.localName == "gpx") {
            const i = at([], Bft, t, [this.getReadOptions(t, e)]);
            return i ? (this.handleReadExtensions_(i), i) : [];
          }
          return [];
        }
        writeFeaturesNode(t, e) {
          e = this.adaptOptions(e);
          const i = ee("http://www.topografix.com/GPX/1/1", "gpx");
          return i.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xsi", sh), i.setAttributeNS(sh, "xsi:schemaLocation", bft), i.setAttribute("version", "1.1"), i.setAttribute("creator", "OpenLayers"), Zt({ node: i }, Pft, tgt, t, [e]), i;
        }
      }
      const Fft = tt(fn, { name: z(ot), cmt: z(ot), desc: z(ot), src: z(ot), link: pp, number: z(Cn), extensions: K0, type: z(ot), rtept: agt }), kft = tt(fn, { ele: z(_e), time: z($0) }), Oft = tt(fn, { name: z(ot), cmt: z(ot), desc: z(ot), src: z(ot), link: pp, number: z(Cn), type: z(ot), extensions: K0, trkseg: sgt }), Qft = tt(fn, { trkpt: ogt }), zft = tt(fn, { ele: z(_e), time: z($0) }), Gft = tt(fn, { ele: z(_e), time: z($0), magvar: z(_e), geoidheight: z(_e), name: z(ot), cmt: z(ot), desc: z(ot), src: z(ot), link: pp, sym: z(ot), type: z(ot), fix: z(ot), sat: z(Cn), hdop: z(_e), vdop: z(_e), pdop: z(_e), ageofdgpsdata: z(_e), dgpsid: z(Cn), extensions: K0 }), Uft = ["text", "type"], Vft = tt(fn, { text: U(Xt), type: U(Xt) }), jft = tt(fn, ["name", "cmt", "desc", "src", "link", "number", "type", "rtept"]), qft = tt(fn, { name: U(Xt), cmt: U(Xt), desc: U(Xt), src: U(Xt), link: U(FS), number: U(Z0), type: U(Xt), rtept: r3(U(kS)) }), Hft = tt(fn, ["ele", "time"]), Yft = tt(fn, ["name", "cmt", "desc", "src", "link", "number", "type", "trkseg"]), Wft = tt(fn, { name: U(Xt), cmt: U(Xt), desc: U(Xt), src: U(Xt), link: U(FS), number: U(Z0), type: U(Xt), trkseg: r3(U(hgt)) }), Xft = _n("trkpt"), $ft = tt(fn, { trkpt: U(kS) }), Zft = tt(fn, ["ele", "time", "magvar", "geoidheight", "name", "cmt", "desc", "src", "link", "sym", "type", "fix", "sat", "hdop", "vdop", "pdop", "ageofdgpsdata", "dgpsid"]), Kft = tt(fn, { ele: U(mr), time: U(Ift), magvar: U(mr), geoidheight: U(mr), name: U(Xt), cmt: U(Xt), desc: U(Xt), src: U(Xt), link: U(FS), sym: U(Xt), type: U(Xt), fix: U(Xt), sat: U(Z0), hdop: U(mr), vdop: U(mr), pdop: U(mr), ageofdgpsdata: U(mr), dgpsid: U(Z0) }), Jft = { Point: "wpt", LineString: "rte", MultiLineString: "trk" };
      function tgt(n, t, e) {
        const i = n.getGeometry();
        if (i) {
          const r = Jft[i.getType()];
          if (r) {
            const a = t[t.length - 1].node;
            return ee(a.namespaceURI, r);
          }
        }
      }
      function PS(n, t, e, i) {
        return n.push(parseFloat(e.getAttribute("lon")), parseFloat(e.getAttribute("lat"))), "ele" in i ? (n.push(i.ele), delete i.ele, t.hasZ = true) : n.push(0), "time" in i ? (n.push(i.time), delete i.time, t.hasM = true) : n.push(0), n;
      }
      function NS(n, t, e) {
        let i = "XY", r = 2;
        if (n.hasZ && n.hasM ? (i = "XYZM", r = 4) : n.hasZ ? (i = "XYZ", r = 3) : n.hasM && (i = "XYM", r = 3), r !== 4) {
          for (let a = 0, o = t.length / 4; a < o; a++) t[a * r] = t[a * 4], t[a * r + 1] = t[a * 4 + 1], n.hasZ && (t[a * r + 2] = t[a * 4 + 2]), n.hasM && (t[a * r + 2] = t[a * 4 + 3]);
          if (t.length = t.length / 4 * r, e) for (let a = 0, o = e.length; a < o; a++) e[a] = e[a] / 4 * r;
        }
        return i;
      }
      function egt(n, t) {
        const e = at({}, Dft, n, t);
        if (e) return e;
      }
      function ngt(n, t) {
        const e = at({}, Lft, n, t);
        if (e) {
          const i = n.getAttribute("author");
          return i !== null && (e.author = i), e;
        }
      }
      function igt(n, t) {
        const e = t[t.length - 1], i = n.getAttribute("minlat"), r = n.getAttribute("minlon"), a = n.getAttribute("maxlat"), o = n.getAttribute("maxlon");
        r !== null && i !== null && o !== null && a !== null && (e.bounds = [[parseFloat(r), parseFloat(i)], [parseFloat(o), parseFloat(a)]]);
      }
      function rgt(n, t) {
        const e = t[t.length - 1], i = n.getAttribute("id"), r = n.getAttribute("domain");
        i !== null && r !== null && (e.email = `${i}@${r}`);
      }
      function pp(n, t) {
        const e = t[t.length - 1], i = n.getAttribute("href");
        i !== null && (e.link = i), yr(Mft, n, t);
      }
      function K0(n, t) {
        const e = t[t.length - 1];
        e.extensionsNode_ = n;
      }
      function agt(n, t) {
        const e = at({}, kft, n, t);
        if (e) {
          const i = t[t.length - 1], r = i.flatCoordinates, a = i.layoutOptions;
          PS(r, a, n, e);
        }
      }
      function ogt(n, t) {
        const e = at({}, zft, n, t);
        if (e) {
          const i = t[t.length - 1], r = i.flatCoordinates, a = i.layoutOptions;
          PS(r, a, n, e);
        }
      }
      function sgt(n, t) {
        const e = t[t.length - 1];
        yr(Qft, n, t);
        const i = e.flatCoordinates;
        e.ends.push(i.length);
      }
      function o3(n, t) {
        const e = t[0], i = at({ flatCoordinates: [], layoutOptions: {} }, Fft, n, t);
        if (!i) return;
        const r = i.flatCoordinates;
        delete i.flatCoordinates;
        const a = i.layoutOptions;
        delete i.layoutOptions;
        const o = NS(a, r), s = new Be(r, o);
        cn(s, false, e);
        const l = new Ce(s);
        return l.setProperties(i, true), l;
      }
      function s3(n, t) {
        const e = t[0], i = at({ flatCoordinates: [], ends: [], layoutOptions: {} }, Oft, n, t);
        if (!i) return;
        const r = i.flatCoordinates;
        delete i.flatCoordinates;
        const a = i.ends;
        delete i.ends;
        const o = i.layoutOptions;
        delete i.layoutOptions;
        const s = NS(o, r, a), l = new ui(r, s, a);
        cn(l, false, e);
        const u = new Ce(l);
        return u.setProperties(i, true), u;
      }
      function l3(n, t) {
        const e = t[0], i = at({}, Gft, n, t);
        if (!i) return;
        const r = {}, a = PS([], r, n, i), o = NS(r, a), s = new Ge(a, o);
        cn(s, false, e);
        const l = new Ce(s);
        return l.setProperties(i, true), l;
      }
      function FS(n, t, e) {
        n.setAttribute("href", t);
        const r = e[e.length - 1].properties, a = [r.linkText, r.linkType];
        Zt({ node: n }, Vft, hi, a, e, Uft);
      }
      function kS(n, t, e) {
        const i = e[e.length - 1], a = i.node.namespaceURI, o = i.properties;
        switch (n.setAttributeNS(null, "lat", String(t[1])), n.setAttributeNS(null, "lon", String(t[0])), i.geometryLayout) {
          case "XYZM":
            t[3] !== 0 && (o.time = t[3]);
          case "XYZ":
            t[2] !== 0 && (o.ele = t[2]);
            break;
          case "XYM":
            t[2] !== 0 && (o.time = t[2]);
            break;
        }
        const l = n.nodeName == "rtept" ? Hft[a] : Zft[a], u = vr(o, l);
        Zt({ node: n, properties: o }, Kft, hi, u, e, l);
      }
      function lgt(n, t, e) {
        const i = e[0], r = t.getProperties(), a = { node: n };
        a.properties = r;
        const o = t.getGeometry();
        if (o.getType() == "LineString") {
          const h = cn(o, true, i);
          a.geometryLayout = h.getLayout(), r.rtept = h.getCoordinates();
        }
        const s = e[e.length - 1].node, l = jft[s.namespaceURI], u = vr(r, l);
        Zt(a, qft, hi, u, e, l);
      }
      function ugt(n, t, e) {
        const i = e[0], r = t.getProperties(), a = { node: n };
        a.properties = r;
        const o = t.getGeometry();
        if (o.getType() == "MultiLineString") {
          const h = cn(o, true, i);
          r.trkseg = h.getLineStrings();
        }
        const s = e[e.length - 1].node, l = Yft[s.namespaceURI], u = vr(r, l);
        Zt(a, Wft, hi, u, e, l);
      }
      function hgt(n, t, e) {
        const i = { node: n };
        i.geometryLayout = t.getLayout(), i.properties = {}, Zt(i, $ft, Xft, t.getCoordinates(), e);
      }
      function cgt(n, t, e) {
        const i = e[0], r = e[e.length - 1];
        r.properties = t.getProperties();
        const a = t.getGeometry();
        if (a.getType() == "Point") {
          const o = cn(a, true, i);
          r.geometryLayout = o.getLayout(), kS(n, o.getCoordinates(), e);
        }
      }
      class OS extends gp {
        constructor() {
          super();
        }
        getType() {
          return "text";
        }
        readFeature(t, e) {
          return this.readFeatureFromText(J0(t), this.adaptOptions(e));
        }
        readFeatureFromText(t, e) {
          return zt();
        }
        readFeatures(t, e) {
          return this.readFeaturesFromText(J0(t), this.adaptOptions(e));
        }
        readFeaturesFromText(t, e) {
          return zt();
        }
        readGeometry(t, e) {
          return this.readGeometryFromText(J0(t), this.adaptOptions(e));
        }
        readGeometryFromText(t, e) {
          return zt();
        }
        readProjection(t) {
          return this.readProjectionFromText(J0(t));
        }
        readProjectionFromText(t) {
          return this.dataProjection;
        }
        writeFeature(t, e) {
          return this.writeFeatureText(t, this.adaptOptions(e));
        }
        writeFeatureText(t, e) {
          return zt();
        }
        writeFeatures(t, e) {
          return this.writeFeaturesText(t, this.adaptOptions(e));
        }
        writeFeaturesText(t, e) {
          return zt();
        }
        writeGeometry(t, e) {
          return this.writeGeometryText(t, this.adaptOptions(e));
        }
        writeGeometryText(t, e) {
          return zt();
        }
      }
      function J0(n) {
        return typeof n == "string" ? n : "";
      }
      const fgt = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/, ggt = /^H.([A-Z]{3}).*?:(.*)/, dgt = /^HFDTE(\d{2})(\d{2})(\d{2})/, Agt = /^HFDTEDATE:(\d{2})(\d{2})(\d{2}),(\d{2})/, pgt = /\r\n|\r|\n/;
      class vgt extends OS {
        constructor(t) {
          super(), t = t || {}, this.dataProjection = qt("EPSG:4326"), this.altitudeMode_ = t.altitudeMode ? t.altitudeMode : "none", this.lad_ = false, this.lod_ = false, this.ladStart_ = 0, this.ladStop_ = 0, this.lodStart_ = 0, this.lodStop_ = 0;
        }
        readFeatureFromText(t, e) {
          const i = this.altitudeMode_, r = t.split(pgt), a = {}, o = [];
          let s = 2e3, l = 0, u = 1, h = -1, c, f;
          for (c = 0, f = r.length; c < f; ++c) {
            const p = r[c];
            let v;
            if (p.charAt(0) == "B") {
              if (v = fgt.exec(p), v) {
                const y = parseInt(v[1], 10), m = parseInt(v[2], 10), _ = parseInt(v[3], 10);
                let I = parseInt(v[4], 10) + parseInt(v[5], 10) / 6e4;
                this.lad_ && (I += parseInt(p.slice(this.ladStart_, this.ladStop_), 10) / 6e4 / jn(10, this.ladStop_ - this.ladStart_)), v[6] == "S" && (I = -I);
                let E = parseInt(v[7], 10) + parseInt(v[8], 10) / 6e4;
                if (this.lod_ && (E += parseInt(p.slice(this.lodStart_, this.lodStop_), 10) / 6e4 / jn(10, this.lodStop_ - this.lodStart_)), v[9] == "W" && (E = -E), o.push(E, I), i != "none") {
                  let w;
                  i == "gps" ? w = parseInt(v[11], 10) : i == "barometric" ? w = parseInt(v[12], 10) : w = 0, o.push(w);
                }
                let x = Date.UTC(s, l, u, y, m, _);
                x < h && (x = Date.UTC(s, l, u + 1, y, m, _)), o.push(x / 1e3), h = x;
              }
            } else if (p.charAt(0) == "H") v = Agt.exec(p), v ? (u = parseInt(v[1], 10), l = parseInt(v[2], 10) - 1, s = 2e3 + parseInt(v[3], 10)) : (v = dgt.exec(p), v ? (u = parseInt(v[1], 10), l = parseInt(v[2], 10) - 1, s = 2e3 + parseInt(v[3], 10)) : (v = ggt.exec(p), v && (a[v[1]] = v[2].trim())));
            else if (p.charAt(0) == "I") {
              const y = parseInt(p.slice(1, 3), 10);
              for (let m = 0; m < y; m++) {
                const _ = p.slice(7 + m * 7, 10 + m * 7);
                if (_ === "LAD" || _ === "LOD") {
                  const I = parseInt(p.slice(3 + m * 7, 5 + m * 7), 10) - 1, E = parseInt(p.slice(5 + m * 7, 7 + m * 7), 10);
                  _ === "LAD" ? (this.lad_ = true, this.ladStart_ = I, this.ladStop_ = E) : _ === "LOD" && (this.lod_ = true, this.lodStart_ = I, this.lodStop_ = E);
                }
              }
            }
          }
          if (o.length === 0) return null;
          const g = i == "none" ? "XYM" : "XYZM", d = new Be(o, g), A = new Ce(cn(d, false, e));
          return A.setProperties(a, true), A;
        }
        readFeaturesFromText(t, e) {
          const i = this.readFeatureFromText(t, e);
          return i ? [i] : [];
        }
      }
      const Ns = ["http://www.google.com/kml/ext/2.2"], Ft = [null, "http://earth.google.com/kml/2.0", "http://earth.google.com/kml/2.1", "http://earth.google.com/kml/2.2", "http://www.opengis.net/kml/2.2"], ygt = "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd", u3 = { fraction: "fraction", pixels: "pixels", insetPixels: "pixels" }, mgt = tt(Ft, { ExtendedData: C3, Region: S3, MultiGeometry: z(I3, "geometry"), LineString: z(_3, "geometry"), LinearRing: z(E3, "geometry"), Point: z(x3, "geometry"), Polygon: z(w3, "geometry"), Style: z(HS), StyleMap: ndt, address: z(ot), description: z(ot), name: z(ot), open: z(Ul), phoneNumber: z(ot), styleUrl: z(A3), visibility: z(Ul) }, tt(Ns, { MultiTrack: z(Vgt, "geometry"), Track: z(m3, "geometry") })), _gt = tt(Ft, { ExtendedData: C3, Region: S3, Link: ddt, address: z(ot), description: z(ot), name: z(ot), open: z(Ul), phoneNumber: z(ot), visibility: z(Ul) }), Egt = tt(Ft, { href: z(d3) }), Igt = tt(Ft, { Altitude: z(_e), Longitude: z(_e), Latitude: z(_e), Tilt: z(_e), AltitudeMode: z(ot), Heading: z(_e), Roll: z(_e) }), h3 = tt(Ft, { LatLonAltBox: sdt, Lod: udt }), xgt = tt(Ft, ["Document", "Placemark"]), wgt = tt(Ft, { Document: U(Idt), Placemark: U(R3) });
      let lg, t_ = null, QS, vp, yp, mp, e_, zS = null, GS, US = null, VS, lh = null, c3 = null, jS = null;
      function n_(n) {
        return 32 / Math.min(n[0], n[1]);
      }
      function Cgt() {
        lg = [255, 255, 255, 1], t_ = new me({ color: lg }), QS = [20, 2], vp = "pixels", yp = "pixels", mp = [64, 64], e_ = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png", zS = new Qr({ anchor: QS, anchorOrigin: "bottom-left", anchorXUnits: vp, anchorYUnits: yp, crossOrigin: "anonymous", rotation: 0, scale: n_(mp), size: mp, src: e_ }), GS = "NO_IMAGE", US = new Ke({ color: lg, width: 1 }), VS = new Ke({ color: [51, 51, 51, 1], width: 2 }), lh = new Si({ font: "bold 16px Helvetica", fill: t_, stroke: VS, scale: 0.8 }), c3 = new pe({ fill: t_, image: zS, text: lh, stroke: US, zIndex: 0 }), jS = [c3];
      }
      let i_;
      function Sgt(n) {
        return n;
      }
      class bgt extends Ap {
        constructor(t) {
          super(), t = t || {}, jS || Cgt(), this.dataProjection = qt("EPSG:4326"), this.defaultStyle_ = t.defaultStyle ? t.defaultStyle : jS, this.extractStyles_ = t.extractStyles !== void 0 ? t.extractStyles : true, this.writeStyles_ = t.writeStyles !== void 0 ? t.writeStyles : true, this.sharedStyles_ = {}, this.showPointNames_ = t.showPointNames !== void 0 ? t.showPointNames : true, this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : "anonymous", this.iconUrlFunction_ = t.iconUrlFunction ? t.iconUrlFunction : Sgt, this.supportedMediaTypes = ["application/vnd.google-earth.kml+xml"];
        }
        readDocumentOrFolder_(t, e) {
          const i = tt(Ft, { Document: X0(this.readDocumentOrFolder_, this), Folder: X0(this.readDocumentOrFolder_, this), Placemark: Lt(this.readPlacemark_, this), Style: this.readSharedStyle_.bind(this), StyleMap: this.readSharedStyleMap_.bind(this) }), r = at([], i, t, e, this);
          if (r) return r;
        }
        readPlacemark_(t, e) {
          const i = at({ geometry: null }, mgt, t, e, this);
          if (!i) return;
          const r = new Ce(), a = t.getAttribute("id");
          a !== null && r.setId(a);
          const o = e[0], s = i.geometry;
          if (s && cn(s, false, o), r.setGeometry(s), delete i.geometry, this.extractStyles_) {
            const l = i.Style, u = i.styleUrl, h = Bgt(l, u, this.defaultStyle_, this.sharedStyles_, this.showPointNames_);
            r.setStyle(h);
          }
          return delete i.Style, r.setProperties(i, true), r;
        }
        readSharedStyle_(t, e) {
          const i = t.getAttribute("id");
          if (i !== null) {
            const r = HS.call(this, t, e);
            if (r) {
              let a, o = t.baseURI;
              (!o || o == "about:blank") && (o = window.location.href), o ? a = new URL("#" + i, o).href : a = "#" + i, this.sharedStyles_[a] = r;
            }
          }
        }
        readSharedStyleMap_(t, e) {
          const i = t.getAttribute("id");
          if (i === null) return;
          const r = v3.call(this, t, e);
          if (!r) return;
          let a, o = t.baseURI;
          (!o || o == "about:blank") && (o = window.location.href), o ? a = new URL("#" + i, o).href : a = "#" + i, this.sharedStyles_[a] = r;
        }
        readFeatureFromNode(t, e) {
          if (!Ft.includes(t.namespaceURI)) return null;
          const i = this.readPlacemark_(t, [this.getReadOptions(t, e)]);
          return i || null;
        }
        readFeaturesFromNode(t, e) {
          if (!Ft.includes(t.namespaceURI)) return [];
          let i;
          const r = t.localName;
          if (r == "Document" || r == "Folder") return i = this.readDocumentOrFolder_(t, [this.getReadOptions(t, e)]), i || [];
          if (r == "Placemark") {
            const a = this.readPlacemark_(t, [this.getReadOptions(t, e)]);
            return a ? [a] : [];
          }
          if (r == "kml") {
            i = [];
            for (let a = t.firstElementChild; a; a = a.nextElementSibling) {
              const o = this.readFeaturesFromNode(a, e);
              o && Le(i, o);
            }
            return i;
          }
          return [];
        }
        readName(t) {
          if (t) {
            if (typeof t == "string") {
              const e = ua(t);
              return this.readNameFromDocument(e);
            }
            return la(t) ? this.readNameFromDocument(t) : this.readNameFromNode(t);
          }
        }
        readNameFromDocument(t) {
          for (let e = t.firstChild; e; e = e.nextSibling) if (e.nodeType == Node.ELEMENT_NODE) {
            const i = this.readNameFromNode(e);
            if (i) return i;
          }
        }
        readNameFromNode(t) {
          for (let e = t.firstElementChild; e; e = e.nextElementSibling) if (Ft.includes(e.namespaceURI) && e.localName == "name") return ot(e);
          for (let e = t.firstElementChild; e; e = e.nextElementSibling) {
            const i = e.localName;
            if (Ft.includes(e.namespaceURI) && (i == "Document" || i == "Folder" || i == "Placemark" || i == "kml")) {
              const r = this.readNameFromNode(e);
              if (r) return r;
            }
          }
        }
        readNetworkLinks(t) {
          const e = [];
          if (typeof t == "string") {
            const i = ua(t);
            Le(e, this.readNetworkLinksFromDocument(i));
          } else la(t) ? Le(e, this.readNetworkLinksFromDocument(t)) : Le(e, this.readNetworkLinksFromNode(t));
          return e;
        }
        readNetworkLinksFromDocument(t) {
          const e = [];
          for (let i = t.firstChild; i; i = i.nextSibling) i.nodeType == Node.ELEMENT_NODE && Le(e, this.readNetworkLinksFromNode(i));
          return e;
        }
        readNetworkLinksFromNode(t) {
          const e = [];
          for (let i = t.firstElementChild; i; i = i.nextElementSibling) if (Ft.includes(i.namespaceURI) && i.localName == "NetworkLink") {
            const r = at({}, _gt, i, []);
            e.push(r);
          }
          for (let i = t.firstElementChild; i; i = i.nextElementSibling) {
            const r = i.localName;
            Ft.includes(i.namespaceURI) && (r == "Document" || r == "Folder" || r == "kml") && Le(e, this.readNetworkLinksFromNode(i));
          }
          return e;
        }
        readRegion(t) {
          const e = [];
          if (typeof t == "string") {
            const i = ua(t);
            Le(e, this.readRegionFromDocument(i));
          } else la(t) ? Le(e, this.readRegionFromDocument(t)) : Le(e, this.readRegionFromNode(t));
          return e;
        }
        readRegionFromDocument(t) {
          const e = [];
          for (let i = t.firstChild; i; i = i.nextSibling) i.nodeType == Node.ELEMENT_NODE && Le(e, this.readRegionFromNode(i));
          return e;
        }
        readRegionFromNode(t) {
          const e = [];
          for (let i = t.firstElementChild; i; i = i.nextElementSibling) if (Ft.includes(i.namespaceURI) && i.localName == "Region") {
            const r = at({}, h3, i, []);
            e.push(r);
          }
          for (let i = t.firstElementChild; i; i = i.nextElementSibling) {
            const r = i.localName;
            Ft.includes(i.namespaceURI) && (r == "Document" || r == "Folder" || r == "kml") && Le(e, this.readRegionFromNode(i));
          }
          return e;
        }
        readCamera(t) {
          const e = [];
          if (typeof t == "string") {
            const i = ua(t);
            Le(e, this.readCameraFromDocument(i));
          } else la(t) ? Le(e, this.readCameraFromDocument(t)) : Le(e, this.readCameraFromNode(t));
          return e;
        }
        readCameraFromDocument(t) {
          const e = [];
          for (let i = t.firstChild; i; i = i.nextSibling) i.nodeType === Node.ELEMENT_NODE && Le(e, this.readCameraFromNode(i));
          return e;
        }
        readCameraFromNode(t) {
          const e = [];
          for (let i = t.firstElementChild; i; i = i.nextElementSibling) if (Ft.includes(i.namespaceURI) && i.localName === "Camera") {
            const r = at({}, Igt, i, []);
            e.push(r);
          }
          for (let i = t.firstElementChild; i; i = i.nextElementSibling) {
            const r = i.localName;
            Ft.includes(i.namespaceURI) && (r === "Document" || r === "Folder" || r === "Placemark" || r === "kml") && Le(e, this.readCameraFromNode(i));
          }
          return e;
        }
        writeFeaturesNode(t, e) {
          e = this.adaptOptions(e);
          const i = ee(Ft[4], "kml"), r = "http://www.w3.org/2000/xmlns/";
          i.setAttributeNS(r, "xmlns:gx", Ns[0]), i.setAttributeNS(r, "xmlns:xsi", sh), i.setAttributeNS(sh, "xsi:schemaLocation", ygt);
          const a = { node: i }, o = {};
          t.length > 1 ? o.Document = t : t.length == 1 && (o.Placemark = t[0]);
          const s = xgt[i.namespaceURI], l = vr(o, s);
          return Zt(a, wgt, hi, l, [e], s, this), i;
        }
      }
      function Tgt(n, t) {
        const e = [0, 0];
        let i = "start";
        const r = n.getImage();
        if (r) {
          const s = r.getSize();
          if (s && s.length == 2) {
            const l = r.getScaleArray(), u = r.getAnchor();
            e[0] = l[0] * (s[0] - u[0]), e[1] = l[1] * (s[1] / 2 - u[1]), i = "left";
          }
        }
        let a = n.getText();
        return a ? (a = a.clone(), a.setFont(a.getFont() || lh.getFont()), a.setScale(a.getScale() || lh.getScale()), a.setFill(a.getFill() || lh.getFill()), a.setStroke(a.getStroke() || VS)) : a = lh.clone(), a.setText(t), a.setOffsetX(e[0]), a.setOffsetY(e[1]), a.setTextAlign(i), new pe({ image: r, text: a });
      }
      function Bgt(n, t, e, i, r) {
        return function(a, o) {
          let s = r, l = "", u = [];
          if (s) {
            const c = a.getGeometry();
            if (c) if (c instanceof wn) u = c.getGeometriesArrayRecursive().filter(function(f) {
              const g = f.getType();
              return g === "Point" || g === "MultiPoint";
            }), s = u.length > 0;
            else {
              const f = c.getType();
              s = f === "Point" || f === "MultiPoint";
            }
          }
          s && (l = a.get("name"), s = s && !!l, s && /&[^&]+;/.test(l) && (i_ || (i_ = document.createElement("textarea")), i_.innerHTML = l, l = i_.value));
          let h = e;
          if (n ? h = n : t && (h = f3(t, e, i)), s) {
            const c = Tgt(h[0], l);
            if (u.length > 0) {
              c.setGeometry(new wn(u));
              const f = new pe({ geometry: h[0].getGeometry(), image: null, fill: h[0].getFill(), stroke: h[0].getStroke(), text: null });
              return [c, f].concat(h.slice(1));
            }
            return c;
          }
          return h;
        };
      }
      function f3(n, t, e) {
        return Array.isArray(n) ? n : typeof n == "string" ? f3(e[n], t, e) : t;
      }
      function r_(n) {
        const t = Hi(n, false), e = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(t);
        if (e) {
          const i = e[1];
          return [parseInt(i.substr(6, 2), 16), parseInt(i.substr(4, 2), 16), parseInt(i.substr(2, 2), 16), parseInt(i.substr(0, 2), 16) / 255];
        }
      }
      function g3(n) {
        let t = Hi(n, false);
        const e = [];
        t = t.replace(/\s*,\s*/g, ",");
        const i = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
        let r;
        for (; r = i.exec(t); ) {
          const a = parseFloat(r[1]), o = parseFloat(r[2]), s = r[3] ? parseFloat(r[3]) : 0;
          e.push(a, o, s), t = t.substr(r[0].length);
        }
        if (t === "") return e;
      }
      function d3(n) {
        const t = Hi(n, false).trim();
        let e = n.baseURI;
        return (!e || e == "about:blank") && (e = window.location.href), e ? new URL(t, e).href : t;
      }
      function A3(n) {
        const t = Hi(n, false).trim().replace(/^(?!.*#)/, "#");
        let e = n.baseURI;
        return (!e || e == "about:blank") && (e = window.location.href), e ? new URL(t, e).href : t;
      }
      function Mgt(n) {
        const t = n.getAttribute("xunits"), e = n.getAttribute("yunits");
        let i;
        return t !== "insetPixels" ? e !== "insetPixels" ? i = "bottom-left" : i = "top-left" : e !== "insetPixels" ? i = "bottom-right" : i = "top-right", { x: parseFloat(n.getAttribute("x")), xunits: u3[t], y: parseFloat(n.getAttribute("y")), yunits: u3[e], origin: i };
      }
      function p3(n) {
        return _e(n);
      }
      const Dgt = tt(Ft, { Pair: edt });
      function v3(n, t) {
        return at(void 0, Dgt, n, t, this);
      }
      const Rgt = tt(Ft, { Icon: z(Hgt), color: z(r_), heading: z(_e), hotSpot: z(Mgt), scale: z(p3) });
      function Lgt(n, t) {
        const e = at({}, Rgt, n, t);
        if (!e) return;
        const i = t[t.length - 1], r = "Icon" in e ? e.Icon : {}, a = !("Icon" in e) || Object.keys(r).length > 0;
        let o;
        const s = r.href;
        s ? o = s : a && (o = e_);
        let l, u, h, c = "bottom-left";
        const f = e.hotSpot;
        f ? (l = [f.x, f.y], u = f.xunits, h = f.yunits, c = f.origin) : /^https?:\/\/maps\.(?:google|gstatic)\.com\//.test(o) && (o.includes("pushpin") ? (l = QS, u = vp, h = yp) : o.includes("arrow-reverse") ? (l = [54, 42], u = vp, h = yp) : o.includes("paddle") && (l = [32, 1], u = vp, h = yp));
        let g;
        const d = r.x, A = r.y;
        d !== void 0 && A !== void 0 && (g = [d, A]);
        let p;
        const v = r.w, y = r.h;
        v !== void 0 && y !== void 0 && (p = [v, y]);
        let m;
        const _ = e.heading;
        _ !== void 0 && (m = ea(_));
        const I = e.scale, E = e.color;
        if (a) {
          o == e_ && (p = mp);
          const x = new Qr({ anchor: l, anchorOrigin: c, anchorXUnits: u, anchorYUnits: h, crossOrigin: this.crossOrigin_, offset: g, offsetOrigin: "bottom-left", rotation: m, scale: I, size: p, src: this.iconUrlFunction_(o), color: E }), w = x.getScaleArray()[0], C = x.getSize();
          if (C === null) {
            const S = x.getImageState();
            if (S === Mt.IDLE || S === Mt.LOADING) {
              const b = function() {
                const T = x.getImageState();
                if (!(T === Mt.IDLE || T === Mt.LOADING)) {
                  const B = x.getSize();
                  if (B && B.length == 2) {
                    const R = n_(B);
                    x.setScale(w * R);
                  }
                  x.unlistenImageChange(b);
                }
              };
              x.listenImageChange(b), S === Mt.IDLE && x.load();
            }
          } else if (C.length == 2) {
            const S = n_(C);
            x.setScale(w * S);
          }
          i.imageStyle = x;
        } else i.imageStyle = GS;
      }
      const Pgt = tt(Ft, { color: z(r_), scale: z(p3) });
      function Ngt(n, t) {
        const e = at({}, Pgt, n, t);
        if (!e) return;
        const i = t[t.length - 1], r = new Si({ fill: new me({ color: "color" in e ? e.color : lg }), scale: e.scale });
        i.textStyle = r;
      }
      const Fgt = tt(Ft, { color: z(r_), width: z(_e) });
      function kgt(n, t) {
        const e = at({}, Fgt, n, t);
        if (!e) return;
        const i = t[t.length - 1], r = new Ke({ color: "color" in e ? e.color : lg, width: "width" in e ? e.width : 1 });
        i.strokeStyle = r;
      }
      const Ogt = tt(Ft, { color: z(r_), fill: z(Ul), outline: z(Ul) });
      function Qgt(n, t) {
        const e = at({}, Ogt, n, t);
        if (!e) return;
        const i = t[t.length - 1], r = new me({ color: "color" in e ? e.color : lg });
        i.fillStyle = r;
        const a = e.fill;
        a !== void 0 && (i.fill = a);
        const o = e.outline;
        o !== void 0 && (i.outline = o);
      }
      const zgt = tt(Ft, { coordinates: Vt(g3) });
      function y3(n, t) {
        return at(null, zgt, n, t);
      }
      function Ggt(n, t) {
        const i = t[t.length - 1].coordinates, r = Hi(n, false), o = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i.exec(r);
        if (o) {
          const s = parseFloat(o[1]), l = parseFloat(o[2]), u = parseFloat(o[3]);
          i.push([s, l, u]);
        } else i.push([]);
      }
      const Ugt = tt(Ns, { Track: Lt(m3) });
      function Vgt(n, t) {
        const e = at([], Ugt, n, t);
        if (e) return new ui(e);
      }
      const jgt = tt(Ft, { when: Adt }, tt(Ns, { coord: Ggt }));
      function m3(n, t) {
        const e = at({ coordinates: [], whens: [] }, jgt, n, t);
        if (!e) return;
        const i = [], r = e.coordinates, a = e.whens;
        for (let o = 0, s = Math.min(r.length, a.length); o < s; ++o) r[o].length == 3 && i.push(r[o][0], r[o][1], r[o][2], a[o]);
        return new Be(i, "XYZM");
      }
      const qgt = tt(Ft, { href: z(d3) }, tt(Ns, { x: z(_e), y: z(_e), w: z(_e), h: z(_e) }));
      function Hgt(n, t) {
        const e = at({}, qgt, n, t);
        return e || null;
      }
      const Ygt = tt(Ft, { coordinates: Vt(g3) });
      function qS(n, t) {
        return at(null, Ygt, n, t);
      }
      const a_ = tt(Ft, { extrude: z(Ul), tessellate: z(Ul), altitudeMode: z(ot) });
      function _3(n, t) {
        const e = at({}, a_, n, t), i = qS(n, t);
        if (i) {
          const r = new Be(i, "XYZ");
          return r.setProperties(e, true), r;
        }
      }
      function E3(n, t) {
        const e = at({}, a_, n, t), i = qS(n, t);
        if (i) {
          const r = new Dn(i, "XYZ", [i.length]);
          return r.setProperties(e, true), r;
        }
      }
      const Wgt = tt(Ft, { LineString: Lt(_3), LinearRing: Lt(E3), MultiGeometry: Lt(I3), Point: Lt(x3), Polygon: Lt(w3) });
      function I3(n, t) {
        const e = at([], Wgt, n, t);
        if (!e) return null;
        if (e.length === 0) return new wn(e);
        let i, r = true;
        const a = e[0].getType();
        let o;
        for (let s = 1, l = e.length; s < l; ++s) if (o = e[s], o.getType() != a) {
          r = false;
          break;
        }
        if (r) {
          let s, l;
          if (a == "Point") {
            const u = e[0];
            s = u.getLayout(), l = u.getFlatCoordinates();
            for (let h = 1, c = e.length; h < c; ++h) o = e[h], Le(l, o.getFlatCoordinates());
            i = new fr(l, s), YS(i, e);
          } else if (a == "LineString") i = new ui(e), YS(i, e);
          else if (a == "Polygon") i = new bi(e), YS(i, e);
          else if (a == "GeometryCollection" || a.startsWith("Multi")) i = new wn(e);
          else throw new Error("Unknown geometry type found");
        } else i = new wn(e);
        return i;
      }
      function x3(n, t) {
        const e = at({}, a_, n, t), i = qS(n, t);
        if (i) {
          const r = new Ge(i, "XYZ");
          return r.setProperties(e, true), r;
        }
      }
      const Xgt = tt(Ft, { innerBoundaryIs: cdt, outerBoundaryIs: gdt });
      function w3(n, t) {
        const e = at({}, a_, n, t), i = at([null], Xgt, n, t);
        if (i && i[0]) {
          const r = i[0], a = [r.length];
          for (let s = 1, l = i.length; s < l; ++s) Le(r, i[s]), a.push(r.length);
          const o = new Dn(r, "XYZ", a);
          return o.setProperties(e, true), o;
        }
      }
      const $gt = tt(Ft, { IconStyle: Lgt, LabelStyle: Ngt, LineStyle: kgt, PolyStyle: Qgt });
      function HS(n, t) {
        const e = at({}, $gt, n, t, this);
        if (!e) return null;
        let i = "fillStyle" in e ? e.fillStyle : t_;
        const r = e.fill;
        r !== void 0 && !r && (i = null);
        let a;
        "imageStyle" in e ? e.imageStyle != GS && (a = e.imageStyle) : a = zS;
        const o = "textStyle" in e ? e.textStyle : lh, s = "strokeStyle" in e ? e.strokeStyle : US, l = e.outline;
        return l !== void 0 && !l ? [new pe({ geometry: function(u) {
          const h = u.getGeometry(), c = h.getType();
          if (c === "GeometryCollection") {
            const f = h;
            return new wn(f.getGeometriesArrayRecursive().filter(function(g) {
              const d = g.getType();
              return d !== "Polygon" && d !== "MultiPolygon";
            }));
          }
          if (c !== "Polygon" && c !== "MultiPolygon") return h;
        }, fill: i, image: a, stroke: s, text: o, zIndex: void 0 }), new pe({ geometry: function(u) {
          const h = u.getGeometry(), c = h.getType();
          if (c === "GeometryCollection") {
            const f = h;
            return new wn(f.getGeometriesArrayRecursive().filter(function(g) {
              const d = g.getType();
              return d === "Polygon" || d === "MultiPolygon";
            }));
          }
          if (c === "Polygon" || c === "MultiPolygon") return h;
        }, fill: i, stroke: null, zIndex: void 0 })] : [new pe({ fill: i, image: a, stroke: s, text: o, zIndex: void 0 })];
      }
      function YS(n, t) {
        const e = t.length, i = new Array(t.length), r = new Array(t.length), a = new Array(t.length);
        let o, s, l;
        o = false, s = false, l = false;
        for (let u = 0; u < e; ++u) {
          const h = t[u];
          i[u] = h.get("extrude"), r[u] = h.get("tessellate"), a[u] = h.get("altitudeMode"), o = o || i[u] !== void 0, s = s || r[u] !== void 0, l = l || a[u];
        }
        o && n.set("extrude", i), s && n.set("tessellate", r), l && n.set("altitudeMode", a);
      }
      const Zgt = tt(Ft, { displayName: z(ot), value: z(ot) });
      function Kgt(n, t) {
        const e = n.getAttribute("name");
        yr(Zgt, n, t);
        const i = t[t.length - 1];
        e && i.displayName ? i[e] = { value: i.value, displayName: i.displayName, toString: function() {
          return i.value;
        } } : e !== null ? i[e] = i.value : i.displayName !== null && (i[i.displayName] = i.value), delete i.value;
      }
      const Jgt = tt(Ft, { Data: Kgt, SchemaData: rdt });
      function C3(n, t) {
        yr(Jgt, n, t);
      }
      function S3(n, t) {
        yr(h3, n, t);
      }
      const tdt = tt(Ft, { Style: z(HS), key: z(ot), styleUrl: z(A3) });
      function edt(n, t) {
        const e = at({}, tdt, n, t, this);
        if (!e) return;
        const i = e.key;
        if (i && i == "normal") {
          const r = e.styleUrl;
          r && (t[t.length - 1] = r);
          const a = e.Style;
          a && (t[t.length - 1] = a);
        }
      }
      function ndt(n, t) {
        const e = v3.call(this, n, t);
        if (!e) return;
        const i = t[t.length - 1];
        if (Array.isArray(e)) i.Style = e;
        else if (typeof e == "string") i.styleUrl = e;
        else throw new Error("`styleMapValue` has an unknown type");
      }
      const idt = tt(Ft, { SimpleData: adt });
      function rdt(n, t) {
        yr(idt, n, t);
      }
      function adt(n, t) {
        const e = n.getAttribute("name");
        if (e !== null) {
          const i = ot(n), r = t[t.length - 1];
          r[e] = i;
        }
      }
      const odt = tt(Ft, { altitudeMode: z(ot), minAltitude: z(_e), maxAltitude: z(_e), north: z(_e), south: z(_e), east: z(_e), west: z(_e) });
      function sdt(n, t) {
        const e = at({}, odt, n, t);
        if (!e) return;
        const i = t[t.length - 1], r = [parseFloat(e.west), parseFloat(e.south), parseFloat(e.east), parseFloat(e.north)];
        i.extent = r, i.altitudeMode = e.altitudeMode, i.minAltitude = parseFloat(e.minAltitude), i.maxAltitude = parseFloat(e.maxAltitude);
      }
      const ldt = tt(Ft, { minLodPixels: z(_e), maxLodPixels: z(_e), minFadeExtent: z(_e), maxFadeExtent: z(_e) });
      function udt(n, t) {
        const e = at({}, ldt, n, t);
        if (!e) return;
        const i = t[t.length - 1];
        i.minLodPixels = parseFloat(e.minLodPixels), i.maxLodPixels = parseFloat(e.maxLodPixels), i.minFadeExtent = parseFloat(e.minFadeExtent), i.maxFadeExtent = parseFloat(e.maxFadeExtent);
      }
      const hdt = tt(Ft, { LinearRing: Lt(y3) });
      function cdt(n, t) {
        const e = at([], hdt, n, t);
        e.length > 0 && t[t.length - 1].push(...e);
      }
      const fdt = tt(Ft, { LinearRing: Vt(y3) });
      function gdt(n, t) {
        const e = at(void 0, fdt, n, t);
        if (e) {
          const i = t[t.length - 1];
          i[0] = e;
        }
      }
      function ddt(n, t) {
        yr(Egt, n, t);
      }
      function Adt(n, t) {
        const i = t[t.length - 1].whens, r = Hi(n, false), a = Date.parse(r);
        i.push(isNaN(a) ? 0 : a);
      }
      function o_(n, t) {
        const e = ia(t), r = [(e.length == 4 ? e[3] : 1) * 255, e[2], e[1], e[0]];
        for (let a = 0; a < 4; ++a) {
          const o = Math.floor(r[a]).toString(16);
          r[a] = o.length == 1 ? "0" + o : o;
        }
        Xt(n, r.join(""));
      }
      function pdt(n, t, e) {
        const i = e[e.length - 1], r = i.layout, a = i.stride;
        let o;
        if (r == "XY" || r == "XYM") o = 2;
        else if (r == "XYZ" || r == "XYZM") o = 3;
        else throw new Error("Invalid geometry layout");
        const s = t.length;
        let l = "";
        if (s > 0) {
          l += t[0];
          for (let u = 1; u < o; ++u) l += "," + t[u];
          for (let u = a; u < s; u += a) {
            l += " " + t[u];
            for (let h = 1; h < o; ++h) l += "," + t[u + h];
          }
        }
        Xt(n, l);
      }
      const s_ = tt(Ft, { Data: U(vdt), value: U(mdt), displayName: U(ydt) });
      function vdt(n, t, e) {
        n.setAttribute("name", t.name);
        const i = { node: n }, r = t.value;
        typeof r == "object" ? (r !== null && r.displayName && Zt(i, s_, hi, [r.displayName], e, ["displayName"]), r !== null && r.value && Zt(i, s_, hi, [r.value], e, ["value"])) : Zt(i, s_, hi, [r], e, ["value"]);
      }
      function ydt(n, t) {
        Eft(n, t);
      }
      function mdt(n, t) {
        Xt(n, t);
      }
      const _dt = tt(Ft, { Placemark: U(R3) }), Edt = function(n, t, e) {
        const i = t[t.length - 1].node;
        return ee(i.namespaceURI, "Placemark");
      };
      function Idt(n, t, e) {
        Zt({ node: n }, _dt, Edt, t, e, void 0, this);
      }
      const xdt = _n("Data");
      function wdt(n, t, e) {
        const i = { node: n }, r = t.names, a = t.values, o = r.length;
        for (let s = 0; s < o; s++) Zt(i, s_, xdt, [{ name: r[s], value: a[s] }], e);
      }
      const b3 = tt(Ft, ["href"], tt(Ns, ["x", "y", "w", "h"])), T3 = tt(Ft, { href: U(Xt) }, tt(Ns, { x: U(mr), y: U(mr), w: U(mr), h: U(mr) })), Cdt = function(n, t, e) {
        return ee(Ns[0], "gx:" + e);
      };
      function Sdt(n, t, e) {
        const i = { node: n }, r = e[e.length - 1].node;
        let a = b3[r.namespaceURI], o = vr(t, a);
        Zt(i, T3, hi, o, e, a), a = b3[Ns[0]], o = vr(t, a), Zt(i, T3, Cdt, o, e, a);
      }
      const bdt = tt(Ft, ["scale", "heading", "Icon", "color", "hotSpot"]), Tdt = tt(Ft, { Icon: U(Sdt), color: U(o_), heading: U(mr), hotSpot: U(eAt), scale: U(N3) });
      function Bdt(n, t, e) {
        const i = { node: n }, r = {}, a = t.getSrc(), o = t.getSize(), s = t.getImageSize(), l = { href: a };
        if (o) {
          l.w = o[0], l.h = o[1];
          const p = t.getAnchor(), v = t.getOrigin();
          if (v && s && v[0] !== 0 && v[1] !== o[1] && (l.x = v[0], l.y = s[1] - (v[1] + o[1])), p && (p[0] !== o[0] / 2 || p[1] !== o[1] / 2)) {
            const y = { x: p[0], xunits: "pixels", y: o[1] - p[1], yunits: "pixels" };
            r.hotSpot = y;
          }
        }
        r.Icon = l;
        let u = t.getScaleArray()[0], h = o;
        if (h === null && (h = mp), h.length == 2) {
          const p = n_(h);
          u = u / p;
        }
        u !== 1 && (r.scale = u);
        const c = t.getRotation();
        c !== 0 && (r.heading = c);
        const f = t.getColor();
        f && (r.color = f);
        const g = e[e.length - 1].node, d = bdt[g.namespaceURI], A = vr(r, d);
        Zt(i, Tdt, hi, A, e, d);
      }
      const Mdt = tt(Ft, ["color", "scale"]), Ddt = tt(Ft, { color: U(o_), scale: U(N3) });
      function Rdt(n, t, e) {
        const i = { node: n }, r = {}, a = t.getFill();
        a && (r.color = a.getColor());
        const o = t.getScale();
        o && o !== 1 && (r.scale = o);
        const s = e[e.length - 1].node, l = Mdt[s.namespaceURI], u = vr(r, l);
        Zt(i, Ddt, hi, u, e, l);
      }
      const Ldt = tt(Ft, ["color", "width"]), Pdt = tt(Ft, { color: U(o_), width: U(mr) });
      function Ndt(n, t, e) {
        const i = { node: n }, r = { color: t.getColor(), width: Number(t.getWidth()) || 1 }, a = e[e.length - 1].node, o = Ldt[a.namespaceURI], s = vr(r, o);
        Zt(i, Pdt, hi, s, e, o);
      }
      const Fdt = { Point: "Point", LineString: "LineString", LinearRing: "LinearRing", Polygon: "Polygon", MultiPoint: "MultiGeometry", MultiLineString: "MultiGeometry", MultiPolygon: "MultiGeometry", GeometryCollection: "MultiGeometry" }, B3 = function(n, t, e) {
        if (n) {
          const i = t[t.length - 1].node;
          return ee(i.namespaceURI, Fdt[n.getType()]);
        }
      }, kdt = _n("Point"), Odt = _n("LineString"), Qdt = _n("LinearRing"), zdt = _n("Polygon"), Gdt = tt(Ft, { LineString: U(ug), Point: U(ug), Polygon: U(P3), GeometryCollection: U(M3) });
      function M3(n, t, e) {
        const i = { node: n }, r = t.getType();
        let a = [], o;
        if (r === "GeometryCollection") t.getGeometriesArrayRecursive().forEach(function(s) {
          const l = s.getType();
          if (l === "MultiPoint") a = a.concat(s.getPoints());
          else if (l === "MultiLineString") a = a.concat(s.getLineStrings());
          else if (l === "MultiPolygon") a = a.concat(s.getPolygons());
          else if (l === "Point" || l === "LineString" || l === "Polygon") a.push(s);
          else throw new Error("Unknown geometry type");
        }), o = B3;
        else if (r === "MultiPoint") a = t.getPoints(), o = kdt;
        else if (r === "MultiLineString") a = t.getLineStrings(), o = Odt;
        else if (r === "MultiPolygon") a = t.getPolygons(), o = zdt;
        else throw new Error("Unknown geometry type");
        Zt(i, Gdt, o, a, e);
      }
      const Udt = tt(Ft, { LinearRing: U(ug) });
      function D3(n, t, e) {
        Zt({ node: n }, Udt, Qdt, [t], e);
      }
      const WS = tt(Ft, { ExtendedData: U(wdt), MultiGeometry: U(M3), LineString: U(ug), LinearRing: U(ug), Point: U(ug), Polygon: U(P3), Style: U(tAt), address: U(Xt), description: U(Xt), name: U(Xt), open: U(sg), phoneNumber: U(Xt), styleUrl: U(Xt), visibility: U(sg) }), Vdt = tt(Ft, ["name", "open", "visibility", "address", "phoneNumber", "description", "styleUrl", "Style"]), jdt = _n("ExtendedData");
      function R3(n, t, e) {
        const i = { node: n };
        t.getId() && n.setAttribute("id", t.getId());
        const r = t.getProperties(), a = { address: 1, description: 1, name: 1, open: 1, phoneNumber: 1, styleUrl: 1, visibility: 1 };
        a[t.getGeometryName()] = 1;
        const o = Object.keys(r || {}).sort().filter(function(g) {
          return !a[g];
        }), s = t.getStyleFunction();
        if (s) {
          const g = s(t, 0);
          if (g) {
            const d = Array.isArray(g) ? g : [g];
            let A = d;
            if (t.getGeometry() && (A = d.filter(function(p) {
              const v = p.getGeometryFunction()(t);
              if (v) {
                const y = v.getType();
                return y === "GeometryCollection" ? v.getGeometriesArrayRecursive().filter(function(m) {
                  const _ = m.getType();
                  return _ === "Point" || _ === "MultiPoint";
                }).length : y === "Point" || y === "MultiPoint";
              }
            })), this.writeStyles_) {
              let p = d, v = d;
              t.getGeometry() && (p = d.filter(function(y) {
                const m = y.getGeometryFunction()(t);
                if (m) {
                  const _ = m.getType();
                  return _ === "GeometryCollection" ? m.getGeometriesArrayRecursive().filter(function(I) {
                    const E = I.getType();
                    return E === "LineString" || E === "MultiLineString";
                  }).length : _ === "LineString" || _ === "MultiLineString";
                }
              }), v = d.filter(function(y) {
                const m = y.getGeometryFunction()(t);
                if (m) {
                  const _ = m.getType();
                  return _ === "GeometryCollection" ? m.getGeometriesArrayRecursive().filter(function(I) {
                    const E = I.getType();
                    return E === "Polygon" || E === "MultiPolygon";
                  }).length : _ === "Polygon" || _ === "MultiPolygon";
                }
              })), r.Style = { pointStyles: A, lineStyles: p, polyStyles: v };
            }
            if (A.length && r.name === void 0) {
              const p = A[0].getText();
              p && (r.name = p.getText());
            }
          }
        }
        const l = e[e.length - 1].node, u = Vdt[l.namespaceURI], h = vr(r, u);
        if (Zt(i, WS, hi, h, e, u), o.length > 0) {
          const g = vr(r, o);
          Zt(i, WS, jdt, [{ names: o, values: g }], e);
        }
        const c = e[0];
        let f = t.getGeometry();
        f && (f = cn(f, true, c)), Zt(i, WS, B3, [f], e);
      }
      const qdt = tt(Ft, ["extrude", "tessellate", "altitudeMode", "coordinates"]), Hdt = tt(Ft, { extrude: U(sg), tessellate: U(sg), altitudeMode: U(Xt), coordinates: U(pdt) });
      function ug(n, t, e) {
        const i = t.getFlatCoordinates(), r = { node: n };
        r.layout = t.getLayout(), r.stride = t.getStride();
        const a = t.getProperties();
        a.coordinates = i;
        const o = e[e.length - 1].node, s = qdt[o.namespaceURI], l = vr(a, s);
        Zt(r, Hdt, hi, l, e, s);
      }
      const Ydt = tt(Ft, ["color", "fill", "outline"]), L3 = tt(Ft, { outerBoundaryIs: U(D3), innerBoundaryIs: U(D3) }), Wdt = _n("innerBoundaryIs"), Xdt = _n("outerBoundaryIs");
      function P3(n, t, e) {
        const i = t.getLinearRings(), r = i.shift(), a = { node: n };
        Zt(a, L3, Wdt, i, e), Zt(a, L3, Xdt, [r], e);
      }
      const $dt = tt(Ft, { color: U(o_), fill: U(sg), outline: U(sg) });
      function Zdt(n, t, e) {
        const i = { node: n }, r = t.getFill(), a = t.getStroke(), o = { color: r ? r.getColor() : void 0, fill: r ? void 0 : false, outline: a ? void 0 : false }, s = e[e.length - 1].node, l = Ydt[s.namespaceURI], u = vr(o, l);
        Zt(i, $dt, hi, u, e, l);
      }
      function N3(n, t) {
        mr(n, Math.round(t * 1e6) / 1e6);
      }
      const Kdt = tt(Ft, ["IconStyle", "LabelStyle", "LineStyle", "PolyStyle"]), Jdt = tt(Ft, { IconStyle: U(Bdt), LabelStyle: U(Rdt), LineStyle: U(Ndt), PolyStyle: U(Zdt) });
      function tAt(n, t, e) {
        const i = { node: n }, r = {};
        if (t.pointStyles.length) {
          const l = t.pointStyles[0].getText();
          l && (r.LabelStyle = l);
          const u = t.pointStyles[0].getImage();
          u && typeof u.getSrc == "function" && (r.IconStyle = u);
        }
        if (t.lineStyles.length) {
          const l = t.lineStyles[0].getStroke();
          l && (r.LineStyle = l);
        }
        if (t.polyStyles.length) {
          const l = t.polyStyles[0].getStroke();
          l && !r.LineStyle && (r.LineStyle = l), r.PolyStyle = t.polyStyles[0];
        }
        const a = e[e.length - 1].node, o = Kdt[a.namespaceURI], s = vr(r, o);
        Zt(i, Jdt, hi, s, e, o);
      }
      function eAt(n, t) {
        n.setAttribute("x", String(t.x)), n.setAttribute("y", String(t.y)), n.setAttribute("xunits", t.xunits), n.setAttribute("yunits", t.yunits);
      }
      const XS = 65536 * 65536, F3 = 1 / XS, nAt = 12, k3 = typeof TextDecoder == "undefined" ? null : new TextDecoder("utf-8"), $S = 0, l_ = 1, _p = 2, u_ = 5;
      class iAt {
        constructor(t = new Uint8Array(16)) {
          this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        readFields(t, e, i = this.length) {
          for (; this.pos < i; ) {
            const r = this.readVarint(), a = r >> 3, o = this.pos;
            this.type = r & 7, t(a, e, this), this.pos === o && this.skip(r);
          }
          return e;
        }
        readMessage(t, e) {
          return this.readFields(t, e, this.readVarint() + this.pos);
        }
        readFixed32() {
          const t = this.dataView.getUint32(this.pos, true);
          return this.pos += 4, t;
        }
        readSFixed32() {
          const t = this.dataView.getInt32(this.pos, true);
          return this.pos += 4, t;
        }
        readFixed64() {
          const t = this.dataView.getUint32(this.pos, true) + this.dataView.getUint32(this.pos + 4, true) * XS;
          return this.pos += 8, t;
        }
        readSFixed64() {
          const t = this.dataView.getUint32(this.pos, true) + this.dataView.getInt32(this.pos + 4, true) * XS;
          return this.pos += 8, t;
        }
        readFloat() {
          const t = this.dataView.getFloat32(this.pos, true);
          return this.pos += 4, t;
        }
        readDouble() {
          const t = this.dataView.getFloat64(this.pos, true);
          return this.pos += 8, t;
        }
        readVarint(t) {
          const e = this.buf;
          let i, r;
          return r = e[this.pos++], i = r & 127, r < 128 || (r = e[this.pos++], i |= (r & 127) << 7, r < 128) || (r = e[this.pos++], i |= (r & 127) << 14, r < 128) || (r = e[this.pos++], i |= (r & 127) << 21, r < 128) ? i : (r = e[this.pos], i |= (r & 15) << 28, rAt(i, t, this));
        }
        readVarint64() {
          return this.readVarint(true);
        }
        readSVarint() {
          const t = this.readVarint();
          return t % 2 === 1 ? (t + 1) / -2 : t / 2;
        }
        readBoolean() {
          return !!this.readVarint();
        }
        readString() {
          const t = this.readVarint() + this.pos, e = this.pos;
          return this.pos = t, t - e >= nAt && k3 ? k3.decode(this.buf.subarray(e, t)) : vAt(this.buf, e, t);
        }
        readBytes() {
          const t = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, t);
          return this.pos = t, e;
        }
        readPackedVarint(t = [], e) {
          const i = this.readPackedEnd();
          for (; this.pos < i; ) t.push(this.readVarint(e));
          return t;
        }
        readPackedSVarint(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readSVarint());
          return t;
        }
        readPackedBoolean(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readBoolean());
          return t;
        }
        readPackedFloat(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readFloat());
          return t;
        }
        readPackedDouble(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readDouble());
          return t;
        }
        readPackedFixed32(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readFixed32());
          return t;
        }
        readPackedSFixed32(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readSFixed32());
          return t;
        }
        readPackedFixed64(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readFixed64());
          return t;
        }
        readPackedSFixed64(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readSFixed64());
          return t;
        }
        readPackedEnd() {
          return this.type === _p ? this.readVarint() + this.pos : this.pos + 1;
        }
        skip(t) {
          const e = t & 7;
          if (e === $S) for (; this.buf[this.pos++] > 127; ) ;
          else if (e === _p) this.pos = this.readVarint() + this.pos;
          else if (e === u_) this.pos += 4;
          else if (e === l_) this.pos += 8;
          else throw new Error(`Unimplemented type: ${e}`);
        }
        writeTag(t, e) {
          this.writeVarint(t << 3 | e);
        }
        realloc(t) {
          let e = this.length || 16;
          for (; e < this.pos + t; ) e *= 2;
          if (e !== this.length) {
            const i = new Uint8Array(e);
            i.set(this.buf), this.buf = i, this.dataView = new DataView(i.buffer), this.length = e;
          }
        }
        finish() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }
        writeFixed32(t) {
          this.realloc(4), this.dataView.setInt32(this.pos, t, true), this.pos += 4;
        }
        writeSFixed32(t) {
          this.realloc(4), this.dataView.setInt32(this.pos, t, true), this.pos += 4;
        }
        writeFixed64(t) {
          this.realloc(8), this.dataView.setInt32(this.pos, t & -1, true), this.dataView.setInt32(this.pos + 4, Math.floor(t * F3), true), this.pos += 8;
        }
        writeSFixed64(t) {
          this.realloc(8), this.dataView.setInt32(this.pos, t & -1, true), this.dataView.setInt32(this.pos + 4, Math.floor(t * F3), true), this.pos += 8;
        }
        writeVarint(t) {
          if (t = +t || 0, t > 268435455 || t < 0) {
            aAt(t, this);
            return;
          }
          this.realloc(4), this.buf[this.pos++] = t & 127 | (t > 127 ? 128 : 0), !(t <= 127) && (this.buf[this.pos++] = (t >>>= 7) & 127 | (t > 127 ? 128 : 0), !(t <= 127) && (this.buf[this.pos++] = (t >>>= 7) & 127 | (t > 127 ? 128 : 0), !(t <= 127) && (this.buf[this.pos++] = t >>> 7 & 127)));
        }
        writeSVarint(t) {
          this.writeVarint(t < 0 ? -t * 2 - 1 : t * 2);
        }
        writeBoolean(t) {
          this.writeVarint(+t);
        }
        writeString(t) {
          t = String(t), this.realloc(t.length * 4), this.pos++;
          const e = this.pos;
          this.pos = yAt(this.buf, t, this.pos);
          const i = this.pos - e;
          i >= 128 && O3(e, i, this), this.pos = e - 1, this.writeVarint(i), this.pos += i;
        }
        writeFloat(t) {
          this.realloc(4), this.dataView.setFloat32(this.pos, t, true), this.pos += 4;
        }
        writeDouble(t) {
          this.realloc(8), this.dataView.setFloat64(this.pos, t, true), this.pos += 8;
        }
        writeBytes(t) {
          const e = t.length;
          this.writeVarint(e), this.realloc(e);
          for (let i = 0; i < e; i++) this.buf[this.pos++] = t[i];
        }
        writeRawMessage(t, e) {
          this.pos++;
          const i = this.pos;
          t(e, this);
          const r = this.pos - i;
          r >= 128 && O3(i, r, this), this.pos = i - 1, this.writeVarint(r), this.pos += r;
        }
        writeMessage(t, e, i) {
          this.writeTag(t, _p), this.writeRawMessage(e, i);
        }
        writePackedVarint(t, e) {
          e.length && this.writeMessage(t, lAt, e);
        }
        writePackedSVarint(t, e) {
          e.length && this.writeMessage(t, uAt, e);
        }
        writePackedBoolean(t, e) {
          e.length && this.writeMessage(t, fAt, e);
        }
        writePackedFloat(t, e) {
          e.length && this.writeMessage(t, hAt, e);
        }
        writePackedDouble(t, e) {
          e.length && this.writeMessage(t, cAt, e);
        }
        writePackedFixed32(t, e) {
          e.length && this.writeMessage(t, gAt, e);
        }
        writePackedSFixed32(t, e) {
          e.length && this.writeMessage(t, dAt, e);
        }
        writePackedFixed64(t, e) {
          e.length && this.writeMessage(t, AAt, e);
        }
        writePackedSFixed64(t, e) {
          e.length && this.writeMessage(t, pAt, e);
        }
        writeBytesField(t, e) {
          this.writeTag(t, _p), this.writeBytes(e);
        }
        writeFixed32Field(t, e) {
          this.writeTag(t, u_), this.writeFixed32(e);
        }
        writeSFixed32Field(t, e) {
          this.writeTag(t, u_), this.writeSFixed32(e);
        }
        writeFixed64Field(t, e) {
          this.writeTag(t, l_), this.writeFixed64(e);
        }
        writeSFixed64Field(t, e) {
          this.writeTag(t, l_), this.writeSFixed64(e);
        }
        writeVarintField(t, e) {
          this.writeTag(t, $S), this.writeVarint(e);
        }
        writeSVarintField(t, e) {
          this.writeTag(t, $S), this.writeSVarint(e);
        }
        writeStringField(t, e) {
          this.writeTag(t, _p), this.writeString(e);
        }
        writeFloatField(t, e) {
          this.writeTag(t, u_), this.writeFloat(e);
        }
        writeDoubleField(t, e) {
          this.writeTag(t, l_), this.writeDouble(e);
        }
        writeBooleanField(t, e) {
          this.writeVarintField(t, +e);
        }
      }
      function rAt(n, t, e) {
        const i = e.buf;
        let r, a;
        if (a = i[e.pos++], r = (a & 112) >> 4, a < 128 || (a = i[e.pos++], r |= (a & 127) << 3, a < 128) || (a = i[e.pos++], r |= (a & 127) << 10, a < 128) || (a = i[e.pos++], r |= (a & 127) << 17, a < 128) || (a = i[e.pos++], r |= (a & 127) << 24, a < 128) || (a = i[e.pos++], r |= (a & 1) << 31, a < 128)) return hg(n, r, t);
        throw new Error("Expected varint not more than 10 bytes");
      }
      function hg(n, t, e) {
        return e ? t * 4294967296 + (n >>> 0) : (t >>> 0) * 4294967296 + (n >>> 0);
      }
      function aAt(n, t) {
        let e, i;
        if (n >= 0 ? (e = n % 4294967296 | 0, i = n / 4294967296 | 0) : (e = ~(-n % 4294967296), i = ~(-n / 4294967296), e ^ 4294967295 ? e = e + 1 | 0 : (e = 0, i = i + 1 | 0)), n >= 18446744073709552e3 || n < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
        t.realloc(10), oAt(e, i, t), sAt(i, t);
      }
      function oAt(n, t, e) {
        e.buf[e.pos++] = n & 127 | 128, n >>>= 7, e.buf[e.pos++] = n & 127 | 128, n >>>= 7, e.buf[e.pos++] = n & 127 | 128, n >>>= 7, e.buf[e.pos++] = n & 127 | 128, n >>>= 7, e.buf[e.pos] = n & 127;
      }
      function sAt(n, t) {
        const e = (n & 7) << 4;
        t.buf[t.pos++] |= e | ((n >>>= 3) ? 128 : 0), n && (t.buf[t.pos++] = n & 127 | ((n >>>= 7) ? 128 : 0), n && (t.buf[t.pos++] = n & 127 | ((n >>>= 7) ? 128 : 0), n && (t.buf[t.pos++] = n & 127 | ((n >>>= 7) ? 128 : 0), n && (t.buf[t.pos++] = n & 127 | ((n >>>= 7) ? 128 : 0), n && (t.buf[t.pos++] = n & 127)))));
      }
      function O3(n, t, e) {
        const i = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (Math.LN2 * 7));
        e.realloc(i);
        for (let r = e.pos - 1; r >= n; r--) e.buf[r + i] = e.buf[r];
      }
      function lAt(n, t) {
        for (let e = 0; e < n.length; e++) t.writeVarint(n[e]);
      }
      function uAt(n, t) {
        for (let e = 0; e < n.length; e++) t.writeSVarint(n[e]);
      }
      function hAt(n, t) {
        for (let e = 0; e < n.length; e++) t.writeFloat(n[e]);
      }
      function cAt(n, t) {
        for (let e = 0; e < n.length; e++) t.writeDouble(n[e]);
      }
      function fAt(n, t) {
        for (let e = 0; e < n.length; e++) t.writeBoolean(n[e]);
      }
      function gAt(n, t) {
        for (let e = 0; e < n.length; e++) t.writeFixed32(n[e]);
      }
      function dAt(n, t) {
        for (let e = 0; e < n.length; e++) t.writeSFixed32(n[e]);
      }
      function AAt(n, t) {
        for (let e = 0; e < n.length; e++) t.writeFixed64(n[e]);
      }
      function pAt(n, t) {
        for (let e = 0; e < n.length; e++) t.writeSFixed64(n[e]);
      }
      function vAt(n, t, e) {
        let i = "", r = t;
        for (; r < e; ) {
          const a = n[r];
          let o = null, s = a > 239 ? 4 : a > 223 ? 3 : a > 191 ? 2 : 1;
          if (r + s > e) break;
          let l, u, h;
          s === 1 ? a < 128 && (o = a) : s === 2 ? (l = n[r + 1], (l & 192) === 128 && (o = (a & 31) << 6 | l & 63, o <= 127 && (o = null))) : s === 3 ? (l = n[r + 1], u = n[r + 2], (l & 192) === 128 && (u & 192) === 128 && (o = (a & 15) << 12 | (l & 63) << 6 | u & 63, (o <= 2047 || o >= 55296 && o <= 57343) && (o = null))) : s === 4 && (l = n[r + 1], u = n[r + 2], h = n[r + 3], (l & 192) === 128 && (u & 192) === 128 && (h & 192) === 128 && (o = (a & 15) << 18 | (l & 63) << 12 | (u & 63) << 6 | h & 63, (o <= 65535 || o >= 1114112) && (o = null))), o === null ? (o = 65533, s = 1) : o > 65535 && (o -= 65536, i += String.fromCharCode(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), i += String.fromCharCode(o), r += s;
        }
        return i;
      }
      function yAt(n, t, e) {
        for (let i = 0, r, a; i < t.length; i++) {
          if (r = t.charCodeAt(i), r > 55295 && r < 57344) if (a) if (r < 56320) {
            n[e++] = 239, n[e++] = 191, n[e++] = 189, a = r;
            continue;
          } else r = a - 55296 << 10 | r - 56320 | 65536, a = null;
          else {
            r > 56319 || i + 1 === t.length ? (n[e++] = 239, n[e++] = 191, n[e++] = 189) : a = r;
            continue;
          }
          else a && (n[e++] = 239, n[e++] = 191, n[e++] = 189, a = null);
          r < 128 ? n[e++] = r : (r < 2048 ? n[e++] = r >> 6 | 192 : (r < 65536 ? n[e++] = r >> 12 | 224 : (n[e++] = r >> 18 | 240, n[e++] = r >> 12 & 63 | 128), n[e++] = r >> 6 & 63 | 128), n[e++] = r & 63 | 128);
        }
        return e;
      }
      class mAt extends gp {
        constructor(t) {
          super(), t = t || {}, this.dataProjection = new Oi({ code: "", units: "tile-pixels" }), this.featureClass = t.featureClass ? t.featureClass : Ti, this.geometryName_ = t.geometryName, this.layerName_ = t.layerName ? t.layerName : "layer", this.layers_ = t.layers ? t.layers : null, this.idProperty_ = t.idProperty, this.supportedMediaTypes = ["application/vnd.mapbox-vector-tile", "application/x-protobuf"];
        }
        readRawGeometry_(t, e, i, r) {
          t.pos = e.geometry;
          const a = t.readVarint() + t.pos;
          let o = 1, s = 0, l = 0, u = 0, h = 0, c = 0;
          for (; t.pos < a; ) {
            if (!s) {
              const f = t.readVarint();
              o = f & 7, s = f >> 3;
            }
            if (s--, o === 1 || o === 2) l += t.readSVarint(), u += t.readSVarint(), o === 1 && h > c && (r.push(h), c = h), i.push(l, u), h += 2;
            else if (o === 7) h > c && (i.push(i[c], i[c + 1]), h += 2);
            else throw new Error("Invalid command found in the PBF");
          }
          h > c && (r.push(h), c = h);
        }
        createFeature_(t, e, i) {
          const r = e.type;
          if (r === 0) return null;
          let a;
          const o = e.properties;
          let s;
          this.idProperty_ ? (s = o[this.idProperty_], delete o[this.idProperty_]) : s = e.id, o[this.layerName_] = e.layer.name;
          const l = [], u = [];
          this.readRawGeometry_(t, e, l, u);
          const h = wAt(r, u.length);
          if (this.featureClass === Ti) a = new this.featureClass(h, l, u, 2, o, s), a.transform(i.dataProjection);
          else {
            let c;
            if (h == "Polygon") {
              const d = ew(l, u);
              c = d.length > 1 ? new bi(l, "XY", d) : new Dn(l, "XY", u);
            } else c = h === "Point" ? new Ge(l, "XY") : h === "LineString" ? new Be(l, "XY") : h === "MultiPoint" ? new fr(l, "XY") : h === "MultiLineString" ? new ui(l, "XY", u) : null;
            const f = this.featureClass;
            a = new f(), this.geometryName_ && a.setGeometryName(this.geometryName_);
            const g = cn(c, false, i);
            a.setGeometry(g), s !== void 0 && a.setId(s), a.setProperties(o, true);
          }
          return a;
        }
        getType() {
          return "arraybuffer";
        }
        readFeatures(t, e) {
          const i = this.layers_;
          e = this.adaptOptions(e);
          const r = qt(e.dataProjection);
          r.setWorldExtent(e.extent), e.dataProjection = r;
          const a = new iAt(t), o = a.readFields(_At, {}), s = [];
          for (const l in o) {
            if (i && !i.includes(l)) continue;
            const u = o[l], h = u ? [0, 0, u.extent, u.extent] : null;
            r.setExtent(h);
            for (let c = 0, f = u.length; c < f; ++c) {
              const g = xAt(a, u, c), d = this.createFeature_(a, g, e);
              d !== null && s.push(d);
            }
          }
          return s;
        }
        readProjection(t) {
          return this.dataProjection;
        }
        setLayers(t) {
          this.layers_ = t;
        }
      }
      function _At(n, t, e) {
        if (n === 3) {
          const i = { keys: [], values: [], features: [] }, r = e.readVarint() + e.pos;
          e.readFields(EAt, i, r), i.length = i.features.length, i.length && (t[i.name] = i);
        }
      }
      function EAt(n, t, e) {
        if (n === 15) t.version = e.readVarint();
        else if (n === 1) t.name = e.readString();
        else if (n === 5) t.extent = e.readVarint();
        else if (n === 2) t.features.push(e.pos);
        else if (n === 3) t.keys.push(e.readString());
        else if (n === 4) {
          let i = null;
          const r = e.readVarint() + e.pos;
          for (; e.pos < r; ) n = e.readVarint() >> 3, i = n === 1 ? e.readString() : n === 2 ? e.readFloat() : n === 3 ? e.readDouble() : n === 4 ? e.readVarint64() : n === 5 ? e.readVarint() : n === 6 ? e.readSVarint() : n === 7 ? e.readBoolean() : null;
          t.values.push(i);
        }
      }
      function IAt(n, t, e) {
        if (n == 1) t.id = e.readVarint();
        else if (n == 2) {
          const i = e.readVarint() + e.pos;
          for (; e.pos < i; ) {
            const r = t.layer.keys[e.readVarint()], a = t.layer.values[e.readVarint()];
            t.properties[r] = a;
          }
        } else n == 3 ? t.type = e.readVarint() : n == 4 && (t.geometry = e.pos);
      }
      function xAt(n, t, e) {
        n.pos = t.features[e];
        const i = n.readVarint() + n.pos, r = { layer: t, type: 0, properties: {} };
        return n.readFields(IAt, r, i), r;
      }
      function wAt(n, t) {
        let e;
        return n === 1 ? e = t === 1 ? "Point" : "MultiPoint" : n === 2 ? e = t === 1 ? "LineString" : "MultiLineString" : n === 3 && (e = "Polygon"), e;
      }
      class ZS {
        read(t) {
          if (!t) return null;
          if (typeof t == "string") {
            const e = ua(t);
            return this.readFromDocument(e);
          }
          return la(t) ? this.readFromDocument(t) : this.readFromNode(t);
        }
        readFromDocument(t) {
          for (let e = t.firstChild; e; e = e.nextSibling) if (e.nodeType == Node.ELEMENT_NODE) return this.readFromNode(e);
          return null;
        }
        readFromNode(t) {
          zt();
        }
      }
      const CAt = "http://www.w3.org/1999/xlink";
      function cg(n) {
        return n.getAttributeNS(CAt, "href");
      }
      const _r = [null, "http://www.opengis.net/ows/1.1"], SAt = tt(_r, { ServiceIdentification: z($At), ServiceProvider: z(KAt), OperationsMetadata: z(WAt) });
      class Q3 extends ZS {
        constructor() {
          super();
        }
        readFromNode(t) {
          const e = at({}, SAt, t, []);
          return e || null;
        }
      }
      const bAt = tt(_r, { DeliveryPoint: z(ot), City: z(ot), AdministrativeArea: z(ot), PostalCode: z(ot), Country: z(ot), ElectronicMailAddress: z(ot) }), TAt = tt(_r, { Value: Ve(JAt) }), BAt = tt(_r, { AllowedValues: z(GAt) }), MAt = tt(_r, { Phone: z(XAt), Address: z(zAt) }), DAt = tt(_r, { HTTP: z(HAt) }), RAt = tt(_r, { Get: Ve(qAt), Post: void 0 }), LAt = tt(_r, { DCP: z(jAt) }), PAt = tt(_r, { Operation: YAt }), NAt = tt(_r, { Voice: z(ot), Facsimile: z(ot) }), FAt = tt(_r, { Constraint: Ve(UAt) }), kAt = tt(_r, { IndividualName: z(ot), PositionName: z(ot), ContactInfo: z(VAt) }), OAt = tt(_r, { Abstract: z(ot), AccessConstraints: z(ot), Fees: z(ot), Title: z(ot), ServiceTypeVersion: z(ot), ServiceType: z(ot) }), QAt = tt(_r, { ProviderName: z(ot), ProviderSite: z(cg), ServiceContact: z(ZAt) });
      function zAt(n, t) {
        return at({}, bAt, n, t);
      }
      function GAt(n, t) {
        return at({}, TAt, n, t);
      }
      function UAt(n, t) {
        const e = n.getAttribute("name");
        if (e) return at({ name: e }, BAt, n, t);
      }
      function VAt(n, t) {
        return at({}, MAt, n, t);
      }
      function jAt(n, t) {
        return at({}, DAt, n, t);
      }
      function qAt(n, t) {
        const e = cg(n);
        if (e) return at({ href: e }, FAt, n, t);
      }
      function HAt(n, t) {
        return at({}, RAt, n, t);
      }
      function YAt(n, t) {
        const e = n.getAttribute("name"), i = at({}, LAt, n, t);
        if (!i) return;
        const r = t[t.length - 1];
        r[e] = i;
      }
      function WAt(n, t) {
        return at({}, PAt, n, t);
      }
      function XAt(n, t) {
        return at({}, NAt, n, t);
      }
      function $At(n, t) {
        return at({}, OAt, n, t);
      }
      function ZAt(n, t) {
        return at({}, kAt, n, t);
      }
      function KAt(n, t) {
        return at({}, QAt, n, t);
      }
      function JAt(n, t) {
        return ot(n);
      }
      function z3(n, t, e, i, r, a) {
        r !== void 0 ? (r = r, a = a !== void 0 ? a : 0) : (r = [], a = 0);
        let o = t;
        for (; o < e; ) {
          const s = n[o++];
          r[a++] = n[o++], r[a++] = s;
          for (let l = 2; l < i; ++l) r[a++] = n[o++];
        }
        return r.length = a, r;
      }
      let tpt = class extends OS {
        constructor(t) {
          super(), t = t || {}, this.dataProjection = qt("EPSG:4326"), this.factor_ = t.factor ? t.factor : 1e5, this.geometryLayout_ = t.geometryLayout ? t.geometryLayout : "XY";
        }
        readFeatureFromText(t, e) {
          const i = this.readGeometryFromText(t, e);
          return new Ce(i);
        }
        readFeaturesFromText(t, e) {
          return [this.readFeatureFromText(t, e)];
        }
        readGeometryFromText(t, e) {
          const i = lA(this.geometryLayout_), r = npt(t, i, this.factor_);
          z3(r, 0, r.length, i, r);
          const a = ms(r, 0, r.length, i), o = new Be(a, this.geometryLayout_);
          return cn(o, false, this.adaptOptions(e));
        }
        writeFeatureText(t, e) {
          const i = t.getGeometry();
          if (i) return this.writeGeometryText(i, e);
          throw new Error("Expected `feature` to have a geometry");
        }
        writeFeaturesText(t, e) {
          return this.writeFeatureText(t[0], e);
        }
        writeGeometryText(t, e) {
          t = cn(t, true, this.adaptOptions(e));
          const i = t.getFlatCoordinates(), r = t.getStride();
          return z3(i, 0, i.length, r, i), ept(i, r, this.factor_);
        }
      };
      function ept(n, t, e) {
        e = e || 1e5;
        let i;
        const r = new Array(t);
        for (i = 0; i < t; ++i) r[i] = 0;
        for (let a = 0, o = n.length; a < o; ) for (i = 0; i < t; ++i, ++a) {
          const s = n[a], l = s - r[i];
          r[i] = s, n[a] = l;
        }
        return ipt(n, e);
      }
      function npt(n, t, e) {
        e = e || 1e5;
        let i;
        const r = new Array(t);
        for (i = 0; i < t; ++i) r[i] = 0;
        const a = rpt(n, e);
        for (let o = 0, s = a.length; o < s; ) for (i = 0; i < t; ++i, ++o) r[i] += a[o], a[o] = r[i];
        return a;
      }
      function ipt(n, t) {
        t = t || 1e5;
        for (let e = 0, i = n.length; e < i; ++e) n[e] = Math.round(n[e] * t);
        return apt(n);
      }
      function rpt(n, t) {
        t = t || 1e5;
        const e = opt(n);
        for (let i = 0, r = e.length; i < r; ++i) e[i] /= t;
        return e;
      }
      function apt(n) {
        for (let t = 0, e = n.length; t < e; ++t) {
          const i = n[t];
          n[t] = i < 0 ? ~(i << 1) : i << 1;
        }
        return spt(n);
      }
      function opt(n) {
        const t = lpt(n);
        for (let e = 0, i = t.length; e < i; ++e) {
          const r = t[e];
          t[e] = r & 1 ? ~(r >> 1) : r >> 1;
        }
        return t;
      }
      function spt(n) {
        let t = "";
        for (let e = 0, i = n.length; e < i; ++e) t += upt(n[e]);
        return t;
      }
      function lpt(n) {
        const t = [];
        let e = 0, i = 0;
        for (let r = 0, a = n.length; r < a; ++r) {
          const o = n.charCodeAt(r) - 63;
          e |= (o & 31) << i, o < 32 ? (t.push(e), e = 0, i = 0) : i += 5;
        }
        return t;
      }
      function upt(n) {
        let t, e = "";
        for (; n >= 32; ) t = (32 | n & 31) + 63, e += String.fromCharCode(t), n >>= 5;
        return t = n + 63, e += String.fromCharCode(t), e;
      }
      class hpt extends TS {
        constructor(t) {
          super(), t = t || {}, this.layerName_ = t.layerName, this.layers_ = t.layers ? t.layers : null, this.dataProjection = qt(t.dataProjection ? t.dataProjection : "EPSG:4326");
        }
        readFeaturesFromObject(t, e) {
          if (t.type == "Topology") {
            const i = t;
            let r, a = null, o = null;
            i.transform && (r = i.transform, a = r.scale, o = r.translate);
            const s = i.arcs;
            r && mpt(s, a, o);
            const l = [], u = i.objects, h = this.layerName_;
            let c;
            for (const f in u) this.layers_ && !this.layers_.includes(f) || (u[f].type === "GeometryCollection" ? (c = u[f], l.push.apply(l, ypt(c, s, a, o, h, f, e))) : (c = u[f], l.push(G3(c, s, a, o, h, f, e))));
            return l;
          }
          return [];
        }
        readProjectionFromObject(t) {
          return this.dataProjection;
        }
      }
      const cpt = { Point: fpt, LineString: dpt, Polygon: ppt, MultiPoint: gpt, MultiLineString: Apt, MultiPolygon: vpt };
      function h_(n, t) {
        const e = [];
        let i;
        for (let r = 0, a = n.length; r < a; ++r) if (i = n[r], r > 0 && e.pop(), i >= 0) {
          const o = t[i];
          for (let s = 0, l = o.length; s < l; ++s) e.push(o[s].slice(0));
        } else {
          const o = t[~i];
          for (let s = o.length - 1; s >= 0; --s) e.push(o[s].slice(0));
        }
        return e;
      }
      function fpt(n, t, e) {
        const i = n.coordinates;
        return t && e && KS(i, t, e), new Ge(i);
      }
      function gpt(n, t, e) {
        const i = n.coordinates;
        if (t && e) for (let r = 0, a = i.length; r < a; ++r) KS(i[r], t, e);
        return new fr(i);
      }
      function dpt(n, t) {
        const e = h_(n.arcs, t);
        return new Be(e);
      }
      function Apt(n, t) {
        const e = [];
        for (let i = 0, r = n.arcs.length; i < r; ++i) e[i] = h_(n.arcs[i], t);
        return new ui(e);
      }
      function ppt(n, t) {
        const e = [];
        for (let i = 0, r = n.arcs.length; i < r; ++i) e[i] = h_(n.arcs[i], t);
        return new Dn(e);
      }
      function vpt(n, t) {
        const e = [];
        for (let i = 0, r = n.arcs.length; i < r; ++i) {
          const a = n.arcs[i], o = [];
          for (let s = 0, l = a.length; s < l; ++s) o[s] = h_(a[s], t);
          e[i] = o;
        }
        return new bi(e);
      }
      function ypt(n, t, e, i, r, a, o) {
        const s = n.geometries, l = [];
        for (let u = 0, h = s.length; u < h; ++u) l[u] = G3(s[u], t, e, i, r, a, o);
        return l;
      }
      function G3(n, t, e, i, r, a, o) {
        let s = null;
        const l = n.type;
        if (l) {
          const c = cpt[l];
          l === "Point" || l === "MultiPoint" ? s = c(n, e, i) : s = c(n, t), s = cn(s, false, o);
        }
        const u = new Ce({ geometry: s });
        n.id !== void 0 && u.setId(n.id);
        let h = n.properties;
        return r && (h || (h = {}), h[r] = a), h && u.setProperties(h, true), u;
      }
      function mpt(n, t, e) {
        for (let i = 0, r = n.length; i < r; ++i) _pt(n[i], t, e);
      }
      function _pt(n, t, e) {
        let i = 0, r = 0;
        for (let a = 0, o = n.length; a < o; ++a) {
          const s = n[a];
          i += s[0], r += s[1], s[0] = i, s[1] = r, KS(s, t, e);
        }
      }
      function KS(n, t, e) {
        n[0] = n[0] * t[0] + e[0], n[1] = n[1] * t[1] + e[1];
      }
      class Pe extends lt {
        constructor(t) {
          t = t || {}, super(t), this.schemaLocation = t.schemaLocation ? t.schemaLocation : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
        }
        writeGeometryElement(t, e, i) {
          const r = i[i.length - 1];
          i[i.length - 1] = Object.assign({ multiCurve: true, multiSurface: true }, r), super.writeGeometryElement(t, e, i);
        }
      }
      Pe.prototype.namespace = "http://www.opengis.net/gml/3.2", Pe.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = { "http://www.opengis.net/gml/3.2": { pos: Vt(lt.prototype.readFlatPos), posList: Vt(lt.prototype.readFlatPosList), coordinates: Vt(ve.prototype.readFlatCoordinates) } }, Pe.prototype.FLAT_LINEAR_RINGS_PARSERS = { "http://www.opengis.net/gml/3.2": { interior: lt.prototype.interiorParser, exterior: lt.prototype.exteriorParser } }, Pe.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml/3.2": { Point: Vt(Pt.prototype.readPoint), MultiPoint: Vt(Pt.prototype.readMultiPoint), LineString: Vt(Pt.prototype.readLineString), MultiLineString: Vt(Pt.prototype.readMultiLineString), LinearRing: Vt(Pt.prototype.readLinearRing), Polygon: Vt(Pt.prototype.readPolygon), MultiPolygon: Vt(Pt.prototype.readMultiPolygon), Surface: Vt(Pe.prototype.readSurface), MultiSurface: Vt(lt.prototype.readMultiSurface), Curve: Vt(Pe.prototype.readCurve), MultiCurve: Vt(lt.prototype.readMultiCurve), Envelope: Vt(Pe.prototype.readEnvelope) } }, Pe.prototype.MULTICURVE_PARSERS = { "http://www.opengis.net/gml/3.2": { curveMember: Lt(lt.prototype.curveMemberParser), curveMembers: Lt(lt.prototype.curveMemberParser) } }, Pe.prototype.MULTISURFACE_PARSERS = { "http://www.opengis.net/gml/3.2": { surfaceMember: Lt(lt.prototype.surfaceMemberParser), surfaceMembers: Lt(lt.prototype.surfaceMemberParser) } }, Pe.prototype.CURVEMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { LineString: Lt(Pt.prototype.readLineString), Curve: Lt(lt.prototype.readCurve) } }, Pe.prototype.SURFACEMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { Polygon: Lt(Pt.prototype.readPolygon), Surface: Lt(lt.prototype.readSurface) } }, Pe.prototype.SURFACE_PARSERS = { "http://www.opengis.net/gml/3.2": { patches: Vt(lt.prototype.readPatch) } }, Pe.prototype.CURVE_PARSERS = { "http://www.opengis.net/gml/3.2": { segments: Vt(lt.prototype.readSegment) } }, Pe.prototype.ENVELOPE_PARSERS = { "http://www.opengis.net/gml/3.2": { lowerCorner: Lt(lt.prototype.readFlatPosList), upperCorner: Lt(lt.prototype.readFlatPosList) } }, Pe.prototype.PATCHES_PARSERS = { "http://www.opengis.net/gml/3.2": { PolygonPatch: Vt(lt.prototype.readPolygonPatch) } }, Pe.prototype.SEGMENTS_PARSERS = { "http://www.opengis.net/gml/3.2": { LineStringSegment: X0(lt.prototype.readLineStringSegment) } }, Pe.prototype.MULTIPOINT_PARSERS = { "http://www.opengis.net/gml/3.2": { pointMember: Lt(Pt.prototype.pointMemberParser), pointMembers: Lt(Pt.prototype.pointMemberParser) } }, Pe.prototype.MULTILINESTRING_PARSERS = { "http://www.opengis.net/gml/3.2": { lineStringMember: Lt(Pt.prototype.lineStringMemberParser), lineStringMembers: Lt(Pt.prototype.lineStringMemberParser) } }, Pe.prototype.MULTIPOLYGON_PARSERS = { "http://www.opengis.net/gml/3.2": { polygonMember: Lt(Pt.prototype.polygonMemberParser), polygonMembers: Lt(Pt.prototype.polygonMemberParser) } }, Pe.prototype.POINTMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { Point: Lt(Pt.prototype.readFlatCoordinatesFromNode) } }, Pe.prototype.LINESTRINGMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { LineString: Lt(Pt.prototype.readLineString) } }, Pe.prototype.POLYGONMEMBER_PARSERS = { "http://www.opengis.net/gml/3.2": { Polygon: Lt(Pt.prototype.readPolygon) } }, Pe.prototype.RING_PARSERS = { "http://www.opengis.net/gml/3.2": { LinearRing: Vt(Pt.prototype.readFlatLinearRing), Ring: Vt(Pe.prototype.readFlatCurveRing) } }, Pe.prototype.RING_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { exterior: U(lt.prototype.writeRing), interior: U(lt.prototype.writeRing) } }, Pe.prototype.ENVELOPE_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { lowerCorner: U(Xt), upperCorner: U(Xt) } }, Pe.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { surfaceMember: U(lt.prototype.writeSurfaceOrPolygonMember), polygonMember: U(lt.prototype.writeSurfaceOrPolygonMember) } }, Pe.prototype.POINTMEMBER_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { pointMember: U(lt.prototype.writePointMember) } }, Pe.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { lineStringMember: U(lt.prototype.writeLineStringOrCurveMember), curveMember: U(lt.prototype.writeLineStringOrCurveMember) } }, Pe.prototype.GEOMETRY_SERIALIZERS = { "http://www.opengis.net/gml/3.2": { Curve: U(lt.prototype.writeCurveOrLineString), MultiCurve: U(lt.prototype.writeMultiCurveOrLineString), Point: U(Pe.prototype.writePoint), MultiPoint: U(lt.prototype.writeMultiPoint), LineString: U(lt.prototype.writeCurveOrLineString), MultiLineString: U(lt.prototype.writeMultiCurveOrLineString), LinearRing: U(lt.prototype.writeLinearRing), Polygon: U(lt.prototype.writeSurfaceOrPolygon), MultiPolygon: U(lt.prototype.writeMultiSurfaceOrPolygon), Surface: U(lt.prototype.writeSurfaceOrPolygon), MultiSurface: U(lt.prototype.writeMultiSurfaceOrPolygon), Envelope: U(lt.prototype.writeEnvelope) } };
      class U3 {
        constructor(t) {
          this.tagName_ = t;
        }
        getTagName() {
          return this.tagName_;
        }
      }
      class Ept extends U3 {
        constructor(t, e) {
          super(t), this.conditions = e, ue(this.conditions.length >= 2, "At least 2 conditions are required");
        }
      }
      class Ipt extends Ept {
        constructor(t) {
          super("And", Array.prototype.slice.call(arguments));
        }
      }
      class xpt extends U3 {
        constructor(t, e, i) {
          if (super("BBOX"), this.geometryName = t, this.extent = e, e.length !== 4) throw new Error("Expected an extent with four values ([minX, minY, maxX, maxY])");
          this.srsName = i;
        }
      }
      function wpt(n) {
        const t = [null].concat(Array.prototype.slice.call(arguments));
        return new (Function.prototype.bind.apply(Ipt, t))();
      }
      function Cpt(n, t, e) {
        return new xpt(n, t, e);
      }
      const V3 = { "http://www.opengis.net/gml": { boundedBy: z(Pt.prototype.readExtentElement, "bounds") }, "http://www.opengis.net/wfs/2.0": { member: Lt(Pt.prototype.readFeaturesInternal) } }, Spt = { "http://www.opengis.net/wfs": { totalInserted: z(Cn), totalUpdated: z(Cn), totalDeleted: z(Cn) }, "http://www.opengis.net/wfs/2.0": { totalInserted: z(Cn), totalUpdated: z(Cn), totalDeleted: z(Cn) } }, bpt = { "http://www.opengis.net/wfs": { TransactionSummary: z(W3, "transactionSummary"), InsertResults: z($3, "insertIds") }, "http://www.opengis.net/wfs/2.0": { TransactionSummary: z(W3, "transactionSummary"), InsertResults: z($3, "insertIds") } }, Tpt = { "http://www.opengis.net/wfs": { PropertyName: U(Xt) }, "http://www.opengis.net/wfs/2.0": { PropertyName: U(Xt) } }, j3 = { "http://www.opengis.net/wfs": { Insert: U(Z3), Update: U(tz), Delete: U(J3), Property: U(ez), Native: U(nz) }, "http://www.opengis.net/wfs/2.0": { Insert: U(Z3), Update: U(tz), Delete: U(J3), Property: U(ez), Native: U(nz) } }, q3 = "feature", JS = "http://www.w3.org/2000/xmlns/", tb = { "2.0.0": "http://www.opengis.net/ogc/1.1", "1.1.0": "http://www.opengis.net/ogc", "1.0.0": "http://www.opengis.net/ogc" }, eb = { "2.0.0": "http://www.opengis.net/wfs/2.0", "1.1.0": "http://www.opengis.net/wfs", "1.0.0": "http://www.opengis.net/wfs" }, nb = { "2.0.0": "http://www.opengis.net/fes/2.0", "1.1.0": "http://www.opengis.net/fes", "1.0.0": "http://www.opengis.net/fes" }, H3 = { "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd", "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd", "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd" }, ib = { "2.0.0": Pe, "1.1.0": lt, "1.0.0": ve }, Bpt = "1.1.0";
      class Y3 extends Ap {
        constructor(t) {
          super(), t = t || {}, this.version_ = t.version ? t.version : Bpt, this.featureType_ = t.featureType, this.featureNS_ = t.featureNS, this.gmlFormat_ = t.gmlFormat ? t.gmlFormat : new ib[this.version_](), this.schemaLocation_ = t.schemaLocation ? t.schemaLocation : H3[this.version_];
        }
        getFeatureType() {
          return this.featureType_;
        }
        setFeatureType(t) {
          this.featureType_ = t;
        }
        readFeaturesFromNode(t, e) {
          const i = { node: t };
          Object.assign(i, { featureType: this.featureType_, featureNS: this.featureNS_ }), Object.assign(i, this.getReadOptions(t, e || {}));
          const r = [i];
          let a;
          this.version_ === "2.0.0" ? a = V3 : a = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
          let o = at([], a, t, r, this.gmlFormat_);
          return o || (o = []), o;
        }
        readTransactionResponse(t) {
          if (t) {
            if (typeof t == "string") {
              const e = ua(t);
              return this.readTransactionResponseFromDocument(e);
            }
            return la(t) ? this.readTransactionResponseFromDocument(t) : this.readTransactionResponseFromNode(t);
          }
        }
        readFeatureCollectionMetadata(t) {
          if (t) {
            if (typeof t == "string") {
              const e = ua(t);
              return this.readFeatureCollectionMetadataFromDocument(e);
            }
            return la(t) ? this.readFeatureCollectionMetadataFromDocument(t) : this.readFeatureCollectionMetadataFromNode(t);
          }
        }
        readFeatureCollectionMetadataFromDocument(t) {
          for (let e = t.firstChild; e; e = e.nextSibling) if (e.nodeType == Node.ELEMENT_NODE) return this.readFeatureCollectionMetadataFromNode(e);
        }
        readFeatureCollectionMetadataFromNode(t) {
          const e = {}, i = Ps(t.getAttribute("numberOfFeatures"));
          return e.numberOfFeatures = i, at(e, V3, t, [], this.gmlFormat_);
        }
        readTransactionResponseFromDocument(t) {
          for (let e = t.firstChild; e; e = e.nextSibling) if (e.nodeType == Node.ELEMENT_NODE) return this.readTransactionResponseFromNode(e);
        }
        readTransactionResponseFromNode(t) {
          return at({}, bpt, t, []);
        }
        writeGetFeature(t) {
          const e = ee(eb[this.version_], "GetFeature");
          e.setAttribute("service", "WFS"), e.setAttribute("version", this.version_), t.handle && e.setAttribute("handle", t.handle), t.outputFormat && e.setAttribute("outputFormat", t.outputFormat), t.maxFeatures !== void 0 && e.setAttribute("maxFeatures", String(t.maxFeatures)), t.resultType && e.setAttribute("resultType", t.resultType), t.startIndex !== void 0 && e.setAttribute("startIndex", String(t.startIndex)), t.count !== void 0 && e.setAttribute("count", String(t.count)), t.viewParams !== void 0 && e.setAttribute("viewParams", t.viewParams), e.setAttributeNS(sh, "xsi:schemaLocation", this.schemaLocation_);
          const i = { node: e };
          if (Object.assign(i, { version: this.version_, srsName: t.srsName, featureNS: t.featureNS ? t.featureNS : this.featureNS_, featurePrefix: t.featurePrefix, propertyNames: t.propertyNames ? t.propertyNames : [] }), ue(Array.isArray(t.featureTypes), "`options.featureTypes` must be an Array"), typeof t.featureTypes[0] == "string") {
            let r = t.filter;
            t.bbox && (ue(t.geometryName, "`options.geometryName` must also be provided when `options.bbox` is set"), r = this.combineBboxAndFilter(t.geometryName, t.bbox, t.srsName, r)), Object.assign(i, { geometryName: t.geometryName, filter: r }), fz(e, t.featureTypes, [i]);
          } else t.featureTypes.forEach((r) => {
            const a = this.combineBboxAndFilter(r.geometryName, r.bbox, t.srsName, t.filter);
            Object.assign(i, { geometryName: r.geometryName, filter: a }), fz(e, [r.name], [i]);
          });
          return e;
        }
        combineBboxAndFilter(t, e, i, r) {
          const a = Cpt(t, e, i);
          return r ? wpt(r, a) : a;
        }
        writeTransaction(t, e, i, r) {
          const a = [], o = r.version ? r.version : this.version_, s = ee(eb[o], "Transaction");
          s.setAttribute("service", "WFS"), s.setAttribute("version", o);
          let l;
          r && (l = r.gmlOptions ? r.gmlOptions : {}, r.handle && s.setAttribute("handle", r.handle)), s.setAttributeNS(sh, "xsi:schemaLocation", H3[o]);
          const u = Mpt(s, l, o, r);
          return t && c_("Insert", t, a, u), e && c_("Update", e, a, u), i && c_("Delete", i, a, u), r.nativeElements && c_("Native", r.nativeElements, a, u), s;
        }
        readProjectionFromDocument(t) {
          for (let e = t.firstChild; e; e = e.nextSibling) if (e.nodeType == Node.ELEMENT_NODE) return this.readProjectionFromNode(e);
          return null;
        }
        readProjectionFromNode(t) {
          if (t.firstElementChild && t.firstElementChild.firstElementChild) {
            t = t.firstElementChild.firstElementChild;
            for (let e = t.firstElementChild; e; e = e.nextElementSibling) if (!(e.childNodes.length === 0 || e.childNodes.length === 1 && e.firstChild.nodeType === 3)) {
              const i = [{}];
              return this.gmlFormat_.readGeometryElement(e, i), qt(i.pop().srsName);
            }
          }
          return null;
        }
      }
      function Mpt(n, t, e, i) {
        const r = i.featurePrefix ? i.featurePrefix : q3;
        let a;
        return e === "1.0.0" ? a = 2 : e === "1.1.0" ? a = 3 : e === "2.0.0" && (a = 3.2), Object.assign({ node: n }, { version: e, featureNS: i.featureNS, featureType: i.featureType, featurePrefix: r, gmlVersion: a, hasZ: i.hasZ, srsName: i.srsName }, t);
      }
      function c_(n, t, e, i) {
        Zt(i, j3, _n(n), t, e);
      }
      function W3(n, t) {
        return at({}, Spt, n, t);
      }
      const Dpt = { "http://www.opengis.net/ogc": { FeatureId: Lt(function(n, t) {
        return n.getAttribute("fid");
      }) }, "http://www.opengis.net/ogc/1.1": { FeatureId: Lt(function(n, t) {
        return n.getAttribute("fid");
      }) } };
      function X3(n, t) {
        yr(Dpt, n, t);
      }
      const Rpt = { "http://www.opengis.net/wfs": { Feature: X3 }, "http://www.opengis.net/wfs/2.0": { Feature: X3 } };
      function $3(n, t) {
        return at([], Rpt, n, t);
      }
      function Z3(n, t, e) {
        const i = e[e.length - 1], r = i.featureType, a = i.featureNS, o = i.gmlVersion, s = ee(a, r);
        n.appendChild(s), o === 2 ? ve.prototype.writeFeatureElement(s, t, e) : o === 3 ? lt.prototype.writeFeatureElement(s, t, e) : Pe.prototype.writeFeatureElement(s, t, e);
      }
      function K3(n, t, e) {
        const r = e[e.length - 1].version, a = tb[r], o = ee(a, "Filter"), s = ee(a, "FeatureId");
        o.appendChild(s), s.setAttribute("fid", t), n.appendChild(o);
      }
      function rb(n, t) {
        n = n || q3;
        const e = n + ":";
        return t.startsWith(e) ? t : e + t;
      }
      function J3(n, t, e) {
        const i = e[e.length - 1];
        ue(t.getId() !== void 0, "Features must have an id set");
        const r = i.featureType, a = i.featurePrefix, o = i.featureNS, s = rb(a, r);
        n.setAttribute("typeName", s), n.setAttributeNS(JS, "xmlns:" + a, o);
        const l = t.getId();
        l !== void 0 && K3(n, l, e);
      }
      function tz(n, t, e) {
        const i = e[e.length - 1];
        ue(t.getId() !== void 0, "Features must have an id set");
        const r = i.version, a = i.featureType, o = i.featurePrefix, s = i.featureNS, l = rb(o, a), u = t.getGeometryName();
        n.setAttribute("typeName", l), n.setAttributeNS(JS, "xmlns:" + o, s);
        const h = t.getId();
        if (h !== void 0) {
          const c = t.getKeys(), f = [];
          for (let g = 0, d = c.length; g < d; g++) {
            const A = t.get(c[g]);
            if (A !== void 0) {
              let p = c[g];
              A && typeof A.getSimplifiedGeometry == "function" && (p = u), f.push({ name: p, value: A });
            }
          }
          Zt({ version: r, gmlVersion: i.gmlVersion, node: n, hasZ: i.hasZ, srsName: i.srsName }, j3, _n("Property"), f, e), K3(n, h, e);
        }
      }
      function ez(n, t, e) {
        const i = e[e.length - 1], r = i.version, a = eb[r], s = ee(a, r === "2.0.0" ? "ValueReference" : "Name"), l = i.gmlVersion;
        if (n.appendChild(s), Xt(s, t.name), t.value !== void 0 && t.value !== null) {
          const u = ee(a, "Value");
          n.appendChild(u), t.value && typeof t.value.getSimplifiedGeometry == "function" ? l === 2 ? ve.prototype.writeGeometryElement(u, t.value, e) : l === 3 ? lt.prototype.writeGeometryElement(u, t.value, e) : Pe.prototype.writeGeometryElement(u, t.value, e) : Xt(u, t.value);
        }
      }
      function nz(n, t, e) {
        t.vendorId && n.setAttribute("vendorId", t.vendorId), t.safeToIgnore !== void 0 && n.setAttribute("safeToIgnore", String(t.safeToIgnore)), t.value !== void 0 && Xt(n, t.value);
      }
      const f_ = { "http://www.opengis.net/wfs": { Query: U(iz) }, "http://www.opengis.net/wfs/2.0": { Query: U(iz) }, "http://www.opengis.net/ogc": { During: U(oz), And: U(g_), Or: U(g_), Not: U(sz), BBOX: U(rz), Contains: U(Vl), Intersects: U(Vl), Within: U(Vl), DWithin: U(az), PropertyIsEqualTo: U(ca), PropertyIsNotEqualTo: U(ca), PropertyIsLessThan: U(ca), PropertyIsLessThanOrEqualTo: U(ca), PropertyIsGreaterThan: U(ca), PropertyIsGreaterThanOrEqualTo: U(ca), PropertyIsNull: U(lz), PropertyIsBetween: U(uz), PropertyIsLike: U(hz) }, "http://www.opengis.net/fes/2.0": { During: U(oz), And: U(g_), Or: U(g_), Not: U(sz), BBOX: U(rz), Contains: U(Vl), Disjoint: U(Vl), Intersects: U(Vl), ResourceId: U(Ppt), Within: U(Vl), DWithin: U(az), PropertyIsEqualTo: U(ca), PropertyIsNotEqualTo: U(ca), PropertyIsLessThan: U(ca), PropertyIsLessThanOrEqualTo: U(ca), PropertyIsGreaterThan: U(ca), PropertyIsGreaterThanOrEqualTo: U(ca), PropertyIsNull: U(lz), PropertyIsBetween: U(uz), PropertyIsLike: U(hz) } };
      function iz(n, t, e) {
        const i = e[e.length - 1], r = i.version, a = i.featurePrefix, o = i.featureNS, s = i.propertyNames, l = i.srsName;
        let u;
        a ? u = rb(a, t) : u = t;
        let h;
        r === "2.0.0" ? h = "typeNames" : h = "typeName", n.setAttribute(h, u), l && n.setAttribute("srsName", l), o && n.setAttributeNS(JS, "xmlns:" + a, o);
        const c = Object.assign({}, i);
        c.node = n, Zt(c, Tpt, _n("PropertyName"), s, e);
        const f = i.filter;
        if (f) {
          const g = ee(p_(r), "Filter");
          n.appendChild(g), Lpt(g, f, e);
        }
      }
      function Lpt(n, t, e) {
        const i = e[e.length - 1], r = { node: n };
        Object.assign(r, { context: i }), Zt(r, f_, _n(t.getTagName()), [t], e);
      }
      function rz(n, t, e) {
        const i = e[e.length - 1], a = i.context.version;
        i.srsName = t.srsName;
        const o = ib[a];
        fg(a, n, t.geometryName), o.prototype.writeGeometryElement(n, t.extent, e);
      }
      function Ppt(n, t, e) {
        n.setAttribute("rid", t.rid);
      }
      function Vl(n, t, e) {
        const i = e[e.length - 1], a = i.context.version;
        i.srsName = t.srsName;
        const o = ib[a];
        fg(a, n, t.geometryName), o.prototype.writeGeometryElement(n, t.geometry, e);
      }
      function az(n, t, e) {
        const a = e[e.length - 1].context.version;
        Vl(n, t, e);
        const o = ee(p_(a), "Distance");
        Xt(o, t.distance.toString()), a === "2.0.0" ? o.setAttribute("uom", t.unit) : o.setAttribute("units", t.unit), n.appendChild(o);
      }
      function oz(n, t, e) {
        const a = e[e.length - 1].context.version;
        d_(nb[a], "ValueReference", n, t.propertyName);
        const o = ee(Ls, "TimePeriod");
        n.appendChild(o);
        const s = ee(Ls, "begin");
        o.appendChild(s), cz(s, t.begin);
        const l = ee(Ls, "end");
        o.appendChild(l), cz(l, t.end);
      }
      function g_(n, t, e) {
        const r = e[e.length - 1].context, a = { node: n };
        Object.assign(a, { context: r });
        const o = t.conditions;
        for (let s = 0, l = o.length; s < l; ++s) {
          const u = o[s];
          Zt(a, f_, _n(u.getTagName()), [u], e);
        }
      }
      function sz(n, t, e) {
        const r = e[e.length - 1].context, a = { node: n };
        Object.assign(a, { context: r });
        const o = t.condition;
        Zt(a, f_, _n(o.getTagName()), [o], e);
      }
      function ca(n, t, e) {
        const a = e[e.length - 1].context.version;
        t.matchCase !== void 0 && n.setAttribute("matchCase", t.matchCase.toString()), fg(a, n, t.propertyName), A_(a, n, "" + t.expression);
      }
      function lz(n, t, e) {
        const a = e[e.length - 1].context.version;
        fg(a, n, t.propertyName);
      }
      function uz(n, t, e) {
        const a = e[e.length - 1].context.version, o = p_(a);
        fg(a, n, t.propertyName);
        const s = ee(o, "LowerBoundary");
        n.appendChild(s), A_(a, s, "" + t.lowerBoundary);
        const l = ee(o, "UpperBoundary");
        n.appendChild(l), A_(a, l, "" + t.upperBoundary);
      }
      function hz(n, t, e) {
        const a = e[e.length - 1].context.version;
        n.setAttribute("wildCard", t.wildCard), n.setAttribute("singleChar", t.singleChar), n.setAttribute("escapeChar", t.escapeChar), t.matchCase !== void 0 && n.setAttribute("matchCase", t.matchCase.toString()), fg(a, n, t.propertyName), A_(a, n, "" + t.pattern);
      }
      function d_(n, t, e, i) {
        const r = ee(n, t);
        Xt(r, i), e.appendChild(r);
      }
      function A_(n, t, e) {
        d_(p_(n), "Literal", t, e);
      }
      function fg(n, t, e) {
        n === "2.0.0" ? d_(nb[n], "ValueReference", t, e) : d_(tb[n], "PropertyName", t, e);
      }
      function cz(n, t) {
        const e = ee(Ls, "TimeInstant");
        n.appendChild(e);
        const i = ee(Ls, "timePosition");
        e.appendChild(i), Xt(i, t);
      }
      function fz(n, t, e) {
        const i = e[e.length - 1], r = Object.assign({}, i);
        r.node = n, Zt(r, f_, _n("Query"), t, e);
      }
      function p_(n) {
        let t;
        return n === "2.0.0" ? t = nb[n] : t = tb[n], t;
      }
      const Xe = { POINT: 1, LINE_STRING: 2, POLYGON: 3, MULTI_POINT: 4, MULTI_LINE_STRING: 5, MULTI_POLYGON: 6, GEOMETRY_COLLECTION: 7, POLYHEDRAL_SURFACE: 15, TIN: 16, TRIANGLE: 17 };
      class gz {
        constructor(t) {
          this.view_ = t, this.pos_ = 0, this.initialized_ = false, this.isLittleEndian_ = false, this.hasZ_ = false, this.hasM_ = false, this.srid_ = null, this.layout_ = "XY";
        }
        readUint8() {
          return this.view_.getUint8(this.pos_++);
        }
        readUint32(t) {
          return this.view_.getUint32((this.pos_ += 4) - 4, t !== void 0 ? t : this.isLittleEndian_);
        }
        readDouble(t) {
          return this.view_.getFloat64((this.pos_ += 8) - 8, t !== void 0 ? t : this.isLittleEndian_);
        }
        readPoint() {
          const t = [];
          return t.push(this.readDouble()), t.push(this.readDouble()), this.hasZ_ && t.push(this.readDouble()), this.hasM_ && t.push(this.readDouble()), t;
        }
        readLineString() {
          const t = this.readUint32(), e = [];
          for (let i = 0; i < t; i++) e.push(this.readPoint());
          return e;
        }
        readPolygon() {
          const t = this.readUint32(), e = [];
          for (let i = 0; i < t; i++) e.push(this.readLineString());
          return e;
        }
        readWkbHeader(t) {
          const i = this.readUint8() > 0, r = this.readUint32(i), a = Math.floor((r & 268435455) / 1e3), o = !!(r & 2147483648) || a === 1 || a === 3, s = !!(r & 1073741824) || a === 2 || a === 3, l = !!(r & 536870912), u = (r & 268435455) % 1e3, h = ["XY", o ? "Z" : "", s ? "M" : ""].join(""), c = l ? this.readUint32(i) : null;
          if (t !== void 0 && t !== u) throw new Error("Unexpected WKB geometry type " + u);
          if (this.initialized_) {
            if (this.isLittleEndian_ !== i) throw new Error("Inconsistent endian");
            if (this.layout_ !== h) throw new Error("Inconsistent geometry layout");
            if (c && this.srid_ !== c) throw new Error("Inconsistent coordinate system (SRID)");
          } else this.isLittleEndian_ = i, this.hasZ_ = o, this.hasM_ = s, this.layout_ = h, this.srid_ = c, this.initialized_ = true;
          return u;
        }
        readWkbPayload(t) {
          switch (t) {
            case Xe.POINT:
              return this.readPoint();
            case Xe.LINE_STRING:
              return this.readLineString();
            case Xe.POLYGON:
            case Xe.TRIANGLE:
              return this.readPolygon();
            case Xe.MULTI_POINT:
              return this.readMultiPoint();
            case Xe.MULTI_LINE_STRING:
              return this.readMultiLineString();
            case Xe.MULTI_POLYGON:
            case Xe.POLYHEDRAL_SURFACE:
            case Xe.TIN:
              return this.readMultiPolygon();
            case Xe.GEOMETRY_COLLECTION:
              return this.readGeometryCollection();
            default:
              throw new Error("Unsupported WKB geometry type " + t + " is found");
          }
        }
        readWkbBlock(t) {
          return this.readWkbPayload(this.readWkbHeader(t));
        }
        readWkbCollection(t, e) {
          const i = this.readUint32(), r = [];
          for (let a = 0; a < i; a++) {
            const o = t.call(this, e);
            o && r.push(o);
          }
          return r;
        }
        readMultiPoint() {
          return this.readWkbCollection(this.readWkbBlock, Xe.POINT);
        }
        readMultiLineString() {
          return this.readWkbCollection(this.readWkbBlock, Xe.LINE_STRING);
        }
        readMultiPolygon() {
          return this.readWkbCollection(this.readWkbBlock, Xe.POLYGON);
        }
        readGeometryCollection() {
          return this.readWkbCollection(this.readGeometry);
        }
        readGeometry() {
          const t = this.readWkbHeader(), e = this.readWkbPayload(t);
          switch (t) {
            case Xe.POINT:
              return new Ge(e, this.layout_);
            case Xe.LINE_STRING:
              return new Be(e, this.layout_);
            case Xe.POLYGON:
            case Xe.TRIANGLE:
              return new Dn(e, this.layout_);
            case Xe.MULTI_POINT:
              return new fr(e, this.layout_);
            case Xe.MULTI_LINE_STRING:
              return new ui(e, this.layout_);
            case Xe.MULTI_POLYGON:
            case Xe.POLYHEDRAL_SURFACE:
            case Xe.TIN:
              return new bi(e, this.layout_);
            case Xe.GEOMETRY_COLLECTION:
              return new wn(e);
            default:
              return null;
          }
        }
        getSrid() {
          return this.srid_;
        }
      }
      class Npt {
        constructor(t) {
          t = t || {}, this.layout_ = t.layout, this.isLittleEndian_ = t.littleEndian !== false, this.isEWKB_ = t.ewkb !== false, this.writeQueue_ = [], this.nodata_ = Object.assign({ X: 0, Y: 0, Z: 0, M: 0 }, t.nodata);
        }
        writeUint8(t) {
          this.writeQueue_.push([1, t]);
        }
        writeUint32(t) {
          this.writeQueue_.push([4, t]);
        }
        writeDouble(t) {
          this.writeQueue_.push([8, t]);
        }
        writePoint(t, e) {
          const i = Object.assign.apply(null, e.split("").map((r, a) => ({ [r]: t[a] })));
          for (const r of this.layout_) this.writeDouble(r in i ? i[r] : this.nodata_[r]);
        }
        writeLineString(t, e) {
          this.writeUint32(t.length);
          for (let i = 0; i < t.length; i++) this.writePoint(t[i], e);
        }
        writePolygon(t, e) {
          this.writeUint32(t.length);
          for (let i = 0; i < t.length; i++) this.writeLineString(t[i], e);
        }
        writeWkbHeader(t, e) {
          t %= 1e3, this.layout_.includes("Z") && (t += this.isEWKB_ ? 2147483648 : 1e3), this.layout_.includes("M") && (t += this.isEWKB_ ? 1073741824 : 2e3), this.isEWKB_ && Number.isInteger(e) && (t |= 536870912), this.writeUint8(this.isLittleEndian_ ? 1 : 0), this.writeUint32(t), this.isEWKB_ && Number.isInteger(e) && this.writeUint32(e);
        }
        writeMultiPoint(t, e) {
          this.writeUint32(t.length);
          for (let i = 0; i < t.length; i++) this.writeWkbHeader(1), this.writePoint(t[i], e);
        }
        writeMultiLineString(t, e) {
          this.writeUint32(t.length);
          for (let i = 0; i < t.length; i++) this.writeWkbHeader(2), this.writeLineString(t[i], e);
        }
        writeMultiPolygon(t, e) {
          this.writeUint32(t.length);
          for (let i = 0; i < t.length; i++) this.writeWkbHeader(3), this.writePolygon(t[i], e);
        }
        writeGeometryCollection(t) {
          this.writeUint32(t.length);
          for (let e = 0; e < t.length; e++) this.writeGeometry(t[e]);
        }
        findMinimumLayout(t, e = "XYZM") {
          const i = (r, a) => r === a ? r : r === "XYZM" ? a : a === "XYZM" ? r : "XY";
          if (t instanceof Oa) return i(t.getLayout(), e);
          if (t instanceof wn) {
            const r = t.getGeometriesArray();
            for (let a = 0; a < r.length && e !== "XY"; a++) e = this.findMinimumLayout(r[a], e);
          }
          return e;
        }
        writeGeometry(t, e) {
          const i = { Point: Xe.POINT, LineString: Xe.LINE_STRING, Polygon: Xe.POLYGON, MultiPoint: Xe.MULTI_POINT, MultiLineString: Xe.MULTI_LINE_STRING, MultiPolygon: Xe.MULTI_POLYGON, GeometryCollection: Xe.GEOMETRY_COLLECTION }, r = t.getType(), a = i[r];
          if (!a) throw new Error("GeometryType " + r + " is not supported");
          this.layout_ || (this.layout_ = this.findMinimumLayout(t)), this.writeWkbHeader(a, e), t instanceof Oa ? { Point: this.writePoint, LineString: this.writeLineString, Polygon: this.writePolygon, MultiPoint: this.writeMultiPoint, MultiLineString: this.writeMultiLineString, MultiPolygon: this.writeMultiPolygon }[r].call(this, t.getCoordinates(), t.getLayout()) : t instanceof wn && this.writeGeometryCollection(t.getGeometriesArray());
        }
        getBuffer() {
          const t = this.writeQueue_.reduce((a, o) => a + o[0], 0), e = new ArrayBuffer(t), i = new DataView(e);
          let r = 0;
          return this.writeQueue_.forEach((a) => {
            switch (a[0]) {
              case 1:
                i.setUint8(r, a[1]);
                break;
              case 4:
                i.setUint32(r, a[1], this.isLittleEndian_);
                break;
              case 8:
                i.setFloat64(r, a[1], this.isLittleEndian_);
                break;
            }
            r += a[0];
          }), e;
        }
      }
      class Fpt extends gp {
        constructor(t) {
          super(), t = t || {}, this.splitCollection = !!t.splitCollection, this.viewCache_ = null, this.hex_ = t.hex !== false, this.littleEndian_ = t.littleEndian !== false, this.ewkb_ = t.ewkb !== false, this.layout_ = t.geometryLayout, this.nodataZ_ = t.nodataZ || 0, this.nodataM_ = t.nodataM || 0, this.srid_ = t.srid;
        }
        getType() {
          return this.hex_ ? "text" : "arraybuffer";
        }
        readFeature(t, e) {
          return new Ce({ geometry: this.readGeometry(t, e) });
        }
        readFeatures(t, e) {
          let i = [];
          const r = this.readGeometry(t, e);
          return this.splitCollection && r instanceof wn ? i = r.getGeometriesArray() : i = [r], i.map((a) => new Ce({ geometry: a }));
        }
        readGeometry(t, e) {
          const i = dz(t);
          if (!i) return null;
          const a = new gz(i).readGeometry();
          return this.viewCache_ = i, e = this.getReadOptions(t, e), this.viewCache_ = null, cn(a, false, e);
        }
        readProjection(t) {
          const e = this.viewCache_ || dz(t);
          if (!e) return;
          const i = new gz(e);
          return i.readWkbHeader(), i.getSrid() && qt("EPSG:" + i.getSrid()) || void 0;
        }
        writeFeature(t, e) {
          return this.writeGeometry(t.getGeometry(), e);
        }
        writeFeatures(t, e) {
          return this.writeGeometry(new wn(t.map((i) => i.getGeometry())), e);
        }
        writeGeometry(t, e) {
          e = this.adaptOptions(e);
          const i = new Npt({ layout: this.layout_, littleEndian: this.littleEndian_, ewkb: this.ewkb_, nodata: { Z: this.nodataZ_, M: this.nodataM_ } });
          let r = Number.isInteger(this.srid_) ? Number(this.srid_) : null;
          if (this.srid_ !== false && !Number.isInteger(this.srid_)) {
            const o = e.dataProjection && qt(e.dataProjection);
            if (o) {
              const s = o.getCode();
              s.startsWith("EPSG:") && (r = Number(s.substring(5)));
            }
          }
          i.writeGeometry(cn(t, true, e), r);
          const a = i.getBuffer();
          return this.hex_ ? kpt(a) : a;
        }
      }
      function kpt(n) {
        const t = new Uint8Array(n);
        return Array.from(t.values()).map((e) => (e < 16 ? "0" : "") + Number(e).toString(16).toUpperCase()).join("");
      }
      function Opt(n) {
        const t = new Uint8Array(n.length / 2);
        for (let e = 0; e < n.length / 2; e++) t[e] = parseInt(n.substr(e * 2, 2), 16);
        return new DataView(t.buffer);
      }
      function dz(n) {
        return typeof n == "string" ? Opt(n) : ArrayBuffer.isView(n) ? n instanceof DataView ? n : new DataView(n.buffer, n.byteOffset, n.byteLength) : n instanceof ArrayBuffer ? new DataView(n) : null;
      }
      const Qpt = { POINT: Ge, LINESTRING: Be, POLYGON: Dn, MULTIPOINT: fr, MULTILINESTRING: ui, MULTIPOLYGON: bi }, Az = "EMPTY", pz = "Z", vz = "M", zpt = "ZM", je = { START: 0, TEXT: 1, LEFT_PAREN: 2, RIGHT_PAREN: 3, NUMBER: 4, COMMA: 5, EOF: 6 }, Gpt = { Point: "POINT", LineString: "LINESTRING", Polygon: "POLYGON", MultiPoint: "MULTIPOINT", MultiLineString: "MULTILINESTRING", MultiPolygon: "MULTIPOLYGON", GeometryCollection: "GEOMETRYCOLLECTION", Circle: "CIRCLE" };
      class Upt {
        constructor(t) {
          this.wkt = t, this.index_ = -1;
        }
        isAlpha_(t) {
          return t >= "a" && t <= "z" || t >= "A" && t <= "Z";
        }
        isNumeric_(t, e) {
          return e = e !== void 0 ? e : false, t >= "0" && t <= "9" || t == "." && !e;
        }
        isWhiteSpace_(t) {
          return t == " " || t == "	" || t == "\r" || t == `
`;
        }
        nextChar_() {
          return this.wkt.charAt(++this.index_);
        }
        nextToken() {
          const t = this.nextChar_(), e = this.index_;
          let i = t, r;
          if (t == "(") r = je.LEFT_PAREN;
          else if (t == ",") r = je.COMMA;
          else if (t == ")") r = je.RIGHT_PAREN;
          else if (this.isNumeric_(t) || t == "-") r = je.NUMBER, i = this.readNumber_();
          else if (this.isAlpha_(t)) r = je.TEXT, i = this.readText_();
          else {
            if (this.isWhiteSpace_(t)) return this.nextToken();
            if (t === "") r = je.EOF;
            else throw new Error("Unexpected character: " + t);
          }
          return { position: e, value: i, type: r };
        }
        readNumber_() {
          let t;
          const e = this.index_;
          let i = false, r = false;
          do
            t == "." ? i = true : (t == "e" || t == "E") && (r = true), t = this.nextChar_();
          while (this.isNumeric_(t, i) || !r && (t == "e" || t == "E") || r && (t == "-" || t == "+"));
          return parseFloat(this.wkt.substring(e, this.index_--));
        }
        readText_() {
          let t;
          const e = this.index_;
          do
            t = this.nextChar_();
          while (this.isAlpha_(t));
          return this.wkt.substring(e, this.index_--).toUpperCase();
        }
      }
      class Vpt {
        constructor(t) {
          this.lexer_ = t, this.token_ = { position: 0, type: je.START }, this.layout_ = "XY";
        }
        consume_() {
          this.token_ = this.lexer_.nextToken();
        }
        isTokenType(t) {
          return this.token_.type == t;
        }
        match(t) {
          const e = this.isTokenType(t);
          return e && this.consume_(), e;
        }
        parse() {
          return this.consume_(), this.parseGeometry_();
        }
        parseGeometryLayout_() {
          let t = "XY";
          const e = this.token_;
          if (this.isTokenType(je.TEXT)) {
            const i = e.value;
            i === pz ? t = "XYZ" : i === vz ? t = "XYM" : i === zpt && (t = "XYZM"), t !== "XY" && this.consume_();
          }
          return t;
        }
        parseGeometryCollectionText_() {
          if (this.match(je.LEFT_PAREN)) {
            const t = [];
            do
              t.push(this.parseGeometry_());
            while (this.match(je.COMMA));
            if (this.match(je.RIGHT_PAREN)) return t;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parsePointText_() {
          if (this.match(je.LEFT_PAREN)) {
            const t = this.parsePoint_();
            if (this.match(je.RIGHT_PAREN)) return t;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parseLineStringText_() {
          if (this.match(je.LEFT_PAREN)) {
            const t = this.parsePointList_();
            if (this.match(je.RIGHT_PAREN)) return t;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parsePolygonText_() {
          if (this.match(je.LEFT_PAREN)) {
            const t = this.parseLineStringTextList_();
            if (this.match(je.RIGHT_PAREN)) return t;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parseMultiPointText_() {
          if (this.match(je.LEFT_PAREN)) {
            let t;
            if (this.token_.type == je.LEFT_PAREN ? t = this.parsePointTextList_() : t = this.parsePointList_(), this.match(je.RIGHT_PAREN)) return t;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parseMultiLineStringText_() {
          if (this.match(je.LEFT_PAREN)) {
            const t = this.parseLineStringTextList_();
            if (this.match(je.RIGHT_PAREN)) return t;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parseMultiPolygonText_() {
          if (this.match(je.LEFT_PAREN)) {
            const t = this.parsePolygonTextList_();
            if (this.match(je.RIGHT_PAREN)) return t;
          }
          throw new Error(this.formatErrorMessage_());
        }
        parsePoint_() {
          const t = [], e = this.layout_.length;
          for (let i = 0; i < e; ++i) {
            const r = this.token_;
            if (this.match(je.NUMBER)) t.push(r.value);
            else break;
          }
          if (t.length == e) return t;
          throw new Error(this.formatErrorMessage_());
        }
        parsePointList_() {
          const t = [this.parsePoint_()];
          for (; this.match(je.COMMA); ) t.push(this.parsePoint_());
          return t;
        }
        parsePointTextList_() {
          const t = [this.parsePointText_()];
          for (; this.match(je.COMMA); ) t.push(this.parsePointText_());
          return t;
        }
        parseLineStringTextList_() {
          const t = [this.parseLineStringText_()];
          for (; this.match(je.COMMA); ) t.push(this.parseLineStringText_());
          return t;
        }
        parsePolygonTextList_() {
          const t = [this.parsePolygonText_()];
          for (; this.match(je.COMMA); ) t.push(this.parsePolygonText_());
          return t;
        }
        isEmptyGeometry_() {
          const t = this.isTokenType(je.TEXT) && this.token_.value == Az;
          return t && this.consume_(), t;
        }
        formatErrorMessage_() {
          return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
        }
        parseGeometry_() {
          const t = this.token_;
          if (this.match(je.TEXT)) {
            const e = t.value;
            this.layout_ = this.parseGeometryLayout_();
            const i = this.isEmptyGeometry_();
            if (e == "GEOMETRYCOLLECTION") {
              if (i) return new wn([]);
              const o = this.parseGeometryCollectionText_();
              return new wn(o);
            }
            const r = Qpt[e];
            if (!r) throw new Error("Invalid geometry type: " + e);
            let a;
            if (i) e == "POINT" ? a = [NaN, NaN] : a = [];
            else switch (e) {
              case "POINT": {
                a = this.parsePointText_();
                break;
              }
              case "LINESTRING": {
                a = this.parseLineStringText_();
                break;
              }
              case "POLYGON": {
                a = this.parsePolygonText_();
                break;
              }
              case "MULTIPOINT": {
                a = this.parseMultiPointText_();
                break;
              }
              case "MULTILINESTRING": {
                a = this.parseMultiLineStringText_();
                break;
              }
              case "MULTIPOLYGON": {
                a = this.parseMultiPolygonText_();
                break;
              }
            }
            return new r(a, this.layout_);
          }
          throw new Error(this.formatErrorMessage_());
        }
      }
      class jpt extends OS {
        constructor(t) {
          super(), t = t || {}, this.splitCollection_ = t.splitCollection !== void 0 ? t.splitCollection : false;
        }
        parse_(t) {
          const e = new Upt(t);
          return new Vpt(e).parse();
        }
        readFeatureFromText(t, e) {
          const i = this.readGeometryFromText(t, e), r = new Ce();
          return r.setGeometry(i), r;
        }
        readFeaturesFromText(t, e) {
          let i = [];
          const r = this.readGeometryFromText(t, e);
          this.splitCollection_ && r.getType() == "GeometryCollection" ? i = r.getGeometriesArray() : i = [r];
          const a = [];
          for (let o = 0, s = i.length; o < s; ++o) {
            const l = new Ce();
            l.setGeometry(i[o]), a.push(l);
          }
          return a;
        }
        readGeometryFromText(t, e) {
          const i = this.parse_(t);
          return cn(i, false, e);
        }
        writeFeatureText(t, e) {
          const i = t.getGeometry();
          return i ? this.writeGeometryText(i, e) : "";
        }
        writeFeaturesText(t, e) {
          if (t.length == 1) return this.writeFeatureText(t[0], e);
          const i = [];
          for (let a = 0, o = t.length; a < o; ++a) i.push(t[a].getGeometry());
          const r = new wn(i);
          return this.writeGeometryText(r, e);
        }
        writeGeometryText(t, e) {
          return _z(cn(t, true, e));
        }
      }
      function yz(n) {
        const t = n.getCoordinates();
        return t.length === 0 ? "" : t.join(" ");
      }
      function qpt(n) {
        const t = [], e = n.getPoints();
        for (let i = 0, r = e.length; i < r; ++i) t.push("(" + yz(e[i]) + ")");
        return t.join(",");
      }
      function Hpt(n) {
        const t = [], e = n.getGeometries();
        for (let i = 0, r = e.length; i < r; ++i) t.push(_z(e[i]));
        return t.join(",");
      }
      function ab(n) {
        const t = n.getCoordinates(), e = [];
        for (let i = 0, r = t.length; i < r; ++i) e.push(t[i].join(" "));
        return e.join(",");
      }
      function Ypt(n) {
        const t = [], e = n.getLineStrings();
        for (let i = 0, r = e.length; i < r; ++i) t.push("(" + ab(e[i]) + ")");
        return t.join(",");
      }
      function mz(n) {
        const t = [], e = n.getLinearRings();
        for (let i = 0, r = e.length; i < r; ++i) t.push("(" + ab(e[i]) + ")");
        return t.join(",");
      }
      function Wpt(n) {
        const t = [], e = n.getPolygons();
        for (let i = 0, r = e.length; i < r; ++i) t.push("(" + mz(e[i]) + ")");
        return t.join(",");
      }
      function Xpt(n) {
        const t = n.getLayout();
        let e = "";
        return (t === "XYZ" || t === "XYZM") && (e += pz), (t === "XYM" || t === "XYZM") && (e += vz), e;
      }
      const $pt = { Point: yz, LineString: ab, Polygon: mz, MultiPoint: qpt, MultiLineString: Ypt, MultiPolygon: Wpt, GeometryCollection: Hpt };
      function _z(n) {
        const t = n.getType(), e = $pt[t], i = e(n);
        let r = Gpt[t];
        if (typeof n.getFlatCoordinates == "function") {
          const a = Xpt(n);
          a.length > 0 && (r += " " + a);
        }
        return i.length === 0 ? r + " " + Az : r + "(" + i + ")";
      }
      const qn = [null, "http://www.opengis.net/wms"];
      function gg(n) {
        return dm(n[0].version, "1.3") >= 0;
      }
      const Zpt = tt(qn, { Service: z(_vt), Capability: z(mvt) }), Ez = { Request: z(Bvt), Exception: z(wvt), Layer: z(Cvt) }, Kpt = tt(qn, Qt(rt({}, Ez), { UserDefinedSymbolization: z(vvt) })), Jpt = tt(qn, Ez);
      class tvt extends ZS {
        constructor() {
          super(), this.version = void 0;
        }
        readFromNode(t) {
          this.version = t.getAttribute("version").trim();
          const e = at({ version: this.version }, Zpt, t, []);
          return e || null;
        }
      }
      const Iz = { Name: z(ot), Title: z(ot), Abstract: z(ot), KeywordList: z(Tz), OnlineResource: z(cg), ContactInformation: z(Evt), Fees: z(ot), AccessConstraints: z(ot) }, evt = tt(qn, Iz), nvt = tt(qn, Qt(rt({}, Iz), { LayerLimit: z(Cn), MaxWidth: z(Cn), MaxHeight: z(Cn) })), ivt = tt(qn, { ContactPersonPrimary: z(Ivt), ContactPosition: z(ot), ContactAddress: z(xvt), ContactVoiceTelephone: z(ot), ContactFacsimileTelephone: z(ot), ContactElectronicMailAddress: z(ot) }), rvt = tt(qn, { ContactPerson: z(ot), ContactOrganization: z(ot) }), avt = tt(qn, { AddressType: z(ot), Address: z(ot), City: z(ot), StateOrProvince: z(ot), PostCode: z(ot), Country: z(ot) }), ovt = tt(qn, { Format: Lt(ot) }), xz = { Name: z(ot), Title: z(ot), Abstract: z(ot), KeywordList: z(Tz), BoundingBox: Ve(Sz), Dimension: Ve(Svt), Attribution: z(pvt), AuthorityURL: Ve(Rvt), Identifier: Ve(ot), MetadataURL: Ve(Lvt), DataURL: Ve(Fs), FeatureListURL: Ve(Fs), Style: Ve(Pvt), Layer: Ve(v_) }, wz = tt(qn, Qt(rt({}, xz), { SRS: Ve(ot), Extent: z(bvt), ScaleHint: Ve(Tvt), LatLonBoundingBox: z((n, t) => Sz(n, t, false)), Layer: Ve(v_) })), Cz = tt(qn, Qt(rt({}, xz), { CRS: Ve(ot), EX_GeographicBoundingBox: z(yvt), MinScaleDenominator: z(_e), MaxScaleDenominator: z(_e), Layer: Ve(v_) })), svt = tt(qn, { Title: z(ot), OnlineResource: z(cg), LogoURL: z(bz) }), lvt = tt(qn, { westBoundLongitude: z(_e), eastBoundLongitude: z(_e), southBoundLatitude: z(_e), northBoundLatitude: z(_e) }), uvt = tt(qn, { GetCapabilities: z(ob), GetMap: z(ob), GetFeatureInfo: z(ob) }), hvt = tt(qn, { Format: Ve(ot), DCPType: Ve(Mvt) }), cvt = tt(qn, { HTTP: z(Dvt) }), fvt = tt(qn, { Get: z(Fs), Post: z(Fs) }), gvt = tt(qn, { Name: z(ot), Title: z(ot), Abstract: z(ot), LegendURL: Ve(bz), StyleSheetURL: z(Fs), StyleURL: z(Fs) }), dvt = tt(qn, { Format: z(ot), OnlineResource: z(cg) }), Avt = tt(qn, { Keyword: Lt(ot) });
      function pvt(n, t) {
        return at({}, svt, n, t);
      }
      function vvt(n, t) {
        return { SupportSLD: !!ha(n.getAttribute("UserDefinedSymbolization")), UserLayer: !!ha(n.getAttribute("UserLayer")), UserStyle: !!ha(n.getAttribute("UserStyle")), RemoteWFS: !!ha(n.getAttribute("RemoteWFS")) };
      }
      function Sz(n, t, e = true) {
        const i = [qa(n.getAttribute("minx")), qa(n.getAttribute("miny")), qa(n.getAttribute("maxx")), qa(n.getAttribute("maxy"))], r = [qa(n.getAttribute("resx")), qa(n.getAttribute("resy"))], a = { extent: i, res: r };
        return e && (gg(t) ? a.crs = n.getAttribute("CRS") : a.srs = n.getAttribute("SRS")), a;
      }
      function yvt(n, t) {
        const e = at({}, lvt, n, t);
        if (!e) return;
        const i = e.westBoundLongitude, r = e.southBoundLatitude, a = e.eastBoundLongitude, o = e.northBoundLatitude;
        if (!(i === void 0 || r === void 0 || a === void 0 || o === void 0)) return [i, r, a, o];
      }
      function mvt(n, t) {
        return at({}, gg(t) ? Jpt : Kpt, n, t);
      }
      function _vt(n, t) {
        return at({}, gg(t) ? nvt : evt, n, t);
      }
      function Evt(n, t) {
        return at({}, ivt, n, t);
      }
      function Ivt(n, t) {
        return at({}, rvt, n, t);
      }
      function xvt(n, t) {
        return at({}, avt, n, t);
      }
      function wvt(n, t) {
        return at([], ovt, n, t);
      }
      function Cvt(n, t) {
        const e = at({}, gg(t) ? Cz : wz, n, t);
        return e.Layer === void 0 ? Object.assign(e, v_(n, t)) : e;
      }
      function v_(n, t) {
        const e = gg(t), i = t[t.length - 1], r = at({}, e ? Cz : wz, n, t);
        if (!r) return;
        let a = ha(n.getAttribute("queryable"));
        a === void 0 && (a = i.queryable), r.queryable = a !== void 0 ? a : false;
        let o = Ps(n.getAttribute("cascaded"));
        o === void 0 && (o = i.cascaded), r.cascaded = o;
        let s = ha(n.getAttribute("opaque"));
        s === void 0 && (s = i.opaque), r.opaque = s !== void 0 ? s : false;
        let l = ha(n.getAttribute("noSubsets"));
        l === void 0 && (l = i.noSubsets), r.noSubsets = l !== void 0 ? l : false;
        let u = qa(n.getAttribute("fixedWidth"));
        u || (u = i.fixedWidth), r.fixedWidth = u;
        let h = qa(n.getAttribute("fixedHeight"));
        h || (h = i.fixedHeight), r.fixedHeight = h;
        const c = ["Style", "AuthorityURL"];
        e ? c.push("CRS") : c.push("SRS", "Dimension"), c.forEach(function(g) {
          if (g in i) {
            const d = r[g] || [];
            r[g] = d.concat(i[g]);
          }
        });
        const f = ["BoundingBox", "Attribution"];
        return e ? f.push("Dimension", "EX_GeographicBoundingBox", "MinScaleDenominator", "MaxScaleDenominator") : f.push("LatLonBoundingBox", "ScaleHint", "Extent"), f.forEach(function(g) {
          if (!(g in r)) {
            const d = i[g];
            r[g] = d;
          }
        }), r;
      }
      function Svt(n, t) {
        const e = { name: n.getAttribute("name"), units: n.getAttribute("units"), unitSymbol: n.getAttribute("unitSymbol") };
        return gg(t) && Object.assign(e, { default: n.getAttribute("default"), multipleValues: ha(n.getAttribute("multipleValues")), nearestValue: ha(n.getAttribute("nearestValue")), current: ha(n.getAttribute("current")), values: ot(n) }), e;
      }
      function bvt(n, t) {
        return { name: n.getAttribute("name"), default: n.getAttribute("default"), nearestValue: ha(n.getAttribute("nearestValue")) };
      }
      function Tvt(n, t) {
        return { min: qa(n.getAttribute("min")), max: qa(n.getAttribute("max")) };
      }
      function Fs(n, t) {
        return at({}, dvt, n, t);
      }
      function Bvt(n, t) {
        return at({}, uvt, n, t);
      }
      function Mvt(n, t) {
        return at({}, cvt, n, t);
      }
      function Dvt(n, t) {
        return at({}, fvt, n, t);
      }
      function ob(n, t) {
        return at({}, hvt, n, t);
      }
      function bz(n, t) {
        const e = Fs(n, t);
        if (e) {
          const i = [Ps(n.getAttribute("width")), Ps(n.getAttribute("height"))];
          return e.size = i, e;
        }
      }
      function Rvt(n, t) {
        const e = Fs(n, t);
        if (e) return e.name = n.getAttribute("name"), e;
      }
      function Lvt(n, t) {
        const e = Fs(n, t);
        if (e) return e.type = n.getAttribute("type"), e;
      }
      function Pvt(n, t) {
        return at({}, gvt, n, t);
      }
      function Tz(n, t) {
        return at([], Avt, n, t);
      }
      const Nvt = "_feature", Fvt = "_layer";
      class kvt extends Ap {
        constructor(t) {
          super(), t = t || {}, this.featureNS_ = "http://mapserver.gis.umn.edu/mapserver", this.gmlFormat_ = new ve(), this.layers_ = t.layers ? t.layers : null;
        }
        getLayers() {
          return this.layers_;
        }
        setLayers(t) {
          this.layers_ = t;
        }
        readFeatures_(t, e) {
          t.setAttribute("namespaceURI", this.featureNS_);
          const i = t.localName;
          let r = [];
          if (t.childNodes.length === 0) return r;
          if (i == "msGMLOutput") for (let a = 0, o = t.childNodes.length; a < o; a++) {
            const s = t.childNodes[a];
            if (s.nodeType !== Node.ELEMENT_NODE) continue;
            const l = s, u = e[0], h = Fvt, c = l.localName.replace(h, "");
            if (this.layers_ && !this.layers_.includes(c)) continue;
            const f = c + Nvt;
            u.featureType = f, u.featureNS = this.featureNS_;
            const g = {};
            g[f] = Lt(this.gmlFormat_.readFeatureElement, this.gmlFormat_);
            const d = tt([u.featureNS, null], g);
            l.setAttribute("namespaceURI", this.featureNS_);
            const A = at([], d, l, e, this.gmlFormat_);
            A && Le(r, A);
          }
          if (i == "FeatureCollection") {
            const a = at([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, t, [{}], this.gmlFormat_);
            a && (r = a);
          }
          return r;
        }
        readFeaturesFromNode(t, e) {
          const i = {};
          return e && Object.assign(i, this.getReadOptions(t, e)), this.readFeatures_(t, [i]);
        }
      }
      const No = [null, "http://www.opengis.net/wmts/1.0"], dg = [null, "http://www.opengis.net/ows/1.1"], Ovt = tt(No, { Contents: z(Xvt) });
      class Qvt extends ZS {
        constructor() {
          super(), this.owsParser_ = new Q3();
        }
        readFromNode(t) {
          let e = t.getAttribute("version");
          e && (e = e.trim());
          let i = this.owsParser_.readFromNode(t);
          return i ? (i.version = e, i = at(i, Ovt, t, []), i || null) : null;
        }
      }
      const zvt = tt(No, { Layer: Ve($vt), TileMatrixSet: Ve(Zvt) }), Gvt = tt(No, { Style: Ve(Kvt), Format: Ve(ot), TileMatrixSetLink: Ve(Jvt), Dimension: Ve(tyt), ResourceURL: Ve(eyt) }, tt(dg, { Title: z(ot), Abstract: z(ot), WGS84BoundingBox: z(Mz), BoundingBox: Ve(nyt), Identifier: z(ot) })), Uvt = tt(No, { LegendURL: Ve(iyt) }, tt(dg, { Title: z(ot), Identifier: z(ot) })), Vvt = tt(No, { TileMatrixSet: z(ot), TileMatrixSetLimits: z(ayt) }), jvt = tt(No, { TileMatrixLimits: Lt(oyt) }), qvt = tt(No, { TileMatrix: z(ot), MinTileRow: z(Cn), MaxTileRow: z(Cn), MinTileCol: z(Cn), MaxTileCol: z(Cn) }), Hvt = tt(No, { Default: z(ot), Value: Ve(ot) }, tt(dg, { Identifier: z(ot) })), Bz = tt(dg, { LowerCorner: Lt(sb), UpperCorner: Lt(sb) }), Yvt = tt(No, { WellKnownScaleSet: z(ot), TileMatrix: Ve(ryt) }, tt(dg, { SupportedCRS: z(ot), Identifier: z(ot), BoundingBox: z(Mz) })), Wvt = tt(No, { TopLeftCorner: z(sb), ScaleDenominator: z(_e), TileWidth: z(Cn), TileHeight: z(Cn), MatrixWidth: z(Cn), MatrixHeight: z(Cn) }, tt(dg, { Identifier: z(ot) }));
      function Xvt(n, t) {
        return at({}, zvt, n, t);
      }
      function $vt(n, t) {
        return at({}, Gvt, n, t);
      }
      function Zvt(n, t) {
        return at({}, Yvt, n, t);
      }
      function Kvt(n, t) {
        const e = at({}, Uvt, n, t);
        if (!e) return;
        const i = n.getAttribute("isDefault") === "true";
        return e.isDefault = i, e;
      }
      function Jvt(n, t) {
        return at({}, Vvt, n, t);
      }
      function tyt(n, t) {
        return at({}, Hvt, n, t);
      }
      function eyt(n, t) {
        const e = n.getAttribute("format"), i = n.getAttribute("template"), r = n.getAttribute("resourceType"), a = {};
        return e && (a.format = e), i && (a.template = i), r && (a.resourceType = r), a;
      }
      function Mz(n, t) {
        const e = at([], Bz, n, t);
        if (e.length == 2) return Mn(e);
      }
      function nyt(n, t) {
        const e = n.getAttribute("crs"), i = at([], Bz, n, t);
        if (i.length == 2) return { extent: Mn(i), crs: e };
      }
      function iyt(n, t) {
        const e = {};
        return e.format = n.getAttribute("format"), e.href = cg(n), e;
      }
      function sb(n, t) {
        const e = ot(n).split(/\s+/);
        if (!e || e.length != 2) return;
        const i = +e[0], r = +e[1];
        if (!(isNaN(i) || isNaN(r))) return [i, r];
      }
      function ryt(n, t) {
        return at({}, Wvt, n, t);
      }
      function ayt(n, t) {
        return at([], jvt, n, t);
      }
      function oyt(n, t) {
        return at({}, qvt, n, t);
      }
      const syt = Object.freeze(Object.defineProperty({ __proto__: null, EsriJSON: Vct, GML: LS, GPX: Nft, GeoJSON: ag, IGC: vgt, IIIFInfo: nct, KML: bgt, MVT: mAt, OWS: Q3, Polyline: tpt, TopoJSON: hpt, WFS: Y3, WKB: Fpt, WKT: jpt, WMSCapabilities: tvt, WMSGetFeatureInfo: kvt, WMTSCapabilities: Qvt }, Symbol.toStringTag, { value: "Module" })), lyt = (n) => {
        if (!n) return new kr({ radius: 2 });
        const t = { radius: n.radius || 2, fill: new me(n.fill || { color: "blue" }), stroke: new Ke(n.stroke || { color: "white" }) };
        return new kr(t);
      }, uyt = (n) => {
        const t = rt({ font: "14px sans-serif", padding: [2, 5, 2, 5] }, n), e = new Si(t);
        if (n.text && e.setText(n.text), Nn(n, "fill")) {
          const i = new me(n.fill);
          e.setFill(i);
        }
        if (Nn(n, "backgroundFill")) {
          const i = new me(n.backgroundFill);
          e.setBackgroundFill(i);
        }
        if (Nn(n, "stroke")) {
          const i = new Ke(n.stroke);
          e.setStroke(i);
        }
        if (Nn(n, "backgroundStroke")) {
          const i = new Ke(n.backgroundStroke);
          e.setBackgroundStroke(i);
        }
        return e;
      }, uh = (n) => {
        var e, i;
        const t = new pe();
        if (Nn(n, "fill") ? t.setFill(new me(n.fill)) : t.setFill(new me({ color: "rgba(67,126,255,0.15)" })), Nn(n, "stroke") ? t.setStroke(new Ke(n.stroke)) : t.setStroke(new Ke({ color: "rgba(67,126,255,1)", width: 1 })), Nn(n, "icon") && t.setImage(new Qr(n.icon)), Nn(n, "circle")) {
          const r = lyt(n.circle);
          t.setImage(r);
        }
        if (Nn(n, "text")) {
          const r = n.text;
          if (r) {
            const a = uyt(r);
            t.setText(a);
          }
        }
        if (Nn(n, "shape")) {
          let r, a;
          if (Nn(n.shape, "fill") && (r = new me((e = n.shape) == null ? void 0 : e.fill)), Nn(n.shape, "stroke") && (a = new Ke((i = n.shape) == null ? void 0 : i.stroke)), n.shape) {
            const o = Qt(rt({}, n.shape), { stroke: a, fill: r }), s = new Xu(o);
            t.setImage(s);
          }
        }
        return t;
      }, y_ = (n, t, e) => {
        const i = uh(t);
        n.setStyle(i), Nn(t, "styleFunction") ? n.setStyle(function(r, a) {
          return t.styleFunction && t.styleFunction(r, a, e, i);
        }) : n.setStyle(i);
      }, Dz = (n, t) => {
        const e = P.inject("VMap"), i = P.unref(e).map, r = i.getView().getProjection().getMetersPerUnit();
        let a = P.shallowRef(), o = P.shallowRef(), s = P.shallowRef(), l = P.shallowRef(void 0), u = P.ref([]);
        const h = ["singleclick", "pointermove"];
        P.ref(false), P.watch(() => n.visible, (x) => {
          var w;
          a.value && ((w = l.value) == null || w.setActive(x || false));
        });
        const c = (x) => {
          x.on("modifyend", (w) => {
            t("modifyend", Qt(rt({}, w), { metersPerUnit: r }));
          }), x.on("modifystart", (w) => {
            t("modifystart", Qt(rt({}, w), { metersPerUnit: r }));
          });
        }, f = () => {
          a && n.modify && (l.value = new $w({ hitDetection: a.value, source: s.value }), i.addInteraction(l.value), c(l.value));
        }, g = () => {
          var x, w, C, S, b, T, B, R, M, L, N, F, k, O, Q, j, Y, G;
          if ((x = n.source) != null && x.featureFormat) {
            if ((w = n.source) != null && w.url && (((C = n.source) == null ? void 0 : C.featureFormat) === "GeoJSON" || ((S = n.source) == null ? void 0 : S.featureFormat) === "EsriJSON" || ((b = n.source) == null ? void 0 : b.featureFormat) === "TopoJSON")) {
              let $ = { dataProjection: void 0, featureProjection: void 0 };
              return ((B = (T = n.source) == null ? void 0 : T.formatOptions) != null && B.dataProjection || (M = (R = n.source) == null ? void 0 : R.formatOptions) != null && M.featureProjection) && ((N = (L = n.source) == null ? void 0 : L.formatOptions) != null && N.dataProjection && ($.dataProjection = new Oi((k = (F = n.source) == null ? void 0 : F.formatOptions) == null ? void 0 : k.dataProjection)), (Q = (O = n.source) == null ? void 0 : O.formatOptions) != null && Q.featureProjection && ($.featureProjection = new Oi((Y = (j = n.source) == null ? void 0 : j.formatOptions) == null ? void 0 : Y.featureProjection))), new oa({ url: n.source.url, format: new syt[(G = n.source) == null ? void 0 : G.featureFormat](rt(rt({}, n.source.formatOptions), $)) });
            }
          } else return new oa(n.source);
        }, d = (x, w) => {
          const { pixel: C } = w, S = A(C);
          Qt(rt({}, w), { feature: S }), t(x, w, S);
        }, A = (x) => i.forEachFeatureAtPixel(x, (w) => w, { layerFilter: (w) => {
          var C;
          return w.get("id") === ((C = a.value) == null ? void 0 : C.get("id"));
        } }), p = () => {
          u.value.forEach((x) => {
            yl(x);
          });
        }, v = (x) => {
          x.set("id", n.layerId), h.forEach((w) => {
            u.value.push(i.on(w, (C) => {
              d(w, C);
            }));
          }), s.value && setTimeout(() => {
            f();
          }, 0), x.on("sourceready", (w) => {
            t("sourceready", w);
          }), i.addLayer(x);
        }, y = () => Tt(this, null, function* () {
          var w;
          s.value = g(), (w = s.value) == null || w.on("addfeature", (C) => {
            t("addfeature", C);
          });
          const x = n.layerStyle;
          return !x || Object.keys(x).length, n.featureStyle ? a.value = new aa(Qt(rt({}, n), { source: s.value, style: (C) => y_(C, n.featureStyle, i) })) : a.value = new aa(Qt(rt({}, n), { source: s.value, style: x })), v(a.value), Promise.resolve(a.value);
        }), m = () => {
          var w;
          s.value = g(), (w = s.value) == null || w.on("addfeature", (C) => {
            t("addfeature", C);
          });
          const x = n.layerStyle;
          return !x || Object.keys(x).length, o.value = new Nct(Qt(rt({}, n), { source: s.value, style: x })), v(o.value), Promise.resolve(o.value);
        }, _ = (x) => {
          var w;
          return (w = s.value) == null ? void 0 : w.getFeatureById(x);
        };
        return { initVectorLayer: y, initWebglLayer: m, dispose: p, getFeatureById: _, removeFeatureById: (x) => {
          var C;
          const w = _(x);
          w && ((C = s.value) == null || C.removeFeature(w));
        }, getSource: () => s.value };
      }, m_ = P.defineComponent({ name: "OlVector", __name: "index", props: { layerId: { default: `vector-layer-${Gl()}` }, source: { default: void 0 }, layerStyle: { default: () => OC() }, featureStyle: { default: void 0 }, modify: { type: Boolean, default: false }, className: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, renderOrder: {}, renderBuffer: {}, map: {}, declutter: { type: [String, Number, Boolean] }, background: {}, updateWhileAnimating: { type: Boolean }, updateWhileInteracting: { type: Boolean }, properties: {} }, emits: ["singleclick", "pointermove", "sourceready", "featuresloadend", "featuresloadstart", "addfeature", "modifyend", "modifystart", "change"], setup(n, { expose: t, emit: e }) {
        const i = n, r = P.inject("VMap"), a = P.unref(r).map;
        let o = P.shallowRef(), s = P.ref(false);
        const l = e, { initVectorLayer: u, dispose: h, getFeatureById: c, removeFeatureById: f, getSource: g } = Dz(i, l);
        P.provide("ParentLayer", o), P.watchEffect(() => {
          Rs(o.value, i);
        }), P.watch(() => i.layerStyle, (A) => {
          var p;
          (p = o.value) == null || p.setStyle(A);
        }, { deep: true }), P.watch(() => i.source, () => {
          var A, p;
          (p = (A = o.value) == null ? void 0 : A.getSource()) == null || p.clear(), o.value && a.removeLayer(o.value), d();
        });
        const d = () => Tt(this, null, function* () {
          const A = yield u();
          s.value = true, o.value = A;
        });
        return t({ getFeatureById: c, removeFeatureById: f, getSource: g, getLayer: () => o.value }), P.onMounted(() => {
          d();
        }), P.onBeforeUnmount(() => {
          h();
        }), (A, p) => P.unref(s) ? P.renderSlot(A.$slots, "default", { key: 0 }) : P.createCommentVNode("", true);
      } }), hyt = (n) => n.component(m_.name || "OlVector", m_), lb = P.defineComponent({ name: "OlWebglVector", __name: "index", props: { layerId: { default: `vector-layer-${Gl()}` }, source: { default: void 0 }, layerStyle: { default: () => OC() }, featureStyle: { default: void 0 }, modify: { type: Boolean, default: false }, className: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, renderOrder: {}, renderBuffer: {}, map: {}, declutter: { type: [String, Number, Boolean] }, background: {}, updateWhileAnimating: { type: Boolean }, updateWhileInteracting: { type: Boolean }, properties: {} }, emits: ["singleclick", "pointermove", "sourceready", "featuresloadend", "featuresloadstart", "addfeature", "modifyend", "modifystart", "change"], setup(n, { expose: t, emit: e }) {
        const i = n, r = P.inject("VMap"), a = P.unref(r).map;
        let o = P.shallowRef(), s = P.ref(false);
        P.provide("ParentLayer", o), P.watchEffect(() => {
          Rs(o.value, i);
        }), P.watch(() => i.layerStyle, (A) => {
          var p;
          (p = o.value) == null || p.setStyle(A);
        }, { deep: true }), P.watch(() => i.source, () => {
          var A, p;
          (p = (A = o.value) == null ? void 0 : A.getSource()) == null || p.clear(), o.value && a.removeLayer(o.value), d();
        });
        const l = e, { initWebglLayer: u, dispose: h, getFeatureById: c, removeFeatureById: f, getSource: g } = Dz(i, l), d = () => Tt(this, null, function* () {
          const A = yield u();
          s.value = true, o.value = A;
        });
        return t({ getFeatureById: c, removeFeatureById: f, getSource: g, getLayer: () => o.value }), P.onMounted(() => {
          d();
        }), P.onBeforeUnmount(() => {
          h();
        }), (A, p) => P.unref(s) ? P.renderSlot(A.$slots, "default", { key: 0 }) : P.createCommentVNode("", true);
      } }), cyt = (n) => n.component(lb.name || "OlWebglVector", lb), fyt = Object.prototype.hasOwnProperty, hh = typeof Symbol != "undefined" ? Symbol.toStringTag : void 0;
      function gyt(n) {
        if (n === null) return n === void 0 ? "[object Undefined]" : "[object Null]";
        if (!(hh && hh in Object(n))) return toString.call(n);
        const t = fyt.call(n, hh), e = n[hh];
        let i = false;
        try {
          n[hh] = void 0, i = true;
        } catch (a) {
        }
        const r = Object.prototype.toString.call(n);
        return i && (t ? n[hh] = e : delete n[hh]), r;
      }
      function Ep(n) {
        if (!dyt(n)) return false;
        const t = gyt(n);
        return t === "[object Function]" || t === "[object AsyncFunction]" || t === "[object GeneratorFunction]" || t === "[object Proxy]";
      }
      function dyt(n) {
        const t = typeof n;
        return n !== null && (t === "object" || t === "function");
      }
      function Ayt(n) {
        return n == null ? false : typeof n == "string" || n.constructor !== null && n.constructor === String;
      }
      function ub(n) {
        return Object.prototype.toString.call(n) === "[object Number]" && !isNaN(n);
      }
      function pyt(n) {
        return Array.isArray(n);
      }
      function hb(n, ...t) {
        return Object.assign(n, ...t);
      }
      function t4t(n, t) {
      }
      const Rz = {};
      function vyt(n, t) {
        Rz[t] || (Rz[t] = true);
      }
      function yyt(n, t) {
        return n - t * Math.floor(n / t);
      }
      function Fo(n) {
        return n != null && !isNaN(n);
      }
      function myt(n, t = {}) {
        let e, i;
        if (n.forEach(function(o) {
          switch (o.header.parameterCategory + "," + o.header.parameterNumber) {
            case "1,2":
            case "2,2":
              e = o;
              break;
            case "1,3":
            case "2,3":
              i = o;
              break;
          }
        }), !i || !e) return;
        const r = e.header;
        return new Lz(rt({ xmin: r.lo1, ymin: r.la1, xmax: r.lo2, ymax: r.la2, deltaX: r.dx, deltaY: r.dy, cols: r.nx, rows: r.ny, us: e.data, vs: i.data }, t));
      }
      class cb {
        constructor(t, e) {
          this.u = t, this.v = e, this.m = this.magnitude();
        }
        magnitude() {
          return Math.sqrt(jn(this.u, 2) + jn(this.v, 2));
        }
        directionTo() {
          let e = Math.atan2(this.u, this.v) * (180 / Math.PI);
          return e < 0 && (e += 360), e;
        }
        directionFrom() {
          return (this.directionTo() + 180) % 360;
        }
      }
      class Lz {
        constructor(t) {
          this.grid = [], this.xmin = t.xmin, this.xmax = t.xmax, this.ymin = t.ymin, this.ymax = t.ymax, this.cols = t.cols, this.rows = t.rows, this.us = t.us, this.vs = t.vs, this.deltaX = t.deltaX, this.deltaY = t.deltaY, this.flipY = !!t.flipY, this.ymin = Math.min(t.ymax, t.ymin), this.ymax = Math.max(t.ymax, t.ymin), this.deltaY < 0 && this.ymin < this.ymax || t.flipY === void 0 && (this.flipY = true), this.isFields = true;
          const e = Math.ceil((this.xmax - this.xmin) / t.deltaX), i = Math.ceil((this.ymax - this.ymin) / t.deltaY);
          e !== this.cols || this.rows, this.isContinuous = Math.floor(this.cols * t.deltaX) >= 360, this.translateX = "translateX" in t ? t.translateX : this.xmax > 180, "wrappedX" in t && vyt("[wind-core]: ", "`wrappedX` namespace will deprecated please use `translateX` instead"), this.wrapX = !!t.wrapX, this.grid = this.buildGrid(), this.range = this.calculateRange();
        }
        buildGrid() {
          const t = [];
          let e = 0;
          const { rows: i, cols: r, us: a, vs: o } = this;
          for (let s = 0; s < i; s++) {
            const l = [];
            for (let u = 0; u < r; u++, e++) {
              const h = a[e], c = o[e], f = this.isValid(h) && this.isValid(c);
              l[u] = f ? new cb(h, c) : null;
            }
            this.isContinuous && l.push(l[0]), t[s] = l;
          }
          return t;
        }
        release() {
          this.grid = [];
        }
        extent() {
          return [this.xmin, this.ymin, this.xmax, this.ymax];
        }
        bilinearInterpolateVector(t, e, i, r, a, o) {
          const s = 1 - t, l = 1 - e, u = s * l, h = t * l, c = s * e, f = t * e, g = i.u * u + r.u * h + a.u * c + o.u * f, d = i.v * u + r.v * h + a.v * c + o.v * f;
          return new cb(g, d);
        }
        calculateRange() {
          if (!this.grid || !this.grid[0]) return;
          const t = this.grid.length, e = this.grid[0].length;
          let i, r;
          for (let a = 0; a < t; a++) for (let o = 0; o < e; o++) {
            const s = this.grid[a][o];
            if (s !== null) {
              const l = s.m || s.magnitude();
              i === void 0 ? i = l : r === void 0 ? (r = l, i = Math.min(i, r), r = Math.max(i, r)) : (i = Math.min(l, i), r = Math.max(l, r));
            }
          }
          return [i, r];
        }
        isValid(t) {
          return t != null;
        }
        getWrappedLongitudes() {
          let t = this.xmin, e = this.xmax;
          return this.translateX && (this.isContinuous ? (t = -180, e = 180) : (e = this.xmax - 360, t = this.xmin - 360)), [t, e];
        }
        contains(t, e) {
          const [i, r] = this.getWrappedLongitudes();
          r > 180 && t >= -180 && t <= r - 360 ? t += 360 : i < -180 && t <= 180 && t >= i + 360 && (t -= 360);
          const a = t >= i && t <= r;
          let o;
          return this.deltaY >= 0 ? o = e >= this.ymin && e <= this.ymax : o = e >= this.ymax && e <= this.ymin, a && o;
        }
        getDecimalIndexes(t, e) {
          const i = yyt(t - this.xmin, 360) / this.deltaX;
          if (this.flipY) {
            const r = (this.ymax - e) / this.deltaY;
            return [i, r];
          } else {
            const r = (this.ymin + e) / this.deltaY;
            return [i, r];
          }
        }
        valueAt(t, e) {
          let i = false;
          if ((this.wrapX || this.contains(t, e)) && (i = true), !i) return null;
          const r = this.getDecimalIndexes(t, e), a = Math.floor(r[0]), o = Math.floor(r[1]), s = this.clampColumnIndex(a), l = this.clampRowIndex(o);
          return this.valueAtIndexes(s, l);
        }
        interpolatedValueAt(t, e) {
          let i = false;
          if ((this.wrapX || this.contains(t, e)) && (i = true), !i) return null;
          const [r, a] = this.getDecimalIndexes(t, e);
          return this.interpolatePoint(r, a);
        }
        hasValueAt(t, e) {
          return this.valueAt(t, e) !== null;
        }
        interpolatePoint(t, e) {
          const i = this.getFourSurroundingIndexes(t, e), [r, a, o, s] = i, l = this.getFourSurroundingValues(r, a, o, s);
          if (l) {
            const [u, h, c, f] = l;
            return this.bilinearInterpolateVector(t - r, e - o, u, h, c, f);
          }
          return null;
        }
        clampColumnIndex(t) {
          let e = t;
          t < 0 && (e = 0);
          const i = this.cols - 1;
          return t > i && (e = i), e;
        }
        clampRowIndex(t) {
          let e = t;
          t < 0 && (e = 0);
          const i = this.rows - 1;
          return t > i && (e = i), e;
        }
        getFourSurroundingIndexes(t, e) {
          const i = Math.floor(t);
          let r = i + 1;
          this.isContinuous && r >= this.cols && (r = 0), r = this.clampColumnIndex(r);
          const a = this.clampRowIndex(Math.floor(e)), o = this.clampRowIndex(a + 1);
          return [i, r, a, o];
        }
        getFourSurroundingValues(t, e, i, r) {
          let a;
          if (a = this.grid[i]) {
            const o = a[t], s = a[e];
            if (this.isValid(o) && this.isValid(s) && (a = this.grid[r])) {
              const l = a[t], u = a[e];
              if (this.isValid(l) && this.isValid(u)) return [o, s, l, u];
            }
          }
          return null;
        }
        valueAtIndexes(t, e) {
          return this.grid[e][t];
        }
        lonLatAtIndexes(t, e) {
          const i = this.longitudeAtX(t), r = this.latitudeAtY(e);
          return [i, r];
        }
        longitudeAtX(t) {
          const e = this.deltaX / 2;
          let i = this.xmin + e + t * this.deltaX;
          return this.translateX && (i = i > 180 ? i - 360 : i), i;
        }
        latitudeAtY(t) {
          const e = this.deltaY / 2;
          return this.ymax - e - t * this.deltaY;
        }
        randomize(t = {}, e, i, r) {
          const a = Math.random() * (e || this.cols) | 0, o = Math.random() * (i || this.rows) | 0, s = r([a, o]);
          return s !== null ? (t.x = s[0], t.y = s[1]) : (t.x = this.longitudeAtX(a), t.y = this.latitudeAtY(o)), t;
        }
        checkFields() {
          return this.isFields;
        }
      }
      const Pz = { globalAlpha: 0.9, lineWidth: 1, colorScale: "#fff", velocityScale: 1 / 25, maxAge: 90, paths: 800, frameRate: 20, useCoordsDraw: true };
      function Nz(n, t, e, i) {
        return Math.max(0, Math.min(i.length - 1, Math.round((n - t) / (e - t) * (i.length - 1))));
      }
      const SP = class SP {
        constructor(t, e, i) {
          if (this.particles = [], this.generated = false, this.ctx = t, !this.ctx) throw new Error("ctx error");
          this.animate = this.animate.bind(this), this.setOptions(e), i && this.updateData(i);
        }
        setOptions(t) {
          this.options = rt(rt({}, Pz), t);
          const { width: e, height: i } = this.ctx.canvas;
          "particleAge" in t && !("maxAge" in t) && ub(this.options.particleAge) && (this.options.maxAge = this.options.particleAge), "particleMultiplier" in t && !("paths" in t) && ub(this.options.particleMultiplier) && (this.options.paths = Math.round(e * i * this.options.particleMultiplier)), this.prerender();
        }
        getOptions() {
          return this.options;
        }
        updateData(t) {
          this.field = t, this.generated && (this.particles = this.prepareParticlePaths());
        }
        project(...t) {
          throw new Error("project must be overriden");
        }
        unproject(...t) {
          throw new Error("unproject must be overriden");
        }
        intersectsCoordinate(t) {
          throw new Error("must be overriden");
        }
        clearCanvas() {
          this.stop(), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.forceStop = false;
        }
        isStop() {
          return !this.starting;
        }
        start() {
          this.starting = true, this.forceStop = false, this.then = Date.now(), this.animate();
        }
        stop() {
          cancelAnimationFrame(this.animationLoop), this.starting = false, this.forceStop = true;
        }
        animate() {
          this.animationLoop && cancelAnimationFrame(this.animationLoop), this.animationLoop = requestAnimationFrame(this.animate);
          const t = Date.now(), e = t - this.then;
          e > this.options.frameRate && (this.then = t - e % this.options.frameRate, this.render());
        }
        prerender() {
          this.generated = false, this.field && (this.particles = this.prepareParticlePaths(), this.generated = true, !this.starting && !this.forceStop && (this.starting = true, this.then = Date.now(), this.animate()));
        }
        render() {
          this.moveParticles(), this.drawParticles(), this.postrender();
        }
        postrender() {
        }
        moveParticles() {
          const { width: t, height: e } = this.ctx.canvas, i = this.particles, r = this.options.maxAge, a = Ep(this.options.velocityScale) ? this.options.velocityScale() : this.options.velocityScale;
          let o = 0;
          const s = i.length;
          for (; o < s; o++) {
            const l = i[o];
            l.age > r && (l.age = 0, this.field.randomize(l, t, e, this.unproject));
            const u = l.x, h = l.y, c = this.field.interpolatedValueAt(u, h);
            if (c === null) l.age = r;
            else {
              const f = u + c.u * a, g = h + c.v * a;
              this.field.hasValueAt(f, g) ? (l.xt = f, l.yt = g, l.m = c.m) : (l.x = f, l.y = g, l.age = r);
            }
            l.age++;
          }
        }
        fadeIn() {
          const t = this.ctx.globalCompositeOperation;
          this.ctx.globalCompositeOperation = "destination-in", this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.globalCompositeOperation = t;
        }
        drawParticles() {
          const t = this.particles;
          this.fadeIn(), this.ctx.globalAlpha = this.options.globalAlpha, this.ctx.fillStyle = `rgba(0, 0, 0, ${this.options.globalAlpha})`, this.ctx.lineWidth = ub(this.options.lineWidth) ? this.options.lineWidth : 1, this.ctx.strokeStyle = Ayt(this.options.colorScale) ? this.options.colorScale : "#fff";
          let e = 0;
          const i = t.length;
          if (this.field && i > 0) {
            let r, a;
            for (Fo(this.options.minVelocity) && Fo(this.options.maxVelocity) ? (r = this.options.minVelocity, a = this.options.maxVelocity) : [r, a] = this.field.range; e < i; e++) this[this.options.useCoordsDraw ? "drawCoordsParticle" : "drawPixelParticle"](t[e], r, a);
          }
        }
        drawPixelParticle(t, e, i) {
          const r = [t.x, t.y], a = [t.xt, t.yt];
          if (a && r && Fo(a[0]) && Fo(a[1]) && Fo(r[0]) && Fo(r[1]) && t.age <= this.options.maxAge) {
            if (this.ctx.beginPath(), this.ctx.moveTo(r[0], r[1]), this.ctx.lineTo(a[0], a[1]), Ep(this.options.colorScale)) this.ctx.strokeStyle = this.options.colorScale(t.m);
            else if (Array.isArray(this.options.colorScale)) {
              const o = Nz(t.m, e, i, this.options.colorScale);
              this.ctx.strokeStyle = this.options.colorScale[o];
            }
            Ep(this.options.lineWidth) && (this.ctx.lineWidth = this.options.lineWidth(t.m)), t.x = t.xt, t.y = t.yt, this.ctx.stroke();
          }
        }
        drawCoordsParticle(t, e, i) {
          const r = [t.x, t.y], a = [t.xt, t.yt];
          if (a && r && Fo(a[0]) && Fo(a[1]) && Fo(r[0]) && Fo(r[1]) && this.intersectsCoordinate(a) && t.age <= this.options.maxAge) {
            const o = this.project(r), s = this.project(a);
            if (o && s) {
              if (this.ctx.beginPath(), this.ctx.moveTo(o[0], o[1]), this.ctx.lineTo(s[0], s[1]), t.x = t.xt, t.y = t.yt, Ep(this.options.colorScale)) this.ctx.strokeStyle = this.options.colorScale(t.m);
              else if (Array.isArray(this.options.colorScale)) {
                const l = Nz(t.m, e, i, this.options.colorScale);
                this.ctx.strokeStyle = this.options.colorScale[l];
              }
              Ep(this.options.lineWidth) && (this.ctx.lineWidth = this.options.lineWidth(t.m)), this.ctx.stroke();
            }
          }
        }
        prepareParticlePaths() {
          const { width: t, height: e } = this.ctx.canvas, i = typeof this.options.paths == "function" ? this.options.paths(this) : this.options.paths, r = [];
          if (!this.field) return [];
          let a = 0;
          for (; a < i; a++) r.push(this.field.randomize({ age: this.randomize() }, t, e, this.unproject));
          return r;
        }
        randomize() {
          return Math.floor(Math.random() * this.options.maxAge);
        }
      };
      SP.Field = Lz;
      let fb = SP;
      const Fz = { ANIMATING: 0, INTERACTING: 1 };
      class _yt extends Ym {
        constructor(t) {
          super(t), this.pixelTransform = an(), this.inversePixelTransform = an();
        }
        useContainer(t, e, i) {
          super.useContainer(null, e, i);
        }
        getBackground(t) {
          return super.getBackground ? super.getBackground(t) : "";
        }
        prepareFrame(t) {
          var o, s;
          const e = t.layerStatesArray[t.layerIndex], i = t.viewState, r = t.viewHints;
          let a = t.extent;
          return e.extent !== void 0 && (a = oi(a, zi(e.extent, i.projection))), !r[Fz.ANIMATING] && !t.animate && !r[Fz.INTERACTING] && !ps(a) ? ((s = (o = this.wind) == null ? void 0 : o.isStop) != null && s.call(o) && this.wind.start(), true) : this.getLayer().get("forceRender");
        }
        prepareContainer(t, e) {
          const i = t.size, r = t.viewState.rotation, a = t.pixelRatio, o = Math.round(i[0] * a), s = Math.round(i[1] * a);
          Lr(this.pixelTransform, t.size[0] / 2, t.size[1] / 2, 1 / a, 1 / a, r, -o / 2, -s / 2), ml(this.inversePixelTransform, this.pixelTransform);
          const l = QP(this.pixelTransform);
          if (this.useContainer(e, l, this.getBackground(t)), !this.containerReused) {
            const u = this.context.canvas;
            (u.width != o || u.height != s) && (u.width = o, u.height = s), l !== u.style.transform && (u.style.transform = l);
          }
        }
        getRenderContext(t) {
          return this.context;
        }
        renderFrame(t, e) {
          const i = t.layerStatesArray[t.layerIndex], r = t.viewState;
          this.prepareContainer(t, e);
          const a = this.getRenderContext(t);
          a.imageSmoothingEnabled = false, this.preRender(a, t);
          let o = false, s = true;
          if (i.extent) {
            const c = zi(i.extent, r.projection);
            s = Ai(c, t.extent), o = s && !Pr(c, t.extent), o && this.clipUnrotated(a, t, c);
          }
          const l = this.getLayer(), u = l.getWindOptions(), h = l.getData();
          return this.execute(this.context, t, u, h), this.postRender(this.context, t), o && a.restore(), a.imageSmoothingEnabled = true, this.container;
        }
        setOptions(t) {
          this.wind && this.wind.setOptions(t);
        }
        setData(t) {
          this.wind && this.wind.updateData(t);
        }
        execute(t, e, i, r) {
          this.wind || (this.wind = new fb(t, i, r), this.wind.project = this.getPixelFromCoordinateInternal.bind(this), this.wind.unproject = this.getCoordinateFromPixel.bind(this), this.wind.intersectsCoordinate = this.intersectsCoordinate.bind(this), this.wind.postrender = () => {
          }, this.wind.prerender());
        }
        getPixelFromCoordinateInternal(t) {
          const e = this.frameState;
          if (e) {
            const i = e.viewState, r = e.pixelRatio, a = po(t, "EPSG:4326", i.projection), o = ke(a, i.projection), s = nn(e.coordinateToPixelTransform, o.slice(0, 2));
            return [s[0] * r, s[1] * r];
          } else return null;
        }
        getCoordinateFromPixel(t) {
          const e = this.frameState;
          if (e) {
            const i = e.viewState, r = nn(e.pixelToCoordinateTransform, t.slice(0, 2)), a = vo(r, i.projection), o = po(a, i.projection, "EPSG:4326");
            return [o[0], o[1]];
          } else return null;
        }
        intersectsCoordinate(t) {
          const e = this.frameState;
          if (e) {
            const i = e.viewState, r = po(t, "EPSG:4326", i.projection), a = ke(r, i.projection);
            return Jr(e.extent, a.slice(0, 2));
          }
          return true;
        }
      }
      const Eyt = { forceRender: true, windOptions: {} };
      class Iyt extends Zu {
        constructor(t, e) {
          const i = hb({}, Eyt, e);
          super(i), this.options = i, this.className_ = e.className !== void 0 ? e.className : "wind-layer", this.pickWindOptions(), t && this.setData(t, e.fieldOptions);
        }
        appendTo(t) {
          t.addLayer(this);
        }
        onAdd() {
          var e;
          const t = this.getRenderer();
          t && ((e = t.wind) == null || e.start());
        }
        onRemove() {
          const t = this.getRenderer();
          t && t.wind.stop();
        }
        createRenderer() {
          return new _yt(this);
        }
        getRenderer() {
          return super.getRenderer();
        }
        pickWindOptions() {
          Object.keys(Pz).forEach((t) => {
            t in this.options && (this.options.windOptions === void 0 && (this.options.windOptions = {}), this.options.windOptions[t] = this.options[t]);
          });
        }
        getData() {
          return this.field;
        }
        setData(t, e = {}) {
          t && t.checkFields && t.checkFields() ? this.field = t : pyt(t) && (this.field = myt(t, e));
          const i = this.getRenderer();
          return i && this.field && i.setData(this.field), this.changed(), this;
        }
        setWindOptions(t) {
          const e = this.options.windOptions || {};
          this.options = hb(this.options, { windOptions: hb(e, t || {}) });
          const i = this.getRenderer();
          if (i) {
            const r = this.options.windOptions;
            i.setOptions(r);
          }
          this.changed();
        }
        getWindOptions() {
          return this.options.windOptions || {};
        }
        render(t, e) {
          const i = this.getRenderer();
          return i && i.prepareFrame(t) ? (this.rendered = true, i.renderFrame(t, e)) : null;
        }
        setMapInternal(t) {
          super.setMapInternal(t), t ? this.onAdd() : this.onRemove();
        }
        setMap(t) {
          super.setMap(t), t ? this.onAdd() : this.onRemove();
        }
      }
      const gb = P.defineComponent({ name: "OlWind", __name: "index", props: { layerId: {}, data: {}, forceRender: { type: Boolean, default: true }, windOptions: {}, fieldOptions: {}, className: {}, opacity: {}, visible: { type: Boolean }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, renderOrder: {}, renderBuffer: {}, map: {}, declutter: { type: [String, Number, Boolean] }, background: {}, updateWhileAnimating: { type: Boolean }, updateWhileInteracting: { type: Boolean }, properties: {} }, emits: ["mount", "singleclick", "pointermove"], setup(n, { expose: t, emit: e }) {
        const i = P.inject("VMap"), r = P.unref(i).map, a = n, o = P.shallowRef(), s = e;
        function l(A) {
          if (A < 0.3) return 0;
          if (A >= 0.3 && A < 1.6) return 1;
          if (A >= 1.6 && A < 3.4) return 2;
          if (A >= 3.4 && A < 5.5) return 3;
          if (A >= 5.5 && A < 8) return 4;
          if (A >= 8 && A < 10.8) return 5;
          if (A >= 10.8 && A < 13.9) return 6;
          if (A >= 13.9 && A < 17.2) return 7;
          if (A >= 17.2 && A < 20.8) return 8;
          if (A >= 20.8 && A < 24.5) return 9;
          if (A >= 24.5 && A < 28.5) return 10;
          if (A >= 28.5 && A < 32.7) return 11;
          if (A >= 32.7 && A < 37) return 12;
          if (A >= 37 && A < 41.5) return 13;
          if (A >= 41.5 && A < 46.2) return 14;
          if (A >= 46.2 && A < 51) return 15;
          if (A >= 51 && A < 56.1) return 16;
          if (A >= 56.1 && A < 61.2) return 17;
          if (A >= 61.2) return 18;
        }
        function u(A) {
          if (A >= 0 && A <= 22.5 || A <= 360 && A > 337.5) return "";
          if (A <= 337.5 && A > 292.5) return "";
          if (A <= 292.5 && A > 247.5) return "";
          if (A <= 247.5 && A > 202.5) return "";
          if (A <= 202.5 && A > 157.5) return "";
          if (A <= 157.5 && A > 112.5) return "";
          if (A <= 112.5 && A > 67.5) return "";
          if (A <= 67.5 && A > 22.5) return "";
        }
        const h = () => {
          o.value = new Iyt(a.data, { windOptions: a.windOptions, forceRender: a.forceRender, fieldOptions: a.fieldOptions }), Rs(o.value, a).onMounted(), o.value.setMap(r), r.on("singleclick", (A) => {
            const p = c(A), v = Object.assign({}, rt({}, A), { coordinate: A.coordinate, pixel: A.pixel });
            s("singleclick", Qt(rt({}, v), { data: p }));
          }), r.on("pointermove", (A) => {
            const p = c(A), v = Object.assign({}, rt({}, A), { coordinate: A.coordinate, pixel: A.pixel });
            s("pointermove", Qt(rt({}, v), { data: p }));
          }), s("mount", o.value);
        }, c = (A) => {
          var y;
          const v = ((y = o.value) == null ? void 0 : y.field).valueAt(A.coordinate[0], A.coordinate[1]);
          if (v) {
            const { u: m, v: _, m: I } = v, E = new cb(m, _);
            return { u: m, v: _, m: I, directionTo: E.directionTo(), directionFrom: E.directionFrom(), windLevel: `${l(I)}`, windDirection: u(E.directionFrom()) };
          } else return null;
        };
        P.watch(() => a.data, (A) => {
          var p;
          (p = o.value) == null || p.setData(A);
        }, { deep: true }), P.watch(() => a.windOptions, (A) => {
          var p;
          A && ((p = o.value) == null || p.setWindOptions(A));
        }, { deep: true }), P.watchEffect(() => {
          Rs(o.value, a);
        });
        const f = () => {
          r == null || r.removeLayer(o.value), o.value = null;
        };
        return t({ getData: () => {
          var A;
          return (A = o.value) == null ? void 0 : A.getData();
        }, getWindOptions: () => {
          var A;
          return (A = o.value) == null ? void 0 : A.getWindOptions();
        } }), P.onMounted(() => {
          h();
        }), P.onUnmounted(() => {
          f();
        }), (A, p) => P.renderSlot(A.$slots, "default");
      } }), xyt = (n) => n.component(gb.name || "OlWind", gb), db = P.defineComponent({ name: "OlWfs", __name: "index", props: { options: { default: () => ({ featureNS: "", featurePrefix: "", featureTypes: [], outputFormat: "application/json", maxFeatures: 1 / 0 }) } }, setup(n) {
        const t = P.inject("ParentLayer"), e = n, i = () => {
          const r = new Y3().writeGetFeature(Qt(rt({}, e.options), { outputFormat: "application/json" }));
          fetch(e.options.featureNS, { method: "POST", body: new XMLSerializer().serializeToString(r) }).then(function(a) {
            return a.json();
          }).then((a) => {
            var s;
            const o = new ag().readFeatures(a);
            if (t && P.unref(t)) {
              const l = (s = P.unref(t)) == null ? void 0 : s.getSource();
              l && l.addFeatures(o);
            }
          });
        };
        return P.onMounted(() => {
          i();
        }), (r, a) => P.renderSlot(r.$slots, "default");
      } }), wyt = (n) => n.component(db.name || "OlWfs", db), Ab = P.defineComponent({ name: "OlWms", __name: "index", props: { tileGrid: {}, attributions: {}, attributionsCollapsible: { type: Boolean }, cacheSize: {}, crossOrigin: {}, interpolate: { type: Boolean }, params: {}, gutter: {}, hidpi: { type: Boolean }, projection: {}, reprojectionErrorThreshold: {}, tileClass: {}, serverType: {}, tileLoadFunction: {}, url: {}, urls: {}, wrapX: { type: Boolean }, transition: {}, zDirection: {}, imageLoadFunction: {}, ratio: {}, resolutions: {} }, emits: ["singleclick"], setup(n, { emit: t }) {
        const e = P.inject("VMap"), i = P.unref(e).map, r = P.inject("ParentTileLayer"), a = n, o = t, s = () => {
          var l;
          if (r.value) {
            const u = (l = r.value) == null ? void 0 : l.get("layerTypeName");
            let h, c;
            if (a.tileGrid && (h = new $f(a.tileGrid)), u === "ImageLayer") {
              const f = Qt(rt({}, a), { tileGrid: h });
              c = new hct(f), r.value.setSource(c);
            } else if (u === "TileLayer") {
              const f = Qt(rt({}, a), { tileGrid: h });
              c = new pct(f), r.value.setSource(c);
            }
            if (!c) return;
            i.on("pointermove", function(f) {
              if (f.dragging) return;
              const g = r.value.getData(f.pixel), d = g && g[3] > 0;
              i.getTargetElement().style.cursor = d ? "pointer" : "";
            }), i.on("singleclick", (f) => {
              const g = i.getView(), d = g.getResolution();
              if (!d) return;
              const A = c == null ? void 0 : c.getFeatureInfoUrl(f.coordinate, d, g.getProjection().getCode(), { INFO_FORMAT: "application/json" });
              A && fetch(A).then((p) => p.json()).then((p) => {
                o("singleclick", f, p);
              });
            });
          }
        };
        return P.onMounted(() => {
          s();
        }), (l, u) => P.renderSlot(l.$slots, "default");
      } }), Cyt = (n) => n.component(Ab.name || "OlWms", Ab), pb = P.defineComponent({ name: "OlHeatmap", __name: "index", props: { layerId: { default: `vector-layer-${Gl()}` }, source: {}, className: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, gradient: { default: () => ["#00f", "#0ff", "#0f0", "#ff0", "#f00"] }, radius: { default: 8 }, blur: { default: 15 }, weight: { type: [String, Function], default: "weight" }, properties: {} }, emits: ["singleclick", "pointermove", "sourceready", "featuresloadend", "featuresloadstart", "addfeature"], setup(n, { emit: t }) {
        const e = n, i = P.inject("VMap"), r = P.unref(i).map;
        let a = P.shallowRef(), o = P.shallowRef(), s = P.ref([]);
        const l = ["singleclick", "pointermove"], u = t;
        let h = P.ref(false);
        P.provide("ParentLayer", a), P.watchEffect(() => {
          Rs(a.value, e);
        }), P.watch(() => e.blur, (A) => {
          var p;
          (a.value || A === 0) && ((p = a.value) == null || p.setBlur(A));
        }), P.watch(() => e.radius, (A) => {
          var p;
          (a.value || A === 0) && ((p = a.value) == null || p.setRadius(A));
        }), P.watch(() => e.gradient, (A) => {
          var p;
          a.value && ((p = a.value) == null || p.setGradient(A));
        }, { deep: true }), P.watch(() => e.source, () => {
          var A;
          (A = o.value) == null || A.clear(), a.value && r.removeLayer(a.value), c();
        });
        const c = () => {
          o.value = new oa(rt({}, e.source)), o.value.once("addfeature", () => {
            u("addfeature", a.value, o.value);
          }), a.value = new xct(Qt(rt({}, e), { source: o.value })), a.value.set("id", e.layerId), r.addLayer(a.value), l.forEach((A) => {
            s.value.push(r.on(A, (p) => {
              f(A, p);
            }));
          }), a.value.on("sourceready", () => {
            h.value = true, u("sourceready", a.value);
          });
        }, f = (A, p) => {
          const { pixel: v } = p, y = g(v);
          u(A, p, y);
        }, g = (A) => r.forEachFeatureAtPixel(A, (p) => p, { layerFilter: (p) => {
          var v;
          return p.get("id") === ((v = a.value) == null ? void 0 : v.get("id"));
        } }), d = () => {
          s.value.forEach((A) => {
            yl(A);
          });
        };
        return P.onMounted(() => {
          c();
        }), P.onBeforeUnmount(() => {
          d();
        }), (A, p) => P.unref(h) ? P.renderSlot(A.$slots, "default", { key: 0 }) : P.createCommentVNode("", true);
      } }), Syt = (n) => n.component(pb.name || "OlHeatmap", pb), vb = P.defineComponent({ name: "OlTiff", __name: "index", props: { source: {}, layerStyle: {}, className: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, preload: {}, sources: {}, map: {}, useInterimTilesOnError: { type: Boolean }, cacheSize: {}, properties: {} }, setup(n) {
        const t = n, e = P.inject("VMap"), i = P.unref(e).map, r = new jQ(t.source), a = new VC(Qt(rt({}, t), { source: r }));
        return P.watchEffect(() => {
          Rs(a, t);
        }), P.onMounted(() => {
          i.addLayer(a);
        }), (o, s) => P.renderSlot(o.$slots, "default");
      } }), byt = (n) => n.component(vb.name || "OlTiff", vb), kz = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], yb = 1, Ip = 8;
      class mb {
        static from(t) {
          if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
          const [e, i] = new Uint8Array(t, 0, 2);
          if (e !== 219) throw new Error("Data does not appear to be in a KDBush format.");
          const r = i >> 4;
          if (r !== yb) throw new Error(`Got v${r} data when expected v${yb}.`);
          const a = kz[i & 15];
          if (!a) throw new Error("Unrecognized array type.");
          const [o] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
          return new mb(s, o, a, t);
        }
        constructor(t, e = 64, i = Float64Array, r) {
          if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
          this.numItems = +t, this.nodeSize = Math.min(Math.max(+e, 2), 65535), this.ArrayType = i, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
          const a = kz.indexOf(this.ArrayType), o = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
          if (a < 0) throw new Error(`Unexpected typed array class: ${i}.`);
          r && r instanceof ArrayBuffer ? (this.data = r, this.ids = new this.IndexArrayType(this.data, Ip, t), this.coords = new this.ArrayType(this.data, Ip + s + l, t * 2), this._pos = t * 2, this._finished = true) : (this.data = new ArrayBuffer(Ip + o + s + l), this.ids = new this.IndexArrayType(this.data, Ip, t), this.coords = new this.ArrayType(this.data, Ip + s + l, t * 2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, (yb << 4) + a]), new Uint16Array(this.data, 2, 1)[0] = e, new Uint32Array(this.data, 4, 1)[0] = t);
        }
        add(t, e) {
          const i = this._pos >> 1;
          return this.ids[i] = i, this.coords[this._pos++] = t, this.coords[this._pos++] = e, i;
        }
        finish() {
          const t = this._pos >> 1;
          if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
          return _b(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
        }
        range(t, e, i, r) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: a, coords: o, nodeSize: s } = this, l = [0, a.length - 1, 0], u = [];
          for (; l.length; ) {
            const h = l.pop() || 0, c = l.pop() || 0, f = l.pop() || 0;
            if (c - f <= s) {
              for (let p = f; p <= c; p++) {
                const v = o[2 * p], y = o[2 * p + 1];
                v >= t && v <= i && y >= e && y <= r && u.push(a[p]);
              }
              continue;
            }
            const g = f + c >> 1, d = o[2 * g], A = o[2 * g + 1];
            d >= t && d <= i && A >= e && A <= r && u.push(a[g]), (h === 0 ? t <= d : e <= A) && (l.push(f), l.push(g - 1), l.push(1 - h)), (h === 0 ? i >= d : r >= A) && (l.push(g + 1), l.push(c), l.push(1 - h));
          }
          return u;
        }
        within(t, e, i) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: r, coords: a, nodeSize: o } = this, s = [0, r.length - 1, 0], l = [], u = i * i;
          for (; s.length; ) {
            const h = s.pop() || 0, c = s.pop() || 0, f = s.pop() || 0;
            if (c - f <= o) {
              for (let p = f; p <= c; p++) Qz(a[2 * p], a[2 * p + 1], t, e) <= u && l.push(r[p]);
              continue;
            }
            const g = f + c >> 1, d = a[2 * g], A = a[2 * g + 1];
            Qz(d, A, t, e) <= u && l.push(r[g]), (h === 0 ? t - i <= d : e - i <= A) && (s.push(f), s.push(g - 1), s.push(1 - h)), (h === 0 ? t + i >= d : e + i >= A) && (s.push(g + 1), s.push(c), s.push(1 - h));
          }
          return l;
        }
      }
      function _b(n, t, e, i, r, a) {
        if (r - i <= e) return;
        const o = i + r >> 1;
        Oz(n, t, o, i, r, a), _b(n, t, e, i, o - 1, 1 - a), _b(n, t, e, o + 1, r, 1 - a);
      }
      function Oz(n, t, e, i, r, a) {
        for (; r > i; ) {
          if (r - i > 600) {
            const u = r - i + 1, h = e - i + 1, c = Math.log(u), f = 0.5 * Math.exp(2 * c / 3), g = 0.5 * Math.sqrt(c * f * (u - f) / u) * (h - u / 2 < 0 ? -1 : 1), d = Math.max(i, Math.floor(e - h * f / u + g)), A = Math.min(r, Math.floor(e + (u - h) * f / u + g));
            Oz(n, t, e, d, A, a);
          }
          const o = t[2 * e + a];
          let s = i, l = r;
          for (xp(n, t, i, e), t[2 * r + a] > o && xp(n, t, i, r); s < l; ) {
            for (xp(n, t, s, l), s++, l--; t[2 * s + a] < o; ) s++;
            for (; t[2 * l + a] > o; ) l--;
          }
          t[2 * i + a] === o ? xp(n, t, i, l) : (l++, xp(n, t, l, r)), l <= e && (i = l + 1), e <= l && (r = l - 1);
        }
      }
      function xp(n, t, e, i) {
        Eb(n, e, i), Eb(t, 2 * e, 2 * i), Eb(t, 2 * e + 1, 2 * i + 1);
      }
      function Eb(n, t, e) {
        const i = n[t];
        n[t] = n[e], n[e] = i;
      }
      function Qz(n, t, e, i) {
        const r = n - e, a = t - i;
        return r * r + a * a;
      }
      const Tyt = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (n) => n }, zz = Math.fround || /* @__PURE__ */ ((n) => (t) => (n[0] = +t, n[0]))(new Float32Array(1)), ch = 2, jl = 3, Ib = 4, ql = 5, Gz = 6;
      class Byt {
        constructor(t) {
          this.options = Object.assign(Object.create(Tyt), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(t) {
          const { log: e, minZoom: i, maxZoom: r } = this.options, a = `prepare ${t.length} points`;
          this.points = t;
          const o = [];
          for (let l = 0; l < t.length; l++) {
            const u = t[l];
            if (!u.geometry) continue;
            const [h, c] = u.geometry.coordinates, f = zz(__(h)), g = zz(E_(c));
            o.push(f, g, 1 / 0, l, -1, 1), this.options.reduce && o.push(0);
          }
          let s = this.trees[r + 1] = this._createTree(o);
          for (let l = r; l >= i; l--) {
            const u = +Date.now();
            s = this.trees[l] = this._createTree(this._cluster(s, l));
          }
          return this;
        }
        getClusters(t, e) {
          let i = ((t[0] + 180) % 360 + 360) % 360 - 180;
          const r = Math.max(-90, Math.min(90, t[1]));
          let a = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
          const o = Math.max(-90, Math.min(90, t[3]));
          if (t[2] - t[0] >= 360) i = -180, a = 180;
          else if (i > a) {
            const c = this.getClusters([i, r, 180, o], e), f = this.getClusters([-180, r, a, o], e);
            return c.concat(f);
          }
          const s = this.trees[this._limitZoom(e)], l = s.range(__(i), E_(o), __(a), E_(r)), u = s.data, h = [];
          for (const c of l) {
            const f = this.stride * c;
            h.push(u[f + ql] > 1 ? Uz(u, f, this.clusterProps) : this.points[u[f + jl]]);
          }
          return h;
        }
        getChildren(t) {
          const e = this._getOriginId(t), i = this._getOriginZoom(t), r = "No cluster with the specified id.", a = this.trees[i];
          if (!a) throw new Error(r);
          const o = a.data;
          if (e * this.stride >= o.length) throw new Error(r);
          const s = this.options.radius / (this.options.extent * Math.pow(2, i - 1)), l = o[e * this.stride], u = o[e * this.stride + 1], h = a.within(l, u, s), c = [];
          for (const f of h) {
            const g = f * this.stride;
            o[g + Ib] === t && c.push(o[g + ql] > 1 ? Uz(o, g, this.clusterProps) : this.points[o[g + jl]]);
          }
          if (c.length === 0) throw new Error(r);
          return c;
        }
        getLeaves(t, e, i) {
          e = e || 10, i = i || 0;
          const r = [];
          return this._appendLeaves(r, t, e, i, 0), r;
        }
        getTile(t, e, i) {
          const r = this.trees[this._limitZoom(t)], a = Math.pow(2, t), { extent: o, radius: s } = this.options, l = s / o, u = (i - l) / a, h = (i + 1 + l) / a, c = { features: [] };
          return this._addTileFeatures(r.range((e - l) / a, u, (e + 1 + l) / a, h), r.data, e, i, a, c), e === 0 && this._addTileFeatures(r.range(1 - l / a, u, 1, h), r.data, a, i, a, c), e === a - 1 && this._addTileFeatures(r.range(0, u, l / a, h), r.data, -1, i, a, c), c.features.length ? c : null;
        }
        getClusterExpansionZoom(t) {
          let e = this._getOriginZoom(t) - 1;
          for (; e <= this.options.maxZoom; ) {
            const i = this.getChildren(t);
            if (e++, i.length !== 1) break;
            t = i[0].properties.cluster_id;
          }
          return e;
        }
        _appendLeaves(t, e, i, r, a) {
          const o = this.getChildren(e);
          for (const s of o) {
            const l = s.properties;
            if (l && l.cluster ? a + l.point_count <= r ? a += l.point_count : a = this._appendLeaves(t, l.cluster_id, i, r, a) : a < r ? a++ : t.push(s), t.length === i) break;
          }
          return a;
        }
        _createTree(t) {
          const e = new mb(t.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let i = 0; i < t.length; i += this.stride) e.add(t[i], t[i + 1]);
          return e.finish(), e.data = t, e;
        }
        _addTileFeatures(t, e, i, r, a, o) {
          for (const s of t) {
            const l = s * this.stride, u = e[l + ql] > 1;
            let h, c, f;
            if (u) h = Vz(e, l, this.clusterProps), c = e[l], f = e[l + 1];
            else {
              const A = this.points[e[l + jl]];
              h = A.properties;
              const [p, v] = A.geometry.coordinates;
              c = __(p), f = E_(v);
            }
            const g = { type: 1, geometry: [[Math.round(this.options.extent * (c * a - i)), Math.round(this.options.extent * (f * a - r))]], tags: h };
            let d;
            u || this.options.generateId ? d = e[l + jl] : d = this.points[e[l + jl]].id, d !== void 0 && (g.id = d), o.features.push(g);
          }
        }
        _limitZoom(t) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
        }
        _cluster(t, e) {
          const { radius: i, extent: r, reduce: a, minPoints: o } = this.options, s = i / (r * Math.pow(2, e)), l = t.data, u = [], h = this.stride;
          for (let c = 0; c < l.length; c += h) {
            if (l[c + ch] <= e) continue;
            l[c + ch] = e;
            const f = l[c], g = l[c + 1], d = t.within(l[c], l[c + 1], s), A = l[c + ql];
            let p = A;
            for (const v of d) {
              const y = v * h;
              l[y + ch] > e && (p += l[y + ql]);
            }
            if (p > A && p >= o) {
              let v = f * A, y = g * A, m, _ = -1;
              const I = ((c / h | 0) << 5) + (e + 1) + this.points.length;
              for (const E of d) {
                const x = E * h;
                if (l[x + ch] <= e) continue;
                l[x + ch] = e;
                const w = l[x + ql];
                v += l[x] * w, y += l[x + 1] * w, l[x + Ib] = I, a && (m || (m = this._map(l, c, true), _ = this.clusterProps.length, this.clusterProps.push(m)), a(m, this._map(l, x)));
              }
              l[c + Ib] = I, u.push(v / p, y / p, 1 / 0, I, -1, p), a && u.push(_);
            } else {
              for (let v = 0; v < h; v++) u.push(l[c + v]);
              if (p > 1) for (const v of d) {
                const y = v * h;
                if (!(l[y + ch] <= e)) {
                  l[y + ch] = e;
                  for (let m = 0; m < h; m++) u.push(l[y + m]);
                }
              }
            }
          }
          return u;
        }
        _getOriginId(t) {
          return t - this.points.length >> 5;
        }
        _getOriginZoom(t) {
          return (t - this.points.length) % 32;
        }
        _map(t, e, i) {
          if (t[e + ql] > 1) {
            const o = this.clusterProps[t[e + Gz]];
            return i ? Object.assign({}, o) : o;
          }
          const r = this.points[t[e + jl]].properties, a = this.options.map(r);
          return i && a === r ? Object.assign({}, a) : a;
        }
      }
      function Uz(n, t, e) {
        return { type: "Feature", id: n[t + jl], properties: Vz(n, t, e), geometry: { type: "Point", coordinates: [Myt(n[t]), Dyt(n[t + 1])] } };
      }
      function Vz(n, t, e) {
        const i = n[t + ql], r = i >= 1e4 ? `${Math.round(i / 1e3)}k` : i >= 1e3 ? `${Math.round(i / 100) / 10}k` : i, a = n[t + Gz], o = a === -1 ? {} : Object.assign({}, e[a]);
        return Object.assign(o, { cluster: true, cluster_id: n[t + jl], point_count: i, point_count_abbreviated: r });
      }
      function __(n) {
        return n / 360 + 0.5;
      }
      function E_(n) {
        const t = Math.sin(n * Math.PI / 180), e = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
        return e < 0 ? 0 : e > 1 ? 1 : e;
      }
      function Myt(n) {
        return (n - 0.5) * 360;
      }
      function Dyt(n) {
        const t = (180 - n * 360) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
      }
      const fh = P.defineComponent({ name: "OlFeature", props: { geometries: { type: Array, default: void 0 }, geoJson: { type: Object, default: void 0 }, options: { type: Object, default: void 0 } }, setup(n, { expose: t }) {
        const e = P.inject("VMap"), i = P.unref(e).map, r = P.inject("ParentLayer");
        let a, o = P.ref();
        const s = () => {
          let v = r.value.getSource();
          if (r.value.get("cluster") && r.value.getSource() && (v = r.value.getSource().getSource()), v) {
            const y = r.value.get("superCluster");
            if (y) {
              a = new Byt(y);
              let m = [];
              n.geoJson && m.push(...u("Point")), n.geometries && n.geometries.length > 0 && m.push(...d("Point"));
              const _ = new ag().writeFeaturesObject(m);
              a.load(_.features);
              const I = i.getView().calculateExtent(i.getSize()), E = a.getClusters(I, i.getView().getZoom() || 0), x = new ag().readFeatures({ type: "FeatureCollection", features: E }).map((w) => {
                const C = w.get("properties");
                if (C && typeof C == "object") for (const S in C) Object.prototype.hasOwnProperty.call(C, S) && w.set(S, C[S]);
                return w;
              });
              v.addFeatures(x), i.on("precompose", () => {
                const w = i.getView().calculateExtent(i.getSize()), S = { type: "FeatureCollection", features: a.getClusters(w, i.getView().getZoom() || 0) }, b = r.value.getSource();
                b && (b.clear(), b.addFeatures(new ag().readFeatures(S).map((T) => {
                  const B = T.get("properties");
                  if (B && typeof B == "object") for (const M in B) Object.prototype.hasOwnProperty.call(B, M) && T.set(M, B[M]);
                  const R = T.get("style");
                  return R && y_(T, R, i), T;
                })));
              });
            } else n.geoJson && l(v, r.value.get("cluster") ? "Point" : void 0), n.geometries && n.geometries.length > 0 && f(v, r.value.get("cluster") ? "Point" : void 0);
          }
        }, l = (v, y) => {
          const m = u(y);
          m && m.length > 0 && (o.value = m, v.addFeatures(m));
        }, u = (v) => {
          let y, m, _;
          const I = v ? h(v) : n.geoJson, E = n.options;
          return E && E.dataProjection && (y = new Oi(E.dataProjection)), E && E.featureProjection && (m = new Oi(E.featureProjection)), E && E.extent && (_ = E.extent), new ag().readFeatures(I, E ? { extent: _, dataProjection: y, featureProjection: m } : void 0).map((w) => {
            const C = w.get("style"), S = w.get("id");
            return C && y_(w, C, i), S && !w.getId() && w.setId(S), w;
          });
        }, h = (v) => {
          const y = n.geoJson;
          if (y) return y.type === "FeatureCollection" ? { type: "FeatureCollection", features: y.features.filter((m) => m.geometry.type === v) } : y.type === "Feature" ? y.geometry.type === v ? y : null : y.type === v ? y : null;
        }, c = (v) => {
          const y = i.getView().getProjection().getMetersPerUnit();
          return v && y ? v / y : 0;
        }, f = (v, y) => {
          const m = d(y);
          m && m.length > 0 && (o.value = m, v.addFeatures(m));
        }, g = (v) => {
          if (v.type === "Point") return new Ge(v.geometry.coordinates);
          if (v.type === "MultiPoint") return new fr(v.geometry.coordinates);
          if (v.type === "Circle") {
            const y = v.geometry, m = c(y.radius);
            return new MA(y.center, m);
          } else {
            if (v.type === "Polygon") return new Dn(v.geometry.coordinates);
            if (v.type === "LineString") return new Be(v.geometry.coordinates);
            if (v.type === "MultiPolygon") return new bi(v.geometry.coordinates);
            if (v.type === "MultiLineString") return new ui(v.geometry.coordinates);
            if (v.type === "LinearRing") return new mo(v.geometry.coordinates);
          }
        }, d = (v) => {
          const y = n.geometries;
          if (!y) return [];
          let m = [];
          return y.forEach((_) => {
            if (_.type === "GeometryCollection") {
              let I = [];
              _.geometry.geometries.forEach((x) => {
                const w = v || _.type, C = g({ type: w, geometry: x });
                C && I.push(C);
              });
              const E = new wn(I);
              m.push(new Ce(rt({ geometry: E }, _.properties)));
            } else {
              if (v && _.type !== v) return;
              const I = new Ce(rt({ geometry: g(_) }, _.properties));
              m.push(I);
            }
          }), m.map((_) => {
            const I = _.get("style"), E = _.get("id");
            return I && y_(_, I, i), E && !_.getId() && _.setId(E), _;
          });
        }, A = (v, y, m) => {
          if (a) return a.getLeaves(v, y, m);
          throw new Error("SuperCluster is not initialized");
        }, p = (v) => {
          if (!r) return;
          let y = r.value.getSource();
          r.value.get("cluster") && r.value.getSource() && (y = r.value.getSource().getSource()), y == null || y.clear(), v && s();
        };
        return P.watch(() => n.geoJson, (v) => {
          p(v);
        }, { deep: true }), P.watch(() => n.geometries, (v) => {
          p(v);
        }, { deep: true }), P.onMounted(() => {
          r && s();
        }), t({ getLeaves: A }), { getLeaves: A };
      }, render() {
        return null;
      } }), Ryt = (n) => n.component(fh.name || "OlFeature", fh), xb = P.defineComponent({ name: "OlCluster", __name: "index", props: { layerId: { default: `vector-layer-${Gl()}` }, source: {}, clusterOptions: { default: () => ({}) }, clusterStyle: { default: () => ({}) }, layerStyle: { default: () => ({}) }, superCluster: { default: void 0 }, className: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, renderOrder: {}, renderBuffer: {}, map: {}, declutter: { type: [String, Number, Boolean] }, style: {}, background: {}, updateWhileAnimating: { type: Boolean }, updateWhileInteracting: { type: Boolean }, properties: {} }, emits: ["singleclick", "pointermove", "sourceready", "featuresloadend", "featuresloadstart", "addfeature"], setup(n, { emit: t }) {
        const e = n, i = P.inject("VMap"), r = P.unref(i).map;
        let a = P.shallowRef(), o = P.shallowRef(), s = P.shallowRef(), l = P.ref([]);
        const u = ["singleclick", "pointermove"], h = t;
        let c = P.ref(false);
        P.provide("ParentLayer", a), P.watchEffect(() => {
          Rs(a.value, e);
        });
        const f = (v, y) => {
          const m = Qt(rt({}, v.text), { text: y });
          return Qt(rt({}, v), { text: m });
        }, g = () => {
          var v, y, m, _;
          if (o.value = new oa(rt({}, e.source)), e.superCluster) {
            const I = {}, E = ((y = (v = s == null ? void 0 : s.value) == null ? void 0 : v.getSource()) == null ? void 0 : y.getFeatures().length) || 0;
            a.value = new aa(Qt(rt({}, e), { source: o.value, style: (x) => {
              const w = x.get("cluster") || 0, C = x.get("point_count_abbreviated") || 0;
              let S = I[C];
              if (w) {
                if (!S) {
                  let b = {};
                  b = { image: new kr({ radius: 4, fill: new me({ color: "blue" }) }), text: new Si({ font: "16px sans-serif", text: C.toString() }) }, e.clusterStyle ? (b = e.clusterStyle, b instanceof Array ? (b.forEach((T) => {
                    let B = 0, R = E;
                    if (Nn(T, "min") || Nn(T, "max")) B = T.min, R = T.max, B < C && C <= R && (b = f(T, C.toString()));
                    else if (E > 0) {
                      const M = E / b.style.length;
                      for (let L = 0; L < b.style.length; L++) B = L * M, R = M * (L + 1), B < C && C <= R && (b = f(b.style[L], C.toString()));
                    }
                  }), S = uh(b)) : (b = f(b, C.toString()), S = uh(b))) : S = new pe(b), I[C] = S;
                }
              } else S = uh(e.layerStyle);
              return S;
            } })), a.value.set("superCluster", e.superCluster);
          } else {
            s.value = new rut(Qt(rt({}, e.clusterOptions), { source: o.value }));
            const I = {}, E = ((_ = (m = s == null ? void 0 : s.value) == null ? void 0 : m.getSource()) == null ? void 0 : _.getFeatures().length) || 0;
            a.value = new aa(Qt(rt({}, e), { source: s.value, style: function(x) {
              const w = x.get("features").length;
              let C = I[w];
              if (w > 1) {
                if (!C) {
                  let S = {};
                  S = e.clusterStyle, !S || Object.keys(S).length === 0 ? (S = { image: new kr({ radius: 20, stroke: new Ke({ color: "#fff" }), fill: new me({ color: "#3399CC" }) }), text: new Si({ font: "16px sans-serif", text: w.toString(), fill: new me({ color: "#fff" }) }) }, C = new pe(S)) : S instanceof Array ? (S.forEach((b) => {
                    let T = 0, B = E;
                    if (Nn(b, "min") || Nn(b, "max")) T = b.min, B = b.max, T < w && w <= B && (S = f(b, w.toString()));
                    else if (E > 0) {
                      const R = E / S.style.length;
                      for (let M = 0; M < S.style.length; M++) T = M * R, B = R * (M + 1), T < w && w <= B && (S = f(S.style[M], w.toString()));
                    }
                  }), C = uh(S)) : (S = f(S, w.toString()), C = uh(S)), I[w] = C;
                }
              } else C = uh(e.layerStyle);
              return C;
            } })), a.value.set("cluster", true);
          }
          a.value.set("id", e.layerId), r.addLayer(a.value), u.forEach((I) => {
            l.value.push(r.on(I, (E) => {
              d(I, E);
            }));
          }), a.value.on("sourceready", () => {
            c.value = true, h("sourceready", a.value);
          });
        }, d = (v, y) => {
          const { pixel: m } = y, _ = A(m);
          h(v, y, _);
        }, A = (v) => r.forEachFeatureAtPixel(v, (y) => y, { layerFilter: (y) => {
          var m;
          return y.get("id") === ((m = a.value) == null ? void 0 : m.get("id"));
        } }), p = () => {
          l.value.forEach((v) => {
            yl(v);
          });
        };
        return P.onMounted(() => {
          g();
        }), P.onBeforeUnmount(() => {
          p();
        }), (v, y) => P.unref(c) ? P.renderSlot(v.$slots, "default", { key: 0 }) : P.createCommentVNode("", true);
      } }), Lyt = (n) => n.component(xb.name || "OlCluster", xb), wb = P.defineComponent({ name: "OlOverlay", __name: "index", props: { overlayId: { default: `overlay-${Gl()}` }, data: { default: () => ({}) }, id: {}, element: {}, offset: { default: () => [0, 0] }, position: { default: void 0 }, positioning: {}, stopEvent: { type: Boolean }, insertFirst: { type: Boolean }, autoPan: { type: [Boolean, Object] }, className: {} }, emits: ["load"], setup(n, { emit: t }) {
        const e = n;
        let i = P.shallowRef();
        const r = P.inject("VMap"), a = P.unref(r).map, o = t, s = `overlay-el-${Gl()}`;
        P.watch(() => e.position, (u) => {
          i.value.setPosition(u);
        }, { deep: true, immediate: false });
        const l = () => {
          let u = e.element ? e.element : document.getElementById(s.toString());
          const h = Qt(rt({}, e), { id: e.overlayId, element: u });
          i.value = new YF(h);
          const c = rt({}, h);
          for (const f in c) Object.prototype.hasOwnProperty.call(c, f) && i.value.set(f, c[f]);
          a.addOverlay(i.value), o("load", i.value, a);
        };
        return P.onMounted(() => {
          l();
        }), (u, h) => (P.openBlock(), P.createElementBlock("div", P.mergeProps({ id: s, ref: "overlayRef" }, u.$attrs), [P.renderSlot(u.$slots, "default", { data: u.data })], 16));
      } }), Pyt = (n) => n.component(wb.name || "OlOverlay", wb), Cb = P.defineComponent({ name: "OlOverview", __name: "index", props: { className: {}, collapsed: { type: Boolean, default: false }, collapseLabel: {}, collapsible: { type: Boolean, default: true }, label: {}, layers: {}, render: {}, rotateWithView: { type: Boolean }, target: {}, tipLabel: {}, view: {}, tileType: { default: "TDT" }, layerId: { default: `tile-layer-${Gl()}` }, source: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, preload: {}, map: {}, background: {}, useInterimTilesOnError: { type: Boolean }, properties: {}, cacheSize: {} }, setup(n) {
        const t = n, { init: e, setOverviewMapOptions: i } = JQ(t);
        return P.watchEffect(() => {
          i(rt({}, t)).then(() => {
            e(true);
          });
        }), (r, a) => P.renderSlot(r.$slots, "default");
      } }), Nyt = (n) => n.component(Cb.name || "OlOverview", Cb), Sb = P.defineComponent({ name: "OlZoomSlider", __name: "index", props: { className: {}, duration: {}, render: {}, target: {} }, setup(n) {
        const t = n, e = P.inject("VMap"), i = P.unref(e).map, r = P.shallowRef(), a = () => {
          r.value = new Het(rt({}, t)), i.addControl(r.value);
        };
        return P.watchEffect(() => {
          r.value && i.removeControl(r.value), a();
        }), (o, s) => P.renderSlot(o.$slots, "default");
      } }), Fyt = (n) => n.component(Sb.name || "OlZoomSlider", Sb), bb = P.defineComponent({ name: "OlFullScreen", __name: "index", props: { className: {}, label: {}, labelActive: {}, activeClassName: {}, inactiveClassName: {}, tipLabel: {}, keys: { type: Boolean }, target: {}, source: {} }, setup(n) {
        const t = P.inject("VMap"), e = P.unref(t).map, i = n, r = P.shallowRef(), a = () => {
          r.value = new Qet(rt({}, i)), e.addControl(r.value);
        };
        return P.watchEffect(() => {
          r.value && e.removeControl(r.value), a();
        }), (o, s) => P.renderSlot(o.$slots, "default");
      } }), kyt = (n) => n.component(bb.name || "OlFullScreen", bb), Tb = P.defineComponent({ name: "OlScaleLine", __name: "index", props: { className: {}, minWidth: {}, maxWidth: {}, render: {}, target: {}, units: {}, bar: { type: Boolean }, steps: {}, text: { type: Boolean }, dpi: {} }, setup(n) {
        const t = P.inject("VMap"), e = P.unref(t).map, i = n, r = P.shallowRef(), a = () => {
          r.value = new qet(rt({}, i)), e.addControl(r.value);
        };
        return P.watchEffect(() => {
          r.value && e.removeControl(r.value), a();
        }), (o, s) => P.renderSlot(o.$slots, "default");
      } }), Oyt = (n) => n.component(Tb.name || "OlScaleLine", Tb), Bb = P.defineComponent({ name: "OlMousePosition", __name: "index", props: { coordinateFormat: { default: 6 }, className: {}, projection: {}, render: {}, placeholder: {}, wrapX: { type: Boolean } }, setup(n) {
        const t = P.inject("VMap"), e = P.unref(t).map, i = n, r = P.shallowRef(), a = P.ref(), o = () => {
          var s;
          r.value = new Uet(Qt(rt({}, i), { coordinateFormat: tK(Number(i.coordinateFormat)) })), e.addControl(r.value), (s = a.value) == null || s.remove();
        };
        return P.watchEffect(() => {
          r.value && e.removeControl(r.value), o();
        }), (s, l) => P.renderSlot(s.$slots, "default");
      } }), Qyt = (n) => n.component(Bb.name || "OlMousePosition", Bb), zyt = { class: "form-item" }, Gyt = { class: "form-item" }, Uyt = P.defineComponent({ __name: "index", props: { type: { default: "Point" }, feature: { default: void 0 }, pinClass: { default: "overlay-pin" }, titleClass: { default: "" }, bodyClass: { default: "" }, footerClass: { default: "" } }, emits: ["save"], setup(n, { emit: t }) {
        const e = P.inject("VMap"), i = P.unref(e).map, r = P.inject("ParentLayer"), a = n, o = { Point: "", Polygon: "" };
        let s = P.ref(void 0);
        const l = (p) => {
          var v;
          if (p) {
            if (p.get("type") === "Point") return (v = p.getGeometry()) == null ? void 0 : v.getCoordinates();
            {
              const { topCenter: y } = RO(p.getGeometry());
              return y;
            }
          }
        };
        P.watch(() => a.feature, (p) => {
          u.value = "", h.value = "", c.value = void 0, s.value = void 0, p && (f.value = p.get("type") ? p.get("type") : a.type, s.value = l(p));
        });
        let u = P.shallowRef(""), h = P.shallowRef(""), c = P.shallowRef(void 0), f = P.shallowRef("Point");
        const g = t, d = () => {
          var m;
          const p = c.value ? c.value : a.feature;
          p == null || p.set("name", u.value), p == null || p.set("remark", h.value), p == null || p.set("type", (m = p == null ? void 0 : p.get("type")) != null ? m : a.type), p == null || p.set("position", l(p));
          const v = (p == null ? void 0 : p.getStyle()) || new pe({ fill: new me({ color: "rgba(255, 255, 255, 0.6)" }), stroke: new Ke({ color: "#319FD3", width: 1 }), image: new Qr({ anchor: [0.5, 46], anchorXUnits: "fraction", anchorYUnits: "pixels", src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADdElEQVRYR8WWXYjcVBiG3zfJGb1oq4todXZnVOpsMlbRLtQK1p+CVNAbERQEqUVEVPy58EIpqFAQwasqVOhFWdrSIuiNUAQR/3ApVIr0hzozu93KJtktsgWRxeLmJPlKho52JzOTZIo2t+d7v/c5b76cHOIqP7zK/igEIADPlNWGyJBHQY4DHANlUcBZI4p/MubDqRqwXGRTuQAEUM0x9TIMvkXg1r4GIosA3rE9PUlA8oBkAsyO4Dq9Sh0GuTlPw3aN4Os1UfBUeQEXsjQDAZKdtypqCuR9WY3S63JcLelH1v2BPwdpBwI0q+pjgG8UN+8o5Ijt6gcJxP169AVorsXtKKkZkGYvsQDnKDIPYEO/mrYuxnOOHxwsDNCoqj0EX0oJRc4jlmec+fD7ZK09I6vVdgA7Aa7prhfBdN0L7EIAApjNqlokOHK5UCCBBU7U3OB0d8NWRW0U4CjIVKomsL7mBr/2guj5ChqjGKdZaqV3I7vrnn6t324aFXWI5LM9UnvB8fRkboDpivVQTOPHbgEh22xXHxgAsJ1kykgQ76i74Ye5AZqj1haYxncpQSwvOr7e2w+gVVXbBNyXSq4owGwZVW2V5nq8gs/qnk5HfKmwVVWfCPh6Krk4esL2o69yJ5AUNiqlaRK1FSIRgfBexw9OdjdL5gamOkWw1DW4emRZj9z8O/4qCGDtII0P0iJJTrb31JLe1znlZsashyPyc5A3pgcQXzpe8GShzzApPnsT1i5fo3ySVk+xSCTEcYBlArf0NYhlk+3rnwsDJIJWRU0KmRwyQz0i8k3d01sHiQf+C9rDaKqzA4/aAd2NWO4f9/XRoQESYbOidoN8dYgIvnDc4OksXeZ9oDGKG2iqMwCvz2r277osW6Gu3bEAL0uTCXAphVdAfprVrLPOOH7f9sOdeepzASR3wWZVHSM4kaNpy3aDuwiEOWrzX0pnymoiMnGs199uxcETx1vqfvhDHvOkJlcCnWbNMbULBt/s11xE9tc9/Xxe88IAv92Ga/+OSidIjHebCDDHC8Hdznks/WcA7cNpVN0jBn4BaayIPowfqC+ER4qYF07gn1dRsd4Fjcun/CPHDd4uaj40QPJVtKqlwwAeB+Rb29WPEYj+N4DEKLmMBqvUlBh6651zODeM+dAJdMxOA6X1QDCs+RUDXIlxR3sRcjswMD6XvKYAAAAASUVORK5CYII=" }) }), y = (v == null ? void 0 : v.getText()) || new Si({ font: "16px Calibri,sans-serif", fill: new me({ color: "#000" }), padding: [2, 2, 2, 2], backgroundFill: new me({ color: "#fff" }) });
          y.setText(u.value), v.setText(y), p == null || p.setStyle(v), g("save", { name: u.value, remark: h.value, type: f.value, feature: p }), s.value = void 0, u.value = "", h.value = "";
        }, A = (p) => i.forEachFeatureAtPixel(p, (v) => v, { layerFilter: (v) => {
          var y;
          return v.get("id") === ((y = r.value) == null ? void 0 : y.get("id"));
        } });
        return P.onMounted(() => {
          r.value && i.on("singleclick", (p) => {
            const v = A(p.pixel);
            if (v) {
              c.value = v;
              const y = v.get("type"), m = v.get("name"), _ = v.get("remark");
              c.value.set("type", y), c.value.set("name", m), f.value = y, u.value = m, h.value = _, v.get("position") && (s.value = v.get("position"));
            }
          });
        }), (p, v) => {
          const y = P.resolveComponent("ol-overlay");
          return P.openBlock(), P.createBlock(y, { "class-name": a.pinClass, position: P.unref(s), offset: [0, -30], positioning: "bottom-center" }, { default: P.withCtx(() => [P.createElementVNode("div", { class: P.normalizeClass(["title", a.titleClass]) }, "" + P.toDisplayString(o[P.unref(f)]), 3), P.createElementVNode("div", { class: P.normalizeClass(["body", a.bodyClass]) }, [P.createElementVNode("div", zyt, [v[2] || (v[2] = P.createElementVNode("label", { for: "name" }, ":", -1)), P.withDirectives(P.createElementVNode("input", { "onUpdate:modelValue": v[0] || (v[0] = (m) => P.isRef(u) ? u.value = m : u = m), type: "text" }, null, 512), [[P.vModelText, P.unref(u)]])]), P.createElementVNode("div", Gyt, [v[3] || (v[3] = P.createElementVNode("label", { for: "remark" }, ":", -1)), P.withDirectives(P.createElementVNode("input", { "onUpdate:modelValue": v[1] || (v[1] = (m) => P.isRef(h) ? h.value = m : h = m), type: "text" }, null, 512), [[P.vModelText, P.unref(h)]])])], 2), P.createElementVNode("div", { class: P.normalizeClass(["footer", a.footerClass]) }, [P.createElementVNode("button", { class: "btn-ok", onClick: d }, "")], 2)]), _: 1 }, 8, ["class-name", "position"]);
        };
      } }), Mb = P.defineComponent({ name: "OlDraw", props: { type: { type: String, default: "" }, snap: { type: Boolean, default: false }, modify: { type: Boolean, default: false }, pin: { type: Boolean, default: false }, pinClass: { type: String, default: "" }, pinTitleClass: { type: [Array, String], default: "" }, pinBodyClass: { type: [Array, String], default: "" }, pinFooterClass: { type: [Array, String], default: "" } }, emits: ["drawend", "drawstart", "modifyend", "modifystart", "savePin"], setup(n, { expose: t, emit: e }) {
        const i = P.inject("VMap"), r = P.unref(i).map, a = P.inject("ParentLayer");
        let o = P.shallowRef(), s, l, u = P.shallowRef(void 0);
        const h = (v) => {
          v.on("drawend", (y) => {
            e("drawend", y), n.pin && (u.value = y.feature, f());
          }), v.on("drawstart", (y) => {
            e("drawstart", y);
          });
        }, c = (v) => {
          v.on("modifyend", (y) => {
            e("modifyend", y);
          }), v.on("modifystart", (y) => {
            e("modifystart", y);
          });
        }, f = () => {
          o.value && r.removeInteraction(o.value), l && r.removeInteraction(l), s && r.removeInteraction(s);
        }, g = () => {
          if (f(), u.value = void 0, n.type) {
            let v;
            const y = a.value.getSource();
            let m;
            n.type === "Rectangle" ? (m = "Circle", v = { source: y, type: m, geometryFunction: Ret() }) : n.type === "Square" ? (m = "Circle", v = { source: y, type: m, geometryFunction: Det(4) }) : (m = n.type, v = { source: y, type: m }), o.value = new JF(v), o.value.set("interactions_name", "Draw"), r.addInteraction(o.value), h(o.value), n.snap && (l = new Oet({ source: y }), l.set("interactions_name", "Snap"), r.addInteraction(l)), n.modify && (s = new $w({ source: y }), s.set("interactions_name", "Modify"), r.addInteraction(s), c(s));
          }
        }, d = () => {
          u.value = void 0, a.value.getSource().clear();
        }, A = (v) => {
          var y;
          (y = o.value) == null || y.setActive(v);
        };
        return P.watch(() => n.type, () => {
          u.value = void 0, g();
        }), P.onMounted(() => {
          g();
        }), t({ clear: d, setActive: A }), { render: () => {
          if (n.pin) {
            let v;
            if (!n.type) return null;
            if (n.type === "Point") v = "Point";
            else if (["Polygon", "Rectangle", "Square", "Circle"].includes(n.type)) v = "Polygon";
            else return null;
            return P.h("div", {}, [P.h(Uyt, { name: "default", type: v, feature: u.value, pinClass: n.pinClass, titleClass: n.pinTitleClass, bodyClass: n.pinBodyClass, footerClass: n.pinFooterClass, onSave: (y) => {
              e("savePin", y);
            } })]);
          } else return null;
        }, clear: d, setActive: A };
      }, render() {
        return this.render();
      } }), Vyt = (n) => n.component(Mb.name || "OlDraw", Mb), Db = P.defineComponent({ name: "OlMeasure", props: { type: { type: String, default: "" }, showSegments: { type: Boolean, default: false }, clearPrevious: { type: Boolean, default: false } }, setup(n, { expose: t, emit: e }) {
        const i = P.inject("VMap"), r = P.unref(i).map, a = P.inject("ParentLayer"), o = P.unref(a).getSource(), s = new pe({ fill: new me({ color: "rgba(255, 255, 255, 0.2)" }), stroke: new Ke({ color: "rgba(0, 0, 0, 0.5)", lineDash: [10, 10], width: 2 }), image: new kr({ radius: 5, stroke: new Ke({ color: "rgba(0, 0, 0, 0.7)" }), fill: new me({ color: "rgba(255, 255, 255, 0.2)" }) }) }), l = new pe({ text: new Si({ font: "14px Calibri,sans-serif", fill: new me({ color: "rgba(255, 255, 255, 1)" }), backgroundFill: new me({ color: "rgba(0, 0, 0, 0.7)" }), padding: [3, 3, 3, 3], textBaseline: "bottom", offsetY: -15 }), image: new Xu({ radius: 8, points: 3, angle: Math.PI, displacement: [0, 10], fill: new me({ color: "rgba(0, 0, 0, 0.7)" }) }) }), u = new pe({ text: new Si({ font: "12px Calibri,sans-serif", fill: new me({ color: "rgba(255, 255, 255, 1)" }), backgroundFill: new me({ color: "rgba(0, 0, 0, 0.4)" }), padding: [2, 2, 2, 2], textAlign: "left", offsetX: 15 }) }), h = new pe({ image: new kr({ radius: 5, stroke: new Ke({ color: "rgba(0, 0, 0, 0.7)" }), fill: new me({ color: "rgba(0, 0, 0, 0.4)" }) }), text: new Si({ text: "", font: "12px Calibri,sans-serif", fill: new me({ color: "rgba(255, 255, 255, 1)" }), backgroundFill: new me({ color: "rgba(0, 0, 0, 0.7)" }), padding: [2, 2, 2, 2], textAlign: "left", offsetX: 15 }) }), c = new pe({ text: new Si({ font: "12px Calibri,sans-serif", fill: new me({ color: "rgba(255, 255, 255, 1)" }), backgroundFill: new me({ color: "rgba(0, 0, 0, 0.4)" }), padding: [2, 2, 2, 2], textBaseline: "bottom", offsetY: -12 }), image: new Xu({ radius: 6, points: 3, angle: Math.PI, displacement: [0, 8], fill: new me({ color: "rgba(0, 0, 0, 0.4)" }) }) }), f = [c];
        let g, d, A;
        const p = function(x) {
          const w = ZP(x, { projection: P.unref(r).getView().getProjection() });
          let C;
          return w > 100 ? C = Math.round(w / 1e3 * 100) / 100 + " km" : C = Math.round(w * 100) / 100 + " m", C;
        }, v = function(x) {
          const w = KP(x, { projection: P.unref(r).getView().getProjection() });
          let C;
          return w > 1e4 ? C = Math.round(w / 1e6 * 100) / 100 + " km" : C = Math.round(w * 100) / 100 + " m", C;
        }, y = (x, w, C, S) => {
          var N, F, k;
          const b = [], T = x.getGeometry();
          if (!T) return new pe();
          const B = T.getType();
          let R, M, L;
          if ((!C || C === B || B === "Point") && (b.push(s), B === "Polygon" ? (R = T.getInteriorPoint(), M = v(T), L = new Be(T.getCoordinates()[0])) : B === "LineString" && (R = new Ge(T.getLastCoordinate()), M = p(T), L = T)), w && L) {
            let O = 0;
            if (!L) return new pe();
            L.forEachSegment(function(Q, j) {
              const Y = new Be([Q, j]), G = p(Y);
              f.length - 1 < O && f.push(c.clone());
              const $ = new Ge(Y.getCoordinateAt(0.5)), J = f[O];
              if (J) {
                J.setGeometry($);
                const et = J.getText();
                et == null || et.setText(G), b.push(f[O]), O++;
              }
            });
          }
          if (M) {
            l.setGeometry(R);
            const O = l.getText();
            O == null || O.setText(M), b.push(l);
          }
          return S && B === "Point" && !((F = (N = d.getOverlay()) == null ? void 0 : N.getSource()) != null && F.getFeatures().length) && (A = T, (k = u.getText()) == null || k.setText(S), b.push(u)), b;
        }, m = () => {
          const x = n.type === "area" ? "Polygon" : "LineString", w = " " + (n.type === "area" ? "" : ""), C = "";
          let S = C;
          g = new JF({ source: o, type: x, style: function(b) {
            return y(b, n.showSegments, x, S);
          } }), g.on("drawstart", function() {
            n.clearPrevious && o.clear(), d.setActive(false), S = w;
          }), g.on("drawend", function() {
            h.setGeometry(A), d.setActive(true), r.once("pointermove", function() {
              h.setGeometry("");
            }), S = C;
          }), d.setActive(true), r.addInteraction(g);
        }, _ = () => {
          d = new $w({ source: o, style: h }), a.value.setStyle((x) => y(x, n.showSegments)), r.addInteraction(d), n.type && m();
        }, I = () => {
          a.value.getSource().clear();
        }, E = (x) => {
          g.setActive(x);
        };
        return P.watch(() => n.type, (x) => {
          r.removeInteraction(g), x && m();
        }), P.onMounted(() => {
          _();
        }), t({ clear: I, setActive: E }), { clear: I, setActive: E };
      }, render() {
        return null;
      } }), jyt = (n) => n.component(Db.name || "OlMeasure", Db), Rb = P.defineComponent({ name: "OlDragRotateAndZoom", __name: "index", props: { condition: {}, duration: {} }, setup(n) {
        const t = P.inject("VMap"), e = P.unref(t).map, i = n, r = P.shallowRef(), a = () => {
          r.value = new bet(i), e.addInteraction(r.value);
        };
        return P.watchEffect(() => {
          r.value && e.removeInteraction(r.value), a();
        }), P.onMounted(() => {
          a();
        }), (o, s) => P.renderSlot(o.$slots, "default");
      } }), qyt = (n) => n.component(Rb.name || "OlDragRotateAndZoom", Rb);
      var jz = { exports: {} };
      (function(n) {
        (function() {
          function t(s, l) {
            var u = s.x - l.x, h = s.y - l.y;
            return u * u + h * h;
          }
          function e(s, l, u) {
            var h = l.x, c = l.y, f = u.x - h, g = u.y - c;
            if (f !== 0 || g !== 0) {
              var d = ((s.x - h) * f + (s.y - c) * g) / (f * f + g * g);
              d > 1 ? (h = u.x, c = u.y) : d > 0 && (h += f * d, c += g * d);
            }
            return f = s.x - h, g = s.y - c, f * f + g * g;
          }
          function i(s, l) {
            for (var u = s[0], h = [u], c, f = 1, g = s.length; f < g; f++) c = s[f], t(c, u) > l && (h.push(c), u = c);
            return u !== c && h.push(c), h;
          }
          function r(s, l, u, h, c) {
            for (var f = h, g, d = l + 1; d < u; d++) {
              var A = e(s[d], s[l], s[u]);
              A > f && (g = d, f = A);
            }
            f > h && (g - l > 1 && r(s, l, g, h, c), c.push(s[g]), u - g > 1 && r(s, g, u, h, c));
          }
          function a(s, l) {
            var u = s.length - 1, h = [s[0]];
            return r(s, 0, u, l, h), h.push(s[u]), h;
          }
          function o(s, l, u) {
            if (s.length <= 2) return s;
            var h = l !== void 0 ? l * l : 1;
            return s = u ? s : i(s, h), s = a(s, h), s;
          }
          n.exports = o, n.exports.default = o;
        })();
      })(jz);
      var Hyt = jz.exports;
      const Yyt = up(Hyt);
      class I_ {
        constructor(t, e) {
          Jt(this, "min", { x: 0, y: 0 });
          Jt(this, "max", { x: 0, y: 0 });
          this.min = t, this.max = e;
        }
        intersects(t) {
          const e = this.min, i = this.max, r = t.min, a = t.max;
          return a.x <= e.x || r.x >= i.x || a.y <= e.y || r.y >= i.y;
        }
      }
      class qz extends aa {
        constructor(e) {
          var r;
          const i = Object.assign({}, e);
          delete i.map;
          super(i);
          Jt(this, "map");
          Jt(this, "pointsArr", []);
          Jt(this, "zoom", 1);
          Jt(this, "textBounds", []);
          Jt(this, "styleOptions", { fillColor: "rgb(26,58,91,0.6)", strokeColor: "rgb(26,58,91)", textColor: "white", fontCss: "bolder 15px sans-serif", boxWidth: 50 });
          Jt(this, "textViewCom", []);
          Jt(this, "source");
          this.map = e.map, this.pointsArr = e.pointsArr ? e.pointsArr : this.pointsArr, this.zoom = e.zoom ? e.zoom : 1, this.styleOptions = e.styleOptions ? e.styleOptions : this.styleOptions, this.source = this.getSource() || new oa(), this.setSource(this.source), (r = this.map) == null || r.on("moveend", (a) => {
            this.moveEnd();
          });
        }
        moveEnd() {
          var i, r;
          (((r = (i = this.map) == null ? void 0 : i.getView()) == null ? void 0 : r.getZoom()) || 0) >= this.zoom ? this.drawText().then(() => {
            this.source.clear();
            const a = this.get("textComponent");
            a && a.length > 0 && a.forEach((o) => {
              var s, l;
              (s = this.getSource()) == null || s.addFeature(o.polyline), (l = this.getSource()) == null || l.addFeature(o.textBack);
            });
          }) : this.source.clear();
        }
        drawText() {
          return Tt(this, null, function* () {
            var a;
            const e = this.styleOptions, r = document.createElement("canvas").getContext("2d");
            r && (e.fontCss && (r.font = e.fontCss), (a = this.map) == null || a.once("postrender", () => Tt(this, null, function* () {
              const o = [];
              this.pointsArr.forEach((s) => {
                var h, c, f, g, d, A, p, v;
                const l = cN(s.position, "EPSG:4326"), u = ((h = this.map) == null ? void 0 : h.getPixelFromCoordinate(l)) || [0, 0];
                if (Jr(((c = this.map) == null ? void 0 : c.getView().calculateExtent()) || [0, 0], l)) {
                  s.text = s.text || "";
                  let y = e.boxWidth || Math.ceil(r.measureText(s.text).width);
                  y += 30;
                  const m = u[0] + 10, _ = u[0] + y, I = u[1] - 40, E = u[1] - 10, x = [m, Number(((I + E) / 2).toFixed(0))], w = { x: m, y: I }, C = { x: _, y: E }, S = new I_(w, C), b = u[0] - y, T = u[0] - 10, B = u[1] - 40, R = u[1] - 10, M = [T, Number(((B + R) / 2).toFixed(0))], L = { x: b, y: B }, N = { x: T, y: R }, F = new I_(L, N), k = u[0] - y, O = u[0] - 10, Q = u[1] + 10, j = u[1] + 40, Y = [O, Number(((Q + j) / 2).toFixed(0))], G = { x: k, y: Q }, $ = { x: O, y: j }, J = new I_(G, $), et = u[0] + 10, nt = u[0] + y, gt = u[1] + 10, q = u[1] + 40, W = [et, Number(((gt + q) / 2).toFixed(0))], it = { x: et, y: gt }, Ot = { x: nt, y: q }, pt = new I_(it, Ot), St = { bound: S, minx: m, miny: I, maxx: _, maxy: E, polylineCenter: x }, bt = { bound: F, minx: b, miny: B, maxx: T, maxy: R, polylineCenter: M }, xe = { bound: J, minx: k, miny: Q, maxx: O, maxy: j, polylineCenter: Y }, sn = { bound: pt, minx: et, miny: gt, maxx: nt, maxy: q, polylineCenter: W }, Ie = /* @__PURE__ */ new Map([["rightTopBounds", St], ["leftTopBounds", bt], ["leftBomBounds", xe], ["rightBomBounds", sn]]);
                  let yn = true, ln = 0, Br = 0, Mr = 0, gs = 0, Vn = [0, 0], Yd = "";
                  for (const [nm, lo] of Ie) {
                    for (let Zd = 0; Zd < this.textBounds.length && (yn = this.textBounds[Zd].intersects(lo.bound), !!yn); Zd++) ;
                    yn && (Yd = nm);
                  }
                  if (!yn) return;
                  for (const [nm, lo] of Ie) nm === Yd && (this.textBounds.push(lo.bound), Vn = lo.polylineCenter, ln = lo.minx, Br = lo.miny, Mr = lo.maxx, gs = lo.maxy);
                  const tm = ((f = this.map) == null ? void 0 : f.getCoordinateFromPixel([ln, Br])) || [], Wd = ((g = this.map) == null ? void 0 : g.getCoordinateFromPixel([Mr, Br])) || [], Xd = ((d = this.map) == null ? void 0 : d.getCoordinateFromPixel([Mr, gs])) || [], bP = ((A = this.map) == null ? void 0 : A.getCoordinateFromPixel([ln, gs])) || [], $d = new Ce(new Dn([[tm, Wd, Xd, bP]]));
                  $d.setStyle(new pe({ text: new Si({ font: e.fontCss, fill: new me({ color: e.textColor }), backgroundFill: new me({ color: e.fillColor }), backgroundStroke: new Ke({ color: e.strokeColor }), offsetY: 0.5, overflow: true }) })), (p = $d.getStyle().getText()) == null || p.setText(s.text);
                  const em = ((v = this.map) == null ? void 0 : v.getCoordinateFromPixel(Vn)) || [0, 0], px = new Ce(new Be([s.position, em]));
                  px.setStyle(new pe({ stroke: new Ke({ color: e.strokeColor }) })), o.push({ textBack: $d, polyline: px, text: s.text });
                }
              }), this.set("textComponent", o);
            })));
          });
        }
        keepVisible() {
          if (this.textViewCom = this.get("invisible"), !!this.textViewCom) for (let e = this.textViewCom.length - 1; e >= 0; e--) {
            const i = this.textViewCom[e];
            this.textVisibility(i.text, false);
          }
        }
        textVisibility(e, i) {
          var s, l, u, h, c;
          let r = this.getObjectByText(e);
          this.textViewCom = this.get("invisible");
          let a = false, o = 0;
          if (this.textViewCom instanceof Array) for (let f = ((s = this.textViewCom) == null ? void 0 : s.length) - 1; f >= 0; f--) {
            let g = this.textViewCom[f];
            e === g.text && (a = true, o = f);
          }
          if (r.length > 0) for (let f = r.length - 1; f >= 0; f--) {
            let g = r[f];
            if (!i) this.textViewCom instanceof Array ? !a && this.textViewCom.push(g) : this.set("invisible", [g]), (l = g.textBack) == null || l.setStyle(void 0), (u = g.polyline) == null || u.setStyle(void 0);
            else if (this.textViewCom instanceof Array && a) {
              this.textViewCom.splice(o, 1);
              let d = this.getObjectByText(g.text);
              for (let A = d.length - 1; A >= 0; A--) (h = d[A].textBack) == null || h.setStyle(void 0), (c = d[A].polyline) == null || c.setStyle(void 0);
            }
          }
          else i ? a && this.textViewCom.splice(o, 1) : this.textViewCom instanceof Array ? !a && this.textViewCom.push({ text: e }) : this.set("invisible", [{ text: e }]);
        }
        getObjectByText(e) {
          const i = this.get("textComponent"), r = [];
          for (let a = (i == null ? void 0 : i.length) - 1; a >= 0; a--) {
            const o = i[a];
            o.text === e && r.push(o);
          }
          return r;
        }
      }
      var Ur = 63710088e-1, Hz = { centimeters: Ur * 100, centimetres: Ur * 100, degrees: 360 / (2 * Math.PI), feet: Ur * 3.28084, inches: Ur * 39.37, kilometers: Ur / 1e3, kilometres: Ur / 1e3, meters: Ur, metres: Ur, miles: Ur / 1609.344, millimeters: Ur * 1e3, millimetres: Ur * 1e3, nauticalmiles: Ur / 1852, radians: 1, yards: Ur * 1.0936 };
      function Yz(n, t, e = {}) {
        const i = { type: "Feature" };
        return (e.id === 0 || e.id) && (i.id = e.id), e.bbox && (i.bbox = e.bbox), i.properties = t || {}, i.geometry = n, i;
      }
      function Wyt(n, t, e = {}) {
        if (!n) throw new Error("coordinates is required");
        if (!Array.isArray(n)) throw new Error("coordinates must be an Array");
        if (n.length < 2) throw new Error("coordinates must be at least 2 numbers long");
        if (!Wz(n[0]) || !Wz(n[1])) throw new Error("coordinates must contain numbers");
        return Yz({ type: "Point", coordinates: n }, t, e);
      }
      function wp(n, t, e = {}) {
        if (n.length < 2) throw new Error("coordinates must be an array of two or more positions");
        return Yz({ type: "LineString", coordinates: n }, t, e);
      }
      function Xyt(n, t = "kilometers") {
        const e = Hz[t];
        if (!e) throw new Error(t + " units is invalid");
        return n * e;
      }
      function $yt(n, t = "kilometers") {
        const e = Hz[t];
        if (!e) throw new Error(t + " units is invalid");
        return n / e;
      }
      function Lb(n) {
        return n % (2 * Math.PI) * 180 / Math.PI;
      }
      function Ha(n) {
        return n % 360 * Math.PI / 180;
      }
      function Wz(n) {
        return !isNaN(n) && n !== null && !Array.isArray(n);
      }
      function Zyt(n) {
        return n !== null && typeof n == "object" && !Array.isArray(n);
      }
      function Cp(n) {
        if (!n) throw new Error("coord is required");
        if (!Array.isArray(n)) {
          if (n.type === "Feature" && n.geometry !== null && n.geometry.type === "Point") return [...n.geometry.coordinates];
          if (n.type === "Point") return [...n.coordinates];
        }
        if (Array.isArray(n) && n.length >= 2 && !Array.isArray(n[0]) && !Array.isArray(n[1])) return [...n];
        throw new Error("coord must be GeoJSON Point or an Array of numbers");
      }
      function Pb(n, t, e = {}) {
        if (e.final === true) return Kyt(n, t);
        const i = Cp(n), r = Cp(t), a = Ha(i[0]), o = Ha(r[0]), s = Ha(i[1]), l = Ha(r[1]), u = Math.sin(o - a) * Math.cos(l), h = Math.cos(s) * Math.sin(l) - Math.sin(s) * Math.cos(l) * Math.cos(o - a);
        return Lb(Math.atan2(u, h));
      }
      function Kyt(n, t) {
        let e = Pb(t, n);
        return e = (e + 180) % 360, e;
      }
      function Xz(n, t, e, i = {}) {
        const r = Cp(n), a = Ha(r[0]), o = Ha(r[1]), s = Ha(e), l = $yt(t, i.units), u = Math.asin(Math.sin(o) * Math.cos(l) + Math.cos(o) * Math.sin(l) * Math.cos(s)), h = a + Math.atan2(Math.sin(s) * Math.sin(l) * Math.cos(o), Math.cos(l) - Math.sin(o) * Math.sin(u)), c = Lb(h), f = Lb(u);
        return Wyt([c, f], i.properties);
      }
      function Jyt(n, t, e = {}) {
        var i = Cp(n), r = Cp(t), a = Ha(r[1] - i[1]), o = Ha(r[0] - i[0]), s = Ha(i[1]), l = Ha(r[1]), u = Math.pow(Math.sin(a / 2), 2) + Math.pow(Math.sin(o / 2), 2) * Math.cos(s) * Math.cos(l);
        return Xyt(2 * Math.atan2(Math.sqrt(u), Math.sqrt(1 - u)), e.units);
      }
      function tmt(n, t, e, i) {
        if (i = i || {}, !Zyt(i)) throw new Error("options is invalid");
        var r, a = [];
        if (n.type === "Feature") r = n.geometry.coordinates;
        else if (n.type === "LineString") r = n.coordinates;
        else throw new Error("input must be a LineString Feature or Geometry");
        for (var o = r.length, s = 0, l, u, h, c = 0; c < r.length && !(t >= s && c === r.length - 1); c++) {
          if (s > t && a.length === 0) {
            if (l = t - s, !l) return a.push(r[c]), wp(a);
            u = Pb(r[c], r[c - 1]) - 180, h = Xz(r[c], l, u, i), a.push(h.geometry.coordinates);
          }
          if (s >= e) return l = e - s, l ? (u = Pb(r[c], r[c - 1]) - 180, h = Xz(r[c], l, u, i), a.push(h.geometry.coordinates), wp(a)) : (a.push(r[c]), wp(a));
          if (s >= t && a.push(r[c]), c === r.length - 1) return wp(a);
          s += Jyt(r[c], r[c + 1], i);
        }
        if (s < t && r.length === o) throw new Error("Start position is beyond line");
        var f = r[r.length - 1];
        return wp([f, f]);
      }
      class emt {
        constructor(t) {
          Jt(this, "_operators");
          Jt(this, "_carIcon");
          Jt(this, "_direction");
          Jt(this, "_map");
          Jt(this, "_status");
          Jt(this, "_pathInfo");
          Jt(this, "_bubble");
          Jt(this, "_moving");
          Jt(this, "_tracePointsModePlay");
          Jt(this, "_lineLayer");
          Jt(this, "_movePath");
          Jt(this, "_originPath");
          Jt(this, "_revealLayer");
          Jt(this, "_showTracePoint");
          Jt(this, "_nodesLayer");
          Jt(this, "_moveNodes");
          Jt(this, "_timeStep");
          Jt(this, "_speed");
          Jt(this, "_speedUp");
          Jt(this, "_nowTime");
          Jt(this, "_moveIdx");
          Jt(this, "_animateLayer");
          Jt(this, "_animateLine");
          Jt(this, "_group");
          Jt(this, "_labelVisible");
          Jt(this, "_traceEvent");
          Jt(this, "_simplifyEvent");
          Jt(this, "_eventType");
          Jt(this, "_animateStart");
          Jt(this, "_textLayer");
          Jt(this, "_moveListener");
          Jt(this, "_step");
          Jt(this, "_viewCode");
          Jt(this, "_defaultStyles");
          Jt(this, "_nodesCollection");
          Jt(this, "_nodeInfos");
          Jt(this, "_visible");
          var f;
          t = t || {};
          const e = t.bubble !== void 0 ? t.bubble : false, i = t.showTracePoint ? t.showTracePoint : false, r = t.tracePointsModePlay ? t.tracePointsModePlay : "animation", a = t.mapObj !== void 0 ? t.mapObj : null, o = t.path !== void 0 ? t.path : [], s = t.options, l = Date.now();
          !t.path || t.path.length < 1, this._operators = { carIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAVCAYAAADfLRcdAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDE0IDc5LjE1Njc5NywgMjAxNC8wOC8yMC0wOTo1MzowMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkQ0RkExMTQ2Rjc4NzExRTQ4QkI3QTA2OTk3QzQ4M0IzIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkQ0RkExMTQ3Rjc4NzExRTQ4QkI3QTA2OTk3QzQ4M0IzIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RDRGQTExNDRGNzg3MTFFNDhCQjdBMDY5OTdDNDgzQjMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RDRGQTExNDVGNzg3MTFFNDhCQjdBMDY5OTdDNDgzQjMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz62sMp6AAAFiklEQVR42tRXW2wUVRj+zpmZvc4uS2mhhQK21FLshoKGWkBMSAwQSVBf0QfiJciDLya+8KAx8RJfeJV440GJaDAmGGKUmAASI+GhDQ1a7t1Kb1tot7s7uzvX4z8zC+12bdHVkDjJn5md/c853/nO918GeEDXkfe2f5+9+KzxxeuQap2D/RPn5BO7Aowxns/n9Ju958Q8PjL5yIxz4+KZk86spRLG5Y1T/Zfbf31sz7HN/xqsuIo4THwgStgr8lBtDcwxwQxa0rKB4WkFBcOGpgNSwIFusYoJjv0ATOQYdm9lWBQX4Iz2I8iDxhsGMDSm4mx/FJ3LR/HWi4ASokEmmeYj4UG6K/Tock9jSjxRjG/PRCrADn4SHVi8ttTOGM0sHAguIRKyCSlgF4HsOPDxKY7T4zvQ3NqFYmYSsbp6BEKhe0Bt08LR41/CsSzse34fZEWBbdPGtCxKWhoxeQiNketIhHOYyEgYGAqgc/UU3n5VgbA5iBQyAccWYLKCYLOCnLmLNrhNJHte5h7Ys/ubIlsPjGp3F/3tViOefEVCOCJjSYKjqZ6jdTnwdI+Fp5IppCaAvmsKxiZlondGCYQLJ34S2Ngp0LMBqFMFHmmxUb+U4+DhNpz4WYIlhWgTAWKIAHGOyVQKR98dx45uYoXTKZGRA/S0BT1n+6cd74G8qNlRO76WmNXLHI/R8nXom7U4eqENJdNAUSczdJR0HW/s1HDwhavehMIDx2BbtChj4Ip7hvDeuyYp7pHSe9l//8yBNTh/MwhOALnrf/fu2GhWBnDms+IMWMk1eOM8IxVYsV2QMl9F+Wyg7tV3hTxZZdw5BHZLlzEjdJpEJn0FVeaZEvYtEPF/yyECMivm9+6hDdoOLJKKSTIxPLNh0USXLnN6XiCqluiQE9Ok5dXTfO5/wxN2lb9D7LYtz9ectjat1wioQSdhklmkTdN7NuguB6O4cInhdobPM9oNnAFg1UtSlUc2J+5FuEuw+yyIBTVUqBnsyiYNsUiUpOOza7msEmg3KCUKxOvDAvUJZ/4JBKUlnmdVYHXzL9KnEEioVs1gFbmIjofbEVdjPleOQ8zaHruCIIxO3C/du/nNgDz3tUWpIzAnATNKZ6SFKi3/7UuYXgA9vqkbBun/xuAgbo0OwyESbLKcJhauT+765FIFVuaiapi7e/CAv2hNpUchEhxkclliWcGa1lY82rXBA/Hdt8cxli5XgXnHc28vVWCDgWqhu+kpk5eRiNYG1rTCsOjohRtYrgQoZVmZKciyjKYlDejZOHyfyk+5kM67CllcZeWBvrlAGU2aL0Vq1uwfo1EPbIlqrmGY0F0z3WfK41oOHQ8tlA1cGFE6BFVUeaxcVj2IB4O4NqLWDPb8RZU2WyKAZZBkJQJsUoAVs5Po7lwoGxAeaR01Fp/aXAhWEf5d7Y4X/XPBnusLVOjdomZGzwvPzKJvRsH/bZXcGj8z/sPjEeSKBWJU98B6DNN9enwMmzflEJDn32hxiMOciJKWUovkXw43qrN7g53dWbx/pB/hsIS6ONBRz9DSBGxoc+u1QCot0HtNxshtmbojp6I3OHmaoWudg571lOpiDpKtDhoaOVqWljB+I0xlWYFpu5o1vPSlpdM49OYcRnkchdQUrHLBVBq2UOgpDu9Cwe+6Dsf765Jap9fPubRJ1MgEK7uuj04xfN6XBFOXUe9WBAuGPS3fY5vQ3kmPeRVq6YqVVG4l74Qc26Tw0NCcyCC54g4a4yZ+H4njythibGm5gndeo+ChVtM2yl0XrRmKUC1vYDD4Hmjmc6Ju1W5eUz+rUT9bmK+f/ZH62eycfrbsQRL1+9le6mebqZ/dT6xF3XMmm/KlyWNelvMbGPK3pfpieNvtyP/yS+GBXf/FN9ifAgwAIOzB+qcKmLcAAAAASUVORK5CYII=", speed: 1e3, timeStep: 1, startIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADb0lEQVRYR8WWW4jcZBzFz8lukn1Si5fOjKK20NmEKtoFL+C1IBX0RQQFQeoiIipeHnxQCioURPBJhQo+yFJFEfRFKIKIN1wKFZGqtJPZbgtFTWa7i1LFy+bbyZHsztJ1MpkkI9I85vufc375/798CXGWL57lfFQDENgw/g4Qt0loQroE5CKl410r+WphPJkF55erPFQ5AMFuGO8RiU+TuCwvQNAioWdDuz0DQmVACgE2aeu5E8Y9QODGMoZpjaSP6fx2d8jwzyLNcADBrht/lsC1RUYD1g//ZS/f+itPnB6mHQpQj71XCT45QnhPooOhHdwEIsnzyAXYrMktluExgmODxJIiED8D2JFXszaO5P7Ibb9TGaAee28QfLhfKGhJ1L0du/15ura2R+xpgHsJnpMJkuZCN5isBiCMNYy/mPr3CeNEnOq4R4/0G9bi5jWEdYhgpquJzPaOO390EMTAEVwgr+kYtrMC7Qud4PG8p6nH3rsE7+tfT5A82HHaM6UB6sa/mcKX2fZjd+S03s4DqMXetAVmgkTtiezgpdIANTO505L12QDBQ6HTejMfwN9tAfsz4FUBGtp6KYx7csAI3gudINPi9bpa7L1mgU9kRmDhzs5466PSHUgLG8v+HIhtG0WC1JWuPuW2v+836+2bHwA4/9bAJPYvmxa48EclgLrx9lB8cUAXTgt6/m/b7F8/5WrGu4XC+wQvzLRf+DByW3dVew0BXKQtm8fMxE8ExgceRFAXwGEIDZL1vIAE3es6ztzXlQFWxxB7MwCn88RF9wV9EjnBrmF1Q78F6WaUcU4MO2qHmXexcv2Cc+zQyABrXfD3AXis6Gmzs9cHkRvcU6Qr/B+4WN75MpwHcF6R2Zl1LcM220Ie/7FIUwiQGtTiyUctWK8Xma2vJ9QLHTvYW6a+FAAE1o33DcGpQlOpHTrBFSBWCmuB8j+ljdifEpRCDIVOqJ0dO/iiTHhaU64DPbd67L9C4Kk8c0FvRU7wQNnwygDQ5RONeOI7kM0BJ95J4yRXLrH9+/8HkJ6QcfOqMVjfErQ2Bq1QN5yyg4NVwqt3oOdeM/5zlnBmlwsvh27rmarhIwOsvhWxf4DEHQA+De3W7SDSb0Plq9Im3Oi+9jPqzBqbu5bYiion9wQjA6zqtd0Bj8Sjho8+gv+S2Kf9B1+VRDBEEbAnAAAAAElFTkSuQmCC", endIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADdElEQVRYR8WWXYjcVBiG3zfJGb1oq4todXZnVOpsMlbRLtQK1p+CVNAbERQEqUVEVPy58EIpqFAQwasqVOhFWdrSIuiNUAQR/3ApVIr0hzozu93KJtktsgWRxeLmJPlKho52JzOTZIo2t+d7v/c5b76cHOIqP7zK/igEIADPlNWGyJBHQY4DHANlUcBZI4p/MubDqRqwXGRTuQAEUM0x9TIMvkXg1r4GIosA3rE9PUlA8oBkAsyO4Dq9Sh0GuTlPw3aN4Os1UfBUeQEXsjQDAZKdtypqCuR9WY3S63JcLelH1v2BPwdpBwI0q+pjgG8UN+8o5Ijt6gcJxP169AVorsXtKKkZkGYvsQDnKDIPYEO/mrYuxnOOHxwsDNCoqj0EX0oJRc4jlmec+fD7ZK09I6vVdgA7Aa7prhfBdN0L7EIAApjNqlokOHK5UCCBBU7U3OB0d8NWRW0U4CjIVKomsL7mBr/2guj5ChqjGKdZaqV3I7vrnn6t324aFXWI5LM9UnvB8fRkboDpivVQTOPHbgEh22xXHxgAsJ1kykgQ76i74Ye5AZqj1haYxncpQSwvOr7e2w+gVVXbBNyXSq4owGwZVW2V5nq8gs/qnk5HfKmwVVWfCPh6Krk4esL2o69yJ5AUNiqlaRK1FSIRgfBexw9OdjdL5gamOkWw1DW4emRZj9z8O/4qCGDtII0P0iJJTrb31JLe1znlZsashyPyc5A3pgcQXzpe8GShzzApPnsT1i5fo3ySVk+xSCTEcYBlArf0NYhlk+3rnwsDJIJWRU0KmRwyQz0i8k3d01sHiQf+C9rDaKqzA4/aAd2NWO4f9/XRoQESYbOidoN8dYgIvnDc4OksXeZ9oDGKG2iqMwCvz2r277osW6Gu3bEAL0uTCXAphVdAfprVrLPOOH7f9sOdeepzASR3wWZVHSM4kaNpy3aDuwiEOWrzX0pnymoiMnGs199uxcETx1vqfvhDHvOkJlcCnWbNMbULBt/s11xE9tc9/Xxe88IAv92Ga/+OSidIjHebCDDHC8Hdznks/WcA7cNpVN0jBn4BaayIPowfqC+ER4qYF07gn1dRsd4Fjcun/CPHDd4uaj40QPJVtKqlwwAeB+Rb29WPEYj+N4DEKLmMBqvUlBh6651zODeM+dAJdMxOA6X1QDCs+RUDXIlxR3sRcjswMD6XvKYAAAAASUVORK5CYII=", showInfoWin: false, arrowPixel: 0.2, textStyle: {} }, this._operators = rt(rt({}, this._operators), s);
          const u = new me({ color: "rgba(255,255,255,0.4)" }), h = new Ke({ color: "#3399CC", width: 1.25 });
          this._defaultStyles = [new pe({ image: new kr({ fill: u, stroke: h, radius: 5 }), fill: u, stroke: h })], this._nodesCollection = null, this._nodeInfos = [];
          const c = new Qr({ src: this._operators.carIcon, scale: 1, anchor: [0.5, 0.5], offset: [0, 0] });
          c.load(), this._carIcon = new pe({ image: c }), this._direction = 0, a && (this._map = a), this._viewCode = (f = this._map) == null ? void 0 : f.getView().getProjection().getCode(), this._status = "stop", this._pathInfo = o, this._bubble = e, this._moving = false, this._tracePointsModePlay = r, this._visible = t.visible, this._lineLayer = new aa({ source: new oa({ features: [], strategy: Xm }), properties: { vzBelong: "vzTrackPath", vzTime: l } }), this._movePath = [], this._lineLayer.set("projection", this._viewCode, true), this._lineLayer.set("track-type", "trackPath"), this._movePath = [], this._originPath = null, this._revealLayer = new aa({ source: new oa({ features: [], strategy: Xm }), properties: { vzBelong: "vzTrackPath", vzTime: l } }), this._revealLayer.set("projection", this._viewCode, true), this._revealLayer.set("track-type", "trackReveal"), this._showTracePoint = i, this._nodesLayer = new aa({ source: new oa({ features: [], strategy: Xm }), style: null, properties: { vzBelong: "vzTrackPath", vzTime: l }, visible: this._visible }), this._nodesLayer.set("projection", this._viewCode, true), this._nodesLayer.set("track-type", "trackNodes"), this._nodesLayer.setVisible(this._showTracePoint), this._moveNodes = [], this._speed = this._operators.speed, this._timeStep = this._operators.timeStep, this._speedUp = 1, this._nowTime = null, this._moveIdx = 1, this._animateLayer = new aa({ source: new oa({ features: [], strategy: Xm }), style: new pe({ stroke: new Ke({ color: "red", width: 2 }) }), properties: { vzBelong: "vzTrackPath", vzTime: l } }), this._animateLayer.set("projection", this._viewCode, true), this._animateLayer.set("track-type", "trackAnimate"), this._animateLine = new Ce({ geometry: new Be([]) }), this._group = new zr({ layers: [this._lineLayer, this._revealLayer, this._nodesLayer, this._animateLayer], zIndex: 99, properties: { type: "vzTrackPath", vzTime: l }, visible: this._visible }), this._labelVisible = t.labelVisible || false, a == null || a.addLayer(this._group), this._traceEvent = a == null ? void 0 : a.on(["singleclick", "pointermove"], (g) => {
            this.eventListener(g);
          }), this._eventType = ["nodeClick", "nodeMouseover", "nodeMouseout", "pathClick", "pathMouseover", "pathMouseout", "move"], this._animateStart = new Ce(), this._textLayer = null, this._moveListener = null, this._step = 0, this._simplifyEvent = a == null ? void 0 : a.getView().on("change:resolution", (g) => {
            Number.isInteger(g.target.getZoom()) && this.simplifyOpera(g);
          }), this.initLinesAndMarkers();
        }
        simplifyOpera(t) {
          var h, c;
          let e;
          const i = t.target.getProjection().getCode(), r = this._viewCode !== i, a = t.target.getResolution();
          e = this._nodesCollection ? this._nodesCollection.map((f) => {
            var d, A;
            if (r && f.get("isSimplify") === false) {
              const p = (d = f.getGeometry()) == null ? void 0 : d.transform(this._viewCode, i);
              p instanceof Ge && f.setGeometry(p);
            }
            const g = (A = f.getGeometry()) == null ? void 0 : A.getCoordinates();
            return { x: g[0] / a, y: g[1] / a, idx: f.get("node_idx") };
          }) : [], r && (this._viewCode = i);
          const o = Yyt(e, 2, false), s = [], l = [];
          o.forEach((f) => {
            s.push([f.x * a, f.y * a]), l.push(f == null ? void 0 : f.idx);
          }), this._originPath instanceof Be && this._originPath.setCoordinates(s), !this._moving && this._status !== "moving" && this._moveListener !== null && this._tracePointsModePlay === "animation" && this._originPath instanceof Be && ((h = this._animateLine.getGeometry()) == null || h.setCoordinates(s.slice(0, l.indexOf(this._moveIdx) + 1).concat([this._animateStart.getGeometry().getCoordinates()]))), (c = this._nodesLayer.getSource()) == null || c.clear(), new Promise((f) => {
            var g;
            this._nodeInfos = [], this._nodesLayer.getVisible() && ((g = this._nodesCollection) == null || g.forEach((d, A) => {
              d.set("isSimplify", false), d.setStyle(null), l.includes(A + 1) && (d.set("isSimplify", true), d.setStyle(this._defaultStyles), this._nodeInfos.push(d));
            })), f(this._nodeInfos);
          }).then((f) => {
            var g;
            (g = this._nodesLayer.getSource()) == null || g.addFeatures(f);
          });
        }
        eventListener(t) {
          var i, r, a, o, s, l, u, h, c;
          if ((i = this._map) == null ? void 0 : i.hasFeatureAtPixel(t.pixel, { layerFilter: function(f) {
            return f.get("track-type") === "trackPath" || f.get("track-type") === "trackNodes";
          }, hitTolerance: 0 })) {
            this._moveNodes = ((r = this._map) == null ? void 0 : r.getFeaturesAtPixel(t.pixel, { layerFilter: function(d) {
              return d.get("track-type") === "trackNodes";
            }, hitTolerance: 0 })) || [], this._movePath = ((a = this._map) == null ? void 0 : a.getFeaturesAtPixel(t.pixel, { layerFilter: function(d) {
              return d.get("track-type") === "trackPath";
            }, hitTolerance: 0 })) || [];
            const f = this._moveNodes.map((d) => d.getProperties()), g = this._movePath.map((d) => d);
            switch (t.type) {
              case "singleclick":
                f.length >= 1 && ((o = this._map) == null || o.dispatchEvent({ type: "nodeClick", target: this._bubble ? [f[0]] : f, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
                  throw new Error("Function not implemented.");
                }, stopPropagation: function() {
                  throw new Error("Function not implemented.");
                } })), g.length >= 1 && ((s = this._map) == null || s.dispatchEvent({ type: "pathClick", target: this._bubble ? [g[0]] : g, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
                  throw new Error("Function not implemented.");
                }, stopPropagation: function() {
                  throw new Error("Function not implemented.");
                } }));
                break;
              case "pointermove":
                f.length >= 1 && ((l = this._map) == null || l.dispatchEvent({ type: "nodeMouseover", target: this._bubble ? [f[0]] : f, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
                  throw new Error("Function not implemented.");
                }, stopPropagation: function() {
                  throw new Error("Function not implemented.");
                } })), g.length >= 1 && ((u = this._map) == null || u.dispatchEvent({ type: "pathMouseover", target: this._bubble ? [g[0]] : g, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
                  throw new Error("Function not implemented.");
                }, stopPropagation: function() {
                  throw new Error("Function not implemented.");
                } }));
                break;
            }
          } else {
            const f = this._moveNodes.map((d) => d.getProperties());
            this._moveNodes.length > 0 && this._moveNodes.splice(0, this._moveNodes.length), t.type === "pointermove" && f.length > 0 && ((h = this._map) == null || h.dispatchEvent({ type: "nodeMouseout", target: this._bubble ? [f[0]] : f, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
              throw new Error("Function not implemented.");
            }, stopPropagation: function() {
              throw new Error("Function not implemented.");
            } }));
            const g = this._movePath.map((d) => d);
            this._movePath.length > 0 && this._movePath.splice(0, this._movePath.length), t.type === "pointermove" && g.length > 0 && ((c = this._map) == null || c.dispatchEvent({ type: "pathMouseout", target: this._bubble ? [g[0]] : g, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
              throw new Error("Function not implemented.");
            }, stopPropagation: function() {
              throw new Error("Function not implemented.");
            } }));
          }
        }
        initLinesAndMarkers() {
          var u, h, c, f, g, d, A;
          const t = (u = this._pathInfo) == null ? void 0 : u.map((p) => [p.longitude, p.latitude]), e = [], i = [];
          let r = 0;
          for (const p of t) {
            const v = new Ce({ geometry: new Ge(cN(p, this._viewCode)) });
            let y = null;
            if (this._pathInfo && (y = this._pathInfo[r]), y && (y.node_idx = r + 1, y.isSimplify = false, v.setProperties(y, true), v.setId("tackNode-" + y.node_idx)), r === 0) {
              const m = v.clone();
              this._animateStart = v.clone(), this._animateStart.setId("moveCarFeature"), m.setStyle(new pe({ image: new Qr({ src: this._operators.startIcon, anchor: [0.5, 1] }), text: new Si({ text: "" }) })), (h = this._revealLayer.getSource()) == null || h.addFeature(m);
            } else if (this._pathInfo && r === this._pathInfo.length - 1) {
              const m = v.clone();
              m.setStyle(new pe({ image: new Qr({ src: this._operators.endIcon, anchor: [0.5, 1] }), text: new Si({ text: "" }) })), (c = this._revealLayer.getSource()) == null || c.addFeature(m);
            }
            i.push(v), r++;
          }
          const a = new Be(t);
          this._originPath = a.transform("EPSG:4326", this._viewCode);
          const o = new Ce({ geometry: this._originPath }), s = new pe({ image: new Qr({ src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABfUlEQVQ4T3WTTSvFYRDFf8dLKIqytFckthTpJkQWlyhF2fgEVr6BheytpChEsqB08xbZWPgOJAs7ieRlNMzV//75P7vnmZkz58ycR2ZWD7QBF5KM1DGzTuBO0k065neZ2S3QBGwAU5I+iolmNgrsAI9An6SrNIgDnAE9EdgFJiS9+93MuoEToBx4AgYkXSZBHKAWOAS6IrAP5CW9BUge2AIqgJdg8guiSKoBDoDeDJBhwNlVBsiQpNPvGST0VgF7TjPeCsCIpNdo0g84O2fibx4r/AJEUjVwlJDjXbybU/eZjAGbMROXmC8BiKQ64BxoDyYLkuYTTCeB9WD/9B9AA3AMdGQAzALLAfCcluDF3r01itMS5oDFiP3MIUHNi90T7ko/XjyYGOIMsFJSXByimTVGQbFzegOuew0o+7PGKL4AmjM8MA2shua/RjIzX1suw8pucZfiUjOt/AC4BHfaeOoz+d63oziX9Zla3CzAkqTP9G8zM4/dS7r+7zt/Aaattn1kX8VgAAAAAElFTkSuQmCC", anchor: [0.75, 0.5], scale: 0.7, rotateWithView: false }) });
          o.set("arrow", [new pe({ stroke: new Ke({ color: "rgba(0, 0, 255, 0.6)", width: 10 }) }), s]), o.set("mainView", (f = this._map) == null ? void 0 : f.getView()), o.setStyle((p, v) => nmt(p, v)), e.push(o), (g = this._lineLayer.getSource()) == null || g.addFeatures(e), this._nodesCollection = i, (A = (d = this._animateLayer) == null ? void 0 : d.getSource()) == null || A.addFeature(this._animateLine), o.get("mainView") !== void 0 && o.get("mainView").dispatchEvent("change:resolution");
          const l = this._labelVisible;
          this.labelVisible(l);
        }
        labelVisible(t) {
          var e, i;
          if (t && !this._textLayer) {
            const r = (e = this._pathInfo) == null ? void 0 : e.map((a) => ({ position: [a.longitude, a.latitude], text: a.gnssTime }));
            if (this._textLayer = new qz({ map: this._map, pointsArr: r, zoom: 12, zIndex: 99 }), this._textLayer) {
              this._textLayer.set("id", "pathLabelLayer" + (/* @__PURE__ */ new Date()).getTime());
              let a = this._group.getLayers().getArray();
              a.push(this._textLayer), this._group.setLayers(new zr({ layers: a }).getLayers());
            }
          } else (i = this._textLayer) == null || i.setVisible(t);
          this._group.set("labelVisible", t || false);
        }
        start(t) {
          var e, i;
          this._pathInfo && this._pathInfo.length < 1 || ((this._moving || this._status === "pause") && this.stop(), this._moveIdx = t || 1, this._moving = true, this._status = "moving", this._nowTime = Date.now(), this._tracePointsModePlay === "skip" ? (this._moveListener = this._lineLayer.on("postrender", (r) => {
            this.tracePointsPlay(r);
          }), (e = this._map) == null || e.render()) : this._tracePointsModePlay === "animation" && (this._step = 0, this._moveListener = this._lineLayer.on("postrender", (r) => {
            this.animationPlay(r);
          }), (i = this._map) == null || i.render()));
        }
        stop() {
          var e, i, r, a;
          this._moveIdx = 1, this._status = "stop", this._moving = false, this._step = 0, this._moveListener !== null && (yl(this._moveListener), this._moveListener = null);
          const t = (e = this._animateLayer.getSource()) == null ? void 0 : e.getFeatureById("moveCarFeature");
          t && ((i = this._animateLayer.getSource()) == null || i.removeFeature(t)), (r = this._animateLine.getGeometry()) == null || r.setCoordinates([]), this._originPath instanceof Be && ((a = this._animateStart.getGeometry()) == null || a.setCoordinates(this._originPath.getFirstCoordinate()));
        }
        pause() {
          this._status = "pause", this._moving = false;
        }
        resume() {
          this._status = "moving", this._moving = true;
        }
        tracePointsPlay(t) {
          var a, o, s, l, u, h, c, f, g, d;
          const e = t.frameState;
          if (!e) return;
          const i = this._nodesCollection ? this._nodesCollection.map((A) => A.getGeometry().getCoordinates()) : [], r = (e.time - (this._nowTime || 0)) / 1e3 % 60;
          if (this._moving && (this._moveIdx === 1 || r >= (this._timeStep || 1))) {
            this._nowTime = e.time;
            let A = this._moveIdx === 1 ? this._speedUp : this._moveIdx + this._speedUp, p = null;
            const v = this._animateLine.getGeometry();
            if (i && this._moveIdx === i.length) {
              this.stop();
              return;
            }
            if (i && A >= i.length && this._moveIdx < i.length) {
              A = i.length;
              let I = null;
              i && (I = new Ce(new Ge(i[A - 1]))), p = I;
              const E = i[A - 1][0] - i[A - 2][0], x = i[A - 1][1] - i[A - 2][1], w = Math.atan2(x, E);
              this._direction !== w && (this._direction = w), (o = (a = this._carIcon) == null ? void 0 : a.getImage()) == null || o.setRotation(-this._direction + 2 * Math.PI);
              for (let C = i.length - this._moveIdx; C > 0; --C) A !== 0 && A - C <= i.length - 1 && (v == null || v.appendCoordinate(i[A - C]));
            } else if (i && A < i.length && this._moveIdx < i.length) {
              let I = null;
              if (i && (I = new Ce(new Ge(i[A - 1]))), p = I, i && A !== i.length - 1) {
                const E = i[A][0] - i[A - 1][0], x = i[A][1] - i[A - 1][1], w = Math.atan2(x, E);
                this._direction !== w && (this._direction = w), (l = (s = this._carIcon) == null ? void 0 : s.getImage()) == null || l.setRotation(-this._direction + 2 * Math.PI);
              }
              for (let E = this._speedUp; E > 0; --E) A !== 0 && A - E <= i.length - 1 && (v == null || v.appendCoordinate(i[A - E]));
            }
            this._animateStart.setStyle(this._carIcon), this._animateStart.getGeometry().setCoordinates(((u = p == null ? void 0 : p.getGeometry()) == null ? void 0 : u.getCoordinates()) || [0, 0]), ((h = this._animateLayer.getSource()) == null ? void 0 : h.getFeatureById("moveCarFeature")) || (f = (c = this._animateLayer) == null ? void 0 : c.getSource()) == null || f.addFeature(this._animateStart), this._moveIdx = A;
            const m = (g = this._map) == null ? void 0 : g.getView().getProjection().getCode(), _ = { index: this._moveIdx, status: this._status, position: i[A - 1], lngLat: fN(this._animateStart.getGeometry().getCoordinates(), m), passNode: this._nodesCollection ? this._nodesCollection[A - 1] : void 0, length: v == null ? void 0 : v.getLength() };
            this._animateLayer.dispatchEvent({ type: "move", target: _, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
              throw new Error("Function not implemented.");
            }, stopPropagation: function() {
              throw new Error("Function not implemented.");
            } });
          }
          (d = this._map) == null || d.render();
        }
        animationPlay(t) {
          var i, r, a, o, s, l;
          let e = 0;
          if (t.frameState) {
            if (this._nowTime = t.frameState.time, this._originPath instanceof Be && this._moving && this._step !== void 0 && this._step <= 1) {
              const u = this._originPath.clone();
              u.transform(this._viewCode, "EPSG:3857");
              const h = u.getLength(), c = this._animateLine.getGeometry(), f = this._originPath.clone();
              if (this._step !== 0) {
                const m = { geometry: { coordinates: f.getCoordinates(), type: "LineString" }, properties: {}, type: "Feature" };
                e = h * this._step;
                const _ = tmt(m, 0, e / 1e3, { units: "kilometers" });
                f.setCoordinates(_.geometry.coordinates), f.transform("EPSG:4326", this._viewCode);
                const I = f.getCoordinates();
                c == null || c.setCoordinates(I);
                let E = 0, x = 0;
                if (I.length > 2) {
                  const C = I[I.length - 2], S = I[I.length - 1];
                  E = C[0] - S[0], x = C[1] - S[1];
                  const b = Math.atan2(x, E);
                  this._direction !== b && (this._direction = b), (r = (i = this._carIcon) == null ? void 0 : i.getImage()) == null || r.setRotation(-this._direction + Math.PI);
                }
                this._animateStart.setStyle(this._carIcon), this._animateStart.getGeometry().setCoordinates(f.getLastCoordinate()), ((a = this._animateLayer.getSource()) == null ? void 0 : a.getFeatureById("moveCarFeature")) || (o = this._animateLayer.getSource()) == null || o.addFeature(this._animateStart);
              }
              const g = c == null ? void 0 : c.getLength();
              let d = 0, A = 0;
              const p = new Be([]);
              this._originPath.forEachSegment(function(m, _) {
                p.setCoordinates([m, _]), A <= g && (A += p.getLength(), d++);
              }), this._moveIdx = this._nodeInfos[d - 1].get("node_idx"), this._step += 5 * 1e-7 * (this._speed || 0);
              const v = (s = this._map) == null ? void 0 : s.getView().getProjection().getCode(), y = { index: this._moveIdx, status: this._status, speed: this._speed, position: this._animateStart.getGeometry().getCoordinates(), lngLat: fN(this._animateStart.getGeometry().getCoordinates(), v), passNode: this._nodesCollection ? this._nodesCollection[this._moveIdx - 1] : void 0, length: g };
              this._animateLayer.dispatchEvent({ type: "move", target: y, propagationStopped: false, defaultPrevented: false, preventDefault: function() {
                throw new Error("Function not implemented.");
              }, stopPropagation: function() {
                throw new Error("Function not implemented.");
              } });
            }
            if (this._moving && this._step && this._step >= 1) {
              this.stop();
              return;
            }
            (l = this._map) == null || l.render();
          }
        }
        setFitView(t) {
          var e;
          this._originPath !== null && t && ((e = this._map) == null || e.getView().fit(this._originPath));
        }
        getPaths() {
          return this._pathInfo;
        }
        setPaths(t) {
          this.clearPaths(), this._pathInfo = t, this.initLinesAndMarkers();
        }
        clearPaths() {
          this._moving && this.stop(), this._group.getLayersArray().forEach((t) => {
            (t instanceof aa || t instanceof qz) && t.getSource().clear();
          });
        }
        destroy() {
          var t, e, i;
          this._moving && this.stop(), this.clearPaths(), yl(this._traceEvent || []), (i = this._map) == null || i.getView().removeEventListener("change:resolution", (t = this._simplifyEvent) != null && t.listener ? (e = this._simplifyEvent) == null ? void 0 : e.listener : () => {
          });
        }
        getSpeed() {
          return this._speed;
        }
        setSpeed(t) {
          this._speed = t;
        }
        getSpeedUp() {
          return this._speedUp;
        }
        setSpeedUp(t) {
          this._speedUp = t, this._speed = (this._speed || 0) * t;
        }
        getPercent() {
          return this._step > 0 ? Number(this._step.toPrecision(3)) : 0;
        }
        setPercent(t) {
          t <= 1 && t >= 0 && (this._step = t);
        }
        setTraceLineStyle(t) {
          var a;
          t = t || {};
          const e = t.lineColor ? t.lineColor : "rgba(0, 0, 255, 0.6)", i = t.lineWidth ? t.lineWidth : 10, r = (a = this._lineLayer.getSource()) == null ? void 0 : a.getFeatures();
          r == null || r.forEach((o) => {
            o.get("arrow")[0].setStroke(new Ke({ color: e, width: i }));
          }), this._lineLayer.changed();
        }
        setPassLineStyle(t) {
          t = t || {};
          const e = t.lineColor ? t.lineColor : "red", i = t.lineWidth ? t.lineWidth : 2, r = new pe({ stroke: new Ke({ color: e, width: i }) });
          this._animateLayer.setStyle(r), this._animateLayer.changed();
        }
        setTraceNodeStyle(t) {
          var l;
          t = t || {};
          const e = t.fillColor ? t.fillColor : "rgba(255,255,255,0.4)", i = t.lineColor ? t.lineColor : "#3399CC", r = t.lineWidth ? t.lineWidth : 1.25, a = t.size ? t.size : 5, o = new me({ color: e }), s = new Ke({ color: i, width: r });
          this._defaultStyles = [new pe({ image: new kr({ fill: o, stroke: s, radius: a }), fill: o, stroke: s })], (l = this._nodesLayer.getSource()) == null || l.getFeatures().forEach((u) => {
            u.setStyle(this._defaultStyles), u.changed();
          });
        }
        getEvents() {
          return this._eventType;
        }
        on(t, e) {
          var r;
          if (this._eventType.includes(t)) return t === "move" ? this._animateLayer.on(t, e) : (r = this._map) == null ? void 0 : r.on(t, e);
        }
        once(t, e) {
          var r;
          if (this._eventType.includes(t)) return t === "move" ? this._animateLayer.once(t, e) : (r = this._map) == null ? void 0 : r.once(t, e);
        }
        un(t, e) {
          var r;
          if (this._eventType.includes(t)) return t === "move" ? this._animateLayer.un(t, e) : (r = this._map) == null ? void 0 : r.un(t, e);
        }
      }
      function nmt(n, t) {
        const e = n.get("arrow"), i = n.get("mainView"), r = [e[0]], a = n.getGeometry();
        if (a && a instanceof Be) {
          const o = a.getLength(), s = 200 * (t || 0) / o;
          for (let l = 0; l <= 1; l += s) {
            const u = a.getCoordinateAt(l);
            if (Jr(i.calculateExtent(), u)) {
              const c = a.getCoordinateAt(l + 5e-5), f = c[0] - u[0], g = c[1] - u[1], d = Math.atan2(g, f);
              if (l !== 0) {
                const A = e[1].clone();
                A.setGeometry(new Ge(u)), A.getImage().setRotation(-d + 2 * Math.PI), r.push(A);
              }
            }
          }
        }
        return r;
      }
      const Nb = P.defineComponent({ name: "OlPath", props: { bubble: { type: Boolean, default: true }, showTracePoint: { type: Boolean, default: true }, tracePointsModePlay: { type: String, default: "" }, path: { type: Array, default: () => [] }, options: { type: Object, default: () => ({}) }, autoPlay: { type: Boolean, default: false }, visible: { type: Boolean, default: true }, labelVisible: { type: Boolean, default: false } }, emits: ["load", "nodeClick", "nodeMouseover", "nodeMouseout", "pathClick", "pathMouseover", "pathMouseout", "move"], setup(n, { expose: t, emit: e }) {
        const i = P.inject("VMap"), r = P.unref(i).map;
        let a = P.shallowRef();
        P.watch(() => n.visible, (E) => {
          const x = r.getLayerGroup();
          if (x) {
            const C = x.getLayers().getArray().find((S) => S.get("type") === "vzTrackPath");
            C && C.setVisible(E);
          }
        }), P.watch(() => n.labelVisible, (E) => {
          const x = r.getLayerGroup();
          if (x) {
            const C = x.getLayers().getArray().find((S) => S.get("type") === "vzTrackPath");
            C && C.getLayersArray().forEach((S) => {
              S.get("id") && S.get("id").indexOf("pathLabelLayer") > -1 && S.setVisible(E);
            });
          }
        });
        const o = (E) => {
          var x, w, C, S, b, T, B;
          if (E && E.length > 0 || n.path && n.path.length > 0) {
            const R = Qt(rt({}, n), { mapObj: r, path: E || n.path }), M = new emt(R);
            M.setTraceLineStyle({ lineColor: ((x = R.options) == null ? void 0 : x.lineColor) || "rgba(0, 0, 255, 0.6)", lineWidth: ((w = R.options) == null ? void 0 : w.lineWidth) || 10 }), M.setPassLineStyle({ lineColor: ((C = R.options) == null ? void 0 : C.passLineColor) || "red", lineWidth: ((S = R.options) == null ? void 0 : S.passLineWidth) || 2 }), M.setTraceNodeStyle({ lineColor: ((b = R.options) == null ? void 0 : b.nodeStrokeColor) || "#3399CC", lineWidth: ((T = R.options) == null ? void 0 : T.nodeStrokeWidth) || 1.25, fillColor: ((B = R.options) == null ? void 0 : B.nodeFillColor) || "rgba(255,255,255,0.4)" }), a.value = M, a.value.getEvents().forEach((L) => {
              var N;
              (N = a.value) == null || N.on(L, (F) => {
                e(L, F);
              });
            }), e("load", a), n.autoPlay && s();
          }
        }, s = (E) => {
          var x;
          (x = a.value) == null || x.start(E);
        }, l = () => {
          var E;
          (E = a.value) == null || E.stop();
        }, u = () => {
          var E;
          (E = a.value) == null || E.pause();
        }, h = () => {
          var E;
          (E = a.value) == null || E.resume();
        }, c = () => {
          var E;
          return (E = a.value) == null ? void 0 : E._status;
        }, f = () => {
          var E;
          (E = a.value) == null || E.destroy();
        }, g = (E) => {
          var x;
          (x = a.value) == null || x.setFitView(E);
        }, d = () => {
          var E;
          return (E = a.value) == null ? void 0 : E.getPaths();
        }, A = (E) => {
          var x;
          (x = a.value) == null || x.setPaths(E);
        }, p = () => {
          var E;
          return (E = a.value) == null ? void 0 : E.getSpeed();
        }, v = (E) => {
          var x;
          (x = a.value) == null || x.setSpeed(E);
        }, y = () => {
          var E;
          return (E = a.value) == null ? void 0 : E.getSpeedUp();
        }, m = (E) => {
          var x;
          (x = a.value) == null || x.setSpeedUp(E);
        }, _ = () => {
          var E;
          return (E = a.value) == null ? void 0 : E.getPercent();
        }, I = (E) => {
          var x;
          (x = a.value) == null || x.setPercent(E);
        };
        P.onMounted(() => {
          o();
        }), t({ init: o, start: s, stop: l, pause: u, resume: h, getStatus: c, destroy: f, setFitView: g, getPaths: d, setPaths: A, getSpeed: p, setSpeed: v, getSpeedUp: y, setSpeedUp: m, getPercent: _, setPercent: I });
      }, render() {
        return null;
      } }), imt = (n) => n.component(Nb.name || "OlPath", Nb);
      var rmt = Error, amt = EvalError, omt = RangeError, smt = ReferenceError, $z = SyntaxError, Sp = TypeError, lmt = URIError, umt = Object.getOwnPropertyDescriptor, x_ = umt;
      if (x_) try {
        x_([], "length");
      } catch (n) {
        x_ = null;
      }
      var w_ = x_, C_ = Object.defineProperty || false;
      if (C_) try {
        C_({}, "a", { value: 1 });
      } catch (n) {
        C_ = false;
      }
      var S_ = C_, Fb, Zz;
      function hmt() {
        return Zz || (Zz = 1, Fb = function() {
          if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return false;
          if (typeof Symbol.iterator == "symbol") return true;
          var t = {}, e = Symbol("test"), i = Object(e);
          if (typeof e == "string" || Object.prototype.toString.call(e) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]") return false;
          var r = 42;
          t[e] = r;
          for (var a in t) return false;
          if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0) return false;
          var o = Object.getOwnPropertySymbols(t);
          if (o.length !== 1 || o[0] !== e || !Object.prototype.propertyIsEnumerable.call(t, e)) return false;
          if (typeof Object.getOwnPropertyDescriptor == "function") {
            var s = Object.getOwnPropertyDescriptor(t, e);
            if (s.value !== r || s.enumerable !== true) return false;
          }
          return true;
        }), Fb;
      }
      var kb, Kz;
      function cmt() {
        if (Kz) return kb;
        Kz = 1;
        var n = typeof Symbol != "undefined" && Symbol, t = hmt();
        return kb = function() {
          return typeof n != "function" || typeof Symbol != "function" || typeof n("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : t();
        }, kb;
      }
      var Ob, Jz;
      function fmt() {
        if (Jz) return Ob;
        Jz = 1;
        var n = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, e = Math.max, i = "[object Function]", r = function(l, u) {
          for (var h = [], c = 0; c < l.length; c += 1) h[c] = l[c];
          for (var f = 0; f < u.length; f += 1) h[f + l.length] = u[f];
          return h;
        }, a = function(l, u) {
          for (var h = [], c = u, f = 0; c < l.length; c += 1, f += 1) h[f] = l[c];
          return h;
        }, o = function(s, l) {
          for (var u = "", h = 0; h < s.length; h += 1) u += s[h], h + 1 < s.length && (u += l);
          return u;
        };
        return Ob = function(l) {
          var u = this;
          if (typeof u != "function" || t.apply(u) !== i) throw new TypeError(n + u);
          for (var h = a(arguments, 1), c, f = function() {
            if (this instanceof c) {
              var v = u.apply(this, r(h, arguments));
              return Object(v) === v ? v : this;
            }
            return u.apply(l, r(h, arguments));
          }, g = e(0, u.length - h.length), d = [], A = 0; A < g; A++) d[A] = "$" + A;
          if (c = Function("binder", "return function (" + o(d, ",") + "){ return binder.apply(this,arguments); }")(f), u.prototype) {
            var p = function() {
            };
            p.prototype = u.prototype, c.prototype = new p(), p.prototype = null;
          }
          return c;
        }, Ob;
      }
      var Qb, tG;
      function bp() {
        if (tG) return Qb;
        tG = 1;
        var n = fmt();
        return Qb = Function.prototype.bind || n, Qb;
      }
      var zb, eG;
      function Gb() {
        return eG || (eG = 1, zb = Function.prototype.call), zb;
      }
      var Ub, nG;
      function Vb() {
        return nG || (nG = 1, Ub = Function.prototype.apply), Ub;
      }
      var gmt = typeof Reflect != "undefined" && Reflect && Reflect.apply, dmt = bp(), Amt = Vb(), pmt = Gb(), vmt = gmt, iG = vmt || dmt.call(pmt, Amt), ymt = bp(), mmt = Sp, _mt = Gb(), Emt = iG, rG = function(t) {
        if (t.length < 1 || typeof t[0] != "function") throw new mmt("a function is required");
        return Emt(ymt, _mt, t);
      }, jb, aG;
      function Imt() {
        if (aG) return jb;
        aG = 1;
        var n = rG, t = w_, e = [].__proto__ === Array.prototype, i = e && t && t(Object.prototype, "__proto__"), r = Object, a = r.getPrototypeOf;
        return jb = i && typeof i.get == "function" ? n([i.get]) : typeof a == "function" ? function(s) {
          return a(s == null ? s : r(s));
        } : false, jb;
      }
      var qb, oG;
      function xmt() {
        if (oG) return qb;
        oG = 1;
        var n = Function.prototype.call, t = Object.prototype.hasOwnProperty, e = bp();
        return qb = e.call(n, t), qb;
      }
      var Se, wmt = rmt, Cmt = amt, Smt = omt, bmt = smt, Ag = $z, pg = Sp, Tmt = lmt, sG = Function, Hb = function(n) {
        try {
          return sG('"use strict"; return (' + n + ").constructor;")();
        } catch (t) {
        }
      }, Tp = w_, Bmt = S_, Yb = function() {
        throw new pg();
      }, Mmt = Tp ? function() {
        try {
          return arguments.callee, Yb;
        } catch (n) {
          try {
            return Tp(arguments, "callee").get;
          } catch (t) {
            return Yb;
          }
        }
      }() : Yb, vg = cmt()(), Dmt = Imt(), ci = typeof Reflect == "function" && Reflect.getPrototypeOf || Object.getPrototypeOf || Dmt, lG = Vb(), Bp = Gb(), yg = {}, Rmt = typeof Uint8Array == "undefined" || !ci ? Se : ci(Uint8Array), gh = { __proto__: null, "%AggregateError%": typeof AggregateError == "undefined" ? Se : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer == "undefined" ? Se : ArrayBuffer, "%ArrayIteratorPrototype%": vg && ci ? ci([][Symbol.iterator]()) : Se, "%AsyncFromSyncIteratorPrototype%": Se, "%AsyncFunction%": yg, "%AsyncGenerator%": yg, "%AsyncGeneratorFunction%": yg, "%AsyncIteratorPrototype%": yg, "%Atomics%": typeof Atomics == "undefined" ? Se : Atomics, "%BigInt%": typeof BigInt == "undefined" ? Se : BigInt, "%BigInt64Array%": typeof BigInt64Array == "undefined" ? Se : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array == "undefined" ? Se : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView == "undefined" ? Se : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": wmt, "%eval%": eval, "%EvalError%": Cmt, "%Float32Array%": typeof Float32Array == "undefined" ? Se : Float32Array, "%Float64Array%": typeof Float64Array == "undefined" ? Se : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry == "undefined" ? Se : FinalizationRegistry, "%Function%": sG, "%GeneratorFunction%": yg, "%Int8Array%": typeof Int8Array == "undefined" ? Se : Int8Array, "%Int16Array%": typeof Int16Array == "undefined" ? Se : Int16Array, "%Int32Array%": typeof Int32Array == "undefined" ? Se : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": vg && ci ? ci(ci([][Symbol.iterator]())) : Se, "%JSON%": typeof JSON == "object" ? JSON : Se, "%Map%": typeof Map == "undefined" ? Se : Map, "%MapIteratorPrototype%": typeof Map == "undefined" || !vg || !ci ? Se : ci((/* @__PURE__ */ new Map())[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%Object.getOwnPropertyDescriptor%": Tp, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise == "undefined" ? Se : Promise, "%Proxy%": typeof Proxy == "undefined" ? Se : Proxy, "%RangeError%": Smt, "%ReferenceError%": bmt, "%Reflect%": typeof Reflect == "undefined" ? Se : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set == "undefined" ? Se : Set, "%SetIteratorPrototype%": typeof Set == "undefined" || !vg || !ci ? Se : ci((/* @__PURE__ */ new Set())[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer == "undefined" ? Se : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": vg && ci ? ci(""[Symbol.iterator]()) : Se, "%Symbol%": vg ? Symbol : Se, "%SyntaxError%": Ag, "%ThrowTypeError%": Mmt, "%TypedArray%": Rmt, "%TypeError%": pg, "%Uint8Array%": typeof Uint8Array == "undefined" ? Se : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray == "undefined" ? Se : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array == "undefined" ? Se : Uint16Array, "%Uint32Array%": typeof Uint32Array == "undefined" ? Se : Uint32Array, "%URIError%": Tmt, "%WeakMap%": typeof WeakMap == "undefined" ? Se : WeakMap, "%WeakRef%": typeof WeakRef == "undefined" ? Se : WeakRef, "%WeakSet%": typeof WeakSet == "undefined" ? Se : WeakSet, "%Function.prototype.call%": Bp, "%Function.prototype.apply%": lG, "%Object.defineProperty%": Bmt };
      if (ci) try {
        null.error;
      } catch (n) {
        var Lmt = ci(ci(n));
        gh["%Error.prototype%"] = Lmt;
      }
      var Pmt = function n(t) {
        var e;
        if (t === "%AsyncFunction%") e = Hb("async function () {}");
        else if (t === "%GeneratorFunction%") e = Hb("function* () {}");
        else if (t === "%AsyncGeneratorFunction%") e = Hb("async function* () {}");
        else if (t === "%AsyncGenerator%") {
          var i = n("%AsyncGeneratorFunction%");
          i && (e = i.prototype);
        } else if (t === "%AsyncIteratorPrototype%") {
          var r = n("%AsyncGenerator%");
          r && ci && (e = ci(r.prototype));
        }
        return gh[t] = e, e;
      }, uG = { __proto__: null, "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, Mp = bp(), b_ = xmt(), Nmt = Mp.call(Bp, Array.prototype.concat), Fmt = Mp.call(lG, Array.prototype.splice), hG = Mp.call(Bp, String.prototype.replace), T_ = Mp.call(Bp, String.prototype.slice), kmt = Mp.call(Bp, RegExp.prototype.exec), Omt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Qmt = /\\(\\)?/g, zmt = function(t) {
        var e = T_(t, 0, 1), i = T_(t, -1);
        if (e === "%" && i !== "%") throw new Ag("invalid intrinsic syntax, expected closing `%`");
        if (i === "%" && e !== "%") throw new Ag("invalid intrinsic syntax, expected opening `%`");
        var r = [];
        return hG(t, Omt, function(a, o, s, l) {
          r[r.length] = s ? hG(l, Qmt, "$1") : o || a;
        }), r;
      }, Gmt = function(t, e) {
        var i = t, r;
        if (b_(uG, i) && (r = uG[i], i = "%" + r[0] + "%"), b_(gh, i)) {
          var a = gh[i];
          if (a === yg && (a = Pmt(i)), typeof a == "undefined" && !e) throw new pg("intrinsic " + t + " exists, but is not available. Please file an issue!");
          return { alias: r, name: i, value: a };
        }
        throw new Ag("intrinsic " + t + " does not exist!");
      }, Wb = function(t, e) {
        if (typeof t != "string" || t.length === 0) throw new pg("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof e != "boolean") throw new pg('"allowMissing" argument must be a boolean');
        if (kmt(/^%?[^%]*%?$/, t) === null) throw new Ag("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var i = zmt(t), r = i.length > 0 ? i[0] : "", a = Gmt("%" + r + "%", e), o = a.name, s = a.value, l = false, u = a.alias;
        u && (r = u[0], Fmt(i, Nmt([0, 1], u)));
        for (var h = 1, c = true; h < i.length; h += 1) {
          var f = i[h], g = T_(f, 0, 1), d = T_(f, -1);
          if ((g === '"' || g === "'" || g === "`" || d === '"' || d === "'" || d === "`") && g !== d) throw new Ag("property names with quotes must have matching quotes");
          if ((f === "constructor" || !c) && (l = true), r += "." + f, o = "%" + r + "%", b_(gh, o)) s = gh[o];
          else if (s != null) {
            if (!(f in s)) {
              if (!e) throw new pg("base intrinsic for " + t + " exists, but the property is not available.");
              return;
            }
            if (Tp && h + 1 >= i.length) {
              var A = Tp(s, f);
              c = !!A, c && "get" in A && !("originalValue" in A.get) ? s = A.get : s = s[f];
            } else c = b_(s, f), s = s[f];
            c && !l && (gh[o] = s);
          }
        }
        return s;
      }, cG = { exports: {} }, fG = S_, Umt = $z, mg = Sp, gG = w_, Vmt = function(t, e, i) {
        if (!t || typeof t != "object" && typeof t != "function") throw new mg("`obj` must be an object or a function`");
        if (typeof e != "string" && typeof e != "symbol") throw new mg("`property` must be a string or a symbol`");
        if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new mg("`nonEnumerable`, if provided, must be a boolean or null");
        if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new mg("`nonWritable`, if provided, must be a boolean or null");
        if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new mg("`nonConfigurable`, if provided, must be a boolean or null");
        if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new mg("`loose`, if provided, must be a boolean");
        var r = arguments.length > 3 ? arguments[3] : null, a = arguments.length > 4 ? arguments[4] : null, o = arguments.length > 5 ? arguments[5] : null, s = arguments.length > 6 ? arguments[6] : false, l = !!gG && gG(t, e);
        if (fG) fG(t, e, { configurable: o === null && l ? l.configurable : !o, enumerable: r === null && l ? l.enumerable : !r, value: i, writable: a === null && l ? l.writable : !a });
        else if (s || !r && !a && !o) t[e] = i;
        else throw new Umt("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }, Xb = S_, dG = function() {
        return !!Xb;
      };
      dG.hasArrayLengthDefineBug = function() {
        if (!Xb) return null;
        try {
          return Xb([], "length", { value: 1 }).length !== 1;
        } catch (t) {
          return true;
        }
      };
      var jmt = dG, qmt = Wb, AG = Vmt, Hmt = jmt(), pG = w_, vG = Sp, Ymt = qmt("%Math.floor%"), Wmt = function(t, e) {
        if (typeof t != "function") throw new vG("`fn` is not a function");
        if (typeof e != "number" || e < 0 || e > 4294967295 || Ymt(e) !== e) throw new vG("`length` must be a positive 32-bit integer");
        var i = arguments.length > 2 && !!arguments[2], r = true, a = true;
        if ("length" in t && pG) {
          var o = pG(t, "length");
          o && !o.configurable && (r = false), o && !o.writable && (a = false);
        }
        return (r || a || !i) && (Hmt ? AG(t, "length", e, true, true) : AG(t, "length", e)), t;
      }, Xmt = bp(), $mt = Vb(), Zmt = iG, Kmt = function() {
        return Zmt(Xmt, $mt, arguments);
      };
      (function(n) {
        var t = Wmt, e = S_, i = rG, r = Kmt;
        n.exports = function(o) {
          var s = i(arguments), l = o.length - (arguments.length - 1);
          return t(s, 1 + (l > 0 ? l : 0), true);
        }, e ? e(n.exports, "apply", { value: r }) : n.exports.apply = r;
      })(cG);
      var Jmt = cG.exports, yG = Wb, mG = Jmt, t0t = mG(yG("String.prototype.indexOf")), e0t = function(t, e) {
        var i = yG(t, !!e);
        return typeof i == "function" && t0t(t, ".prototype.") > -1 ? mG(i) : i;
      };
      const n0t = but(xht);
      var $b = typeof Map == "function" && Map.prototype, Zb = Object.getOwnPropertyDescriptor && $b ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, B_ = $b && Zb && typeof Zb.get == "function" ? Zb.get : null, _G = $b && Map.prototype.forEach, Kb = typeof Set == "function" && Set.prototype, Jb = Object.getOwnPropertyDescriptor && Kb ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, M_ = Kb && Jb && typeof Jb.get == "function" ? Jb.get : null, EG = Kb && Set.prototype.forEach, i0t = typeof WeakMap == "function" && WeakMap.prototype, Dp = i0t ? WeakMap.prototype.has : null, r0t = typeof WeakSet == "function" && WeakSet.prototype, Rp = r0t ? WeakSet.prototype.has : null, a0t = typeof WeakRef == "function" && WeakRef.prototype, IG = a0t ? WeakRef.prototype.deref : null, o0t = Boolean.prototype.valueOf, s0t = Object.prototype.toString, l0t = Function.prototype.toString, u0t = String.prototype.match, t2 = String.prototype.slice, Hl = String.prototype.replace, h0t = String.prototype.toUpperCase, xG = String.prototype.toLowerCase, wG = RegExp.prototype.test, CG = Array.prototype.concat, ko = Array.prototype.join, c0t = Array.prototype.slice, SG = Math.floor, e2 = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, n2 = Object.getOwnPropertySymbols, i2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, _g = typeof Symbol == "function" && typeof Symbol.iterator == "object", Ri = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === _g || true) ? Symbol.toStringTag : null, bG = Object.prototype.propertyIsEnumerable, TG = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(n) {
        return n.__proto__;
      } : null);
      function BG(n, t) {
        if (n === 1 / 0 || n === -1 / 0 || n !== n || n && n > -1e3 && n < 1e3 || wG.call(/e/, t)) return t;
        var e = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof n == "number") {
          var i = n < 0 ? -SG(-n) : SG(n);
          if (i !== n) {
            var r = String(i), a = t2.call(t, r.length + 1);
            return Hl.call(r, e, "$&_") + "." + Hl.call(Hl.call(a, /([0-9]{3})/g, "$&_"), /_$/, "");
          }
        }
        return Hl.call(t, e, "$&_");
      }
      var r2 = n0t, MG = r2.custom, DG = NG(MG) ? MG : null, RG = { __proto__: null, double: '"', single: "'" }, f0t = { __proto__: null, double: /(["\\])/g, single: /(['\\])/g }, g0t = function n(t, e, i, r) {
        var a = e || {};
        if (ks(a, "quoteStyle") && !ks(RG, a.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
        if (ks(a, "maxStringLength") && (typeof a.maxStringLength == "number" ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0 : a.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        var o = ks(a, "customInspect") ? a.customInspect : true;
        if (typeof o != "boolean" && o !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        if (ks(a, "indent") && a.indent !== null && a.indent !== "	" && !(parseInt(a.indent, 10) === a.indent && a.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        if (ks(a, "numericSeparator") && typeof a.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        var s = a.numericSeparator;
        if (typeof t == "undefined") return "undefined";
        if (t === null) return "null";
        if (typeof t == "boolean") return t ? "true" : "false";
        if (typeof t == "string") return kG(t, a);
        if (typeof t == "number") {
          if (t === 0) return 1 / 0 / t > 0 ? "0" : "-0";
          var l = String(t);
          return s ? BG(t, l) : l;
        }
        if (typeof t == "bigint") {
          var u = String(t) + "n";
          return s ? BG(t, u) : u;
        }
        var h = typeof a.depth == "undefined" ? 5 : a.depth;
        if (typeof i == "undefined" && (i = 0), i >= h && h > 0 && typeof t == "object") return a2(t) ? "[Array]" : "[Object]";
        var c = D0t(a, i);
        if (typeof r == "undefined") r = [];
        else if (FG(r, t) >= 0) return "[Circular]";
        function f(B, R, M) {
          if (R && (r = c0t.call(r), r.push(R)), M) {
            var L = { depth: a.depth };
            return ks(a, "quoteStyle") && (L.quoteStyle = a.quoteStyle), n(B, L, i + 1, r);
          }
          return n(B, a, i + 1, r);
        }
        if (typeof t == "function" && !PG(t)) {
          var g = I0t(t), d = D_(t, f);
          return "[Function" + (g ? ": " + g : " (anonymous)") + "]" + (d.length > 0 ? " { " + ko.call(d, ", ") + " }" : "");
        }
        if (NG(t)) {
          var A = _g ? Hl.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : i2.call(t);
          return typeof t == "object" && !_g ? Lp(A) : A;
        }
        if (T0t(t)) {
          for (var p = "<" + xG.call(String(t.nodeName)), v = t.attributes || [], y = 0; y < v.length; y++) p += " " + v[y].name + "=" + LG(d0t(v[y].value), "double", a);
          return p += ">", t.childNodes && t.childNodes.length && (p += "..."), p += "</" + xG.call(String(t.nodeName)) + ">", p;
        }
        if (a2(t)) {
          if (t.length === 0) return "[]";
          var m = D_(t, f);
          return c && !M0t(m) ? "[" + s2(m, c) + "]" : "[ " + ko.call(m, ", ") + " ]";
        }
        if (p0t(t)) {
          var _ = D_(t, f);
          return !("cause" in Error.prototype) && "cause" in t && !bG.call(t, "cause") ? "{ [" + String(t) + "] " + ko.call(CG.call("[cause]: " + f(t.cause), _), ", ") + " }" : _.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + ko.call(_, ", ") + " }";
        }
        if (typeof t == "object" && o) {
          if (DG && typeof t[DG] == "function" && r2) return r2(t, { depth: h - i });
          if (o !== "symbol" && typeof t.inspect == "function") return t.inspect();
        }
        if (x0t(t)) {
          var I = [];
          return _G && _G.call(t, function(B, R) {
            I.push(f(R, t, true) + " => " + f(B, t));
          }), OG("Map", B_.call(t), I, c);
        }
        if (S0t(t)) {
          var E = [];
          return EG && EG.call(t, function(B) {
            E.push(f(B, t));
          }), OG("Set", M_.call(t), E, c);
        }
        if (w0t(t)) return o2("WeakMap");
        if (b0t(t)) return o2("WeakSet");
        if (C0t(t)) return o2("WeakRef");
        if (y0t(t)) return Lp(f(Number(t)));
        if (_0t(t)) return Lp(f(e2.call(t)));
        if (m0t(t)) return Lp(o0t.call(t));
        if (v0t(t)) return Lp(f(String(t)));
        if (typeof window != "undefined" && t === window) return "{ [object Window] }";
        if (typeof globalThis != "undefined" && t === globalThis || typeof bQ != "undefined" && t === bQ) return "{ [object globalThis] }";
        if (!A0t(t) && !PG(t)) {
          var x = D_(t, f), w = TG ? TG(t) === Object.prototype : t instanceof Object || t.constructor === Object, C = t instanceof Object ? "" : "null prototype", S = !w && Ri && Object(t) === t && Ri in t ? t2.call(Yl(t), 8, -1) : C ? "Object" : "", b = w || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : "", T = b + (S || C ? "[" + ko.call(CG.call([], S || [], C || []), ": ") + "] " : "");
          return x.length === 0 ? T + "{}" : c ? T + "{" + s2(x, c) + "}" : T + "{ " + ko.call(x, ", ") + " }";
        }
        return String(t);
      };
      function LG(n, t, e) {
        var i = e.quoteStyle || t, r = RG[i];
        return r + n + r;
      }
      function d0t(n) {
        return Hl.call(String(n), /"/g, "&quot;");
      }
      function a2(n) {
        return Yl(n) === "[object Array]" && (!Ri || !(typeof n == "object" && Ri in n));
      }
      function A0t(n) {
        return Yl(n) === "[object Date]" && (!Ri || !(typeof n == "object" && Ri in n));
      }
      function PG(n) {
        return Yl(n) === "[object RegExp]" && (!Ri || !(typeof n == "object" && Ri in n));
      }
      function p0t(n) {
        return Yl(n) === "[object Error]" && (!Ri || !(typeof n == "object" && Ri in n));
      }
      function v0t(n) {
        return Yl(n) === "[object String]" && (!Ri || !(typeof n == "object" && Ri in n));
      }
      function y0t(n) {
        return Yl(n) === "[object Number]" && (!Ri || !(typeof n == "object" && Ri in n));
      }
      function m0t(n) {
        return Yl(n) === "[object Boolean]" && (!Ri || !(typeof n == "object" && Ri in n));
      }
      function NG(n) {
        if (_g) return n && typeof n == "object" && n instanceof Symbol;
        if (typeof n == "symbol") return true;
        if (!n || typeof n != "object" || !i2) return false;
        try {
          return i2.call(n), true;
        } catch (t) {
        }
        return false;
      }
      function _0t(n) {
        if (!n || typeof n != "object" || !e2) return false;
        try {
          return e2.call(n), true;
        } catch (t) {
        }
        return false;
      }
      var E0t = Object.prototype.hasOwnProperty || function(n) {
        return n in this;
      };
      function ks(n, t) {
        return E0t.call(n, t);
      }
      function Yl(n) {
        return s0t.call(n);
      }
      function I0t(n) {
        if (n.name) return n.name;
        var t = u0t.call(l0t.call(n), /^function\s*([\w$]+)/);
        return t ? t[1] : null;
      }
      function FG(n, t) {
        if (n.indexOf) return n.indexOf(t);
        for (var e = 0, i = n.length; e < i; e++) if (n[e] === t) return e;
        return -1;
      }
      function x0t(n) {
        if (!B_ || !n || typeof n != "object") return false;
        try {
          B_.call(n);
          try {
            M_.call(n);
          } catch (t) {
            return true;
          }
          return n instanceof Map;
        } catch (t) {
        }
        return false;
      }
      function w0t(n) {
        if (!Dp || !n || typeof n != "object") return false;
        try {
          Dp.call(n, Dp);
          try {
            Rp.call(n, Rp);
          } catch (t) {
            return true;
          }
          return n instanceof WeakMap;
        } catch (t) {
        }
        return false;
      }
      function C0t(n) {
        if (!IG || !n || typeof n != "object") return false;
        try {
          return IG.call(n), true;
        } catch (t) {
        }
        return false;
      }
      function S0t(n) {
        if (!M_ || !n || typeof n != "object") return false;
        try {
          M_.call(n);
          try {
            B_.call(n);
          } catch (t) {
            return true;
          }
          return n instanceof Set;
        } catch (t) {
        }
        return false;
      }
      function b0t(n) {
        if (!Rp || !n || typeof n != "object") return false;
        try {
          Rp.call(n, Rp);
          try {
            Dp.call(n, Dp);
          } catch (t) {
            return true;
          }
          return n instanceof WeakSet;
        } catch (t) {
        }
        return false;
      }
      function T0t(n) {
        return !n || typeof n != "object" ? false : typeof HTMLElement != "undefined" && n instanceof HTMLElement ? true : typeof n.nodeName == "string" && typeof n.getAttribute == "function";
      }
      function kG(n, t) {
        if (n.length > t.maxStringLength) {
          var e = n.length - t.maxStringLength, i = "... " + e + " more character" + (e > 1 ? "s" : "");
          return kG(t2.call(n, 0, t.maxStringLength), t) + i;
        }
        var r = f0t[t.quoteStyle || "single"];
        r.lastIndex = 0;
        var a = Hl.call(Hl.call(n, r, "\\$1"), /[\x00-\x1f]/g, B0t);
        return LG(a, "single", t);
      }
      function B0t(n) {
        var t = n.charCodeAt(0), e = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[t];
        return e ? "\\" + e : "\\x" + (t < 16 ? "0" : "") + h0t.call(t.toString(16));
      }
      function Lp(n) {
        return "Object(" + n + ")";
      }
      function o2(n) {
        return n + " { ? }";
      }
      function OG(n, t, e, i) {
        var r = i ? s2(e, i) : ko.call(e, ", ");
        return n + " (" + t + ") {" + r + "}";
      }
      function M0t(n) {
        for (var t = 0; t < n.length; t++) if (FG(n[t], `
`) >= 0) return false;
        return true;
      }
      function D0t(n, t) {
        var e;
        if (n.indent === "	") e = "	";
        else if (typeof n.indent == "number" && n.indent > 0) e = ko.call(Array(n.indent + 1), " ");
        else return null;
        return { base: e, prev: ko.call(Array(t + 1), e) };
      }
      function s2(n, t) {
        if (n.length === 0) return "";
        var e = `
` + t.prev + t.base;
        return e + ko.call(n, "," + e) + `
` + t.prev;
      }
      function D_(n, t) {
        var e = a2(n), i = [];
        if (e) {
          i.length = n.length;
          for (var r = 0; r < n.length; r++) i[r] = ks(n, r) ? t(n[r], n) : "";
        }
        var a = typeof n2 == "function" ? n2(n) : [], o;
        if (_g) {
          o = {};
          for (var s = 0; s < a.length; s++) o["$" + a[s]] = a[s];
        }
        for (var l in n) ks(n, l) && (e && String(Number(l)) === l && l < n.length || _g && o["$" + l] instanceof Symbol || (wG.call(/[^\w$]/, l) ? i.push(t(l, n) + ": " + t(n[l], n)) : i.push(l + ": " + t(n[l], n))));
        if (typeof n2 == "function") for (var u = 0; u < a.length; u++) bG.call(n, a[u]) && i.push("[" + t(a[u]) + "]: " + t(n[a[u]], n));
        return i;
      }
      var QG = Wb, Eg = e0t, R0t = g0t, L0t = Sp, R_ = QG("%WeakMap%", true), L_ = QG("%Map%", true), P0t = Eg("WeakMap.prototype.get", true), N0t = Eg("WeakMap.prototype.set", true), F0t = Eg("WeakMap.prototype.has", true), k0t = Eg("Map.prototype.get", true), O0t = Eg("Map.prototype.set", true), Q0t = Eg("Map.prototype.has", true), l2 = function(n, t) {
        for (var e = n, i; (i = e.next) !== null; e = i) if (i.key === t) return e.next = i.next, i.next = n.next, n.next = i, i;
      }, z0t = function(n, t) {
        var e = l2(n, t);
        return e && e.value;
      }, G0t = function(n, t, e) {
        var i = l2(n, t);
        i ? i.value = e : n.next = { key: t, next: n.next, value: e };
      }, U0t = function(n, t) {
        return !!l2(n, t);
      }, V0t = function() {
        var t, e, i, r = { assert: function(a) {
          if (!r.has(a)) throw new L0t("Side channel does not contain " + R0t(a));
        }, get: function(a) {
          if (R_ && a && (typeof a == "object" || typeof a == "function")) {
            if (t) return P0t(t, a);
          } else if (L_) {
            if (e) return k0t(e, a);
          } else if (i) return z0t(i, a);
        }, has: function(a) {
          if (R_ && a && (typeof a == "object" || typeof a == "function")) {
            if (t) return F0t(t, a);
          } else if (L_) {
            if (e) return Q0t(e, a);
          } else if (i) return U0t(i, a);
          return false;
        }, set: function(a, o) {
          R_ && a && (typeof a == "object" || typeof a == "function") ? (t || (t = new R_()), N0t(t, a, o)) : L_ ? (e || (e = new L_()), O0t(e, a, o)) : (i || (i = { key: {}, next: null }), G0t(i, a, o));
        } };
        return r;
      }, j0t = String.prototype.replace, q0t = /%20/g, u2 = { RFC1738: "RFC1738", RFC3986: "RFC3986" }, h2 = { default: u2.RFC3986, formatters: { RFC1738: function(n) {
        return j0t.call(n, q0t, "+");
      }, RFC3986: function(n) {
        return String(n);
      } }, RFC1738: u2.RFC1738, RFC3986: u2.RFC3986 }, H0t = h2, c2 = Object.prototype.hasOwnProperty, dh = Array.isArray, Oo = function() {
        for (var n = [], t = 0; t < 256; ++t) n.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
        return n;
      }(), Y0t = function(t) {
        for (; t.length > 1; ) {
          var e = t.pop(), i = e.obj[e.prop];
          if (dh(i)) {
            for (var r = [], a = 0; a < i.length; ++a) typeof i[a] != "undefined" && r.push(i[a]);
            e.obj[e.prop] = r;
          }
        }
      }, zG = function(t, e) {
        for (var i = e && e.plainObjects ? { __proto__: null } : {}, r = 0; r < t.length; ++r) typeof t[r] != "undefined" && (i[r] = t[r]);
        return i;
      }, W0t = function n(t, e, i) {
        if (!e) return t;
        if (typeof e != "object" && typeof e != "function") {
          if (dh(t)) t.push(e);
          else if (t && typeof t == "object") (i && (i.plainObjects || i.allowPrototypes) || !c2.call(Object.prototype, e)) && (t[e] = true);
          else return [t, e];
          return t;
        }
        if (!t || typeof t != "object") return [t].concat(e);
        var r = t;
        return dh(t) && !dh(e) && (r = zG(t, i)), dh(t) && dh(e) ? (e.forEach(function(a, o) {
          if (c2.call(t, o)) {
            var s = t[o];
            s && typeof s == "object" && a && typeof a == "object" ? t[o] = n(s, a, i) : t.push(a);
          } else t[o] = a;
        }), t) : Object.keys(e).reduce(function(a, o) {
          var s = e[o];
          return c2.call(a, o) ? a[o] = n(a[o], s, i) : a[o] = s, a;
        }, r);
      }, X0t = function(t, e) {
        return Object.keys(e).reduce(function(i, r) {
          return i[r] = e[r], i;
        }, t);
      }, $0t = function(n, t, e) {
        var i = n.replace(/\+/g, " ");
        if (e === "iso-8859-1") return i.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
          return decodeURIComponent(i);
        } catch (r) {
          return i;
        }
      }, f2 = 1024, Z0t = function(t, e, i, r, a) {
        if (t.length === 0) return t;
        var o = t;
        if (typeof t == "symbol" ? o = Symbol.prototype.toString.call(t) : typeof t != "string" && (o = String(t)), i === "iso-8859-1") return escape(o).replace(/%u[0-9a-f]{4}/gi, function(g) {
          return "%26%23" + parseInt(g.slice(2), 16) + "%3B";
        });
        for (var s = "", l = 0; l < o.length; l += f2) {
          for (var u = o.length >= f2 ? o.slice(l, l + f2) : o, h = [], c = 0; c < u.length; ++c) {
            var f = u.charCodeAt(c);
            if (f === 45 || f === 46 || f === 95 || f === 126 || f >= 48 && f <= 57 || f >= 65 && f <= 90 || f >= 97 && f <= 122 || a === H0t.RFC1738 && (f === 40 || f === 41)) {
              h[h.length] = u.charAt(c);
              continue;
            }
            if (f < 128) {
              h[h.length] = Oo[f];
              continue;
            }
            if (f < 2048) {
              h[h.length] = Oo[192 | f >> 6] + Oo[128 | f & 63];
              continue;
            }
            if (f < 55296 || f >= 57344) {
              h[h.length] = Oo[224 | f >> 12] + Oo[128 | f >> 6 & 63] + Oo[128 | f & 63];
              continue;
            }
            c += 1, f = 65536 + ((f & 1023) << 10 | u.charCodeAt(c) & 1023), h[h.length] = Oo[240 | f >> 18] + Oo[128 | f >> 12 & 63] + Oo[128 | f >> 6 & 63] + Oo[128 | f & 63];
          }
          s += h.join("");
        }
        return s;
      }, K0t = function(t) {
        for (var e = [{ obj: { o: t }, prop: "o" }], i = [], r = 0; r < e.length; ++r) for (var a = e[r], o = a.obj[a.prop], s = Object.keys(o), l = 0; l < s.length; ++l) {
          var u = s[l], h = o[u];
          typeof h == "object" && h !== null && i.indexOf(h) === -1 && (e.push({ obj: o, prop: u }), i.push(h));
        }
        return Y0t(e), t;
      }, J0t = function(t) {
        return Object.prototype.toString.call(t) === "[object RegExp]";
      }, t_t = function(t) {
        return !t || typeof t != "object" ? false : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t));
      }, e_t = function(t, e) {
        return [].concat(t, e);
      }, n_t = function(t, e) {
        if (dh(t)) {
          for (var i = [], r = 0; r < t.length; r += 1) i.push(e(t[r]));
          return i;
        }
        return e(t);
      }, GG = { arrayToObject: zG, assign: X0t, combine: e_t, compact: K0t, decode: $0t, encode: Z0t, isBuffer: t_t, isRegExp: J0t, maybeMap: n_t, merge: W0t }, UG = V0t, P_ = GG, Pp = h2, i_t = Object.prototype.hasOwnProperty, VG = { brackets: function(t) {
        return t + "[]";
      }, comma: "comma", indices: function(t, e) {
        return t + "[" + e + "]";
      }, repeat: function(t) {
        return t;
      } }, Qo = Array.isArray, r_t = Array.prototype.push, jG = function(n, t) {
        r_t.apply(n, Qo(t) ? t : [t]);
      }, a_t = Date.prototype.toISOString, qG = Pp.default, $n = { addQueryPrefix: false, allowDots: false, allowEmptyArrays: false, arrayFormat: "indices", charset: "utf-8", charsetSentinel: false, commaRoundTrip: false, delimiter: "&", encode: true, encodeDotInKeys: false, encoder: P_.encode, encodeValuesOnly: false, filter: void 0, format: qG, formatter: Pp.formatters[qG], indices: false, serializeDate: function(t) {
        return a_t.call(t);
      }, skipNulls: false, strictNullHandling: false }, o_t = function(t) {
        return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint";
      }, g2 = {}, s_t = function n(t, e, i, r, a, o, s, l, u, h, c, f, g, d, A, p, v, y) {
        for (var m = t, _ = y, I = 0, E = false; (_ = _.get(g2)) !== void 0 && !E; ) {
          var x = _.get(t);
          if (I += 1, typeof x != "undefined") {
            if (x === I) throw new RangeError("Cyclic object value");
            E = true;
          }
          typeof _.get(g2) == "undefined" && (I = 0);
        }
        if (typeof h == "function" ? m = h(e, m) : m instanceof Date ? m = g(m) : i === "comma" && Qo(m) && (m = P_.maybeMap(m, function(O) {
          return O instanceof Date ? g(O) : O;
        })), m === null) {
          if (o) return u && !p ? u(e, $n.encoder, v, "key", d) : e;
          m = "";
        }
        if (o_t(m) || P_.isBuffer(m)) {
          if (u) {
            var w = p ? e : u(e, $n.encoder, v, "key", d);
            return [A(w) + "=" + A(u(m, $n.encoder, v, "value", d))];
          }
          return [A(e) + "=" + A(String(m))];
        }
        var C = [];
        if (typeof m == "undefined") return C;
        var S;
        if (i === "comma" && Qo(m)) p && u && (m = P_.maybeMap(m, u)), S = [{ value: m.length > 0 ? m.join(",") || null : void 0 }];
        else if (Qo(h)) S = h;
        else {
          var b = Object.keys(m);
          S = c ? b.sort(c) : b;
        }
        var T = l ? String(e).replace(/\./g, "%2E") : String(e), B = r && Qo(m) && m.length === 1 ? T + "[]" : T;
        if (a && Qo(m) && m.length === 0) return B + "[]";
        for (var R = 0; R < S.length; ++R) {
          var M = S[R], L = typeof M == "object" && M && typeof M.value != "undefined" ? M.value : m[M];
          if (!(s && L === null)) {
            var N = f && l ? String(M).replace(/\./g, "%2E") : String(M), F = Qo(m) ? typeof i == "function" ? i(B, N) : B : B + (f ? "." + N : "[" + N + "]");
            y.set(t, I);
            var k = UG();
            k.set(g2, y), jG(C, n(L, F, i, r, a, o, s, l, i === "comma" && p && Qo(m) ? null : u, h, c, f, g, d, A, p, v, k));
          }
        }
        return C;
      }, l_t = function(t) {
        if (!t) return $n;
        if (typeof t.allowEmptyArrays != "undefined" && typeof t.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof t.encodeDotInKeys != "undefined" && typeof t.encodeDotInKeys != "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
        if (t.encoder !== null && typeof t.encoder != "undefined" && typeof t.encoder != "function") throw new TypeError("Encoder has to be a function.");
        var e = t.charset || $n.charset;
        if (typeof t.charset != "undefined" && t.charset !== "utf-8" && t.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var i = Pp.default;
        if (typeof t.format != "undefined") {
          if (!i_t.call(Pp.formatters, t.format)) throw new TypeError("Unknown format option provided.");
          i = t.format;
        }
        var r = Pp.formatters[i], a = $n.filter;
        (typeof t.filter == "function" || Qo(t.filter)) && (a = t.filter);
        var o;
        if (t.arrayFormat in VG ? o = t.arrayFormat : "indices" in t ? o = t.indices ? "indices" : "repeat" : o = $n.arrayFormat, "commaRoundTrip" in t && typeof t.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        var s = typeof t.allowDots == "undefined" ? t.encodeDotInKeys === true ? true : $n.allowDots : !!t.allowDots;
        return { addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : $n.addQueryPrefix, allowDots: s, allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : $n.allowEmptyArrays, arrayFormat: o, charset: e, charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : $n.charsetSentinel, commaRoundTrip: !!t.commaRoundTrip, delimiter: typeof t.delimiter == "undefined" ? $n.delimiter : t.delimiter, encode: typeof t.encode == "boolean" ? t.encode : $n.encode, encodeDotInKeys: typeof t.encodeDotInKeys == "boolean" ? t.encodeDotInKeys : $n.encodeDotInKeys, encoder: typeof t.encoder == "function" ? t.encoder : $n.encoder, encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : $n.encodeValuesOnly, filter: a, format: i, formatter: r, serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : $n.serializeDate, skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : $n.skipNulls, sort: typeof t.sort == "function" ? t.sort : null, strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : $n.strictNullHandling };
      }, u_t = function(n, t) {
        var e = n, i = l_t(t), r, a;
        typeof i.filter == "function" ? (a = i.filter, e = a("", e)) : Qo(i.filter) && (a = i.filter, r = a);
        var o = [];
        if (typeof e != "object" || e === null) return "";
        var s = VG[i.arrayFormat], l = s === "comma" && i.commaRoundTrip;
        r || (r = Object.keys(e)), i.sort && r.sort(i.sort);
        for (var u = UG(), h = 0; h < r.length; ++h) {
          var c = r[h], f = e[c];
          i.skipNulls && f === null || jG(o, s_t(f, c, s, l, i.allowEmptyArrays, i.strictNullHandling, i.skipNulls, i.encodeDotInKeys, i.encode ? i.encoder : null, i.filter, i.sort, i.allowDots, i.serializeDate, i.format, i.formatter, i.encodeValuesOnly, i.charset, u));
        }
        var g = o.join(i.delimiter), d = i.addQueryPrefix === true ? "?" : "";
        return i.charsetSentinel && (i.charset === "iso-8859-1" ? d += "utf8=%26%2310003%3B&" : d += "utf8=%E2%9C%93&"), g.length > 0 ? d + g : "";
      }, Ig = GG, d2 = Object.prototype.hasOwnProperty, h_t = Array.isArray, Sn = { allowDots: false, allowEmptyArrays: false, allowPrototypes: false, allowSparse: false, arrayLimit: 20, charset: "utf-8", charsetSentinel: false, comma: false, decodeDotInKeys: false, decoder: Ig.decode, delimiter: "&", depth: 5, duplicates: "combine", ignoreQueryPrefix: false, interpretNumericEntities: false, parameterLimit: 1e3, parseArrays: true, plainObjects: false, strictDepth: false, strictNullHandling: false }, c_t = function(n) {
        return n.replace(/&#(\d+);/g, function(t, e) {
          return String.fromCharCode(parseInt(e, 10));
        });
      }, HG = function(n, t) {
        return n && typeof n == "string" && t.comma && n.indexOf(",") > -1 ? n.split(",") : n;
      }, f_t = "utf8=%26%2310003%3B", g_t = "utf8=%E2%9C%93", d_t = function(t, e) {
        var i = { __proto__: null }, r = e.ignoreQueryPrefix ? t.replace(/^\?/, "") : t;
        r = r.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
        var a = e.parameterLimit === 1 / 0 ? void 0 : e.parameterLimit, o = r.split(e.delimiter, a), s = -1, l, u = e.charset;
        if (e.charsetSentinel) for (l = 0; l < o.length; ++l) o[l].indexOf("utf8=") === 0 && (o[l] === g_t ? u = "utf-8" : o[l] === f_t && (u = "iso-8859-1"), s = l, l = o.length);
        for (l = 0; l < o.length; ++l) if (l !== s) {
          var h = o[l], c = h.indexOf("]="), f = c === -1 ? h.indexOf("=") : c + 1, g, d;
          f === -1 ? (g = e.decoder(h, Sn.decoder, u, "key"), d = e.strictNullHandling ? null : "") : (g = e.decoder(h.slice(0, f), Sn.decoder, u, "key"), d = Ig.maybeMap(HG(h.slice(f + 1), e), function(p) {
            return e.decoder(p, Sn.decoder, u, "value");
          })), d && e.interpretNumericEntities && u === "iso-8859-1" && (d = c_t(String(d))), h.indexOf("[]=") > -1 && (d = h_t(d) ? [d] : d);
          var A = d2.call(i, g);
          A && e.duplicates === "combine" ? i[g] = Ig.combine(i[g], d) : (!A || e.duplicates === "last") && (i[g] = d);
        }
        return i;
      }, A_t = function(n, t, e, i) {
        for (var r = i ? t : HG(t, e), a = n.length - 1; a >= 0; --a) {
          var o, s = n[a];
          if (s === "[]" && e.parseArrays) o = e.allowEmptyArrays && (r === "" || e.strictNullHandling && r === null) ? [] : [].concat(r);
          else {
            o = e.plainObjects ? { __proto__: null } : {};
            var l = s.charAt(0) === "[" && s.charAt(s.length - 1) === "]" ? s.slice(1, -1) : s, u = e.decodeDotInKeys ? l.replace(/%2E/g, ".") : l, h = parseInt(u, 10);
            !e.parseArrays && u === "" ? o = { 0: r } : !isNaN(h) && s !== u && String(h) === u && h >= 0 && e.parseArrays && h <= e.arrayLimit ? (o = [], o[h] = r) : u !== "__proto__" && (o[u] = r);
          }
          r = o;
        }
        return r;
      }, p_t = function(t, e, i, r) {
        if (t) {
          var a = i.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t, o = /(\[[^[\]]*])/, s = /(\[[^[\]]*])/g, l = i.depth > 0 && o.exec(a), u = l ? a.slice(0, l.index) : a, h = [];
          if (u) {
            if (!i.plainObjects && d2.call(Object.prototype, u) && !i.allowPrototypes) return;
            h.push(u);
          }
          for (var c = 0; i.depth > 0 && (l = s.exec(a)) !== null && c < i.depth; ) {
            if (c += 1, !i.plainObjects && d2.call(Object.prototype, l[1].slice(1, -1)) && !i.allowPrototypes) return;
            h.push(l[1]);
          }
          if (l) {
            if (i.strictDepth === true) throw new RangeError("Input depth exceeded depth option of " + i.depth + " and strictDepth is true");
            h.push("[" + a.slice(l.index) + "]");
          }
          return A_t(h, e, i, r);
        }
      }, v_t = function(t) {
        if (!t) return Sn;
        if (typeof t.allowEmptyArrays != "undefined" && typeof t.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof t.decodeDotInKeys != "undefined" && typeof t.decodeDotInKeys != "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
        if (t.decoder !== null && typeof t.decoder != "undefined" && typeof t.decoder != "function") throw new TypeError("Decoder has to be a function.");
        if (typeof t.charset != "undefined" && t.charset !== "utf-8" && t.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var e = typeof t.charset == "undefined" ? Sn.charset : t.charset, i = typeof t.duplicates == "undefined" ? Sn.duplicates : t.duplicates;
        if (i !== "combine" && i !== "first" && i !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
        var r = typeof t.allowDots == "undefined" ? t.decodeDotInKeys === true ? true : Sn.allowDots : !!t.allowDots;
        return { allowDots: r, allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : Sn.allowEmptyArrays, allowPrototypes: typeof t.allowPrototypes == "boolean" ? t.allowPrototypes : Sn.allowPrototypes, allowSparse: typeof t.allowSparse == "boolean" ? t.allowSparse : Sn.allowSparse, arrayLimit: typeof t.arrayLimit == "number" ? t.arrayLimit : Sn.arrayLimit, charset: e, charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Sn.charsetSentinel, comma: typeof t.comma == "boolean" ? t.comma : Sn.comma, decodeDotInKeys: typeof t.decodeDotInKeys == "boolean" ? t.decodeDotInKeys : Sn.decodeDotInKeys, decoder: typeof t.decoder == "function" ? t.decoder : Sn.decoder, delimiter: typeof t.delimiter == "string" || Ig.isRegExp(t.delimiter) ? t.delimiter : Sn.delimiter, depth: typeof t.depth == "number" || t.depth === false ? +t.depth : Sn.depth, duplicates: i, ignoreQueryPrefix: t.ignoreQueryPrefix === true, interpretNumericEntities: typeof t.interpretNumericEntities == "boolean" ? t.interpretNumericEntities : Sn.interpretNumericEntities, parameterLimit: typeof t.parameterLimit == "number" ? t.parameterLimit : Sn.parameterLimit, parseArrays: t.parseArrays !== false, plainObjects: typeof t.plainObjects == "boolean" ? t.plainObjects : Sn.plainObjects, strictDepth: typeof t.strictDepth == "boolean" ? !!t.strictDepth : Sn.strictDepth, strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Sn.strictNullHandling };
      }, y_t = function(n, t) {
        var e = v_t(t);
        if (n === "" || n === null || typeof n == "undefined") return e.plainObjects ? { __proto__: null } : {};
        for (var i = typeof n == "string" ? d_t(n, e) : n, r = e.plainObjects ? { __proto__: null } : {}, a = Object.keys(i), o = 0; o < a.length; ++o) {
          var s = a[o], l = p_t(s, i[s], e, typeof n == "string");
          r = Ig.merge(r, l, e);
        }
        return e.allowSparse === true ? r : Ig.compact(r);
      }, m_t = u_t, __t = y_t, E_t = h2, I_t = { formats: E_t, parse: __t, stringify: m_t };
      const x_t = up(I_t), w_t = function(n) {
        let t = 0;
        for (let e = 0, i = n.length - 1; e < i; ++e) n[e + 1] && (t += Math.sqrt(Math.pow(n[e + 1][0] - n[e][0], 2) + Math.pow(n[e + 1][1] - n[e][1], 2)));
        return t;
      }, C_t = function(n, t) {
        if (!n) return 0;
        let e = { x: n[0], y: n[1] }, i = { x: t[0], y: t[1] };
        const r = Math.abs(i.x - e.x), a = Math.abs(i.y - e.y), o = Math.sqrt(r * r + a * a), s = Math.asin(a / o);
        let l = 0;
        return i.y < e.y && i.x === e.x ? l = Math.PI * 2 / 3 : i.y > e.y && i.x === e.x ? l = Math.PI / 2 : i.y === e.y && i.x < e.x ? l = Math.PI : i.y === e.y && i.x > e.x ? l = 0 : i.y > e.y && i.x > e.x ? l = s : i.y > e.y && i.x < e.x ? l = Math.PI - s : i.y < e.y && i.x < e.x ? l = Math.PI + s : i.y < e.y && i.x > e.x && (l = Math.PI * 2 - s), l;
      }, S_t = function(n) {
        const t = n.map, e = n.pixel, i = n.coordinates, r = [];
        for (let a = 0; a < i.length - 1; a++) {
          const o = i[a], s = i[a + 1], l = t.getPixelFromCoordinate(o), u = t.getPixelFromCoordinate(s), c = w_t([l, u]), f = Math.floor(c / e), g = C_t(l, u);
          for (let d = 1; d < f + 1; d++) {
            const A = [l[0] + e * d * Math.cos(g), l[1] + e * d * Math.sin(g)], p = t.getCoordinateFromPixel(A);
            r.push({ rotate: g, coordinate: p });
          }
        }
        return r;
      }, b_t = (n) => {
        const { map: t, layer: e, icon: i } = n;
        if (!e) return;
        const r = e.getSource();
        if (!r) return;
        const a = { pixel: n.pixel || 50, coordinates: n.coordinates, map: t }, o = S_t(a), s = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABfUlEQVQ4T3WTTSvFYRDFf8dLKIqytFckthTpJkQWlyhF2fgEVr6BheytpChEsqB08xbZWPgOJAs7ieRlNMzV//75P7vnmZkz58ycR2ZWD7QBF5KM1DGzTuBO0k065neZ2S3QBGwAU5I+iolmNgrsAI9An6SrNIgDnAE9EdgFJiS9+93MuoEToBx4AgYkXSZBHKAWOAS6IrAP5CW9BUge2AIqgJdg8guiSKoBDoDeDJBhwNlVBsiQpNPvGST0VgF7TjPeCsCIpNdo0g84O2fibx4r/AJEUjVwlJDjXbybU/eZjAGbMROXmC8BiKQ64BxoDyYLkuYTTCeB9WD/9B9AA3AMdGQAzALLAfCcluDF3r01itMS5oDFiP3MIUHNi90T7ko/XjyYGOIMsFJSXByimTVGQbFzegOuew0o+7PGKL4AmjM8MA2shua/RjIzX1suw8pucZfiUjOt/AC4BHfaeOoz+d63oziX9Zla3CzAkqTP9G8zM4/dS7r+7zt/Aaattn1kX8VgAAAAAElFTkSuQmCC", l = 0.5;
        for (let u = 0; u < o.length; u++) {
          const h = o[u].coordinate, c = o[u].rotate, f = new Ce({ geometry: new Ge(h) });
          f.setStyle(new pe({ image: new Qr(Qt(rt({ src: s, scale: l }, i), { rotation: c })) })), f.set("isArrow", true), r.addFeature(f);
        }
      }, YG = (n) => {
        if (!n.map || !n.coordinates || n.coordinates.length < 2) return;
        const { layer: t } = n;
        b_t(Qt(rt({}, n), { layer: t }));
      }, A2 = P.defineComponent({ name: "OlRoute", __name: "index", props: { arrow: { default: 50 }, startStyle: {}, endStyle: {}, lineStyle: {}, stopsStyle: {}, layerId: {}, source: {}, layerStyle: {}, featureStyle: {}, modify: { type: Boolean }, className: {}, opacity: {}, visible: { type: Boolean, default: true }, extent: {}, zIndex: {}, minResolution: {}, maxResolution: {}, minZoom: {}, maxZoom: {}, renderOrder: {}, renderBuffer: {}, map: {}, declutter: { type: [String, Number, Boolean] }, background: {}, updateWhileAnimating: { type: Boolean }, updateWhileInteracting: { type: Boolean }, properties: {}, type: {}, url: {}, method: { default: "get" }, params: {} }, emits: ["resolve"], setup(n, { expose: t, emit: e }) {
        const i = P.inject("VMap"), r = P.unref(i).map, a = n;
        let o = P.ref();
        const s = P.shallowRef();
        let l = P.ref(), u = P.ref(), h = P.ref(), c = P.ref(), f = P.ref(), g = P.ref(false), d = P.ref(), A = P.ref(false), p = P.ref(), v = P.ref(false);
        const y = P.computed(() => g.value && A.value), m = { circle: { radius: 14, fill: { color: "rgba(255, 0, 0, 0.5)" }, stroke: { color: "rgba(255, 0, 0, 1)", width: 2 } }, text: { text: "", font: "bold 16px sans-serif", stroke: { color: "rgba(255, 255, 255, 1)", width: 3 } } }, _ = { circle: { radius: 10, fill: { color: "rgba(255, 140, 0, 0.5)" }, stroke: { color: "rgba(255, 140, 0, 1)", width: 2 } } }, I = { circle: { radius: 15, fill: { color: "rgba(0, 255, 0, 0.5)" }, stroke: { color: "rgba(0, 255, 0, 1)", width: 2 } }, text: { text: "", font: "bold 16px sans-serif", stroke: { color: "rgba(255, 255, 255, 1)", width: 3 } } }, E = { stroke: { color: "rgba(67, 126, 255, 0.6)", width: 10 } }, x = () => {
          let q = rt({}, a);
          delete q.method, delete q.arrow, delete q.startStyle, delete q.lineStyle, delete q.endStyle, delete q.stopsStyle, delete q.params, delete q.url, delete q.type, o.value = q;
        };
        P.watchEffect(() => {
          x();
        }), P.onBeforeMount(() => {
          x();
        });
        const w = e, C = (q, W) => Tt(this, null, function* () {
          return fetch(q + "?" + W, { method: "get" }).then((it) => it.json()).then((it) => Promise.resolve(it)).catch((it) => Promise.reject(it));
        }), S = (q, W) => Tt(this, null, function* () {
          return fetch(q, { method: "post", body: JSON.stringify(W) }).then((it) => it.json()).then((it) => Promise.resolve(it)).catch((it) => Promise.reject(it));
        }), b = (q) => Tt(this, null, function* () {
          if (a.url) {
            if (a.method.toUpperCase() === "GET") return C(a.url, q).then((W) => (w("resolve", rt({ type: a.type, method: a.method }, W)), Promise.resolve(W))).catch((W) => Promise.reject(W));
            if (a.method.toUpperCase() === "POST") return S(a.url, q).then((W) => W.json()).then((W) => (w("resolve", rt({ type: a.type, method: a.method }, W)), Promise.resolve(W))).catch((W) => Promise.reject(W));
          }
        }), T = () => {
          const q = et(f.value, p.value, d.value);
          if (q.length === 0) return;
          const W = q.join(";"), it = Qt(rt({}, a.params), { stops: W }), Ot = new URLSearchParams();
          for (const [pt, St] of Object.entries(it)) Ot.append(encodeURIComponent(pt), typeof St == "string" ? St : JSON.stringify(St));
          return a.method === "GET" || a.method === "get" ? Ot : it;
        }, B = () => Tt(this, null, function* () {
          const q = T();
          if (q) return b(q);
        }), R = () => Tt(this, null, function* () {
          const { error: q, routes: W, stops: it } = yield B();
          if (q) return new Error(q.message);
          if (W) {
            const pt = W.features[0].geometry.paths[0].map((bt) => [bt[0], bt[1]]);
            let St;
            if (it) {
              let bt = [];
              it.features.forEach((Ie) => {
                const yn = [Ie.geometry.x, Ie.geometry.y];
                bt.push(yn);
              }), k(bt[0]), O(bt[bt.length - 1]);
              const sn = bt.slice(1, bt.length - 1).map((Ie, yn) => ({ index: yn, coordinate: Ie }));
              Q(sn);
            } else St = pt.length - 1, k(pt[0]), O(pt[St]);
            J(pt);
          }
        }), M = () => Tt(this, null, function* () {
          const { paths: q } = yield L();
          if (q) {
            const { points: W } = q[0];
            J(W.coordinates);
          }
        }), L = () => Tt(this, null, function* () {
          const q = N();
          if (q) return b(q);
        }), N = () => {
          const q = et(f.value, p.value, d.value);
          if (q.length !== 0) if (a.method === "get" || a.method === "GET") {
            let W = x_t.stringify(a.params), it = "&point=";
            return q.forEach((Ot, pt) => {
              it = it + Ot[1] + "," + Ot[0] + (pt < q.length - 1 ? "&point=" : "");
            }), W = W + it, W;
          } else return Qt(rt({}, a.params), { points: q });
        }, F = () => {
          a.type === "arcgis" ? R() : a.type === "graphhopper" && M();
        }, k = (q) => {
          var W;
          if ((W = s.value) == null || W.removeFeatureById("start"), q) {
            f.value = q;
            let it = I;
            Nn(a, "startStyle") && a.startStyle && (it = a.startStyle), l.value = { type: "Feature", geometry: { type: "Point", coordinates: q }, properties: { id: "start", style: it } };
          }
        }, O = (q) => {
          var W;
          if ((W = s.value) == null || W.removeFeatureById("end"), q) {
            d.value = q;
            let it = m;
            Nn(a, "endStyle") && a.endStyle && (it = a.endStyle), u.value = { type: "Feature", geometry: { type: "Point", coordinates: q }, properties: { id: "end", style: it } };
          }
        }, Q = (q) => {
          var it;
          const W = (it = s.value) == null ? void 0 : it.getSource();
          if (W) {
            const Ot = W.getFeatures();
            Ot && Ot.length > 0 && Ot.forEach((pt) => {
              var St;
              pt.get("isStops") && ((St = s.value) == null || St.removeFeatureById(pt.get("id")));
            });
          }
          if (q && q.length > 0) {
            p.value = q.map((pt) => pt.coordinate);
            let Ot = _;
            Nn(a, "stopsStyle") && a.stopsStyle && (Ot = a.stopsStyle), h.value = { type: "FeatureCollection", features: q.map((pt) => ({ type: "Feature", geometry: { type: "Point", coordinates: pt.coordinate }, properties: { isStops: true, id: `stop_${pt.index}`, style: Ot } })) };
          }
        }, j = (q) => Tt(this, null, function* () {
          g.value = !!q, k(q), nt();
        }), Y = (q) => Tt(this, null, function* () {
          A.value = !!q, O(q), nt();
        }), G = (q) => Tt(this, null, function* () {
          v.value = !!q, Q(q), nt();
        });
        let $ = P.ref([]);
        const J = (q) => {
          var it, Ot, pt;
          (it = s.value) == null || it.removeFeatureById("route");
          const W = (Ot = s.value) == null ? void 0 : Ot.getSource();
          if (W) {
            const St = W.getFeatures();
            St && St.length > 0 && St.forEach((bt) => {
              bt.get("isArrow") && W.removeFeature(bt);
            });
          }
          if ($.value.forEach((St) => {
            yl(St);
          }), $.value = [], q) {
            c.value = { type: "Feature", geometry: { type: "LineString", coordinates: q }, properties: { id: "route", style: rt(rt({}, E), a.lineStyle) } };
            const St = (pt = s.value) == null ? void 0 : pt.getLayer();
            W && a.arrow && (YG({ map: r, coordinates: q, layer: St, pixel: a.arrow }), $.value.push(St == null ? void 0 : St.on("postrender", () => {
              const bt = r.getView().getZoom();
              W.getFeatures().forEach((xe) => {
                xe.get("isArrow") && W.removeFeature(xe);
              }), bt && Math.round(bt) === bt && YG({ map: r, coordinates: q, layer: St, pixel: a.arrow });
            })));
          }
        }, et = (q, W, it) => {
          let Ot = [q];
          return W && W.length > 0 && Ot.push(...W), Ot.push(it), Ot;
        }, nt = () => {
          y.value && F();
        };
        return t({ setStartPoint: j, setEndPoint: Y, setStopsPoints: G, reset: nt, clear: () => {
          g.value = false, A.value = false, v.value = false, Q(), k(), O(), J();
        } }), (q, W) => (P.openBlock(), P.createBlock(P.unref(m_), P.mergeProps({ ref_key: "vectorRef", ref: s }, P.unref(o)), { default: P.withCtx(() => [P.createVNode(P.unref(fh), { "geo-json": P.unref(l) }, null, 8, ["geo-json"]), P.createVNode(P.unref(fh), { "geo-json": P.unref(u) }, null, 8, ["geo-json"]), P.createVNode(P.unref(fh), { "geo-json": P.unref(h) }, null, 8, ["geo-json"]), P.createVNode(P.unref(fh), { "geo-json": P.unref(c) }, null, 8, ["geo-json"])]), _: 1 }, 16));
      } }), T_t = (n) => n.component(A2.name || "OlRoute", A2);
      var p2 = function(n, t) {
        return p2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
          e.__proto__ = i;
        } || function(e, i) {
          for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]);
        }, p2(n, t);
      };
      function V(n, t) {
        if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        p2(n, t);
        function e() {
          this.constructor = n;
        }
        n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
      }
      var B_t = /* @__PURE__ */ function() {
        function n() {
          this.firefox = false, this.ie = false, this.edge = false, this.newEdge = false, this.weChat = false;
        }
        return n;
      }(), M_t = /* @__PURE__ */ function() {
        function n() {
          this.browser = new B_t(), this.node = false, this.wxa = false, this.worker = false, this.svgSupported = false, this.touchEventsSupported = false, this.pointerEventsSupported = false, this.domSupported = false, this.transformSupported = false, this.transform3dSupported = false, this.hasGlobalWindow = typeof window != "undefined";
        }
        return n;
      }(), re = new M_t();
      typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (re.wxa = true, re.touchEventsSupported = true) : typeof document == "undefined" && typeof self != "undefined" ? re.worker = true : typeof navigator == "undefined" || navigator.userAgent.indexOf("Node.js") === 0 ? (re.node = true, re.svgSupported = true) : D_t(navigator.userAgent, re);
      function D_t(n, t) {
        var e = t.browser, i = n.match(/Firefox\/([\d.]+)/), r = n.match(/MSIE\s([\d.]+)/) || n.match(/Trident\/.+?rv:(([\d.]+))/), a = n.match(/Edge?\/([\d.]+)/), o = /micromessenger/i.test(n);
        i && (e.firefox = true, e.version = i[1]), r && (e.ie = true, e.version = r[1]), a && (e.edge = true, e.version = a[1], e.newEdge = +a[1].split(".")[0] > 18), o && (e.weChat = true), t.svgSupported = typeof SVGRect != "undefined", t.touchEventsSupported = "ontouchstart" in window && !e.ie && !e.edge, t.pointerEventsSupported = "onpointerdown" in window && (e.edge || e.ie && +e.version >= 11), t.domSupported = typeof document != "undefined";
        var s = document.documentElement.style;
        t.transform3dSupported = (e.ie && "transition" in s || e.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in s) && !("OTransition" in s), t.transformSupported = t.transform3dSupported || e.ie && +e.version >= 9;
      }
      var v2 = 12, WG = "sans-serif", Wl = v2 + "px " + WG, R_t = 20, L_t = 100, P_t = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
      function N_t(n) {
        var t = {};
        if (typeof JSON == "undefined") return t;
        for (var e = 0; e < n.length; e++) {
          var i = String.fromCharCode(e + 32), r = (n.charCodeAt(e) - R_t) / L_t;
          t[i] = r;
        }
        return t;
      }
      var F_t = N_t(P_t), Xl = { createCanvas: function() {
        return typeof document != "undefined" && document.createElement("canvas");
      }, measureText: /* @__PURE__ */ function() {
        var n, t;
        return function(e, i) {
          if (!n) {
            var r = Xl.createCanvas();
            n = r && r.getContext("2d");
          }
          if (n) return t !== i && (t = n.font = i || Wl), n.measureText(e);
          e = e || "", i = i || Wl;
          var a = /((?:\d+)?\.?\d*)px/.exec(i), o = a && +a[1] || v2, s = 0;
          if (i.indexOf("mono") >= 0) s = o * e.length;
          else for (var l = 0; l < e.length; l++) {
            var u = F_t[e[l]];
            s += u == null ? o : u * o;
          }
          return { width: s };
        };
      }(), loadImage: function(n, t, e) {
        var i = new Image();
        return i.onload = t, i.onerror = e, i.src = n, i;
      } }, XG = zo(["Function", "RegExp", "Date", "Error", "CanvasGradient", "CanvasPattern", "Image", "Canvas"], function(n, t) {
        return n["[object " + t + "]"] = true, n;
      }, {}), $G = zo(["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64"], function(n, t) {
        return n["[object " + t + "Array]"] = true, n;
      }, {}), xg = Object.prototype.toString, N_ = Array.prototype, k_t = N_.forEach, O_t = N_.filter, y2 = N_.slice, Q_t = N_.map, ZG = (function() {
      }).constructor, F_ = ZG ? ZG.prototype : null, m2 = "__proto__", z_t = 2311;
      function KG() {
        return z_t++;
      }
      function Ya() {
        for (var n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];
      }
      function Ct(n) {
        if (n == null || typeof n != "object") return n;
        var t = n, e = xg.call(n);
        if (e === "[object Array]") {
          if (!Np(n)) {
            t = [];
            for (var i = 0, r = n.length; i < r; i++) t[i] = Ct(n[i]);
          }
        } else if ($G[e]) {
          if (!Np(n)) {
            var a = n.constructor;
            if (a.from) t = a.from(n);
            else {
              t = new a(n.length);
              for (var i = 0, r = n.length; i < r; i++) t[i] = n[i];
            }
          }
        } else if (!XG[e] && !Np(n) && !Ah(n)) {
          t = {};
          for (var o in n) n.hasOwnProperty(o) && o !== m2 && (t[o] = Ct(n[o]));
        }
        return t;
      }
      function Yt(n, t, e) {
        if (!Et(t) || !Et(n)) return e ? Ct(t) : n;
        for (var i in t) if (t.hasOwnProperty(i) && i !== m2) {
          var r = n[i], a = t[i];
          Et(a) && Et(r) && !Z(a) && !Z(r) && !Ah(a) && !Ah(r) && !JG(a) && !JG(r) && !Np(a) && !Np(r) ? Yt(r, a, e) : (e || !(i in n)) && (n[i] = Ct(t[i]));
        }
        return n;
      }
      function _2(n, t) {
        for (var e = n[0], i = 1, r = n.length; i < r; i++) e = Yt(e, n[i], t);
        return e;
      }
      function X(n, t) {
        if (Object.assign) Object.assign(n, t);
        else for (var e in t) t.hasOwnProperty(e) && e !== m2 && (n[e] = t[e]);
        return n;
      }
      function wt(n, t, e) {
        for (var i = oe(t), r = 0; r < i.length; r++) {
          var a = i[r];
          (e ? t[a] != null : n[a] == null) && (n[a] = t[a]);
        }
        return n;
      }
      function $t(n, t) {
        if (n) {
          if (n.indexOf) return n.indexOf(t);
          for (var e = 0, i = n.length; e < i; e++) if (n[e] === t) return e;
        }
        return -1;
      }
      function G_t(n, t) {
        var e = n.prototype;
        function i() {
        }
        i.prototype = t.prototype, n.prototype = new i();
        for (var r in e) e.hasOwnProperty(r) && (n.prototype[r] = e[r]);
        n.prototype.constructor = n, n.superClass = t;
      }
      function kn(n, t, e) {
        if (n = "prototype" in n ? n.prototype : n, t = "prototype" in t ? t.prototype : t, Object.getOwnPropertyNames) for (var i = Object.getOwnPropertyNames(t), r = 0; r < i.length; r++) {
          var a = i[r];
          a !== "constructor" && (e ? t[a] != null : n[a] == null) && (n[a] = t[a]);
        }
        else wt(n, t, e);
      }
      function Li(n) {
        return !n || typeof n == "string" ? false : typeof n.length == "number";
      }
      function D(n, t, e) {
        if (n && t) if (n.forEach && n.forEach === k_t) n.forEach(t, e);
        else if (n.length === +n.length) for (var i = 0, r = n.length; i < r; i++) t.call(e, n[i], i, n);
        else for (var a in n) n.hasOwnProperty(a) && t.call(e, n[a], a, n);
      }
      function K(n, t, e) {
        if (!n) return [];
        if (!t) return E2(n);
        if (n.map && n.map === Q_t) return n.map(t, e);
        for (var i = [], r = 0, a = n.length; r < a; r++) i.push(t.call(e, n[r], r, n));
        return i;
      }
      function zo(n, t, e, i) {
        if (n && t) {
          for (var r = 0, a = n.length; r < a; r++) e = t.call(i, e, n[r], r, n);
          return e;
        }
      }
      function Fe(n, t, e) {
        if (!n) return [];
        if (!t) return E2(n);
        if (n.filter && n.filter === O_t) return n.filter(t, e);
        for (var i = [], r = 0, a = n.length; r < a; r++) t.call(e, n[r], r, n) && i.push(n[r]);
        return i;
      }
      function U_t(n, t, e) {
        if (n && t) {
          for (var i = 0, r = n.length; i < r; i++) if (t.call(e, n[i], i, n)) return n[i];
        }
      }
      function oe(n) {
        if (!n) return [];
        if (Object.keys) return Object.keys(n);
        var t = [];
        for (var e in n) n.hasOwnProperty(e) && t.push(e);
        return t;
      }
      function V_t(n, t) {
        for (var e = [], i = 2; i < arguments.length; i++) e[i - 2] = arguments[i];
        return function() {
          return n.apply(t, e.concat(y2.call(arguments)));
        };
      }
      var ct = F_ && yt(F_.bind) ? F_.call.bind(F_.bind) : V_t;
      function Gt(n) {
        for (var t = [], e = 1; e < arguments.length; e++) t[e - 1] = arguments[e];
        return function() {
          return n.apply(this, t.concat(y2.call(arguments)));
        };
      }
      function Z(n) {
        return Array.isArray ? Array.isArray(n) : xg.call(n) === "[object Array]";
      }
      function yt(n) {
        return typeof n == "function";
      }
      function ht(n) {
        return typeof n == "string";
      }
      function k_(n) {
        return xg.call(n) === "[object String]";
      }
      function ye(n) {
        return typeof n == "number";
      }
      function Et(n) {
        var t = typeof n;
        return t === "function" || !!n && t === "object";
      }
      function JG(n) {
        return !!XG[xg.call(n)];
      }
      function Yi(n) {
        return !!$G[xg.call(n)];
      }
      function Ah(n) {
        return typeof n == "object" && typeof n.nodeType == "number" && typeof n.ownerDocument == "object";
      }
      function O_(n) {
        return n.colorStops != null;
      }
      function j_t(n) {
        return n.image != null;
      }
      function t5(n) {
        return xg.call(n) === "[object RegExp]";
      }
      function ph(n) {
        return n !== n;
      }
      function On() {
        for (var n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];
        for (var e = 0, i = n.length; e < i; e++) if (n[e] != null) return n[e];
      }
      function kt(n, t) {
        return n != null ? n : t;
      }
      function fa(n, t, e) {
        return n != null ? n : t != null ? t : e;
      }
      function E2(n) {
        for (var t = [], e = 1; e < arguments.length; e++) t[e - 1] = arguments[e];
        return y2.apply(n, t);
      }
      function I2(n) {
        if (typeof n == "number") return [n, n, n, n];
        var t = n.length;
        return t === 2 ? [n[0], n[1], n[0], n[1]] : t === 3 ? [n[0], n[1], n[2], n[1]] : n;
      }
      function It(n, t) {
        if (!n) throw new Error(t);
      }
      function Wa(n) {
        return n == null ? null : typeof n.trim == "function" ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
      }
      var e5 = "__ec_primitive__";
      function Q_(n) {
        n[e5] = true;
      }
      function Np(n) {
        return n[e5];
      }
      var q_t = function() {
        function n() {
          this.data = {};
        }
        return n.prototype.delete = function(t) {
          var e = this.has(t);
          return e && delete this.data[t], e;
        }, n.prototype.has = function(t) {
          return this.data.hasOwnProperty(t);
        }, n.prototype.get = function(t) {
          return this.data[t];
        }, n.prototype.set = function(t, e) {
          return this.data[t] = e, this;
        }, n.prototype.keys = function() {
          return oe(this.data);
        }, n.prototype.forEach = function(t) {
          var e = this.data;
          for (var i in e) e.hasOwnProperty(i) && t(e[i], i);
        }, n;
      }(), n5 = typeof Map == "function";
      function H_t() {
        return n5 ? /* @__PURE__ */ new Map() : new q_t();
      }
      var Y_t = function() {
        function n(t) {
          var e = Z(t);
          this.data = H_t();
          var i = this;
          t instanceof n ? t.each(r) : t && D(t, r);
          function r(a, o) {
            e ? i.set(a, o) : i.set(o, a);
          }
        }
        return n.prototype.hasKey = function(t) {
          return this.data.has(t);
        }, n.prototype.get = function(t) {
          return this.data.get(t);
        }, n.prototype.set = function(t, e) {
          return this.data.set(t, e), e;
        }, n.prototype.each = function(t, e) {
          this.data.forEach(function(i, r) {
            t.call(e, i, r);
          });
        }, n.prototype.keys = function() {
          var t = this.data.keys();
          return n5 ? Array.from(t) : t;
        }, n.prototype.removeKey = function(t) {
          this.data.delete(t);
        }, n;
      }();
      function dt(n) {
        return new Y_t(n);
      }
      function z_(n, t) {
        for (var e = new n.constructor(n.length + t.length), i = 0; i < n.length; i++) e[i] = n[i];
        for (var r = n.length, i = 0; i < t.length; i++) e[i + r] = t[i];
        return e;
      }
      function G_(n, t) {
        var e;
        if (Object.create) e = Object.create(n);
        else {
          var i = function() {
          };
          i.prototype = n, e = new i();
        }
        return t && X(e, t), e;
      }
      function i5(n) {
        var t = n.style;
        t.webkitUserSelect = "none", t.userSelect = "none", t.webkitTapHighlightColor = "rgba(0,0,0,0)", t["-webkit-touch-callout"] = "none";
      }
      function ft(n, t) {
        return n.hasOwnProperty(t);
      }
      function bn() {
      }
      var U_ = 180 / Math.PI;
      function vh(n, t) {
        return n == null && (n = 0), t == null && (t = 0), [n, t];
      }
      function Wi(n, t) {
        return n[0] = t[0], n[1] = t[1], n;
      }
      function Os(n) {
        return [n[0], n[1]];
      }
      function W_t(n, t, e) {
        return n[0] = t, n[1] = e, n;
      }
      function r5(n, t, e) {
        return n[0] = t[0] + e[0], n[1] = t[1] + e[1], n;
      }
      function x2(n, t, e, i) {
        return n[0] = t[0] + e[0] * i, n[1] = t[1] + e[1] * i, n;
      }
      function yh(n, t, e) {
        return n[0] = t[0] - e[0], n[1] = t[1] - e[1], n;
      }
      function w2(n) {
        return Math.sqrt(X_t(n));
      }
      function X_t(n) {
        return n[0] * n[0] + n[1] * n[1];
      }
      function V_(n, t, e) {
        return n[0] = t[0] * e, n[1] = t[1] * e, n;
      }
      function wg(n, t) {
        var e = w2(t);
        return e === 0 ? (n[0] = 0, n[1] = 0) : (n[0] = t[0] / e, n[1] = t[1] / e), n;
      }
      function C2(n, t) {
        return Math.sqrt((n[0] - t[0]) * (n[0] - t[0]) + (n[1] - t[1]) * (n[1] - t[1]));
      }
      var $l = C2;
      function $_t(n, t) {
        return (n[0] - t[0]) * (n[0] - t[0]) + (n[1] - t[1]) * (n[1] - t[1]);
      }
      var mh = $_t;
      function j_(n, t, e, i) {
        return n[0] = t[0] + i * (e[0] - t[0]), n[1] = t[1] + i * (e[1] - t[1]), n;
      }
      function _i(n, t, e) {
        var i = t[0], r = t[1];
        return n[0] = e[0] * i + e[2] * r + e[4], n[1] = e[1] * i + e[3] * r + e[5], n;
      }
      function Zl(n, t, e) {
        return n[0] = Math.min(t[0], e[0]), n[1] = Math.min(t[1], e[1]), n;
      }
      function Kl(n, t, e) {
        return n[0] = Math.max(t[0], e[0]), n[1] = Math.max(t[1], e[1]), n;
      }
      var Cg = /* @__PURE__ */ function() {
        function n(t, e) {
          this.target = t, this.topTarget = e && e.topTarget;
        }
        return n;
      }(), Z_t = function() {
        function n(t) {
          this.handler = t, t.on("mousedown", this._dragStart, this), t.on("mousemove", this._drag, this), t.on("mouseup", this._dragEnd, this);
        }
        return n.prototype._dragStart = function(t) {
          for (var e = t.target; e && !e.draggable; ) e = e.parent || e.__hostTarget;
          e && (this._draggingTarget = e, e.dragging = true, this._x = t.offsetX, this._y = t.offsetY, this.handler.dispatchToElement(new Cg(e, t), "dragstart", t.event));
        }, n.prototype._drag = function(t) {
          var e = this._draggingTarget;
          if (e) {
            var i = t.offsetX, r = t.offsetY, a = i - this._x, o = r - this._y;
            this._x = i, this._y = r, e.drift(a, o, t), this.handler.dispatchToElement(new Cg(e, t), "drag", t.event);
            var s = this.handler.findHover(i, r, e).target, l = this._dropTarget;
            this._dropTarget = s, e !== s && (l && s !== l && this.handler.dispatchToElement(new Cg(l, t), "dragleave", t.event), s && s !== l && this.handler.dispatchToElement(new Cg(s, t), "dragenter", t.event));
          }
        }, n.prototype._dragEnd = function(t) {
          var e = this._draggingTarget;
          e && (e.dragging = false), this.handler.dispatchToElement(new Cg(e, t), "dragend", t.event), this._dropTarget && this.handler.dispatchToElement(new Cg(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null;
        }, n;
      }(), ga = function() {
        function n(t) {
          t && (this._$eventProcessor = t);
        }
        return n.prototype.on = function(t, e, i, r) {
          this._$handlers || (this._$handlers = {});
          var a = this._$handlers;
          if (typeof e == "function" && (r = i, i = e, e = null), !i || !t) return this;
          var o = this._$eventProcessor;
          e != null && o && o.normalizeQuery && (e = o.normalizeQuery(e)), a[t] || (a[t] = []);
          for (var s = 0; s < a[t].length; s++) if (a[t][s].h === i) return this;
          var l = { h: i, query: e, ctx: r || this, callAtLast: i.zrEventfulCallAtLast }, u = a[t].length - 1, h = a[t][u];
          return h && h.callAtLast ? a[t].splice(u, 0, l) : a[t].push(l), this;
        }, n.prototype.isSilent = function(t) {
          var e = this._$handlers;
          return !e || !e[t] || !e[t].length;
        }, n.prototype.off = function(t, e) {
          var i = this._$handlers;
          if (!i) return this;
          if (!t) return this._$handlers = {}, this;
          if (e) {
            if (i[t]) {
              for (var r = [], a = 0, o = i[t].length; a < o; a++) i[t][a].h !== e && r.push(i[t][a]);
              i[t] = r;
            }
            i[t] && i[t].length === 0 && delete i[t];
          } else delete i[t];
          return this;
        }, n.prototype.trigger = function(t) {
          for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
          if (!this._$handlers) return this;
          var r = this._$handlers[t], a = this._$eventProcessor;
          if (r) for (var o = e.length, s = r.length, l = 0; l < s; l++) {
            var u = r[l];
            if (!(a && a.filter && u.query != null && !a.filter(t, u.query))) switch (o) {
              case 0:
                u.h.call(u.ctx);
                break;
              case 1:
                u.h.call(u.ctx, e[0]);
                break;
              case 2:
                u.h.call(u.ctx, e[0], e[1]);
                break;
              default:
                u.h.apply(u.ctx, e);
                break;
            }
          }
          return a && a.afterTrigger && a.afterTrigger(t), this;
        }, n.prototype.triggerWithContext = function(t) {
          for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
          if (!this._$handlers) return this;
          var r = this._$handlers[t], a = this._$eventProcessor;
          if (r) for (var o = e.length, s = e[o - 1], l = r.length, u = 0; u < l; u++) {
            var h = r[u];
            if (!(a && a.filter && h.query != null && !a.filter(t, h.query))) switch (o) {
              case 0:
                h.h.call(s);
                break;
              case 1:
                h.h.call(s, e[0]);
                break;
              case 2:
                h.h.call(s, e[0], e[1]);
                break;
              default:
                h.h.apply(s, e.slice(1, o - 1));
                break;
            }
          }
          return a && a.afterTrigger && a.afterTrigger(t), this;
        }, n;
      }(), K_t = Math.log(2);
      function S2(n, t, e, i, r, a) {
        var o = i + "-" + r, s = n.length;
        if (a.hasOwnProperty(o)) return a[o];
        if (t === 1) {
          var l = Math.round(Math.log((1 << s) - 1 & ~r) / K_t);
          return n[e][l];
        }
        for (var u = i | 1 << e, h = e + 1; i & 1 << h; ) h++;
        for (var c = 0, f = 0, g = 0; f < s; f++) {
          var d = 1 << f;
          d & r || (c += (g % 2 ? -1 : 1) * n[e][f] * S2(n, t - 1, h, u, r | d, a), g++);
        }
        return a[o] = c, c;
      }
      function a5(n, t) {
        var e = [[n[0], n[1], 1, 0, 0, 0, -t[0] * n[0], -t[0] * n[1]], [0, 0, 0, n[0], n[1], 1, -t[1] * n[0], -t[1] * n[1]], [n[2], n[3], 1, 0, 0, 0, -t[2] * n[2], -t[2] * n[3]], [0, 0, 0, n[2], n[3], 1, -t[3] * n[2], -t[3] * n[3]], [n[4], n[5], 1, 0, 0, 0, -t[4] * n[4], -t[4] * n[5]], [0, 0, 0, n[4], n[5], 1, -t[5] * n[4], -t[5] * n[5]], [n[6], n[7], 1, 0, 0, 0, -t[6] * n[6], -t[6] * n[7]], [0, 0, 0, n[6], n[7], 1, -t[7] * n[6], -t[7] * n[7]]], i = {}, r = S2(e, 8, 0, 0, 0, i);
        if (r !== 0) {
          for (var a = [], o = 0; o < 8; o++) for (var s = 0; s < 8; s++) a[s] == null && (a[s] = 0), a[s] += ((o + s) % 2 ? -1 : 1) * S2(e, 7, o === 0 ? 1 : 0, 1 << o, 1 << s, i) / r * t[o];
          return function(l, u, h) {
            var c = u * a[6] + h * a[7] + 1;
            l[0] = (u * a[0] + h * a[1] + a[2]) / c, l[1] = (u * a[3] + h * a[4] + a[5]) / c;
          };
        }
      }
      var o5 = "___zrEVENTSAVED", b2 = [];
      function J_t(n, t, e, i, r) {
        return T2(b2, t, i, r, true) && T2(n, e, b2[0], b2[1]);
      }
      function T2(n, t, e, i, r) {
        if (t.getBoundingClientRect && re.domSupported && !s5(t)) {
          var a = t[o5] || (t[o5] = {}), o = t1t(t, a), s = e1t(o, a, r);
          if (s) return s(n, e, i), true;
        }
        return false;
      }
      function t1t(n, t) {
        var e = t.markers;
        if (e) return e;
        e = t.markers = [];
        for (var i = ["left", "right"], r = ["top", "bottom"], a = 0; a < 4; a++) {
          var o = document.createElement("div"), s = o.style, l = a % 2, u = (a >> 1) % 2;
          s.cssText = ["position: absolute", "visibility: hidden", "padding: 0", "margin: 0", "border-width: 0", "user-select: none", "width:0", "height:0", i[l] + ":0", r[u] + ":0", i[1 - l] + ":auto", r[1 - u] + ":auto", ""].join("!important;"), n.appendChild(o), e.push(o);
        }
        return e;
      }
      function e1t(n, t, e) {
        for (var i = e ? "invTrans" : "trans", r = t[i], a = t.srcCoords, o = [], s = [], l = true, u = 0; u < 4; u++) {
          var h = n[u].getBoundingClientRect(), c = 2 * u, f = h.left, g = h.top;
          o.push(f, g), l = l && a && f === a[c] && g === a[c + 1], s.push(n[u].offsetLeft, n[u].offsetTop);
        }
        return l && r ? r : (t.srcCoords = o, t[i] = e ? a5(s, o) : a5(o, s));
      }
      function s5(n) {
        return n.nodeName.toUpperCase() === "CANVAS";
      }
      var n1t = /([&<>"'])/g, i1t = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
      function Er(n) {
        return n == null ? "" : (n + "").replace(n1t, function(t, e) {
          return i1t[e];
        });
      }
      var r1t = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, B2 = [], a1t = re.browser.firefox && +re.browser.version.split(".")[0] < 39;
      function M2(n, t, e, i) {
        return e = e || {}, i ? l5(n, t, e) : a1t && t.layerX != null && t.layerX !== t.offsetX ? (e.zrX = t.layerX, e.zrY = t.layerY) : t.offsetX != null ? (e.zrX = t.offsetX, e.zrY = t.offsetY) : l5(n, t, e), e;
      }
      function l5(n, t, e) {
        if (re.domSupported && n.getBoundingClientRect) {
          var i = t.clientX, r = t.clientY;
          if (s5(n)) {
            var a = n.getBoundingClientRect();
            e.zrX = i - a.left, e.zrY = r - a.top;
            return;
          } else if (T2(B2, n, i, r)) {
            e.zrX = B2[0], e.zrY = B2[1];
            return;
          }
        }
        e.zrX = e.zrY = 0;
      }
      function D2(n) {
        return n || window.event;
      }
      function da(n, t, e) {
        if (t = D2(t), t.zrX != null) return t;
        var i = t.type, r = i && i.indexOf("touch") >= 0;
        if (r) {
          var o = i !== "touchend" ? t.targetTouches[0] : t.changedTouches[0];
          o && M2(n, o, t, e);
        } else {
          M2(n, t, t, e);
          var a = o1t(t);
          t.zrDelta = a ? a / 120 : -(t.detail || 0) / 3;
        }
        var s = t.button;
        return t.which == null && s !== void 0 && r1t.test(t.type) && (t.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), t;
      }
      function o1t(n) {
        var t = n.wheelDelta;
        if (t) return t;
        var e = n.deltaX, i = n.deltaY;
        if (e == null || i == null) return t;
        var r = Math.abs(i !== 0 ? i : e), a = i > 0 ? -1 : i < 0 ? 1 : e > 0 ? -1 : 1;
        return 3 * r * a;
      }
      function R2(n, t, e, i) {
        n.addEventListener(t, e, i);
      }
      function s1t(n, t, e, i) {
        n.removeEventListener(t, e, i);
      }
      var Qs = function(n) {
        n.preventDefault(), n.stopPropagation(), n.cancelBubble = true;
      };
      function u5(n) {
        return n.which === 2 || n.which === 3;
      }
      var l1t = function() {
        function n() {
          this._track = [];
        }
        return n.prototype.recognize = function(t, e, i) {
          return this._doTrack(t, e, i), this._recognize(t);
        }, n.prototype.clear = function() {
          return this._track.length = 0, this;
        }, n.prototype._doTrack = function(t, e, i) {
          var r = t.touches;
          if (r) {
            for (var a = { points: [], touches: [], target: e, event: t }, o = 0, s = r.length; o < s; o++) {
              var l = r[o], u = M2(i, l, {});
              a.points.push([u.zrX, u.zrY]), a.touches.push(l);
            }
            this._track.push(a);
          }
        }, n.prototype._recognize = function(t) {
          for (var e in L2) if (L2.hasOwnProperty(e)) {
            var i = L2[e](this._track, t);
            if (i) return i;
          }
        }, n;
      }();
      function h5(n) {
        var t = n[1][0] - n[0][0], e = n[1][1] - n[0][1];
        return Math.sqrt(t * t + e * e);
      }
      function u1t(n) {
        return [(n[0][0] + n[1][0]) / 2, (n[0][1] + n[1][1]) / 2];
      }
      var L2 = { pinch: function(n, t) {
        var e = n.length;
        if (e) {
          var i = (n[e - 1] || {}).points, r = (n[e - 2] || {}).points || i;
          if (r && r.length > 1 && i && i.length > 1) {
            var a = h5(i) / h5(r);
            !isFinite(a) && (a = 1), t.pinchScale = a;
            var o = u1t(i);
            return t.pinchX = o[0], t.pinchY = o[1], { type: "pinch", target: n[0].target, event: t };
          }
        }
      } };
      function Vr() {
        return [1, 0, 0, 1, 0, 0];
      }
      function q_(n) {
        return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 1, n[4] = 0, n[5] = 0, n;
      }
      function P2(n, t) {
        return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n;
      }
      function zs(n, t, e) {
        var i = t[0] * e[0] + t[2] * e[1], r = t[1] * e[0] + t[3] * e[1], a = t[0] * e[2] + t[2] * e[3], o = t[1] * e[2] + t[3] * e[3], s = t[0] * e[4] + t[2] * e[5] + t[4], l = t[1] * e[4] + t[3] * e[5] + t[5];
        return n[0] = i, n[1] = r, n[2] = a, n[3] = o, n[4] = s, n[5] = l, n;
      }
      function Go(n, t, e) {
        return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4] + e[0], n[5] = t[5] + e[1], n;
      }
      function _h(n, t, e, i) {
        i === void 0 && (i = [0, 0]);
        var r = t[0], a = t[2], o = t[4], s = t[1], l = t[3], u = t[5], h = Math.sin(e), c = Math.cos(e);
        return n[0] = r * c + s * h, n[1] = -r * h + s * c, n[2] = a * c + l * h, n[3] = -a * h + c * l, n[4] = c * (o - i[0]) + h * (u - i[1]) + i[0], n[5] = c * (u - i[1]) - h * (o - i[0]) + i[1], n;
      }
      function N2(n, t, e) {
        var i = e[0], r = e[1];
        return n[0] = t[0] * i, n[1] = t[1] * r, n[2] = t[2] * i, n[3] = t[3] * r, n[4] = t[4] * i, n[5] = t[5] * r, n;
      }
      function Sg(n, t) {
        var e = t[0], i = t[2], r = t[4], a = t[1], o = t[3], s = t[5], l = e * o - a * i;
        return l ? (l = 1 / l, n[0] = o * l, n[1] = -a * l, n[2] = -i * l, n[3] = e * l, n[4] = (i * s - o * r) * l, n[5] = (a * r - e * s) * l, n) : null;
      }
      function h1t(n) {
        var t = Vr();
        return P2(t, n), t;
      }
      var jt = function() {
        function n(t, e) {
          this.x = t || 0, this.y = e || 0;
        }
        return n.prototype.copy = function(t) {
          return this.x = t.x, this.y = t.y, this;
        }, n.prototype.clone = function() {
          return new n(this.x, this.y);
        }, n.prototype.set = function(t, e) {
          return this.x = t, this.y = e, this;
        }, n.prototype.equal = function(t) {
          return t.x === this.x && t.y === this.y;
        }, n.prototype.add = function(t) {
          return this.x += t.x, this.y += t.y, this;
        }, n.prototype.scale = function(t) {
          this.x *= t, this.y *= t;
        }, n.prototype.scaleAndAdd = function(t, e) {
          this.x += t.x * e, this.y += t.y * e;
        }, n.prototype.sub = function(t) {
          return this.x -= t.x, this.y -= t.y, this;
        }, n.prototype.dot = function(t) {
          return this.x * t.x + this.y * t.y;
        }, n.prototype.len = function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, n.prototype.lenSquare = function() {
          return this.x * this.x + this.y * this.y;
        }, n.prototype.normalize = function() {
          var t = this.len();
          return this.x /= t, this.y /= t, this;
        }, n.prototype.distance = function(t) {
          var e = this.x - t.x, i = this.y - t.y;
          return Math.sqrt(e * e + i * i);
        }, n.prototype.distanceSquare = function(t) {
          var e = this.x - t.x, i = this.y - t.y;
          return e * e + i * i;
        }, n.prototype.negate = function() {
          return this.x = -this.x, this.y = -this.y, this;
        }, n.prototype.transform = function(t) {
          if (t) {
            var e = this.x, i = this.y;
            return this.x = t[0] * e + t[2] * i + t[4], this.y = t[1] * e + t[3] * i + t[5], this;
          }
        }, n.prototype.toArray = function(t) {
          return t[0] = this.x, t[1] = this.y, t;
        }, n.prototype.fromArray = function(t) {
          this.x = t[0], this.y = t[1];
        }, n.set = function(t, e, i) {
          t.x = e, t.y = i;
        }, n.copy = function(t, e) {
          t.x = e.x, t.y = e.y;
        }, n.len = function(t) {
          return Math.sqrt(t.x * t.x + t.y * t.y);
        }, n.lenSquare = function(t) {
          return t.x * t.x + t.y * t.y;
        }, n.dot = function(t, e) {
          return t.x * e.x + t.y * e.y;
        }, n.add = function(t, e, i) {
          t.x = e.x + i.x, t.y = e.y + i.y;
        }, n.sub = function(t, e, i) {
          t.x = e.x - i.x, t.y = e.y - i.y;
        }, n.scale = function(t, e, i) {
          t.x = e.x * i, t.y = e.y * i;
        }, n.scaleAndAdd = function(t, e, i, r) {
          t.x = e.x + i.x * r, t.y = e.y + i.y * r;
        }, n.lerp = function(t, e, i, r) {
          var a = 1 - r;
          t.x = a * e.x + r * i.x, t.y = a * e.y + r * i.y;
        }, n;
      }(), H_ = Math.min, Y_ = Math.max, Eh = new jt(), Ih = new jt(), xh = new jt(), wh = new jt(), Fp = new jt(), kp = new jt(), Wt = function() {
        function n(t, e, i, r) {
          i < 0 && (t = t + i, i = -i), r < 0 && (e = e + r, r = -r), this.x = t, this.y = e, this.width = i, this.height = r;
        }
        return n.prototype.union = function(t) {
          var e = H_(t.x, this.x), i = H_(t.y, this.y);
          isFinite(this.x) && isFinite(this.width) ? this.width = Y_(t.x + t.width, this.x + this.width) - e : this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = Y_(t.y + t.height, this.y + this.height) - i : this.height = t.height, this.x = e, this.y = i;
        }, n.prototype.applyTransform = function(t) {
          n.applyTransform(this, this, t);
        }, n.prototype.calculateTransform = function(t) {
          var e = this, i = t.width / e.width, r = t.height / e.height, a = Vr();
          return Go(a, a, [-e.x, -e.y]), N2(a, a, [i, r]), Go(a, a, [t.x, t.y]), a;
        }, n.prototype.intersect = function(t, e) {
          if (!t) return false;
          t instanceof n || (t = n.create(t));
          var i = this, r = i.x, a = i.x + i.width, o = i.y, s = i.y + i.height, l = t.x, u = t.x + t.width, h = t.y, c = t.y + t.height, f = !(a < l || u < r || s < h || c < o);
          if (e) {
            var g = 1 / 0, d = 0, A = Math.abs(a - l), p = Math.abs(u - r), v = Math.abs(s - h), y = Math.abs(c - o), m = Math.min(A, p), _ = Math.min(v, y);
            a < l || u < r ? m > d && (d = m, A < p ? jt.set(kp, -A, 0) : jt.set(kp, p, 0)) : m < g && (g = m, A < p ? jt.set(Fp, A, 0) : jt.set(Fp, -p, 0)), s < h || c < o ? _ > d && (d = _, v < y ? jt.set(kp, 0, -v) : jt.set(kp, 0, y)) : m < g && (g = m, v < y ? jt.set(Fp, 0, v) : jt.set(Fp, 0, -y));
          }
          return e && jt.copy(e, f ? Fp : kp), f;
        }, n.prototype.contain = function(t, e) {
          var i = this;
          return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i.height;
        }, n.prototype.clone = function() {
          return new n(this.x, this.y, this.width, this.height);
        }, n.prototype.copy = function(t) {
          n.copy(this, t);
        }, n.prototype.plain = function() {
          return { x: this.x, y: this.y, width: this.width, height: this.height };
        }, n.prototype.isFinite = function() {
          return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
        }, n.prototype.isZero = function() {
          return this.width === 0 || this.height === 0;
        }, n.create = function(t) {
          return new n(t.x, t.y, t.width, t.height);
        }, n.copy = function(t, e) {
          t.x = e.x, t.y = e.y, t.width = e.width, t.height = e.height;
        }, n.applyTransform = function(t, e, i) {
          if (!i) {
            t !== e && n.copy(t, e);
            return;
          }
          if (i[1] < 1e-5 && i[1] > -1e-5 && i[2] < 1e-5 && i[2] > -1e-5) {
            var r = i[0], a = i[3], o = i[4], s = i[5];
            t.x = e.x * r + o, t.y = e.y * a + s, t.width = e.width * r, t.height = e.height * a, t.width < 0 && (t.x += t.width, t.width = -t.width), t.height < 0 && (t.y += t.height, t.height = -t.height);
            return;
          }
          Eh.x = xh.x = e.x, Eh.y = wh.y = e.y, Ih.x = wh.x = e.x + e.width, Ih.y = xh.y = e.y + e.height, Eh.transform(i), wh.transform(i), Ih.transform(i), xh.transform(i), t.x = H_(Eh.x, Ih.x, xh.x, wh.x), t.y = H_(Eh.y, Ih.y, xh.y, wh.y);
          var l = Y_(Eh.x, Ih.x, xh.x, wh.x), u = Y_(Eh.y, Ih.y, xh.y, wh.y);
          t.width = l - t.x, t.height = u - t.y;
        }, n;
      }(), c5 = "silent";
      function c1t(n, t, e) {
        return { type: n, event: e, target: t.target, topTarget: t.topTarget, cancelBubble: false, offsetX: e.zrX, offsetY: e.zrY, gestureEvent: e.gestureEvent, pinchX: e.pinchX, pinchY: e.pinchY, pinchScale: e.pinchScale, wheelDelta: e.zrDelta, zrByTouch: e.zrByTouch, which: e.which, stop: f1t };
      }
      function f1t() {
        Qs(this.event);
      }
      var g1t = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.handler = null, e;
        }
        return t.prototype.dispose = function() {
        }, t.prototype.setCursor = function() {
        }, t;
      }(ga), Op = /* @__PURE__ */ function() {
        function n(t, e) {
          this.x = t, this.y = e;
        }
        return n;
      }(), d1t = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"], F2 = new Wt(0, 0, 0, 0), f5 = function(n) {
        V(t, n);
        function t(e, i, r, a, o) {
          var s = n.call(this) || this;
          return s._hovered = new Op(0, 0), s.storage = e, s.painter = i, s.painterRoot = a, s._pointerSize = o, r = r || new g1t(), s.proxy = null, s.setHandlerProxy(r), s._draggingMgr = new Z_t(s), s;
        }
        return t.prototype.setHandlerProxy = function(e) {
          this.proxy && this.proxy.dispose(), e && (D(d1t, function(i) {
            e.on && e.on(i, this[i], this);
          }, this), e.handler = this), this.proxy = e;
        }, t.prototype.mousemove = function(e) {
          var i = e.zrX, r = e.zrY, a = d5(this, i, r), o = this._hovered, s = o.target;
          s && !s.__zr && (o = this.findHover(o.x, o.y), s = o.target);
          var l = this._hovered = a ? new Op(i, r) : this.findHover(i, r), u = l.target, h = this.proxy;
          h.setCursor && h.setCursor(u ? u.cursor : "default"), s && u !== s && this.dispatchToElement(o, "mouseout", e), this.dispatchToElement(l, "mousemove", e), u && u !== s && this.dispatchToElement(l, "mouseover", e);
        }, t.prototype.mouseout = function(e) {
          var i = e.zrEventControl;
          i !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", e), i !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: e });
        }, t.prototype.resize = function() {
          this._hovered = new Op(0, 0);
        }, t.prototype.dispatch = function(e, i) {
          var r = this[e];
          r && r.call(this, i);
        }, t.prototype.dispose = function() {
          this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
        }, t.prototype.setCursorStyle = function(e) {
          var i = this.proxy;
          i.setCursor && i.setCursor(e);
        }, t.prototype.dispatchToElement = function(e, i, r) {
          e = e || {};
          var a = e.target;
          if (!(a && a.silent)) {
            for (var o = "on" + i, s = c1t(i, e, r); a && (a[o] && (s.cancelBubble = !!a[o].call(a, s)), a.trigger(i, s), a = a.__hostTarget ? a.__hostTarget : a.parent, !s.cancelBubble); ) ;
            s.cancelBubble || (this.trigger(i, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
              typeof l[o] == "function" && l[o].call(l, s), l.trigger && l.trigger(i, s);
            }));
          }
        }, t.prototype.findHover = function(e, i, r) {
          var a = this.storage.getDisplayList(), o = new Op(e, i);
          if (g5(a, o, e, i, r), this._pointerSize && !o.target) {
            for (var s = [], l = this._pointerSize, u = l / 2, h = new Wt(e - u, i - u, l, l), c = a.length - 1; c >= 0; c--) {
              var f = a[c];
              f !== r && !f.ignore && !f.ignoreCoarsePointer && (!f.parent || !f.parent.ignoreCoarsePointer) && (F2.copy(f.getBoundingRect()), f.transform && F2.applyTransform(f.transform), F2.intersect(h) && s.push(f));
            }
            if (s.length) for (var g = 4, d = Math.PI / 12, A = Math.PI * 2, p = 0; p < u; p += g) for (var v = 0; v < A; v += d) {
              var y = e + p * Math.cos(v), m = i + p * Math.sin(v);
              if (g5(s, o, y, m, r), o.target) return o;
            }
          }
          return o;
        }, t.prototype.processGesture = function(e, i) {
          this._gestureMgr || (this._gestureMgr = new l1t());
          var r = this._gestureMgr;
          i === "start" && r.clear();
          var a = r.recognize(e, this.findHover(e.zrX, e.zrY, null).target, this.proxy.dom);
          if (i === "end" && r.clear(), a) {
            var o = a.type;
            e.gestureEvent = o;
            var s = new Op();
            s.target = a.target, this.dispatchToElement(s, o, a.event);
          }
        }, t;
      }(ga);
      D(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(n) {
        f5.prototype[n] = function(t) {
          var e = t.zrX, i = t.zrY, r = d5(this, e, i), a, o;
          if ((n !== "mouseup" || !r) && (a = this.findHover(e, i), o = a.target), n === "mousedown") this._downEl = o, this._downPoint = [t.zrX, t.zrY], this._upEl = o;
          else if (n === "mouseup") this._upEl = o;
          else if (n === "click") {
            if (this._downEl !== this._upEl || !this._downPoint || $l(this._downPoint, [t.zrX, t.zrY]) > 4) return;
            this._downPoint = null;
          }
          this.dispatchToElement(a, n, t);
        };
      });
      function A1t(n, t, e) {
        if (n[n.rectHover ? "rectContain" : "contain"](t, e)) {
          for (var i = n, r = void 0, a = false; i; ) {
            if (i.ignoreClip && (a = true), !a) {
              var o = i.getClipPath();
              if (o && !o.contain(t, e)) return false;
            }
            i.silent && (r = true);
            var s = i.__hostTarget;
            i = s || i.parent;
          }
          return r ? c5 : true;
        }
        return false;
      }
      function g5(n, t, e, i, r) {
        for (var a = n.length - 1; a >= 0; a--) {
          var o = n[a], s = void 0;
          if (o !== r && !o.ignore && (s = A1t(o, e, i)) && (!t.topTarget && (t.topTarget = o), s !== c5)) {
            t.target = o;
            break;
          }
        }
      }
      function d5(n, t, e) {
        var i = n.painter;
        return t < 0 || t > i.getWidth() || e < 0 || e > i.getHeight();
      }
      var A5 = 32, Qp = 7;
      function p1t(n) {
        for (var t = 0; n >= A5; ) t |= n & 1, n >>= 1;
        return n + t;
      }
      function p5(n, t, e, i) {
        var r = t + 1;
        if (r === e) return 1;
        if (i(n[r++], n[t]) < 0) {
          for (; r < e && i(n[r], n[r - 1]) < 0; ) r++;
          v1t(n, t, r);
        } else for (; r < e && i(n[r], n[r - 1]) >= 0; ) r++;
        return r - t;
      }
      function v1t(n, t, e) {
        for (e--; t < e; ) {
          var i = n[t];
          n[t++] = n[e], n[e--] = i;
        }
      }
      function v5(n, t, e, i, r) {
        for (i === t && i++; i < e; i++) {
          for (var a = n[i], o = t, s = i, l; o < s; ) l = o + s >>> 1, r(a, n[l]) < 0 ? s = l : o = l + 1;
          var u = i - o;
          switch (u) {
            case 3:
              n[o + 3] = n[o + 2];
            case 2:
              n[o + 2] = n[o + 1];
            case 1:
              n[o + 1] = n[o];
              break;
            default:
              for (; u > 0; ) n[o + u] = n[o + u - 1], u--;
          }
          n[o] = a;
        }
      }
      function k2(n, t, e, i, r, a) {
        var o = 0, s = 0, l = 1;
        if (a(n, t[e + r]) > 0) {
          for (s = i - r; l < s && a(n, t[e + r + l]) > 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
          l > s && (l = s), o += r, l += r;
        } else {
          for (s = r + 1; l < s && a(n, t[e + r - l]) <= 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
          l > s && (l = s);
          var u = o;
          o = r - l, l = r - u;
        }
        for (o++; o < l; ) {
          var h = o + (l - o >>> 1);
          a(n, t[e + h]) > 0 ? o = h + 1 : l = h;
        }
        return l;
      }
      function O2(n, t, e, i, r, a) {
        var o = 0, s = 0, l = 1;
        if (a(n, t[e + r]) < 0) {
          for (s = r + 1; l < s && a(n, t[e + r - l]) < 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
          l > s && (l = s);
          var u = o;
          o = r - l, l = r - u;
        } else {
          for (s = i - r; l < s && a(n, t[e + r + l]) >= 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
          l > s && (l = s), o += r, l += r;
        }
        for (o++; o < l; ) {
          var h = o + (l - o >>> 1);
          a(n, t[e + h]) < 0 ? l = h : o = h + 1;
        }
        return l;
      }
      function y1t(n, t) {
        var e = Qp, i, r, a = 0, o = [];
        i = [], r = [];
        function s(g, d) {
          i[a] = g, r[a] = d, a += 1;
        }
        function l() {
          for (; a > 1; ) {
            var g = a - 2;
            if (g >= 1 && r[g - 1] <= r[g] + r[g + 1] || g >= 2 && r[g - 2] <= r[g] + r[g - 1]) r[g - 1] < r[g + 1] && g--;
            else if (r[g] > r[g + 1]) break;
            h(g);
          }
        }
        function u() {
          for (; a > 1; ) {
            var g = a - 2;
            g > 0 && r[g - 1] < r[g + 1] && g--, h(g);
          }
        }
        function h(g) {
          var d = i[g], A = r[g], p = i[g + 1], v = r[g + 1];
          r[g] = A + v, g === a - 3 && (i[g + 1] = i[g + 2], r[g + 1] = r[g + 2]), a--;
          var y = O2(n[p], n, d, A, 0, t);
          d += y, A -= y, A !== 0 && (v = k2(n[d + A - 1], n, p, v, v - 1, t), v !== 0 && (A <= v ? c(d, A, p, v) : f(d, A, p, v)));
        }
        function c(g, d, A, p) {
          var v = 0;
          for (v = 0; v < d; v++) o[v] = n[g + v];
          var y = 0, m = A, _ = g;
          if (n[_++] = n[m++], --p === 0) {
            for (v = 0; v < d; v++) n[_ + v] = o[y + v];
            return;
          }
          if (d === 1) {
            for (v = 0; v < p; v++) n[_ + v] = n[m + v];
            n[_ + p] = o[y];
            return;
          }
          for (var I = e, E, x, w; ; ) {
            E = 0, x = 0, w = false;
            do
              if (t(n[m], o[y]) < 0) {
                if (n[_++] = n[m++], x++, E = 0, --p === 0) {
                  w = true;
                  break;
                }
              } else if (n[_++] = o[y++], E++, x = 0, --d === 1) {
                w = true;
                break;
              }
            while ((E | x) < I);
            if (w) break;
            do {
              if (E = O2(n[m], o, y, d, 0, t), E !== 0) {
                for (v = 0; v < E; v++) n[_ + v] = o[y + v];
                if (_ += E, y += E, d -= E, d <= 1) {
                  w = true;
                  break;
                }
              }
              if (n[_++] = n[m++], --p === 0) {
                w = true;
                break;
              }
              if (x = k2(o[y], n, m, p, 0, t), x !== 0) {
                for (v = 0; v < x; v++) n[_ + v] = n[m + v];
                if (_ += x, m += x, p -= x, p === 0) {
                  w = true;
                  break;
                }
              }
              if (n[_++] = o[y++], --d === 1) {
                w = true;
                break;
              }
              I--;
            } while (E >= Qp || x >= Qp);
            if (w) break;
            I < 0 && (I = 0), I += 2;
          }
          if (e = I, e < 1 && (e = 1), d === 1) {
            for (v = 0; v < p; v++) n[_ + v] = n[m + v];
            n[_ + p] = o[y];
          } else {
            if (d === 0) throw new Error();
            for (v = 0; v < d; v++) n[_ + v] = o[y + v];
          }
        }
        function f(g, d, A, p) {
          var v = 0;
          for (v = 0; v < p; v++) o[v] = n[A + v];
          var y = g + d - 1, m = p - 1, _ = A + p - 1, I = 0, E = 0;
          if (n[_--] = n[y--], --d === 0) {
            for (I = _ - (p - 1), v = 0; v < p; v++) n[I + v] = o[v];
            return;
          }
          if (p === 1) {
            for (_ -= d, y -= d, E = _ + 1, I = y + 1, v = d - 1; v >= 0; v--) n[E + v] = n[I + v];
            n[_] = o[m];
            return;
          }
          for (var x = e; ; ) {
            var w = 0, C = 0, S = false;
            do
              if (t(o[m], n[y]) < 0) {
                if (n[_--] = n[y--], w++, C = 0, --d === 0) {
                  S = true;
                  break;
                }
              } else if (n[_--] = o[m--], C++, w = 0, --p === 1) {
                S = true;
                break;
              }
            while ((w | C) < x);
            if (S) break;
            do {
              if (w = d - O2(o[m], n, g, d, d - 1, t), w !== 0) {
                for (_ -= w, y -= w, d -= w, E = _ + 1, I = y + 1, v = w - 1; v >= 0; v--) n[E + v] = n[I + v];
                if (d === 0) {
                  S = true;
                  break;
                }
              }
              if (n[_--] = o[m--], --p === 1) {
                S = true;
                break;
              }
              if (C = p - k2(n[y], o, 0, p, p - 1, t), C !== 0) {
                for (_ -= C, m -= C, p -= C, E = _ + 1, I = m + 1, v = 0; v < C; v++) n[E + v] = o[I + v];
                if (p <= 1) {
                  S = true;
                  break;
                }
              }
              if (n[_--] = n[y--], --d === 0) {
                S = true;
                break;
              }
              x--;
            } while (w >= Qp || C >= Qp);
            if (S) break;
            x < 0 && (x = 0), x += 2;
          }
          if (e = x, e < 1 && (e = 1), p === 1) {
            for (_ -= d, y -= d, E = _ + 1, I = y + 1, v = d - 1; v >= 0; v--) n[E + v] = n[I + v];
            n[_] = o[m];
          } else {
            if (p === 0) throw new Error();
            for (I = _ - (p - 1), v = 0; v < p; v++) n[I + v] = o[v];
          }
        }
        return { mergeRuns: l, forceMergeRuns: u, pushRun: s };
      }
      function W_(n, t, e, i) {
        e || (e = 0), i || (i = n.length);
        var r = i - e;
        if (!(r < 2)) {
          var a = 0;
          if (r < A5) {
            a = p5(n, e, i, t), v5(n, e, i, e + a, t);
            return;
          }
          var o = y1t(n, t), s = p1t(r);
          do {
            if (a = p5(n, e, i, t), a < s) {
              var l = r;
              l > s && (l = s), v5(n, e, e + l, e + a, t), a = l;
            }
            o.pushRun(e, a), o.mergeRuns(), r -= a, e += a;
          } while (r !== 0);
          o.forceMergeRuns();
        }
      }
      var jr = 1, zp = 2, bg = 4, y5 = false;
      function Q2() {
        y5 || (y5 = true);
      }
      function m5(n, t) {
        return n.zlevel === t.zlevel ? n.z === t.z ? n.z2 - t.z2 : n.z - t.z : n.zlevel - t.zlevel;
      }
      var m1t = function() {
        function n() {
          this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = m5;
        }
        return n.prototype.traverse = function(t, e) {
          for (var i = 0; i < this._roots.length; i++) this._roots[i].traverse(t, e);
        }, n.prototype.getDisplayList = function(t, e) {
          e = e || false;
          var i = this._displayList;
          return (t || !i.length) && this.updateDisplayList(e), i;
        }, n.prototype.updateDisplayList = function(t) {
          this._displayListLen = 0;
          for (var e = this._roots, i = this._displayList, r = 0, a = e.length; r < a; r++) this._updateAndAddDisplayable(e[r], null, t);
          i.length = this._displayListLen, W_(i, m5);
        }, n.prototype._updateAndAddDisplayable = function(t, e, i) {
          if (!(t.ignore && !i)) {
            t.beforeUpdate(), t.update(), t.afterUpdate();
            var r = t.getClipPath();
            if (t.ignoreClip) e = null;
            else if (r) {
              e ? e = e.slice() : e = [];
              for (var a = r, o = t; a; ) a.parent = o, a.updateTransform(), e.push(a), o = a, a = a.getClipPath();
            }
            if (t.childrenRef) {
              for (var s = t.childrenRef(), l = 0; l < s.length; l++) {
                var u = s[l];
                t.__dirty && (u.__dirty |= jr), this._updateAndAddDisplayable(u, e, i);
              }
              t.__dirty = 0;
            } else {
              var h = t;
              e && e.length ? h.__clipPaths = e : h.__clipPaths && h.__clipPaths.length > 0 && (h.__clipPaths = []), isNaN(h.z) && (Q2(), h.z = 0), isNaN(h.z2) && (Q2(), h.z2 = 0), isNaN(h.zlevel) && (Q2(), h.zlevel = 0), this._displayList[this._displayListLen++] = h;
            }
            var c = t.getDecalElement && t.getDecalElement();
            c && this._updateAndAddDisplayable(c, e, i);
            var f = t.getTextGuideLine();
            f && this._updateAndAddDisplayable(f, e, i);
            var g = t.getTextContent();
            g && this._updateAndAddDisplayable(g, e, i);
          }
        }, n.prototype.addRoot = function(t) {
          t.__zr && t.__zr.storage === this || this._roots.push(t);
        }, n.prototype.delRoot = function(t) {
          if (t instanceof Array) {
            for (var e = 0, i = t.length; e < i; e++) this.delRoot(t[e]);
            return;
          }
          var r = $t(this._roots, t);
          r >= 0 && this._roots.splice(r, 1);
        }, n.prototype.delAllRoots = function() {
          this._roots = [], this._displayList = [], this._displayListLen = 0;
        }, n.prototype.getRoots = function() {
          return this._roots;
        }, n.prototype.dispose = function() {
          this._displayList = null, this._roots = null;
        }, n;
      }(), X_;
      X_ = re.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(n) {
        return setTimeout(n, 16);
      };
      var Gp = { linear: function(n) {
        return n;
      }, quadraticIn: function(n) {
        return n * n;
      }, quadraticOut: function(n) {
        return n * (2 - n);
      }, quadraticInOut: function(n) {
        return (n *= 2) < 1 ? 0.5 * n * n : -0.5 * (--n * (n - 2) - 1);
      }, cubicIn: function(n) {
        return n * n * n;
      }, cubicOut: function(n) {
        return --n * n * n + 1;
      }, cubicInOut: function(n) {
        return (n *= 2) < 1 ? 0.5 * n * n * n : 0.5 * ((n -= 2) * n * n + 2);
      }, quarticIn: function(n) {
        return n * n * n * n;
      }, quarticOut: function(n) {
        return 1 - --n * n * n * n;
      }, quarticInOut: function(n) {
        return (n *= 2) < 1 ? 0.5 * n * n * n * n : -0.5 * ((n -= 2) * n * n * n - 2);
      }, quinticIn: function(n) {
        return n * n * n * n * n;
      }, quinticOut: function(n) {
        return --n * n * n * n * n + 1;
      }, quinticInOut: function(n) {
        return (n *= 2) < 1 ? 0.5 * n * n * n * n * n : 0.5 * ((n -= 2) * n * n * n * n + 2);
      }, sinusoidalIn: function(n) {
        return 1 - Math.cos(n * Math.PI / 2);
      }, sinusoidalOut: function(n) {
        return Math.sin(n * Math.PI / 2);
      }, sinusoidalInOut: function(n) {
        return 0.5 * (1 - Math.cos(Math.PI * n));
      }, exponentialIn: function(n) {
        return n === 0 ? 0 : Math.pow(1024, n - 1);
      }, exponentialOut: function(n) {
        return n === 1 ? 1 : 1 - Math.pow(2, -10 * n);
      }, exponentialInOut: function(n) {
        return n === 0 ? 0 : n === 1 ? 1 : (n *= 2) < 1 ? 0.5 * Math.pow(1024, n - 1) : 0.5 * (-Math.pow(2, -10 * (n - 1)) + 2);
      }, circularIn: function(n) {
        return 1 - Math.sqrt(1 - n * n);
      }, circularOut: function(n) {
        return Math.sqrt(1 - --n * n);
      }, circularInOut: function(n) {
        return (n *= 2) < 1 ? -0.5 * (Math.sqrt(1 - n * n) - 1) : 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1);
      }, elasticIn: function(n) {
        var t, e = 0.1, i = 0.4;
        return n === 0 ? 0 : n === 1 ? 1 : (!e || e < 1 ? (e = 1, t = i / 4) : t = i * Math.asin(1 / e) / (2 * Math.PI), -(e * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - t) * (2 * Math.PI) / i)));
      }, elasticOut: function(n) {
        var t, e = 0.1, i = 0.4;
        return n === 0 ? 0 : n === 1 ? 1 : (!e || e < 1 ? (e = 1, t = i / 4) : t = i * Math.asin(1 / e) / (2 * Math.PI), e * Math.pow(2, -10 * n) * Math.sin((n - t) * (2 * Math.PI) / i) + 1);
      }, elasticInOut: function(n) {
        var t, e = 0.1, i = 0.4;
        return n === 0 ? 0 : n === 1 ? 1 : (!e || e < 1 ? (e = 1, t = i / 4) : t = i * Math.asin(1 / e) / (2 * Math.PI), (n *= 2) < 1 ? -0.5 * (e * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - t) * (2 * Math.PI) / i)) : e * Math.pow(2, -10 * (n -= 1)) * Math.sin((n - t) * (2 * Math.PI) / i) * 0.5 + 1);
      }, backIn: function(n) {
        var t = 1.70158;
        return n * n * ((t + 1) * n - t);
      }, backOut: function(n) {
        var t = 1.70158;
        return --n * n * ((t + 1) * n + t) + 1;
      }, backInOut: function(n) {
        var t = 2.5949095;
        return (n *= 2) < 1 ? 0.5 * (n * n * ((t + 1) * n - t)) : 0.5 * ((n -= 2) * n * ((t + 1) * n + t) + 2);
      }, bounceIn: function(n) {
        return 1 - Gp.bounceOut(1 - n);
      }, bounceOut: function(n) {
        return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375;
      }, bounceInOut: function(n) {
        return n < 0.5 ? Gp.bounceIn(n * 2) * 0.5 : Gp.bounceOut(n * 2 - 1) * 0.5 + 0.5;
      } }, $_ = Math.pow, Jl = Math.sqrt, Z_ = 1e-8, _5 = 1e-4, E5 = Jl(3), K_ = 1 / 3, Uo = vh(), Aa = vh(), Tg = vh();
      function tu(n) {
        return n > -Z_ && n < Z_;
      }
      function I5(n) {
        return n > Z_ || n < -Z_;
      }
      function Zn(n, t, e, i, r) {
        var a = 1 - r;
        return a * a * (a * n + 3 * r * t) + r * r * (r * i + 3 * a * e);
      }
      function x5(n, t, e, i, r) {
        var a = 1 - r;
        return 3 * (((t - n) * a + 2 * (e - t) * r) * a + (i - e) * r * r);
      }
      function J_(n, t, e, i, r, a) {
        var o = i + 3 * (t - e) - n, s = 3 * (e - t * 2 + n), l = 3 * (t - n), u = n - r, h = s * s - 3 * o * l, c = s * l - 9 * o * u, f = l * l - 3 * s * u, g = 0;
        if (tu(h) && tu(c)) if (tu(s)) a[0] = 0;
        else {
          var d = -l / s;
          d >= 0 && d <= 1 && (a[g++] = d);
        }
        else {
          var A = c * c - 4 * h * f;
          if (tu(A)) {
            var p = c / h, d = -s / o + p, v = -p / 2;
            d >= 0 && d <= 1 && (a[g++] = d), v >= 0 && v <= 1 && (a[g++] = v);
          } else if (A > 0) {
            var y = Jl(A), m = h * s + 1.5 * o * (-c + y), _ = h * s + 1.5 * o * (-c - y);
            m < 0 ? m = -$_(-m, K_) : m = $_(m, K_), _ < 0 ? _ = -$_(-_, K_) : _ = $_(_, K_);
            var d = (-s - (m + _)) / (3 * o);
            d >= 0 && d <= 1 && (a[g++] = d);
          } else {
            var I = (2 * h * s - 3 * o * c) / (2 * Jl(h * h * h)), E = Math.acos(I) / 3, x = Jl(h), w = Math.cos(E), d = (-s - 2 * x * w) / (3 * o), v = (-s + x * (w + E5 * Math.sin(E))) / (3 * o), C = (-s + x * (w - E5 * Math.sin(E))) / (3 * o);
            d >= 0 && d <= 1 && (a[g++] = d), v >= 0 && v <= 1 && (a[g++] = v), C >= 0 && C <= 1 && (a[g++] = C);
          }
        }
        return g;
      }
      function w5(n, t, e, i, r) {
        var a = 6 * e - 12 * t + 6 * n, o = 9 * t + 3 * i - 3 * n - 9 * e, s = 3 * t - 3 * n, l = 0;
        if (tu(o)) {
          if (I5(a)) {
            var u = -s / a;
            u >= 0 && u <= 1 && (r[l++] = u);
          }
        } else {
          var h = a * a - 4 * o * s;
          if (tu(h)) r[0] = -a / (2 * o);
          else if (h > 0) {
            var c = Jl(h), u = (-a + c) / (2 * o), f = (-a - c) / (2 * o);
            u >= 0 && u <= 1 && (r[l++] = u), f >= 0 && f <= 1 && (r[l++] = f);
          }
        }
        return l;
      }
      function eu(n, t, e, i, r, a) {
        var o = (t - n) * r + n, s = (e - t) * r + t, l = (i - e) * r + e, u = (s - o) * r + o, h = (l - s) * r + s, c = (h - u) * r + u;
        a[0] = n, a[1] = o, a[2] = u, a[3] = c, a[4] = c, a[5] = h, a[6] = l, a[7] = i;
      }
      function C5(n, t, e, i, r, a, o, s, l, u, h) {
        var c, f = 5e-3, g = 1 / 0, d, A, p, v;
        Uo[0] = l, Uo[1] = u;
        for (var y = 0; y < 1; y += 0.05) Aa[0] = Zn(n, e, r, o, y), Aa[1] = Zn(t, i, a, s, y), p = mh(Uo, Aa), p < g && (c = y, g = p);
        g = 1 / 0;
        for (var m = 0; m < 32 && !(f < _5); m++) d = c - f, A = c + f, Aa[0] = Zn(n, e, r, o, d), Aa[1] = Zn(t, i, a, s, d), p = mh(Aa, Uo), d >= 0 && p < g ? (c = d, g = p) : (Tg[0] = Zn(n, e, r, o, A), Tg[1] = Zn(t, i, a, s, A), v = mh(Tg, Uo), A <= 1 && v < g ? (c = A, g = v) : f *= 0.5);
        return h && (h[0] = Zn(n, e, r, o, c), h[1] = Zn(t, i, a, s, c)), Jl(g);
      }
      function _1t(n, t, e, i, r, a, o, s, l) {
        for (var u = n, h = t, c = 0, f = 1 / l, g = 1; g <= l; g++) {
          var d = g * f, A = Zn(n, e, r, o, d), p = Zn(t, i, a, s, d), v = A - u, y = p - h;
          c += Math.sqrt(v * v + y * y), u = A, h = p;
        }
        return c;
      }
      function fi(n, t, e, i) {
        var r = 1 - i;
        return r * (r * n + 2 * i * t) + i * i * e;
      }
      function z2(n, t, e, i) {
        return 2 * ((1 - i) * (t - n) + i * (e - t));
      }
      function E1t(n, t, e, i, r) {
        var a = n - 2 * t + e, o = 2 * (t - n), s = n - i, l = 0;
        if (tu(a)) {
          if (I5(o)) {
            var u = -s / o;
            u >= 0 && u <= 1 && (r[l++] = u);
          }
        } else {
          var h = o * o - 4 * a * s;
          if (tu(h)) {
            var u = -o / (2 * a);
            u >= 0 && u <= 1 && (r[l++] = u);
          } else if (h > 0) {
            var c = Jl(h), u = (-o + c) / (2 * a), f = (-o - c) / (2 * a);
            u >= 0 && u <= 1 && (r[l++] = u), f >= 0 && f <= 1 && (r[l++] = f);
          }
        }
        return l;
      }
      function S5(n, t, e) {
        var i = n + e - 2 * t;
        return i === 0 ? 0.5 : (n - t) / i;
      }
      function Up(n, t, e, i, r) {
        var a = (t - n) * i + n, o = (e - t) * i + t, s = (o - a) * i + a;
        r[0] = n, r[1] = a, r[2] = s, r[3] = s, r[4] = o, r[5] = e;
      }
      function b5(n, t, e, i, r, a, o, s, l) {
        var u, h = 5e-3, c = 1 / 0;
        Uo[0] = o, Uo[1] = s;
        for (var f = 0; f < 1; f += 0.05) {
          Aa[0] = fi(n, e, r, f), Aa[1] = fi(t, i, a, f);
          var g = mh(Uo, Aa);
          g < c && (u = f, c = g);
        }
        c = 1 / 0;
        for (var d = 0; d < 32 && !(h < _5); d++) {
          var A = u - h, p = u + h;
          Aa[0] = fi(n, e, r, A), Aa[1] = fi(t, i, a, A);
          var g = mh(Aa, Uo);
          if (A >= 0 && g < c) u = A, c = g;
          else {
            Tg[0] = fi(n, e, r, p), Tg[1] = fi(t, i, a, p);
            var v = mh(Tg, Uo);
            p <= 1 && v < c ? (u = p, c = v) : h *= 0.5;
          }
        }
        return l && (l[0] = fi(n, e, r, u), l[1] = fi(t, i, a, u)), Jl(c);
      }
      function I1t(n, t, e, i, r, a, o) {
        for (var s = n, l = t, u = 0, h = 1 / o, c = 1; c <= o; c++) {
          var f = c * h, g = fi(n, e, r, f), d = fi(t, i, a, f), A = g - s, p = d - l;
          u += Math.sqrt(A * A + p * p), s = g, l = d;
        }
        return u;
      }
      var x1t = /cubic-bezier\(([0-9,\.e ]+)\)/;
      function G2(n) {
        var t = n && x1t.exec(n);
        if (t) {
          var e = t[1].split(","), i = +Wa(e[0]), r = +Wa(e[1]), a = +Wa(e[2]), o = +Wa(e[3]);
          if (isNaN(i + r + a + o)) return;
          var s = [];
          return function(l) {
            return l <= 0 ? 0 : l >= 1 ? 1 : J_(0, i, a, 1, l, s) && Zn(0, r, o, 1, s[0]);
          };
        }
      }
      var w1t = function() {
        function n(t) {
          this._inited = false, this._startTime = 0, this._pausedTime = 0, this._paused = false, this._life = t.life || 1e3, this._delay = t.delay || 0, this.loop = t.loop || false, this.onframe = t.onframe || bn, this.ondestroy = t.ondestroy || bn, this.onrestart = t.onrestart || bn, t.easing && this.setEasing(t.easing);
        }
        return n.prototype.step = function(t, e) {
          if (this._inited || (this._startTime = t + this._delay, this._inited = true), this._paused) {
            this._pausedTime += e;
            return;
          }
          var i = this._life, r = t - this._startTime - this._pausedTime, a = r / i;
          a < 0 && (a = 0), a = Math.min(a, 1);
          var o = this.easingFunc, s = o ? o(a) : a;
          if (this.onframe(s), a === 1) if (this.loop) {
            var l = r % i;
            this._startTime = t - l, this._pausedTime = 0, this.onrestart();
          } else return true;
          return false;
        }, n.prototype.pause = function() {
          this._paused = true;
        }, n.prototype.resume = function() {
          this._paused = false;
        }, n.prototype.setEasing = function(t) {
          this.easing = t, this.easingFunc = yt(t) ? t : Gp[t] || G2(t);
        }, n;
      }(), T5 = /* @__PURE__ */ function() {
        function n(t) {
          this.value = t;
        }
        return n;
      }(), C1t = function() {
        function n() {
          this._len = 0;
        }
        return n.prototype.insert = function(t) {
          var e = new T5(t);
          return this.insertEntry(e), e;
        }, n.prototype.insertEntry = function(t) {
          this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
        }, n.prototype.remove = function(t) {
          var e = t.prev, i = t.next;
          e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len--;
        }, n.prototype.len = function() {
          return this._len;
        }, n.prototype.clear = function() {
          this.head = this.tail = null, this._len = 0;
        }, n;
      }(), Vp = function() {
        function n(t) {
          this._list = new C1t(), this._maxSize = 10, this._map = {}, this._maxSize = t;
        }
        return n.prototype.put = function(t, e) {
          var i = this._list, r = this._map, a = null;
          if (r[t] == null) {
            var o = i.len(), s = this._lastRemovedEntry;
            if (o >= this._maxSize && o > 0) {
              var l = i.head;
              i.remove(l), delete r[l.key], a = l.value, this._lastRemovedEntry = l;
            }
            s ? s.value = e : s = new T5(e), s.key = t, i.insertEntry(s), r[t] = s;
          }
          return a;
        }, n.prototype.get = function(t) {
          var e = this._map[t], i = this._list;
          if (e != null) return e !== i.tail && (i.remove(e), i.insertEntry(e)), e.value;
        }, n.prototype.clear = function() {
          this._list.clear(), this._map = {};
        }, n.prototype.len = function() {
          return this._list.len();
        }, n;
      }(), B5 = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
      function Xa(n) {
        return n = Math.round(n), n < 0 ? 0 : n > 255 ? 255 : n;
      }
      function S1t(n) {
        return n = Math.round(n), n < 0 ? 0 : n > 360 ? 360 : n;
      }
      function jp(n) {
        return n < 0 ? 0 : n > 1 ? 1 : n;
      }
      function U2(n) {
        var t = n;
        return t.length && t.charAt(t.length - 1) === "%" ? Xa(parseFloat(t) / 100 * 255) : Xa(parseInt(t, 10));
      }
      function Ch(n) {
        var t = n;
        return t.length && t.charAt(t.length - 1) === "%" ? jp(parseFloat(t) / 100) : jp(parseFloat(t));
      }
      function V2(n, t, e) {
        return e < 0 ? e += 1 : e > 1 && (e -= 1), e * 6 < 1 ? n + (t - n) * e * 6 : e * 2 < 1 ? t : e * 3 < 2 ? n + (t - n) * (2 / 3 - e) * 6 : n;
      }
      function nu(n, t, e) {
        return n + (t - n) * e;
      }
      function pa(n, t, e, i, r) {
        return n[0] = t, n[1] = e, n[2] = i, n[3] = r, n;
      }
      function j2(n, t) {
        return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n;
      }
      var M5 = new Vp(20), t1 = null;
      function Bg(n, t) {
        t1 && j2(t1, t), t1 = M5.put(n, t1 || t.slice());
      }
      function qr(n, t) {
        if (n) {
          t = t || [];
          var e = M5.get(n);
          if (e) return j2(t, e);
          n = n + "";
          var i = n.replace(/ /g, "").toLowerCase();
          if (i in B5) return j2(t, B5[i]), Bg(n, t), t;
          var r = i.length;
          if (i.charAt(0) === "#") {
            if (r === 4 || r === 5) {
              var a = parseInt(i.slice(1, 4), 16);
              if (!(a >= 0 && a <= 4095)) {
                pa(t, 0, 0, 0, 1);
                return;
              }
              return pa(t, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, r === 5 ? parseInt(i.slice(4), 16) / 15 : 1), Bg(n, t), t;
            } else if (r === 7 || r === 9) {
              var a = parseInt(i.slice(1, 7), 16);
              if (!(a >= 0 && a <= 16777215)) {
                pa(t, 0, 0, 0, 1);
                return;
              }
              return pa(t, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, r === 9 ? parseInt(i.slice(7), 16) / 255 : 1), Bg(n, t), t;
            }
            return;
          }
          var o = i.indexOf("("), s = i.indexOf(")");
          if (o !== -1 && s + 1 === r) {
            var l = i.substr(0, o), u = i.substr(o + 1, s - (o + 1)).split(","), h = 1;
            switch (l) {
              case "rgba":
                if (u.length !== 4) return u.length === 3 ? pa(t, +u[0], +u[1], +u[2], 1) : pa(t, 0, 0, 0, 1);
                h = Ch(u.pop());
              case "rgb":
                if (u.length >= 3) return pa(t, U2(u[0]), U2(u[1]), U2(u[2]), u.length === 3 ? h : Ch(u[3])), Bg(n, t), t;
                pa(t, 0, 0, 0, 1);
                return;
              case "hsla":
                if (u.length !== 4) {
                  pa(t, 0, 0, 0, 1);
                  return;
                }
                return u[3] = Ch(u[3]), q2(u, t), Bg(n, t), t;
              case "hsl":
                if (u.length !== 3) {
                  pa(t, 0, 0, 0, 1);
                  return;
                }
                return q2(u, t), Bg(n, t), t;
              default:
                return;
            }
          }
          pa(t, 0, 0, 0, 1);
        }
      }
      function q2(n, t) {
        var e = (parseFloat(n[0]) % 360 + 360) % 360 / 360, i = Ch(n[1]), r = Ch(n[2]), a = r <= 0.5 ? r * (i + 1) : r + i - r * i, o = r * 2 - a;
        return t = t || [], pa(t, Xa(V2(o, a, e + 1 / 3) * 255), Xa(V2(o, a, e) * 255), Xa(V2(o, a, e - 1 / 3) * 255), 1), n.length === 4 && (t[3] = n[3]), t;
      }
      function b1t(n) {
        if (n) {
          var t = n[0] / 255, e = n[1] / 255, i = n[2] / 255, r = Math.min(t, e, i), a = Math.max(t, e, i), o = a - r, s = (a + r) / 2, l, u;
          if (o === 0) l = 0, u = 0;
          else {
            s < 0.5 ? u = o / (a + r) : u = o / (2 - a - r);
            var h = ((a - t) / 6 + o / 2) / o, c = ((a - e) / 6 + o / 2) / o, f = ((a - i) / 6 + o / 2) / o;
            t === a ? l = f - c : e === a ? l = 1 / 3 + h - f : i === a && (l = 2 / 3 + c - h), l < 0 && (l += 1), l > 1 && (l -= 1);
          }
          var g = [l * 360, u, s];
          return n[3] != null && g.push(n[3]), g;
        }
      }
      function H2(n, t) {
        var e = qr(n);
        if (e) {
          for (var i = 0; i < 3; i++) t < 0 ? e[i] = e[i] * (1 - t) | 0 : e[i] = (255 - e[i]) * t + e[i] | 0, e[i] > 255 ? e[i] = 255 : e[i] < 0 && (e[i] = 0);
          return Gs(e, e.length === 4 ? "rgba" : "rgb");
        }
      }
      function Y2(n, t, e) {
        if (!(!(t && t.length) || !(n >= 0 && n <= 1))) {
          e = e || [];
          var i = n * (t.length - 1), r = Math.floor(i), a = Math.ceil(i), o = t[r], s = t[a], l = i - r;
          return e[0] = Xa(nu(o[0], s[0], l)), e[1] = Xa(nu(o[1], s[1], l)), e[2] = Xa(nu(o[2], s[2], l)), e[3] = jp(nu(o[3], s[3], l)), e;
        }
      }
      function T1t(n, t, e) {
        if (!(!(t && t.length) || !(n >= 0 && n <= 1))) {
          var i = n * (t.length - 1), r = Math.floor(i), a = Math.ceil(i), o = qr(t[r]), s = qr(t[a]), l = i - r, u = Gs([Xa(nu(o[0], s[0], l)), Xa(nu(o[1], s[1], l)), Xa(nu(o[2], s[2], l)), jp(nu(o[3], s[3], l))], "rgba");
          return e ? { color: u, leftIndex: r, rightIndex: a, value: i } : u;
        }
      }
      function qp(n, t, e, i) {
        var r = qr(n);
        if (n) return r = b1t(r), t != null && (r[0] = S1t(t)), e != null && (r[1] = Ch(e)), i != null && (r[2] = Ch(i)), Gs(q2(r), "rgba");
      }
      function e1(n, t) {
        var e = qr(n);
        if (e && t != null) return e[3] = jp(t), Gs(e, "rgba");
      }
      function Gs(n, t) {
        if (!(!n || !n.length)) {
          var e = n[0] + "," + n[1] + "," + n[2];
          return (t === "rgba" || t === "hsva" || t === "hsla") && (e += "," + n[3]), t + "(" + e + ")";
        }
      }
      function n1(n, t) {
        var e = qr(n);
        return e ? (0.299 * e[0] + 0.587 * e[1] + 0.114 * e[2]) * e[3] / 255 + (1 - e[3]) * t : 0;
      }
      var D5 = new Vp(100);
      function W2(n) {
        if (ht(n)) {
          var t = D5.get(n);
          return t || (t = H2(n, -0.1), D5.put(n, t)), t;
        } else if (O_(n)) {
          var e = X({}, n);
          return e.colorStops = K(n.colorStops, function(i) {
            return { offset: i.offset, color: H2(i.color, -0.1) };
          }), e;
        }
        return n;
      }
      var i1 = Math.round;
      function Hp(n) {
        var t;
        if (!n || n === "transparent") n = "none";
        else if (typeof n == "string" && n.indexOf("rgba") > -1) {
          var e = qr(n);
          e && (n = "rgb(" + e[0] + "," + e[1] + "," + e[2] + ")", t = e[3]);
        }
        return { color: n, opacity: t == null ? 1 : t };
      }
      var R5 = 1e-4;
      function iu(n) {
        return n < R5 && n > -R5;
      }
      function r1(n) {
        return i1(n * 1e3) / 1e3;
      }
      function X2(n) {
        return i1(n * 1e4) / 1e4;
      }
      function B1t(n) {
        return "matrix(" + r1(n[0]) + "," + r1(n[1]) + "," + r1(n[2]) + "," + r1(n[3]) + "," + X2(n[4]) + "," + X2(n[5]) + ")";
      }
      var M1t = { left: "start", right: "end", center: "middle", middle: "middle" };
      function D1t(n, t, e) {
        return e === "top" ? n += t / 2 : e === "bottom" && (n -= t / 2), n;
      }
      function R1t(n) {
        return n && (n.shadowBlur || n.shadowOffsetX || n.shadowOffsetY);
      }
      function L1t(n) {
        var t = n.style, e = n.getGlobalScale();
        return [t.shadowColor, (t.shadowBlur || 0).toFixed(2), (t.shadowOffsetX || 0).toFixed(2), (t.shadowOffsetY || 0).toFixed(2), e[0], e[1]].join(",");
      }
      function L5(n) {
        return n && !!n.image;
      }
      function P1t(n) {
        return n && !!n.svgElement;
      }
      function $2(n) {
        return L5(n) || P1t(n);
      }
      function P5(n) {
        return n.type === "linear";
      }
      function N5(n) {
        return n.type === "radial";
      }
      function F5(n) {
        return n && (n.type === "linear" || n.type === "radial");
      }
      function a1(n) {
        return "url(#" + n + ")";
      }
      function k5(n) {
        var t = n.getGlobalScale(), e = Math.max(t[0], t[1]);
        return Math.max(Math.ceil(Math.log(e) / Math.log(10)), 1);
      }
      function O5(n) {
        var t = n.x || 0, e = n.y || 0, i = (n.rotation || 0) * U_, r = kt(n.scaleX, 1), a = kt(n.scaleY, 1), o = n.skewX || 0, s = n.skewY || 0, l = [];
        return (t || e) && l.push("translate(" + t + "px," + e + "px)"), i && l.push("rotate(" + i + ")"), (r !== 1 || a !== 1) && l.push("scale(" + r + "," + a + ")"), (o || s) && l.push("skew(" + i1(o * U_) + "deg, " + i1(s * U_) + "deg)"), l.join(" ");
      }
      var N1t = function() {
        return re.hasGlobalWindow && yt(window.btoa) ? function(n) {
          return window.btoa(unescape(encodeURIComponent(n)));
        } : typeof Buffer != "undefined" ? function(n) {
          return Buffer.from(n).toString("base64");
        } : function(n) {
          return Ya("Base64 isn't natively supported in the current environment."), null;
        };
      }(), Z2 = Array.prototype.slice;
      function Us(n, t, e) {
        return (t - n) * e + n;
      }
      function K2(n, t, e, i) {
        for (var r = t.length, a = 0; a < r; a++) n[a] = Us(t[a], e[a], i);
        return n;
      }
      function F1t(n, t, e, i) {
        for (var r = t.length, a = r && t[0].length, o = 0; o < r; o++) {
          n[o] || (n[o] = []);
          for (var s = 0; s < a; s++) n[o][s] = Us(t[o][s], e[o][s], i);
        }
        return n;
      }
      function o1(n, t, e, i) {
        for (var r = t.length, a = 0; a < r; a++) n[a] = t[a] + e[a] * i;
        return n;
      }
      function Q5(n, t, e, i) {
        for (var r = t.length, a = r && t[0].length, o = 0; o < r; o++) {
          n[o] || (n[o] = []);
          for (var s = 0; s < a; s++) n[o][s] = t[o][s] + e[o][s] * i;
        }
        return n;
      }
      function k1t(n, t) {
        for (var e = n.length, i = t.length, r = e > i ? t : n, a = Math.min(e, i), o = r[a - 1] || { color: [0, 0, 0, 0], offset: 0 }, s = a; s < Math.max(e, i); s++) r.push({ offset: o.offset, color: o.color.slice() });
      }
      function O1t(n, t, e) {
        var i = n, r = t;
        if (!(!i.push || !r.push)) {
          var a = i.length, o = r.length;
          if (a !== o) {
            var s = a > o;
            if (s) i.length = o;
            else for (var l = a; l < o; l++) i.push(e === 1 ? r[l] : Z2.call(r[l]));
          }
          for (var u = i[0] && i[0].length, l = 0; l < i.length; l++) if (e === 1) isNaN(i[l]) && (i[l] = r[l]);
          else for (var h = 0; h < u; h++) isNaN(i[l][h]) && (i[l][h] = r[l][h]);
        }
      }
      function Yp(n) {
        if (Li(n)) {
          var t = n.length;
          if (Li(n[0])) {
            for (var e = [], i = 0; i < t; i++) e.push(Z2.call(n[i]));
            return e;
          }
          return Z2.call(n);
        }
        return n;
      }
      function s1(n) {
        return n[0] = Math.floor(n[0]) || 0, n[1] = Math.floor(n[1]) || 0, n[2] = Math.floor(n[2]) || 0, n[3] = n[3] == null ? 1 : n[3], "rgba(" + n.join(",") + ")";
      }
      function Q1t(n) {
        return Li(n && n[0]) ? 2 : 1;
      }
      var l1 = 0, u1 = 1, z5 = 2, Wp = 3, J2 = 4, tT = 5, G5 = 6;
      function U5(n) {
        return n === J2 || n === tT;
      }
      function h1(n) {
        return n === u1 || n === z5;
      }
      var Xp = [0, 0, 0, 0], z1t = function() {
        function n(t) {
          this.keyframes = [], this.discrete = false, this._invalid = false, this._needsSort = false, this._lastFr = 0, this._lastFrP = 0, this.propName = t;
        }
        return n.prototype.isFinished = function() {
          return this._finished;
        }, n.prototype.setFinished = function() {
          this._finished = true, this._additiveTrack && this._additiveTrack.setFinished();
        }, n.prototype.needsAnimate = function() {
          return this.keyframes.length >= 1;
        }, n.prototype.getAdditiveTrack = function() {
          return this._additiveTrack;
        }, n.prototype.addKeyframe = function(t, e, i) {
          this._needsSort = true;
          var r = this.keyframes, a = r.length, o = false, s = G5, l = e;
          if (Li(e)) {
            var u = Q1t(e);
            s = u, (u === 1 && !ye(e[0]) || u === 2 && !ye(e[0][0])) && (o = true);
          } else if (ye(e) && !ph(e)) s = l1;
          else if (ht(e)) if (!isNaN(+e)) s = l1;
          else {
            var h = qr(e);
            h && (l = h, s = Wp);
          }
          else if (O_(e)) {
            var c = X({}, l);
            c.colorStops = K(e.colorStops, function(g) {
              return { offset: g.offset, color: qr(g.color) };
            }), P5(e) ? s = J2 : N5(e) && (s = tT), l = c;
          }
          a === 0 ? this.valType = s : (s !== this.valType || s === G5) && (o = true), this.discrete = this.discrete || o;
          var f = { time: t, value: l, rawValue: e, percent: 0 };
          return i && (f.easing = i, f.easingFunc = yt(i) ? i : Gp[i] || G2(i)), r.push(f), f;
        }, n.prototype.prepare = function(t, e) {
          var i = this.keyframes;
          this._needsSort && i.sort(function(A, p) {
            return A.time - p.time;
          });
          for (var r = this.valType, a = i.length, o = i[a - 1], s = this.discrete, l = h1(r), u = U5(r), h = 0; h < a; h++) {
            var c = i[h], f = c.value, g = o.value;
            c.percent = c.time / t, s || (l && h !== a - 1 ? O1t(f, g, r) : u && k1t(f.colorStops, g.colorStops));
          }
          if (!s && r !== tT && e && this.needsAnimate() && e.needsAnimate() && r === e.valType && !e._finished) {
            this._additiveTrack = e;
            for (var d = i[0].value, h = 0; h < a; h++) r === l1 ? i[h].additiveValue = i[h].value - d : r === Wp ? i[h].additiveValue = o1([], i[h].value, d, -1) : h1(r) && (i[h].additiveValue = r === u1 ? o1([], i[h].value, d, -1) : Q5([], i[h].value, d, -1));
          }
        }, n.prototype.step = function(t, e) {
          if (!this._finished) {
            this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
            var i = this._additiveTrack != null, r = i ? "additiveValue" : "value", a = this.valType, o = this.keyframes, s = o.length, l = this.propName, u = a === Wp, h, c = this._lastFr, f = Math.min, g, d;
            if (s === 1) g = d = o[0];
            else {
              if (e < 0) h = 0;
              else if (e < this._lastFrP) {
                var A = f(c + 1, s - 1);
                for (h = A; h >= 0 && !(o[h].percent <= e); h--) ;
                h = f(h, s - 2);
              } else {
                for (h = c; h < s && !(o[h].percent > e); h++) ;
                h = f(h - 1, s - 2);
              }
              d = o[h + 1], g = o[h];
            }
            if (g && d) {
              this._lastFr = h, this._lastFrP = e;
              var p = d.percent - g.percent, v = p === 0 ? 1 : f((e - g.percent) / p, 1);
              d.easingFunc && (v = d.easingFunc(v));
              var y = i ? this._additiveValue : u ? Xp : t[l];
              if ((h1(a) || u) && !y && (y = this._additiveValue = []), this.discrete) t[l] = v < 1 ? g.rawValue : d.rawValue;
              else if (h1(a)) a === u1 ? K2(y, g[r], d[r], v) : F1t(y, g[r], d[r], v);
              else if (U5(a)) {
                var m = g[r], _ = d[r], I = a === J2;
                t[l] = { type: I ? "linear" : "radial", x: Us(m.x, _.x, v), y: Us(m.y, _.y, v), colorStops: K(m.colorStops, function(x, w) {
                  var C = _.colorStops[w];
                  return { offset: Us(x.offset, C.offset, v), color: s1(K2([], x.color, C.color, v)) };
                }), global: _.global }, I ? (t[l].x2 = Us(m.x2, _.x2, v), t[l].y2 = Us(m.y2, _.y2, v)) : t[l].r = Us(m.r, _.r, v);
              } else if (u) K2(y, g[r], d[r], v), i || (t[l] = s1(y));
              else {
                var E = Us(g[r], d[r], v);
                i ? this._additiveValue = E : t[l] = E;
              }
              i && this._addToTarget(t);
            }
          }
        }, n.prototype._addToTarget = function(t) {
          var e = this.valType, i = this.propName, r = this._additiveValue;
          e === l1 ? t[i] = t[i] + r : e === Wp ? (qr(t[i], Xp), o1(Xp, Xp, r, 1), t[i] = s1(Xp)) : e === u1 ? o1(t[i], t[i], r, 1) : e === z5 && Q5(t[i], t[i], r, 1);
        }, n;
      }(), eT = function() {
        function n(t, e, i, r) {
          if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = t, this._loop = e, e && r) {
            Ya("Can' use additive animation on looped animation.");
            return;
          }
          this._additiveAnimators = r, this._allowDiscrete = i;
        }
        return n.prototype.getMaxTime = function() {
          return this._maxTime;
        }, n.prototype.getDelay = function() {
          return this._delay;
        }, n.prototype.getLoop = function() {
          return this._loop;
        }, n.prototype.getTarget = function() {
          return this._target;
        }, n.prototype.changeTarget = function(t) {
          this._target = t;
        }, n.prototype.when = function(t, e, i) {
          return this.whenWithKeys(t, e, oe(e), i);
        }, n.prototype.whenWithKeys = function(t, e, i, r) {
          for (var a = this._tracks, o = 0; o < i.length; o++) {
            var s = i[o], l = a[s];
            if (!l) {
              l = a[s] = new z1t(s);
              var u = void 0, h = this._getAdditiveTrack(s);
              if (h) {
                var c = h.keyframes, f = c[c.length - 1];
                u = f && f.value, h.valType === Wp && u && (u = s1(u));
              } else u = this._target[s];
              if (u == null) continue;
              t > 0 && l.addKeyframe(0, Yp(u), r), this._trackKeys.push(s);
            }
            l.addKeyframe(t, Yp(e[s]), r);
          }
          return this._maxTime = Math.max(this._maxTime, t), this;
        }, n.prototype.pause = function() {
          this._clip.pause(), this._paused = true;
        }, n.prototype.resume = function() {
          this._clip.resume(), this._paused = false;
        }, n.prototype.isPaused = function() {
          return !!this._paused;
        }, n.prototype.duration = function(t) {
          return this._maxTime = t, this._force = true, this;
        }, n.prototype._doneCallback = function() {
          this._setTracksFinished(), this._clip = null;
          var t = this._doneCbs;
          if (t) for (var e = t.length, i = 0; i < e; i++) t[i].call(this);
        }, n.prototype._abortedCallback = function() {
          this._setTracksFinished();
          var t = this.animation, e = this._abortedCbs;
          if (t && t.removeClip(this._clip), this._clip = null, e) for (var i = 0; i < e.length; i++) e[i].call(this);
        }, n.prototype._setTracksFinished = function() {
          for (var t = this._tracks, e = this._trackKeys, i = 0; i < e.length; i++) t[e[i]].setFinished();
        }, n.prototype._getAdditiveTrack = function(t) {
          var e, i = this._additiveAnimators;
          if (i) for (var r = 0; r < i.length; r++) {
            var a = i[r].getTrack(t);
            a && (e = a);
          }
          return e;
        }, n.prototype.start = function(t) {
          if (!(this._started > 0)) {
            this._started = 1;
            for (var e = this, i = [], r = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
              var o = this._trackKeys[a], s = this._tracks[o], l = this._getAdditiveTrack(o), u = s.keyframes, h = u.length;
              if (s.prepare(r, l), s.needsAnimate()) if (!this._allowDiscrete && s.discrete) {
                var c = u[h - 1];
                c && (e._target[s.propName] = c.rawValue), s.setFinished();
              } else i.push(s);
            }
            if (i.length || this._force) {
              var f = new w1t({ life: r, loop: this._loop, delay: this._delay || 0, onframe: function(g) {
                e._started = 2;
                var d = e._additiveAnimators;
                if (d) {
                  for (var A = false, p = 0; p < d.length; p++) if (d[p]._clip) {
                    A = true;
                    break;
                  }
                  A || (e._additiveAnimators = null);
                }
                for (var p = 0; p < i.length; p++) i[p].step(e._target, g);
                var v = e._onframeCbs;
                if (v) for (var p = 0; p < v.length; p++) v[p](e._target, g);
              }, ondestroy: function() {
                e._doneCallback();
              } });
              this._clip = f, this.animation && this.animation.addClip(f), t && f.setEasing(t);
            } else this._doneCallback();
            return this;
          }
        }, n.prototype.stop = function(t) {
          if (this._clip) {
            var e = this._clip;
            t && e.onframe(1), this._abortedCallback();
          }
        }, n.prototype.delay = function(t) {
          return this._delay = t, this;
        }, n.prototype.during = function(t) {
          return t && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(t)), this;
        }, n.prototype.done = function(t) {
          return t && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(t)), this;
        }, n.prototype.aborted = function(t) {
          return t && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(t)), this;
        }, n.prototype.getClip = function() {
          return this._clip;
        }, n.prototype.getTrack = function(t) {
          return this._tracks[t];
        }, n.prototype.getTracks = function() {
          var t = this;
          return K(this._trackKeys, function(e) {
            return t._tracks[e];
          });
        }, n.prototype.stopTracks = function(t, e) {
          if (!t.length || !this._clip) return true;
          for (var i = this._tracks, r = this._trackKeys, a = 0; a < t.length; a++) {
            var o = i[t[a]];
            o && !o.isFinished() && (e ? o.step(this._target, 1) : this._started === 1 && o.step(this._target, 0), o.setFinished());
          }
          for (var s = true, a = 0; a < r.length; a++) if (!i[r[a]].isFinished()) {
            s = false;
            break;
          }
          return s && this._abortedCallback(), s;
        }, n.prototype.saveTo = function(t, e, i) {
          if (t) {
            e = e || this._trackKeys;
            for (var r = 0; r < e.length; r++) {
              var a = e[r], o = this._tracks[a];
              if (!(!o || o.isFinished())) {
                var s = o.keyframes, l = s[i ? 0 : s.length - 1];
                l && (t[a] = Yp(l.rawValue));
              }
            }
          }
        }, n.prototype.__changeFinalValue = function(t, e) {
          e = e || oe(t);
          for (var i = 0; i < e.length; i++) {
            var r = e[i], a = this._tracks[r];
            if (a) {
              var o = a.keyframes;
              if (o.length > 1) {
                var s = o.pop();
                a.addKeyframe(s.time, t[r]), a.prepare(this._maxTime, a.getAdditiveTrack());
              }
            }
          }
        }, n;
      }();
      function Mg() {
        return (/* @__PURE__ */ new Date()).getTime();
      }
      var G1t = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this) || this;
          return i._running = false, i._time = 0, i._pausedTime = 0, i._pauseStart = 0, i._paused = false, e = e || {}, i.stage = e.stage || {}, i;
        }
        return t.prototype.addClip = function(e) {
          e.animation && this.removeClip(e), this._head ? (this._tail.next = e, e.prev = this._tail, e.next = null, this._tail = e) : this._head = this._tail = e, e.animation = this;
        }, t.prototype.addAnimator = function(e) {
          e.animation = this;
          var i = e.getClip();
          i && this.addClip(i);
        }, t.prototype.removeClip = function(e) {
          if (e.animation) {
            var i = e.prev, r = e.next;
            i ? i.next = r : this._head = r, r ? r.prev = i : this._tail = i, e.next = e.prev = e.animation = null;
          }
        }, t.prototype.removeAnimator = function(e) {
          var i = e.getClip();
          i && this.removeClip(i), e.animation = null;
        }, t.prototype.update = function(e) {
          for (var i = Mg() - this._pausedTime, r = i - this._time, a = this._head; a; ) {
            var o = a.next, s = a.step(i, r);
            s && (a.ondestroy(), this.removeClip(a)), a = o;
          }
          this._time = i, e || (this.trigger("frame", r), this.stage.update && this.stage.update());
        }, t.prototype._startLoop = function() {
          var e = this;
          this._running = true;
          function i() {
            e._running && (X_(i), !e._paused && e.update());
          }
          X_(i);
        }, t.prototype.start = function() {
          this._running || (this._time = Mg(), this._pausedTime = 0, this._startLoop());
        }, t.prototype.stop = function() {
          this._running = false;
        }, t.prototype.pause = function() {
          this._paused || (this._pauseStart = Mg(), this._paused = true);
        }, t.prototype.resume = function() {
          this._paused && (this._pausedTime += Mg() - this._pauseStart, this._paused = false);
        }, t.prototype.clear = function() {
          for (var e = this._head; e; ) {
            var i = e.next;
            e.prev = e.next = e.animation = null, e = i;
          }
          this._head = this._tail = null;
        }, t.prototype.isFinished = function() {
          return this._head == null;
        }, t.prototype.animate = function(e, i) {
          i = i || {}, this.start();
          var r = new eT(e, i.loop);
          return this.addAnimator(r), r;
        }, t;
      }(ga), U1t = 300, nT = re.domSupported, iT = function() {
        var n = ["click", "dblclick", "mousewheel", "wheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"], t = ["touchstart", "touchend", "touchmove"], e = { pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1 }, i = K(n, function(r) {
          var a = r.replace("mouse", "pointer");
          return e.hasOwnProperty(a) ? a : r;
        });
        return { mouse: n, touch: t, pointer: i };
      }(), V5 = { mouse: ["mousemove", "mouseup"], pointer: ["pointermove", "pointerup"] }, j5 = false;
      function rT(n) {
        var t = n.pointerType;
        return t === "pen" || t === "touch";
      }
      function V1t(n) {
        n.touching = true, n.touchTimer != null && (clearTimeout(n.touchTimer), n.touchTimer = null), n.touchTimer = setTimeout(function() {
          n.touching = false, n.touchTimer = null;
        }, 700);
      }
      function aT(n) {
        n && (n.zrByTouch = true);
      }
      function j1t(n, t) {
        return da(n.dom, new q1t(n, t), true);
      }
      function q5(n, t) {
        for (var e = t, i = false; e && e.nodeType !== 9 && !(i = e.domBelongToZr || e !== t && e === n.painterRoot); ) e = e.parentNode;
        return i;
      }
      var q1t = /* @__PURE__ */ function() {
        function n(t, e) {
          this.stopPropagation = bn, this.stopImmediatePropagation = bn, this.preventDefault = bn, this.type = e.type, this.target = this.currentTarget = t.dom, this.pointerType = e.pointerType, this.clientX = e.clientX, this.clientY = e.clientY;
        }
        return n;
      }(), $a = { mousedown: function(n) {
        n = da(this.dom, n), this.__mayPointerCapture = [n.zrX, n.zrY], this.trigger("mousedown", n);
      }, mousemove: function(n) {
        n = da(this.dom, n);
        var t = this.__mayPointerCapture;
        t && (n.zrX !== t[0] || n.zrY !== t[1]) && this.__togglePointerCapture(true), this.trigger("mousemove", n);
      }, mouseup: function(n) {
        n = da(this.dom, n), this.__togglePointerCapture(false), this.trigger("mouseup", n);
      }, mouseout: function(n) {
        n = da(this.dom, n);
        var t = n.toElement || n.relatedTarget;
        q5(this, t) || (this.__pointerCapturing && (n.zrEventControl = "no_globalout"), this.trigger("mouseout", n));
      }, wheel: function(n) {
        j5 = true, n = da(this.dom, n), this.trigger("mousewheel", n);
      }, mousewheel: function(n) {
        j5 || (n = da(this.dom, n), this.trigger("mousewheel", n));
      }, touchstart: function(n) {
        n = da(this.dom, n), aT(n), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(n, "start"), $a.mousemove.call(this, n), $a.mousedown.call(this, n);
      }, touchmove: function(n) {
        n = da(this.dom, n), aT(n), this.handler.processGesture(n, "change"), $a.mousemove.call(this, n);
      }, touchend: function(n) {
        n = da(this.dom, n), aT(n), this.handler.processGesture(n, "end"), $a.mouseup.call(this, n), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < U1t && $a.click.call(this, n);
      }, pointerdown: function(n) {
        $a.mousedown.call(this, n);
      }, pointermove: function(n) {
        rT(n) || $a.mousemove.call(this, n);
      }, pointerup: function(n) {
        $a.mouseup.call(this, n);
      }, pointerout: function(n) {
        rT(n) || $a.mouseout.call(this, n);
      } };
      D(["click", "dblclick", "contextmenu"], function(n) {
        $a[n] = function(t) {
          t = da(this.dom, t), this.trigger(n, t);
        };
      });
      var oT = { pointermove: function(n) {
        rT(n) || oT.mousemove.call(this, n);
      }, pointerup: function(n) {
        oT.mouseup.call(this, n);
      }, mousemove: function(n) {
        this.trigger("mousemove", n);
      }, mouseup: function(n) {
        var t = this.__pointerCapturing;
        this.__togglePointerCapture(false), this.trigger("mouseup", n), t && (n.zrEventControl = "only_globalout", this.trigger("mouseout", n));
      } };
      function H1t(n, t) {
        var e = t.domHandlers;
        re.pointerEventsSupported ? D(iT.pointer, function(i) {
          c1(t, i, function(r) {
            e[i].call(n, r);
          });
        }) : (re.touchEventsSupported && D(iT.touch, function(i) {
          c1(t, i, function(r) {
            e[i].call(n, r), V1t(t);
          });
        }), D(iT.mouse, function(i) {
          c1(t, i, function(r) {
            r = D2(r), t.touching || e[i].call(n, r);
          });
        }));
      }
      function Y1t(n, t) {
        re.pointerEventsSupported ? D(V5.pointer, e) : re.touchEventsSupported || D(V5.mouse, e);
        function e(i) {
          function r(a) {
            a = D2(a), q5(n, a.target) || (a = j1t(n, a), t.domHandlers[i].call(n, a));
          }
          c1(t, i, r, { capture: true });
        }
      }
      function c1(n, t, e, i) {
        n.mounted[t] = e, n.listenerOpts[t] = i, R2(n.domTarget, t, e, i);
      }
      function sT(n) {
        var t = n.mounted;
        for (var e in t) t.hasOwnProperty(e) && s1t(n.domTarget, e, t[e], n.listenerOpts[e]);
        n.mounted = {};
      }
      var H5 = /* @__PURE__ */ function() {
        function n(t, e) {
          this.mounted = {}, this.listenerOpts = {}, this.touching = false, this.domTarget = t, this.domHandlers = e;
        }
        return n;
      }(), W1t = function(n) {
        V(t, n);
        function t(e, i) {
          var r = n.call(this) || this;
          return r.__pointerCapturing = false, r.dom = e, r.painterRoot = i, r._localHandlerScope = new H5(e, $a), nT && (r._globalHandlerScope = new H5(document, oT)), H1t(r, r._localHandlerScope), r;
        }
        return t.prototype.dispose = function() {
          sT(this._localHandlerScope), nT && sT(this._globalHandlerScope);
        }, t.prototype.setCursor = function(e) {
          this.dom.style && (this.dom.style.cursor = e || "default");
        }, t.prototype.__togglePointerCapture = function(e) {
          if (this.__mayPointerCapture = null, nT && +this.__pointerCapturing ^ +e) {
            this.__pointerCapturing = e;
            var i = this._globalHandlerScope;
            e ? Y1t(this, i) : sT(i);
          }
        }, t;
      }(ga), Y5 = 1;
      re.hasGlobalWindow && (Y5 = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
      var f1 = Y5, lT = 0.4, uT = "#333", hT = "#ccc", X1t = "#eee", W5 = q_, X5 = 5e-5;
      function Sh(n) {
        return n > X5 || n < -X5;
      }
      var bh = [], Dg = [], cT = Vr(), fT = Math.abs, Vs = function() {
        function n() {
        }
        return n.prototype.getLocalTransform = function(t) {
          return n.getLocalTransform(this, t);
        }, n.prototype.setPosition = function(t) {
          this.x = t[0], this.y = t[1];
        }, n.prototype.setScale = function(t) {
          this.scaleX = t[0], this.scaleY = t[1];
        }, n.prototype.setSkew = function(t) {
          this.skewX = t[0], this.skewY = t[1];
        }, n.prototype.setOrigin = function(t) {
          this.originX = t[0], this.originY = t[1];
        }, n.prototype.needLocalTransform = function() {
          return Sh(this.rotation) || Sh(this.x) || Sh(this.y) || Sh(this.scaleX - 1) || Sh(this.scaleY - 1) || Sh(this.skewX) || Sh(this.skewY);
        }, n.prototype.updateTransform = function() {
          var t = this.parent && this.parent.transform, e = this.needLocalTransform(), i = this.transform;
          if (!(e || t)) {
            i && (W5(i), this.invTransform = null);
            return;
          }
          i = i || Vr(), e ? this.getLocalTransform(i) : W5(i), t && (e ? zs(i, t, i) : P2(i, t)), this.transform = i, this._resolveGlobalScaleRatio(i);
        }, n.prototype._resolveGlobalScaleRatio = function(t) {
          var e = this.globalScaleRatio;
          if (e != null && e !== 1) {
            this.getGlobalScale(bh);
            var i = bh[0] < 0 ? -1 : 1, r = bh[1] < 0 ? -1 : 1, a = ((bh[0] - i) * e + i) / bh[0] || 0, o = ((bh[1] - r) * e + r) / bh[1] || 0;
            t[0] *= a, t[1] *= a, t[2] *= o, t[3] *= o;
          }
          this.invTransform = this.invTransform || Vr(), Sg(this.invTransform, t);
        }, n.prototype.getComputedTransform = function() {
          for (var t = this, e = []; t; ) e.push(t), t = t.parent;
          for (; t = e.pop(); ) t.updateTransform();
          return this.transform;
        }, n.prototype.setLocalTransform = function(t) {
          if (t) {
            var e = t[0] * t[0] + t[1] * t[1], i = t[2] * t[2] + t[3] * t[3], r = Math.atan2(t[1], t[0]), a = Math.PI / 2 + r - Math.atan2(t[3], t[2]);
            i = Math.sqrt(i) * Math.cos(a), e = Math.sqrt(e), this.skewX = a, this.skewY = 0, this.rotation = -r, this.x = +t[4], this.y = +t[5], this.scaleX = e, this.scaleY = i, this.originX = 0, this.originY = 0;
          }
        }, n.prototype.decomposeTransform = function() {
          if (this.transform) {
            var t = this.parent, e = this.transform;
            t && t.transform && (t.invTransform = t.invTransform || Vr(), zs(Dg, t.invTransform, e), e = Dg);
            var i = this.originX, r = this.originY;
            (i || r) && (cT[4] = i, cT[5] = r, zs(Dg, e, cT), Dg[4] -= i, Dg[5] -= r, e = Dg), this.setLocalTransform(e);
          }
        }, n.prototype.getGlobalScale = function(t) {
          var e = this.transform;
          return t = t || [], e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), e[0] < 0 && (t[0] = -t[0]), e[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t);
        }, n.prototype.transformCoordToLocal = function(t, e) {
          var i = [t, e], r = this.invTransform;
          return r && _i(i, i, r), i;
        }, n.prototype.transformCoordToGlobal = function(t, e) {
          var i = [t, e], r = this.transform;
          return r && _i(i, i, r), i;
        }, n.prototype.getLineScale = function() {
          var t = this.transform;
          return t && fT(t[0] - 1) > 1e-10 && fT(t[3] - 1) > 1e-10 ? Math.sqrt(fT(t[0] * t[3] - t[2] * t[1])) : 1;
        }, n.prototype.copyTransform = function(t) {
          $5(this, t);
        }, n.getLocalTransform = function(t, e) {
          e = e || [];
          var i = t.originX || 0, r = t.originY || 0, a = t.scaleX, o = t.scaleY, s = t.anchorX, l = t.anchorY, u = t.rotation || 0, h = t.x, c = t.y, f = t.skewX ? Math.tan(t.skewX) : 0, g = t.skewY ? Math.tan(-t.skewY) : 0;
          if (i || r || s || l) {
            var d = i + s, A = r + l;
            e[4] = -d * a - f * A * o, e[5] = -A * o - g * d * a;
          } else e[4] = e[5] = 0;
          return e[0] = a, e[3] = o, e[1] = g * a, e[2] = f * o, u && _h(e, e, u), e[4] += i + h, e[5] += r + c, e;
        }, n.initDefaultProps = function() {
          var t = n.prototype;
          t.scaleX = t.scaleY = t.globalScaleRatio = 1, t.x = t.y = t.originX = t.originY = t.skewX = t.skewY = t.rotation = t.anchorX = t.anchorY = 0;
        }(), n;
      }(), Vo = ["x", "y", "originX", "originY", "anchorX", "anchorY", "rotation", "scaleX", "scaleY", "skewX", "skewY"];
      function $5(n, t) {
        for (var e = 0; e < Vo.length; e++) {
          var i = Vo[e];
          n[i] = t[i];
        }
      }
      var Z5 = {};
      function Hr(n, t) {
        t = t || Wl;
        var e = Z5[t];
        e || (e = Z5[t] = new Vp(500));
        var i = e.get(n);
        return i == null && (i = Xl.measureText(n, t).width, e.put(n, i)), i;
      }
      function K5(n, t, e, i) {
        var r = Hr(n, t), a = g1(t), o = Zp(0, r, e), s = Rg(0, a, i), l = new Wt(o, s, r, a);
        return l;
      }
      function $p(n, t, e, i) {
        var r = ((n || "") + "").split(`
`), a = r.length;
        if (a === 1) return K5(r[0], t, e, i);
        for (var o = new Wt(0, 0, 0, 0), s = 0; s < r.length; s++) {
          var l = K5(r[s], t, e, i);
          s === 0 ? o.copy(l) : o.union(l);
        }
        return o;
      }
      function Zp(n, t, e) {
        return e === "right" ? n -= t : e === "center" && (n -= t / 2), n;
      }
      function Rg(n, t, e) {
        return e === "middle" ? n -= t / 2 : e === "bottom" && (n -= t), n;
      }
      function g1(n) {
        return Hr("", n);
      }
      function Za(n, t) {
        return typeof n == "string" ? n.lastIndexOf("%") >= 0 ? parseFloat(n) / 100 * t : parseFloat(n) : n;
      }
      function d1(n, t, e) {
        var i = t.position || "inside", r = t.distance != null ? t.distance : 5, a = e.height, o = e.width, s = a / 2, l = e.x, u = e.y, h = "left", c = "top";
        if (i instanceof Array) l += Za(i[0], e.width), u += Za(i[1], e.height), h = null, c = null;
        else switch (i) {
          case "left":
            l -= r, u += s, h = "right", c = "middle";
            break;
          case "right":
            l += r + o, u += s, c = "middle";
            break;
          case "top":
            l += o / 2, u -= r, h = "center", c = "bottom";
            break;
          case "bottom":
            l += o / 2, u += a + r, h = "center";
            break;
          case "inside":
            l += o / 2, u += s, h = "center", c = "middle";
            break;
          case "insideLeft":
            l += r, u += s, c = "middle";
            break;
          case "insideRight":
            l += o - r, u += s, h = "right", c = "middle";
            break;
          case "insideTop":
            l += o / 2, u += r, h = "center";
            break;
          case "insideBottom":
            l += o / 2, u += a - r, h = "center", c = "bottom";
            break;
          case "insideTopLeft":
            l += r, u += r;
            break;
          case "insideTopRight":
            l += o - r, u += r, h = "right";
            break;
          case "insideBottomLeft":
            l += r, u += a - r, c = "bottom";
            break;
          case "insideBottomRight":
            l += o - r, u += a - r, h = "right", c = "bottom";
            break;
        }
        return n = n || {}, n.x = l, n.y = u, n.align = h, n.verticalAlign = c, n;
      }
      var gT = "__zr_normal__", dT = Vo.concat(["ignore"]), $1t = zo(Vo, function(n, t) {
        return n[t] = true, n;
      }, { ignore: false }), Lg = {}, Z1t = new Wt(0, 0, 0, 0), A1 = function() {
        function n(t) {
          this.id = KG(), this.animators = [], this.currentStates = [], this.states = {}, this._init(t);
        }
        return n.prototype._init = function(t) {
          this.attr(t);
        }, n.prototype.drift = function(t, e, i) {
          switch (this.draggable) {
            case "horizontal":
              e = 0;
              break;
            case "vertical":
              t = 0;
              break;
          }
          var r = this.transform;
          r || (r = this.transform = [1, 0, 0, 1, 0, 0]), r[4] += t, r[5] += e, this.decomposeTransform(), this.markRedraw();
        }, n.prototype.beforeUpdate = function() {
        }, n.prototype.afterUpdate = function() {
        }, n.prototype.update = function() {
          this.updateTransform(), this.__dirty && this.updateInnerText();
        }, n.prototype.updateInnerText = function(t) {
          var e = this._textContent;
          if (e && (!e.ignore || t)) {
            this.textConfig || (this.textConfig = {});
            var i = this.textConfig, r = i.local, a = e.innerTransformable, o = void 0, s = void 0, l = false;
            a.parent = r ? this : null;
            var u = false;
            if (a.copyTransform(e), i.position != null) {
              var h = Z1t;
              i.layoutRect ? h.copy(i.layoutRect) : h.copy(this.getBoundingRect()), r || h.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(Lg, i, h) : d1(Lg, i, h), a.x = Lg.x, a.y = Lg.y, o = Lg.align, s = Lg.verticalAlign;
              var c = i.origin;
              if (c && i.rotation != null) {
                var f = void 0, g = void 0;
                c === "center" ? (f = h.width * 0.5, g = h.height * 0.5) : (f = Za(c[0], h.width), g = Za(c[1], h.height)), u = true, a.originX = -a.x + f + (r ? 0 : h.x), a.originY = -a.y + g + (r ? 0 : h.y);
              }
            }
            i.rotation != null && (a.rotation = i.rotation);
            var d = i.offset;
            d && (a.x += d[0], a.y += d[1], u || (a.originX = -d[0], a.originY = -d[1]));
            var A = i.inside == null ? typeof i.position == "string" && i.position.indexOf("inside") >= 0 : i.inside, p = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), v = void 0, y = void 0, m = void 0;
            A && this.canBeInsideText() ? (v = i.insideFill, y = i.insideStroke, (v == null || v === "auto") && (v = this.getInsideTextFill()), (y == null || y === "auto") && (y = this.getInsideTextStroke(v), m = true)) : (v = i.outsideFill, y = i.outsideStroke, (v == null || v === "auto") && (v = this.getOutsideFill()), (y == null || y === "auto") && (y = this.getOutsideStroke(v), m = true)), v = v || "#000", (v !== p.fill || y !== p.stroke || m !== p.autoStroke || o !== p.align || s !== p.verticalAlign) && (l = true, p.fill = v, p.stroke = y, p.autoStroke = m, p.align = o, p.verticalAlign = s, e.setDefaultTextStyle(p)), e.__dirty |= jr, l && e.dirtyStyle(true);
          }
        }, n.prototype.canBeInsideText = function() {
          return true;
        }, n.prototype.getInsideTextFill = function() {
          return "#fff";
        }, n.prototype.getInsideTextStroke = function(t) {
          return "#000";
        }, n.prototype.getOutsideFill = function() {
          return this.__zr && this.__zr.isDarkMode() ? hT : uT;
        }, n.prototype.getOutsideStroke = function(t) {
          var e = this.__zr && this.__zr.getBackgroundColor(), i = typeof e == "string" && qr(e);
          i || (i = [255, 255, 255, 1]);
          for (var r = i[3], a = this.__zr.isDarkMode(), o = 0; o < 3; o++) i[o] = i[o] * r + (a ? 0 : 255) * (1 - r);
          return i[3] = 1, Gs(i, "rgba");
        }, n.prototype.traverse = function(t, e) {
        }, n.prototype.attrKV = function(t, e) {
          t === "textConfig" ? this.setTextConfig(e) : t === "textContent" ? this.setTextContent(e) : t === "clipPath" ? this.setClipPath(e) : t === "extra" ? (this.extra = this.extra || {}, X(this.extra, e)) : this[t] = e;
        }, n.prototype.hide = function() {
          this.ignore = true, this.markRedraw();
        }, n.prototype.show = function() {
          this.ignore = false, this.markRedraw();
        }, n.prototype.attr = function(t, e) {
          if (typeof t == "string") this.attrKV(t, e);
          else if (Et(t)) for (var i = t, r = oe(i), a = 0; a < r.length; a++) {
            var o = r[a];
            this.attrKV(o, t[o]);
          }
          return this.markRedraw(), this;
        }, n.prototype.saveCurrentToNormalState = function(t) {
          this._innerSaveToNormal(t);
          for (var e = this._normalState, i = 0; i < this.animators.length; i++) {
            var r = this.animators[i], a = r.__fromStateTransition;
            if (!(r.getLoop() || a && a !== gT)) {
              var o = r.targetName, s = o ? e[o] : e;
              r.saveTo(s);
            }
          }
        }, n.prototype._innerSaveToNormal = function(t) {
          var e = this._normalState;
          e || (e = this._normalState = {}), t.textConfig && !e.textConfig && (e.textConfig = this.textConfig), this._savePrimaryToNormal(t, e, dT);
        }, n.prototype._savePrimaryToNormal = function(t, e, i) {
          for (var r = 0; r < i.length; r++) {
            var a = i[r];
            t[a] != null && !(a in e) && (e[a] = this[a]);
          }
        }, n.prototype.hasState = function() {
          return this.currentStates.length > 0;
        }, n.prototype.getState = function(t) {
          return this.states[t];
        }, n.prototype.ensureState = function(t) {
          var e = this.states;
          return e[t] || (e[t] = {}), e[t];
        }, n.prototype.clearStates = function(t) {
          this.useState(gT, false, t);
        }, n.prototype.useState = function(t, e, i, r) {
          var a = t === gT, o = this.hasState();
          if (!(!o && a)) {
            var s = this.currentStates, l = this.stateTransition;
            if (!($t(s, t) >= 0 && (e || s.length === 1))) {
              var u;
              if (this.stateProxy && !a && (u = this.stateProxy(t)), u || (u = this.states && this.states[t]), !u && !a) {
                Ya("State " + t + " not exists.");
                return;
              }
              a || this.saveCurrentToNormalState(u);
              var h = !!(u && u.hoverLayer || r);
              h && this._toggleHoverLayerFlag(true), this._applyStateObj(t, u, this._normalState, e, !i && !this.__inHover && l && l.duration > 0, l);
              var c = this._textContent, f = this._textGuide;
              return c && c.useState(t, e, i, h), f && f.useState(t, e, i, h), a ? (this.currentStates = [], this._normalState = {}) : e ? this.currentStates.push(t) : this.currentStates = [t], this._updateAnimationTargets(), this.markRedraw(), !h && this.__inHover && (this._toggleHoverLayerFlag(false), this.__dirty &= ~jr), u;
            }
          }
        }, n.prototype.useStates = function(t, e, i) {
          if (!t.length) this.clearStates();
          else {
            var r = [], a = this.currentStates, o = t.length, s = o === a.length;
            if (s) {
              for (var l = 0; l < o; l++) if (t[l] !== a[l]) {
                s = false;
                break;
              }
            }
            if (s) return;
            for (var l = 0; l < o; l++) {
              var u = t[l], h = void 0;
              this.stateProxy && (h = this.stateProxy(u, t)), h || (h = this.states[u]), h && r.push(h);
            }
            var c = r[o - 1], f = !!(c && c.hoverLayer || i);
            f && this._toggleHoverLayerFlag(true);
            var g = this._mergeStates(r), d = this.stateTransition;
            this.saveCurrentToNormalState(g), this._applyStateObj(t.join(","), g, this._normalState, false, !e && !this.__inHover && d && d.duration > 0, d);
            var A = this._textContent, p = this._textGuide;
            A && A.useStates(t, e, f), p && p.useStates(t, e, f), this._updateAnimationTargets(), this.currentStates = t.slice(), this.markRedraw(), !f && this.__inHover && (this._toggleHoverLayerFlag(false), this.__dirty &= ~jr);
          }
        }, n.prototype.isSilent = function() {
          for (var t = this.silent, e = this.parent; !t && e; ) {
            if (e.silent) {
              t = true;
              break;
            }
            e = e.parent;
          }
          return t;
        }, n.prototype._updateAnimationTargets = function() {
          for (var t = 0; t < this.animators.length; t++) {
            var e = this.animators[t];
            e.targetName && e.changeTarget(this[e.targetName]);
          }
        }, n.prototype.removeState = function(t) {
          var e = $t(this.currentStates, t);
          if (e >= 0) {
            var i = this.currentStates.slice();
            i.splice(e, 1), this.useStates(i);
          }
        }, n.prototype.replaceState = function(t, e, i) {
          var r = this.currentStates.slice(), a = $t(r, t), o = $t(r, e) >= 0;
          a >= 0 ? o ? r.splice(a, 1) : r[a] = e : i && !o && r.push(e), this.useStates(r);
        }, n.prototype.toggleState = function(t, e) {
          e ? this.useState(t, true) : this.removeState(t);
        }, n.prototype._mergeStates = function(t) {
          for (var e = {}, i, r = 0; r < t.length; r++) {
            var a = t[r];
            X(e, a), a.textConfig && (i = i || {}, X(i, a.textConfig));
          }
          return i && (e.textConfig = i), e;
        }, n.prototype._applyStateObj = function(t, e, i, r, a, o) {
          var s = !(e && r);
          e && e.textConfig ? (this.textConfig = X({}, r ? this.textConfig : i.textConfig), X(this.textConfig, e.textConfig)) : s && i.textConfig && (this.textConfig = i.textConfig);
          for (var l = {}, u = false, h = 0; h < dT.length; h++) {
            var c = dT[h], f = a && $1t[c];
            e && e[c] != null ? f ? (u = true, l[c] = e[c]) : this[c] = e[c] : s && i[c] != null && (f ? (u = true, l[c] = i[c]) : this[c] = i[c]);
          }
          if (!a) for (var h = 0; h < this.animators.length; h++) {
            var g = this.animators[h], d = g.targetName;
            g.getLoop() || g.__changeFinalValue(d ? (e || i)[d] : e || i);
          }
          u && this._transitionState(t, l, o);
        }, n.prototype._attachComponent = function(t) {
          if (t.__zr && !t.__hostTarget) {
            if (true) throw new Error("Text element has been added to zrender.");
            return;
          }
          if (t === this) {
            if (true) throw new Error("Recursive component attachment.");
            return;
          }
          var e = this.__zr;
          e && t.addSelfToZr(e), t.__zr = e, t.__hostTarget = this;
        }, n.prototype._detachComponent = function(t) {
          t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__hostTarget = null;
        }, n.prototype.getClipPath = function() {
          return this._clipPath;
        }, n.prototype.setClipPath = function(t) {
          this._clipPath && this._clipPath !== t && this.removeClipPath(), this._attachComponent(t), this._clipPath = t, this.markRedraw();
        }, n.prototype.removeClipPath = function() {
          var t = this._clipPath;
          t && (this._detachComponent(t), this._clipPath = null, this.markRedraw());
        }, n.prototype.getTextContent = function() {
          return this._textContent;
        }, n.prototype.setTextContent = function(t) {
          var e = this._textContent;
          if (e !== t) {
            if (e && e !== t && this.removeTextContent(), t.__zr && !t.__hostTarget) throw new Error("Text element has been added to zrender.");
            t.innerTransformable = new Vs(), this._attachComponent(t), this._textContent = t, this.markRedraw();
          }
        }, n.prototype.setTextConfig = function(t) {
          this.textConfig || (this.textConfig = {}), X(this.textConfig, t), this.markRedraw();
        }, n.prototype.removeTextConfig = function() {
          this.textConfig = null, this.markRedraw();
        }, n.prototype.removeTextContent = function() {
          var t = this._textContent;
          t && (t.innerTransformable = null, this._detachComponent(t), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
        }, n.prototype.getTextGuideLine = function() {
          return this._textGuide;
        }, n.prototype.setTextGuideLine = function(t) {
          this._textGuide && this._textGuide !== t && this.removeTextGuideLine(), this._attachComponent(t), this._textGuide = t, this.markRedraw();
        }, n.prototype.removeTextGuideLine = function() {
          var t = this._textGuide;
          t && (this._detachComponent(t), this._textGuide = null, this.markRedraw());
        }, n.prototype.markRedraw = function() {
          this.__dirty |= jr;
          var t = this.__zr;
          t && (this.__inHover ? t.refreshHover() : t.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
        }, n.prototype.dirty = function() {
          this.markRedraw();
        }, n.prototype._toggleHoverLayerFlag = function(t) {
          this.__inHover = t;
          var e = this._textContent, i = this._textGuide;
          e && (e.__inHover = t), i && (i.__inHover = t);
        }, n.prototype.addSelfToZr = function(t) {
          if (this.__zr !== t) {
            this.__zr = t;
            var e = this.animators;
            if (e) for (var i = 0; i < e.length; i++) t.animation.addAnimator(e[i]);
            this._clipPath && this._clipPath.addSelfToZr(t), this._textContent && this._textContent.addSelfToZr(t), this._textGuide && this._textGuide.addSelfToZr(t);
          }
        }, n.prototype.removeSelfFromZr = function(t) {
          if (this.__zr) {
            this.__zr = null;
            var e = this.animators;
            if (e) for (var i = 0; i < e.length; i++) t.animation.removeAnimator(e[i]);
            this._clipPath && this._clipPath.removeSelfFromZr(t), this._textContent && this._textContent.removeSelfFromZr(t), this._textGuide && this._textGuide.removeSelfFromZr(t);
          }
        }, n.prototype.animate = function(t, e, i) {
          var r = t ? this[t] : this;
          if (!r) {
            Ya('Property "' + t + '" is not existed in element ' + this.id);
            return;
          }
          var a = new eT(r, e, i);
          return t && (a.targetName = t), this.addAnimator(a, t), a;
        }, n.prototype.addAnimator = function(t, e) {
          var i = this.__zr, r = this;
          t.during(function() {
            r.updateDuringAnimation(e);
          }).done(function() {
            var a = r.animators, o = $t(a, t);
            o >= 0 && a.splice(o, 1);
          }), this.animators.push(t), i && i.animation.addAnimator(t), i && i.wakeUp();
        }, n.prototype.updateDuringAnimation = function(t) {
          this.markRedraw();
        }, n.prototype.stopAnimation = function(t, e) {
          for (var i = this.animators, r = i.length, a = [], o = 0; o < r; o++) {
            var s = i[o];
            !t || t === s.scope ? s.stop(e) : a.push(s);
          }
          return this.animators = a, this;
        }, n.prototype.animateTo = function(t, e, i) {
          AT(this, t, e, i);
        }, n.prototype.animateFrom = function(t, e, i) {
          AT(this, t, e, i, true);
        }, n.prototype._transitionState = function(t, e, i, r) {
          for (var a = AT(this, e, i, r), o = 0; o < a.length; o++) a[o].__fromStateTransition = t;
        }, n.prototype.getBoundingRect = function() {
          return null;
        }, n.prototype.getPaintRect = function() {
          return null;
        }, n.initDefaultProps = function() {
          var t = n.prototype;
          t.type = "element", t.name = "", t.ignore = t.silent = t.isGroup = t.draggable = t.dragging = t.ignoreClip = t.__inHover = false, t.__dirty = jr;
          var e = {};
          function i(a, o, s) {
            e[a + o + s] || (e[a + o + s] = true);
          }
          function r(a, o, s, l) {
            Object.defineProperty(t, a, { get: function() {
              if (i(a, s, l), !this[o]) {
                var h = this[o] = [];
                u(this, h);
              }
              return this[o];
            }, set: function(h) {
              i(a, s, l), this[s] = h[0], this[l] = h[1], this[o] = h, u(this, h);
            } });
            function u(h, c) {
              Object.defineProperty(c, 0, { get: function() {
                return h[s];
              }, set: function(f) {
                h[s] = f;
              } }), Object.defineProperty(c, 1, { get: function() {
                return h[l];
              }, set: function(f) {
                h[l] = f;
              } });
            }
          }
          Object.defineProperty && (r("position", "_legacyPos", "x", "y"), r("scale", "_legacyScale", "scaleX", "scaleY"), r("origin", "_legacyOrigin", "originX", "originY"));
        }(), n;
      }();
      kn(A1, ga), kn(A1, Vs);
      function AT(n, t, e, i, r) {
        e = e || {};
        var a = [];
        J5(n, "", n, t, e, i, a, r);
        var o = a.length, s = false, l = e.done, u = e.aborted, h = function() {
          s = true, o--, o <= 0 && (s ? l && l() : u && u());
        }, c = function() {
          o--, o <= 0 && (s ? l && l() : u && u());
        };
        o || l && l(), a.length > 0 && e.during && a[0].during(function(d, A) {
          e.during(A);
        });
        for (var f = 0; f < a.length; f++) {
          var g = a[f];
          h && g.done(h), c && g.aborted(c), e.force && g.duration(e.duration), g.start(e.easing);
        }
        return a;
      }
      function pT(n, t, e) {
        for (var i = 0; i < e; i++) n[i] = t[i];
      }
      function K1t(n) {
        return Li(n[0]);
      }
      function J1t(n, t, e) {
        if (Li(t[e])) if (Li(n[e]) || (n[e] = []), Yi(t[e])) {
          var i = t[e].length;
          n[e].length !== i && (n[e] = new t[e].constructor(i), pT(n[e], t[e], i));
        } else {
          var r = t[e], a = n[e], o = r.length;
          if (K1t(r)) for (var s = r[0].length, l = 0; l < o; l++) a[l] ? pT(a[l], r[l], s) : a[l] = Array.prototype.slice.call(r[l]);
          else pT(a, r, o);
          a.length = r.length;
        }
        else n[e] = t[e];
      }
      function tEt(n, t) {
        return n === t || Li(n) && Li(t) && eEt(n, t);
      }
      function eEt(n, t) {
        var e = n.length;
        if (e !== t.length) return false;
        for (var i = 0; i < e; i++) if (n[i] !== t[i]) return false;
        return true;
      }
      function J5(n, t, e, i, r, a, o, s) {
        for (var l = oe(i), u = r.duration, h = r.delay, c = r.additive, f = r.setToFinal, g = !Et(a), d = n.animators, A = [], p = 0; p < l.length; p++) {
          var v = l[p], y = i[v];
          if (y != null && e[v] != null && (g || a[v])) if (Et(y) && !Li(y) && !O_(y)) {
            if (t) {
              s || (e[v] = y, n.updateDuringAnimation(t));
              continue;
            }
            J5(n, v, e[v], y, r, a && a[v], o, s);
          } else A.push(v);
          else s || (e[v] = y, n.updateDuringAnimation(t), A.push(v));
        }
        var m = A.length;
        if (!c && m) for (var _ = 0; _ < d.length; _++) {
          var I = d[_];
          if (I.targetName === t) {
            var E = I.stopTracks(A);
            if (E) {
              var x = $t(d, I);
              d.splice(x, 1);
            }
          }
        }
        if (r.force || (A = Fe(A, function(b) {
          return !tEt(i[b], e[b]);
        }), m = A.length), m > 0 || r.force && !o.length) {
          var w = void 0, C = void 0, S = void 0;
          if (s) {
            C = {}, f && (w = {});
            for (var _ = 0; _ < m; _++) {
              var v = A[_];
              C[v] = e[v], f ? w[v] = i[v] : e[v] = i[v];
            }
          } else if (f) {
            S = {};
            for (var _ = 0; _ < m; _++) {
              var v = A[_];
              S[v] = Yp(e[v]), J1t(e, i, v);
            }
          }
          var I = new eT(e, false, false, c ? Fe(d, function(T) {
            return T.targetName === t;
          }) : null);
          I.targetName = t, r.scope && (I.scope = r.scope), f && w && I.whenWithKeys(0, w, A), S && I.whenWithKeys(0, S, A), I.whenWithKeys(u == null ? 500 : u, s ? C : i, A).delay(h || 0), n.addAnimator(I, t), o.push(I);
        }
      }
      var Dt = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this) || this;
          return i.isGroup = true, i._children = [], i.attr(e), i;
        }
        return t.prototype.childrenRef = function() {
          return this._children;
        }, t.prototype.children = function() {
          return this._children.slice();
        }, t.prototype.childAt = function(e) {
          return this._children[e];
        }, t.prototype.childOfName = function(e) {
          for (var i = this._children, r = 0; r < i.length; r++) if (i[r].name === e) return i[r];
        }, t.prototype.childCount = function() {
          return this._children.length;
        }, t.prototype.add = function(e) {
          if (e && (e !== this && e.parent !== this && (this._children.push(e), this._doAdd(e)), e.__hostTarget)) throw "This elemenet has been used as an attachment";
          return this;
        }, t.prototype.addBefore = function(e, i) {
          if (e && e !== this && e.parent !== this && i && i.parent === this) {
            var r = this._children, a = r.indexOf(i);
            a >= 0 && (r.splice(a, 0, e), this._doAdd(e));
          }
          return this;
        }, t.prototype.replace = function(e, i) {
          var r = $t(this._children, e);
          return r >= 0 && this.replaceAt(i, r), this;
        }, t.prototype.replaceAt = function(e, i) {
          var r = this._children, a = r[i];
          if (e && e !== this && e.parent !== this && e !== a) {
            r[i] = e, a.parent = null;
            var o = this.__zr;
            o && a.removeSelfFromZr(o), this._doAdd(e);
          }
          return this;
        }, t.prototype._doAdd = function(e) {
          e.parent && e.parent.remove(e), e.parent = this;
          var i = this.__zr;
          i && i !== e.__zr && e.addSelfToZr(i), i && i.refresh();
        }, t.prototype.remove = function(e) {
          var i = this.__zr, r = this._children, a = $t(r, e);
          return a < 0 ? this : (r.splice(a, 1), e.parent = null, i && e.removeSelfFromZr(i), i && i.refresh(), this);
        }, t.prototype.removeAll = function() {
          for (var e = this._children, i = this.__zr, r = 0; r < e.length; r++) {
            var a = e[r];
            i && a.removeSelfFromZr(i), a.parent = null;
          }
          return e.length = 0, this;
        }, t.prototype.eachChild = function(e, i) {
          for (var r = this._children, a = 0; a < r.length; a++) {
            var o = r[a];
            e.call(i, o, a);
          }
          return this;
        }, t.prototype.traverse = function(e, i) {
          for (var r = 0; r < this._children.length; r++) {
            var a = this._children[r], o = e.call(i, a);
            a.isGroup && !o && a.traverse(e, i);
          }
          return this;
        }, t.prototype.addSelfToZr = function(e) {
          n.prototype.addSelfToZr.call(this, e);
          for (var i = 0; i < this._children.length; i++) {
            var r = this._children[i];
            r.addSelfToZr(e);
          }
        }, t.prototype.removeSelfFromZr = function(e) {
          n.prototype.removeSelfFromZr.call(this, e);
          for (var i = 0; i < this._children.length; i++) {
            var r = this._children[i];
            r.removeSelfFromZr(e);
          }
        }, t.prototype.getBoundingRect = function(e) {
          for (var i = new Wt(0, 0, 0, 0), r = e || this._children, a = [], o = null, s = 0; s < r.length; s++) {
            var l = r[s];
            if (!(l.ignore || l.invisible)) {
              var u = l.getBoundingRect(), h = l.getLocalTransform(a);
              h ? (Wt.applyTransform(i, u, h), o = o || i.clone(), o.union(i)) : (o = o || u.clone(), o.union(u));
            }
          }
          return o || i;
        }, t;
      }(A1);
      Dt.prototype.type = "group";
      var Kp = {}, t4 = {};
      function nEt(n) {
        delete t4[n];
      }
      function iEt(n) {
        if (!n) return false;
        if (typeof n == "string") return n1(n, 1) < lT;
        if (n.colorStops) {
          for (var t = n.colorStops, e = 0, i = t.length, r = 0; r < i; r++) e += n1(t[r].color, 1);
          return e /= i, e < lT;
        }
        return false;
      }
      var rEt = function() {
        function n(t, e, i) {
          var r = this;
          this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = true, this._needsRefreshHover = true, this._darkMode = false, i = i || {}, this.dom = e, this.id = t;
          var a = new m1t(), o = i.renderer || "canvas";
          if (Kp[o] || (o = oe(Kp)[0]), !Kp[o]) throw new Error("Renderer '" + o + "' is not imported. Please import it first.");
          i.useDirtyRect = i.useDirtyRect == null ? false : i.useDirtyRect;
          var s = new Kp[o](e, a, i, t), l = i.ssr || s.ssrOnly;
          this.storage = a, this.painter = s;
          var u = !re.node && !re.worker && !l ? new W1t(s.getViewportRoot(), s.root) : null, h = i.useCoarsePointer, c = h == null || h === "auto" ? re.touchEventsSupported : !!h, f = 44, g;
          c && (g = kt(i.pointerSize, f)), this.handler = new f5(a, s, u, s.root, g), this.animation = new G1t({ stage: { update: l ? null : function() {
            return r._flush(true);
          } } }), l || this.animation.start();
        }
        return n.prototype.add = function(t) {
          this._disposed || !t || (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh());
        }, n.prototype.remove = function(t) {
          this._disposed || !t || (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh());
        }, n.prototype.configLayer = function(t, e) {
          this._disposed || (this.painter.configLayer && this.painter.configLayer(t, e), this.refresh());
        }, n.prototype.setBackgroundColor = function(t) {
          this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this.refresh(), this._backgroundColor = t, this._darkMode = iEt(t));
        }, n.prototype.getBackgroundColor = function() {
          return this._backgroundColor;
        }, n.prototype.setDarkMode = function(t) {
          this._darkMode = t;
        }, n.prototype.isDarkMode = function() {
          return this._darkMode;
        }, n.prototype.refreshImmediately = function(t) {
          this._disposed || (t || this.animation.update(true), this._needsRefresh = false, this.painter.refresh(), this._needsRefresh = false);
        }, n.prototype.refresh = function() {
          this._disposed || (this._needsRefresh = true, this.animation.start());
        }, n.prototype.flush = function() {
          this._disposed || this._flush(false);
        }, n.prototype._flush = function(t) {
          var e, i = Mg();
          this._needsRefresh && (e = true, this.refreshImmediately(t)), this._needsRefreshHover && (e = true, this.refreshHoverImmediately());
          var r = Mg();
          e ? (this._stillFrameAccum = 0, this.trigger("rendered", { elapsedTime: r - i })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
        }, n.prototype.setSleepAfterStill = function(t) {
          this._sleepAfterStill = t;
        }, n.prototype.wakeUp = function() {
          this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
        }, n.prototype.refreshHover = function() {
          this._needsRefreshHover = true;
        }, n.prototype.refreshHoverImmediately = function() {
          this._disposed || (this._needsRefreshHover = false, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
        }, n.prototype.resize = function(t) {
          this._disposed || (t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize());
        }, n.prototype.clearAnimation = function() {
          this._disposed || this.animation.clear();
        }, n.prototype.getWidth = function() {
          if (!this._disposed) return this.painter.getWidth();
        }, n.prototype.getHeight = function() {
          if (!this._disposed) return this.painter.getHeight();
        }, n.prototype.setCursorStyle = function(t) {
          this._disposed || this.handler.setCursorStyle(t);
        }, n.prototype.findHover = function(t, e) {
          if (!this._disposed) return this.handler.findHover(t, e);
        }, n.prototype.on = function(t, e, i) {
          return this._disposed || this.handler.on(t, e, i), this;
        }, n.prototype.off = function(t, e) {
          this._disposed || this.handler.off(t, e);
        }, n.prototype.trigger = function(t, e) {
          this._disposed || this.handler.trigger(t, e);
        }, n.prototype.clear = function() {
          if (!this._disposed) {
            for (var t = this.storage.getRoots(), e = 0; e < t.length; e++) t[e] instanceof Dt && t[e].removeSelfFromZr(this);
            this.storage.delAllRoots(), this.painter.clear();
          }
        }, n.prototype.dispose = function() {
          this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = true, nEt(this.id));
        }, n;
      }();
      function e4(n, t) {
        var e = new rEt(KG(), n, t);
        return t4[e.id] = e, e;
      }
      function aEt(n, t) {
        Kp[n] = t;
      }
      var vT;
      function oEt(n) {
        if (typeof vT == "function") return vT(n);
      }
      function sEt(n) {
        vT = n;
      }
      var n4 = 1e-4, i4 = 20;
      function lEt(n) {
        return n.replace(/^\s+|\s+$/g, "");
      }
      function Ne(n, t, e, i) {
        var r = t[0], a = t[1], o = e[0], s = e[1], l = a - r, u = s - o;
        if (l === 0) return u === 0 ? o : (o + s) / 2;
        if (i) if (l > 0) {
          if (n <= r) return o;
          if (n >= a) return s;
        } else {
          if (n >= r) return o;
          if (n <= a) return s;
        }
        else {
          if (n === r) return o;
          if (n === a) return s;
        }
        return (n - r) / l * u + o;
      }
      function st(n, t) {
        switch (n) {
          case "center":
          case "middle":
            n = "50%";
            break;
          case "left":
          case "top":
            n = "0%";
            break;
          case "right":
          case "bottom":
            n = "100%";
            break;
        }
        return ht(n) ? lEt(n).match(/%$/) ? parseFloat(n) / 100 * t : parseFloat(n) : n == null ? NaN : +n;
      }
      function En(n, t, e) {
        return t == null && (t = 10), t = Math.min(Math.max(0, t), i4), n = (+n).toFixed(t), e ? n : +n;
      }
      function va(n) {
        return n.sort(function(t, e) {
          return t - e;
        }), n;
      }
      function jo(n) {
        if (n = +n, isNaN(n)) return 0;
        if (n > 1e-14) {
          for (var t = 1, e = 0; e < 15; e++, t *= 10) if (Math.round(n * t) / t === n) return e;
        }
        return yT(n);
      }
      function yT(n) {
        var t = n.toString().toLowerCase(), e = t.indexOf("e"), i = e > 0 ? +t.slice(e + 1) : 0, r = e > 0 ? e : t.length, a = t.indexOf("."), o = a < 0 ? 0 : r - 1 - a;
        return Math.max(0, o - i);
      }
      function r4(n, t) {
        var e = Math.log, i = Math.LN10, r = Math.floor(e(n[1] - n[0]) / i), a = Math.round(e(Math.abs(t[1] - t[0])) / i), o = Math.min(Math.max(-r + a, 0), 20);
        return isFinite(o) ? o : 20;
      }
      function uEt(n, t) {
        var e = zo(n, function(g, d) {
          return g + (isNaN(d) ? 0 : d);
        }, 0);
        if (e === 0) return [];
        for (var i = Math.pow(10, t), r = K(n, function(g) {
          return (isNaN(g) ? 0 : g) / e * i * 100;
        }), a = i * 100, o = K(r, function(g) {
          return Math.floor(g);
        }), s = zo(o, function(g, d) {
          return g + d;
        }, 0), l = K(r, function(g, d) {
          return g - o[d];
        }); s < a; ) {
          for (var u = Number.NEGATIVE_INFINITY, h = null, c = 0, f = l.length; c < f; ++c) l[c] > u && (u = l[c], h = c);
          ++o[h], l[h] = 0, ++s;
        }
        return K(o, function(g) {
          return g / i;
        });
      }
      function hEt(n, t) {
        var e = Math.max(jo(n), jo(t)), i = n + t;
        return e > i4 ? i : En(i, e);
      }
      var a4 = 9007199254740991;
      function o4(n) {
        var t = Math.PI * 2;
        return (n % t + t) % t;
      }
      function Jp(n) {
        return n > -n4 && n < n4;
      }
      var cEt = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
      function qo(n) {
        if (n instanceof Date) return n;
        if (ht(n)) {
          var t = cEt.exec(n);
          if (!t) return /* @__PURE__ */ new Date(NaN);
          if (t[8]) {
            var e = +t[4] || 0;
            return t[8].toUpperCase() !== "Z" && (e -= +t[8].slice(0, 3)), new Date(Date.UTC(+t[1], +(t[2] || 1) - 1, +t[3] || 1, e, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0));
          } else return new Date(+t[1], +(t[2] || 1) - 1, +t[3] || 1, +t[4] || 0, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0);
        } else if (n == null) return /* @__PURE__ */ new Date(NaN);
        return new Date(Math.round(n));
      }
      function fEt(n) {
        return Math.pow(10, p1(n));
      }
      function p1(n) {
        if (n === 0) return 0;
        var t = Math.floor(Math.log(n) / Math.LN10);
        return n / Math.pow(10, t) >= 10 && t++, t;
      }
      function s4(n, t) {
        var e = p1(n), i = Math.pow(10, e), r = n / i, a;
        return r < 1.5 ? a = 1 : r < 2.5 ? a = 2 : r < 4 ? a = 3 : r < 7 ? a = 5 : a = 10, n = a * i, e >= -20 ? +n.toFixed(e < 0 ? -e : 0) : n;
      }
      function mT(n, t) {
        var e = (n.length - 1) * t + 1, i = Math.floor(e), r = +n[i - 1], a = e - i;
        return a ? r + a * (n[i] - r) : r;
      }
      function l4(n) {
        n.sort(function(l, u) {
          return s(l, u, 0) ? -1 : 1;
        });
        for (var t = -1 / 0, e = 1, i = 0; i < n.length; ) {
          for (var r = n[i].interval, a = n[i].close, o = 0; o < 2; o++) r[o] <= t && (r[o] = t, a[o] = o ? 1 : 1 - e), t = r[o], e = a[o];
          r[0] === r[1] && a[0] * a[1] !== 1 ? n.splice(i, 1) : i++;
        }
        return n;
        function s(l, u, h) {
          return l.interval[h] < u.interval[h] || l.interval[h] === u.interval[h] && (l.close[h] - u.close[h] === (h ? -1 : 1) || !h && s(l, u, 1));
        }
      }
      function js(n) {
        var t = parseFloat(n);
        return t == n && (t !== 0 || !ht(n) || n.indexOf("x") <= 0) ? t : NaN;
      }
      function _T(n) {
        return !isNaN(js(n));
      }
      function u4() {
        return Math.round(Math.random() * 9);
      }
      function h4(n, t) {
        return t === 0 ? n : h4(t, n % t);
      }
      function c4(n, t) {
        return n == null ? t : t == null ? n : n * t / h4(n, t);
      }
      var e4t = "[ECharts] ", f4 = {}, gEt = typeof console != "undefined" && console.warn && console.log;
      function v1(n, t, e) {
        if (gEt && e) {
          if (f4[t]) return;
          f4[t] = true;
        }
      }
      function dEt(n, t) {
        v1("log", n, t);
      }
      function gn(n, t) {
        v1("warn", n, t);
      }
      function Ei(n, t) {
        v1("error", n, t);
      }
      function Ka(n) {
        v1("warn", "DEPRECATED: " + n, true);
      }
      function Qn(n, t, e) {
        Ka((e ? "[" + e + "]" : "") + (n + " is deprecated, use " + t + " instead."));
      }
      function Ir() {
        for (var n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];
        var e = "";
        if (true) {
          var i = function(r) {
            return r === void 0 ? "undefined" : r === 1 / 0 ? "Infinity" : r === -1 / 0 ? "-Infinity" : ph(r) ? "NaN" : r instanceof Date ? "Date(" + r.toISOString() + ")" : yt(r) ? "function () { ... }" : t5(r) ? r + "" : null;
          };
          e = K(n, function(r) {
            if (ht(r)) return r;
            var a = i(r);
            if (a != null) return a;
            if (typeof JSON != "undefined" && JSON.stringify) try {
              return JSON.stringify(r, function(o, s) {
                var l = i(s);
                return l == null ? s : l;
              });
            } catch (o) {
              return "?";
            }
            else return "?";
          }).join(" ");
        }
        return e;
      }
      function be(n) {
        throw new Error(n);
      }
      function g4(n, t, e) {
        return (t - n) * e + n;
      }
      var d4 = "series\0", A4 = "\0_ec_\0";
      function ze(n) {
        return n instanceof Array ? n : n == null ? [] : [n];
      }
      function Th(n, t, e) {
        if (n) {
          n[t] = n[t] || {}, n.emphasis = n.emphasis || {}, n.emphasis[t] = n.emphasis[t] || {};
          for (var i = 0, r = e.length; i < r; i++) {
            var a = e[i];
            !n.emphasis[t].hasOwnProperty(a) && n[t].hasOwnProperty(a) && (n.emphasis[t][a] = n[t][a]);
          }
        }
      }
      var p4 = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
      function Pg(n) {
        return Et(n) && !Z(n) && !(n instanceof Date) ? n.value : n;
      }
      function AEt(n) {
        return Et(n) && !(n instanceof Array);
      }
      function v4(n, t, e) {
        var i = e === "normalMerge", r = e === "replaceMerge", a = e === "replaceAll";
        n = n || [], t = (t || []).slice();
        var o = dt();
        D(t, function(l, u) {
          if (!Et(l)) {
            t[u] = null;
            return;
          }
          l.id != null && !_4(l.id) && m4(l.id), l.name != null && !_4(l.name) && m4(l.name);
        });
        var s = pEt(n, o, e);
        return (i || r) && vEt(s, n, o, t), i && yEt(s, t), i || r ? mEt(s, t, r) : a && _Et(s, t), EEt(s), s;
      }
      function pEt(n, t, e) {
        var i = [];
        if (e === "replaceAll") return i;
        for (var r = 0; r < n.length; r++) {
          var a = n[r];
          a && a.id != null && t.set(a.id, r), i.push({ existing: e === "replaceMerge" || Ng(a) ? null : a, newOption: null, keyInfo: null, brandNew: null });
        }
        return i;
      }
      function vEt(n, t, e, i) {
        D(i, function(r, a) {
          if (!(!r || r.id == null)) {
            var o = tv(r.id), s = e.get(o);
            if (s != null) {
              var l = n[s];
              It(!l.newOption, 'Duplicated option on id "' + o + '".'), l.newOption = r, l.existing = t[s], i[a] = null;
            }
          }
        });
      }
      function yEt(n, t) {
        D(t, function(e, i) {
          if (!(!e || e.name == null)) for (var r = 0; r < n.length; r++) {
            var a = n[r].existing;
            if (!n[r].newOption && a && (a.id == null || e.id == null) && !Ng(e) && !Ng(a) && y4("name", a, e)) {
              n[r].newOption = e, t[i] = null;
              return;
            }
          }
        });
      }
      function mEt(n, t, e) {
        D(t, function(i) {
          if (i) {
            for (var r, a = 0; (r = n[a]) && (r.newOption || Ng(r.existing) || r.existing && i.id != null && !y4("id", i, r.existing)); ) a++;
            r ? (r.newOption = i, r.brandNew = e) : n.push({ newOption: i, brandNew: e, existing: null, keyInfo: null }), a++;
          }
        });
      }
      function _Et(n, t) {
        D(t, function(e) {
          n.push({ newOption: e, brandNew: true, existing: null, keyInfo: null });
        });
      }
      function EEt(n) {
        var t = dt();
        D(n, function(e) {
          var i = e.existing;
          i && t.set(i.id, e);
        }), D(n, function(e) {
          var i = e.newOption;
          It(!i || i.id == null || !t.get(i.id) || t.get(i.id) === e, "id duplicates: " + (i && i.id)), i && i.id != null && t.set(i.id, e), !e.keyInfo && (e.keyInfo = {});
        }), D(n, function(e, i) {
          var r = e.existing, a = e.newOption, o = e.keyInfo;
          if (Et(a)) {
            if (o.name = a.name != null ? tv(a.name) : r ? r.name : d4 + i, r) o.id = tv(r.id);
            else if (a.id != null) o.id = tv(a.id);
            else {
              var s = 0;
              do
                o.id = "\0" + o.name + "\0" + s++;
              while (t.get(o.id));
            }
            t.set(o.id, e);
          }
        });
      }
      function y4(n, t, e) {
        var i = Hn(t[n], null), r = Hn(e[n], null);
        return i != null && r != null && i === r;
      }
      function tv(n) {
        if (n == null) throw new Error();
        return Hn(n, "");
      }
      function Hn(n, t) {
        return n == null ? t : ht(n) ? n : ye(n) || k_(n) ? n + "" : t;
      }
      function m4(n) {
        gn("`" + n + "` is invalid id or name. Must be a string or number.");
      }
      function _4(n) {
        return k_(n) || _T(n);
      }
      function ET(n) {
        var t = n.name;
        return !!(t && t.indexOf(d4));
      }
      function Ng(n) {
        return n && n.id != null && tv(n.id).indexOf(A4) === 0;
      }
      function IEt(n) {
        return A4 + n;
      }
      function xEt(n, t, e) {
        D(n, function(i) {
          var r = i.newOption;
          Et(r) && (i.keyInfo.mainType = t, i.keyInfo.subType = wEt(t, r, i.existing, e));
        });
      }
      function wEt(n, t, e, i) {
        var r = t.type ? t.type : e ? e.subType : i.determineSubType(n, t);
        return r;
      }
      function CEt(n, t) {
        var e = {}, i = {};
        return r(n || [], e), r(t || [], i, e), [a(e), a(i)];
        function r(o, s, l) {
          for (var u = 0, h = o.length; u < h; u++) {
            var c = Hn(o[u].seriesId, null);
            if (c == null) return;
            for (var f = ze(o[u].dataIndex), g = l && l[c], d = 0, A = f.length; d < A; d++) {
              var p = f[d];
              g && g[p] ? g[p] = null : (s[c] || (s[c] = {}))[p] = 1;
            }
          }
        }
        function a(o, s) {
          var l = [];
          for (var u in o) if (o.hasOwnProperty(u) && o[u] != null) if (s) l.push(+u);
          else {
            var h = a(o[u], true);
            h.length && l.push({ seriesId: u, dataIndex: h });
          }
          return l;
        }
      }
      function Bh(n, t) {
        if (t.dataIndexInside != null) return t.dataIndexInside;
        if (t.dataIndex != null) return Z(t.dataIndex) ? K(t.dataIndex, function(e) {
          return n.indexOfRawIndex(e);
        }) : n.indexOfRawIndex(t.dataIndex);
        if (t.name != null) return Z(t.name) ? K(t.name, function(e) {
          return n.indexOfName(e);
        }) : n.indexOfName(t.name);
      }
      function ce() {
        var n = "__ec_inner_" + SEt++;
        return function(t) {
          return t[n] || (t[n] = {});
        };
      }
      var SEt = u4();
      function ev(n, t, e) {
        var i = IT(t, e), r = i.mainTypeSpecified, a = i.queryOptionMap, o = i.others, s = o, l = e ? e.defaultMainType : null;
        return !r && l && a.set(l, {}), a.each(function(u, h) {
          var c = nv(n, h, u, { useDefault: l === h, enableAll: e && e.enableAll != null ? e.enableAll : true, enableNone: e && e.enableNone != null ? e.enableNone : true });
          s[h + "Models"] = c.models, s[h + "Model"] = c.models[0];
        }), s;
      }
      function IT(n, t) {
        var e;
        if (ht(n)) {
          var i = {};
          i[n + "Index"] = 0, e = i;
        } else e = n;
        var r = dt(), a = {}, o = false;
        return D(e, function(s, l) {
          if (l === "dataIndex" || l === "dataIndexInside") {
            a[l] = s;
            return;
          }
          var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], h = u[1], c = (u[2] || "").toLowerCase();
          if (!(!h || !c || t && t.includeMainTypes && $t(t.includeMainTypes, h) < 0)) {
            o = o || !!h;
            var f = r.get(h) || r.set(h, {});
            f[c] = s;
          }
        }), { mainTypeSpecified: o, queryOptionMap: r, others: a };
      }
      var zn = { useDefault: true, enableAll: false, enableNone: false }, bEt = { useDefault: false, enableAll: true, enableNone: true };
      function nv(n, t, e, i) {
        i = i || zn;
        var r = e.index, a = e.id, o = e.name, s = { models: null, specified: r != null || a != null || o != null };
        if (!s.specified) {
          var l = void 0;
          return s.models = i.useDefault && (l = n.getComponent(t)) ? [l] : [], s;
        }
        return r === "none" || r === false ? (It(i.enableNone, '`"none"` or `false` is not a valid value on index option.'), s.models = [], s) : (r === "all" && (It(i.enableAll, '`"all"` is not a valid value on index option.'), r = a = o = null), s.models = n.queryComponents({ mainType: t, index: r, id: a, name: o }), s);
      }
      function E4(n, t, e) {
        n.setAttribute ? n.setAttribute(t, e) : n[t] = e;
      }
      function TEt(n, t) {
        return n.getAttribute ? n.getAttribute(t) : n[t];
      }
      function BEt(n) {
        return n === "auto" ? re.domSupported ? "html" : "richText" : n || "html";
      }
      function xT(n, t) {
        var e = dt(), i = [];
        return D(n, function(r) {
          var a = t(r);
          (e.get(a) || (i.push(a), e.set(a, []))).push(r);
        }), { keys: i, buckets: e };
      }
      function I4(n, t, e, i, r) {
        var a = t == null || t === "auto";
        if (i == null) return i;
        if (ye(i)) {
          var o = g4(e || 0, i, r);
          return En(o, a ? Math.max(jo(e || 0), jo(i)) : t);
        } else {
          if (ht(i)) return r < 1 ? e : i;
          for (var s = [], l = e, u = i, h = Math.max(l ? l.length : 0, u.length), c = 0; c < h; ++c) {
            var f = n.getDimensionInfo(c);
            if (f && f.type === "ordinal") s[c] = (r < 1 && l ? l : u)[c];
            else {
              var g = l && l[c] ? l[c] : 0, d = u[c], o = g4(g, d, r);
              s[c] = En(o, a ? Math.max(jo(g), jo(d)) : t);
            }
          }
          return s;
        }
      }
      var MEt = ".", Mh = "___EC__COMPONENT__CONTAINER___", x4 = "___EC__EXTENDED_CLASS___";
      function Ho(n) {
        var t = { main: "", sub: "" };
        if (n) {
          var e = n.split(MEt);
          t.main = e[0] || "", t.sub = e[1] || "";
        }
        return t;
      }
      function DEt(n) {
        It(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(n), 'componentType "' + n + '" illegal');
      }
      function REt(n) {
        return !!(n && n[x4]);
      }
      function wT(n, t) {
        n.$constructor = n, n.extend = function(e) {
          D(t, function(a) {
            e[a];
          });
          var i = this, r;
          return LEt(i) ? r = function(a) {
            V(o, a);
            function o() {
              return a.apply(this, arguments) || this;
            }
            return o;
          }(i) : (r = function() {
            (e.$constructor || i).apply(this, arguments);
          }, G_t(r, this)), X(r.prototype, e), r[x4] = true, r.extend = this.extend, r.superCall = FEt, r.superApply = kEt, r.superClass = i, r;
        };
      }
      function LEt(n) {
        return yt(n) && /^class\s/.test(Function.prototype.toString.call(n));
      }
      function w4(n, t) {
        n.extend = t.extend;
      }
      var PEt = Math.round(Math.random() * 10);
      function NEt(n) {
        var t = ["__\0is_clz", PEt++].join("_");
        n.prototype[t] = true, It(!n.isInstance, 'The method "is" can not be defined.'), n.isInstance = function(e) {
          return !!(e && e[t]);
        };
      }
      function FEt(n, t) {
        for (var e = [], i = 2; i < arguments.length; i++) e[i - 2] = arguments[i];
        return this.superClass.prototype[t].apply(n, e);
      }
      function kEt(n, t, e) {
        return this.superClass.prototype[t].apply(n, e);
      }
      function y1(n) {
        var t = {};
        n.registerClass = function(i) {
          var r = i.type || i.prototype.type;
          if (r) {
            DEt(r), i.prototype.type = r;
            var a = Ho(r);
            if (!a.sub) t[a.main], t[a.main] = i;
            else if (a.sub !== Mh) {
              var o = e(a);
              o[a.sub] = i;
            }
          }
          return i;
        }, n.getClass = function(i, r, a) {
          var o = t[i];
          if (o && o[Mh] && (o = r ? o[r] : null), a && !o) throw new Error(r ? "Component " + i + "." + (r || "") + " is used but not imported." : i + ".type should be specified.");
          return o;
        }, n.getClassesByMainType = function(i) {
          var r = Ho(i), a = [], o = t[r.main];
          return o && o[Mh] ? D(o, function(s, l) {
            l !== Mh && a.push(s);
          }) : a.push(o), a;
        }, n.hasClass = function(i) {
          var r = Ho(i);
          return !!t[r.main];
        }, n.getAllClassMainTypes = function() {
          var i = [];
          return D(t, function(r, a) {
            i.push(a);
          }), i;
        }, n.hasSubTypes = function(i) {
          var r = Ho(i), a = t[r.main];
          return a && a[Mh];
        };
        function e(i) {
          var r = t[i.main];
          return (!r || !r[Mh]) && (r = t[i.main] = {}, r[Mh] = true), r;
        }
      }
      function Dh(n, t) {
        for (var e = 0; e < n.length; e++) n[e][1] || (n[e][1] = n[e][0]);
        return t = t || false, function(i, r, a) {
          for (var o = {}, s = 0; s < n.length; s++) {
            var l = n[s][1];
            if (!(r && $t(r, l) >= 0 || a && $t(a, l) < 0)) {
              var u = i.getShallow(l, t);
              u != null && (o[n[s][0]] = u);
            }
          }
          return o;
        };
      }
      var OEt = [["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["opacity"], ["shadowColor"]], QEt = Dh(OEt), zEt = function() {
        function n() {
        }
        return n.prototype.getAreaStyle = function(t, e) {
          return QEt(this, t, e);
        }, n;
      }(), CT = new Vp(50);
      function GEt(n) {
        if (typeof n == "string") {
          var t = CT.get(n);
          return t && t.image;
        } else return n;
      }
      function ST(n, t, e, i, r) {
        if (n) if (typeof n == "string") {
          if (t && t.__zrImageSrc === n || !e) return t;
          var a = CT.get(n), o = { hostEl: e, cb: i, cbPayload: r };
          return a ? (t = a.image, !m1(t) && a.pending.push(o)) : (t = Xl.loadImage(n, C4, C4), t.__zrImageSrc = n, CT.put(n, t.__cachedImgObj = { image: t, pending: [o] })), t;
        } else return n;
        else return t;
      }
      function C4() {
        var n = this.__cachedImgObj;
        this.onload = this.onerror = this.__cachedImgObj = null;
        for (var t = 0; t < n.pending.length; t++) {
          var e = n.pending[t], i = e.cb;
          i && i(this, e.cbPayload), e.hostEl.dirty();
        }
        n.pending.length = 0;
      }
      function m1(n) {
        return n && n.width && n.height;
      }
      var bT = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
      function UEt(n, t, e, i, r) {
        if (!t) return "";
        var a = (n + "").split(`
`);
        r = S4(t, e, i, r);
        for (var o = 0, s = a.length; o < s; o++) a[o] = b4(a[o], r);
        return a.join(`
`);
      }
      function S4(n, t, e, i) {
        i = i || {};
        var r = X({}, i);
        r.font = t, e = kt(e, "..."), r.maxIterations = kt(i.maxIterations, 2);
        var a = r.minChar = kt(i.minChar, 0);
        r.cnCharWidth = Hr("", t);
        var o = r.ascCharWidth = Hr("a", t);
        r.placeholder = kt(i.placeholder, "");
        for (var s = n = Math.max(0, n - 1), l = 0; l < a && s >= o; l++) s -= o;
        var u = Hr(e, t);
        return u > s && (e = "", u = 0), s = n - u, r.ellipsis = e, r.ellipsisWidth = u, r.contentWidth = s, r.containerWidth = n, r;
      }
      function b4(n, t) {
        var e = t.containerWidth, i = t.font, r = t.contentWidth;
        if (!e) return "";
        var a = Hr(n, i);
        if (a <= e) return n;
        for (var o = 0; ; o++) {
          if (a <= r || o >= t.maxIterations) {
            n += t.ellipsis;
            break;
          }
          var s = o === 0 ? VEt(n, r, t.ascCharWidth, t.cnCharWidth) : a > 0 ? Math.floor(n.length * r / a) : 0;
          n = n.substr(0, s), a = Hr(n, i);
        }
        return n === "" && (n = t.placeholder), n;
      }
      function VEt(n, t, e, i) {
        for (var r = 0, a = 0, o = n.length; a < o && r < t; a++) {
          var s = n.charCodeAt(a);
          r += 0 <= s && s <= 127 ? e : i;
        }
        return a;
      }
      function jEt(n, t) {
        n != null && (n += "");
        var e = t.overflow, i = t.padding, r = t.font, a = e === "truncate", o = g1(r), s = kt(t.lineHeight, o), l = !!t.backgroundColor, u = t.lineOverflow === "truncate", h = t.width, c;
        h != null && (e === "break" || e === "breakAll") ? c = n ? B4(n, t.font, h, e === "breakAll", 0).lines : [] : c = n ? n.split(`
`) : [];
        var f = c.length * s, g = kt(t.height, f);
        if (f > g && u) {
          var d = Math.floor(g / s);
          c = c.slice(0, d);
        }
        if (n && a && h != null) for (var A = S4(h, r, t.ellipsis, { minChar: t.truncateMinChar, placeholder: t.placeholder }), p = 0; p < c.length; p++) c[p] = b4(c[p], A);
        for (var v = g, y = 0, p = 0; p < c.length; p++) y = Math.max(Hr(c[p], r), y);
        h == null && (h = y);
        var m = y;
        return i && (v += i[0] + i[2], m += i[1] + i[3], h += i[1] + i[3]), l && (m = h), { lines: c, height: g, outerWidth: m, outerHeight: v, lineHeight: s, calculatedLineHeight: o, contentWidth: y, contentHeight: f, width: h };
      }
      var qEt = /* @__PURE__ */ function() {
        function n() {
        }
        return n;
      }(), T4 = /* @__PURE__ */ function() {
        function n(t) {
          this.tokens = [], t && (this.tokens = t);
        }
        return n;
      }(), HEt = /* @__PURE__ */ function() {
        function n() {
          this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [];
        }
        return n;
      }();
      function YEt(n, t) {
        var e = new HEt();
        if (n != null && (n += ""), !n) return e;
        for (var i = t.width, r = t.height, a = t.overflow, o = (a === "break" || a === "breakAll") && i != null ? { width: i, accumWidth: 0, breakAll: a === "breakAll" } : null, s = bT.lastIndex = 0, l; (l = bT.exec(n)) != null; ) {
          var u = l.index;
          u > s && TT(e, n.substring(s, u), t, o), TT(e, l[2], t, o, l[1]), s = bT.lastIndex;
        }
        s < n.length && TT(e, n.substring(s, n.length), t, o);
        var h = [], c = 0, f = 0, g = t.padding, d = a === "truncate", A = t.lineOverflow === "truncate";
        function p(F, k, O) {
          F.width = k, F.lineHeight = O, c += O, f = Math.max(f, k);
        }
        t: for (var v = 0; v < e.lines.length; v++) {
          for (var y = e.lines[v], m = 0, _ = 0, I = 0; I < y.tokens.length; I++) {
            var E = y.tokens[I], x = E.styleName && t.rich[E.styleName] || {}, w = E.textPadding = x.padding, C = w ? w[1] + w[3] : 0, S = E.font = x.font || t.font;
            E.contentHeight = g1(S);
            var b = kt(x.height, E.contentHeight);
            if (E.innerHeight = b, w && (b += w[0] + w[2]), E.height = b, E.lineHeight = fa(x.lineHeight, t.lineHeight, b), E.align = x && x.align || t.align, E.verticalAlign = x && x.verticalAlign || "middle", A && r != null && c + E.lineHeight > r) {
              I > 0 ? (y.tokens = y.tokens.slice(0, I), p(y, _, m), e.lines = e.lines.slice(0, v + 1)) : e.lines = e.lines.slice(0, v);
              break t;
            }
            var T = x.width, B = T == null || T === "auto";
            if (typeof T == "string" && T.charAt(T.length - 1) === "%") E.percentWidth = T, h.push(E), E.contentWidth = Hr(E.text, S);
            else {
              if (B) {
                var R = x.backgroundColor, M = R && R.image;
                M && (M = GEt(M), m1(M) && (E.width = Math.max(E.width, M.width * b / M.height)));
              }
              var L = d && i != null ? i - _ : null;
              L != null && L < E.width ? !B || L < C ? (E.text = "", E.width = E.contentWidth = 0) : (E.text = UEt(E.text, L - C, S, t.ellipsis, { minChar: t.truncateMinChar }), E.width = E.contentWidth = Hr(E.text, S)) : E.contentWidth = Hr(E.text, S);
            }
            E.width += C, _ += E.width, x && (m = Math.max(m, E.lineHeight));
          }
          p(y, _, m);
        }
        e.outerWidth = e.width = kt(i, f), e.outerHeight = e.height = kt(r, c), e.contentHeight = c, e.contentWidth = f, g && (e.outerWidth += g[1] + g[3], e.outerHeight += g[0] + g[2]);
        for (var v = 0; v < h.length; v++) {
          var E = h[v], N = E.percentWidth;
          E.width = parseInt(N, 10) / 100 * e.width;
        }
        return e;
      }
      function TT(n, t, e, i, r) {
        var a = t === "", o = r && e.rich[r] || {}, s = n.lines, l = o.font || e.font, u = false, h, c;
        if (i) {
          var f = o.padding, g = f ? f[1] + f[3] : 0;
          if (o.width != null && o.width !== "auto") {
            var d = Za(o.width, i.width) + g;
            s.length > 0 && d + i.accumWidth > i.width && (h = t.split(`
`), u = true), i.accumWidth = d;
          } else {
            var A = B4(t, l, i.width, i.breakAll, i.accumWidth);
            i.accumWidth = A.accumWidth + g, c = A.linesWidths, h = A.lines;
          }
        } else h = t.split(`
`);
        for (var p = 0; p < h.length; p++) {
          var v = h[p], y = new qEt();
          if (y.styleName = r, y.text = v, y.isLineHolder = !v && !a, typeof o.width == "number" ? y.width = o.width : y.width = c ? c[p] : Hr(v, l), !p && !u) {
            var m = (s[s.length - 1] || (s[0] = new T4())).tokens, _ = m.length;
            _ === 1 && m[0].isLineHolder ? m[0] = y : (v || !_ || a) && m.push(y);
          } else s.push(new T4([y]));
        }
      }
      function WEt(n) {
        var t = n.charCodeAt(0);
        return t >= 32 && t <= 591 || t >= 880 && t <= 4351 || t >= 4608 && t <= 5119 || t >= 7680 && t <= 8303;
      }
      var XEt = zo(",&?/;] ".split(""), function(n, t) {
        return n[t] = true, n;
      }, {});
      function $Et(n) {
        return WEt(n) ? !!XEt[n] : true;
      }
      function B4(n, t, e, i, r) {
        for (var a = [], o = [], s = "", l = "", u = 0, h = 0, c = 0; c < n.length; c++) {
          var f = n.charAt(c);
          if (f === `
`) {
            l && (s += l, h += u), a.push(s), o.push(h), s = "", l = "", u = 0, h = 0;
            continue;
          }
          var g = Hr(f, t), d = i ? false : !$Et(f);
          if (a.length ? h + g > e : r + h + g > e) {
            h ? (s || l) && (d ? (s || (s = l, l = "", u = 0, h = u), a.push(s), o.push(h - u), l += f, u += g, s = "", h = u) : (l && (s += l, l = "", u = 0), a.push(s), o.push(h), s = f, h = g)) : d ? (a.push(l), o.push(u), l = f, u = g) : (a.push(f), o.push(g));
            continue;
          }
          h += g, d ? (l += f, u += g) : (l && (s += l, l = "", u = 0), s += f);
        }
        return !a.length && !s && (s = n, l = "", u = 0), l && (s += l), s && (a.push(s), o.push(h)), a.length === 1 && (h += r), { accumWidth: h, lines: a, linesWidths: o };
      }
      var BT = "__zr_style_" + Math.round(Math.random() * 10), Rh = { shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, shadowColor: "#000", opacity: 1, blend: "source-over" }, _1 = { style: { shadowBlur: true, shadowOffsetX: true, shadowOffsetY: true, shadowColor: true, opacity: true } };
      Rh[BT] = true;
      var M4 = ["z", "z2", "invisible"], ZEt = ["invisible"], ya = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype._init = function(e) {
          for (var i = oe(e), r = 0; r < i.length; r++) {
            var a = i[r];
            a === "style" ? this.useStyle(e[a]) : n.prototype.attrKV.call(this, a, e[a]);
          }
          this.style || this.useStyle({});
        }, t.prototype.beforeBrush = function() {
        }, t.prototype.afterBrush = function() {
        }, t.prototype.innerBeforeBrush = function() {
        }, t.prototype.innerAfterBrush = function() {
        }, t.prototype.shouldBePainted = function(e, i, r, a) {
          var o = this.transform;
          if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && KEt(this, e, i) || o && !o[0] && !o[3]) return false;
          if (r && this.__clipPaths) {
            for (var s = 0; s < this.__clipPaths.length; ++s) if (this.__clipPaths[s].isZeroArea()) return false;
          }
          if (a && this.parent) for (var l = this.parent; l; ) {
            if (l.ignore) return false;
            l = l.parent;
          }
          return true;
        }, t.prototype.contain = function(e, i) {
          return this.rectContain(e, i);
        }, t.prototype.traverse = function(e, i) {
          e.call(i, this);
        }, t.prototype.rectContain = function(e, i) {
          var r = this.transformCoordToLocal(e, i), a = this.getBoundingRect();
          return a.contain(r[0], r[1]);
        }, t.prototype.getPaintRect = function() {
          var e = this._paintRect;
          if (!this._paintRect || this.__dirty) {
            var i = this.transform, r = this.getBoundingRect(), a = this.style, o = a.shadowBlur || 0, s = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
            e = this._paintRect || (this._paintRect = new Wt(0, 0, 0, 0)), i ? Wt.applyTransform(e, r, i) : e.copy(r), (o || s || l) && (e.width += o * 2 + Math.abs(s), e.height += o * 2 + Math.abs(l), e.x = Math.min(e.x, e.x + s - o), e.y = Math.min(e.y, e.y + l - o));
            var u = this.dirtyRectTolerance;
            e.isZero() || (e.x = Math.floor(e.x - u), e.y = Math.floor(e.y - u), e.width = Math.ceil(e.width + 1 + u * 2), e.height = Math.ceil(e.height + 1 + u * 2));
          }
          return e;
        }, t.prototype.setPrevPaintRect = function(e) {
          e ? (this._prevPaintRect = this._prevPaintRect || new Wt(0, 0, 0, 0), this._prevPaintRect.copy(e)) : this._prevPaintRect = null;
        }, t.prototype.getPrevPaintRect = function() {
          return this._prevPaintRect;
        }, t.prototype.animateStyle = function(e) {
          return this.animate("style", e);
        }, t.prototype.updateDuringAnimation = function(e) {
          e === "style" ? this.dirtyStyle() : this.markRedraw();
        }, t.prototype.attrKV = function(e, i) {
          e !== "style" ? n.prototype.attrKV.call(this, e, i) : this.style ? this.setStyle(i) : this.useStyle(i);
        }, t.prototype.setStyle = function(e, i) {
          return typeof e == "string" ? this.style[e] = i : X(this.style, e), this.dirtyStyle(), this;
        }, t.prototype.dirtyStyle = function(e) {
          e || this.markRedraw(), this.__dirty |= zp, this._rect && (this._rect = null);
        }, t.prototype.dirty = function() {
          this.dirtyStyle();
        }, t.prototype.styleChanged = function() {
          return !!(this.__dirty & zp);
        }, t.prototype.styleUpdated = function() {
          this.__dirty &= ~zp;
        }, t.prototype.createStyle = function(e) {
          return G_(Rh, e);
        }, t.prototype.useStyle = function(e) {
          e[BT] || (e = this.createStyle(e)), this.__inHover ? this.__hoverStyle = e : this.style = e, this.dirtyStyle();
        }, t.prototype.isStyleObject = function(e) {
          return e[BT];
        }, t.prototype._innerSaveToNormal = function(e) {
          n.prototype._innerSaveToNormal.call(this, e);
          var i = this._normalState;
          e.style && !i.style && (i.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(e, i, M4);
        }, t.prototype._applyStateObj = function(e, i, r, a, o, s) {
          n.prototype._applyStateObj.call(this, e, i, r, a, o, s);
          var l = !(i && a), u;
          if (i && i.style ? o ? a ? u = i.style : (u = this._mergeStyle(this.createStyle(), r.style), this._mergeStyle(u, i.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : r.style), this._mergeStyle(u, i.style)) : l && (u = r.style), u) if (o) {
            var h = this.style;
            if (this.style = this.createStyle(l ? {} : h), l) for (var c = oe(h), f = 0; f < c.length; f++) {
              var g = c[f];
              g in u && (u[g] = u[g], this.style[g] = h[g]);
            }
            for (var d = oe(u), f = 0; f < d.length; f++) {
              var g = d[f];
              this.style[g] = this.style[g];
            }
            this._transitionState(e, { style: u }, s, this.getAnimationStyleProps());
          } else this.useStyle(u);
          for (var A = this.__inHover ? ZEt : M4, f = 0; f < A.length; f++) {
            var g = A[f];
            i && i[g] != null ? this[g] = i[g] : l && r[g] != null && (this[g] = r[g]);
          }
        }, t.prototype._mergeStates = function(e) {
          for (var i = n.prototype._mergeStates.call(this, e), r, a = 0; a < e.length; a++) {
            var o = e[a];
            o.style && (r = r || {}, this._mergeStyle(r, o.style));
          }
          return r && (i.style = r), i;
        }, t.prototype._mergeStyle = function(e, i) {
          return X(e, i), e;
        }, t.prototype.getAnimationStyleProps = function() {
          return _1;
        }, t.initDefaultProps = function() {
          var e = t.prototype;
          e.type = "displayable", e.invisible = false, e.z = 0, e.z2 = 0, e.zlevel = 0, e.culling = false, e.cursor = "pointer", e.rectHover = false, e.incremental = false, e._rect = null, e.dirtyRectTolerance = 0, e.__dirty = jr | zp;
        }(), t;
      }(A1), MT = new Wt(0, 0, 0, 0), DT = new Wt(0, 0, 0, 0);
      function KEt(n, t, e) {
        return MT.copy(n.getBoundingRect()), n.transform && MT.applyTransform(n.transform), DT.width = t, DT.height = e, !MT.intersect(DT);
      }
      var xr = Math.min, wr = Math.max, RT = Math.sin, LT = Math.cos, Lh = Math.PI * 2, E1 = vh(), I1 = vh(), x1 = vh();
      function w1(n, t, e) {
        if (n.length !== 0) {
          for (var i = n[0], r = i[0], a = i[0], o = i[1], s = i[1], l = 1; l < n.length; l++) i = n[l], r = xr(r, i[0]), a = wr(a, i[0]), o = xr(o, i[1]), s = wr(s, i[1]);
          t[0] = r, t[1] = o, e[0] = a, e[1] = s;
        }
      }
      function D4(n, t, e, i, r, a) {
        r[0] = xr(n, e), r[1] = xr(t, i), a[0] = wr(n, e), a[1] = wr(t, i);
      }
      var R4 = [], L4 = [];
      function JEt(n, t, e, i, r, a, o, s, l, u) {
        var h = w5, c = Zn, f = h(n, e, r, o, R4);
        l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
        for (var g = 0; g < f; g++) {
          var d = c(n, e, r, o, R4[g]);
          l[0] = xr(d, l[0]), u[0] = wr(d, u[0]);
        }
        f = h(t, i, a, s, L4);
        for (var g = 0; g < f; g++) {
          var A = c(t, i, a, s, L4[g]);
          l[1] = xr(A, l[1]), u[1] = wr(A, u[1]);
        }
        l[0] = xr(n, l[0]), u[0] = wr(n, u[0]), l[0] = xr(o, l[0]), u[0] = wr(o, u[0]), l[1] = xr(t, l[1]), u[1] = wr(t, u[1]), l[1] = xr(s, l[1]), u[1] = wr(s, u[1]);
      }
      function tIt(n, t, e, i, r, a, o, s) {
        var l = S5, u = fi, h = wr(xr(l(n, e, r), 1), 0), c = wr(xr(l(t, i, a), 1), 0), f = u(n, e, r, h), g = u(t, i, a, c);
        o[0] = xr(n, r, f), o[1] = xr(t, a, g), s[0] = wr(n, r, f), s[1] = wr(t, a, g);
      }
      function eIt(n, t, e, i, r, a, o, s, l) {
        var u = Zl, h = Kl, c = Math.abs(r - a);
        if (c % Lh < 1e-4 && c > 1e-4) {
          s[0] = n - e, s[1] = t - i, l[0] = n + e, l[1] = t + i;
          return;
        }
        if (E1[0] = LT(r) * e + n, E1[1] = RT(r) * i + t, I1[0] = LT(a) * e + n, I1[1] = RT(a) * i + t, u(s, E1, I1), h(l, E1, I1), r = r % Lh, r < 0 && (r = r + Lh), a = a % Lh, a < 0 && (a = a + Lh), r > a && !o ? a += Lh : r < a && o && (r += Lh), o) {
          var f = a;
          a = r, r = f;
        }
        for (var g = 0; g < a; g += Math.PI / 2) g > r && (x1[0] = LT(g) * e + n, x1[1] = RT(g) * i + t, u(s, x1, s), h(l, x1, l));
      }
      var $e = { M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7 }, Ph = [], Nh = [], Yo = [], ru = [], Wo = [], Xo = [], PT = Math.min, NT = Math.max, Fh = Math.cos, kh = Math.sin, qs = Math.abs, FT = Math.PI, au = FT * 2, kT = typeof Float32Array != "undefined", iv = [];
      function OT(n) {
        var t = Math.round(n / FT * 1e8) / 1e8;
        return t % 2 * FT;
      }
      function QT(n, t) {
        var e = OT(n[0]);
        e < 0 && (e += au);
        var i = e - n[0], r = n[1];
        r += i, !t && r - e >= au ? r = e + au : t && e - r >= au ? r = e - au : !t && e > r ? r = e + (au - OT(e - r)) : t && e < r && (r = e - (au - OT(r - e))), n[0] = e, n[1] = r;
      }
      var $o = function() {
        function n(t) {
          this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, t && (this._saveData = false), this._saveData && (this.data = []);
        }
        return n.prototype.increaseVersion = function() {
          this._version++;
        }, n.prototype.getVersion = function() {
          return this._version;
        }, n.prototype.setScale = function(t, e, i) {
          i = i || 0, i > 0 && (this._ux = qs(i / f1 / t) || 0, this._uy = qs(i / f1 / e) || 0);
        }, n.prototype.setDPR = function(t) {
          this.dpr = t;
        }, n.prototype.setContext = function(t) {
          this._ctx = t;
        }, n.prototype.getContext = function() {
          return this._ctx;
        }, n.prototype.beginPath = function() {
          return this._ctx && this._ctx.beginPath(), this.reset(), this;
        }, n.prototype.reset = function() {
          this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
        }, n.prototype.moveTo = function(t, e) {
          return this._drawPendingPt(), this.addData($e.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this;
        }, n.prototype.lineTo = function(t, e) {
          var i = qs(t - this._xi), r = qs(e - this._yi), a = i > this._ux || r > this._uy;
          if (this.addData($e.L, t, e), this._ctx && a && this._ctx.lineTo(t, e), a) this._xi = t, this._yi = e, this._pendingPtDist = 0;
          else {
            var o = i * i + r * r;
            o > this._pendingPtDist && (this._pendingPtX = t, this._pendingPtY = e, this._pendingPtDist = o);
          }
          return this;
        }, n.prototype.bezierCurveTo = function(t, e, i, r, a, o) {
          return this._drawPendingPt(), this.addData($e.C, t, e, i, r, a, o), this._ctx && this._ctx.bezierCurveTo(t, e, i, r, a, o), this._xi = a, this._yi = o, this;
        }, n.prototype.quadraticCurveTo = function(t, e, i, r) {
          return this._drawPendingPt(), this.addData($e.Q, t, e, i, r), this._ctx && this._ctx.quadraticCurveTo(t, e, i, r), this._xi = i, this._yi = r, this;
        }, n.prototype.arc = function(t, e, i, r, a, o) {
          this._drawPendingPt(), iv[0] = r, iv[1] = a, QT(iv, o), r = iv[0], a = iv[1];
          var s = a - r;
          return this.addData($e.A, t, e, i, i, r, s, 0, o ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, r, a, o), this._xi = Fh(a) * i + t, this._yi = kh(a) * i + e, this;
        }, n.prototype.arcTo = function(t, e, i, r, a) {
          return this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, e, i, r, a), this;
        }, n.prototype.rect = function(t, e, i, r) {
          return this._drawPendingPt(), this._ctx && this._ctx.rect(t, e, i, r), this.addData($e.R, t, e, i, r), this;
        }, n.prototype.closePath = function() {
          this._drawPendingPt(), this.addData($e.Z);
          var t = this._ctx, e = this._x0, i = this._y0;
          return t && t.closePath(), this._xi = e, this._yi = i, this;
        }, n.prototype.fill = function(t) {
          t && t.fill(), this.toStatic();
        }, n.prototype.stroke = function(t) {
          t && t.stroke(), this.toStatic();
        }, n.prototype.len = function() {
          return this._len;
        }, n.prototype.setData = function(t) {
          var e = t.length;
          !(this.data && this.data.length === e) && kT && (this.data = new Float32Array(e));
          for (var i = 0; i < e; i++) this.data[i] = t[i];
          this._len = e;
        }, n.prototype.appendPath = function(t) {
          t instanceof Array || (t = [t]);
          for (var e = t.length, i = 0, r = this._len, a = 0; a < e; a++) i += t[a].len();
          kT && this.data instanceof Float32Array && (this.data = new Float32Array(r + i));
          for (var a = 0; a < e; a++) for (var o = t[a].data, s = 0; s < o.length; s++) this.data[r++] = o[s];
          this._len = r;
        }, n.prototype.addData = function(t, e, i, r, a, o, s, l, u) {
          if (this._saveData) {
            var h = this.data;
            this._len + arguments.length > h.length && (this._expandData(), h = this.data);
            for (var c = 0; c < arguments.length; c++) h[this._len++] = arguments[c];
          }
        }, n.prototype._drawPendingPt = function() {
          this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
        }, n.prototype._expandData = function() {
          if (!(this.data instanceof Array)) {
            for (var t = [], e = 0; e < this._len; e++) t[e] = this.data[e];
            this.data = t;
          }
        }, n.prototype.toStatic = function() {
          if (this._saveData) {
            this._drawPendingPt();
            var t = this.data;
            t instanceof Array && (t.length = this._len, kT && this._len > 11 && (this.data = new Float32Array(t)));
          }
        }, n.prototype.getBoundingRect = function() {
          Yo[0] = Yo[1] = Wo[0] = Wo[1] = Number.MAX_VALUE, ru[0] = ru[1] = Xo[0] = Xo[1] = -Number.MAX_VALUE;
          var t = this.data, e = 0, i = 0, r = 0, a = 0, o;
          for (o = 0; o < this._len; ) {
            var s = t[o++], l = o === 1;
            switch (l && (e = t[o], i = t[o + 1], r = e, a = i), s) {
              case $e.M:
                e = r = t[o++], i = a = t[o++], Wo[0] = r, Wo[1] = a, Xo[0] = r, Xo[1] = a;
                break;
              case $e.L:
                D4(e, i, t[o], t[o + 1], Wo, Xo), e = t[o++], i = t[o++];
                break;
              case $e.C:
                JEt(e, i, t[o++], t[o++], t[o++], t[o++], t[o], t[o + 1], Wo, Xo), e = t[o++], i = t[o++];
                break;
              case $e.Q:
                tIt(e, i, t[o++], t[o++], t[o], t[o + 1], Wo, Xo), e = t[o++], i = t[o++];
                break;
              case $e.A:
                var u = t[o++], h = t[o++], c = t[o++], f = t[o++], g = t[o++], d = t[o++] + g;
                o += 1;
                var A = !t[o++];
                l && (r = Fh(g) * c + u, a = kh(g) * f + h), eIt(u, h, c, f, g, d, A, Wo, Xo), e = Fh(d) * c + u, i = kh(d) * f + h;
                break;
              case $e.R:
                r = e = t[o++], a = i = t[o++];
                var p = t[o++], v = t[o++];
                D4(r, a, r + p, a + v, Wo, Xo);
                break;
              case $e.Z:
                e = r, i = a;
                break;
            }
            Zl(Yo, Yo, Wo), Kl(ru, ru, Xo);
          }
          return o === 0 && (Yo[0] = Yo[1] = ru[0] = ru[1] = 0), new Wt(Yo[0], Yo[1], ru[0] - Yo[0], ru[1] - Yo[1]);
        }, n.prototype._calculateLength = function() {
          var t = this.data, e = this._len, i = this._ux, r = this._uy, a = 0, o = 0, s = 0, l = 0;
          this._pathSegLen || (this._pathSegLen = []);
          for (var u = this._pathSegLen, h = 0, c = 0, f = 0; f < e; ) {
            var g = t[f++], d = f === 1;
            d && (a = t[f], o = t[f + 1], s = a, l = o);
            var A = -1;
            switch (g) {
              case $e.M:
                a = s = t[f++], o = l = t[f++];
                break;
              case $e.L: {
                var p = t[f++], v = t[f++], y = p - a, m = v - o;
                (qs(y) > i || qs(m) > r || f === e - 1) && (A = Math.sqrt(y * y + m * m), a = p, o = v);
                break;
              }
              case $e.C: {
                var _ = t[f++], I = t[f++], p = t[f++], v = t[f++], E = t[f++], x = t[f++];
                A = _1t(a, o, _, I, p, v, E, x, 10), a = E, o = x;
                break;
              }
              case $e.Q: {
                var _ = t[f++], I = t[f++], p = t[f++], v = t[f++];
                A = I1t(a, o, _, I, p, v, 10), a = p, o = v;
                break;
              }
              case $e.A:
                var w = t[f++], C = t[f++], S = t[f++], b = t[f++], T = t[f++], B = t[f++], R = B + T;
                f += 1, d && (s = Fh(T) * S + w, l = kh(T) * b + C), A = NT(S, b) * PT(au, Math.abs(B)), a = Fh(R) * S + w, o = kh(R) * b + C;
                break;
              case $e.R: {
                s = a = t[f++], l = o = t[f++];
                var M = t[f++], L = t[f++];
                A = M * 2 + L * 2;
                break;
              }
              case $e.Z: {
                var y = s - a, m = l - o;
                A = Math.sqrt(y * y + m * m), a = s, o = l;
                break;
              }
            }
            A >= 0 && (u[c++] = A, h += A);
          }
          return this._pathLen = h, h;
        }, n.prototype.rebuildPath = function(t, e) {
          var i = this.data, r = this._ux, a = this._uy, o = this._len, s, l, u, h, c, f, g = e < 1, d, A, p = 0, v = 0, y, m = 0, _, I;
          if (!(g && (this._pathSegLen || this._calculateLength(), d = this._pathSegLen, A = this._pathLen, y = e * A, !y))) t: for (var E = 0; E < o; ) {
            var x = i[E++], w = E === 1;
            switch (w && (u = i[E], h = i[E + 1], s = u, l = h), x !== $e.L && m > 0 && (t.lineTo(_, I), m = 0), x) {
              case $e.M:
                s = u = i[E++], l = h = i[E++], t.moveTo(u, h);
                break;
              case $e.L: {
                c = i[E++], f = i[E++];
                var C = qs(c - u), S = qs(f - h);
                if (C > r || S > a) {
                  if (g) {
                    var b = d[v++];
                    if (p + b > y) {
                      var T = (y - p) / b;
                      t.lineTo(u * (1 - T) + c * T, h * (1 - T) + f * T);
                      break t;
                    }
                    p += b;
                  }
                  t.lineTo(c, f), u = c, h = f, m = 0;
                } else {
                  var B = C * C + S * S;
                  B > m && (_ = c, I = f, m = B);
                }
                break;
              }
              case $e.C: {
                var R = i[E++], M = i[E++], L = i[E++], N = i[E++], F = i[E++], k = i[E++];
                if (g) {
                  var b = d[v++];
                  if (p + b > y) {
                    var T = (y - p) / b;
                    eu(u, R, L, F, T, Ph), eu(h, M, N, k, T, Nh), t.bezierCurveTo(Ph[1], Nh[1], Ph[2], Nh[2], Ph[3], Nh[3]);
                    break t;
                  }
                  p += b;
                }
                t.bezierCurveTo(R, M, L, N, F, k), u = F, h = k;
                break;
              }
              case $e.Q: {
                var R = i[E++], M = i[E++], L = i[E++], N = i[E++];
                if (g) {
                  var b = d[v++];
                  if (p + b > y) {
                    var T = (y - p) / b;
                    Up(u, R, L, T, Ph), Up(h, M, N, T, Nh), t.quadraticCurveTo(Ph[1], Nh[1], Ph[2], Nh[2]);
                    break t;
                  }
                  p += b;
                }
                t.quadraticCurveTo(R, M, L, N), u = L, h = N;
                break;
              }
              case $e.A:
                var O = i[E++], Q = i[E++], j = i[E++], Y = i[E++], G = i[E++], $ = i[E++], J = i[E++], et = !i[E++], nt = j > Y ? j : Y, gt = qs(j - Y) > 1e-3, q = G + $, W = false;
                if (g) {
                  var b = d[v++];
                  p + b > y && (q = G + $ * (y - p) / b, W = true), p += b;
                }
                if (gt && t.ellipse ? t.ellipse(O, Q, j, Y, J, G, q, et) : t.arc(O, Q, nt, G, q, et), W) break t;
                w && (s = Fh(G) * j + O, l = kh(G) * Y + Q), u = Fh(q) * j + O, h = kh(q) * Y + Q;
                break;
              case $e.R:
                s = u = i[E], l = h = i[E + 1], c = i[E++], f = i[E++];
                var it = i[E++], Ot = i[E++];
                if (g) {
                  var b = d[v++];
                  if (p + b > y) {
                    var pt = y - p;
                    t.moveTo(c, f), t.lineTo(c + PT(pt, it), f), pt -= it, pt > 0 && t.lineTo(c + it, f + PT(pt, Ot)), pt -= Ot, pt > 0 && t.lineTo(c + NT(it - pt, 0), f + Ot), pt -= it, pt > 0 && t.lineTo(c, f + NT(Ot - pt, 0));
                    break t;
                  }
                  p += b;
                }
                t.rect(c, f, it, Ot);
                break;
              case $e.Z:
                if (g) {
                  var b = d[v++];
                  if (p + b > y) {
                    var T = (y - p) / b;
                    t.lineTo(u * (1 - T) + s * T, h * (1 - T) + l * T);
                    break t;
                  }
                  p += b;
                }
                t.closePath(), u = s, h = l;
            }
          }
        }, n.prototype.clone = function() {
          var t = new n(), e = this.data;
          return t.data = e.slice ? e.slice() : Array.prototype.slice.call(e), t._len = this._len, t;
        }, n.CMD = $e, n.initDefaultProps = function() {
          var t = n.prototype;
          t._saveData = true, t._ux = 0, t._uy = 0, t._pendingPtDist = 0, t._version = 0;
        }(), n;
      }();
      function ou(n, t, e, i, r, a, o) {
        if (r === 0) return false;
        var s = r, l = 0, u = n;
        if (o > t + s && o > i + s || o < t - s && o < i - s || a > n + s && a > e + s || a < n - s && a < e - s) return false;
        if (n !== e) l = (t - i) / (n - e), u = (n * i - e * t) / (n - e);
        else return Math.abs(a - n) <= s / 2;
        var h = l * a - o + u, c = h * h / (l * l + 1);
        return c <= s / 2 * s / 2;
      }
      function nIt(n, t, e, i, r, a, o, s, l, u, h) {
        if (l === 0) return false;
        var c = l;
        if (h > t + c && h > i + c && h > a + c && h > s + c || h < t - c && h < i - c && h < a - c && h < s - c || u > n + c && u > e + c && u > r + c && u > o + c || u < n - c && u < e - c && u < r - c && u < o - c) return false;
        var f = C5(n, t, e, i, r, a, o, s, u, h, null);
        return f <= c / 2;
      }
      function P4(n, t, e, i, r, a, o, s, l) {
        if (o === 0) return false;
        var u = o;
        if (l > t + u && l > i + u && l > a + u || l < t - u && l < i - u && l < a - u || s > n + u && s > e + u && s > r + u || s < n - u && s < e - u && s < r - u) return false;
        var h = b5(n, t, e, i, r, a, s, l, null);
        return h <= u / 2;
      }
      var N4 = Math.PI * 2;
      function Yr(n) {
        return n %= N4, n < 0 && (n += N4), n;
      }
      var rv = Math.PI * 2;
      function iIt(n, t, e, i, r, a, o, s, l) {
        if (o === 0) return false;
        var u = o;
        s -= n, l -= t;
        var h = Math.sqrt(s * s + l * l);
        if (h - u > e || h + u < e) return false;
        if (Math.abs(i - r) % rv < 1e-4) return true;
        if (a) {
          var c = i;
          i = Yr(r), r = Yr(c);
        } else i = Yr(i), r = Yr(r);
        i > r && (r += rv);
        var f = Math.atan2(l, s);
        return f < 0 && (f += rv), f >= i && f <= r || f + rv >= i && f + rv <= r;
      }
      function Hs(n, t, e, i, r, a) {
        if (a > t && a > i || a < t && a < i || i === t) return 0;
        var o = (a - t) / (i - t), s = i < t ? 1 : -1;
        (o === 1 || o === 0) && (s = i < t ? 0.5 : -0.5);
        var l = o * (e - n) + n;
        return l === r ? 1 / 0 : l > r ? s : 0;
      }
      var su = $o.CMD, Oh = Math.PI * 2, rIt = 1e-4;
      function aIt(n, t) {
        return Math.abs(n - t) < rIt;
      }
      var Xi = [-1, -1, -1], ma = [-1, -1];
      function oIt() {
        var n = ma[0];
        ma[0] = ma[1], ma[1] = n;
      }
      function sIt(n, t, e, i, r, a, o, s, l, u) {
        if (u > t && u > i && u > a && u > s || u < t && u < i && u < a && u < s) return 0;
        var h = J_(t, i, a, s, u, Xi);
        if (h === 0) return 0;
        for (var c = 0, f = -1, g = void 0, d = void 0, A = 0; A < h; A++) {
          var p = Xi[A], v = p === 0 || p === 1 ? 0.5 : 1, y = Zn(n, e, r, o, p);
          y < l || (f < 0 && (f = w5(t, i, a, s, ma), ma[1] < ma[0] && f > 1 && oIt(), g = Zn(t, i, a, s, ma[0]), f > 1 && (d = Zn(t, i, a, s, ma[1]))), f === 2 ? p < ma[0] ? c += g < t ? v : -v : p < ma[1] ? c += d < g ? v : -v : c += s < d ? v : -v : p < ma[0] ? c += g < t ? v : -v : c += s < g ? v : -v);
        }
        return c;
      }
      function lIt(n, t, e, i, r, a, o, s) {
        if (s > t && s > i && s > a || s < t && s < i && s < a) return 0;
        var l = E1t(t, i, a, s, Xi);
        if (l === 0) return 0;
        var u = S5(t, i, a);
        if (u >= 0 && u <= 1) {
          for (var h = 0, c = fi(t, i, a, u), f = 0; f < l; f++) {
            var g = Xi[f] === 0 || Xi[f] === 1 ? 0.5 : 1, d = fi(n, e, r, Xi[f]);
            d < o || (Xi[f] < u ? h += c < t ? g : -g : h += a < c ? g : -g);
          }
          return h;
        } else {
          var g = Xi[0] === 0 || Xi[0] === 1 ? 0.5 : 1, d = fi(n, e, r, Xi[0]);
          return d < o ? 0 : a < t ? g : -g;
        }
      }
      function uIt(n, t, e, i, r, a, o, s) {
        if (s -= t, s > e || s < -e) return 0;
        var l = Math.sqrt(e * e - s * s);
        Xi[0] = -l, Xi[1] = l;
        var u = Math.abs(i - r);
        if (u < 1e-4) return 0;
        if (u >= Oh - 1e-4) {
          i = 0, r = Oh;
          var h = a ? 1 : -1;
          return o >= Xi[0] + n && o <= Xi[1] + n ? h : 0;
        }
        if (i > r) {
          var c = i;
          i = r, r = c;
        }
        i < 0 && (i += Oh, r += Oh);
        for (var f = 0, g = 0; g < 2; g++) {
          var d = Xi[g];
          if (d + n > o) {
            var A = Math.atan2(s, d), h = a ? 1 : -1;
            A < 0 && (A = Oh + A), (A >= i && A <= r || A + Oh >= i && A + Oh <= r) && (A > Math.PI / 2 && A < Math.PI * 1.5 && (h = -h), f += h);
          }
        }
        return f;
      }
      function F4(n, t, e, i, r) {
        for (var a = n.data, o = n.len(), s = 0, l = 0, u = 0, h = 0, c = 0, f, g, d = 0; d < o; ) {
          var A = a[d++], p = d === 1;
          switch (A === su.M && d > 1 && (e || (s += Hs(l, u, h, c, i, r))), p && (l = a[d], u = a[d + 1], h = l, c = u), A) {
            case su.M:
              h = a[d++], c = a[d++], l = h, u = c;
              break;
            case su.L:
              if (e) {
                if (ou(l, u, a[d], a[d + 1], t, i, r)) return true;
              } else s += Hs(l, u, a[d], a[d + 1], i, r) || 0;
              l = a[d++], u = a[d++];
              break;
            case su.C:
              if (e) {
                if (nIt(l, u, a[d++], a[d++], a[d++], a[d++], a[d], a[d + 1], t, i, r)) return true;
              } else s += sIt(l, u, a[d++], a[d++], a[d++], a[d++], a[d], a[d + 1], i, r) || 0;
              l = a[d++], u = a[d++];
              break;
            case su.Q:
              if (e) {
                if (P4(l, u, a[d++], a[d++], a[d], a[d + 1], t, i, r)) return true;
              } else s += lIt(l, u, a[d++], a[d++], a[d], a[d + 1], i, r) || 0;
              l = a[d++], u = a[d++];
              break;
            case su.A:
              var v = a[d++], y = a[d++], m = a[d++], _ = a[d++], I = a[d++], E = a[d++];
              d += 1;
              var x = !!(1 - a[d++]);
              f = Math.cos(I) * m + v, g = Math.sin(I) * _ + y, p ? (h = f, c = g) : s += Hs(l, u, f, g, i, r);
              var w = (i - v) * _ / m + v;
              if (e) {
                if (iIt(v, y, _, I, I + E, x, t, w, r)) return true;
              } else s += uIt(v, y, _, I, I + E, x, w, r);
              l = Math.cos(I + E) * m + v, u = Math.sin(I + E) * _ + y;
              break;
            case su.R:
              h = l = a[d++], c = u = a[d++];
              var C = a[d++], S = a[d++];
              if (f = h + C, g = c + S, e) {
                if (ou(h, c, f, c, t, i, r) || ou(f, c, f, g, t, i, r) || ou(f, g, h, g, t, i, r) || ou(h, g, h, c, t, i, r)) return true;
              } else s += Hs(f, c, f, g, i, r), s += Hs(h, g, h, c, i, r);
              break;
            case su.Z:
              if (e) {
                if (ou(l, u, h, c, t, i, r)) return true;
              } else s += Hs(l, u, h, c, i, r);
              l = h, u = c;
              break;
          }
        }
        return !e && !aIt(u, c) && (s += Hs(l, u, h, c, i, r) || 0), s !== 0;
      }
      function hIt(n, t, e) {
        return F4(n, 0, false, t, e);
      }
      function cIt(n, t, e, i) {
        return F4(n, t, true, e, i);
      }
      var C1 = wt({ fill: "#000", stroke: null, strokePercent: 1, fillOpacity: 1, strokeOpacity: 1, lineDashOffset: 0, lineWidth: 1, lineCap: "butt", miterLimit: 10, strokeNoScale: false, strokeFirst: false }, Rh), fIt = { style: wt({ fill: true, stroke: true, strokePercent: true, fillOpacity: true, strokeOpacity: true, lineDashOffset: true, lineWidth: true, miterLimit: true }, _1.style) }, zT = Vo.concat(["invisible", "culling", "z", "z2", "zlevel", "parent"]), ne = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.update = function() {
          var e = this;
          n.prototype.update.call(this);
          var i = this.style;
          if (i.decal) {
            var r = this._decalEl = this._decalEl || new t();
            r.buildPath === t.prototype.buildPath && (r.buildPath = function(l) {
              e.buildPath(l, e.shape);
            }), r.silent = true;
            var a = r.style;
            for (var o in i) a[o] !== i[o] && (a[o] = i[o]);
            a.fill = i.fill ? i.decal : null, a.decal = null, a.shadowColor = null, i.strokeFirst && (a.stroke = null);
            for (var s = 0; s < zT.length; ++s) r[zT[s]] = this[zT[s]];
            r.__dirty |= jr;
          } else this._decalEl && (this._decalEl = null);
        }, t.prototype.getDecalElement = function() {
          return this._decalEl;
        }, t.prototype._init = function(e) {
          var i = oe(e);
          this.shape = this.getDefaultShape();
          var r = this.getDefaultStyle();
          r && this.useStyle(r);
          for (var a = 0; a < i.length; a++) {
            var o = i[a], s = e[o];
            o === "style" ? this.style ? X(this.style, s) : this.useStyle(s) : o === "shape" ? X(this.shape, s) : n.prototype.attrKV.call(this, o, s);
          }
          this.style || this.useStyle({});
        }, t.prototype.getDefaultStyle = function() {
          return null;
        }, t.prototype.getDefaultShape = function() {
          return {};
        }, t.prototype.canBeInsideText = function() {
          return this.hasFill();
        }, t.prototype.getInsideTextFill = function() {
          var e = this.style.fill;
          if (e !== "none") {
            if (ht(e)) {
              var i = n1(e, 0);
              return i > 0.5 ? uT : i > 0.2 ? X1t : hT;
            } else if (e) return hT;
          }
          return uT;
        }, t.prototype.getInsideTextStroke = function(e) {
          var i = this.style.fill;
          if (ht(i)) {
            var r = this.__zr, a = !!(r && r.isDarkMode()), o = n1(e, 0) < lT;
            if (a === o) return i;
          }
        }, t.prototype.buildPath = function(e, i, r) {
        }, t.prototype.pathUpdated = function() {
          this.__dirty &= ~bg;
        }, t.prototype.getUpdatedPathProxy = function(e) {
          return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, e), this.path;
        }, t.prototype.createPathProxy = function() {
          this.path = new $o(false);
        }, t.prototype.hasStroke = function() {
          var e = this.style, i = e.stroke;
          return !(i == null || i === "none" || !(e.lineWidth > 0));
        }, t.prototype.hasFill = function() {
          var e = this.style, i = e.fill;
          return i != null && i !== "none";
        }, t.prototype.getBoundingRect = function() {
          var e = this._rect, i = this.style, r = !e;
          if (r) {
            var a = false;
            this.path || (a = true, this.createPathProxy());
            var o = this.path;
            (a || this.__dirty & bg) && (o.beginPath(), this.buildPath(o, this.shape, false), this.pathUpdated()), e = o.getBoundingRect();
          }
          if (this._rect = e, this.hasStroke() && this.path && this.path.len() > 0) {
            var s = this._rectStroke || (this._rectStroke = e.clone());
            if (this.__dirty || r) {
              s.copy(e);
              var l = i.strokeNoScale ? this.getLineScale() : 1, u = i.lineWidth;
              if (!this.hasFill()) {
                var h = this.strokeContainThreshold;
                u = Math.max(u, h == null ? 4 : h);
              }
              l > 1e-10 && (s.width += u / l, s.height += u / l, s.x -= u / l / 2, s.y -= u / l / 2);
            }
            return s;
          }
          return e;
        }, t.prototype.contain = function(e, i) {
          var r = this.transformCoordToLocal(e, i), a = this.getBoundingRect(), o = this.style;
          if (e = r[0], i = r[1], a.contain(e, i)) {
            var s = this.path;
            if (this.hasStroke()) {
              var l = o.lineWidth, u = o.strokeNoScale ? this.getLineScale() : 1;
              if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), cIt(s, l / u, e, i))) return true;
            }
            if (this.hasFill()) return hIt(s, e, i);
          }
          return false;
        }, t.prototype.dirtyShape = function() {
          this.__dirty |= bg, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
        }, t.prototype.dirty = function() {
          this.dirtyStyle(), this.dirtyShape();
        }, t.prototype.animateShape = function(e) {
          return this.animate("shape", e);
        }, t.prototype.updateDuringAnimation = function(e) {
          e === "style" ? this.dirtyStyle() : e === "shape" ? this.dirtyShape() : this.markRedraw();
        }, t.prototype.attrKV = function(e, i) {
          e === "shape" ? this.setShape(i) : n.prototype.attrKV.call(this, e, i);
        }, t.prototype.setShape = function(e, i) {
          var r = this.shape;
          return r || (r = this.shape = {}), typeof e == "string" ? r[e] = i : X(r, e), this.dirtyShape(), this;
        }, t.prototype.shapeChanged = function() {
          return !!(this.__dirty & bg);
        }, t.prototype.createStyle = function(e) {
          return G_(C1, e);
        }, t.prototype._innerSaveToNormal = function(e) {
          n.prototype._innerSaveToNormal.call(this, e);
          var i = this._normalState;
          e.shape && !i.shape && (i.shape = X({}, this.shape));
        }, t.prototype._applyStateObj = function(e, i, r, a, o, s) {
          n.prototype._applyStateObj.call(this, e, i, r, a, o, s);
          var l = !(i && a), u;
          if (i && i.shape ? o ? a ? u = i.shape : (u = X({}, r.shape), X(u, i.shape)) : (u = X({}, a ? this.shape : r.shape), X(u, i.shape)) : l && (u = r.shape), u) if (o) {
            this.shape = X({}, this.shape);
            for (var h = {}, c = oe(u), f = 0; f < c.length; f++) {
              var g = c[f];
              typeof u[g] == "object" ? this.shape[g] = u[g] : h[g] = u[g];
            }
            this._transitionState(e, { shape: h }, s);
          } else this.shape = u, this.dirtyShape();
        }, t.prototype._mergeStates = function(e) {
          for (var i = n.prototype._mergeStates.call(this, e), r, a = 0; a < e.length; a++) {
            var o = e[a];
            o.shape && (r = r || {}, this._mergeStyle(r, o.shape));
          }
          return r && (i.shape = r), i;
        }, t.prototype.getAnimationStyleProps = function() {
          return fIt;
        }, t.prototype.isZeroArea = function() {
          return false;
        }, t.extend = function(e) {
          var i = function(a) {
            V(o, a);
            function o(s) {
              var l = a.call(this, s) || this;
              return e.init && e.init.call(l, s), l;
            }
            return o.prototype.getDefaultStyle = function() {
              return Ct(e.style);
            }, o.prototype.getDefaultShape = function() {
              return Ct(e.shape);
            }, o;
          }(t);
          for (var r in e) typeof e[r] == "function" && (i.prototype[r] = e[r]);
          return i;
        }, t.initDefaultProps = function() {
          var e = t.prototype;
          e.type = "path", e.strokeContainThreshold = 5, e.segmentIgnoreThreshold = 0, e.subPixelOptimize = false, e.autoBatch = false, e.__dirty = jr | zp | bg;
        }(), t;
      }(ya), gIt = wt({ strokeFirst: true, font: Wl, x: 0, y: 0, textAlign: "left", textBaseline: "top", miterLimit: 2 }, C1), Fg = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.hasStroke = function() {
          var e = this.style, i = e.stroke;
          return i != null && i !== "none" && e.lineWidth > 0;
        }, t.prototype.hasFill = function() {
          var e = this.style, i = e.fill;
          return i != null && i !== "none";
        }, t.prototype.createStyle = function(e) {
          return G_(gIt, e);
        }, t.prototype.setBoundingRect = function(e) {
          this._rect = e;
        }, t.prototype.getBoundingRect = function() {
          var e = this.style;
          if (!this._rect) {
            var i = e.text;
            i != null ? i += "" : i = "";
            var r = $p(i, e.font, e.textAlign, e.textBaseline);
            if (r.x += e.x || 0, r.y += e.y || 0, this.hasStroke()) {
              var a = e.lineWidth;
              r.x -= a / 2, r.y -= a / 2, r.width += a, r.height += a;
            }
            this._rect = r;
          }
          return this._rect;
        }, t.initDefaultProps = function() {
          var e = t.prototype;
          e.dirtyRectTolerance = 10;
        }(), t;
      }(ya);
      Fg.prototype.type = "tspan";
      var dIt = wt({ x: 0, y: 0 }, Rh), AIt = { style: wt({ x: true, y: true, width: true, height: true, sx: true, sy: true, sWidth: true, sHeight: true }, _1.style) };
      function pIt(n) {
        return !!(n && typeof n != "string" && n.width && n.height);
      }
      var gi = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.createStyle = function(e) {
          return G_(dIt, e);
        }, t.prototype._getSize = function(e) {
          var i = this.style, r = i[e];
          if (r != null) return r;
          var a = pIt(i.image) ? i.image : this.__image;
          if (!a) return 0;
          var o = e === "width" ? "height" : "width", s = i[o];
          return s == null ? a[e] : a[e] / a[o] * s;
        }, t.prototype.getWidth = function() {
          return this._getSize("width");
        }, t.prototype.getHeight = function() {
          return this._getSize("height");
        }, t.prototype.getAnimationStyleProps = function() {
          return AIt;
        }, t.prototype.getBoundingRect = function() {
          var e = this.style;
          return this._rect || (this._rect = new Wt(e.x || 0, e.y || 0, this.getWidth(), this.getHeight())), this._rect;
        }, t;
      }(ya);
      gi.prototype.type = "image";
      function vIt(n, t) {
        var e = t.x, i = t.y, r = t.width, a = t.height, o = t.r, s, l, u, h;
        r < 0 && (e = e + r, r = -r), a < 0 && (i = i + a, a = -a), typeof o == "number" ? s = l = u = h = o : o instanceof Array ? o.length === 1 ? s = l = u = h = o[0] : o.length === 2 ? (s = u = o[0], l = h = o[1]) : o.length === 3 ? (s = o[0], l = h = o[1], u = o[2]) : (s = o[0], l = o[1], u = o[2], h = o[3]) : s = l = u = h = 0;
        var c;
        s + l > r && (c = s + l, s *= r / c, l *= r / c), u + h > r && (c = u + h, u *= r / c, h *= r / c), l + u > a && (c = l + u, l *= a / c, u *= a / c), s + h > a && (c = s + h, s *= a / c, h *= a / c), n.moveTo(e + s, i), n.lineTo(e + r - l, i), l !== 0 && n.arc(e + r - l, i + l, l, -Math.PI / 2, 0), n.lineTo(e + r, i + a - u), u !== 0 && n.arc(e + r - u, i + a - u, u, 0, Math.PI / 2), n.lineTo(e + h, i + a), h !== 0 && n.arc(e + h, i + a - h, h, Math.PI / 2, Math.PI), n.lineTo(e, i + s), s !== 0 && n.arc(e + s, i + s, s, Math.PI, Math.PI * 1.5);
      }
      var kg = Math.round;
      function k4(n, t, e) {
        if (t) {
          var i = t.x1, r = t.x2, a = t.y1, o = t.y2;
          n.x1 = i, n.x2 = r, n.y1 = a, n.y2 = o;
          var s = e && e.lineWidth;
          return s && (kg(i * 2) === kg(r * 2) && (n.x1 = n.x2 = Qh(i, s, true)), kg(a * 2) === kg(o * 2) && (n.y1 = n.y2 = Qh(a, s, true))), n;
        }
      }
      function O4(n, t, e) {
        if (t) {
          var i = t.x, r = t.y, a = t.width, o = t.height;
          n.x = i, n.y = r, n.width = a, n.height = o;
          var s = e && e.lineWidth;
          return s && (n.x = Qh(i, s, true), n.y = Qh(r, s, true), n.width = Math.max(Qh(i + a, s, false) - n.x, a === 0 ? 0 : 1), n.height = Math.max(Qh(r + o, s, false) - n.y, o === 0 ? 0 : 1)), n;
        }
      }
      function Qh(n, t, e) {
        if (!t) return n;
        var i = kg(n * 2);
        return (i + kg(t)) % 2 === 0 ? i / 2 : (i + (e ? 1 : -1)) / 2;
      }
      var yIt = /* @__PURE__ */ function() {
        function n() {
          this.x = 0, this.y = 0, this.width = 0, this.height = 0;
        }
        return n;
      }(), mIt = {}, fe = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultShape = function() {
          return new yIt();
        }, t.prototype.buildPath = function(e, i) {
          var r, a, o, s;
          if (this.subPixelOptimize) {
            var l = O4(mIt, i, this.style);
            r = l.x, a = l.y, o = l.width, s = l.height, l.r = i.r, i = l;
          } else r = i.x, a = i.y, o = i.width, s = i.height;
          i.r ? vIt(e, i) : e.rect(r, a, o, s);
        }, t.prototype.isZeroArea = function() {
          return !this.shape.width || !this.shape.height;
        }, t;
      }(ne);
      fe.prototype.type = "rect";
      var Q4 = { fill: "#000" }, z4 = 2, _It = { style: wt({ fill: true, stroke: true, fillOpacity: true, strokeOpacity: true, lineWidth: true, fontSize: true, lineHeight: true, width: true, height: true, textShadowColor: true, textShadowBlur: true, textShadowOffsetX: true, textShadowOffsetY: true, backgroundColor: true, padding: true, borderColor: true, borderWidth: true, borderRadius: true }, _1.style) }, Ae = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this) || this;
          return i.type = "text", i._children = [], i._defaultStyle = Q4, i.attr(e), i;
        }
        return t.prototype.childrenRef = function() {
          return this._children;
        }, t.prototype.update = function() {
          n.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
          for (var e = 0; e < this._children.length; e++) {
            var i = this._children[e];
            i.zlevel = this.zlevel, i.z = this.z, i.z2 = this.z2, i.culling = this.culling, i.cursor = this.cursor, i.invisible = this.invisible;
          }
        }, t.prototype.updateTransform = function() {
          var e = this.innerTransformable;
          e ? (e.updateTransform(), e.transform && (this.transform = e.transform)) : n.prototype.updateTransform.call(this);
        }, t.prototype.getLocalTransform = function(e) {
          var i = this.innerTransformable;
          return i ? i.getLocalTransform(e) : n.prototype.getLocalTransform.call(this, e);
        }, t.prototype.getComputedTransform = function() {
          return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(true)), n.prototype.getComputedTransform.call(this);
        }, t.prototype._updateSubTexts = function() {
          this._childCursor = 0, xIt(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
        }, t.prototype.addSelfToZr = function(e) {
          n.prototype.addSelfToZr.call(this, e);
          for (var i = 0; i < this._children.length; i++) this._children[i].__zr = e;
        }, t.prototype.removeSelfFromZr = function(e) {
          n.prototype.removeSelfFromZr.call(this, e);
          for (var i = 0; i < this._children.length; i++) this._children[i].__zr = null;
        }, t.prototype.getBoundingRect = function() {
          if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
            for (var e = new Wt(0, 0, 0, 0), i = this._children, r = [], a = null, o = 0; o < i.length; o++) {
              var s = i[o], l = s.getBoundingRect(), u = s.getLocalTransform(r);
              u ? (e.copy(l), e.applyTransform(u), a = a || e.clone(), a.union(e)) : (a = a || l.clone(), a.union(l));
            }
            this._rect = a || e;
          }
          return this._rect;
        }, t.prototype.setDefaultTextStyle = function(e) {
          this._defaultStyle = e || Q4;
        }, t.prototype.setTextContent = function(e) {
          if (true) throw new Error("Can't attach text on another text");
        }, t.prototype._mergeStyle = function(e, i) {
          if (!i) return e;
          var r = i.rich, a = e.rich || r && {};
          return X(e, i), r && a ? (this._mergeRich(a, r), e.rich = a) : a && (e.rich = a), e;
        }, t.prototype._mergeRich = function(e, i) {
          for (var r = oe(i), a = 0; a < r.length; a++) {
            var o = r[a];
            e[o] = e[o] || {}, X(e[o], i[o]);
          }
        }, t.prototype.getAnimationStyleProps = function() {
          return _It;
        }, t.prototype._getOrCreateChild = function(e) {
          var i = this._children[this._childCursor];
          return (!i || !(i instanceof e)) && (i = new e()), this._children[this._childCursor++] = i, i.__zr = this.__zr, i.parent = this, i;
        }, t.prototype._updatePlainTexts = function() {
          var e = this.style, i = e.font || Wl, r = e.padding, a = X4(e), o = jEt(a, e), s = GT(e), l = !!e.backgroundColor, u = o.outerHeight, h = o.outerWidth, c = o.contentWidth, f = o.lines, g = o.lineHeight, d = this._defaultStyle, A = e.x || 0, p = e.y || 0, v = e.align || d.align || "left", y = e.verticalAlign || d.verticalAlign || "top", m = A, _ = Rg(p, o.contentHeight, y);
          if (s || r) {
            var I = Zp(A, h, v), E = Rg(p, u, y);
            s && this._renderBackground(e, e, I, E, h, u);
          }
          _ += g / 2, r && (m = W4(A, v, r), y === "top" ? _ += r[0] : y === "bottom" && (_ -= r[2]));
          for (var x = 0, w = false, C = Y4("fill" in e ? e.fill : (w = true, d.fill)), S = H4("stroke" in e ? e.stroke : !l && (!d.autoStroke || w) ? (x = z4, d.stroke) : null), b = e.textShadowBlur > 0, T = e.width != null && (e.overflow === "truncate" || e.overflow === "break" || e.overflow === "breakAll"), B = o.calculatedLineHeight, R = 0; R < f.length; R++) {
            var M = this._getOrCreateChild(Fg), L = M.createStyle();
            M.useStyle(L), L.text = f[R], L.x = m, L.y = _, v && (L.textAlign = v), L.textBaseline = "middle", L.opacity = e.opacity, L.strokeFirst = true, b && (L.shadowBlur = e.textShadowBlur || 0, L.shadowColor = e.textShadowColor || "transparent", L.shadowOffsetX = e.textShadowOffsetX || 0, L.shadowOffsetY = e.textShadowOffsetY || 0), L.stroke = S, L.fill = C, S && (L.lineWidth = e.lineWidth || x, L.lineDash = e.lineDash, L.lineDashOffset = e.lineDashOffset || 0), L.font = i, V4(L, e), _ += g, T && M.setBoundingRect(new Wt(Zp(L.x, e.width, L.textAlign), Rg(L.y, B, L.textBaseline), c, B));
          }
        }, t.prototype._updateRichTexts = function() {
          var e = this.style, i = X4(e), r = YEt(i, e), a = r.width, o = r.outerWidth, s = r.outerHeight, l = e.padding, u = e.x || 0, h = e.y || 0, c = this._defaultStyle, f = e.align || c.align, g = e.verticalAlign || c.verticalAlign, d = Zp(u, o, f), A = Rg(h, s, g), p = d, v = A;
          l && (p += l[3], v += l[0]);
          var y = p + a;
          GT(e) && this._renderBackground(e, e, d, A, o, s);
          for (var m = !!e.backgroundColor, _ = 0; _ < r.lines.length; _++) {
            for (var I = r.lines[_], E = I.tokens, x = E.length, w = I.lineHeight, C = I.width, S = 0, b = p, T = y, B = x - 1, R = void 0; S < x && (R = E[S], !R.align || R.align === "left"); ) this._placeToken(R, e, w, v, b, "left", m), C -= R.width, b += R.width, S++;
            for (; B >= 0 && (R = E[B], R.align === "right"); ) this._placeToken(R, e, w, v, T, "right", m), C -= R.width, T -= R.width, B--;
            for (b += (a - (b - p) - (y - T) - C) / 2; S <= B; ) R = E[S], this._placeToken(R, e, w, v, b + R.width / 2, "center", m), b += R.width, S++;
            v += w;
          }
        }, t.prototype._placeToken = function(e, i, r, a, o, s, l) {
          var u = i.rich[e.styleName] || {};
          u.text = e.text;
          var h = e.verticalAlign, c = a + r / 2;
          h === "top" ? c = a + e.height / 2 : h === "bottom" && (c = a + r - e.height / 2);
          var f = !e.isLineHolder && GT(u);
          f && this._renderBackground(u, i, s === "right" ? o - e.width : s === "center" ? o - e.width / 2 : o, c - e.height / 2, e.width, e.height);
          var g = !!u.backgroundColor, d = e.textPadding;
          d && (o = W4(o, s, d), c -= e.height / 2 - d[0] - e.innerHeight / 2);
          var A = this._getOrCreateChild(Fg), p = A.createStyle();
          A.useStyle(p);
          var v = this._defaultStyle, y = false, m = 0, _ = Y4("fill" in u ? u.fill : "fill" in i ? i.fill : (y = true, v.fill)), I = H4("stroke" in u ? u.stroke : "stroke" in i ? i.stroke : !g && !l && (!v.autoStroke || y) ? (m = z4, v.stroke) : null), E = u.textShadowBlur > 0 || i.textShadowBlur > 0;
          p.text = e.text, p.x = o, p.y = c, E && (p.shadowBlur = u.textShadowBlur || i.textShadowBlur || 0, p.shadowColor = u.textShadowColor || i.textShadowColor || "transparent", p.shadowOffsetX = u.textShadowOffsetX || i.textShadowOffsetX || 0, p.shadowOffsetY = u.textShadowOffsetY || i.textShadowOffsetY || 0), p.textAlign = s, p.textBaseline = "middle", p.font = e.font || Wl, p.opacity = fa(u.opacity, i.opacity, 1), V4(p, u), I && (p.lineWidth = fa(u.lineWidth, i.lineWidth, m), p.lineDash = kt(u.lineDash, i.lineDash), p.lineDashOffset = i.lineDashOffset || 0, p.stroke = I), _ && (p.fill = _);
          var x = e.contentWidth, w = e.contentHeight;
          A.setBoundingRect(new Wt(Zp(p.x, x, p.textAlign), Rg(p.y, w, p.textBaseline), x, w));
        }, t.prototype._renderBackground = function(e, i, r, a, o, s) {
          var l = e.backgroundColor, u = e.borderWidth, h = e.borderColor, c = l && l.image, f = l && !c, g = e.borderRadius, d = this, A, p;
          if (f || e.lineHeight || u && h) {
            A = this._getOrCreateChild(fe), A.useStyle(A.createStyle()), A.style.fill = null;
            var v = A.shape;
            v.x = r, v.y = a, v.width = o, v.height = s, v.r = g, A.dirtyShape();
          }
          if (f) {
            var y = A.style;
            y.fill = l || null, y.fillOpacity = kt(e.fillOpacity, 1);
          } else if (c) {
            p = this._getOrCreateChild(gi), p.onload = function() {
              d.dirtyStyle();
            };
            var m = p.style;
            m.image = l.image, m.x = r, m.y = a, m.width = o, m.height = s;
          }
          if (u && h) {
            var y = A.style;
            y.lineWidth = u, y.stroke = h, y.strokeOpacity = kt(e.strokeOpacity, 1), y.lineDash = e.borderDash, y.lineDashOffset = e.borderDashOffset || 0, A.strokeContainThreshold = 0, A.hasFill() && A.hasStroke() && (y.strokeFirst = true, y.lineWidth *= 2);
          }
          var _ = (A || p).style;
          _.shadowBlur = e.shadowBlur || 0, _.shadowColor = e.shadowColor || "transparent", _.shadowOffsetX = e.shadowOffsetX || 0, _.shadowOffsetY = e.shadowOffsetY || 0, _.opacity = fa(e.opacity, i.opacity, 1);
        }, t.makeFont = function(e) {
          var i = "";
          return j4(e) && (i = [e.fontStyle, e.fontWeight, U4(e.fontSize), e.fontFamily || "sans-serif"].join(" ")), i && Wa(i) || e.textFont || e.font;
        }, t;
      }(ya), EIt = { left: true, right: 1, center: 1 }, IIt = { top: 1, bottom: 1, middle: 1 }, G4 = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
      function U4(n) {
        return typeof n == "string" && (n.indexOf("px") !== -1 || n.indexOf("rem") !== -1 || n.indexOf("em") !== -1) ? n : isNaN(+n) ? v2 + "px" : n + "px";
      }
      function V4(n, t) {
        for (var e = 0; e < G4.length; e++) {
          var i = G4[e], r = t[i];
          r != null && (n[i] = r);
        }
      }
      function j4(n) {
        return n.fontSize != null || n.fontFamily || n.fontWeight;
      }
      function xIt(n) {
        return q4(n), D(n.rich, q4), n;
      }
      function q4(n) {
        if (n) {
          n.font = Ae.makeFont(n);
          var t = n.align;
          t === "middle" && (t = "center"), n.align = t == null || EIt[t] ? t : "left";
          var e = n.verticalAlign;
          e === "center" && (e = "middle"), n.verticalAlign = e == null || IIt[e] ? e : "top";
          var i = n.padding;
          i && (n.padding = I2(n.padding));
        }
      }
      function H4(n, t) {
        return n == null || t <= 0 || n === "transparent" || n === "none" ? null : n.image || n.colorStops ? "#000" : n;
      }
      function Y4(n) {
        return n == null || n === "none" ? null : n.image || n.colorStops ? "#000" : n;
      }
      function W4(n, t, e) {
        return t === "right" ? n - e[1] : t === "center" ? n + e[3] / 2 - e[1] / 2 : n + e[3];
      }
      function X4(n) {
        var t = n.text;
        return t != null && (t += ""), t;
      }
      function GT(n) {
        return !!(n.backgroundColor || n.lineHeight || n.borderWidth && n.borderColor);
      }
      var Nt = ce(), UT = function(n, t, e, i) {
        if (i) {
          var r = Nt(i);
          r.dataIndex = e, r.dataType = t, r.seriesIndex = n, r.ssrType = "chart", i.type === "group" && i.traverse(function(a) {
            var o = Nt(a);
            o.seriesIndex = n, o.dataIndex = e, o.dataType = t, o.ssrType = "chart";
          });
        }
      }, $4 = 1, Z4 = {}, K4 = ce(), VT = ce(), jT = 0, av = 1, S1 = 2, $i = ["emphasis", "blur", "select"], ov = ["normal", "emphasis", "blur", "select"], Og = 10, wIt = 9, zh = "highlight", b1 = "downplay", sv = "select", T1 = "unselect", lv = "toggleSelect";
      function Qg(n) {
        return n != null && n !== "none";
      }
      function B1(n, t, e) {
        n.onHoverStateChange && (n.hoverState || 0) !== e && n.onHoverStateChange(t), n.hoverState = e;
      }
      function J4(n) {
        B1(n, "emphasis", S1);
      }
      function t8(n) {
        n.hoverState === S1 && B1(n, "normal", jT);
      }
      function qT(n) {
        B1(n, "blur", av);
      }
      function e8(n) {
        n.hoverState === av && B1(n, "normal", jT);
      }
      function CIt(n) {
        n.selected = true;
      }
      function SIt(n) {
        n.selected = false;
      }
      function n8(n, t, e) {
        t(n, e);
      }
      function Ys(n, t, e) {
        n8(n, t, e), n.isGroup && n.traverse(function(i) {
          n8(i, t, e);
        });
      }
      function M1(n, t) {
        switch (t) {
          case "emphasis":
            n.hoverState = S1;
            break;
          case "normal":
            n.hoverState = jT;
            break;
          case "blur":
            n.hoverState = av;
            break;
          case "select":
            n.selected = true;
        }
      }
      function bIt(n, t, e, i) {
        for (var r = n.style, a = {}, o = 0; o < t.length; o++) {
          var s = t[o], l = r[s];
          a[s] = l == null ? i && i[s] : l;
        }
        for (var o = 0; o < n.animators.length; o++) {
          var u = n.animators[o];
          u.__fromStateTransition && u.__fromStateTransition.indexOf(e) < 0 && u.targetName === "style" && u.saveTo(a, t);
        }
        return a;
      }
      function TIt(n, t, e, i) {
        var r = e && $t(e, "select") >= 0, a = false;
        if (n instanceof ne) {
          var o = K4(n), s = r && o.selectFill || o.normalFill, l = r && o.selectStroke || o.normalStroke;
          if (Qg(s) || Qg(l)) {
            i = i || {};
            var u = i.style || {};
            u.fill === "inherit" ? (a = true, i = X({}, i), u = X({}, u), u.fill = s) : !Qg(u.fill) && Qg(s) ? (a = true, i = X({}, i), u = X({}, u), u.fill = W2(s)) : !Qg(u.stroke) && Qg(l) && (a || (i = X({}, i), u = X({}, u)), u.stroke = W2(l)), i.style = u;
          }
        }
        if (i && i.z2 == null) {
          a || (i = X({}, i));
          var h = n.z2EmphasisLift;
          i.z2 = n.z2 + (h != null ? h : Og);
        }
        return i;
      }
      function BIt(n, t, e) {
        if (e && e.z2 == null) {
          e = X({}, e);
          var i = n.z2SelectLift;
          e.z2 = n.z2 + (i != null ? i : wIt);
        }
        return e;
      }
      function MIt(n, t, e) {
        var i = $t(n.currentStates, t) >= 0, r = n.style.opacity, a = i ? null : bIt(n, ["opacity"], t, { opacity: 1 });
        e = e || {};
        var o = e.style || {};
        return o.opacity == null && (e = X({}, e), o = X({ opacity: i ? r : a.opacity * 0.1 }, o), e.style = o), e;
      }
      function HT(n, t) {
        var e = this.states[n];
        if (this.style) {
          if (n === "emphasis") return TIt(this, n, t, e);
          if (n === "blur") return MIt(this, n, e);
          if (n === "select") return BIt(this, n, e);
        }
        return e;
      }
      function Gh(n) {
        n.stateProxy = HT;
        var t = n.getTextContent(), e = n.getTextGuideLine();
        t && (t.stateProxy = HT), e && (e.stateProxy = HT);
      }
      function i8(n, t) {
        !l8(n, t) && !n.__highByOuter && Ys(n, J4);
      }
      function r8(n, t) {
        !l8(n, t) && !n.__highByOuter && Ys(n, t8);
      }
      function Ws(n, t) {
        n.__highByOuter |= 1 << (t || 0), Ys(n, J4);
      }
      function Xs(n, t) {
        !(n.__highByOuter &= ~(1 << (t || 0))) && Ys(n, t8);
      }
      function a8(n) {
        Ys(n, qT);
      }
      function YT(n) {
        Ys(n, e8);
      }
      function o8(n) {
        Ys(n, CIt);
      }
      function s8(n) {
        Ys(n, SIt);
      }
      function l8(n, t) {
        return n.__highDownSilentOnTouch && t.zrByTouch;
      }
      function u8(n) {
        var t = n.getModel(), e = [], i = [];
        t.eachComponent(function(r, a) {
          var o = VT(a), s = r === "series", l = s ? n.getViewOfSeriesModel(a) : n.getViewOfComponentModel(a);
          !s && i.push(l), o.isBlured && (l.group.traverse(function(u) {
            e8(u);
          }), s && e.push(a)), o.isBlured = false;
        }), D(i, function(r) {
          r && r.toggleBlurSeries && r.toggleBlurSeries(e, false, t);
        });
      }
      function WT(n, t, e, i) {
        var r = i.getModel();
        e = e || "coordinateSystem";
        function a(u, h) {
          for (var c = 0; c < h.length; c++) {
            var f = u.getItemGraphicEl(h[c]);
            f && YT(f);
          }
        }
        if (n != null && !(!t || t === "none")) {
          var o = r.getSeriesByIndex(n), s = o.coordinateSystem;
          s && s.master && (s = s.master);
          var l = [];
          r.eachSeries(function(u) {
            var h = o === u, c = u.coordinateSystem;
            c && c.master && (c = c.master);
            var f = c && s ? c === s : h;
            if (!(e === "series" && !h || e === "coordinateSystem" && !f || t === "series" && h)) {
              var g = i.getViewOfSeriesModel(u);
              if (g.group.traverse(function(p) {
                p.__highByOuter && h && t === "self" || qT(p);
              }), Li(t)) a(u.getData(), t);
              else if (Et(t)) for (var d = oe(t), A = 0; A < d.length; A++) a(u.getData(d[A]), t[d[A]]);
              l.push(u), VT(u).isBlured = true;
            }
          }), r.eachComponent(function(u, h) {
            if (u !== "series") {
              var c = i.getViewOfComponentModel(h);
              c && c.toggleBlurSeries && c.toggleBlurSeries(l, true, r);
            }
          });
        }
      }
      function XT(n, t, e) {
        if (!(n == null || t == null)) {
          var i = e.getModel().getComponent(n, t);
          if (i) {
            VT(i).isBlured = true;
            var r = e.getViewOfComponentModel(i);
            !r || !r.focusBlurEnabled || r.group.traverse(function(a) {
              qT(a);
            });
          }
        }
      }
      function DIt(n, t, e) {
        var i = n.seriesIndex, r = n.getData(t.dataType);
        if (!r) {
          Ei("Unknown dataType " + t.dataType);
          return;
        }
        var a = Bh(r, t);
        a = (Z(a) ? a[0] : a) || 0;
        var o = r.getItemGraphicEl(a);
        if (!o) for (var s = r.count(), l = 0; !o && l < s; ) o = r.getItemGraphicEl(l++);
        if (o) {
          var u = Nt(o);
          WT(i, u.focus, u.blurScope, e);
        } else {
          var h = n.get(["emphasis", "focus"]), c = n.get(["emphasis", "blurScope"]);
          h != null && WT(i, h, c, e);
        }
      }
      function $T(n, t, e, i) {
        var r = { focusSelf: false, dispatchers: null };
        if (n == null || n === "series" || t == null || e == null) return r;
        var a = i.getModel().getComponent(n, t);
        if (!a) return r;
        var o = i.getViewOfComponentModel(a);
        if (!o || !o.findHighDownDispatchers) return r;
        for (var s = o.findHighDownDispatchers(e), l, u = 0; u < s.length; u++) if (!lu(s[u]) && Ei("param should be highDownDispatcher"), Nt(s[u]).focus === "self") {
          l = true;
          break;
        }
        return { focusSelf: l, dispatchers: s };
      }
      function RIt(n, t, e) {
        !lu(n) && Ei("param should be highDownDispatcher");
        var i = Nt(n), r = $T(i.componentMainType, i.componentIndex, i.componentHighDownName, e), a = r.dispatchers, o = r.focusSelf;
        a ? (o && XT(i.componentMainType, i.componentIndex, e), D(a, function(s) {
          return i8(s, t);
        })) : (WT(i.seriesIndex, i.focus, i.blurScope, e), i.focus === "self" && XT(i.componentMainType, i.componentIndex, e), i8(n, t));
      }
      function LIt(n, t, e) {
        !lu(n) && Ei("param should be highDownDispatcher"), u8(e);
        var i = Nt(n), r = $T(i.componentMainType, i.componentIndex, i.componentHighDownName, e).dispatchers;
        r ? D(r, function(a) {
          return r8(a, t);
        }) : r8(n, t);
      }
      function PIt(n, t, e) {
        if (KT(t)) {
          var i = t.dataType, r = n.getData(i), a = Bh(r, t);
          Z(a) || (a = [a]), n[t.type === lv ? "toggleSelect" : t.type === sv ? "select" : "unselect"](a, i);
        }
      }
      function h8(n) {
        var t = n.getAllData();
        D(t, function(e) {
          var i = e.data, r = e.type;
          i.eachItemGraphicEl(function(a, o) {
            n.isSelected(o, r) ? o8(a) : s8(a);
          });
        });
      }
      function NIt(n) {
        var t = [];
        return n.eachSeries(function(e) {
          var i = e.getAllData();
          D(i, function(r) {
            r.data;
            var a = r.type, o = e.getSelectedDataIndices();
            if (o.length > 0) {
              var s = { dataIndex: o, seriesIndex: e.seriesIndex };
              a != null && (s.dataType = a), t.push(s);
            }
          });
        }), t;
      }
      function Uh(n, t, e) {
        Vh(n, true), Ys(n, Gh), ZT(n, t, e);
      }
      function FIt(n) {
        Vh(n, false);
      }
      function pn(n, t, e, i) {
        i ? FIt(n) : Uh(n, t, e);
      }
      function ZT(n, t, e) {
        var i = Nt(n);
        t != null ? (i.focus = t, i.blurScope = e) : i.focus && (i.focus = null);
      }
      var c8 = ["emphasis", "blur", "select"], kIt = { itemStyle: "getItemStyle", lineStyle: "getLineStyle", areaStyle: "getAreaStyle" };
      function Ii(n, t, e, i) {
        e = e || "itemStyle";
        for (var r = 0; r < c8.length; r++) {
          var a = c8[r], o = t.getModel([a, e]), s = n.ensureState(a);
          s.style = i ? i(o) : o[kIt[e]]();
        }
      }
      function Vh(n, t) {
        var e = t === false, i = n;
        n.highDownSilentOnTouch && (i.__highDownSilentOnTouch = n.highDownSilentOnTouch), (!e || i.__highDownDispatcher) && (i.__highByOuter = i.__highByOuter || 0, i.__highDownDispatcher = !e);
      }
      function lu(n) {
        return !!(n && n.__highDownDispatcher);
      }
      function OIt(n, t, e) {
        var i = Nt(n);
        i.componentMainType = t.mainType, i.componentIndex = t.componentIndex, i.componentHighDownName = e;
      }
      function QIt(n) {
        var t = Z4[n];
        return t == null && $4 <= 32 && (t = Z4[n] = $4++), t;
      }
      function KT(n) {
        var t = n.type;
        return t === sv || t === T1 || t === lv;
      }
      function f8(n) {
        var t = n.type;
        return t === zh || t === b1;
      }
      function zIt(n) {
        var t = K4(n);
        t.normalFill = n.style.fill, t.normalStroke = n.style.stroke;
        var e = n.states.select || {};
        t.selectFill = e.style && e.style.fill || null, t.selectStroke = e.style && e.style.stroke || null;
      }
      var zg = $o.CMD, GIt = [[], [], []], g8 = Math.sqrt, UIt = Math.atan2;
      function d8(n, t) {
        if (t) {
          var e = n.data, i = n.len(), r, a, o, s, l, u, h = zg.M, c = zg.C, f = zg.L, g = zg.R, d = zg.A, A = zg.Q;
          for (o = 0, s = 0; o < i; ) {
            switch (r = e[o++], s = o, a = 0, r) {
              case h:
                a = 1;
                break;
              case f:
                a = 1;
                break;
              case c:
                a = 3;
                break;
              case A:
                a = 2;
                break;
              case d:
                var p = t[4], v = t[5], y = g8(t[0] * t[0] + t[1] * t[1]), m = g8(t[2] * t[2] + t[3] * t[3]), _ = UIt(-t[1] / m, t[0] / y);
                e[o] *= y, e[o++] += p, e[o] *= m, e[o++] += v, e[o++] *= y, e[o++] *= m, e[o++] += _, e[o++] += _, o += 2, s = o;
                break;
              case g:
                u[0] = e[o++], u[1] = e[o++], _i(u, u, t), e[s++] = u[0], e[s++] = u[1], u[0] += e[o++], u[1] += e[o++], _i(u, u, t), e[s++] = u[0], e[s++] = u[1];
            }
            for (l = 0; l < a; l++) {
              var I = GIt[l];
              I[0] = e[o++], I[1] = e[o++], _i(I, I, t), e[s++] = I[0], e[s++] = I[1];
            }
          }
          n.increaseVersion();
        }
      }
      var JT = Math.sqrt, D1 = Math.sin, R1 = Math.cos, uv = Math.PI;
      function A8(n) {
        return Math.sqrt(n[0] * n[0] + n[1] * n[1]);
      }
      function tB(n, t) {
        return (n[0] * t[0] + n[1] * t[1]) / (A8(n) * A8(t));
      }
      function p8(n, t) {
        return (n[0] * t[1] < n[1] * t[0] ? -1 : 1) * Math.acos(tB(n, t));
      }
      function v8(n, t, e, i, r, a, o, s, l, u, h) {
        var c = l * (uv / 180), f = R1(c) * (n - e) / 2 + D1(c) * (t - i) / 2, g = -1 * D1(c) * (n - e) / 2 + R1(c) * (t - i) / 2, d = f * f / (o * o) + g * g / (s * s);
        d > 1 && (o *= JT(d), s *= JT(d));
        var A = (r === a ? -1 : 1) * JT((o * o * (s * s) - o * o * (g * g) - s * s * (f * f)) / (o * o * (g * g) + s * s * (f * f))) || 0, p = A * o * g / s, v = A * -s * f / o, y = (n + e) / 2 + R1(c) * p - D1(c) * v, m = (t + i) / 2 + D1(c) * p + R1(c) * v, _ = p8([1, 0], [(f - p) / o, (g - v) / s]), I = [(f - p) / o, (g - v) / s], E = [(-1 * f - p) / o, (-1 * g - v) / s], x = p8(I, E);
        if (tB(I, E) <= -1 && (x = uv), tB(I, E) >= 1 && (x = 0), x < 0) {
          var w = Math.round(x / uv * 1e6) / 1e6;
          x = uv * 2 + w % 2 * uv;
        }
        h.addData(u, y, m, o, s, _, x, c, a);
      }
      var VIt = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, jIt = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
      function qIt(n) {
        var t = new $o();
        if (!n) return t;
        var e = 0, i = 0, r = e, a = i, o, s = $o.CMD, l = n.match(VIt);
        if (!l) return t;
        for (var u = 0; u < l.length; u++) {
          for (var h = l[u], c = h.charAt(0), f = void 0, g = h.match(jIt) || [], d = g.length, A = 0; A < d; A++) g[A] = parseFloat(g[A]);
          for (var p = 0; p < d; ) {
            var v = void 0, y = void 0, m = void 0, _ = void 0, I = void 0, E = void 0, x = void 0, w = e, C = i, S = void 0, b = void 0;
            switch (c) {
              case "l":
                e += g[p++], i += g[p++], f = s.L, t.addData(f, e, i);
                break;
              case "L":
                e = g[p++], i = g[p++], f = s.L, t.addData(f, e, i);
                break;
              case "m":
                e += g[p++], i += g[p++], f = s.M, t.addData(f, e, i), r = e, a = i, c = "l";
                break;
              case "M":
                e = g[p++], i = g[p++], f = s.M, t.addData(f, e, i), r = e, a = i, c = "L";
                break;
              case "h":
                e += g[p++], f = s.L, t.addData(f, e, i);
                break;
              case "H":
                e = g[p++], f = s.L, t.addData(f, e, i);
                break;
              case "v":
                i += g[p++], f = s.L, t.addData(f, e, i);
                break;
              case "V":
                i = g[p++], f = s.L, t.addData(f, e, i);
                break;
              case "C":
                f = s.C, t.addData(f, g[p++], g[p++], g[p++], g[p++], g[p++], g[p++]), e = g[p - 2], i = g[p - 1];
                break;
              case "c":
                f = s.C, t.addData(f, g[p++] + e, g[p++] + i, g[p++] + e, g[p++] + i, g[p++] + e, g[p++] + i), e += g[p - 2], i += g[p - 1];
                break;
              case "S":
                v = e, y = i, S = t.len(), b = t.data, o === s.C && (v += e - b[S - 4], y += i - b[S - 3]), f = s.C, w = g[p++], C = g[p++], e = g[p++], i = g[p++], t.addData(f, v, y, w, C, e, i);
                break;
              case "s":
                v = e, y = i, S = t.len(), b = t.data, o === s.C && (v += e - b[S - 4], y += i - b[S - 3]), f = s.C, w = e + g[p++], C = i + g[p++], e += g[p++], i += g[p++], t.addData(f, v, y, w, C, e, i);
                break;
              case "Q":
                w = g[p++], C = g[p++], e = g[p++], i = g[p++], f = s.Q, t.addData(f, w, C, e, i);
                break;
              case "q":
                w = g[p++] + e, C = g[p++] + i, e += g[p++], i += g[p++], f = s.Q, t.addData(f, w, C, e, i);
                break;
              case "T":
                v = e, y = i, S = t.len(), b = t.data, o === s.Q && (v += e - b[S - 4], y += i - b[S - 3]), e = g[p++], i = g[p++], f = s.Q, t.addData(f, v, y, e, i);
                break;
              case "t":
                v = e, y = i, S = t.len(), b = t.data, o === s.Q && (v += e - b[S - 4], y += i - b[S - 3]), e += g[p++], i += g[p++], f = s.Q, t.addData(f, v, y, e, i);
                break;
              case "A":
                m = g[p++], _ = g[p++], I = g[p++], E = g[p++], x = g[p++], w = e, C = i, e = g[p++], i = g[p++], f = s.A, v8(w, C, e, i, E, x, m, _, I, f, t);
                break;
              case "a":
                m = g[p++], _ = g[p++], I = g[p++], E = g[p++], x = g[p++], w = e, C = i, e += g[p++], i += g[p++], f = s.A, v8(w, C, e, i, E, x, m, _, I, f, t);
                break;
            }
          }
          (c === "z" || c === "Z") && (f = s.Z, t.addData(f), e = r, i = a), o = f;
        }
        return t.toStatic(), t;
      }
      var y8 = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.applyTransform = function(e) {
        }, t;
      }(ne);
      function m8(n) {
        return n.setData != null;
      }
      function _8(n, t) {
        var e = qIt(n), i = X({}, t);
        return i.buildPath = function(r) {
          if (m8(r)) {
            r.setData(e.data);
            var a = r.getContext();
            a && r.rebuildPath(a, 1);
          } else {
            var a = r;
            e.rebuildPath(a, 1);
          }
        }, i.applyTransform = function(r) {
          d8(e, r), this.dirtyShape();
        }, i;
      }
      function E8(n, t) {
        return new y8(_8(n, t));
      }
      function HIt(n, t) {
        var e = _8(n, t), i = function(r) {
          V(a, r);
          function a(o) {
            var s = r.call(this, o) || this;
            return s.applyTransform = e.applyTransform, s.buildPath = e.buildPath, s;
          }
          return a;
        }(y8);
        return i;
      }
      function YIt(n, t) {
        for (var e = [], i = n.length, r = 0; r < i; r++) {
          var a = n[r];
          e.push(a.getUpdatedPathProxy(true));
        }
        var o = new ne(t);
        return o.createPathProxy(), o.buildPath = function(s) {
          if (m8(s)) {
            s.appendPath(e);
            var l = s.getContext();
            l && s.rebuildPath(l, 1);
          }
        }, o;
      }
      function eB(n, t) {
        t = t || {};
        var e = new ne();
        return n.shape && e.setShape(n.shape), e.setStyle(n.style), t.bakeTransform ? d8(e.path, n.getComputedTransform()) : t.toLocal ? e.setLocalTransform(n.getComputedTransform()) : e.copyTransform(n), e.buildPath = n.buildPath, e.applyTransform = e.applyTransform, e.z = n.z, e.z2 = n.z2, e.zlevel = n.zlevel, e;
      }
      var WIt = /* @__PURE__ */ function() {
        function n() {
          this.cx = 0, this.cy = 0, this.r = 0;
        }
        return n;
      }(), $s = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultShape = function() {
          return new WIt();
        }, t.prototype.buildPath = function(e, i) {
          e.moveTo(i.cx + i.r, i.cy), e.arc(i.cx, i.cy, i.r, 0, Math.PI * 2);
        }, t;
      }(ne);
      $s.prototype.type = "circle";
      var XIt = /* @__PURE__ */ function() {
        function n() {
          this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
        }
        return n;
      }(), L1 = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultShape = function() {
          return new XIt();
        }, t.prototype.buildPath = function(e, i) {
          var r = 0.5522848, a = i.cx, o = i.cy, s = i.rx, l = i.ry, u = s * r, h = l * r;
          e.moveTo(a - s, o), e.bezierCurveTo(a - s, o - h, a - u, o - l, a, o - l), e.bezierCurveTo(a + u, o - l, a + s, o - h, a + s, o), e.bezierCurveTo(a + s, o + h, a + u, o + l, a, o + l), e.bezierCurveTo(a - u, o + l, a - s, o + h, a - s, o), e.closePath();
        }, t;
      }(ne);
      L1.prototype.type = "ellipse";
      var I8 = Math.PI, nB = I8 * 2, jh = Math.sin, Gg = Math.cos, $It = Math.acos, Pi = Math.atan2, x8 = Math.abs, hv = Math.sqrt, cv = Math.max, Zo = Math.min, Ja = 1e-4;
      function ZIt(n, t, e, i, r, a, o, s) {
        var l = e - n, u = i - t, h = o - r, c = s - a, f = c * l - h * u;
        if (!(f * f < Ja)) return f = (h * (t - a) - c * (n - r)) / f, [n + f * l, t + f * u];
      }
      function P1(n, t, e, i, r, a, o) {
        var s = n - e, l = t - i, u = (o ? a : -a) / hv(s * s + l * l), h = u * l, c = -u * s, f = n + h, g = t + c, d = e + h, A = i + c, p = (f + d) / 2, v = (g + A) / 2, y = d - f, m = A - g, _ = y * y + m * m, I = r - a, E = f * A - d * g, x = (m < 0 ? -1 : 1) * hv(cv(0, I * I * _ - E * E)), w = (E * m - y * x) / _, C = (-E * y - m * x) / _, S = (E * m + y * x) / _, b = (-E * y + m * x) / _, T = w - p, B = C - v, R = S - p, M = b - v;
        return T * T + B * B > R * R + M * M && (w = S, C = b), { cx: w, cy: C, x0: -h, y0: -c, x1: w * (r / I - 1), y1: C * (r / I - 1) };
      }
      function KIt(n) {
        var t;
        if (Z(n)) {
          var e = n.length;
          if (!e) return n;
          e === 1 ? t = [n[0], n[0], 0, 0] : e === 2 ? t = [n[0], n[0], n[1], n[1]] : e === 3 ? t = n.concat(n[2]) : t = n;
        } else t = [n, n, n, n];
        return t;
      }
      function JIt(n, t) {
        var e, i = cv(t.r, 0), r = cv(t.r0 || 0, 0), a = i > 0, o = r > 0;
        if (!(!a && !o)) {
          if (a || (i = r, r = 0), r > i) {
            var s = i;
            i = r, r = s;
          }
          var l = t.startAngle, u = t.endAngle;
          if (!(isNaN(l) || isNaN(u))) {
            var h = t.cx, c = t.cy, f = !!t.clockwise, g = x8(u - l), d = g > nB && g % nB;
            if (d > Ja && (g = d), !(i > Ja)) n.moveTo(h, c);
            else if (g > nB - Ja) n.moveTo(h + i * Gg(l), c + i * jh(l)), n.arc(h, c, i, l, u, !f), r > Ja && (n.moveTo(h + r * Gg(u), c + r * jh(u)), n.arc(h, c, r, u, l, f));
            else {
              var A = void 0, p = void 0, v = void 0, y = void 0, m = void 0, _ = void 0, I = void 0, E = void 0, x = void 0, w = void 0, C = void 0, S = void 0, b = void 0, T = void 0, B = void 0, R = void 0, M = i * Gg(l), L = i * jh(l), N = r * Gg(u), F = r * jh(u), k = g > Ja;
              if (k) {
                var O = t.cornerRadius;
                O && (e = KIt(O), A = e[0], p = e[1], v = e[2], y = e[3]);
                var Q = x8(i - r) / 2;
                if (m = Zo(Q, v), _ = Zo(Q, y), I = Zo(Q, A), E = Zo(Q, p), C = x = cv(m, _), S = w = cv(I, E), (x > Ja || w > Ja) && (b = i * Gg(u), T = i * jh(u), B = r * Gg(l), R = r * jh(l), g < I8)) {
                  var j = ZIt(M, L, B, R, b, T, N, F);
                  if (j) {
                    var Y = M - j[0], G = L - j[1], $ = b - j[0], J = T - j[1], et = 1 / jh($It((Y * $ + G * J) / (hv(Y * Y + G * G) * hv($ * $ + J * J))) / 2), nt = hv(j[0] * j[0] + j[1] * j[1]);
                    C = Zo(x, (i - nt) / (et + 1)), S = Zo(w, (r - nt) / (et - 1));
                  }
                }
              }
              if (!k) n.moveTo(h + M, c + L);
              else if (C > Ja) {
                var gt = Zo(v, C), q = Zo(y, C), W = P1(B, R, M, L, i, gt, f), it = P1(b, T, N, F, i, q, f);
                n.moveTo(h + W.cx + W.x0, c + W.cy + W.y0), C < x && gt === q ? n.arc(h + W.cx, c + W.cy, C, Pi(W.y0, W.x0), Pi(it.y0, it.x0), !f) : (gt > 0 && n.arc(h + W.cx, c + W.cy, gt, Pi(W.y0, W.x0), Pi(W.y1, W.x1), !f), n.arc(h, c, i, Pi(W.cy + W.y1, W.cx + W.x1), Pi(it.cy + it.y1, it.cx + it.x1), !f), q > 0 && n.arc(h + it.cx, c + it.cy, q, Pi(it.y1, it.x1), Pi(it.y0, it.x0), !f));
              } else n.moveTo(h + M, c + L), n.arc(h, c, i, l, u, !f);
              if (!(r > Ja) || !k) n.lineTo(h + N, c + F);
              else if (S > Ja) {
                var gt = Zo(A, S), q = Zo(p, S), W = P1(N, F, b, T, r, -q, f), it = P1(M, L, B, R, r, -gt, f);
                n.lineTo(h + W.cx + W.x0, c + W.cy + W.y0), S < w && gt === q ? n.arc(h + W.cx, c + W.cy, S, Pi(W.y0, W.x0), Pi(it.y0, it.x0), !f) : (q > 0 && n.arc(h + W.cx, c + W.cy, q, Pi(W.y0, W.x0), Pi(W.y1, W.x1), !f), n.arc(h, c, r, Pi(W.cy + W.y1, W.cx + W.x1), Pi(it.cy + it.y1, it.cx + it.x1), f), gt > 0 && n.arc(h + it.cx, c + it.cy, gt, Pi(it.y1, it.x1), Pi(it.y0, it.x0), !f));
              } else n.lineTo(h + N, c + F), n.arc(h, c, r, u, l, f);
            }
            n.closePath();
          }
        }
      }
      var txt = /* @__PURE__ */ function() {
        function n() {
          this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true, this.cornerRadius = 0;
        }
        return n;
      }(), Zi = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultShape = function() {
          return new txt();
        }, t.prototype.buildPath = function(e, i) {
          JIt(e, i);
        }, t.prototype.isZeroArea = function() {
          return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
        }, t;
      }(ne);
      Zi.prototype.type = "sector";
      var ext = /* @__PURE__ */ function() {
        function n() {
          this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
        }
        return n;
      }(), fv = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultShape = function() {
          return new ext();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.cx, a = i.cy, o = Math.PI * 2;
          e.moveTo(r + i.r, a), e.arc(r, a, i.r, 0, o, false), e.moveTo(r + i.r0, a), e.arc(r, a, i.r0, 0, o, true);
        }, t;
      }(ne);
      fv.prototype.type = "ring";
      function nxt(n, t, e, i) {
        var r = [], a = [], o = [], s = [], l, u, h, c;
        if (i) {
          h = [1 / 0, 1 / 0], c = [-1 / 0, -1 / 0];
          for (var f = 0, g = n.length; f < g; f++) Zl(h, h, n[f]), Kl(c, c, n[f]);
          Zl(h, h, i[0]), Kl(c, c, i[1]);
        }
        for (var f = 0, g = n.length; f < g; f++) {
          var d = n[f];
          if (e) l = n[f ? f - 1 : g - 1], u = n[(f + 1) % g];
          else if (f === 0 || f === g - 1) {
            r.push(Os(n[f]));
            continue;
          } else l = n[f - 1], u = n[f + 1];
          yh(a, u, l), V_(a, a, t);
          var A = C2(d, l), p = C2(d, u), v = A + p;
          v !== 0 && (A /= v, p /= v), V_(o, a, -A), V_(s, a, p);
          var y = r5([], d, o), m = r5([], d, s);
          i && (Kl(y, y, h), Zl(y, y, c), Kl(m, m, h), Zl(m, m, c)), r.push(y), r.push(m);
        }
        return e && r.push(r.shift()), r;
      }
      function w8(n, t, e) {
        var i = t.smooth, r = t.points;
        if (r && r.length >= 2) {
          if (i) {
            var a = nxt(r, i, e, t.smoothConstraint);
            n.moveTo(r[0][0], r[0][1]);
            for (var o = r.length, s = 0; s < (e ? o : o - 1); s++) {
              var l = a[s * 2], u = a[s * 2 + 1], h = r[(s + 1) % o];
              n.bezierCurveTo(l[0], l[1], u[0], u[1], h[0], h[1]);
            }
          } else {
            n.moveTo(r[0][0], r[0][1]);
            for (var s = 1, c = r.length; s < c; s++) n.lineTo(r[s][0], r[s][1]);
          }
          e && n.closePath();
        }
      }
      var ixt = /* @__PURE__ */ function() {
        function n() {
          this.points = null, this.smooth = 0, this.smoothConstraint = null;
        }
        return n;
      }(), Ki = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultShape = function() {
          return new ixt();
        }, t.prototype.buildPath = function(e, i) {
          w8(e, i, true);
        }, t;
      }(ne);
      Ki.prototype.type = "polygon";
      var rxt = /* @__PURE__ */ function() {
        function n() {
          this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
        }
        return n;
      }(), Ji = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new rxt();
        }, t.prototype.buildPath = function(e, i) {
          w8(e, i, false);
        }, t;
      }(ne);
      Ji.prototype.type = "polyline";
      var axt = {}, oxt = /* @__PURE__ */ function() {
        function n() {
          this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
        }
        return n;
      }(), Kn = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new oxt();
        }, t.prototype.buildPath = function(e, i) {
          var r, a, o, s;
          if (this.subPixelOptimize) {
            var l = k4(axt, i, this.style);
            r = l.x1, a = l.y1, o = l.x2, s = l.y2;
          } else r = i.x1, a = i.y1, o = i.x2, s = i.y2;
          var u = i.percent;
          u !== 0 && (e.moveTo(r, a), u < 1 && (o = r * (1 - u) + o * u, s = a * (1 - u) + s * u), e.lineTo(o, s));
        }, t.prototype.pointAt = function(e) {
          var i = this.shape;
          return [i.x1 * (1 - e) + i.x2 * e, i.y1 * (1 - e) + i.y2 * e];
        }, t;
      }(ne);
      Kn.prototype.type = "line";
      var Cr = [], sxt = /* @__PURE__ */ function() {
        function n() {
          this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
        }
        return n;
      }();
      function C8(n, t, e) {
        var i = n.cpx2, r = n.cpy2;
        return i != null || r != null ? [(e ? x5 : Zn)(n.x1, n.cpx1, n.cpx2, n.x2, t), (e ? x5 : Zn)(n.y1, n.cpy1, n.cpy2, n.y2, t)] : [(e ? z2 : fi)(n.x1, n.cpx1, n.x2, t), (e ? z2 : fi)(n.y1, n.cpy1, n.y2, t)];
      }
      var gv = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new sxt();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.x1, a = i.y1, o = i.x2, s = i.y2, l = i.cpx1, u = i.cpy1, h = i.cpx2, c = i.cpy2, f = i.percent;
          f !== 0 && (e.moveTo(r, a), h == null || c == null ? (f < 1 && (Up(r, l, o, f, Cr), l = Cr[1], o = Cr[2], Up(a, u, s, f, Cr), u = Cr[1], s = Cr[2]), e.quadraticCurveTo(l, u, o, s)) : (f < 1 && (eu(r, l, h, o, f, Cr), l = Cr[1], h = Cr[2], o = Cr[3], eu(a, u, c, s, f, Cr), u = Cr[1], c = Cr[2], s = Cr[3]), e.bezierCurveTo(l, u, h, c, o, s)));
        }, t.prototype.pointAt = function(e) {
          return C8(this.shape, e, false);
        }, t.prototype.tangentAt = function(e) {
          var i = C8(this.shape, e, true);
          return wg(i, i);
        }, t;
      }(ne);
      gv.prototype.type = "bezier-curve";
      var lxt = /* @__PURE__ */ function() {
        function n() {
          this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true;
        }
        return n;
      }(), N1 = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new lxt();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.cx, a = i.cy, o = Math.max(i.r, 0), s = i.startAngle, l = i.endAngle, u = i.clockwise, h = Math.cos(s), c = Math.sin(s);
          e.moveTo(h * o + r, c * o + a), e.arc(r, a, o, s, l, !u);
        }, t;
      }(ne);
      N1.prototype.type = "arc";
      var iB = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "compound", e;
        }
        return t.prototype._updatePathDirty = function() {
          for (var e = this.shape.paths, i = this.shapeChanged(), r = 0; r < e.length; r++) i = i || e[r].shapeChanged();
          i && this.dirtyShape();
        }, t.prototype.beforeBrush = function() {
          this._updatePathDirty();
          for (var e = this.shape.paths || [], i = this.getGlobalScale(), r = 0; r < e.length; r++) e[r].path || e[r].createPathProxy(), e[r].path.setScale(i[0], i[1], e[r].segmentIgnoreThreshold);
        }, t.prototype.buildPath = function(e, i) {
          for (var r = i.paths || [], a = 0; a < r.length; a++) r[a].buildPath(e, r[a].shape, true);
        }, t.prototype.afterBrush = function() {
          for (var e = this.shape.paths || [], i = 0; i < e.length; i++) e[i].pathUpdated();
        }, t.prototype.getBoundingRect = function() {
          return this._updatePathDirty.call(this), ne.prototype.getBoundingRect.call(this);
        }, t;
      }(ne), S8 = function() {
        function n(t) {
          this.colorStops = t || [];
        }
        return n.prototype.addColorStop = function(t, e) {
          this.colorStops.push({ offset: t, color: e });
        }, n;
      }(), dv = function(n) {
        V(t, n);
        function t(e, i, r, a, o, s) {
          var l = n.call(this, o) || this;
          return l.x = e == null ? 0 : e, l.y = i == null ? 0 : i, l.x2 = r == null ? 1 : r, l.y2 = a == null ? 0 : a, l.type = "linear", l.global = s || false, l;
        }
        return t;
      }(S8), b8 = function(n) {
        V(t, n);
        function t(e, i, r, a, o) {
          var s = n.call(this, a) || this;
          return s.x = e == null ? 0.5 : e, s.y = i == null ? 0.5 : i, s.r = r == null ? 0.5 : r, s.type = "radial", s.global = o || false, s;
        }
        return t;
      }(S8), qh = [0, 0], Hh = [0, 0], F1 = new jt(), k1 = new jt(), O1 = function() {
        function n(t, e) {
          this._corners = [], this._axes = [], this._origin = [0, 0];
          for (var i = 0; i < 4; i++) this._corners[i] = new jt();
          for (var i = 0; i < 2; i++) this._axes[i] = new jt();
          t && this.fromBoundingRect(t, e);
        }
        return n.prototype.fromBoundingRect = function(t, e) {
          var i = this._corners, r = this._axes, a = t.x, o = t.y, s = a + t.width, l = o + t.height;
          if (i[0].set(a, o), i[1].set(s, o), i[2].set(s, l), i[3].set(a, l), e) for (var u = 0; u < 4; u++) i[u].transform(e);
          jt.sub(r[0], i[1], i[0]), jt.sub(r[1], i[3], i[0]), r[0].normalize(), r[1].normalize();
          for (var u = 0; u < 2; u++) this._origin[u] = r[u].dot(i[0]);
        }, n.prototype.intersect = function(t, e) {
          var i = true, r = !e;
          return F1.set(1 / 0, 1 / 0), k1.set(0, 0), !this._intersectCheckOneSide(this, t, F1, k1, r, 1) && (i = false, r) || !this._intersectCheckOneSide(t, this, F1, k1, r, -1) && (i = false, r) || r || jt.copy(e, i ? F1 : k1), i;
        }, n.prototype._intersectCheckOneSide = function(t, e, i, r, a, o) {
          for (var s = true, l = 0; l < 2; l++) {
            var u = this._axes[l];
            if (this._getProjMinMaxOnAxis(l, t._corners, qh), this._getProjMinMaxOnAxis(l, e._corners, Hh), qh[1] < Hh[0] || qh[0] > Hh[1]) {
              if (s = false, a) return s;
              var h = Math.abs(Hh[0] - qh[1]), c = Math.abs(qh[0] - Hh[1]);
              Math.min(h, c) > r.len() && (h < c ? jt.scale(r, u, -h * o) : jt.scale(r, u, c * o));
            } else if (i) {
              var h = Math.abs(Hh[0] - qh[1]), c = Math.abs(qh[0] - Hh[1]);
              Math.min(h, c) < i.len() && (h < c ? jt.scale(i, u, h * o) : jt.scale(i, u, -c * o));
            }
          }
          return s;
        }, n.prototype._getProjMinMaxOnAxis = function(t, e, i) {
          for (var r = this._axes[t], a = this._origin, o = e[0].dot(r) + a[t], s = o, l = o, u = 1; u < e.length; u++) {
            var h = e[u].dot(r) + a[t];
            s = Math.min(h, s), l = Math.max(h, l);
          }
          i[0] = s, i[1] = l;
        }, n;
      }(), uxt = [], hxt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.notClear = true, e.incremental = true, e._displayables = [], e._temporaryDisplayables = [], e._cursor = 0, e;
        }
        return t.prototype.traverse = function(e, i) {
          e.call(i, this);
        }, t.prototype.useStyle = function() {
          this.style = {};
        }, t.prototype.getCursor = function() {
          return this._cursor;
        }, t.prototype.innerAfterBrush = function() {
          this._cursor = this._displayables.length;
        }, t.prototype.clearDisplaybles = function() {
          this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = false;
        }, t.prototype.clearTemporalDisplayables = function() {
          this._temporaryDisplayables = [];
        }, t.prototype.addDisplayable = function(e, i) {
          i ? this._temporaryDisplayables.push(e) : this._displayables.push(e), this.markRedraw();
        }, t.prototype.addDisplayables = function(e, i) {
          i = i || false;
          for (var r = 0; r < e.length; r++) this.addDisplayable(e[r], i);
        }, t.prototype.getDisplayables = function() {
          return this._displayables;
        }, t.prototype.getTemporalDisplayables = function() {
          return this._temporaryDisplayables;
        }, t.prototype.eachPendingDisplayable = function(e) {
          for (var i = this._cursor; i < this._displayables.length; i++) e && e(this._displayables[i]);
          for (var i = 0; i < this._temporaryDisplayables.length; i++) e && e(this._temporaryDisplayables[i]);
        }, t.prototype.update = function() {
          this.updateTransform();
          for (var e = this._cursor; e < this._displayables.length; e++) {
            var i = this._displayables[e];
            i.parent = this, i.update(), i.parent = null;
          }
          for (var e = 0; e < this._temporaryDisplayables.length; e++) {
            var i = this._temporaryDisplayables[e];
            i.parent = this, i.update(), i.parent = null;
          }
        }, t.prototype.getBoundingRect = function() {
          if (!this._rect) {
            for (var e = new Wt(1 / 0, 1 / 0, -1 / 0, -1 / 0), i = 0; i < this._displayables.length; i++) {
              var r = this._displayables[i], a = r.getBoundingRect().clone();
              r.needLocalTransform() && a.applyTransform(r.getLocalTransform(uxt)), e.union(a);
            }
            this._rect = e;
          }
          return this._rect;
        }, t.prototype.contain = function(e, i) {
          var r = this.transformCoordToLocal(e, i), a = this.getBoundingRect();
          if (a.contain(r[0], r[1])) for (var o = 0; o < this._displayables.length; o++) {
            var s = this._displayables[o];
            if (s.contain(e, i)) return true;
          }
          return false;
        }, t;
      }(ya), T8 = ce();
      function Ug(n, t, e, i, r) {
        var a;
        if (t && t.ecModel) {
          var o = t.ecModel.getUpdatePayload();
          a = o && o.animation;
        }
        var s = t && t.isAnimationEnabled(), l = n === "update";
        if (s) {
          var u = void 0, h = void 0, c = void 0;
          i ? (u = kt(i.duration, 200), h = kt(i.easing, "cubicOut"), c = 0) : (u = t.getShallow(l ? "animationDurationUpdate" : "animationDuration"), h = t.getShallow(l ? "animationEasingUpdate" : "animationEasing"), c = t.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (h = a.easing), a.delay != null && (c = a.delay)), yt(c) && (c = c(e, r)), yt(u) && (u = u(e));
          var f = { duration: u || 0, delay: c, easing: h };
          return f;
        } else return null;
      }
      function rB(n, t, e, i, r, a, o) {
        var s = false, l;
        yt(r) ? (o = a, a = r, r = null) : Et(r) && (a = r.cb, o = r.during, s = r.isFrom, l = r.removeOpt, r = r.dataIndex);
        var u = n === "leave";
        u || t.stopAnimation("leave");
        var h = Ug(n, i, r, u ? l || {} : null, i && i.getAnimationDelayParams ? i.getAnimationDelayParams(t, r) : null);
        if (h && h.duration > 0) {
          var c = h.duration, f = h.delay, g = h.easing, d = { duration: c, delay: f || 0, easing: g, done: a, force: !!a || !!o, setToFinal: !u, scope: n, during: o };
          s ? t.animateFrom(e, d) : t.animateTo(e, d);
        } else t.stopAnimation(), !s && t.attr(e), o && o(1), a && a();
      }
      function Ee(n, t, e, i, r, a) {
        rB("update", n, t, e, i, r, a);
      }
      function on(n, t, e, i, r, a) {
        rB("enter", n, t, e, i, r, a);
      }
      function Vg(n) {
        if (!n.__zr) return true;
        for (var t = 0; t < n.animators.length; t++) {
          var e = n.animators[t];
          if (e.scope === "leave") return true;
        }
        return false;
      }
      function uu(n, t, e, i, r, a) {
        Vg(n) || rB("leave", n, t, e, i, r, a);
      }
      function B8(n, t, e, i) {
        n.removeTextContent(), n.removeTextGuideLine(), uu(n, { style: { opacity: 0 } }, t, e, i);
      }
      function Av(n, t, e) {
        function i() {
          n.parent && n.parent.remove(n);
        }
        n.isGroup ? n.traverse(function(r) {
          r.isGroup || B8(r, t, e, i);
        }) : B8(n, t, e, i);
      }
      function to(n) {
        T8(n).oldStyle = n.style;
      }
      function cxt(n) {
        return T8(n).oldStyle;
      }
      var Q1 = Math.max, z1 = Math.min, aB = {};
      function fxt(n) {
        return ne.extend(n);
      }
      var gxt = HIt;
      function dxt(n, t) {
        return gxt(n, t);
      }
      function eo(n, t) {
        aB[n] = t;
      }
      function oB(n) {
        if (aB.hasOwnProperty(n)) return aB[n];
      }
      function G1(n, t, e, i) {
        var r = E8(n, t);
        return e && (i === "center" && (e = D8(e, r.getBoundingRect())), R8(r, e)), r;
      }
      function M8(n, t, e) {
        var i = new gi({ style: { image: n, x: t.x, y: t.y, width: t.width, height: t.height }, onload: function(r) {
          if (e === "center") {
            var a = { width: r.width, height: r.height };
            i.setStyle(D8(t, a));
          }
        } });
        return i;
      }
      function D8(n, t) {
        var e = t.width / t.height, i = n.height * e, r;
        i <= n.width ? r = n.height : (i = n.width, r = i / e);
        var a = n.x + n.width / 2, o = n.y + n.height / 2;
        return { x: a - i / 2, y: o - r / 2, width: i, height: r };
      }
      var _a = YIt;
      function R8(n, t) {
        if (n.applyTransform) {
          var e = n.getBoundingRect(), i = e.calculateTransform(t);
          n.applyTransform(i);
        }
      }
      function jg(n, t) {
        return k4(n, n, { lineWidth: t }), n;
      }
      function Axt(n) {
        return O4(n.shape, n.shape, n.style), n;
      }
      var U1 = Qh;
      function Yh(n, t) {
        for (var e = q_([]); n && n !== t; ) zs(e, n.getLocalTransform(), e), n = n.parent;
        return e;
      }
      function no(n, t, e) {
        return t && !Li(t) && (t = Vs.getLocalTransform(t)), e && (t = Sg([], t)), _i([], n, t);
      }
      function V1(n, t, e) {
        var i = t[4] === 0 || t[5] === 0 || t[0] === 0 ? 1 : Math.abs(2 * t[4] / t[0]), r = t[4] === 0 || t[5] === 0 || t[2] === 0 ? 1 : Math.abs(2 * t[4] / t[2]), a = [n === "left" ? -i : n === "right" ? i : 0, n === "top" ? -r : n === "bottom" ? r : 0];
        return a = no(a, t, e), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
      }
      function L8(n) {
        return !n.isGroup;
      }
      function pxt(n) {
        return n.shape != null;
      }
      function pv(n, t, e) {
        if (!n || !t) return;
        function i(o) {
          var s = {};
          return o.traverse(function(l) {
            L8(l) && l.anid && (s[l.anid] = l);
          }), s;
        }
        function r(o) {
          var s = { x: o.x, y: o.y, rotation: o.rotation };
          return pxt(o) && (s.shape = X({}, o.shape)), s;
        }
        var a = i(n);
        t.traverse(function(o) {
          if (L8(o) && o.anid) {
            var s = a[o.anid];
            if (s) {
              var l = r(o);
              o.attr(r(s)), Ee(o, l, e, Nt(o).dataIndex);
            }
          }
        });
      }
      function P8(n, t) {
        return K(n, function(e) {
          var i = e[0];
          i = Q1(i, t.x), i = z1(i, t.x + t.width);
          var r = e[1];
          return r = Q1(r, t.y), r = z1(r, t.y + t.height), [i, r];
        });
      }
      function vxt(n, t) {
        var e = Q1(n.x, t.x), i = z1(n.x + n.width, t.x + t.width), r = Q1(n.y, t.y), a = z1(n.y + n.height, t.y + t.height);
        if (i >= e && a >= r) return { x: e, y: r, width: i - e, height: a - r };
      }
      function vv(n, t, e) {
        var i = X({ rectHover: true }, t), r = i.style = { strokeNoScale: true };
        if (e = e || { x: -1, y: -1, width: 2, height: 2 }, n) return n.indexOf("image://") === 0 ? (r.image = n.slice(8), wt(r, e), new gi(i)) : G1(n.replace("path://", ""), i, e, "center");
      }
      function yv(n, t, e, i, r) {
        for (var a = 0, o = r[r.length - 1]; a < r.length; a++) {
          var s = r[a];
          if (N8(n, t, e, i, s[0], s[1], o[0], o[1])) return true;
          o = s;
        }
      }
      function N8(n, t, e, i, r, a, o, s) {
        var l = e - n, u = i - t, h = o - r, c = s - a, f = sB(h, c, l, u);
        if (yxt(f)) return false;
        var g = n - r, d = t - a, A = sB(g, d, l, u) / f;
        if (A < 0 || A > 1) return false;
        var p = sB(g, d, h, c) / f;
        return !(p < 0 || p > 1);
      }
      function sB(n, t, e, i) {
        return n * i - e * t;
      }
      function yxt(n) {
        return n <= 1e-6 && n >= -1e-6;
      }
      function qg(n) {
        var t = n.itemTooltipOption, e = n.componentModel, i = n.itemName, r = ht(t) ? { formatter: t } : t, a = e.mainType, o = e.componentIndex, s = { componentType: a, name: i, $vars: ["name"] };
        s[a + "Index"] = o;
        var l = n.formatterParamsExtra;
        l && D(oe(l), function(h) {
          ft(s, h) || (s[h] = l[h], s.$vars.push(h));
        });
        var u = Nt(n.el);
        u.componentMainType = a, u.componentIndex = o, u.tooltipConfig = { name: i, option: wt({ content: i, encodeHTMLContent: true, formatterParams: s }, r) };
      }
      function F8(n, t) {
        var e;
        n.isGroup && (e = t(n)), e || n.traverse(t);
      }
      function hu(n, t) {
        if (n) if (Z(n)) for (var e = 0; e < n.length; e++) F8(n[e], t);
        else F8(n, t);
      }
      eo("circle", $s), eo("ellipse", L1), eo("sector", Zi), eo("ring", fv), eo("polygon", Ki), eo("polyline", Ji), eo("rect", fe), eo("line", Kn), eo("bezierCurve", gv), eo("arc", N1);
      const Wh = Object.freeze(Object.defineProperty({ __proto__: null, Arc: N1, BezierCurve: gv, BoundingRect: Wt, Circle: $s, CompoundPath: iB, Ellipse: L1, Group: Dt, Image: gi, IncrementalDisplayable: hxt, Line: Kn, LinearGradient: dv, OrientedBoundingRect: O1, Path: ne, Point: jt, Polygon: Ki, Polyline: Ji, RadialGradient: b8, Rect: fe, Ring: fv, Sector: Zi, Text: Ae, applyTransform: no, clipPointsByRect: P8, clipRectByRect: vxt, createIcon: vv, extendPath: dxt, extendShape: fxt, getShapeClass: oB, getTransform: Yh, groupTransition: pv, initProps: on, isElementRemoved: Vg, lineLineIntersect: N8, linePolygonIntersect: yv, makeImage: M8, makePath: G1, mergePath: _a, registerShape: eo, removeElement: uu, removeElementWithFadeOut: Av, resizePath: R8, setTooltipConfig: qg, subPixelOptimize: U1, subPixelOptimizeLine: jg, subPixelOptimizeRect: Axt, transformDirection: V1, traverseElements: hu, updateProps: Ee }, Symbol.toStringTag, { value: "Module" }));
      var j1 = {};
      function k8(n, t) {
        for (var e = 0; e < $i.length; e++) {
          var i = $i[e], r = t[i], a = n.ensureState(i);
          a.style = a.style || {}, a.style.text = r;
        }
        var o = n.currentStates.slice();
        n.clearStates(true), n.setStyle({ text: t.normal }), n.useStates(o, true);
      }
      function lB(n, t, e) {
        var i = n.labelFetcher, r = n.labelDataIndex, a = n.labelDimIndex, o = t.normal, s;
        i && (s = i.getFormattedLabel(r, "normal", null, a, o && o.get("formatter"), e != null ? { interpolatedValue: e } : null)), s == null && (s = yt(n.defaultText) ? n.defaultText(r, n, e) : n.defaultText);
        for (var l = { normal: s }, u = 0; u < $i.length; u++) {
          var h = $i[u], c = t[h];
          l[h] = kt(i ? i.getFormattedLabel(r, h, null, a, c && c.get("formatter")) : null, s);
        }
        return l;
      }
      function xi(n, t, e, i) {
        e = e || j1;
        for (var r = n instanceof Ae, a = false, o = 0; o < ov.length; o++) {
          var s = t[ov[o]];
          if (s && s.getShallow("show")) {
            a = true;
            break;
          }
        }
        var l = r ? n : n.getTextContent();
        if (a) {
          r || (l || (l = new Ae(), n.setTextContent(l)), n.stateProxy && (l.stateProxy = n.stateProxy));
          var u = lB(e, t), h = t.normal, c = !!h.getShallow("show"), f = Je(h, i && i.normal, e, false, !r);
          f.text = u.normal, r || n.setTextConfig(q1(h, e, false));
          for (var o = 0; o < $i.length; o++) {
            var g = $i[o], s = t[g];
            if (s) {
              var d = l.ensureState(g), A = !!kt(s.getShallow("show"), c);
              if (A !== c && (d.ignore = !A), d.style = Je(s, i && i[g], e, true, !r), d.style.text = u[g], !r) {
                var p = n.ensureState(g);
                p.textConfig = q1(s, e, true);
              }
            }
          }
          l.silent = !!h.getShallow("silent"), l.style.x != null && (f.x = l.style.x), l.style.y != null && (f.y = l.style.y), l.ignore = !c, l.useStyle(f), l.dirty(), e.enableTextSetter && (Hg(l).setLabelText = function(v) {
            var y = lB(e, t, v);
            k8(l, y);
          });
        } else l && (l.ignore = true);
        n.dirty();
      }
      function Jn(n, t) {
        t = t || "label";
        for (var e = { normal: n.getModel(t) }, i = 0; i < $i.length; i++) {
          var r = $i[i];
          e[r] = n.getModel([r, t]);
        }
        return e;
      }
      function Je(n, t, e, i, r) {
        var a = {};
        return mxt(a, n, e, i, r), t && X(a, t), a;
      }
      function q1(n, t, e) {
        t = t || {};
        var i = {}, r, a = n.getShallow("rotate"), o = kt(n.getShallow("distance"), e ? null : 5), s = n.getShallow("offset");
        return r = n.getShallow("position") || (e ? null : "inside"), r === "outside" && (r = t.defaultOutsidePosition || "top"), r != null && (i.position = r), s != null && (i.offset = s), a != null && (a *= Math.PI / 180, i.rotation = a), o != null && (i.distance = o), i.outsideFill = n.get("color") === "inherit" ? t.inheritColor || null : "auto", i;
      }
      function mxt(n, t, e, i, r) {
        e = e || j1;
        var a = t.ecModel, o = a && a.option.textStyle, s = _xt(t), l;
        if (s) {
          l = {};
          for (var u in s) if (s.hasOwnProperty(u)) {
            var h = t.getModel(["rich", u]);
            G8(l[u] = {}, h, o, e, i, r, false, true);
          }
        }
        l && (n.rich = l);
        var c = t.get("overflow");
        c && (n.overflow = c);
        var f = t.get("minMargin");
        f != null && (n.margin = f), G8(n, t, o, e, i, r, true, false);
      }
      function _xt(n) {
        for (var t; n && n !== n.ecModel; ) {
          var e = (n.option || j1).rich;
          if (e) {
            t = t || {};
            for (var i = oe(e), r = 0; r < i.length; r++) {
              var a = i[r];
              t[a] = 1;
            }
          }
          n = n.parentModel;
        }
        return t;
      }
      var O8 = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], Q8 = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], z8 = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
      function G8(n, t, e, i, r, a, o, s) {
        e = !r && e || j1;
        var l = i && i.inheritColor, u = t.getShallow("color"), h = t.getShallow("textBorderColor"), c = kt(t.getShallow("opacity"), e.opacity);
        (u === "inherit" || u === "auto") && (u === "auto" && Qn("color: 'auto'", "color: 'inherit'"), l ? u = l : u = null), (h === "inherit" || h === "auto") && (h === "auto" && Qn("color: 'auto'", "color: 'inherit'"), l ? h = l : h = null), a || (u = u || e.color, h = h || e.textBorderColor), u != null && (n.fill = u), h != null && (n.stroke = h);
        var f = kt(t.getShallow("textBorderWidth"), e.textBorderWidth);
        f != null && (n.lineWidth = f);
        var g = kt(t.getShallow("textBorderType"), e.textBorderType);
        g != null && (n.lineDash = g);
        var d = kt(t.getShallow("textBorderDashOffset"), e.textBorderDashOffset);
        d != null && (n.lineDashOffset = d), !r && c == null && !s && (c = i && i.defaultOpacity), c != null && (n.opacity = c), !r && !a && n.fill == null && i.inheritColor && (n.fill = i.inheritColor);
        for (var A = 0; A < O8.length; A++) {
          var p = O8[A], v = kt(t.getShallow(p), e[p]);
          v != null && (n[p] = v);
        }
        for (var A = 0; A < Q8.length; A++) {
          var p = Q8[A], v = t.getShallow(p);
          v != null && (n[p] = v);
        }
        if (n.verticalAlign == null) {
          var y = t.getShallow("baseline");
          y != null && (n.verticalAlign = y);
        }
        if (!o || !i.disableBox) {
          for (var A = 0; A < z8.length; A++) {
            var p = z8[A], v = t.getShallow(p);
            v != null && (n[p] = v);
          }
          var m = t.getShallow("borderType");
          m != null && (n.borderDash = m), (n.backgroundColor === "auto" || n.backgroundColor === "inherit") && l && (n.backgroundColor === "auto" && Qn("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), n.backgroundColor = l), (n.borderColor === "auto" || n.borderColor === "inherit") && l && (n.borderColor === "auto" && Qn("borderColor: 'auto'", "borderColor: 'inherit'"), n.borderColor = l);
        }
      }
      function uB(n, t) {
        var e = t && t.getModel("textStyle");
        return Wa([n.fontStyle || e && e.getShallow("fontStyle") || "", n.fontWeight || e && e.getShallow("fontWeight") || "", (n.fontSize || e && e.getShallow("fontSize") || 12) + "px", n.fontFamily || e && e.getShallow("fontFamily") || "sans-serif"].join(" "));
      }
      var Hg = ce();
      function U8(n, t, e, i) {
        if (n) {
          var r = Hg(n);
          r.prevValue = r.value, r.value = e;
          var a = t.normal;
          r.valueAnimation = a.get("valueAnimation"), r.valueAnimation && (r.precision = a.get("precision"), r.defaultInterpolatedText = i, r.statesModels = t);
        }
      }
      function V8(n, t, e, i, r) {
        var a = Hg(n);
        if (!a.valueAnimation || a.prevValue === a.value) return;
        var o = a.defaultInterpolatedText, s = kt(a.interpolatedValue, a.prevValue), l = a.value;
        function u(h) {
          var c = I4(e, a.precision, s, l, h);
          a.interpolatedValue = h === 1 ? null : c;
          var f = lB({ labelDataIndex: t, labelFetcher: r, defaultText: o ? o(c) : c + "" }, a.statesModels, c);
          k8(n, f);
        }
        n.percent = 0, (a.prevValue == null ? on : Ee)(n, { percent: 1 }, i, t, null, u);
      }
      var Ext = ["textStyle", "color"], hB = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], cB = new Ae(), Ixt = function() {
        function n() {
        }
        return n.prototype.getTextColor = function(t) {
          var e = this.ecModel;
          return this.getShallow("color") || (!t && e ? e.get(Ext) : null);
        }, n.prototype.getFont = function() {
          return uB({ fontStyle: this.getShallow("fontStyle"), fontWeight: this.getShallow("fontWeight"), fontSize: this.getShallow("fontSize"), fontFamily: this.getShallow("fontFamily") }, this.ecModel);
        }, n.prototype.getTextRect = function(t) {
          for (var e = { text: t, verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline") }, i = 0; i < hB.length; i++) e[hB[i]] = this.getShallow(hB[i]);
          return cB.useStyle(e), cB.update(), cB.getBoundingRect();
        }, n;
      }(), j8 = [["lineWidth", "width"], ["stroke", "color"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["lineDash", "type"], ["lineDashOffset", "dashOffset"], ["lineCap", "cap"], ["lineJoin", "join"], ["miterLimit"]], xxt = Dh(j8), wxt = function() {
        function n() {
        }
        return n.prototype.getLineStyle = function(t) {
          return xxt(this, t);
        }, n;
      }(), q8 = [["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["lineDash", "borderType"], ["lineDashOffset", "borderDashOffset"], ["lineCap", "borderCap"], ["lineJoin", "borderJoin"], ["miterLimit", "borderMiterLimit"]], Cxt = Dh(q8), Sxt = function() {
        function n() {
        }
        return n.prototype.getItemStyle = function(t, e) {
          return Cxt(this, t, e);
        }, n;
      }(), De = function() {
        function n(t, e, i) {
          this.parentModel = e, this.ecModel = i, this.option = t;
        }
        return n.prototype.init = function(t, e, i) {
        }, n.prototype.mergeOption = function(t, e) {
          Yt(this.option, t, true);
        }, n.prototype.get = function(t, e) {
          return t == null ? this.option : this._doGet(this.parsePath(t), !e && this.parentModel);
        }, n.prototype.getShallow = function(t, e) {
          var i = this.option, r = i == null ? i : i[t];
          if (r == null && !e) {
            var a = this.parentModel;
            a && (r = a.getShallow(t));
          }
          return r;
        }, n.prototype.getModel = function(t, e) {
          var i = t != null, r = i ? this.parsePath(t) : null, a = i ? this._doGet(r) : this.option;
          return e = e || this.parentModel && this.parentModel.getModel(this.resolveParentPath(r)), new n(a, e, this.ecModel);
        }, n.prototype.isEmpty = function() {
          return this.option == null;
        }, n.prototype.restoreData = function() {
        }, n.prototype.clone = function() {
          var t = this.constructor;
          return new t(Ct(this.option));
        }, n.prototype.parsePath = function(t) {
          return typeof t == "string" ? t.split(".") : t;
        }, n.prototype.resolveParentPath = function(t) {
          return t;
        }, n.prototype.isAnimationEnabled = function() {
          if (!re.node && this.option) {
            if (this.option.animation != null) return !!this.option.animation;
            if (this.parentModel) return this.parentModel.isAnimationEnabled();
          }
        }, n.prototype._doGet = function(t, e) {
          var i = this.option;
          if (!t) return i;
          for (var r = 0; r < t.length && !(t[r] && (i = i && typeof i == "object" ? i[t[r]] : null, i == null)); r++) ;
          return i == null && e && (i = e._doGet(this.resolveParentPath(t), e.parentModel)), i;
        }, n;
      }();
      wT(De), NEt(De), kn(De, wxt), kn(De, Sxt), kn(De, zEt), kn(De, Ixt);
      var bxt = Math.round(Math.random() * 10);
      function Yg(n) {
        return [n || "", bxt++].join("_");
      }
      function Txt(n) {
        var t = {};
        n.registerSubTypeDefaulter = function(e, i) {
          var r = Ho(e);
          t[r.main] = i;
        }, n.determineSubType = function(e, i) {
          var r = i.type;
          if (!r) {
            var a = Ho(e).main;
            n.hasSubTypes(e) && t[a] && (r = t[a](i));
          }
          return r;
        };
      }
      function Bxt(n, t) {
        n.topologicalTravel = function(a, o, s, l) {
          if (!a.length) return;
          var u = e(o), h = u.graph, c = u.noEntryList, f = {};
          for (D(a, function(y) {
            f[y] = true;
          }); c.length; ) {
            var g = c.pop(), d = h[g], A = !!f[g];
            A && (s.call(l, g, d.originalDeps.slice()), delete f[g]), D(d.successor, A ? v : p);
          }
          D(f, function() {
            var y = "";
            throw y = Ir("Circular dependency may exists: ", f, a, o), new Error(y);
          });
          function p(y) {
            h[y].entryCount--, h[y].entryCount === 0 && c.push(y);
          }
          function v(y) {
            f[y] = true, p(y);
          }
        };
        function e(a) {
          var o = {}, s = [];
          return D(a, function(l) {
            var u = i(o, l), h = u.originalDeps = t(l), c = r(h, a);
            u.entryCount = c.length, u.entryCount === 0 && s.push(l), D(c, function(f) {
              $t(u.predecessor, f) < 0 && u.predecessor.push(f);
              var g = i(o, f);
              $t(g.successor, f) < 0 && g.successor.push(l);
            });
          }), { graph: o, noEntryList: s };
        }
        function i(a, o) {
          return a[o] || (a[o] = { predecessor: [], successor: [] }), a[o];
        }
        function r(a, o) {
          var s = [];
          return D(a, function(l) {
            $t(o, l) >= 0 && s.push(l);
          }), s;
        }
      }
      function cu(n, t) {
        return Yt(Yt({}, n, true), t, true);
      }
      const Mxt = { time: { month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] }, legend: { selector: { all: "All", inverse: "Inv" } }, toolbox: { brush: { title: { rect: "Box Select", polygon: "Lasso Select", lineX: "Horizontally Select", lineY: "Vertically Select", keep: "Keep Selections", clear: "Clear Selections" } }, dataView: { title: "Data View", lang: ["Data View", "Close", "Refresh"] }, dataZoom: { title: { zoom: "Zoom", back: "Zoom Reset" } }, magicType: { title: { line: "Switch to Line Chart", bar: "Switch to Bar Chart", stack: "Stack", tiled: "Tile" } }, restore: { title: "Restore" }, saveAsImage: { title: "Save as Image", lang: ["Right Click to Save Image"] } }, series: { typeNames: { pie: "Pie chart", bar: "Bar chart", line: "Line chart", scatter: "Scatter plot", effectScatter: "Ripple scatter plot", radar: "Radar chart", tree: "Tree", treemap: "Treemap", boxplot: "Boxplot", candlestick: "Candlestick", k: "K line chart", heatmap: "Heat map", map: "Map", parallel: "Parallel coordinate map", lines: "Line graph", graph: "Relationship graph", sankey: "Sankey diagram", funnel: "Funnel chart", gauge: "Gauge", pictorialBar: "Pictorial bar", themeRiver: "Theme River Map", sunburst: "Sunburst", custom: "Custom chart", chart: "Chart" } }, aria: { general: { withTitle: 'This is a chart about "{title}"', withoutTitle: "This is a chart" }, series: { single: { prefix: "", withName: " with type {seriesType} named {seriesName}.", withoutName: " with type {seriesType}." }, multiple: { prefix: ". It consists of {seriesCount} series count.", withName: " The {seriesId} series is a {seriesType} representing {seriesName}.", withoutName: " The {seriesId} series is a {seriesType}.", separator: { middle: "", end: "" } } }, data: { allData: "The data is as follows: ", partialData: "The first {displayCnt} items are: ", withName: "the data for {name} is {value}", withoutName: "{value}", separator: { middle: ", ", end: ". " } } } }, Dxt = { time: { month: ["", "", "", "", "", "", "", "", "", "", "", ""], monthAbbr: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], dayOfWeek: ["", "", "", "", "", "", ""], dayOfWeekAbbr: ["", "", "", "", "", "", ""] }, legend: { selector: { all: "", inverse: "" } }, toolbox: { brush: { title: { rect: "", polygon: "", lineX: "", lineY: "", keep: "", clear: "" } }, dataView: { title: "", lang: ["", "", ""] }, dataZoom: { title: { zoom: "", back: "" } }, magicType: { title: { line: "", bar: "", stack: "", tiled: "" } }, restore: { title: "" }, saveAsImage: { title: "", lang: [""] } }, series: { typeNames: { pie: "", bar: "", line: "", scatter: "", effectScatter: "", radar: "", tree: "", treemap: "", boxplot: "", candlestick: "K", k: "K", heatmap: "", map: "", parallel: "", lines: "", graph: "", sankey: "", funnel: "", gauge: "", pictorialBar: "", themeRiver: "", sunburst: "", custom: "", chart: "" } }, aria: { general: { withTitle: "{title}", withoutTitle: "" }, series: { single: { prefix: "", withName: "{seriesType}{seriesName}", withoutName: "{seriesType}" }, multiple: { prefix: "{seriesCount}", withName: "{seriesId}{seriesName}{seriesType}", withoutName: "{seriesId}{seriesType}", separator: { middle: "", end: "" } } }, data: { allData: "", partialData: "{displayCnt}", withName: "{name}{value}", withoutName: "{value}", separator: { middle: "", end: "" } } } };
      var H1 = "ZH", fB = "EN", Wg = fB, Y1 = {}, gB = {}, H8 = re.domSupported ? function() {
        var n = (document.documentElement.lang || navigator.language || navigator.browserLanguage || Wg).toUpperCase();
        return n.indexOf(H1) > -1 ? H1 : Wg;
      }() : Wg;
      function Y8(n, t) {
        n = n.toUpperCase(), gB[n] = new De(t), Y1[n] = t;
      }
      function Rxt(n) {
        if (ht(n)) {
          var t = Y1[n.toUpperCase()] || {};
          return n === H1 || n === fB ? Ct(t) : Yt(Ct(t), Ct(Y1[Wg]), false);
        } else return Yt(Ct(n), Ct(Y1[Wg]), false);
      }
      function dB(n) {
        return gB[n];
      }
      function Lxt() {
        return gB[Wg];
      }
      Y8(fB, Mxt), Y8(H1, Dxt);
      var AB = 1e3, pB = AB * 60, mv = pB * 60, Ea = mv * 24, W8 = Ea * 365, _v = { year: "{yyyy}", month: "{MMM}", day: "{d}", hour: "{HH}:{mm}", minute: "{HH}:{mm}", second: "{HH}:{mm}:{ss}", millisecond: "{HH}:{mm}:{ss} {SSS}", none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}" }, W1 = "{yyyy}-{MM}-{dd}", X8 = { year: "{yyyy}", month: "{yyyy}-{MM}", day: W1, hour: W1 + " " + _v.hour, minute: W1 + " " + _v.minute, second: W1 + " " + _v.second, millisecond: _v.none }, vB = ["year", "month", "day", "hour", "minute", "second", "millisecond"], $8 = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
      function fu(n, t) {
        return n += "", "0000".substr(0, t - n.length) + n;
      }
      function Xg(n) {
        switch (n) {
          case "half-year":
          case "quarter":
            return "month";
          case "week":
          case "half-week":
            return "day";
          case "half-day":
          case "quarter-day":
            return "hour";
          default:
            return n;
        }
      }
      function Pxt(n) {
        return n === Xg(n);
      }
      function Nxt(n) {
        switch (n) {
          case "year":
          case "month":
            return "day";
          case "millisecond":
            return "millisecond";
          default:
            return "second";
        }
      }
      function X1(n, t, e, i) {
        var r = qo(n), a = r[yB(e)](), o = r[$g(e)]() + 1, s = Math.floor((o - 1) / 3) + 1, l = r[$1(e)](), u = r["get" + (e ? "UTC" : "") + "Day"](), h = r[Ev(e)](), c = (h - 1) % 12 + 1, f = r[Z1(e)](), g = r[K1(e)](), d = r[J1(e)](), A = h >= 12 ? "pm" : "am", p = A.toUpperCase(), v = i instanceof De ? i : dB(i || H8) || Lxt(), y = v.getModel("time"), m = y.get("month"), _ = y.get("monthAbbr"), I = y.get("dayOfWeek"), E = y.get("dayOfWeekAbbr");
        return (t || "").replace(/{a}/g, A + "").replace(/{A}/g, p + "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, fu(a % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, m[o - 1]).replace(/{MMM}/g, _[o - 1]).replace(/{MM}/g, fu(o, 2)).replace(/{M}/g, o + "").replace(/{dd}/g, fu(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, I[u]).replace(/{ee}/g, E[u]).replace(/{e}/g, u + "").replace(/{HH}/g, fu(h, 2)).replace(/{H}/g, h + "").replace(/{hh}/g, fu(c + "", 2)).replace(/{h}/g, c + "").replace(/{mm}/g, fu(f, 2)).replace(/{m}/g, f + "").replace(/{ss}/g, fu(g, 2)).replace(/{s}/g, g + "").replace(/{SSS}/g, fu(d, 3)).replace(/{S}/g, d + "");
      }
      function Fxt(n, t, e, i, r) {
        var a = null;
        if (ht(e)) a = e;
        else if (yt(e)) a = e(n.value, t, { level: n.level });
        else {
          var o = X({}, _v);
          if (n.level > 0) for (var s = 0; s < vB.length; ++s) o[vB[s]] = "{primary|" + o[vB[s]] + "}";
          var l = e ? e.inherit === false ? e : wt(e, o) : o, u = Z8(n.value, r);
          if (l[u]) a = l[u];
          else if (l.inherit) {
            for (var h = $8.indexOf(u), s = h - 1; s >= 0; --s) if (l[u]) {
              a = l[u];
              break;
            }
            a = a || o.none;
          }
          if (Z(a)) {
            var c = n.level == null ? 0 : n.level >= 0 ? n.level : a.length + n.level;
            c = Math.min(c, a.length - 1), a = a[c];
          }
        }
        return X1(new Date(n.value), a, r, i);
      }
      function Z8(n, t) {
        var e = qo(n), i = e[$g(t)]() + 1, r = e[$1(t)](), a = e[Ev(t)](), o = e[Z1(t)](), s = e[K1(t)](), l = e[J1(t)](), u = l === 0, h = u && s === 0, c = h && o === 0, f = c && a === 0, g = f && r === 1, d = g && i === 1;
        return d ? "year" : g ? "month" : f ? "day" : c ? "hour" : h ? "minute" : u ? "second" : "millisecond";
      }
      function K8(n, t, e) {
        var i = ye(n) ? qo(n) : n;
        switch (t = t || Z8(n, e), t) {
          case "year":
            return i[yB(e)]();
          case "half-year":
            return i[$g(e)]() >= 6 ? 1 : 0;
          case "quarter":
            return Math.floor((i[$g(e)]() + 1) / 4);
          case "month":
            return i[$g(e)]();
          case "day":
            return i[$1(e)]();
          case "half-day":
            return i[Ev(e)]() / 24;
          case "hour":
            return i[Ev(e)]();
          case "minute":
            return i[Z1(e)]();
          case "second":
            return i[K1(e)]();
          case "millisecond":
            return i[J1(e)]();
        }
      }
      function yB(n) {
        return n ? "getUTCFullYear" : "getFullYear";
      }
      function $g(n) {
        return n ? "getUTCMonth" : "getMonth";
      }
      function $1(n) {
        return n ? "getUTCDate" : "getDate";
      }
      function Ev(n) {
        return n ? "getUTCHours" : "getHours";
      }
      function Z1(n) {
        return n ? "getUTCMinutes" : "getMinutes";
      }
      function K1(n) {
        return n ? "getUTCSeconds" : "getSeconds";
      }
      function J1(n) {
        return n ? "getUTCMilliseconds" : "getMilliseconds";
      }
      function kxt(n) {
        return n ? "setUTCFullYear" : "setFullYear";
      }
      function J8(n) {
        return n ? "setUTCMonth" : "setMonth";
      }
      function t6(n) {
        return n ? "setUTCDate" : "setDate";
      }
      function e6(n) {
        return n ? "setUTCHours" : "setHours";
      }
      function n6(n) {
        return n ? "setUTCMinutes" : "setMinutes";
      }
      function i6(n) {
        return n ? "setUTCSeconds" : "setSeconds";
      }
      function r6(n) {
        return n ? "setUTCMilliseconds" : "setMilliseconds";
      }
      function a6(n) {
        if (!_T(n)) return ht(n) ? n : "-";
        var t = (n + "").split(".");
        return t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : "");
      }
      function o6(n, t) {
        return n = (n || "").toLowerCase().replace(/-(.)/g, function(e, i) {
          return i.toUpperCase();
        }), t && n && (n = n.charAt(0).toUpperCase() + n.slice(1)), n;
      }
      var Zg = I2;
      function mB(n, t, e) {
        var i = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
        function r(h) {
          return h && Wa(h) ? h : "-";
        }
        function a(h) {
          return !!(h != null && !isNaN(h) && isFinite(h));
        }
        var o = t === "time", s = n instanceof Date;
        if (o || s) {
          var l = o ? qo(n) : n;
          if (isNaN(+l)) {
            if (s) return "-";
          } else return X1(l, i, e);
        }
        if (t === "ordinal") return k_(n) ? r(n) : ye(n) && a(n) ? n + "" : "-";
        var u = js(n);
        return a(u) ? a6(u) : k_(n) ? r(n) : typeof n == "boolean" ? n + "" : "-";
      }
      var s6 = ["a", "b", "c", "d", "e", "f", "g"], _B = function(n, t) {
        return "{" + n + (t == null ? "" : t) + "}";
      };
      function l6(n, t, e) {
        Z(t) || (t = [t]);
        var i = t.length;
        if (!i) return "";
        for (var r = t[0].$vars || [], a = 0; a < r.length; a++) {
          var o = s6[a];
          n = n.replace(_B(o), _B(o, 0));
        }
        for (var s = 0; s < i; s++) for (var l = 0; l < r.length; l++) {
          var u = t[s][r[l]];
          n = n.replace(_B(s6[l], s), e ? Er(u) : u);
        }
        return n;
      }
      function Oxt(n, t, e) {
        return D(t, function(i, r) {
          n = n.replace("{" + r + "}", i);
        }), n;
      }
      function Qxt(n, t) {
        var e = ht(n) ? { color: n, extraCssText: t } : n || {}, i = e.color, r = e.type;
        t = e.extraCssText;
        var a = e.renderMode || "html";
        if (!i) return "";
        if (a === "html") return r === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Er(i) + ";" + (t || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + Er(i) + ";" + (t || "") + '"></span>';
        var o = e.markerId || "markerX";
        return { renderMode: a, content: "{" + o + "|}  ", style: r === "subItem" ? { width: 4, height: 4, borderRadius: 2, backgroundColor: i } : { width: 10, height: 10, borderRadius: 5, backgroundColor: i } };
      }
      function Xh(n, t) {
        return t = t || "transparent", ht(n) ? n : Et(n) && n.colorStops && (n.colorStops[0] || {}).color || t;
      }
      function tE(n, t) {
        if (t === "_blank" || t === "blank") {
          var e = window.open();
          e.opener = null, e.location.href = n;
        } else window.open(n, t);
      }
      var eE = D, u6 = ["left", "right", "top", "bottom", "width", "height"], $h = [["width", "left", "right"], ["height", "top", "bottom"]];
      function EB(n, t, e, i, r) {
        var a = 0, o = 0;
        i == null && (i = 1 / 0), r == null && (r = 1 / 0);
        var s = 0;
        t.eachChild(function(l, u) {
          var h = l.getBoundingRect(), c = t.childAt(u + 1), f = c && c.getBoundingRect(), g, d;
          if (n === "horizontal") {
            var A = h.width + (f ? -f.x + h.x : 0);
            g = a + A, g > i || l.newline ? (a = 0, g = A, o += s + e, s = h.height) : s = Math.max(s, h.height);
          } else {
            var p = h.height + (f ? -f.y + h.y : 0);
            d = o + p, d > r || l.newline ? (a += s + e, o = 0, d = p, s = h.width) : s = Math.max(s, h.width);
          }
          l.newline || (l.x = a, l.y = o, l.markRedraw(), n === "horizontal" ? a = g + e : o = d + e);
        });
      }
      var Zh = EB;
      Gt(EB, "vertical"), Gt(EB, "horizontal");
      function zxt(n, t, e) {
        var i = t.width, r = t.height, a = st(n.left, i), o = st(n.top, r), s = st(n.right, i), l = st(n.bottom, r);
        return (isNaN(a) || isNaN(parseFloat(n.left))) && (a = 0), (isNaN(s) || isNaN(parseFloat(n.right))) && (s = i), (isNaN(o) || isNaN(parseFloat(n.top))) && (o = 0), (isNaN(l) || isNaN(parseFloat(n.bottom))) && (l = r), e = Zg(e || 0), { width: Math.max(s - a - e[1] - e[3], 0), height: Math.max(l - o - e[0] - e[2], 0) };
      }
      function Yn(n, t, e) {
        e = Zg(e || 0);
        var i = t.width, r = t.height, a = st(n.left, i), o = st(n.top, r), s = st(n.right, i), l = st(n.bottom, r), u = st(n.width, i), h = st(n.height, r), c = e[2] + e[0], f = e[1] + e[3], g = n.aspect;
        switch (isNaN(u) && (u = i - s - f - a), isNaN(h) && (h = r - l - c - o), g != null && (isNaN(u) && isNaN(h) && (g > i / r ? u = i * 0.8 : h = r * 0.8), isNaN(u) && (u = g * h), isNaN(h) && (h = u / g)), isNaN(a) && (a = i - s - u - f), isNaN(o) && (o = r - l - h - c), n.left || n.right) {
          case "center":
            a = i / 2 - u / 2 - e[3];
            break;
          case "right":
            a = i - u - f;
            break;
        }
        switch (n.top || n.bottom) {
          case "middle":
          case "center":
            o = r / 2 - h / 2 - e[0];
            break;
          case "bottom":
            o = r - h - c;
            break;
        }
        a = a || 0, o = o || 0, isNaN(u) && (u = i - f - a - (s || 0)), isNaN(h) && (h = r - c - o - (l || 0));
        var d = new Wt(a + e[3], o + e[0], u, h);
        return d.margin = e, d;
      }
      function nE(n, t, e, i, r, a) {
        var o = !r || !r.hv || r.hv[0], s = !r || !r.hv || r.hv[1], l = r && r.boundingMode || "all";
        if (a = a || n, a.x = n.x, a.y = n.y, !o && !s) return false;
        var u;
        if (l === "raw") u = n.type === "group" ? new Wt(0, 0, +t.width || 0, +t.height || 0) : n.getBoundingRect();
        else if (u = n.getBoundingRect(), n.needLocalTransform()) {
          var h = n.getLocalTransform();
          u = u.clone(), u.applyTransform(h);
        }
        var c = Yn(wt({ width: u.width, height: u.height }, t), e, i), f = o ? c.x - u.x : 0, g = s ? c.y - u.y : 0;
        return l === "raw" ? (a.x = f, a.y = g) : (a.x += f, a.y += g), a === n && n.markRedraw(), true;
      }
      function Gxt(n, t) {
        return n[$h[t][0]] != null || n[$h[t][1]] != null && n[$h[t][2]] != null;
      }
      function Iv(n) {
        var t = n.layoutMode || n.constructor.layoutMode;
        return Et(t) ? t : t ? { type: t } : null;
      }
      function gu(n, t, e) {
        var i = e && e.ignoreSize;
        !Z(i) && (i = [i, i]);
        var r = o($h[0], 0), a = o($h[1], 1);
        u($h[0], n, r), u($h[1], n, a);
        function o(h, c) {
          var f = {}, g = 0, d = {}, A = 0, p = 2;
          if (eE(h, function(m) {
            d[m] = n[m];
          }), eE(h, function(m) {
            s(t, m) && (f[m] = d[m] = t[m]), l(f, m) && g++, l(d, m) && A++;
          }), i[c]) return l(t, h[1]) ? d[h[2]] = null : l(t, h[2]) && (d[h[1]] = null), d;
          if (A === p || !g) return d;
          if (g >= p) return f;
          for (var v = 0; v < h.length; v++) {
            var y = h[v];
            if (!s(f, y) && s(n, y)) {
              f[y] = n[y];
              break;
            }
          }
          return f;
        }
        function s(h, c) {
          return h.hasOwnProperty(c);
        }
        function l(h, c) {
          return h[c] != null && h[c] !== "auto";
        }
        function u(h, c, f) {
          eE(h, function(g) {
            c[g] = f[g];
          });
        }
      }
      function Kg(n) {
        return h6({}, n);
      }
      function h6(n, t) {
        return t && n && eE(u6, function(e) {
          t.hasOwnProperty(e) && (n[e] = t[e]);
        }), n;
      }
      var Uxt = ce(), ae = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this, e, i, r) || this;
          return a.uid = Yg("ec_cpt_model"), a;
        }
        return t.prototype.init = function(e, i, r) {
          this.mergeDefaultAndTheme(e, r);
        }, t.prototype.mergeDefaultAndTheme = function(e, i) {
          var r = Iv(this), a = r ? Kg(e) : {}, o = i.getTheme();
          Yt(e, o.get(this.mainType)), Yt(e, this.getDefaultOption()), r && gu(e, a, r);
        }, t.prototype.mergeOption = function(e, i) {
          Yt(this.option, e, true);
          var r = Iv(this);
          r && gu(this.option, e, r);
        }, t.prototype.optionUpdated = function(e, i) {
        }, t.prototype.getDefaultOption = function() {
          var e = this.constructor;
          if (!REt(e)) return e.defaultOption;
          var i = Uxt(this);
          if (!i.defaultOption) {
            for (var r = [], a = e; a; ) {
              var o = a.prototype.defaultOption;
              o && r.push(o), a = a.superClass;
            }
            for (var s = {}, l = r.length - 1; l >= 0; l--) s = Yt(s, r[l], true);
            i.defaultOption = s;
          }
          return i.defaultOption;
        }, t.prototype.getReferringComponents = function(e, i) {
          var r = e + "Index", a = e + "Id";
          return nv(this.ecModel, e, { index: this.get(r, true), id: this.get(a, true) }, i);
        }, t.prototype.getBoxLayoutParams = function() {
          var e = this;
          return { left: e.get("left"), top: e.get("top"), right: e.get("right"), bottom: e.get("bottom"), width: e.get("width"), height: e.get("height") };
        }, t.prototype.getZLevelKey = function() {
          return "";
        }, t.prototype.setZLevel = function(e) {
          this.option.zlevel = e;
        }, t.protoInitialize = function() {
          var e = t.prototype;
          e.type = "component", e.id = "", e.name = "", e.mainType = "", e.subType = "", e.componentIndex = 0;
        }(), t;
      }(De);
      w4(ae, De), y1(ae), Txt(ae), Bxt(ae, Vxt);
      function Vxt(n) {
        var t = [];
        return D(ae.getClassesByMainType(n), function(e) {
          t = t.concat(e.dependencies || e.prototype.dependencies || []);
        }), t = K(t, function(e) {
          return Ho(e).main;
        }), n !== "dataset" && $t(t, "dataset") <= 0 && t.unshift("dataset"), t;
      }
      var c6 = "";
      typeof navigator != "undefined" && (c6 = navigator.platform || "");
      var Jg = "rgba(0, 0, 0, 0.2)";
      const jxt = { darkMode: "auto", colorBy: "series", color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"], gradientColor: ["#f6efa6", "#d88273", "#bf444c"], aria: { decal: { decals: [{ color: Jg, dashArrayX: [1, 0], dashArrayY: [2, 5], symbolSize: 1, rotation: Math.PI / 6 }, { color: Jg, symbol: "circle", dashArrayX: [[8, 8], [0, 8, 8, 0]], dashArrayY: [6, 0], symbolSize: 0.8 }, { color: Jg, dashArrayX: [1, 0], dashArrayY: [4, 3], rotation: -Math.PI / 4 }, { color: Jg, dashArrayX: [[6, 6], [0, 6, 6, 0]], dashArrayY: [6, 0] }, { color: Jg, dashArrayX: [[1, 0], [1, 6]], dashArrayY: [1, 0, 6, 0], rotation: Math.PI / 4 }, { color: Jg, symbol: "triangle", dashArrayX: [[9, 9], [0, 9, 9, 0]], dashArrayY: [7, 2], symbolSize: 0.75 }] } }, textStyle: { fontFamily: c6.match(/^Win/) ? "Microsoft YaHei" : "sans-serif", fontSize: 12, fontStyle: "normal", fontWeight: "normal" }, blendMode: null, stateAnimation: { duration: 300, easing: "cubicOut" }, animation: "auto", animationDuration: 1e3, animationDurationUpdate: 500, animationEasing: "cubicInOut", animationEasingUpdate: "cubicInOut", animationThreshold: 2e3, progressiveThreshold: 3e3, progressive: 400, hoverLayerThreshold: 3e3, useUTC: false };
      var IB = dt(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), Ia = "original", Ni = "arrayRows", xa = "objectRows", Ko = "keyedColumns", Zs = "typedArray", f6 = "unknown", Jo = "column", td = "row", wi = { Must: 1, Might: 2, Not: 3 }, g6 = ce();
      function qxt(n) {
        g6(n).datasetMap = dt();
      }
      function d6(n, t, e) {
        var i = {}, r = wB(t);
        if (!r || !n) return i;
        var a = [], o = [], s = t.ecModel, l = g6(s).datasetMap, u = r.uid + "_" + e.seriesLayoutBy, h, c;
        n = n.slice(), D(n, function(A, p) {
          var v = Et(A) ? A : n[p] = { name: A };
          v.type === "ordinal" && h == null && (h = p, c = d(v)), i[v.name] = [];
        });
        var f = l.get(u) || l.set(u, { categoryWayDim: c, valueWayDim: 0 });
        D(n, function(A, p) {
          var v = A.name, y = d(A);
          if (h == null) {
            var m = f.valueWayDim;
            g(i[v], m, y), g(o, m, y), f.valueWayDim += y;
          } else if (h === p) g(i[v], 0, y), g(a, 0, y);
          else {
            var m = f.categoryWayDim;
            g(i[v], m, y), g(o, m, y), f.categoryWayDim += y;
          }
        });
        function g(A, p, v) {
          for (var y = 0; y < v; y++) A.push(p + y);
        }
        function d(A) {
          var p = A.dimsDef;
          return p ? p.length : 1;
        }
        return a.length && (i.itemName = a), o.length && (i.seriesName = o), i;
      }
      function xB(n, t, e) {
        var i = {}, r = wB(n);
        if (!r) return i;
        var a = t.sourceFormat, o = t.dimensionsDefine, s;
        (a === xa || a === Ko) && D(o, function(h, c) {
          (Et(h) ? h.name : h) === "name" && (s = c);
        });
        var l = function() {
          for (var h = {}, c = {}, f = [], g = 0, d = Math.min(5, e); g < d; g++) {
            var A = p6(t.data, a, t.seriesLayoutBy, o, t.startIndex, g);
            f.push(A);
            var p = A === wi.Not;
            if (p && h.v == null && g !== s && (h.v = g), (h.n == null || h.n === h.v || !p && f[h.n] === wi.Not) && (h.n = g), v(h) && f[h.n] !== wi.Not) return h;
            p || (A === wi.Might && c.v == null && g !== s && (c.v = g), (c.n == null || c.n === c.v) && (c.n = g));
          }
          function v(y) {
            return y.v != null && y.n != null;
          }
          return v(h) ? h : v(c) ? c : null;
        }();
        if (l) {
          i.value = [l.v];
          var u = s != null ? s : l.n;
          i.itemName = [u], i.seriesName = [u];
        }
        return i;
      }
      function wB(n) {
        var t = n.get("data", true);
        if (!t) return nv(n.ecModel, "dataset", { index: n.get("datasetIndex", true), id: n.get("datasetId", true) }, zn).models[0];
      }
      function Hxt(n) {
        return !n.get("transform", true) && !n.get("fromTransformResult", true) ? [] : nv(n.ecModel, "dataset", { index: n.get("fromDatasetIndex", true), id: n.get("fromDatasetId", true) }, zn).models;
      }
      function A6(n, t) {
        return p6(n.data, n.sourceFormat, n.seriesLayoutBy, n.dimensionsDefine, n.startIndex, t);
      }
      function p6(n, t, e, i, r, a) {
        var o, s = 5;
        if (Yi(n)) return wi.Not;
        var l, u;
        if (i) {
          var h = i[a];
          Et(h) ? (l = h.name, u = h.type) : ht(h) && (l = h);
        }
        if (u != null) return u === "ordinal" ? wi.Must : wi.Not;
        if (t === Ni) {
          var c = n;
          if (e === td) {
            for (var f = c[a], g = 0; g < (f || []).length && g < s; g++) if ((o = _(f[r + g])) != null) return o;
          } else for (var g = 0; g < c.length && g < s; g++) {
            var d = c[r + g];
            if (d && (o = _(d[a])) != null) return o;
          }
        } else if (t === xa) {
          var A = n;
          if (!l) return wi.Not;
          for (var g = 0; g < A.length && g < s; g++) {
            var p = A[g];
            if (p && (o = _(p[l])) != null) return o;
          }
        } else if (t === Ko) {
          var v = n;
          if (!l) return wi.Not;
          var f = v[l];
          if (!f || Yi(f)) return wi.Not;
          for (var g = 0; g < f.length && g < s; g++) if ((o = _(f[g])) != null) return o;
        } else if (t === Ia) for (var y = n, g = 0; g < y.length && g < s; g++) {
          var p = y[g], m = Pg(p);
          if (!Z(m)) return wi.Not;
          if ((o = _(m[a])) != null) return o;
        }
        function _(I) {
          var E = ht(I);
          if (I != null && Number.isFinite(Number(I)) && I !== "") return E ? wi.Might : wi.Not;
          if (E && I !== "-") return wi.Must;
        }
        return wi.Not;
      }
      var CB = dt();
      function Yxt(n, t) {
        It(CB.get(n) == null && t), CB.set(n, t);
      }
      function Wxt(n, t, e) {
        var i = CB.get(t);
        if (!i) return e;
        var r = i(n);
        if (!r) return e;
        if (true) for (var a = 0; a < r.length; a++) It(Ng(r[a]));
        return e.concat(r);
      }
      var v6 = ce(), Xxt = ce(), SB = function() {
        function n() {
        }
        return n.prototype.getColorFromPalette = function(t, e, i) {
          var r = ze(this.get("color", true)), a = this.get("colorLayer", true);
          return y6(this, v6, r, a, t, e, i);
        }, n.prototype.clearColorPalette = function() {
          Zxt(this, v6);
        }, n;
      }();
      function bB(n, t, e, i) {
        var r = ze(n.get(["aria", "decal", "decals"]));
        return y6(n, Xxt, r, null, t, e, i);
      }
      function $xt(n, t) {
        for (var e = n.length, i = 0; i < e; i++) if (n[i].length > t) return n[i];
        return n[e - 1];
      }
      function y6(n, t, e, i, r, a, o) {
        a = a || n;
        var s = t(a), l = s.paletteIdx || 0, u = s.paletteNameMap = s.paletteNameMap || {};
        if (u.hasOwnProperty(r)) return u[r];
        var h = o == null || !i ? e : $xt(i, o);
        if (h = h || e, !(!h || !h.length)) {
          var c = h[l];
          return r && (u[r] = c), s.paletteIdx = (l + 1) % h.length, c;
        }
      }
      function Zxt(n, t) {
        t(n).paletteIdx = 0, t(n).paletteNameMap = {};
      }
      var iE, xv, m6, TB = "\0_ec_inner", _6 = 1, Kxt = { grid: "GridComponent", polar: "PolarComponent", geo: "GeoComponent", singleAxis: "SingleAxisComponent", parallel: "ParallelComponent", calendar: "CalendarComponent", graphic: "GraphicComponent", toolbox: "ToolboxComponent", tooltip: "TooltipComponent", axisPointer: "AxisPointerComponent", brush: "BrushComponent", title: "TitleComponent", timeline: "TimelineComponent", markPoint: "MarkPointComponent", markLine: "MarkLineComponent", markArea: "MarkAreaComponent", legend: "LegendComponent", dataZoom: "DataZoomComponent", visualMap: "VisualMapComponent", xAxis: "GridComponent", yAxis: "GridComponent", angleAxis: "PolarComponent", radiusAxis: "PolarComponent" }, Jxt = { line: "LineChart", bar: "BarChart", pie: "PieChart", scatter: "ScatterChart", radar: "RadarChart", map: "MapChart", tree: "TreeChart", treemap: "TreemapChart", graph: "GraphChart", gauge: "GaugeChart", funnel: "FunnelChart", parallel: "ParallelChart", sankey: "SankeyChart", boxplot: "BoxplotChart", candlestick: "CandlestickChart", effectScatter: "EffectScatterChart", lines: "LinesChart", heatmap: "HeatmapChart", pictorialBar: "PictorialBarChart", themeRiver: "ThemeRiverChart", sunburst: "SunburstChart", custom: "CustomChart" }, rE = {};
      function twt(n) {
        D(n, function(t, e) {
          if (!ae.hasClass(e)) {
            var i = Kxt[e];
            i && !rE[i] && (Ei("Component " + e + ` is used but not imported.
import { ` + i + ` } from 'echarts/components';
echarts.use([` + i + "]);"), rE[i] = true);
          }
        });
      }
      var BB = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.init = function(e, i, r, a, o, s) {
          a = a || {}, this.option = null, this._theme = new De(a), this._locale = new De(o), this._optionManager = s;
        }, t.prototype.setOption = function(e, i, r) {
          It(e != null, "option is null/undefined"), It(e[TB] !== _6, "please use chart.getOption()");
          var a = x6(i);
          this._optionManager.setOption(e, r, a), this._resetOption(null, a);
        }, t.prototype.resetOption = function(e, i) {
          return this._resetOption(e, x6(i));
        }, t.prototype._resetOption = function(e, i) {
          var r = false, a = this._optionManager;
          if (!e || e === "recreate") {
            var o = a.mountOption(e === "recreate");
            twt(o), !this.option || e === "recreate" ? m6(this, o) : (this.restoreData(), this._mergeOption(o, i)), r = true;
          }
          if ((e === "timeline" || e === "media") && this.restoreData(), !e || e === "recreate" || e === "timeline") {
            var s = a.getTimelineOption(this);
            s && (r = true, this._mergeOption(s, i));
          }
          if (!e || e === "recreate" || e === "media") {
            var l = a.getMediaOption(this);
            l.length && D(l, function(u) {
              r = true, this._mergeOption(u, i);
            }, this);
          }
          return r;
        }, t.prototype.mergeOption = function(e) {
          this._mergeOption(e, null);
        }, t.prototype._mergeOption = function(e, i) {
          var r = this.option, a = this._componentsMap, o = this._componentsCount, s = [], l = dt(), u = i && i.replaceMergeMainTypeMap;
          qxt(this), D(e, function(c, f) {
            c != null && (ae.hasClass(f) ? f && (s.push(f), l.set(f, true)) : r[f] = r[f] == null ? Ct(c) : Yt(r[f], c, true));
          }), u && u.each(function(c, f) {
            ae.hasClass(f) && !l.get(f) && (s.push(f), l.set(f, true));
          }), ae.topologicalTravel(s, ae.getAllClassMainTypes(), h, this);
          function h(c) {
            var f = Wxt(this, c, ze(e[c])), g = a.get(c), d = g ? u && u.get(c) ? "replaceMerge" : "normalMerge" : "replaceAll", A = v4(g, f, d);
            xEt(A, c, ae), r[c] = null, a.set(c, null), o.set(c, 0);
            var p = [], v = [], y = 0, m, _;
            D(A, function(I, E) {
              var x = I.existing, w = I.newOption;
              if (!w) x && (x.mergeOption({}, this), x.optionUpdated({}, false));
              else {
                var C = c === "series", S = ae.getClass(c, I.keyInfo.subType, !C);
                if (!S) {
                  if (true) {
                    var b = I.keyInfo.subType, T = Jxt[b];
                    rE[b] || (rE[b] = true, Ei(T ? "Series " + b + ` is used but not imported.
import { ` + T + ` } from 'echarts/charts';
echarts.use([` + T + "]);" : "Unknown series " + b));
                  }
                  return;
                }
                if (c === "tooltip") {
                  if (m) {
                    _ || (gn("Currently only one tooltip component is allowed."), _ = true);
                    return;
                  }
                  m = true;
                }
                if (x && x.constructor === S) x.name = I.keyInfo.name, x.mergeOption(w, this), x.optionUpdated(w, false);
                else {
                  var B = X({ componentIndex: E }, I.keyInfo);
                  x = new S(w, this, this, B), X(x, B), I.brandNew && (x.__requireNewView = true), x.init(w, this, this), x.optionUpdated(null, true);
                }
              }
              x ? (p.push(x.option), v.push(x), y++) : (p.push(void 0), v.push(void 0));
            }, this), r[c] = p, a.set(c, v), o.set(c, y), c === "series" && iE(this);
          }
          this._seriesIndices || iE(this);
        }, t.prototype.getOption = function() {
          var e = Ct(this.option);
          return D(e, function(i, r) {
            if (ae.hasClass(r)) {
              for (var a = ze(i), o = a.length, s = false, l = o - 1; l >= 0; l--) a[l] && !Ng(a[l]) ? s = true : (a[l] = null, !s && o--);
              a.length = o, e[r] = a;
            }
          }), delete e[TB], e;
        }, t.prototype.getTheme = function() {
          return this._theme;
        }, t.prototype.getLocaleModel = function() {
          return this._locale;
        }, t.prototype.setUpdatePayload = function(e) {
          this._payload = e;
        }, t.prototype.getUpdatePayload = function() {
          return this._payload;
        }, t.prototype.getComponent = function(e, i) {
          var r = this._componentsMap.get(e);
          if (r) {
            var a = r[i || 0];
            if (a) return a;
            if (i == null) {
              for (var o = 0; o < r.length; o++) if (r[o]) return r[o];
            }
          }
        }, t.prototype.queryComponents = function(e) {
          var i = e.mainType;
          if (!i) return [];
          var r = e.index, a = e.id, o = e.name, s = this._componentsMap.get(i);
          if (!s || !s.length) return [];
          var l;
          return r != null ? (l = [], D(ze(r), function(u) {
            s[u] && l.push(s[u]);
          })) : a != null ? l = E6("id", a, s) : o != null ? l = E6("name", o, s) : l = Fe(s, function(u) {
            return !!u;
          }), I6(l, e);
        }, t.prototype.findComponents = function(e) {
          var i = e.query, r = e.mainType, a = s(i), o = a ? this.queryComponents(a) : Fe(this._componentsMap.get(r), function(u) {
            return !!u;
          });
          return l(I6(o, e));
          function s(u) {
            var h = r + "Index", c = r + "Id", f = r + "Name";
            return u && (u[h] != null || u[c] != null || u[f] != null) ? { mainType: r, index: u[h], id: u[c], name: u[f] } : null;
          }
          function l(u) {
            return e.filter ? Fe(u, e.filter) : u;
          }
        }, t.prototype.eachComponent = function(e, i, r) {
          var a = this._componentsMap;
          if (yt(e)) {
            var o = i, s = e;
            a.each(function(c, f) {
              for (var g = 0; c && g < c.length; g++) {
                var d = c[g];
                d && s.call(o, f, d, d.componentIndex);
              }
            });
          } else for (var l = ht(e) ? a.get(e) : Et(e) ? this.findComponents(e) : null, u = 0; l && u < l.length; u++) {
            var h = l[u];
            h && i.call(r, h, h.componentIndex);
          }
        }, t.prototype.getSeriesByName = function(e) {
          var i = Hn(e, null);
          return Fe(this._componentsMap.get("series"), function(r) {
            return !!r && i != null && r.name === i;
          });
        }, t.prototype.getSeriesByIndex = function(e) {
          return this._componentsMap.get("series")[e];
        }, t.prototype.getSeriesByType = function(e) {
          return Fe(this._componentsMap.get("series"), function(i) {
            return !!i && i.subType === e;
          });
        }, t.prototype.getSeries = function() {
          return Fe(this._componentsMap.get("series"), function(e) {
            return !!e;
          });
        }, t.prototype.getSeriesCount = function() {
          return this._componentsCount.get("series");
        }, t.prototype.eachSeries = function(e, i) {
          xv(this), D(this._seriesIndices, function(r) {
            var a = this._componentsMap.get("series")[r];
            e.call(i, a, r);
          }, this);
        }, t.prototype.eachRawSeries = function(e, i) {
          D(this._componentsMap.get("series"), function(r) {
            r && e.call(i, r, r.componentIndex);
          });
        }, t.prototype.eachSeriesByType = function(e, i, r) {
          xv(this), D(this._seriesIndices, function(a) {
            var o = this._componentsMap.get("series")[a];
            o.subType === e && i.call(r, o, a);
          }, this);
        }, t.prototype.eachRawSeriesByType = function(e, i, r) {
          return D(this.getSeriesByType(e), i, r);
        }, t.prototype.isSeriesFiltered = function(e) {
          return xv(this), this._seriesIndicesMap.get(e.componentIndex) == null;
        }, t.prototype.getCurrentSeriesIndices = function() {
          return (this._seriesIndices || []).slice();
        }, t.prototype.filterSeries = function(e, i) {
          xv(this);
          var r = [];
          D(this._seriesIndices, function(a) {
            var o = this._componentsMap.get("series")[a];
            e.call(i, o, a) && r.push(a);
          }, this), this._seriesIndices = r, this._seriesIndicesMap = dt(r);
        }, t.prototype.restoreData = function(e) {
          iE(this);
          var i = this._componentsMap, r = [];
          i.each(function(a, o) {
            ae.hasClass(o) && r.push(o);
          }), ae.topologicalTravel(r, ae.getAllClassMainTypes(), function(a) {
            D(i.get(a), function(o) {
              o && (a !== "series" || !ewt(o, e)) && o.restoreData();
            });
          });
        }, t.internalField = function() {
          iE = function(e) {
            var i = e._seriesIndices = [];
            D(e._componentsMap.get("series"), function(r) {
              r && i.push(r.componentIndex);
            }), e._seriesIndicesMap = dt(i);
          }, xv = function(e) {
            if (!e._seriesIndices) throw new Error("Option should contains series.");
          }, m6 = function(e, i) {
            e.option = {}, e.option[TB] = _6, e._componentsMap = dt({ series: [] }), e._componentsCount = dt();
            var r = i.aria;
            Et(r) && r.enabled == null && (r.enabled = true), nwt(i, e._theme.option), Yt(i, jxt, false), e._mergeOption(i, null);
          };
        }(), t;
      }(De);
      function ewt(n, t) {
        if (t) {
          var e = t.seriesIndex, i = t.seriesId, r = t.seriesName;
          return e != null && n.componentIndex !== e || i != null && n.id !== i || r != null && n.name !== r;
        }
      }
      function nwt(n, t) {
        var e = n.color && !n.colorLayer;
        D(t, function(i, r) {
          r === "colorLayer" && e || ae.hasClass(r) || (typeof i == "object" ? n[r] = n[r] ? Yt(n[r], i, false) : Ct(i) : n[r] == null && (n[r] = i));
        });
      }
      function E6(n, t, e) {
        if (Z(t)) {
          var i = dt();
          return D(t, function(a) {
            if (a != null) {
              var o = Hn(a, null);
              o != null && i.set(a, true);
            }
          }), Fe(e, function(a) {
            return a && i.get(a[n]);
          });
        } else {
          var r = Hn(t, null);
          return Fe(e, function(a) {
            return a && r != null && a[n] === r;
          });
        }
      }
      function I6(n, t) {
        return t.hasOwnProperty("subType") ? Fe(n, function(e) {
          return e && e.subType === t.subType;
        }) : n;
      }
      function x6(n) {
        var t = dt();
        return n && D(ze(n.replaceMerge), function(e) {
          It(ae.hasClass(e), '"' + e + '" is not valid component main type in "replaceMerge"'), t.set(e, true);
        }), { replaceMergeMainTypeMap: t };
      }
      kn(BB, SB);
      var iwt = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isSSR", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getOption", "getId", "updateLabelLayout"], w6 = /* @__PURE__ */ function() {
        function n(t) {
          D(iwt, function(e) {
            this[e] = ct(t[e], t);
          }, this);
        }
        return n;
      }(), MB = {}, ed = function() {
        function n() {
          this._coordinateSystems = [];
        }
        return n.prototype.create = function(t, e) {
          var i = [];
          D(MB, function(r, a) {
            var o = r.create(t, e);
            i = i.concat(o || []);
          }), this._coordinateSystems = i;
        }, n.prototype.update = function(t, e) {
          D(this._coordinateSystems, function(i) {
            i.update && i.update(t, e);
          });
        }, n.prototype.getCoordinateSystems = function() {
          return this._coordinateSystems.slice();
        }, n.register = function(t, e) {
          MB[t] = e;
        }, n.get = function(t) {
          return MB[t];
        }, n;
      }(), rwt = /^(min|max)?(.+)$/, awt = function() {
        function n(t) {
          this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = t;
        }
        return n.prototype.setOption = function(t, e, i) {
          t && (D(ze(t.series), function(o) {
            o && o.data && Yi(o.data) && Q_(o.data);
          }), D(ze(t.dataset), function(o) {
            o && o.source && Yi(o.source) && Q_(o.source);
          })), t = Ct(t);
          var r = this._optionBackup, a = owt(t, e, !r);
          this._newBaseOption = a.baseOption, r ? (a.timelineOptions.length && (r.timelineOptions = a.timelineOptions), a.mediaList.length && (r.mediaList = a.mediaList), a.mediaDefault && (r.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
        }, n.prototype.mountOption = function(t) {
          var e = this._optionBackup;
          return this._timelineOptions = e.timelineOptions, this._mediaList = e.mediaList, this._mediaDefault = e.mediaDefault, this._currentMediaIndices = [], Ct(t ? e.baseOption : this._newBaseOption);
        }, n.prototype.getTimelineOption = function(t) {
          var e, i = this._timelineOptions;
          if (i.length) {
            var r = t.getComponent("timeline");
            r && (e = Ct(i[r.getCurrentIndex()]));
          }
          return e;
        }, n.prototype.getMediaOption = function(t) {
          var e = this._api.getWidth(), i = this._api.getHeight(), r = this._mediaList, a = this._mediaDefault, o = [], s = [];
          if (!r.length && !a) return s;
          for (var l = 0, u = r.length; l < u; l++) swt(r[l].query, e, i) && o.push(l);
          return !o.length && a && (o = [-1]), o.length && !uwt(o, this._currentMediaIndices) && (s = K(o, function(h) {
            return Ct(h === -1 ? a.option : r[h].option);
          })), this._currentMediaIndices = o, s;
        }, n;
      }();
      function owt(n, t, e) {
        var i = [], r, a, o = n.baseOption, s = n.timeline, l = n.options, u = n.media, h = !!n.media, c = !!(l || s || o && o.timeline);
        o ? (a = o, a.timeline || (a.timeline = s)) : ((c || h) && (n.options = n.media = null), a = n), h && (Z(u) ? D(u, function(g) {
          g && !g.option && Et(g.query) && Et(g.query.option) && Ei("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), g && g.option && (g.query ? i.push(g) : r || (r = g));
        }) : Ei("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), f(a), D(l, function(g) {
          return f(g);
        }), D(i, function(g) {
          return f(g.option);
        });
        function f(g) {
          D(t, function(d) {
            d(g, e);
          });
        }
        return { baseOption: a, timelineOptions: l || [], mediaDefault: r, mediaList: i };
      }
      function swt(n, t, e) {
        var i = { width: t, height: e, aspectratio: t / e }, r = true;
        return D(n, function(a, o) {
          var s = o.match(rwt);
          if (!(!s || !s[1] || !s[2])) {
            var l = s[1], u = s[2].toLowerCase();
            lwt(i[u], a, l) || (r = false);
          }
        }), r;
      }
      function lwt(n, t, e) {
        return e === "min" ? n >= t : e === "max" ? n <= t : n === t;
      }
      function uwt(n, t) {
        return n.join(",") === t.join(",");
      }
      var wa = D, wv = Et, C6 = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
      function DB(n) {
        var t = n && n.itemStyle;
        if (t) for (var e = 0, i = C6.length; e < i; e++) {
          var r = C6[e], a = t.normal, o = t.emphasis;
          a && a[r] && (Qn("itemStyle.normal." + r, r), n[r] = n[r] || {}, n[r].normal ? Yt(n[r].normal, a[r]) : n[r].normal = a[r], a[r] = null), o && o[r] && (Qn("itemStyle.emphasis." + r, "emphasis." + r), n[r] = n[r] || {}, n[r].emphasis ? Yt(n[r].emphasis, o[r]) : n[r].emphasis = o[r], o[r] = null);
        }
      }
      function Fi(n, t, e) {
        if (n && n[t] && (n[t].normal || n[t].emphasis)) {
          var i = n[t].normal, r = n[t].emphasis;
          i && (Ka("'normal' hierarchy in " + t + " has been removed since 4.0. All style properties are configured in " + t + " directly now."), e ? (n[t].normal = n[t].emphasis = null, wt(n[t], i)) : n[t] = i), r && (Ka(t + ".emphasis has been changed to emphasis." + t + " since 4.0"), n.emphasis = n.emphasis || {}, n.emphasis[t] = r, r.focus && (n.emphasis.focus = r.focus), r.blurScope && (n.emphasis.blurScope = r.blurScope));
        }
      }
      function Cv(n) {
        Fi(n, "itemStyle"), Fi(n, "lineStyle"), Fi(n, "areaStyle"), Fi(n, "label"), Fi(n, "labelLine"), Fi(n, "upperLabel"), Fi(n, "edgeLabel");
      }
      function Gn(n, t) {
        var e = wv(n) && n[t], i = wv(e) && e.textStyle;
        if (i) {
          Ka("textStyle hierarchy in " + t + " has been removed since 4.0. All textStyle properties are configured in " + t + " directly now.");
          for (var r = 0, a = p4.length; r < a; r++) {
            var o = p4[r];
            i.hasOwnProperty(o) && (e[o] = i[o]);
          }
        }
      }
      function Ca(n) {
        n && (Cv(n), Gn(n, "label"), n.emphasis && Gn(n.emphasis, "label"));
      }
      function hwt(n) {
        if (wv(n)) {
          DB(n), Cv(n), Gn(n, "label"), Gn(n, "upperLabel"), Gn(n, "edgeLabel"), n.emphasis && (Gn(n.emphasis, "label"), Gn(n.emphasis, "upperLabel"), Gn(n.emphasis, "edgeLabel"));
          var t = n.markPoint;
          t && (DB(t), Ca(t));
          var e = n.markLine;
          e && (DB(e), Ca(e));
          var i = n.markArea;
          i && Ca(i);
          var r = n.data;
          if (n.type === "graph") {
            r = r || n.nodes;
            var a = n.links || n.edges;
            if (a && !Yi(a)) for (var o = 0; o < a.length; o++) Ca(a[o]);
            D(n.categories, function(u) {
              Cv(u);
            });
          }
          if (r && !Yi(r)) for (var o = 0; o < r.length; o++) Ca(r[o]);
          if (t = n.markPoint, t && t.data) for (var s = t.data, o = 0; o < s.length; o++) Ca(s[o]);
          if (e = n.markLine, e && e.data) for (var l = e.data, o = 0; o < l.length; o++) Z(l[o]) ? (Ca(l[o][0]), Ca(l[o][1])) : Ca(l[o]);
          n.type === "gauge" ? (Gn(n, "axisLabel"), Gn(n, "title"), Gn(n, "detail")) : n.type === "treemap" ? (Fi(n.breadcrumb, "itemStyle"), D(n.levels, function(u) {
            Cv(u);
          })) : n.type === "tree" && Cv(n.leaves);
        }
      }
      function Ks(n) {
        return Z(n) ? n : n ? [n] : [];
      }
      function S6(n) {
        return (Z(n) ? n[0] : n) || {};
      }
      function cwt(n, t) {
        wa(Ks(n.series), function(i) {
          wv(i) && hwt(i);
        });
        var e = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
        t && e.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), wa(e, function(i) {
          wa(Ks(n[i]), function(r) {
            r && (Gn(r, "axisLabel"), Gn(r.axisPointer, "label"));
          });
        }), wa(Ks(n.parallel), function(i) {
          var r = i && i.parallelAxisDefault;
          Gn(r, "axisLabel"), Gn(r && r.axisPointer, "label");
        }), wa(Ks(n.calendar), function(i) {
          Fi(i, "itemStyle"), Gn(i, "dayLabel"), Gn(i, "monthLabel"), Gn(i, "yearLabel");
        }), wa(Ks(n.radar), function(i) {
          Gn(i, "name"), i.name && i.axisName == null && (i.axisName = i.name, delete i.name, Ka("name property in radar component has been changed to axisName")), i.nameGap != null && i.axisNameGap == null && (i.axisNameGap = i.nameGap, delete i.nameGap, Ka("nameGap property in radar component has been changed to axisNameGap")), wa(i.indicator, function(r) {
            r.text && Qn("text", "name", "radar.indicator");
          });
        }), wa(Ks(n.geo), function(i) {
          wv(i) && (Ca(i), wa(Ks(i.regions), function(r) {
            Ca(r);
          }));
        }), wa(Ks(n.timeline), function(i) {
          Ca(i), Fi(i, "label"), Fi(i, "itemStyle"), Fi(i, "controlStyle", true);
          var r = i.data;
          Z(r) && D(r, function(a) {
            Et(a) && (Fi(a, "label"), Fi(a, "itemStyle"));
          });
        }), wa(Ks(n.toolbox), function(i) {
          Fi(i, "iconStyle"), wa(i.feature, function(r) {
            Fi(r, "iconStyle");
          });
        }), Gn(S6(n.axisPointer), "label"), Gn(S6(n.tooltip).axisPointer, "label");
      }
      function fwt(n, t) {
        for (var e = t.split(","), i = n, r = 0; r < e.length && (i = i && i[e[r]], i != null); r++) ;
        return i;
      }
      function gwt(n, t, e, i) {
        for (var r = t.split(","), a = n, o, s = 0; s < r.length - 1; s++) o = r[s], a[o] == null && (a[o] = {}), a = a[o];
        a[r[s]] == null && (a[r[s]] = e);
      }
      function b6(n) {
        n && D(dwt, function(t) {
          t[0] in n && !(t[1] in n) && (n[t[1]] = n[t[0]]);
        });
      }
      var dwt = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], Awt = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], RB = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
      function Sv(n) {
        var t = n && n.itemStyle;
        if (t) for (var e = 0; e < RB.length; e++) {
          var i = RB[e][1], r = RB[e][0];
          t[i] != null && (t[r] = t[i], Qn(i, r));
        }
      }
      function T6(n) {
        n && n.alignTo === "edge" && n.margin != null && n.edgeDistance == null && (Qn("label.margin", "label.edgeDistance", "pie"), n.edgeDistance = n.margin);
      }
      function B6(n) {
        n && n.downplay && !n.blur && (n.blur = n.downplay, Qn("downplay", "blur", "sunburst"));
      }
      function pwt(n) {
        n && n.focusNodeAdjacency != null && (n.emphasis = n.emphasis || {}, n.emphasis.focus == null && (Qn("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), n.emphasis.focus = "adjacency"));
      }
      function M6(n, t) {
        if (n) for (var e = 0; e < n.length; e++) t(n[e]), n[e] && M6(n[e].children, t);
      }
      function D6(n, t) {
        cwt(n, t), n.series = ze(n.series), D(n.series, function(e) {
          if (Et(e)) {
            var i = e.type;
            if (i === "line") e.clipOverflow != null && (e.clip = e.clipOverflow, Qn("clipOverflow", "clip", "line"));
            else if (i === "pie" || i === "gauge") {
              e.clockWise != null && (e.clockwise = e.clockWise, Qn("clockWise", "clockwise")), T6(e.label);
              var r = e.data;
              if (r && !Yi(r)) for (var a = 0; a < r.length; a++) T6(r[a]);
              e.hoverOffset != null && (e.emphasis = e.emphasis || {}, (e.emphasis.scaleSize = null) && (Qn("hoverOffset", "emphasis.scaleSize"), e.emphasis.scaleSize = e.hoverOffset));
            } else if (i === "gauge") {
              var o = fwt(e, "pointer.color");
              o != null && gwt(e, "itemStyle.color", o);
            } else if (i === "bar") {
              Sv(e), Sv(e.backgroundStyle), Sv(e.emphasis);
              var r = e.data;
              if (r && !Yi(r)) for (var a = 0; a < r.length; a++) typeof r[a] == "object" && (Sv(r[a]), Sv(r[a] && r[a].emphasis));
            } else if (i === "sunburst") {
              var s = e.highlightPolicy;
              s && (e.emphasis = e.emphasis || {}, e.emphasis.focus || (e.emphasis.focus = s, Qn("highlightPolicy", "emphasis.focus", "sunburst"))), B6(e), M6(e.data, B6);
            } else i === "graph" || i === "sankey" ? pwt(e) : i === "map" && (e.mapType && !e.map && (Qn("mapType", "map", "map"), e.map = e.mapType), e.mapLocation && (Ka("`mapLocation` is not used anymore."), wt(e, e.mapLocation)));
            e.hoverAnimation != null && (e.emphasis = e.emphasis || {}, e.emphasis && e.emphasis.scale == null && (Qn("hoverAnimation", "emphasis.scale"), e.emphasis.scale = e.hoverAnimation)), b6(e);
          }
        }), n.dataRange && (n.visualMap = n.dataRange), D(Awt, function(e) {
          var i = n[e];
          i && (Z(i) || (i = [i]), D(i, function(r) {
            b6(r);
          }));
        });
      }
      function vwt(n) {
        var t = dt();
        n.eachSeries(function(e) {
          var i = e.get("stack");
          if (i) {
            var r = t.get(i) || t.set(i, []), a = e.getData(), o = { stackResultDimension: a.getCalculationInfo("stackResultDimension"), stackedOverDimension: a.getCalculationInfo("stackedOverDimension"), stackedDimension: a.getCalculationInfo("stackedDimension"), stackedByDimension: a.getCalculationInfo("stackedByDimension"), isStackedByIndex: a.getCalculationInfo("isStackedByIndex"), data: a, seriesModel: e };
            if (!o.stackedDimension || !(o.isStackedByIndex || o.stackedByDimension)) return;
            r.length && a.setCalculationInfo("stackedOnSeries", r[r.length - 1].seriesModel), r.push(o);
          }
        }), t.each(ywt);
      }
      function ywt(n) {
        D(n, function(t, e) {
          var i = [], r = [NaN, NaN], a = [t.stackResultDimension, t.stackedOverDimension], o = t.data, s = t.isStackedByIndex, l = t.seriesModel.get("stackStrategy") || "samesign";
          o.modify(a, function(u, h, c) {
            var f = o.get(t.stackedDimension, c);
            if (isNaN(f)) return r;
            var g, d;
            s ? d = o.getRawIndex(c) : g = o.get(t.stackedByDimension, c);
            for (var A = NaN, p = e - 1; p >= 0; p--) {
              var v = n[p];
              if (s || (d = v.data.rawIndexOf(v.stackedByDimension, g)), d >= 0) {
                var y = v.data.getByRawIndex(v.stackResultDimension, d);
                if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && f >= 0 && y > 0 || l === "samesign" && f <= 0 && y < 0) {
                  f = hEt(f, y), A = y;
                  break;
                }
              }
            }
            return i[0] = f, i[1] = A, i;
          });
        });
      }
      var aE = /* @__PURE__ */ function() {
        function n(t) {
          this.data = t.data || (t.sourceFormat === Ko ? {} : []), this.sourceFormat = t.sourceFormat || f6, this.seriesLayoutBy = t.seriesLayoutBy || Jo, this.startIndex = t.startIndex || 0, this.dimensionsDetectedCount = t.dimensionsDetectedCount, this.metaRawOption = t.metaRawOption;
          var e = this.dimensionsDefine = t.dimensionsDefine;
          if (e) for (var i = 0; i < e.length; i++) {
            var r = e[i];
            r.type == null && A6(this, i) === wi.Must && (r.type = "ordinal");
          }
        }
        return n;
      }();
      function LB(n) {
        return n instanceof aE;
      }
      function PB(n, t, e) {
        e = e || R6(n);
        var i = t.seriesLayoutBy, r = _wt(n, e, i, t.sourceHeader, t.dimensions), a = new aE({ data: n, sourceFormat: e, seriesLayoutBy: i, dimensionsDefine: r.dimensionsDefine, startIndex: r.startIndex, dimensionsDetectedCount: r.dimensionsDetectedCount, metaRawOption: Ct(t) });
        return a;
      }
      function NB(n) {
        return new aE({ data: n, sourceFormat: Yi(n) ? Zs : Ia });
      }
      function mwt(n) {
        return new aE({ data: n.data, sourceFormat: n.sourceFormat, seriesLayoutBy: n.seriesLayoutBy, dimensionsDefine: Ct(n.dimensionsDefine), startIndex: n.startIndex, dimensionsDetectedCount: n.dimensionsDetectedCount });
      }
      function R6(n) {
        var t = f6;
        if (Yi(n)) t = Zs;
        else if (Z(n)) {
          n.length === 0 && (t = Ni);
          for (var e = 0, i = n.length; e < i; e++) {
            var r = n[e];
            if (r != null) {
              if (Z(r) || Yi(r)) {
                t = Ni;
                break;
              } else if (Et(r)) {
                t = xa;
                break;
              }
            }
          }
        } else if (Et(n)) {
          for (var a in n) if (ft(n, a) && Li(n[a])) {
            t = Ko;
            break;
          }
        }
        return t;
      }
      function _wt(n, t, e, i, r) {
        var a, o;
        if (!n) return { dimensionsDefine: L6(r), startIndex: o, dimensionsDetectedCount: a };
        if (t === Ni) {
          var s = n;
          i === "auto" || i == null ? P6(function(u) {
            u != null && u !== "-" && (ht(u) ? o == null && (o = 1) : o = 0);
          }, e, s, 10) : o = ye(i) ? i : i ? 1 : 0, !r && o === 1 && (r = [], P6(function(u, h) {
            r[h] = u != null ? u + "" : "";
          }, e, s, 1 / 0)), a = r ? r.length : e === td ? s.length : s[0] ? s[0].length : null;
        } else if (t === xa) r || (r = Ewt(n));
        else if (t === Ko) r || (r = [], D(n, function(u, h) {
          r.push(h);
        }));
        else if (t === Ia) {
          var l = Pg(n[0]);
          a = Z(l) && l.length || 1;
        } else t === Zs && true && It(!!r, "dimensions must be given if data is TypedArray.");
        return { startIndex: o, dimensionsDefine: L6(r), dimensionsDetectedCount: a };
      }
      function Ewt(n) {
        for (var t = 0, e; t < n.length && !(e = n[t++]); ) ;
        if (e) return oe(e);
      }
      function L6(n) {
        if (n) {
          var t = dt();
          return K(n, function(e, i) {
            e = Et(e) ? e : { name: e };
            var r = { name: e.name, displayName: e.displayName, type: e.type };
            if (r.name == null) return r;
            r.name += "", r.displayName == null && (r.displayName = r.name);
            var a = t.get(r.name);
            return a ? r.name += "-" + a.count++ : t.set(r.name, { count: 1 }), r;
          });
        }
      }
      function P6(n, t, e, i) {
        if (t === td) for (var r = 0; r < e.length && r < i; r++) n(e[r] ? e[r][0] : null, r);
        else for (var a = e[0] || [], r = 0; r < a.length && r < i; r++) n(a[r], r);
      }
      function N6(n) {
        var t = n.sourceFormat;
        return t === xa || t === Ko;
      }
      var Kh, Jh, tc, F6, k6, O6 = function() {
        function n(t, e) {
          var i = LB(t) ? t : NB(t);
          this._source = i;
          var r = this._data = i.data;
          if (i.sourceFormat === Zs) {
            if (e == null) throw new Error("Typed array data must specify dimension size");
            this._offset = 0, this._dimSize = e, this._data = r;
          }
          k6(this, r, i);
        }
        return n.prototype.getSource = function() {
          return this._source;
        }, n.prototype.count = function() {
          return 0;
        }, n.prototype.getItem = function(t, e) {
        }, n.prototype.appendData = function(t) {
        }, n.prototype.clean = function() {
        }, n.protoInitialize = function() {
          var t = n.prototype;
          t.pure = false, t.persistent = true;
        }(), n.internalField = function() {
          var t;
          k6 = function(o, s, l) {
            var u = l.sourceFormat, h = l.seriesLayoutBy, c = l.startIndex, f = l.dimensionsDefine, g = F6[kB(u, h)];
            if (It(g, "Invalide sourceFormat: " + u), X(o, g), u === Zs) o.getItem = e, o.count = r, o.fillStorage = i;
            else {
              var d = z6(u, h);
              o.getItem = ct(d, null, s, c, f);
              var A = U6(u, h);
              o.count = ct(A, null, s, c, f);
            }
          };
          var e = function(o, s) {
            o = o - this._offset, s = s || [];
            for (var l = this._data, u = this._dimSize, h = u * o, c = 0; c < u; c++) s[c] = l[h + c];
            return s;
          }, i = function(o, s, l, u) {
            for (var h = this._data, c = this._dimSize, f = 0; f < c; f++) {
              for (var g = u[f], d = g[0] == null ? 1 / 0 : g[0], A = g[1] == null ? -1 / 0 : g[1], p = s - o, v = l[f], y = 0; y < p; y++) {
                var m = h[y * c + f];
                v[o + y] = m, m < d && (d = m), m > A && (A = m);
              }
              g[0] = d, g[1] = A;
            }
          }, r = function() {
            return this._data ? this._data.length / this._dimSize : 0;
          };
          F6 = (t = {}, t[Ni + "_" + Jo] = { pure: true, appendData: a }, t[Ni + "_" + td] = { pure: true, appendData: function() {
            throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
          } }, t[xa] = { pure: true, appendData: a }, t[Ko] = { pure: true, appendData: function(o) {
            var s = this._data;
            D(o, function(l, u) {
              for (var h = s[u] || (s[u] = []), c = 0; c < (l || []).length; c++) h.push(l[c]);
            });
          } }, t[Ia] = { appendData: a }, t[Zs] = { persistent: false, pure: true, appendData: function(o) {
            It(Yi(o), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = o;
          }, clean: function() {
            this._offset += this.count(), this._data = null;
          } }, t);
          function a(o) {
            for (var s = 0; s < o.length; s++) this._data.push(o[s]);
          }
        }(), n;
      }(), Q6 = function(n, t, e, i) {
        return n[i];
      }, Iwt = (Kh = {}, Kh[Ni + "_" + Jo] = function(n, t, e, i) {
        return n[i + t];
      }, Kh[Ni + "_" + td] = function(n, t, e, i, r) {
        i += t;
        for (var a = r || [], o = n, s = 0; s < o.length; s++) {
          var l = o[s];
          a[s] = l ? l[i] : null;
        }
        return a;
      }, Kh[xa] = Q6, Kh[Ko] = function(n, t, e, i, r) {
        for (var a = r || [], o = 0; o < e.length; o++) {
          var s = e[o].name;
          if (s == null) throw new Error();
          var l = n[s];
          a[o] = l ? l[i] : null;
        }
        return a;
      }, Kh[Ia] = Q6, Kh);
      function z6(n, t) {
        var e = Iwt[kB(n, t)];
        return It(e, 'Do not support get item on "' + n + '", "' + t + '".'), e;
      }
      var G6 = function(n, t, e) {
        return n.length;
      }, xwt = (Jh = {}, Jh[Ni + "_" + Jo] = function(n, t, e) {
        return Math.max(0, n.length - t);
      }, Jh[Ni + "_" + td] = function(n, t, e) {
        var i = n[0];
        return i ? Math.max(0, i.length - t) : 0;
      }, Jh[xa] = G6, Jh[Ko] = function(n, t, e) {
        var i = e[0].name;
        if (i == null) throw new Error();
        var r = n[i];
        return r ? r.length : 0;
      }, Jh[Ia] = G6, Jh);
      function U6(n, t) {
        var e = xwt[kB(n, t)];
        return It(e, 'Do not support count on "' + n + '", "' + t + '".'), e;
      }
      var FB = function(n, t, e) {
        return n[t];
      }, wwt = (tc = {}, tc[Ni] = FB, tc[xa] = function(n, t, e) {
        return n[e];
      }, tc[Ko] = FB, tc[Ia] = function(n, t, e) {
        var i = Pg(n);
        return i instanceof Array ? i[t] : i;
      }, tc[Zs] = FB, tc);
      function V6(n) {
        var t = wwt[n];
        return It(t, 'Do not support get value on "' + n + '".'), t;
      }
      function kB(n, t) {
        return n === Ni ? n + "_" + t : n;
      }
      function nd(n, t, e) {
        if (n) {
          var i = n.getRawDataItem(t);
          if (i != null) {
            var r = n.getStore(), a = r.getSource().sourceFormat;
            if (e != null) {
              var o = n.getDimensionIndex(e), s = r.getDimensionProperty(o);
              return V6(a)(i, o, s);
            } else {
              var l = i;
              return a === Ia && (l = Pg(i)), l;
            }
          }
        }
      }
      var Cwt = /\{@(.+?)\}/g, oE = function() {
        function n() {
        }
        return n.prototype.getDataParams = function(t, e) {
          var i = this.getData(e), r = this.getRawValue(t, e), a = i.getRawIndex(t), o = i.getName(t), s = i.getRawDataItem(t), l = i.getItemVisual(t, "style"), u = l && l[i.getItemVisual(t, "drawType") || "fill"], h = l && l.stroke, c = this.mainType, f = c === "series", g = i.userOutput && i.userOutput.get();
          return { componentType: c, componentSubType: this.subType, componentIndex: this.componentIndex, seriesType: f ? this.subType : null, seriesIndex: this.seriesIndex, seriesId: f ? this.id : null, seriesName: f ? this.name : null, name: o, dataIndex: a, data: s, dataType: e, value: r, color: u, borderColor: h, dimensionNames: g ? g.fullDimensions : null, encode: g ? g.encode : null, $vars: ["seriesName", "name", "value"] };
        }, n.prototype.getFormattedLabel = function(t, e, i, r, a, o) {
          e = e || "normal";
          var s = this.getData(i), l = this.getDataParams(t, i);
          if (o && (l.value = o.interpolatedValue), r != null && Z(l.value) && (l.value = l.value[r]), !a) {
            var u = s.getItemModel(t);
            a = u.get(e === "normal" ? ["label", "formatter"] : [e, "label", "formatter"]);
          }
          if (yt(a)) return l.status = e, l.dimensionIndex = r, a(l);
          if (ht(a)) {
            var h = l6(a, l);
            return h.replace(Cwt, function(c, f) {
              var g = f.length, d = f;
              d.charAt(0) === "[" && d.charAt(g - 1) === "]" && (d = +d.slice(1, g - 1), isNaN(d) && Ei("Invalide label formatter: @" + f + ", only support @[0], @[1], @[2], ..."));
              var A = nd(s, t, d);
              if (o && Z(o.interpolatedValue)) {
                var p = s.getDimensionIndex(d);
                p >= 0 && (A = o.interpolatedValue[p]);
              }
              return A != null ? A + "" : "";
            });
          }
        }, n.prototype.getRawValue = function(t, e) {
          return nd(this.getData(e), t);
        }, n.prototype.formatTooltip = function(t, e, i) {
        }, n;
      }();
      function j6(n) {
        var t, e;
        return Et(n) ? n.type ? e = n : "development" : t = n, { text: t, frag: e };
      }
      function bv(n) {
        return new Swt(n);
      }
      var Swt = function() {
        function n(t) {
          t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = true;
        }
        return n.prototype.perform = function(t) {
          var e = this._upstream, i = t && t.skip;
          if (this._dirty && e) {
            var r = this.context;
            r.data = r.outputData = e.context.outputData;
          }
          this.__pipeline && (this.__pipeline.currentTask = this);
          var a;
          this._plan && !i && (a = this._plan(this.context));
          var o = h(this._modBy), s = this._modDataCount || 0, l = h(t && t.modBy), u = t && t.modDataCount || 0;
          (o !== l || s !== u) && (a = "reset");
          function h(y) {
            return !(y >= 1) && (y = 1), y;
          }
          var c;
          (this._dirty || a === "reset") && (this._dirty = false, c = this._doReset(i)), this._modBy = l, this._modDataCount = u;
          var f = t && t.step;
          if (e ? (It(e._outputDueEnd != null), this._dueEnd = e._outputDueEnd) : (It(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
            var g = this._dueIndex, d = Math.min(f != null ? this._dueIndex + f : 1 / 0, this._dueEnd);
            if (!i && (c || g < d)) {
              var A = this._progress;
              if (Z(A)) for (var p = 0; p < A.length; p++) this._doProgress(A[p], g, d, l, u);
              else this._doProgress(A, g, d, l, u);
            }
            this._dueIndex = d;
            var v = this._settedOutputEnd != null ? this._settedOutputEnd : d;
            It(v >= this._outputDueEnd), this._outputDueEnd = v;
          } else this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
          return this.unfinished();
        }, n.prototype.dirty = function() {
          this._dirty = true, this._onDirty && this._onDirty(this.context);
        }, n.prototype._doProgress = function(t, e, i, r, a) {
          q6.reset(e, i, r, a), this._callingProgress = t, this._callingProgress({ start: e, end: i, count: i - e, next: q6.next }, this.context);
        }, n.prototype._doReset = function(t) {
          this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
          var e, i;
          !t && this._reset && (e = this._reset(this.context), e && e.progress && (i = e.forceFirstProgress, e = e.progress), Z(e) && !e.length && (e = null)), this._progress = e, this._modBy = this._modDataCount = null;
          var r = this._downstream;
          return r && r.dirty(), i;
        }, n.prototype.unfinished = function() {
          return this._progress && this._dueIndex < this._dueEnd;
        }, n.prototype.pipe = function(t) {
          It(t && !t._disposed && t !== this), (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty());
        }, n.prototype.dispose = function() {
          this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = false, this._disposed = true);
        }, n.prototype.getUpstream = function() {
          return this._upstream;
        }, n.prototype.getDownstream = function() {
          return this._downstream;
        }, n.prototype.setOutputEnd = function(t) {
          this._outputDueEnd = this._settedOutputEnd = t;
        }, n;
      }(), q6 = /* @__PURE__ */ function() {
        var n, t, e, i, r, a = { reset: function(l, u, h, c) {
          t = l, n = u, e = h, i = c, r = Math.ceil(i / e), a.next = e > 1 && i > 0 ? s : o;
        } };
        return a;
        function o() {
          return t < n ? t++ : null;
        }
        function s() {
          var l = t % r * e + Math.ceil(t / r), u = t >= n ? null : l < i ? l : t;
          return t++, u;
        }
      }();
      function du(n, t) {
        var e = t && t.type;
        return e === "ordinal" ? n : (e === "time" && !ye(n) && n != null && n !== "-" && (n = +qo(n)), n == null || n === "" ? NaN : Number(n));
      }
      var bwt = dt({ number: function(n) {
        return parseFloat(n);
      }, time: function(n) {
        return +qo(n);
      }, trim: function(n) {
        return ht(n) ? Wa(n) : n;
      } });
      function H6(n) {
        return bwt.get(n);
      }
      var Y6 = { lt: function(n, t) {
        return n < t;
      }, lte: function(n, t) {
        return n <= t;
      }, gt: function(n, t) {
        return n > t;
      }, gte: function(n, t) {
        return n >= t;
      } }, Twt = function() {
        function n(t, e) {
          if (!ye(e)) {
            var i = "";
            i = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.', be(i);
          }
          this._opFn = Y6[t], this._rvalFloat = js(e);
        }
        return n.prototype.evaluate = function(t) {
          return ye(t) ? this._opFn(t, this._rvalFloat) : this._opFn(js(t), this._rvalFloat);
        }, n;
      }(), W6 = function() {
        function n(t, e) {
          var i = t === "desc";
          this._resultLT = i ? 1 : -1, e == null && (e = i ? "min" : "max"), this._incomparable = e === "min" ? -1 / 0 : 1 / 0;
        }
        return n.prototype.evaluate = function(t, e) {
          var i = ye(t) ? t : js(t), r = ye(e) ? e : js(e), a = isNaN(i), o = isNaN(r);
          if (a && (i = this._incomparable), o && (r = this._incomparable), a && o) {
            var s = ht(t), l = ht(e);
            s && (i = l ? t : 0), l && (r = s ? e : 0);
          }
          return i < r ? this._resultLT : i > r ? -this._resultLT : 0;
        }, n;
      }(), Bwt = function() {
        function n(t, e) {
          this._rval = e, this._isEQ = t, this._rvalTypeof = typeof e, this._rvalFloat = js(e);
        }
        return n.prototype.evaluate = function(t) {
          var e = t === this._rval;
          if (!e) {
            var i = typeof t;
            i !== this._rvalTypeof && (i === "number" || this._rvalTypeof === "number") && (e = js(t) === this._rvalFloat);
          }
          return this._isEQ ? e : !e;
        }, n;
      }();
      function Mwt(n, t) {
        return n === "eq" || n === "ne" ? new Bwt(n === "eq", t) : ft(Y6, n) ? new Twt(n, t) : null;
      }
      var Dwt = function() {
        function n() {
        }
        return n.prototype.getRawData = function() {
          throw new Error("not supported");
        }, n.prototype.getRawDataItem = function(t) {
          throw new Error("not supported");
        }, n.prototype.cloneRawData = function() {
        }, n.prototype.getDimensionInfo = function(t) {
        }, n.prototype.cloneAllDimensionInfo = function() {
        }, n.prototype.count = function() {
        }, n.prototype.retrieveValue = function(t, e) {
        }, n.prototype.retrieveValueFromItem = function(t, e) {
        }, n.prototype.convertValue = function(t, e) {
          return du(t, e);
        }, n;
      }();
      function Rwt(n, t) {
        var e = new Dwt(), i = n.data, r = e.sourceFormat = n.sourceFormat, a = n.startIndex, o = "";
        n.seriesLayoutBy !== Jo && (o = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.', be(o));
        var s = [], l = {}, u = n.dimensionsDefine;
        if (u) D(u, function(A, p) {
          var v = A.name, y = { index: p, name: v, displayName: A.displayName };
          if (s.push(y), v != null) {
            var m = "";
            ft(l, v) && (m = 'dimension name "' + v + '" duplicated.', be(m)), l[v] = y;
          }
        });
        else for (var h = 0; h < n.dimensionsDetectedCount; h++) s.push({ index: h });
        var c = z6(r, Jo);
        t.__isBuiltIn && (e.getRawDataItem = function(A) {
          return c(i, a, s, A);
        }, e.getRawData = ct(Lwt, null, n)), e.cloneRawData = ct(Pwt, null, n);
        var f = U6(r, Jo);
        e.count = ct(f, null, i, a, s);
        var g = V6(r);
        e.retrieveValue = function(A, p) {
          var v = c(i, a, s, A);
          return d(v, p);
        };
        var d = e.retrieveValueFromItem = function(A, p) {
          if (A != null) {
            var v = s[p];
            if (v) return g(A, p, v.name);
          }
        };
        return e.getDimensionInfo = ct(Nwt, null, s, l), e.cloneAllDimensionInfo = ct(Fwt, null, s), e;
      }
      function Lwt(n) {
        var t = n.sourceFormat;
        if (!OB(t)) {
          var e = "";
          e = "`getRawData` is not supported in source format " + t, be(e);
        }
        return n.data;
      }
      function Pwt(n) {
        var t = n.sourceFormat, e = n.data;
        if (!OB(t)) {
          var i = "";
          i = "`cloneRawData` is not supported in source format " + t, be(i);
        }
        if (t === Ni) {
          for (var r = [], a = 0, o = e.length; a < o; a++) r.push(e[a].slice());
          return r;
        } else if (t === xa) {
          for (var r = [], a = 0, o = e.length; a < o; a++) r.push(X({}, e[a]));
          return r;
        }
      }
      function Nwt(n, t, e) {
        if (e != null) {
          if (ye(e) || !isNaN(e) && !ft(t, e)) return n[e];
          if (ft(t, e)) return t[e];
        }
      }
      function Fwt(n) {
        return Ct(n);
      }
      var X6 = dt();
      function kwt(n) {
        n = Ct(n);
        var t = n.type, e = "";
        t || (e = "Must have a `type` when `registerTransform`.", be(e));
        var i = t.split(":");
        i.length !== 2 && (e = 'Name must include namespace like "ns:regression".', be(e));
        var r = false;
        i[0] === "echarts" && (t = i[1], r = true), n.__isBuiltIn = r, X6.set(t, n);
      }
      function Owt(n, t, e) {
        var i = ze(n), r = i.length, a = "";
        r || (a = "If `transform` declared, it should at least contain one transform.", be(a));
        for (var o = 0, s = r; o < s; o++) {
          var l = i[o];
          t = Qwt(l, t, e, r === 1 ? null : o), o !== s - 1 && (t.length = Math.max(t.length, 1));
        }
        return t;
      }
      function Qwt(n, t, e, i) {
        var r = "";
        t.length || (r = "Must have at least one upstream dataset.", be(r)), Et(n) || (r = "transform declaration must be an object rather than " + typeof n + ".", be(r));
        var a = n.type, o = X6.get(a);
        o || (r = 'Can not find transform on type "' + a + '".', be(r));
        var s = K(t, function(h) {
          return Rwt(h, o);
        }), l = ze(o.transform({ upstream: s[0], upstreamList: s, config: Ct(n.config) }));
        if (n.print) {
          var u = K(l, function(h) {
            var c = i != null ? " === pipe index: " + i : "";
            return ["=== dataset index: " + e.datasetIndex + c + " ===", "- transform result data:", Ir(h.data), "- transform result dimensions:", Ir(h.dimensions)].join(`
`);
          }).join(`
`);
          dEt(u);
        }
        return K(l, function(h, c) {
          var f = "";
          Et(h) || (f = "A transform should not return some empty results.", be(f)), h.data || (f = "Transform result data should be not be null or undefined", be(f));
          var g = R6(h.data);
          OB(g) || (f = "Transform result data should be array rows or object rows.", be(f));
          var d, A = t[0];
          if (A && c === 0 && !h.dimensions) {
            var p = A.startIndex;
            p && (h.data = A.data.slice(0, p).concat(h.data)), d = { seriesLayoutBy: Jo, sourceHeader: p, dimensions: A.metaRawOption.dimensions };
          } else d = { seriesLayoutBy: Jo, sourceHeader: 0, dimensions: h.dimensions };
          return PB(h.data, d, null);
        });
      }
      function OB(n) {
        return n === Ni || n === xa;
      }
      var sE = "undefined", zwt = typeof Uint32Array === sE ? Array : Uint32Array, Gwt = typeof Uint16Array === sE ? Array : Uint16Array, $6 = typeof Int32Array === sE ? Array : Int32Array, Z6 = typeof Float64Array === sE ? Array : Float64Array, K6 = { float: Z6, int: $6, ordinal: Array, number: Array, time: Z6 }, QB;
      function Tv(n) {
        return n > 65535 ? zwt : Gwt;
      }
      function id() {
        return [1 / 0, -1 / 0];
      }
      function Uwt(n) {
        var t = n.constructor;
        return t === Array ? n.slice() : new t(n);
      }
      function J6(n, t, e, i, r) {
        var a = K6[e || "float"];
        if (r) {
          var o = n[t], s = o && o.length;
          if (s !== i) {
            for (var l = new a(i), u = 0; u < s; u++) l[u] = o[u];
            n[t] = l;
          }
        } else n[t] = new a(i);
      }
      var zB = function() {
        function n() {
          this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = dt();
        }
        return n.prototype.initData = function(t, e, i) {
          It(yt(t.getItem) && yt(t.count), "Invalid data provider."), this._provider = t, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
          var r = t.getSource(), a = this.defaultDimValueGetter = QB[r.sourceFormat];
          this._dimValueGetter = i || a, this._rawExtent = [];
          var o = N6(r);
          this._dimensions = K(e, function(s) {
            return o && It(s.property != null), { type: s.type, property: s.property };
          }), this._initDataFromProvider(0, t.count());
        }, n.prototype.getProvider = function() {
          return this._provider;
        }, n.prototype.getSource = function() {
          return this._provider.getSource();
        }, n.prototype.ensureCalculationDimension = function(t, e) {
          var i = this._calcDimNameToIdx, r = this._dimensions, a = i.get(t);
          if (a != null) {
            if (r[a].type === e) return a;
          } else a = r.length;
          return r[a] = { type: e }, i.set(t, a), this._chunks[a] = new K6[e || "float"](this._rawCount), this._rawExtent[a] = id(), a;
        }, n.prototype.collectOrdinalMeta = function(t, e) {
          var i = this._chunks[t], r = this._dimensions[t], a = this._rawExtent, o = r.ordinalOffset || 0, s = i.length;
          o === 0 && (a[t] = id());
          for (var l = a[t], u = o; u < s; u++) {
            var h = i[u] = e.parseAndCollect(i[u]);
            isNaN(h) || (l[0] = Math.min(h, l[0]), l[1] = Math.max(h, l[1]));
          }
          r.ordinalMeta = e, r.ordinalOffset = s, r.type = "ordinal";
        }, n.prototype.getOrdinalMeta = function(t) {
          var e = this._dimensions[t], i = e.ordinalMeta;
          return i;
        }, n.prototype.getDimensionProperty = function(t) {
          var e = this._dimensions[t];
          return e && e.property;
        }, n.prototype.appendData = function(t) {
          It(!this._indices, "appendData can only be called on raw data.");
          var e = this._provider, i = this.count();
          e.appendData(t);
          var r = e.count();
          return e.persistent || (r += i), i < r && this._initDataFromProvider(i, r, true), [i, r];
        }, n.prototype.appendValues = function(t, e) {
          for (var i = this._chunks, r = this._dimensions, a = r.length, o = this._rawExtent, s = this.count(), l = s + Math.max(t.length, e || 0), u = 0; u < a; u++) {
            var h = r[u];
            J6(i, u, h.type, l, true);
          }
          for (var c = [], f = s; f < l; f++) for (var g = f - s, d = 0; d < a; d++) {
            var h = r[d], A = QB.arrayRows.call(this, t[g] || c, h.property, g, d);
            i[d][f] = A;
            var p = o[d];
            A < p[0] && (p[0] = A), A > p[1] && (p[1] = A);
          }
          return this._rawCount = this._count = l, { start: s, end: l };
        }, n.prototype._initDataFromProvider = function(t, e, i) {
          for (var r = this._provider, a = this._chunks, o = this._dimensions, s = o.length, l = this._rawExtent, u = K(o, function(y) {
            return y.property;
          }), h = 0; h < s; h++) {
            var c = o[h];
            l[h] || (l[h] = id()), J6(a, h, c.type, e, i);
          }
          if (r.fillStorage) r.fillStorage(t, e, a, l);
          else for (var f = [], g = t; g < e; g++) {
            f = r.getItem(g, f);
            for (var d = 0; d < s; d++) {
              var A = a[d], p = this._dimValueGetter(f, u[d], g, d);
              A[g] = p;
              var v = l[d];
              p < v[0] && (v[0] = p), p > v[1] && (v[1] = p);
            }
          }
          !r.persistent && r.clean && r.clean(), this._rawCount = this._count = e, this._extent = [];
        }, n.prototype.count = function() {
          return this._count;
        }, n.prototype.get = function(t, e) {
          if (!(e >= 0 && e < this._count)) return NaN;
          var i = this._chunks[t];
          return i ? i[this.getRawIndex(e)] : NaN;
        }, n.prototype.getValues = function(t, e) {
          var i = [], r = [];
          if (e == null) {
            e = t, t = [];
            for (var a = 0; a < this._dimensions.length; a++) r.push(a);
          } else r = t;
          for (var a = 0, o = r.length; a < o; a++) i.push(this.get(r[a], e));
          return i;
        }, n.prototype.getByRawIndex = function(t, e) {
          if (!(e >= 0 && e < this._rawCount)) return NaN;
          var i = this._chunks[t];
          return i ? i[e] : NaN;
        }, n.prototype.getSum = function(t) {
          var e = this._chunks[t], i = 0;
          if (e) for (var r = 0, a = this.count(); r < a; r++) {
            var o = this.get(t, r);
            isNaN(o) || (i += o);
          }
          return i;
        }, n.prototype.getMedian = function(t) {
          var e = [];
          this.each([t], function(a) {
            isNaN(a) || e.push(a);
          });
          var i = e.sort(function(a, o) {
            return a - o;
          }), r = this.count();
          return r === 0 ? 0 : r % 2 === 1 ? i[(r - 1) / 2] : (i[r / 2] + i[r / 2 - 1]) / 2;
        }, n.prototype.indexOfRawIndex = function(t) {
          if (t >= this._rawCount || t < 0) return -1;
          if (!this._indices) return t;
          var e = this._indices, i = e[t];
          if (i != null && i < this._count && i === t) return t;
          for (var r = 0, a = this._count - 1; r <= a; ) {
            var o = (r + a) / 2 | 0;
            if (e[o] < t) r = o + 1;
            else if (e[o] > t) a = o - 1;
            else return o;
          }
          return -1;
        }, n.prototype.indicesOfNearest = function(t, e, i) {
          var r = this._chunks, a = r[t], o = [];
          if (!a) return o;
          i == null && (i = 1 / 0);
          for (var s = 1 / 0, l = -1, u = 0, h = 0, c = this.count(); h < c; h++) {
            var f = this.getRawIndex(h), g = e - a[f], d = Math.abs(g);
            d <= i && ((d < s || d === s && g >= 0 && l < 0) && (s = d, l = g, u = 0), g === l && (o[u++] = h));
          }
          return o.length = u, o;
        }, n.prototype.getIndices = function() {
          var t, e = this._indices;
          if (e) {
            var i = e.constructor, r = this._count;
            if (i === Array) {
              t = new i(r);
              for (var a = 0; a < r; a++) t[a] = e[a];
            } else t = new i(e.buffer, 0, r);
          } else {
            var i = Tv(this._rawCount);
            t = new i(this.count());
            for (var a = 0; a < t.length; a++) t[a] = a;
          }
          return t;
        }, n.prototype.filter = function(t, e) {
          if (!this._count) return this;
          for (var i = this.clone(), r = i.count(), a = Tv(i._rawCount), o = new a(r), s = [], l = t.length, u = 0, h = t[0], c = i._chunks, f = 0; f < r; f++) {
            var g = void 0, d = i.getRawIndex(f);
            if (l === 0) g = e(f);
            else if (l === 1) {
              var A = c[h][d];
              g = e(A, f);
            } else {
              for (var p = 0; p < l; p++) s[p] = c[t[p]][d];
              s[p] = f, g = e.apply(null, s);
            }
            g && (o[u++] = d);
          }
          return u < r && (i._indices = o), i._count = u, i._extent = [], i._updateGetRawIdx(), i;
        }, n.prototype.selectRange = function(t) {
          var e = this.clone(), i = e._count;
          if (!i) return this;
          var r = oe(t), a = r.length;
          if (!a) return this;
          var o = e.count(), s = Tv(e._rawCount), l = new s(o), u = 0, h = r[0], c = t[h][0], f = t[h][1], g = e._chunks, d = false;
          if (!e._indices) {
            var A = 0;
            if (a === 1) {
              for (var p = g[r[0]], v = 0; v < i; v++) {
                var y = p[v];
                (y >= c && y <= f || isNaN(y)) && (l[u++] = A), A++;
              }
              d = true;
            } else if (a === 2) {
              for (var p = g[r[0]], m = g[r[1]], _ = t[r[1]][0], I = t[r[1]][1], v = 0; v < i; v++) {
                var y = p[v], E = m[v];
                (y >= c && y <= f || isNaN(y)) && (E >= _ && E <= I || isNaN(E)) && (l[u++] = A), A++;
              }
              d = true;
            }
          }
          if (!d) if (a === 1) for (var v = 0; v < o; v++) {
            var x = e.getRawIndex(v), y = g[r[0]][x];
            (y >= c && y <= f || isNaN(y)) && (l[u++] = x);
          }
          else for (var v = 0; v < o; v++) {
            for (var w = true, x = e.getRawIndex(v), C = 0; C < a; C++) {
              var S = r[C], y = g[S][x];
              (y < t[S][0] || y > t[S][1]) && (w = false);
            }
            w && (l[u++] = e.getRawIndex(v));
          }
          return u < o && (e._indices = l), e._count = u, e._extent = [], e._updateGetRawIdx(), e;
        }, n.prototype.map = function(t, e) {
          var i = this.clone(t);
          return this._updateDims(i, t, e), i;
        }, n.prototype.modify = function(t, e) {
          this._updateDims(this, t, e);
        }, n.prototype._updateDims = function(t, e, i) {
          for (var r = t._chunks, a = [], o = e.length, s = t.count(), l = [], u = t._rawExtent, h = 0; h < e.length; h++) u[e[h]] = id();
          for (var c = 0; c < s; c++) {
            for (var f = t.getRawIndex(c), g = 0; g < o; g++) l[g] = r[e[g]][f];
            l[o] = c;
            var d = i && i.apply(null, l);
            if (d != null) {
              typeof d != "object" && (a[0] = d, d = a);
              for (var h = 0; h < d.length; h++) {
                var A = e[h], p = d[h], v = u[A], y = r[A];
                y && (y[f] = p), p < v[0] && (v[0] = p), p > v[1] && (v[1] = p);
              }
            }
          }
        }, n.prototype.lttbDownSample = function(t, e) {
          var i = this.clone([t], true), r = i._chunks, a = r[t], o = this.count(), s = 0, l = Math.floor(1 / e), u = this.getRawIndex(0), h, c, f, g = new (Tv(this._rawCount))(Math.min((Math.ceil(o / l) + 2) * 2, o));
          g[s++] = u;
          for (var d = 1; d < o - 1; d += l) {
            for (var A = Math.min(d + l, o - 1), p = Math.min(d + l * 2, o), v = (p + A) / 2, y = 0, m = A; m < p; m++) {
              var _ = this.getRawIndex(m), I = a[_];
              isNaN(I) || (y += I);
            }
            y /= p - A;
            var E = d, x = Math.min(d + l, o), w = d - 1, C = a[u];
            h = -1, f = E;
            for (var S = -1, b = 0, m = E; m < x; m++) {
              var _ = this.getRawIndex(m), I = a[_];
              if (isNaN(I)) {
                b++, S < 0 && (S = _);
                continue;
              }
              c = Math.abs((w - v) * (I - C) - (w - m) * (y - C)), c > h && (h = c, f = _);
            }
            b > 0 && b < x - E && (g[s++] = Math.min(S, f), f = Math.max(S, f)), g[s++] = f, u = f;
          }
          return g[s++] = this.getRawIndex(o - 1), i._count = s, i._indices = g, i.getRawIndex = this._getRawIdx, i;
        }, n.prototype.downSample = function(t, e, i, r) {
          for (var a = this.clone([t], true), o = a._chunks, s = [], l = Math.floor(1 / e), u = o[t], h = this.count(), c = a._rawExtent[t] = id(), f = new (Tv(this._rawCount))(Math.ceil(h / l)), g = 0, d = 0; d < h; d += l) {
            l > h - d && (l = h - d, s.length = l);
            for (var A = 0; A < l; A++) {
              var p = this.getRawIndex(d + A);
              s[A] = u[p];
            }
            var v = i(s), y = this.getRawIndex(Math.min(d + r(s, v) || 0, h - 1));
            u[y] = v, v < c[0] && (c[0] = v), v > c[1] && (c[1] = v), f[g++] = y;
          }
          return a._count = g, a._indices = f, a._updateGetRawIdx(), a;
        }, n.prototype.each = function(t, e) {
          if (this._count) for (var i = t.length, r = this._chunks, a = 0, o = this.count(); a < o; a++) {
            var s = this.getRawIndex(a);
            switch (i) {
              case 0:
                e(a);
                break;
              case 1:
                e(r[t[0]][s], a);
                break;
              case 2:
                e(r[t[0]][s], r[t[1]][s], a);
                break;
              default:
                for (var l = 0, u = []; l < i; l++) u[l] = r[t[l]][s];
                u[l] = a, e.apply(null, u);
            }
          }
        }, n.prototype.getDataExtent = function(t) {
          var e = this._chunks[t], i = id();
          if (!e) return i;
          var r = this.count(), a = !this._indices, o;
          if (a) return this._rawExtent[t].slice();
          if (o = this._extent[t], o) return o.slice();
          o = i;
          for (var s = o[0], l = o[1], u = 0; u < r; u++) {
            var h = this.getRawIndex(u), c = e[h];
            c < s && (s = c), c > l && (l = c);
          }
          return o = [s, l], this._extent[t] = o, o;
        }, n.prototype.getRawDataItem = function(t) {
          var e = this.getRawIndex(t);
          if (this._provider.persistent) return this._provider.getItem(e);
          for (var i = [], r = this._chunks, a = 0; a < r.length; a++) i.push(r[a][e]);
          return i;
        }, n.prototype.clone = function(t, e) {
          var i = new n(), r = this._chunks, a = t && zo(t, function(s, l) {
            return s[l] = true, s;
          }, {});
          if (a) for (var o = 0; o < r.length; o++) i._chunks[o] = a[o] ? Uwt(r[o]) : r[o];
          else i._chunks = r;
          return this._copyCommonProps(i), e || (i._indices = this._cloneIndices()), i._updateGetRawIdx(), i;
        }, n.prototype._copyCommonProps = function(t) {
          t._count = this._count, t._rawCount = this._rawCount, t._provider = this._provider, t._dimensions = this._dimensions, t._extent = Ct(this._extent), t._rawExtent = Ct(this._rawExtent);
        }, n.prototype._cloneIndices = function() {
          if (this._indices) {
            var t = this._indices.constructor, e = void 0;
            if (t === Array) {
              var i = this._indices.length;
              e = new t(i);
              for (var r = 0; r < i; r++) e[r] = this._indices[r];
            } else e = new t(this._indices);
            return e;
          }
          return null;
        }, n.prototype._getRawIdxIdentity = function(t) {
          return t;
        }, n.prototype._getRawIdx = function(t) {
          return t < this._count && t >= 0 ? this._indices[t] : -1;
        }, n.prototype._updateGetRawIdx = function() {
          this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
        }, n.internalField = function() {
          function t(e, i, r, a) {
            return du(e[a], this._dimensions[a]);
          }
          QB = { arrayRows: t, objectRows: function(e, i, r, a) {
            return du(e[i], this._dimensions[a]);
          }, keyedColumns: t, original: function(e, i, r, a) {
            var o = e && (e.value == null ? e : e.value);
            return du(o instanceof Array ? o[a] : o, this._dimensions[a]);
          }, typedArray: function(e, i, r, a) {
            return e[a];
          } };
        }(), n;
      }(), tU = function() {
        function n(t) {
          this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = true, this._sourceHost = t;
        }
        return n.prototype.dirty = function() {
          this._setLocalSource([], []), this._storeList = [], this._dirty = true;
        }, n.prototype._setLocalSource = function(t, e) {
          this._sourceList = t, this._upstreamSignList = e, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
        }, n.prototype._getVersionSign = function() {
          return this._sourceHost.uid + "_" + this._versionSignBase;
        }, n.prototype.prepareSource = function() {
          this._isDirty() && (this._createSource(), this._dirty = false);
        }, n.prototype._createSource = function() {
          this._setLocalSource([], []);
          var t = this._sourceHost, e = this._getUpstreamSourceManagers(), i = !!e.length, r, a;
          if (Bv(t)) {
            var o = t, s = void 0, l = void 0, u = void 0;
            if (i) {
              var h = e[0];
              h.prepareSource(), u = h.getSource(), s = u.data, l = u.sourceFormat, a = [h._getVersionSign()];
            } else s = o.get("data", true), l = Yi(s) ? Zs : Ia, a = [];
            var c = this._getSourceMetaRawOption() || {}, f = u && u.metaRawOption || {}, g = kt(c.seriesLayoutBy, f.seriesLayoutBy) || null, d = kt(c.sourceHeader, f.sourceHeader), A = kt(c.dimensions, f.dimensions), p = g !== f.seriesLayoutBy || !!d != !!f.sourceHeader || A;
            r = p ? [PB(s, { seriesLayoutBy: g, sourceHeader: d, dimensions: A }, l)] : [];
          } else {
            var v = t;
            if (i) {
              var y = this._applyTransform(e);
              r = y.sourceList, a = y.upstreamSignList;
            } else {
              var m = v.get("source", true);
              r = [PB(m, this._getSourceMetaRawOption(), null)], a = [];
            }
          }
          It(r && a), this._setLocalSource(r, a);
        }, n.prototype._applyTransform = function(t) {
          var e = this._sourceHost, i = e.get("transform", true), r = e.get("fromTransformResult", true);
          if (It(r != null || i != null), r != null) {
            var a = "";
            t.length !== 1 && (a = "When using `fromTransformResult`, there should be only one upstream dataset", nU(a));
          }
          var o, s = [], l = [];
          return D(t, function(u) {
            u.prepareSource();
            var h = u.getSource(r || 0), c = "";
            r != null && !h && (c = "Can not retrieve result by `fromTransformResult`: " + r, nU(c)), s.push(h), l.push(u._getVersionSign());
          }), i ? o = Owt(i, s, { datasetIndex: e.componentIndex }) : r != null && (o = [mwt(s[0])]), { sourceList: o, upstreamSignList: l };
        }, n.prototype._isDirty = function() {
          if (this._dirty) return true;
          for (var t = this._getUpstreamSourceManagers(), e = 0; e < t.length; e++) {
            var i = t[e];
            if (i._isDirty() || this._upstreamSignList[e] !== i._getVersionSign()) return true;
          }
        }, n.prototype.getSource = function(t) {
          t = t || 0;
          var e = this._sourceList[t];
          if (!e) {
            var i = this._getUpstreamSourceManagers();
            return i[0] && i[0].getSource(t);
          }
          return e;
        }, n.prototype.getSharedDataStore = function(t) {
          It(Bv(this._sourceHost), "Can only call getDataStore on series source manager.");
          var e = t.makeStoreSchema();
          return this._innerGetDataStore(e.dimensions, t.source, e.hash);
        }, n.prototype._innerGetDataStore = function(t, e, i) {
          var r = 0, a = this._storeList, o = a[r];
          o || (o = a[r] = {});
          var s = o[i];
          if (!s) {
            var l = this._getUpstreamSourceManagers()[0];
            Bv(this._sourceHost) && l ? s = l._innerGetDataStore(t, e, i) : (s = new zB(), s.initData(new O6(e, t.length), t)), o[i] = s;
          }
          return s;
        }, n.prototype._getUpstreamSourceManagers = function() {
          var t = this._sourceHost;
          if (Bv(t)) {
            var e = wB(t);
            return e ? [e.getSourceManager()] : [];
          } else return K(Hxt(t), function(i) {
            return i.getSourceManager();
          });
        }, n.prototype._getSourceMetaRawOption = function() {
          var t = this._sourceHost, e, i, r;
          if (Bv(t)) e = t.get("seriesLayoutBy", true), i = t.get("sourceHeader", true), r = t.get("dimensions", true);
          else if (!this._getUpstreamSourceManagers().length) {
            var a = t;
            e = a.get("seriesLayoutBy", true), i = a.get("sourceHeader", true), r = a.get("dimensions", true);
          }
          return { seriesLayoutBy: e, sourceHeader: i, dimensions: r };
        }, n;
      }();
      function eU(n) {
        var t = n.option.transform;
        t && Q_(n.option.transform);
      }
      function Bv(n) {
        return n.mainType === "series";
      }
      function nU(n) {
        throw new Error(n);
      }
      var iU = "line-height:1";
      function rU(n, t) {
        var e = n.color || "#6e7079", i = n.fontSize || 12, r = n.fontWeight || "400", a = n.color || "#464646", o = n.fontSize || 14, s = n.fontWeight || "900";
        return t === "html" ? { nameStyle: "font-size:" + Er(i + "") + "px;color:" + Er(e) + ";font-weight:" + Er(r + ""), valueStyle: "font-size:" + Er(o + "") + "px;color:" + Er(a) + ";font-weight:" + Er(s + "") } : { nameStyle: { fontSize: i, fill: e, fontWeight: r }, valueStyle: { fontSize: o, fill: a, fontWeight: s } };
      }
      var Vwt = [0, 10, 20, 30], jwt = ["", `
`, `

`, `


`];
      function ti(n, t) {
        return t.type = n, t;
      }
      function GB(n) {
        return n.type === "section";
      }
      function aU(n) {
        return GB(n) ? qwt : Hwt;
      }
      function oU(n) {
        if (GB(n)) {
          var t = 0, e = n.blocks.length, i = e > 1 || e > 0 && !n.noHeader;
          return D(n.blocks, function(r) {
            var a = oU(r);
            a >= t && (t = a + +(i && (!a || GB(r) && !r.noHeader)));
          }), t;
        }
        return 0;
      }
      function qwt(n, t, e, i) {
        var r = t.noHeader, a = Ywt(oU(t)), o = [], s = t.blocks || [];
        It(!s || Z(s)), s = s || [];
        var l = n.orderMode;
        if (t.sortBlocks && l) {
          s = s.slice();
          var u = { valueAsc: "asc", valueDesc: "desc" };
          if (ft(u, l)) {
            var h = new W6(u[l], null);
            s.sort(function(d, A) {
              return h.evaluate(d.sortParam, A.sortParam);
            });
          } else l === "seriesDesc" && s.reverse();
        }
        D(s, function(d, A) {
          var p = t.valueFormatter, v = aU(d)(p ? X(X({}, n), { valueFormatter: p }) : n, d, A > 0 ? a.html : 0, i);
          v != null && o.push(v);
        });
        var c = n.renderMode === "richText" ? o.join(a.richText) : UB(o.join(""), r ? e : a.html);
        if (r) return c;
        var f = mB(t.header, "ordinal", n.useUTC), g = rU(i, n.renderMode).nameStyle;
        return n.renderMode === "richText" ? lU(n, f, g) + a.richText + c : UB('<div style="' + g + ";" + iU + ';">' + Er(f) + "</div>" + c, e);
      }
      function Hwt(n, t, e, i) {
        var r = n.renderMode, a = t.noName, o = t.noValue, s = !t.markerType, l = t.name, u = n.useUTC, h = t.valueFormatter || n.valueFormatter || function(_) {
          return _ = Z(_) ? _ : [_], K(_, function(I, E) {
            return mB(I, Z(g) ? g[E] : g, u);
          });
        };
        if (!(a && o)) {
          var c = s ? "" : n.markupStyleCreator.makeTooltipMarker(t.markerType, t.markerColor || "#333", r), f = a ? "" : mB(l, "ordinal", u), g = t.valueType, d = o ? [] : h(t.value, t.dataIndex), A = !s || !a, p = !s && a, v = rU(i, r), y = v.nameStyle, m = v.valueStyle;
          return r === "richText" ? (s ? "" : c) + (a ? "" : lU(n, f, y)) + (o ? "" : $wt(n, d, A, p, m)) : UB((s ? "" : c) + (a ? "" : Wwt(f, !s, y)) + (o ? "" : Xwt(d, A, p, m)), e);
        }
      }
      function sU(n, t, e, i, r, a) {
        if (n) {
          var o = aU(n), s = { useUTC: r, renderMode: e, orderMode: i, markupStyleCreator: t, valueFormatter: n.valueFormatter };
          return o(s, n, 0, a);
        }
      }
      function Ywt(n) {
        return { html: Vwt[n], richText: jwt[n] };
      }
      function UB(n, t) {
        var e = '<div style="clear:both"></div>', i = "margin: " + t + "px 0 0";
        return '<div style="' + i + ";" + iU + ';">' + n + e + "</div>";
      }
      function Wwt(n, t, e) {
        var i = t ? "margin-left:2px" : "";
        return '<span style="' + e + ";" + i + '">' + Er(n) + "</span>";
      }
      function Xwt(n, t, e, i) {
        var r = e ? "10px" : "20px", a = t ? "float:right;margin-left:" + r : "";
        return n = Z(n) ? n : [n], '<span style="' + a + ";" + i + '">' + K(n, function(o) {
          return Er(o);
        }).join("&nbsp;&nbsp;") + "</span>";
      }
      function lU(n, t, e) {
        return n.markupStyleCreator.wrapRichTextStyle(t, e);
      }
      function $wt(n, t, e, i, r) {
        var a = [r], o = i ? 10 : 20;
        return e && a.push({ padding: [0, 0, 0, o], align: "right" }), n.markupStyleCreator.wrapRichTextStyle(Z(t) ? t.join("  ") : t, a);
      }
      function uU(n, t) {
        var e = n.getData().getItemVisual(t, "style"), i = e[n.visualDrawType];
        return Xh(i);
      }
      function hU(n, t) {
        var e = n.get("padding");
        return e != null ? e : t === "richText" ? [8, 10] : 10;
      }
      var VB = function() {
        function n() {
          this.richTextStyles = {}, this._nextStyleNameId = u4();
        }
        return n.prototype._generateStyleName = function() {
          return "__EC_aUTo_" + this._nextStyleNameId++;
        }, n.prototype.makeTooltipMarker = function(t, e, i) {
          var r = i === "richText" ? this._generateStyleName() : null, a = Qxt({ color: e, type: t, renderMode: i, markerId: r });
          return ht(a) ? a : (It(r), this.richTextStyles[r] = a.style, a.content);
        }, n.prototype.wrapRichTextStyle = function(t, e) {
          var i = {};
          Z(e) ? D(e, function(a) {
            return X(i, a);
          }) : X(i, e);
          var r = this._generateStyleName();
          return this.richTextStyles[r] = i, "{" + r + "|" + t + "}";
        }, n;
      }();
      function cU(n) {
        var t = n.series, e = n.dataIndex, i = n.multipleSeries, r = t.getData(), a = r.mapDimensionsAll("defaultedTooltip"), o = a.length, s = t.getRawValue(e), l = Z(s), u = uU(t, e), h, c, f, g;
        if (o > 1 || l && !o) {
          var d = Zwt(s, t, e, a, u);
          h = d.inlineValues, c = d.inlineValueTypes, f = d.blocks, g = d.inlineValues[0];
        } else if (o) {
          var A = r.getDimensionInfo(a[0]);
          g = h = nd(r, e, a[0]), c = A.type;
        } else g = h = l ? s[0] : s;
        var p = ET(t), v = p && t.name || "", y = r.getName(e), m = i ? v : y;
        return ti("section", { header: v, noHeader: i || !p, sortParam: g, blocks: [ti("nameValue", { markerType: "item", markerColor: u, name: m, noName: !Wa(m), value: h, valueType: c, dataIndex: e })].concat(f || []) });
      }
      function Zwt(n, t, e, i, r) {
        var a = t.getData(), o = zo(n, function(c, f, g) {
          var d = a.getDimensionInfo(g);
          return c = c || d && d.tooltip !== false && d.displayName != null;
        }, false), s = [], l = [], u = [];
        i.length ? D(i, function(c) {
          h(nd(a, e, c), c);
        }) : D(n, h);
        function h(c, f) {
          var g = a.getDimensionInfo(f);
          !g || g.otherDims.tooltip === false || (o ? u.push(ti("nameValue", { markerType: "subItem", markerColor: r, name: g.displayName, value: c, valueType: g.type })) : (s.push(c), l.push(g.type)));
        }
        return { inlineValues: s, inlineValueTypes: l, blocks: u };
      }
      var Au = ce();
      function lE(n, t) {
        return n.getName(t) || n.getId(t);
      }
      var uE = "__universalTransitionEnabled", tn = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e._selectedDataIndicesMap = {}, e;
        }
        return t.prototype.init = function(e, i, r) {
          this.seriesIndex = this.componentIndex, this.dataTask = bv({ count: Jwt, reset: tCt }), this.dataTask.context = { model: this }, this.mergeDefaultAndTheme(e, r);
          var a = Au(this).sourceManager = new tU(this);
          a.prepareSource();
          var o = this.getInitialData(e, r);
          gU(o, this), this.dataTask.context.data = o, It(o, "getInitialData returned invalid data."), Au(this).dataBeforeProcessed = o, fU(this), this._initSelectedMapFromData(o);
        }, t.prototype.mergeDefaultAndTheme = function(e, i) {
          var r = Iv(this), a = r ? Kg(e) : {}, o = this.subType;
          ae.hasClass(o) && (o += "Series"), Yt(e, i.getTheme().get(this.subType)), Yt(e, this.getDefaultOption()), Th(e, "label", ["show"]), this.fillDataTextStyle(e.data), r && gu(e, a, r);
        }, t.prototype.mergeOption = function(e, i) {
          e = Yt(this.option, e, true), this.fillDataTextStyle(e.data);
          var r = Iv(this);
          r && gu(this.option, e, r);
          var a = Au(this).sourceManager;
          a.dirty(), a.prepareSource();
          var o = this.getInitialData(e, i);
          gU(o, this), this.dataTask.dirty(), this.dataTask.context.data = o, Au(this).dataBeforeProcessed = o, fU(this), this._initSelectedMapFromData(o);
        }, t.prototype.fillDataTextStyle = function(e) {
          if (e && !Yi(e)) for (var i = ["show"], r = 0; r < e.length; r++) e[r] && e[r].label && Th(e[r], "label", i);
        }, t.prototype.getInitialData = function(e, i) {
        }, t.prototype.appendData = function(e) {
          var i = this.getRawData();
          i.appendData(e.data);
        }, t.prototype.getData = function(e) {
          var i = jB(this);
          if (i) {
            var r = i.context.data;
            return e == null || !r.getLinkedData ? r : r.getLinkedData(e);
          } else return Au(this).data;
        }, t.prototype.getAllData = function() {
          var e = this.getData();
          return e && e.getLinkedDataAll ? e.getLinkedDataAll() : [{ data: e }];
        }, t.prototype.setData = function(e) {
          var i = jB(this);
          if (i) {
            var r = i.context;
            r.outputData = e, i !== this.dataTask && (r.data = e);
          }
          Au(this).data = e;
        }, t.prototype.getEncode = function() {
          var e = this.get("encode", true);
          if (e) return dt(e);
        }, t.prototype.getSourceManager = function() {
          return Au(this).sourceManager;
        }, t.prototype.getSource = function() {
          return this.getSourceManager().getSource();
        }, t.prototype.getRawData = function() {
          return Au(this).dataBeforeProcessed;
        }, t.prototype.getColorBy = function() {
          var e = this.get("colorBy");
          return e || "series";
        }, t.prototype.isColorBySeries = function() {
          return this.getColorBy() === "series";
        }, t.prototype.getBaseAxis = function() {
          var e = this.coordinateSystem;
          return e && e.getBaseAxis && e.getBaseAxis();
        }, t.prototype.formatTooltip = function(e, i, r) {
          return cU({ series: this, dataIndex: e, multipleSeries: i });
        }, t.prototype.isAnimationEnabled = function() {
          var e = this.ecModel;
          if (re.node && !(e && e.ssr)) return false;
          var i = this.getShallow("animation");
          return i && this.getData().count() > this.getShallow("animationThreshold") && (i = false), !!i;
        }, t.prototype.restoreData = function() {
          this.dataTask.dirty();
        }, t.prototype.getColorFromPalette = function(e, i, r) {
          var a = this.ecModel, o = SB.prototype.getColorFromPalette.call(this, e, i, r);
          return o || (o = a.getColorFromPalette(e, i, r)), o;
        }, t.prototype.coordDimToDataDim = function(e) {
          return this.getRawData().mapDimensionsAll(e);
        }, t.prototype.getProgressive = function() {
          return this.get("progressive");
        }, t.prototype.getProgressiveThreshold = function() {
          return this.get("progressiveThreshold");
        }, t.prototype.select = function(e, i) {
          this._innerSelect(this.getData(i), e);
        }, t.prototype.unselect = function(e, i) {
          var r = this.option.selectedMap;
          if (r) {
            var a = this.option.selectedMode, o = this.getData(i);
            if (a === "series" || r === "all") {
              this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
              return;
            }
            for (var s = 0; s < e.length; s++) {
              var l = e[s], u = lE(o, l);
              r[u] = false, this._selectedDataIndicesMap[u] = -1;
            }
          }
        }, t.prototype.toggleSelect = function(e, i) {
          for (var r = [], a = 0; a < e.length; a++) r[0] = e[a], this.isSelected(e[a], i) ? this.unselect(r, i) : this.select(r, i);
        }, t.prototype.getSelectedDataIndices = function() {
          if (this.option.selectedMap === "all") return [].slice.call(this.getData().getIndices());
          for (var e = this._selectedDataIndicesMap, i = oe(e), r = [], a = 0; a < i.length; a++) {
            var o = e[i[a]];
            o >= 0 && r.push(o);
          }
          return r;
        }, t.prototype.isSelected = function(e, i) {
          var r = this.option.selectedMap;
          if (!r) return false;
          var a = this.getData(i);
          return (r === "all" || r[lE(a, e)]) && !a.getItemModel(e).get(["select", "disabled"]);
        }, t.prototype.isUniversalTransitionEnabled = function() {
          if (this[uE]) return true;
          var e = this.option.universalTransition;
          return e ? e === true ? true : e && e.enabled : false;
        }, t.prototype._innerSelect = function(e, i) {
          var r, a, o = this.option, s = o.selectedMode, l = i.length;
          if (!(!s || !l)) {
            if (s === "series") o.selectedMap = "all";
            else if (s === "multiple") {
              Et(o.selectedMap) || (o.selectedMap = {});
              for (var u = o.selectedMap, h = 0; h < l; h++) {
                var c = i[h], f = lE(e, c);
                u[f] = true, this._selectedDataIndicesMap[f] = e.getRawIndex(c);
              }
            } else if (s === "single" || s === true) {
              var g = i[l - 1], f = lE(e, g);
              o.selectedMap = (r = {}, r[f] = true, r), this._selectedDataIndicesMap = (a = {}, a[f] = e.getRawIndex(g), a);
            }
          }
        }, t.prototype._initSelectedMapFromData = function(e) {
          if (!this.option.selectedMap) {
            var i = [];
            e.hasItemOption && e.each(function(r) {
              var a = e.getRawDataItem(r);
              a && a.selected && i.push(r);
            }), i.length > 0 && this._innerSelect(e, i);
          }
        }, t.registerClass = function(e) {
          return ae.registerClass(e);
        }, t.protoInitialize = function() {
          var e = t.prototype;
          e.type = "series.__base__", e.seriesIndex = 0, e.ignoreStyleOnData = false, e.hasSymbolVisual = false, e.defaultSymbol = "circle", e.visualStyleAccessPath = "itemStyle", e.visualDrawType = "fill";
        }(), t;
      }(ae);
      kn(tn, oE), kn(tn, SB), w4(tn, ae);
      function fU(n) {
        var t = n.name;
        ET(n) || (n.name = Kwt(n) || t);
      }
      function Kwt(n) {
        var t = n.getRawData(), e = t.mapDimensionsAll("seriesName"), i = [];
        return D(e, function(r) {
          var a = t.getDimensionInfo(r);
          a.displayName && i.push(a.displayName);
        }), i.join(" ");
      }
      function Jwt(n) {
        return n.model.getRawData().count();
      }
      function tCt(n) {
        var t = n.model;
        return t.setData(t.getRawData().cloneShallow()), eCt;
      }
      function eCt(n, t) {
        t.outputData && n.end > t.outputData.count() && t.model.getRawData().cloneShallow(t.outputData);
      }
      function gU(n, t) {
        D(z_(n.CHANGABLE_METHODS, n.DOWNSAMPLE_METHODS), function(e) {
          n.wrapMethod(e, Gt(nCt, t));
        });
      }
      function nCt(n, t) {
        var e = jB(n);
        return e && e.setOutputEnd((t || this).count()), t;
      }
      function jB(n) {
        var t = (n.ecModel || {}).scheduler, e = t && t.getPipeline(n.uid);
        if (e) {
          var i = e.currentTask;
          if (i) {
            var r = i.agentStubMap;
            r && (i = r.get(n.uid));
          }
          return i;
        }
      }
      var un = function() {
        function n() {
          this.group = new Dt(), this.uid = Yg("viewComponent");
        }
        return n.prototype.init = function(t, e) {
        }, n.prototype.render = function(t, e, i, r) {
        }, n.prototype.dispose = function(t, e) {
        }, n.prototype.updateView = function(t, e, i, r) {
        }, n.prototype.updateLayout = function(t, e, i, r) {
        }, n.prototype.updateVisual = function(t, e, i, r) {
        }, n.prototype.toggleBlurSeries = function(t, e, i) {
        }, n.prototype.eachRendered = function(t) {
          var e = this.group;
          e && e.traverse(t);
        }, n;
      }();
      wT(un), y1(un);
      function rd() {
        var n = ce();
        return function(t) {
          var e = n(t), i = t.pipelineContext, r = !!e.large, a = !!e.progressiveRender, o = e.large = !!(i && i.large), s = e.progressiveRender = !!(i && i.progressiveRender);
          return (r !== o || a !== s) && "reset";
        };
      }
      var dU = ce(), iCt = rd(), qe = function() {
        function n() {
          this.group = new Dt(), this.uid = Yg("viewChart"), this.renderTask = bv({ plan: rCt, reset: aCt }), this.renderTask.context = { view: this };
        }
        return n.prototype.init = function(t, e) {
        }, n.prototype.render = function(t, e, i, r) {
          if (true) throw new Error("render method must been implemented");
        }, n.prototype.highlight = function(t, e, i, r) {
          var a = t.getData(r && r.dataType);
          if (!a) {
            Ei("Unknown dataType " + r.dataType);
            return;
          }
          pU(a, r, "emphasis");
        }, n.prototype.downplay = function(t, e, i, r) {
          var a = t.getData(r && r.dataType);
          if (!a) {
            Ei("Unknown dataType " + r.dataType);
            return;
          }
          pU(a, r, "normal");
        }, n.prototype.remove = function(t, e) {
          this.group.removeAll();
        }, n.prototype.dispose = function(t, e) {
        }, n.prototype.updateView = function(t, e, i, r) {
          this.render(t, e, i, r);
        }, n.prototype.updateLayout = function(t, e, i, r) {
          this.render(t, e, i, r);
        }, n.prototype.updateVisual = function(t, e, i, r) {
          this.render(t, e, i, r);
        }, n.prototype.eachRendered = function(t) {
          hu(this.group, t);
        }, n.markUpdateMethod = function(t, e) {
          dU(t).updateMethod = e;
        }, n.protoInitialize = function() {
          var t = n.prototype;
          t.type = "chart";
        }(), n;
      }();
      function AU(n, t, e) {
        n && lu(n) && (t === "emphasis" ? Ws : Xs)(n, e);
      }
      function pU(n, t, e) {
        var i = Bh(n, t), r = t && t.highlightKey != null ? QIt(t.highlightKey) : null;
        i != null ? D(ze(i), function(a) {
          AU(n.getItemGraphicEl(a), e, r);
        }) : n.eachItemGraphicEl(function(a) {
          AU(a, e, r);
        });
      }
      wT(qe, ["dispose"]), y1(qe);
      function rCt(n) {
        return iCt(n.model);
      }
      function aCt(n) {
        var t = n.model, e = n.ecModel, i = n.api, r = n.payload, a = t.pipelineContext.progressiveRender, o = n.view, s = r && dU(r).updateMethod, l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render";
        return l !== "render" && o[l](t, e, i, r), oCt[l];
      }
      var oCt = { incrementalPrepareRender: { progress: function(n, t) {
        t.view.incrementalRender(n, t.model, t.ecModel, t.api, t.payload);
      } }, render: { forceFirstProgress: true, progress: function(n, t) {
        t.view.render(t.model, t.ecModel, t.api, t.payload);
      } } }, hE = "\0__throttleOriginMethod", vU = "\0__throttleRate", yU = "\0__throttleType";
      function qB(n, t, e) {
        var i, r = 0, a = 0, o = null, s, l, u, h;
        t = t || 0;
        function c() {
          a = (/* @__PURE__ */ new Date()).getTime(), o = null, n.apply(l, u || []);
        }
        var f = function() {
          for (var g = [], d = 0; d < arguments.length; d++) g[d] = arguments[d];
          i = (/* @__PURE__ */ new Date()).getTime(), l = this, u = g;
          var A = h || t, p = h || e;
          h = null, s = i - (p ? r : a) - A, clearTimeout(o), p ? o = setTimeout(c, A) : s >= 0 ? c() : o = setTimeout(c, -s), r = i;
        };
        return f.clear = function() {
          o && (clearTimeout(o), o = null);
        }, f.debounceNextCall = function(g) {
          h = g;
        }, f;
      }
      function ad(n, t, e, i) {
        var r = n[t];
        if (r) {
          var a = r[hE] || r, o = r[yU], s = r[vU];
          if (s !== e || o !== i) {
            if (e == null || !i) return n[t] = a;
            r = n[t] = qB(a, e, i === "debounce"), r[hE] = a, r[yU] = i, r[vU] = e;
          }
          return r;
        }
      }
      function Mv(n, t) {
        var e = n[t];
        e && e[hE] && (e.clear && e.clear(), n[t] = e[hE]);
      }
      var mU = ce(), _U = { itemStyle: Dh(q8, true), lineStyle: Dh(j8, true) }, sCt = { lineStyle: "stroke", itemStyle: "fill" };
      function EU(n, t) {
        var e = n.visualStyleMapper || _U[t];
        return e || _U.itemStyle;
      }
      function IU(n, t) {
        var e = n.visualDrawType || sCt[t];
        return e || "fill";
      }
      var lCt = { createOnAllSeries: true, performRawSeries: true, reset: function(n, t) {
        var e = n.getData(), i = n.visualStyleAccessPath || "itemStyle", r = n.getModel(i), a = EU(n, i), o = a(r), s = r.getShallow("decal");
        s && (e.setVisual("decal", s), s.dirty = true);
        var l = IU(n, i), u = o[l], h = yt(u) ? u : null, c = o.fill === "auto" || o.stroke === "auto";
        if (!o[l] || h || c) {
          var f = n.getColorFromPalette(n.name, null, t.getSeriesCount());
          o[l] || (o[l] = f, e.setVisual("colorFromPalette", true)), o.fill = o.fill === "auto" || yt(o.fill) ? f : o.fill, o.stroke = o.stroke === "auto" || yt(o.stroke) ? f : o.stroke;
        }
        if (e.setVisual("style", o), e.setVisual("drawType", l), !t.isSeriesFiltered(n) && h) return e.setVisual("colorFromPalette", false), { dataEach: function(g, d) {
          var A = n.getDataParams(d), p = X({}, o);
          p[l] = h(A), g.setItemVisual(d, "style", p);
        } };
      } }, Dv = new De(), uCt = { createOnAllSeries: true, performRawSeries: true, reset: function(n, t) {
        if (!(n.ignoreStyleOnData || t.isSeriesFiltered(n))) {
          var e = n.getData(), i = n.visualStyleAccessPath || "itemStyle", r = EU(n, i), a = e.getVisual("drawType");
          return { dataEach: e.hasItemOption ? function(o, s) {
            var l = o.getRawDataItem(s);
            if (l && l[i]) {
              Dv.option = l[i];
              var u = r(Dv), h = o.ensureUniqueItemVisual(s, "style");
              X(h, u), Dv.option.decal && (o.setItemVisual(s, "decal", Dv.option.decal), Dv.option.decal.dirty = true), a in u && o.setItemVisual(s, "colorFromPalette", false);
            }
          } : null };
        }
      } }, hCt = { performRawSeries: true, overallReset: function(n) {
        var t = dt();
        n.eachSeries(function(e) {
          var i = e.getColorBy();
          if (!e.isColorBySeries()) {
            var r = e.type + "-" + i, a = t.get(r);
            a || (a = {}, t.set(r, a)), mU(e).scope = a;
          }
        }), n.eachSeries(function(e) {
          if (!(e.isColorBySeries() || n.isSeriesFiltered(e))) {
            var i = e.getRawData(), r = {}, a = e.getData(), o = mU(e).scope, s = e.visualStyleAccessPath || "itemStyle", l = IU(e, s);
            a.each(function(u) {
              var h = a.getRawIndex(u);
              r[h] = u;
            }), i.each(function(u) {
              var h = r[u], c = a.getItemVisual(h, "colorFromPalette");
              if (c) {
                var f = a.ensureUniqueItemVisual(h, "style"), g = i.getName(u) || u + "", d = i.count();
                f[l] = e.getColorFromPalette(g, o, d);
              }
            });
          }
        });
      } }, cE = Math.PI;
      function cCt(n, t) {
        t = t || {}, wt(t, { text: "loading", textColor: "#000", fontSize: 12, fontWeight: "normal", fontStyle: "normal", fontFamily: "sans-serif", maskColor: "rgba(255, 255, 255, 0.8)", showSpinner: true, color: "#5470c6", spinnerRadius: 10, lineWidth: 5, zlevel: 0 });
        var e = new Dt(), i = new fe({ style: { fill: t.maskColor }, zlevel: t.zlevel, z: 1e4 });
        e.add(i);
        var r = new Ae({ style: { text: t.text, fill: t.textColor, fontSize: t.fontSize, fontWeight: t.fontWeight, fontStyle: t.fontStyle, fontFamily: t.fontFamily }, zlevel: t.zlevel, z: 10001 }), a = new fe({ style: { fill: "none" }, textContent: r, textConfig: { position: "right", distance: 10 }, zlevel: t.zlevel, z: 10001 });
        e.add(a);
        var o;
        return t.showSpinner && (o = new N1({ shape: { startAngle: -cE / 2, endAngle: -cE / 2 + 0.1, r: t.spinnerRadius }, style: { stroke: t.color, lineCap: "round", lineWidth: t.lineWidth }, zlevel: t.zlevel, z: 10001 }), o.animateShape(true).when(1e3, { endAngle: cE * 3 / 2 }).start("circularInOut"), o.animateShape(true).when(1e3, { startAngle: cE * 3 / 2 }).delay(300).start("circularInOut"), e.add(o)), e.resize = function() {
          var s = r.getBoundingRect().width, l = t.showSpinner ? t.spinnerRadius : 0, u = (n.getWidth() - l * 2 - (t.showSpinner && s ? 10 : 0) - s) / 2 - (t.showSpinner && s ? 0 : 5 + s / 2) + (t.showSpinner ? 0 : s / 2) + (s ? 0 : l), h = n.getHeight() / 2;
          t.showSpinner && o.setShape({ cx: u, cy: h }), a.setShape({ x: u - l, y: h - l, width: l * 2, height: l * 2 }), i.setShape({ x: 0, y: 0, width: n.getWidth(), height: n.getHeight() });
        }, e.resize(), e;
      }
      var xU = function() {
        function n(t, e, i, r) {
          this._stageTaskMap = dt(), this.ecInstance = t, this.api = e, i = this._dataProcessorHandlers = i.slice(), r = this._visualHandlers = r.slice(), this._allHandlers = i.concat(r);
        }
        return n.prototype.restoreData = function(t, e) {
          t.restoreData(e), this._stageTaskMap.each(function(i) {
            var r = i.overallTask;
            r && r.dirty();
          });
        }, n.prototype.getPerformArgs = function(t, e) {
          if (t.__pipeline) {
            var i = this._pipelineMap.get(t.__pipeline.id), r = i.context, a = !e && i.progressiveEnabled && (!r || r.progressiveRender) && t.__idxInPipeline > i.blockIndex, o = a ? i.step : null, s = r && r.modDataCount, l = s != null ? Math.ceil(s / o) : null;
            return { step: o, modBy: l, modDataCount: s };
          }
        }, n.prototype.getPipeline = function(t) {
          return this._pipelineMap.get(t);
        }, n.prototype.updateStreamModes = function(t, e) {
          var i = this._pipelineMap.get(t.uid), r = t.getData(), a = r.count(), o = i.progressiveEnabled && e.incrementalPrepareRender && a >= i.threshold, s = t.get("large") && a >= t.get("largeThreshold"), l = t.get("progressiveChunkMode") === "mod" ? a : null;
          t.pipelineContext = i.context = { progressiveRender: o, modDataCount: l, large: s };
        }, n.prototype.restorePipelines = function(t) {
          var e = this, i = e._pipelineMap = dt();
          t.eachSeries(function(r) {
            var a = r.getProgressive(), o = r.uid;
            i.set(o, { id: o, head: null, tail: null, threshold: r.getProgressiveThreshold(), progressiveEnabled: a && !(r.preventIncremental && r.preventIncremental()), blockIndex: -1, step: Math.round(a || 700), count: 0 }), e._pipe(r, r.dataTask);
          });
        }, n.prototype.prepareStageTasks = function() {
          var t = this._stageTaskMap, e = this.api.getModel(), i = this.api;
          D(this._allHandlers, function(r) {
            var a = t.get(r.uid) || t.set(r.uid, {}), o = "";
            o = '"reset" and "overallReset" must not be both specified.', It(!(r.reset && r.overallReset), o), r.reset && this._createSeriesStageTask(r, a, e, i), r.overallReset && this._createOverallStageTask(r, a, e, i);
          }, this);
        }, n.prototype.prepareView = function(t, e, i, r) {
          var a = t.renderTask, o = a.context;
          o.model = e, o.ecModel = i, o.api = r, a.__block = !t.incrementalPrepareRender, this._pipe(e, a);
        }, n.prototype.performDataProcessorTasks = function(t, e) {
          this._performStageTasks(this._dataProcessorHandlers, t, e, { block: true });
        }, n.prototype.performVisualTasks = function(t, e, i) {
          this._performStageTasks(this._visualHandlers, t, e, i);
        }, n.prototype._performStageTasks = function(t, e, i, r) {
          r = r || {};
          var a = false, o = this;
          D(t, function(l, u) {
            if (!(r.visualType && r.visualType !== l.visualType)) {
              var h = o._stageTaskMap.get(l.uid), c = h.seriesTaskMap, f = h.overallTask;
              if (f) {
                var g, d = f.agentStubMap;
                d.each(function(p) {
                  s(r, p) && (p.dirty(), g = true);
                }), g && f.dirty(), o.updatePayload(f, i);
                var A = o.getPerformArgs(f, r.block);
                d.each(function(p) {
                  p.perform(A);
                }), f.perform(A) && (a = true);
              } else c && c.each(function(p, v) {
                s(r, p) && p.dirty();
                var y = o.getPerformArgs(p, r.block);
                y.skip = !l.performRawSeries && e.isSeriesFiltered(p.context.model), o.updatePayload(p, i), p.perform(y) && (a = true);
              });
            }
          });
          function s(l, u) {
            return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
          }
          this.unfinished = a || this.unfinished;
        }, n.prototype.performSeriesTasks = function(t) {
          var e;
          t.eachSeries(function(i) {
            e = i.dataTask.perform() || e;
          }), this.unfinished = e || this.unfinished;
        }, n.prototype.plan = function() {
          this._pipelineMap.each(function(t) {
            var e = t.tail;
            do {
              if (e.__block) {
                t.blockIndex = e.__idxInPipeline;
                break;
              }
              e = e.getUpstream();
            } while (e);
          });
        }, n.prototype.updatePayload = function(t, e) {
          e !== "remain" && (t.context.payload = e);
        }, n.prototype._createSeriesStageTask = function(t, e, i, r) {
          var a = this, o = e.seriesTaskMap, s = e.seriesTaskMap = dt(), l = t.seriesType, u = t.getTargetSeries;
          t.createOnAllSeries ? i.eachRawSeries(h) : l ? i.eachRawSeriesByType(l, h) : u && u(i, r).each(h);
          function h(c) {
            var f = c.uid, g = s.set(f, o && o.get(f) || bv({ plan: pCt, reset: vCt, count: mCt }));
            g.context = { model: c, ecModel: i, api: r, useClearVisual: t.isVisual && !t.isLayout, plan: t.plan, reset: t.reset, scheduler: a }, a._pipe(c, g);
          }
        }, n.prototype._createOverallStageTask = function(t, e, i, r) {
          var a = this, o = e.overallTask = e.overallTask || bv({ reset: fCt });
          o.context = { ecModel: i, api: r, overallReset: t.overallReset, scheduler: a };
          var s = o.agentStubMap, l = o.agentStubMap = dt(), u = t.seriesType, h = t.getTargetSeries, c = true, f = false, g = "";
          g = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.', It(!t.createOnAllSeries, g), u ? i.eachRawSeriesByType(u, d) : h ? h(i, r).each(d) : (c = false, D(i.getSeries(), d));
          function d(A) {
            var p = A.uid, v = l.set(p, s && s.get(p) || (f = true, bv({ reset: gCt, onDirty: ACt })));
            v.context = { model: A, overallProgress: c }, v.agent = o, v.__block = c, a._pipe(A, v);
          }
          f && o.dirty();
        }, n.prototype._pipe = function(t, e) {
          var i = t.uid, r = this._pipelineMap.get(i);
          !r.head && (r.head = e), r.tail && r.tail.pipe(e), r.tail = e, e.__idxInPipeline = r.count++, e.__pipeline = r;
        }, n.wrapStageHandler = function(t, e) {
          return yt(t) && (t = { overallReset: t, seriesType: _Ct(t) }), t.uid = Yg("stageHandler"), e && (t.visualType = e), t;
        }, n;
      }();
      function fCt(n) {
        n.overallReset(n.ecModel, n.api, n.payload);
      }
      function gCt(n) {
        return n.overallProgress && dCt;
      }
      function dCt() {
        this.agent.dirty(), this.getDownstream().dirty();
      }
      function ACt() {
        this.agent && this.agent.dirty();
      }
      function pCt(n) {
        return n.plan ? n.plan(n.model, n.ecModel, n.api, n.payload) : null;
      }
      function vCt(n) {
        n.useClearVisual && n.data.clearAllVisual();
        var t = n.resetDefines = ze(n.reset(n.model, n.ecModel, n.api, n.payload));
        return t.length > 1 ? K(t, function(e, i) {
          return wU(i);
        }) : yCt;
      }
      var yCt = wU(0);
      function wU(n) {
        return function(t, e) {
          var i = e.data, r = e.resetDefines[n];
          if (r && r.dataEach) for (var a = t.start; a < t.end; a++) r.dataEach(i, a);
          else r && r.progress && r.progress(t, i);
        };
      }
      function mCt(n) {
        return n.data.count();
      }
      function _Ct(n) {
        fE = null;
        try {
          n(Rv, CU);
        } catch (t) {
        }
        return fE;
      }
      var Rv = {}, CU = {}, fE;
      SU(Rv, BB), SU(CU, w6), Rv.eachSeriesByType = Rv.eachRawSeriesByType = function(n) {
        fE = n;
      }, Rv.eachComponent = function(n) {
        n.mainType === "series" && n.subType && (fE = n.subType);
      };
      function SU(n, t) {
        for (var e in t.prototype) n[e] = bn;
      }
      var bU = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
      const ECt = { color: bU, colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], bU] };
      var tr = "#B9B8CE", TU = "#100C2A", gE = function() {
        return { axisLine: { lineStyle: { color: tr } }, splitLine: { lineStyle: { color: "#484753" } }, splitArea: { areaStyle: { color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"] } }, minorSplitLine: { lineStyle: { color: "#20203B" } } };
      }, BU = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"], MU = { darkMode: true, color: BU, backgroundColor: TU, axisPointer: { lineStyle: { color: "#817f91" }, crossStyle: { color: "#817f91" }, label: { color: "#fff" } }, legend: { textStyle: { color: tr } }, textStyle: { color: tr }, title: { textStyle: { color: "#EEF1FA" }, subtextStyle: { color: "#B9B8CE" } }, toolbox: { iconStyle: { borderColor: tr } }, dataZoom: { borderColor: "#71708A", textStyle: { color: tr }, brushStyle: { color: "rgba(135,163,206,0.3)" }, handleStyle: { color: "#353450", borderColor: "#C5CBE3" }, moveHandleStyle: { color: "#B0B6C3", opacity: 0.3 }, fillerColor: "rgba(135,163,206,0.2)", emphasis: { handleStyle: { borderColor: "#91B7F2", color: "#4D587D" }, moveHandleStyle: { color: "#636D9A", opacity: 0.7 } }, dataBackground: { lineStyle: { color: "#71708A", width: 1 }, areaStyle: { color: "#71708A" } }, selectedDataBackground: { lineStyle: { color: "#87A3CE" }, areaStyle: { color: "#87A3CE" } } }, visualMap: { textStyle: { color: tr } }, timeline: { lineStyle: { color: tr }, label: { color: tr }, controlStyle: { color: tr, borderColor: tr } }, calendar: { itemStyle: { color: TU }, dayLabel: { color: tr }, monthLabel: { color: tr }, yearLabel: { color: tr } }, timeAxis: gE(), logAxis: gE(), valueAxis: gE(), categoryAxis: gE(), line: { symbol: "circle" }, graph: { color: BU }, gauge: { title: { color: tr }, axisLine: { lineStyle: { color: [[1, "rgba(207,212,219,0.2)"]] } }, axisLabel: { color: tr }, detail: { color: "#EEF1FA" } }, candlestick: { itemStyle: { color: "#f64e56", color0: "#54ea92", borderColor: "#f64e56", borderColor0: "#54ea92" } } };
      MU.categoryAxis.splitLine.show = false;
      var ICt = function() {
        function n() {
        }
        return n.prototype.normalizeQuery = function(t) {
          var e = {}, i = {}, r = {};
          if (ht(t)) {
            var a = Ho(t);
            e.mainType = a.main || null, e.subType = a.sub || null;
          } else {
            var o = ["Index", "Name", "Id"], s = { name: 1, dataIndex: 1, dataType: 1 };
            D(t, function(l, u) {
              for (var h = false, c = 0; c < o.length; c++) {
                var f = o[c], g = u.lastIndexOf(f);
                if (g > 0 && g === u.length - f.length) {
                  var d = u.slice(0, g);
                  d !== "data" && (e.mainType = d, e[f.toLowerCase()] = l, h = true);
                }
              }
              s.hasOwnProperty(u) && (i[u] = l, h = true), h || (r[u] = l);
            });
          }
          return { cptQuery: e, dataQuery: i, otherQuery: r };
        }, n.prototype.filter = function(t, e) {
          var i = this.eventInfo;
          if (!i) return true;
          var r = i.targetEl, a = i.packedEvent, o = i.model, s = i.view;
          if (!o || !s) return true;
          var l = e.cptQuery, u = e.dataQuery;
          return h(l, o, "mainType") && h(l, o, "subType") && h(l, o, "index", "componentIndex") && h(l, o, "name") && h(l, o, "id") && h(u, a, "name") && h(u, a, "dataIndex") && h(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(t, e.otherQuery, r, a));
          function h(c, f, g, d) {
            return c[g] == null || f[d || g] === c[g];
          }
        }, n.prototype.afterTrigger = function() {
          this.eventInfo = null;
        }, n;
      }(), HB = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], DU = HB.concat(["symbolKeepAspect"]), xCt = { createOnAllSeries: true, performRawSeries: true, reset: function(n, t) {
        var e = n.getData();
        if (n.legendIcon && e.setVisual("legendIcon", n.legendIcon), !n.hasSymbolVisual) return;
        for (var i = {}, r = {}, a = false, o = 0; o < HB.length; o++) {
          var s = HB[o], l = n.get(s);
          yt(l) ? (a = true, r[s] = l) : i[s] = l;
        }
        if (i.symbol = i.symbol || n.defaultSymbol, e.setVisual(X({ legendIcon: n.legendIcon || i.symbol, symbolKeepAspect: n.get("symbolKeepAspect") }, i)), t.isSeriesFiltered(n)) return;
        var u = oe(r);
        function h(c, f) {
          for (var g = n.getRawValue(f), d = n.getDataParams(f), A = 0; A < u.length; A++) {
            var p = u[A];
            c.setItemVisual(f, p, r[p](g, d));
          }
        }
        return { dataEach: a ? h : null };
      } }, wCt = { createOnAllSeries: true, performRawSeries: true, reset: function(n, t) {
        if (!n.hasSymbolVisual || t.isSeriesFiltered(n)) return;
        var e = n.getData();
        function i(r, a) {
          for (var o = r.getItemModel(a), s = 0; s < DU.length; s++) {
            var l = DU[s], u = o.getShallow(l, true);
            u != null && r.setItemVisual(a, l, u);
          }
        }
        return { dataEach: e.hasItemOption ? i : null };
      } };
      function YB(n, t, e) {
        switch (e) {
          case "color":
            var i = n.getItemVisual(t, "style");
            return i[n.getVisual("drawType")];
          case "opacity":
            return n.getItemVisual(t, "style").opacity;
          case "symbol":
          case "symbolSize":
          case "liftZ":
            return n.getItemVisual(t, e);
          default:
        }
      }
      function Lv(n, t) {
        switch (t) {
          case "color":
            var e = n.getVisual("style");
            return e[n.getVisual("drawType")];
          case "opacity":
            return n.getVisual("style").opacity;
          case "symbol":
          case "symbolSize":
          case "liftZ":
            return n.getVisual(t);
          default:
        }
      }
      function RU(n, t, e, i) {
        switch (e) {
          case "color":
            var r = n.ensureUniqueItemVisual(t, "style");
            r[n.getVisual("drawType")] = i, n.setItemVisual(t, "colorFromPalette", false);
            break;
          case "opacity":
            n.ensureUniqueItemVisual(t, "style").opacity = i;
            break;
          case "symbol":
          case "symbolSize":
          case "liftZ":
            n.setItemVisual(t, e, i);
            break;
          default:
        }
      }
      function LU(n, t) {
        function e(i, r) {
          var a = [];
          return i.eachComponent({ mainType: "series", subType: n, query: r }, function(o) {
            a.push(o.seriesIndex);
          }), a;
        }
        D([[n + "ToggleSelect", "toggleSelect"], [n + "Select", "select"], [n + "UnSelect", "unselect"]], function(i) {
          t(i[0], function(r, a, o) {
            r = X({}, r), Qn(r.type, i[1]), o.dispatchAction(X(r, { type: i[1], seriesIndex: e(a, r) }));
          });
        });
      }
      function od(n, t, e, i, r) {
        var a = n + t;
        e.isSilent(a) || (Ka("event " + a + " is deprecated."), i.eachComponent({ mainType: "series", subType: "pie" }, function(o) {
          for (var s = o.seriesIndex, l = o.option.selectedMap, u = r.selected, h = 0; h < u.length; h++) if (u[h].seriesIndex === s) {
            var c = o.getData(), f = Bh(c, r.fromActionPayload);
            e.trigger(a, { type: a, seriesId: o.id, name: Z(f) ? c.getName(f[0]) : c.getName(f), selected: ht(l) ? l : X({}, l) });
          }
        }));
      }
      function CCt(n, t, e) {
        n.on("selectchanged", function(i) {
          var r = e.getModel();
          i.isFromClick ? (od("map", "selectchanged", t, r, i), od("pie", "selectchanged", t, r, i)) : i.fromAction === "select" ? (od("map", "selected", t, r, i), od("pie", "selected", t, r, i)) : i.fromAction === "unselect" && (od("map", "unselected", t, r, i), od("pie", "unselected", t, r, i));
        });
      }
      function ec(n, t, e) {
        for (var i; n && !(t(n) && (i = n, e)); ) n = n.__hostTarget || n.parent;
        return i;
      }
      var SCt = Math.round(Math.random() * 9), bCt = typeof Object.defineProperty == "function", TCt = function() {
        function n() {
          this._id = "__ec_inner_" + SCt++;
        }
        return n.prototype.get = function(t) {
          return this._guard(t)[this._id];
        }, n.prototype.set = function(t, e) {
          var i = this._guard(t);
          return bCt ? Object.defineProperty(i, this._id, { value: e, enumerable: false, configurable: true }) : i[this._id] = e, this;
        }, n.prototype.delete = function(t) {
          return this.has(t) ? (delete this._guard(t)[this._id], true) : false;
        }, n.prototype.has = function(t) {
          return !!this._guard(t)[this._id];
        }, n.prototype._guard = function(t) {
          if (t !== Object(t)) throw TypeError("Value of WeakMap is not a non-null object.");
          return t;
        }, n;
      }(), BCt = ne.extend({ type: "triangle", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function(n, t) {
        var e = t.cx, i = t.cy, r = t.width / 2, a = t.height / 2;
        n.moveTo(e, i - a), n.lineTo(e + r, i + a), n.lineTo(e - r, i + a), n.closePath();
      } }), MCt = ne.extend({ type: "diamond", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function(n, t) {
        var e = t.cx, i = t.cy, r = t.width / 2, a = t.height / 2;
        n.moveTo(e, i - a), n.lineTo(e + r, i), n.lineTo(e, i + a), n.lineTo(e - r, i), n.closePath();
      } }), DCt = ne.extend({ type: "pin", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function(n, t) {
        var e = t.x, i = t.y, r = t.width / 5 * 3, a = Math.max(r, t.height), o = r / 2, s = o * o / (a - o), l = i - a + o + s, u = Math.asin(s / o), h = Math.cos(u) * o, c = Math.sin(u), f = Math.cos(u), g = o * 0.6, d = o * 0.7;
        n.moveTo(e - h, l + s), n.arc(e, l, o, Math.PI - u, Math.PI * 2 + u), n.bezierCurveTo(e + h - c * g, l + s + f * g, e, i - d, e, i), n.bezierCurveTo(e, i - d, e - h + c * g, l + s + f * g, e - h, l + s), n.closePath();
      } }), RCt = ne.extend({ type: "arrow", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function(n, t) {
        var e = t.height, i = t.width, r = t.x, a = t.y, o = i / 3 * 2;
        n.moveTo(r, a), n.lineTo(r + o, a + e), n.lineTo(r, a + e / 4 * 3), n.lineTo(r - o, a + e), n.lineTo(r, a), n.closePath();
      } }), LCt = { line: Kn, rect: fe, roundRect: fe, square: fe, circle: $s, diamond: MCt, pin: DCt, arrow: RCt, triangle: BCt }, PCt = { line: function(n, t, e, i, r) {
        r.x1 = n, r.y1 = t + i / 2, r.x2 = n + e, r.y2 = t + i / 2;
      }, rect: function(n, t, e, i, r) {
        r.x = n, r.y = t, r.width = e, r.height = i;
      }, roundRect: function(n, t, e, i, r) {
        r.x = n, r.y = t, r.width = e, r.height = i, r.r = Math.min(e, i) / 4;
      }, square: function(n, t, e, i, r) {
        var a = Math.min(e, i);
        r.x = n, r.y = t, r.width = a, r.height = a;
      }, circle: function(n, t, e, i, r) {
        r.cx = n + e / 2, r.cy = t + i / 2, r.r = Math.min(e, i) / 2;
      }, diamond: function(n, t, e, i, r) {
        r.cx = n + e / 2, r.cy = t + i / 2, r.width = e, r.height = i;
      }, pin: function(n, t, e, i, r) {
        r.x = n + e / 2, r.y = t + i / 2, r.width = e, r.height = i;
      }, arrow: function(n, t, e, i, r) {
        r.x = n + e / 2, r.y = t + i / 2, r.width = e, r.height = i;
      }, triangle: function(n, t, e, i, r) {
        r.cx = n + e / 2, r.cy = t + i / 2, r.width = e, r.height = i;
      } }, dE = {};
      D(LCt, function(n, t) {
        dE[t] = new n();
      });
      var NCt = ne.extend({ type: "symbol", shape: { symbolType: "", x: 0, y: 0, width: 0, height: 0 }, calculateTextPosition: function(n, t, e) {
        var i = d1(n, t, e), r = this.shape;
        return r && r.symbolType === "pin" && t.position === "inside" && (i.y = e.y + e.height * 0.4), i;
      }, buildPath: function(n, t, e) {
        var i = t.symbolType;
        if (i !== "none") {
          var r = dE[i];
          r || (i = "rect", r = dE[i]), PCt[i](t.x, t.y, t.width, t.height, r.shape), r.buildPath(n, r.shape, e);
        }
      } });
      function FCt(n, t) {
        if (this.type !== "image") {
          var e = this.style;
          this.__isEmptyBrush ? (e.stroke = n, e.fill = t || "#fff", e.lineWidth = 2) : this.shape.symbolType === "line" ? e.stroke = n : e.fill = n, this.markRedraw();
        }
      }
      function Un(n, t, e, i, r, a, o) {
        var s = n.indexOf("empty") === 0;
        s && (n = n.substr(5, 1).toLowerCase() + n.substr(6));
        var l;
        return n.indexOf("image://") === 0 ? l = M8(n.slice(8), new Wt(t, e, i, r), o ? "center" : "cover") : n.indexOf("path://") === 0 ? l = G1(n.slice(7), {}, new Wt(t, e, i, r), o ? "center" : "cover") : l = new NCt({ shape: { symbolType: n, x: t, y: e, width: i, height: r } }), l.__isEmptyBrush = s, l.setColor = FCt, a && l.setColor(a), l;
      }
      function sd(n) {
        return Z(n) || (n = [+n, +n]), [n[0] || 0, n[1] || 0];
      }
      function nc(n, t) {
        if (n != null) return Z(n) || (n = [n, n]), [st(n[0], t[0]) || 0, st(kt(n[1], n[0]), t[1]) || 0];
      }
      function ic(n) {
        return isFinite(n);
      }
      function kCt(n, t, e) {
        var i = t.x == null ? 0 : t.x, r = t.x2 == null ? 1 : t.x2, a = t.y == null ? 0 : t.y, o = t.y2 == null ? 0 : t.y2;
        t.global || (i = i * e.width + e.x, r = r * e.width + e.x, a = a * e.height + e.y, o = o * e.height + e.y), i = ic(i) ? i : 0, r = ic(r) ? r : 1, a = ic(a) ? a : 0, o = ic(o) ? o : 0;
        var s = n.createLinearGradient(i, a, r, o);
        return s;
      }
      function OCt(n, t, e) {
        var i = e.width, r = e.height, a = Math.min(i, r), o = t.x == null ? 0.5 : t.x, s = t.y == null ? 0.5 : t.y, l = t.r == null ? 0.5 : t.r;
        t.global || (o = o * i + e.x, s = s * r + e.y, l = l * a), o = ic(o) ? o : 0.5, s = ic(s) ? s : 0.5, l = l >= 0 && ic(l) ? l : 0.5;
        var u = n.createRadialGradient(o, s, 0, o, s, l);
        return u;
      }
      function WB(n, t, e) {
        for (var i = t.type === "radial" ? OCt(n, t, e) : kCt(n, t, e), r = t.colorStops, a = 0; a < r.length; a++) i.addColorStop(r[a].offset, r[a].color);
        return i;
      }
      function QCt(n, t) {
        if (n === t || !n && !t) return false;
        if (!n || !t || n.length !== t.length) return true;
        for (var e = 0; e < n.length; e++) if (n[e] !== t[e]) return true;
        return false;
      }
      function AE(n) {
        return parseInt(n, 10);
      }
      function ld(n, t, e) {
        var i = ["width", "height"][t], r = ["clientWidth", "clientHeight"][t], a = ["paddingLeft", "paddingTop"][t], o = ["paddingRight", "paddingBottom"][t];
        if (e[i] != null && e[i] !== "auto") return parseFloat(e[i]);
        var s = document.defaultView.getComputedStyle(n);
        return (n[r] || AE(s[i]) || AE(n.style[i])) - (AE(s[a]) || 0) - (AE(s[o]) || 0) | 0;
      }
      function zCt(n, t) {
        return !n || n === "solid" || !(t > 0) ? null : n === "dashed" ? [4 * t, 2 * t] : n === "dotted" ? [t] : ye(n) ? [n] : Z(n) ? n : null;
      }
      function XB(n) {
        var t = n.style, e = t.lineDash && t.lineWidth > 0 && zCt(t.lineDash, t.lineWidth), i = t.lineDashOffset;
        if (e) {
          var r = t.strokeNoScale && n.getLineScale ? n.getLineScale() : 1;
          r && r !== 1 && (e = K(e, function(a) {
            return a / r;
          }), i /= r);
        }
        return [e, i];
      }
      var GCt = new $o(true);
      function pE(n) {
        var t = n.stroke;
        return !(t == null || t === "none" || !(n.lineWidth > 0));
      }
      function PU(n) {
        return typeof n == "string" && n !== "none";
      }
      function vE(n) {
        var t = n.fill;
        return t != null && t !== "none";
      }
      function NU(n, t) {
        if (t.fillOpacity != null && t.fillOpacity !== 1) {
          var e = n.globalAlpha;
          n.globalAlpha = t.fillOpacity * t.opacity, n.fill(), n.globalAlpha = e;
        } else n.fill();
      }
      function FU(n, t) {
        if (t.strokeOpacity != null && t.strokeOpacity !== 1) {
          var e = n.globalAlpha;
          n.globalAlpha = t.strokeOpacity * t.opacity, n.stroke(), n.globalAlpha = e;
        } else n.stroke();
      }
      function $B(n, t, e) {
        var i = ST(t.image, t.__image, e);
        if (m1(i)) {
          var r = n.createPattern(i, t.repeat || "repeat");
          if (typeof DOMMatrix == "function" && r && r.setTransform) {
            var a = new DOMMatrix();
            a.translateSelf(t.x || 0, t.y || 0), a.rotateSelf(0, 0, (t.rotation || 0) * U_), a.scaleSelf(t.scaleX || 1, t.scaleY || 1), r.setTransform(a);
          }
          return r;
        }
      }
      function UCt(n, t, e, i) {
        var r, a = pE(e), o = vE(e), s = e.strokePercent, l = s < 1, u = !t.path;
        (!t.silent || l) && u && t.createPathProxy();
        var h = t.path || GCt, c = t.__dirty;
        if (!i) {
          var f = e.fill, g = e.stroke, d = o && !!f.colorStops, A = a && !!g.colorStops, p = o && !!f.image, v = a && !!g.image, y = void 0, m = void 0, _ = void 0, I = void 0, E = void 0;
          (d || A) && (E = t.getBoundingRect()), d && (y = c ? WB(n, f, E) : t.__canvasFillGradient, t.__canvasFillGradient = y), A && (m = c ? WB(n, g, E) : t.__canvasStrokeGradient, t.__canvasStrokeGradient = m), p && (_ = c || !t.__canvasFillPattern ? $B(n, f, t) : t.__canvasFillPattern, t.__canvasFillPattern = _), v && (I = c || !t.__canvasStrokePattern ? $B(n, g, t) : t.__canvasStrokePattern, t.__canvasStrokePattern = _), d ? n.fillStyle = y : p && (_ ? n.fillStyle = _ : o = false), A ? n.strokeStyle = m : v && (I ? n.strokeStyle = I : a = false);
        }
        var x = t.getGlobalScale();
        h.setScale(x[0], x[1], t.segmentIgnoreThreshold);
        var w, C;
        n.setLineDash && e.lineDash && (r = XB(t), w = r[0], C = r[1]);
        var S = true;
        (u || c & bg) && (h.setDPR(n.dpr), l ? h.setContext(null) : (h.setContext(n), S = false), h.reset(), t.buildPath(h, t.shape, i), h.toStatic(), t.pathUpdated()), S && h.rebuildPath(n, l ? s : 1), w && (n.setLineDash(w), n.lineDashOffset = C), i || (e.strokeFirst ? (a && FU(n, e), o && NU(n, e)) : (o && NU(n, e), a && FU(n, e))), w && n.setLineDash([]);
      }
      function VCt(n, t, e) {
        var i = t.__image = ST(e.image, t.__image, t, t.onload);
        if (!(!i || !m1(i))) {
          var r = e.x || 0, a = e.y || 0, o = t.getWidth(), s = t.getHeight(), l = i.width / i.height;
          if (o == null && s != null ? o = s * l : s == null && o != null ? s = o / l : o == null && s == null && (o = i.width, s = i.height), e.sWidth && e.sHeight) {
            var u = e.sx || 0, h = e.sy || 0;
            n.drawImage(i, u, h, e.sWidth, e.sHeight, r, a, o, s);
          } else if (e.sx && e.sy) {
            var u = e.sx, h = e.sy, c = o - u, f = s - h;
            n.drawImage(i, u, h, c, f, r, a, o, s);
          } else n.drawImage(i, r, a, o, s);
        }
      }
      function jCt(n, t, e) {
        var i, r = e.text;
        if (r != null && (r += ""), r) {
          n.font = e.font || Wl, n.textAlign = e.textAlign, n.textBaseline = e.textBaseline;
          var a = void 0, o = void 0;
          n.setLineDash && e.lineDash && (i = XB(t), a = i[0], o = i[1]), a && (n.setLineDash(a), n.lineDashOffset = o), e.strokeFirst ? (pE(e) && n.strokeText(r, e.x, e.y), vE(e) && n.fillText(r, e.x, e.y)) : (vE(e) && n.fillText(r, e.x, e.y), pE(e) && n.strokeText(r, e.x, e.y)), a && n.setLineDash([]);
        }
      }
      var kU = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], OU = [["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]];
      function QU(n, t, e, i, r) {
        var a = false;
        if (!i && (e = e || {}, t === e)) return false;
        if (i || t.opacity !== e.opacity) {
          Sr(n, r), a = true;
          var o = Math.max(Math.min(t.opacity, 1), 0);
          n.globalAlpha = isNaN(o) ? Rh.opacity : o;
        }
        (i || t.blend !== e.blend) && (a || (Sr(n, r), a = true), n.globalCompositeOperation = t.blend || Rh.blend);
        for (var s = 0; s < kU.length; s++) {
          var l = kU[s];
          (i || t[l] !== e[l]) && (a || (Sr(n, r), a = true), n[l] = n.dpr * (t[l] || 0));
        }
        return (i || t.shadowColor !== e.shadowColor) && (a || (Sr(n, r), a = true), n.shadowColor = t.shadowColor || Rh.shadowColor), a;
      }
      function zU(n, t, e, i, r) {
        var a = Pv(t, r.inHover), o = i ? null : e && Pv(e, r.inHover) || {};
        if (a === o) return false;
        var s = QU(n, a, o, i, r);
        if ((i || a.fill !== o.fill) && (s || (Sr(n, r), s = true), PU(a.fill) && (n.fillStyle = a.fill)), (i || a.stroke !== o.stroke) && (s || (Sr(n, r), s = true), PU(a.stroke) && (n.strokeStyle = a.stroke)), (i || a.opacity !== o.opacity) && (s || (Sr(n, r), s = true), n.globalAlpha = a.opacity == null ? 1 : a.opacity), t.hasStroke()) {
          var l = a.lineWidth, u = l / (a.strokeNoScale && t.getLineScale ? t.getLineScale() : 1);
          n.lineWidth !== u && (s || (Sr(n, r), s = true), n.lineWidth = u);
        }
        for (var h = 0; h < OU.length; h++) {
          var c = OU[h], f = c[0];
          (i || a[f] !== o[f]) && (s || (Sr(n, r), s = true), n[f] = a[f] || c[1]);
        }
        return s;
      }
      function qCt(n, t, e, i, r) {
        return QU(n, Pv(t, r.inHover), e && Pv(e, r.inHover), i, r);
      }
      function GU(n, t) {
        var e = t.transform, i = n.dpr || 1;
        e ? n.setTransform(i * e[0], i * e[1], i * e[2], i * e[3], i * e[4], i * e[5]) : n.setTransform(i, 0, 0, i, 0, 0);
      }
      function HCt(n, t, e) {
        for (var i = false, r = 0; r < n.length; r++) {
          var a = n[r];
          i = i || a.isZeroArea(), GU(t, a), t.beginPath(), a.buildPath(t, a.shape), t.clip();
        }
        e.allClipped = i;
      }
      function YCt(n, t) {
        return n && t ? n[0] !== t[0] || n[1] !== t[1] || n[2] !== t[2] || n[3] !== t[3] || n[4] !== t[4] || n[5] !== t[5] : !(!n && !t);
      }
      var UU = 1, VU = 2, jU = 3, qU = 4;
      function WCt(n) {
        var t = vE(n), e = pE(n);
        return !(n.lineDash || !(+t ^ +e) || t && typeof n.fill != "string" || e && typeof n.stroke != "string" || n.strokePercent < 1 || n.strokeOpacity < 1 || n.fillOpacity < 1);
      }
      function Sr(n, t) {
        t.batchFill && n.fill(), t.batchStroke && n.stroke(), t.batchFill = "", t.batchStroke = "";
      }
      function Pv(n, t) {
        return t && n.__hoverStyle || n.style;
      }
      function HU(n, t) {
        rc(n, t, { inHover: false, viewWidth: 0, viewHeight: 0 }, true);
      }
      function rc(n, t, e, i) {
        var r = t.transform;
        if (!t.shouldBePainted(e.viewWidth, e.viewHeight, false, false)) {
          t.__dirty &= ~jr, t.__isRendered = false;
          return;
        }
        var a = t.__clipPaths, o = e.prevElClipPaths, s = false, l = false;
        if ((!o || QCt(a, o)) && (o && o.length && (Sr(n, e), n.restore(), l = s = true, e.prevElClipPaths = null, e.allClipped = false, e.prevEl = null), a && a.length && (Sr(n, e), n.save(), HCt(a, n, e), s = true), e.prevElClipPaths = a), e.allClipped) {
          t.__isRendered = false;
          return;
        }
        t.beforeBrush && t.beforeBrush(), t.innerBeforeBrush();
        var u = e.prevEl;
        u || (l = s = true);
        var h = t instanceof ne && t.autoBatch && WCt(t.style);
        s || YCt(r, u.transform) ? (Sr(n, e), GU(n, t)) : h || Sr(n, e);
        var c = Pv(t, e.inHover);
        t instanceof ne ? (e.lastDrawType !== UU && (l = true, e.lastDrawType = UU), zU(n, t, u, l, e), (!h || !e.batchFill && !e.batchStroke) && n.beginPath(), UCt(n, t, c, h), h && (e.batchFill = c.fill || "", e.batchStroke = c.stroke || "")) : t instanceof Fg ? (e.lastDrawType !== jU && (l = true, e.lastDrawType = jU), zU(n, t, u, l, e), jCt(n, t, c)) : t instanceof gi ? (e.lastDrawType !== VU && (l = true, e.lastDrawType = VU), qCt(n, t, u, l, e), VCt(n, t, c)) : t.getTemporalDisplayables && (e.lastDrawType !== qU && (l = true, e.lastDrawType = qU), XCt(n, t, e)), h && i && Sr(n, e), t.innerAfterBrush(), t.afterBrush && t.afterBrush(), e.prevEl = t, t.__dirty = 0, t.__isRendered = true;
      }
      function XCt(n, t, e) {
        var i = t.getDisplayables(), r = t.getTemporalDisplayables();
        n.save();
        var a = { prevElClipPaths: null, prevEl: null, allClipped: false, viewWidth: e.viewWidth, viewHeight: e.viewHeight, inHover: e.inHover }, o, s;
        for (o = t.getCursor(), s = i.length; o < s; o++) {
          var l = i[o];
          l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), rc(n, l, a, o === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
        }
        for (var u = 0, h = r.length; u < h; u++) {
          var l = r[u];
          l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), rc(n, l, a, u === h - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
        }
        t.clearTemporalDisplayables(), t.notClear = true, n.restore();
      }
      var ZB = new TCt(), YU = new Vp(100), WU = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
      function ud(n, t) {
        if (n === "none") return null;
        var e = t.getDevicePixelRatio(), i = t.getZr(), r = i.painter.type === "svg";
        n.dirty && ZB.delete(n);
        var a = ZB.get(n);
        if (a) return a;
        var o = wt(n, { symbol: "rect", symbolSize: 1, symbolKeepAspect: true, color: "rgba(0, 0, 0, 0.2)", backgroundColor: null, dashArrayX: 5, dashArrayY: 5, rotation: 0, maxTileWidth: 512, maxTileHeight: 512 });
        o.backgroundColor === "none" && (o.backgroundColor = null);
        var s = { repeat: "repeat" };
        return l(s), s.rotation = o.rotation, s.scaleX = s.scaleY = r ? 1 : 1 / e, ZB.set(n, s), n.dirty = false, s;
        function l(u) {
          for (var h = [e], c = true, f = 0; f < WU.length; ++f) {
            var g = o[WU[f]];
            if (g != null && !Z(g) && !ht(g) && !ye(g) && typeof g != "boolean") {
              c = false;
              break;
            }
            h.push(g);
          }
          var d;
          if (c) {
            d = h.join(",") + (r ? "-svg" : "");
            var A = YU.get(d);
            A && (r ? u.svgElement = A : u.image = A);
          }
          var p = $U(o.dashArrayX), v = $Ct(o.dashArrayY), y = XU(o.symbol), m = ZCt(p), _ = ZU(v), I = !r && Xl.createCanvas(), E = r && { tag: "g", attrs: {}, key: "dcl", children: [] }, x = C(), w;
          I && (I.width = x.width * e, I.height = x.height * e, w = I.getContext("2d")), S(), c && YU.put(d, I || E), u.image = I, u.svgElement = E, u.svgWidth = x.width, u.svgHeight = x.height;
          function C() {
            for (var b = 1, T = 0, B = m.length; T < B; ++T) b = c4(b, m[T]);
            for (var R = 1, T = 0, B = y.length; T < B; ++T) R = c4(R, y[T].length);
            b *= R;
            var M = _ * m.length * y.length;
            if (true) {
              var L = function(N) {
              };
              b > o.maxTileWidth && L("maxTileWidth"), M > o.maxTileHeight && L("maxTileHeight");
            }
            return { width: Math.max(1, Math.min(b, o.maxTileWidth)), height: Math.max(1, Math.min(M, o.maxTileHeight)) };
          }
          function S() {
            w && (w.clearRect(0, 0, I.width, I.height), o.backgroundColor && (w.fillStyle = o.backgroundColor, w.fillRect(0, 0, I.width, I.height)));
            for (var b = 0, T = 0; T < v.length; ++T) b += v[T];
            if (b <= 0) return;
            for (var B = -_, R = 0, M = 0, L = 0; B < x.height; ) {
              if (R % 2 === 0) {
                for (var N = M / 2 % y.length, F = 0, k = 0, O = 0; F < x.width * 2; ) {
                  for (var Q = 0, T = 0; T < p[L].length; ++T) Q += p[L][T];
                  if (Q <= 0) break;
                  if (k % 2 === 0) {
                    var j = (1 - o.symbolSize) * 0.5, Y = F + p[L][k] * j, G = B + v[R] * j, $ = p[L][k] * o.symbolSize, J = v[R] * o.symbolSize, et = O / 2 % y[N].length;
                    nt(Y, G, $, J, y[N][et]);
                  }
                  F += p[L][k], ++O, ++k, k === p[L].length && (k = 0);
                }
                ++L, L === p.length && (L = 0);
              }
              B += v[R], ++M, ++R, R === v.length && (R = 0);
            }
            function nt(gt, q, W, it, Ot) {
              var pt = r ? 1 : e, St = Un(Ot, gt * pt, q * pt, W * pt, it * pt, o.color, o.symbolKeepAspect);
              if (r) {
                var bt = i.painter.renderOneToVNode(St);
                bt && E.children.push(bt);
              } else HU(w, St);
            }
          }
        }
      }
      function XU(n) {
        if (!n || n.length === 0) return [["rect"]];
        if (ht(n)) return [[n]];
        for (var t = true, e = 0; e < n.length; ++e) if (!ht(n[e])) {
          t = false;
          break;
        }
        if (t) return XU([n]);
        for (var i = [], e = 0; e < n.length; ++e) ht(n[e]) ? i.push([n[e]]) : i.push(n[e]);
        return i;
      }
      function $U(n) {
        if (!n || n.length === 0) return [[0, 0]];
        if (ye(n)) {
          var t = Math.ceil(n);
          return [[t, t]];
        }
        for (var e = true, i = 0; i < n.length; ++i) if (!ye(n[i])) {
          e = false;
          break;
        }
        if (e) return $U([n]);
        for (var r = [], i = 0; i < n.length; ++i) if (ye(n[i])) {
          var t = Math.ceil(n[i]);
          r.push([t, t]);
        } else {
          var t = K(n[i], function(s) {
            return Math.ceil(s);
          });
          t.length % 2 === 1 ? r.push(t.concat(t)) : r.push(t);
        }
        return r;
      }
      function $Ct(n) {
        if (!n || typeof n == "object" && n.length === 0) return [0, 0];
        if (ye(n)) {
          var t = Math.ceil(n);
          return [t, t];
        }
        var e = K(n, function(i) {
          return Math.ceil(i);
        });
        return n.length % 2 ? e.concat(e) : e;
      }
      function ZCt(n) {
        return K(n, function(t) {
          return ZU(t);
        });
      }
      function ZU(n) {
        for (var t = 0, e = 0; e < n.length; ++e) t += n[e];
        return n.length % 2 === 1 ? t * 2 : t;
      }
      function KCt(n, t) {
        n.eachRawSeries(function(e) {
          if (!n.isSeriesFiltered(e)) {
            var i = e.getData();
            i.hasItemVisual() && i.each(function(o) {
              var s = i.getItemVisual(o, "decal");
              if (s) {
                var l = i.ensureUniqueItemVisual(o, "style");
                l.decal = ud(s, t);
              }
            });
            var r = i.getVisual("decal");
            if (r) {
              var a = i.getVisual("style");
              a.decal = ud(r, t);
            }
          }
        });
      }
      var io = new ga(), yE = {};
      function JCt(n, t) {
        yE[n] && Ei("Already has an implementation of " + n + "."), yE[n] = t;
      }
      function tSt(n) {
        return yE[n] || Ei("Implementation of " + n + " doesn't exists."), yE[n];
      }
      var eSt = 1, nSt = 800, iSt = 900, rSt = 1e3, aSt = 2e3, oSt = 5e3, KU = 1e3, sSt = 1100, KB = 2e3, JU = 3e3, lSt = 4e3, mE = 4500, uSt = 4600, hSt = 5e3, cSt = 6e3, tV = 7e3, fSt = { PROCESSOR: { FILTER: rSt, SERIES_FILTER: nSt, STATISTIC: oSt }, VISUAL: { LAYOUT: KU, PROGRESSIVE_LAYOUT: sSt, GLOBAL: KB, CHART: JU, POST_CHART_LAYOUT: uSt, COMPONENT: lSt, BRUSH: hSt, CHART_ITEM: mE, ARIA: cSt, DECAL: tV } }, ki = "__flagInMainProcess", br = "__pendingUpdate", JB = "__needsUpdateStatus", eV = /^[a-zA-Z0-9_]+$/, tM = "__connectUpdateStatus", nV = 0, gSt = 1, dSt = 2;
      function iV(n) {
        return function() {
          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
          if (this.isDisposed()) {
            Wr(this.id);
            return;
          }
          return aV(this, n, t);
        };
      }
      function rV(n) {
        return function() {
          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
          return aV(this, n, t);
        };
      }
      function aV(n, t, e) {
        return e[0] = e[0] && e[0].toLowerCase(), ga.prototype[t].apply(n, e);
      }
      var oV = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t;
      }(ga), sV = oV.prototype;
      sV.on = rV("on"), sV.off = rV("off");
      var hd, eM, _E, pu, nM, iM, rM, Nv, Fv, lV, uV, aM, hV, EE, cV, fV, Sa, gV, dV = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this, new ICt()) || this;
          a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], r = r || {}, ht(i) && (i = AV[i]), a._dom = e;
          var o = "canvas", s = "auto", l = false;
          if (true) {
            var u = re.hasGlobalWindow ? window : global;
            u && (o = kt(u.__ECHARTS__DEFAULT__RENDERER__, o), s = kt(u.__ECHARTS__DEFAULT__COARSE_POINTER, s), l = kt(u.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, l));
          }
          r.ssr && sEt(function(g) {
            var d = Nt(g), A = d.dataIndex;
            if (A != null) {
              var p = dt();
              return p.set("series_index", d.seriesIndex), p.set("data_index", A), d.ssrType && p.set("ssr_type", d.ssrType), p;
            }
          });
          var h = a._zr = e4(e, { renderer: r.renderer || o, devicePixelRatio: r.devicePixelRatio, width: r.width, height: r.height, ssr: r.ssr, useDirtyRect: kt(r.useDirtyRect, l), useCoarsePointer: kt(r.useCoarsePointer, s), pointerSize: r.pointerSize });
          a._ssr = r.ssr, a._throttledZrFlush = qB(ct(h.flush, h), 17), i = Ct(i), i && D6(i, true), a._theme = i, a._locale = Rxt(r.locale || H8), a._coordSysMgr = new ed();
          var c = a._api = cV(a);
          function f(g, d) {
            return g.__prio - d.__prio;
          }
          return W_(xE, f), W_(sM, f), a._scheduler = new xU(a, c, sM, xE), a._messageCenter = new oV(), a._initEvents(), a.resize = ct(a.resize, a), h.animation.on("frame", a._onframe, a), lV(h, a), uV(h, a), Q_(a), a;
        }
        return t.prototype._onframe = function() {
          if (!this._disposed) {
            gV(this);
            var e = this._scheduler;
            if (this[br]) {
              var i = this[br].silent;
              this[ki] = true;
              try {
                hd(this), pu.update.call(this, null, this[br].updateParams);
              } catch (l) {
                throw this[ki] = false, this[br] = null, l;
              }
              this._zr.flush(), this[ki] = false, this[br] = null, Nv.call(this, i), Fv.call(this, i);
            } else if (e.unfinished) {
              var r = eSt, a = this._model, o = this._api;
              e.unfinished = false;
              do {
                var s = +/* @__PURE__ */ new Date();
                e.performSeriesTasks(a), e.performDataProcessorTasks(a), iM(this, a), e.performVisualTasks(a), EE(this, this._model, o, "remain", {}), r -= +/* @__PURE__ */ new Date() - s;
              } while (r > 0 && e.unfinished);
              e.unfinished || this._zr.flush();
            }
          }
        }, t.prototype.getDom = function() {
          return this._dom;
        }, t.prototype.getId = function() {
          return this.id;
        }, t.prototype.getZr = function() {
          return this._zr;
        }, t.prototype.isSSR = function() {
          return this._ssr;
        }, t.prototype.setOption = function(e, i, r) {
          if (this[ki]) {
            Ei("`setOption` should not be called during main process.");
            return;
          }
          if (this._disposed) {
            Wr(this.id);
            return;
          }
          var a, o, s;
          if (Et(i) && (r = i.lazyUpdate, a = i.silent, o = i.replaceMerge, s = i.transition, i = i.notMerge), this[ki] = true, !this._model || i) {
            var l = new awt(this._api), u = this._theme, h = this._model = new BB();
            h.scheduler = this._scheduler, h.ssr = this._ssr, h.init(null, null, null, u, this._locale, l);
          }
          this._model.setOption(e, { replaceMerge: o }, lM);
          var c = { seriesTransition: s, optionChanged: true };
          if (r) this[br] = { silent: a, updateParams: c }, this[ki] = false, this.getZr().wakeUp();
          else {
            try {
              hd(this), pu.update.call(this, null, c);
            } catch (f) {
              throw this[br] = null, this[ki] = false, f;
            }
            this._ssr || this._zr.flush(), this[br] = null, this[ki] = false, Nv.call(this, a), Fv.call(this, a);
          }
        }, t.prototype.setTheme = function() {
          Ka("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
        }, t.prototype.getModel = function() {
          return this._model;
        }, t.prototype.getOption = function() {
          return this._model && this._model.getOption();
        }, t.prototype.getWidth = function() {
          return this._zr.getWidth();
        }, t.prototype.getHeight = function() {
          return this._zr.getHeight();
        }, t.prototype.getDevicePixelRatio = function() {
          return this._zr.painter.dpr || re.hasGlobalWindow && window.devicePixelRatio || 1;
        }, t.prototype.getRenderedCanvas = function(e) {
          return Qn("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(e);
        }, t.prototype.renderToCanvas = function(e) {
          e = e || {};
          var i = this._zr.painter;
          if (i.type !== "canvas") throw new Error("renderToCanvas can only be used in the canvas renderer.");
          return i.getRenderedCanvas({ backgroundColor: e.backgroundColor || this._model.get("backgroundColor"), pixelRatio: e.pixelRatio || this.getDevicePixelRatio() });
        }, t.prototype.renderToSVGString = function(e) {
          e = e || {};
          var i = this._zr.painter;
          if (i.type !== "svg") throw new Error("renderToSVGString can only be used in the svg renderer.");
          return i.renderToString({ useViewBox: e.useViewBox });
        }, t.prototype.getSvgDataURL = function() {
          if (re.svgSupported) {
            var e = this._zr, i = e.storage.getDisplayList();
            return D(i, function(r) {
              r.stopAnimation(null, true);
            }), e.painter.toDataURL();
          }
        }, t.prototype.getDataURL = function(e) {
          if (this._disposed) {
            Wr(this.id);
            return;
          }
          e = e || {};
          var i = e.excludeComponents, r = this._model, a = [], o = this;
          D(i, function(l) {
            r.eachComponent({ mainType: l }, function(u) {
              var h = o._componentsMap[u.__viewId];
              h.group.ignore || (a.push(h), h.group.ignore = true);
            });
          });
          var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(e).toDataURL("image/" + (e && e.type || "png"));
          return D(a, function(l) {
            l.group.ignore = false;
          }), s;
        }, t.prototype.getConnectedDataURL = function(e) {
          if (this._disposed) {
            Wr(this.id);
            return;
          }
          var i = e.type === "svg", r = this.group, a = Math.min, o = Math.max, s = 1 / 0;
          if (pV[r]) {
            var l = s, u = s, h = -s, c = -s, f = [], g = e && e.pixelRatio || this.getDevicePixelRatio();
            D(Ov, function(m, _) {
              if (m.group === r) {
                var I = i ? m.getZr().painter.getSvgDom().innerHTML : m.renderToCanvas(Ct(e)), E = m.getDom().getBoundingClientRect();
                l = a(E.left, l), u = a(E.top, u), h = o(E.right, h), c = o(E.bottom, c), f.push({ dom: I, left: E.left, top: E.top });
              }
            }), l *= g, u *= g, h *= g, c *= g;
            var d = h - l, A = c - u, p = Xl.createCanvas(), v = e4(p, { renderer: i ? "svg" : "canvas" });
            if (v.resize({ width: d, height: A }), i) {
              var y = "";
              return D(f, function(m) {
                var _ = m.left - l, I = m.top - u;
                y += '<g transform="translate(' + _ + "," + I + ')">' + m.dom + "</g>";
              }), v.painter.getSvgRoot().innerHTML = y, e.connectedBackgroundColor && v.painter.setBackgroundColor(e.connectedBackgroundColor), v.refreshImmediately(), v.painter.toDataURL();
            } else return e.connectedBackgroundColor && v.add(new fe({ shape: { x: 0, y: 0, width: d, height: A }, style: { fill: e.connectedBackgroundColor } })), D(f, function(m) {
              var _ = new gi({ style: { x: m.left * g - l, y: m.top * g - u, image: m.dom } });
              v.add(_);
            }), v.refreshImmediately(), p.toDataURL("image/" + (e && e.type || "png"));
          } else return this.getDataURL(e);
        }, t.prototype.convertToPixel = function(e, i) {
          return nM(this, "convertToPixel", e, i);
        }, t.prototype.convertFromPixel = function(e, i) {
          return nM(this, "convertFromPixel", e, i);
        }, t.prototype.containPixel = function(e, i) {
          if (this._disposed) {
            Wr(this.id);
            return;
          }
          var r = this._model, a, o = ev(r, e);
          return D(o, function(s, l) {
            l.indexOf("Models") >= 0 && D(s, function(u) {
              var h = u.coordinateSystem;
              if (h && h.containPoint) a = a || !!h.containPoint(i);
              else if (l === "seriesModels") {
                var c = this._chartsMap[u.__viewId];
                c && c.containPoint ? a = a || c.containPoint(i, u) : gn(l + ": " + (c ? "The found component do not support containPoint." : "No view mapping to the found component."));
              } else gn(l + ": containPoint is not supported");
            }, this);
          }, this), !!a;
        }, t.prototype.getVisual = function(e, i) {
          var r = this._model, a = ev(r, e, { defaultMainType: "series" }), o = a.seriesModel;
          o || gn("There is no specified series model");
          var s = o.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(a.dataIndex) : null;
          return l != null ? YB(s, l, i) : Lv(s, i);
        }, t.prototype.getViewOfComponentModel = function(e) {
          return this._componentsMap[e.__viewId];
        }, t.prototype.getViewOfSeriesModel = function(e) {
          return this._chartsMap[e.__viewId];
        }, t.prototype._initEvents = function() {
          var e = this;
          D(ASt, function(i) {
            var r = function(a) {
              var o = e.getModel(), s = a.target, l, u = i === "globalout";
              if (u ? l = {} : s && ec(s, function(d) {
                var A = Nt(d);
                if (A && A.dataIndex != null) {
                  var p = A.dataModel || o.getSeriesByIndex(A.seriesIndex);
                  return l = p && p.getDataParams(A.dataIndex, A.dataType, s) || {}, true;
                } else if (A.eventData) return l = X({}, A.eventData), true;
              }, true), l) {
                var h = l.componentType, c = l.componentIndex;
                (h === "markLine" || h === "markPoint" || h === "markArea") && (h = "series", c = l.seriesIndex);
                var f = h && c != null && o.getComponent(h, c), g = f && e[f.mainType === "series" ? "_chartsMap" : "_componentsMap"][f.__viewId];
                !u && !(f && g) && gn("model or view can not be found by params"), l.event = a, l.type = i, e._$eventProcessor.eventInfo = { targetEl: s, packedEvent: l, model: f, view: g }, e.trigger(i, l);
              }
            };
            r.zrEventfulCallAtLast = true, e._zr.on(i, r, e);
          }), D(kv, function(i, r) {
            e._messageCenter.on(r, function(a) {
              this.trigger(r, a);
            }, e);
          }), D(["selectchanged"], function(i) {
            e._messageCenter.on(i, function(r) {
              this.trigger(i, r);
            }, e);
          }), CCt(this._messageCenter, this, this._api);
        }, t.prototype.isDisposed = function() {
          return this._disposed;
        }, t.prototype.clear = function() {
          if (this._disposed) {
            Wr(this.id);
            return;
          }
          this.setOption({ series: [] }, true);
        }, t.prototype.dispose = function() {
          if (this._disposed) {
            Wr(this.id);
            return;
          }
          this._disposed = true;
          var e = this.getDom();
          e && E4(this.getDom(), hM, "");
          var i = this, r = i._api, a = i._model;
          D(i._componentsViews, function(o) {
            o.dispose(a, r);
          }), D(i._chartsViews, function(o) {
            o.dispose(a, r);
          }), i._zr.dispose(), i._dom = i._model = i._chartsMap = i._componentsMap = i._chartsViews = i._componentsViews = i._scheduler = i._api = i._zr = i._throttledZrFlush = i._theme = i._coordSysMgr = i._messageCenter = null, delete Ov[i.id];
        }, t.prototype.resize = function(e) {
          if (this[ki]) {
            Ei("`resize` should not be called during main process.");
            return;
          }
          if (this._disposed) {
            Wr(this.id);
            return;
          }
          this._zr.resize(e);
          var i = this._model;
          if (this._loadingFX && this._loadingFX.resize(), !!i) {
            var r = i.resetOption("media"), a = e && e.silent;
            this[br] && (a == null && (a = this[br].silent), r = true, this[br] = null), this[ki] = true;
            try {
              r && hd(this), pu.update.call(this, { type: "resize", animation: X({ duration: 0 }, e && e.animation) });
            } catch (o) {
              throw this[ki] = false, o;
            }
            this[ki] = false, Nv.call(this, a), Fv.call(this, a);
          }
        }, t.prototype.showLoading = function(e, i) {
          if (this._disposed) {
            Wr(this.id);
            return;
          }
          if (Et(e) && (i = e, e = ""), e = e || "default", this.hideLoading(), !uM[e]) {
            gn("Loading effects " + e + " not exists.");
            return;
          }
          var r = uM[e](this._api, i), a = this._zr;
          this._loadingFX = r, a.add(r);
        }, t.prototype.hideLoading = function() {
          if (this._disposed) {
            Wr(this.id);
            return;
          }
          this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
        }, t.prototype.makeActionFromEvent = function(e) {
          var i = X({}, e);
          return i.type = kv[e.type], i;
        }, t.prototype.dispatchAction = function(e, i) {
          if (this._disposed) {
            Wr(this.id);
            return;
          }
          if (Et(i) || (i = { silent: !!i }), !!IE[e.type] && this._model) {
            if (this[ki]) {
              this._pendingActions.push(e);
              return;
            }
            var r = i.silent;
            rM.call(this, e, r);
            var a = i.flush;
            a ? this._zr.flush() : a !== false && re.browser.weChat && this._throttledZrFlush(), Nv.call(this, r), Fv.call(this, r);
          }
        }, t.prototype.updateLabelLayout = function() {
          io.trigger("series:layoutlabels", this._model, this._api, { updatedSeries: [] });
        }, t.prototype.appendData = function(e) {
          if (this._disposed) {
            Wr(this.id);
            return;
          }
          var i = e.seriesIndex, r = this.getModel(), a = r.getSeriesByIndex(i);
          It(e.data && a), a.appendData(e), this._scheduler.unfinished = true, this.getZr().wakeUp();
        }, t.internalField = function() {
          hd = function(c) {
            var f = c._scheduler;
            f.restorePipelines(c._model), f.prepareStageTasks(), eM(c, true), eM(c, false), f.plan();
          }, eM = function(c, f) {
            for (var g = c._model, d = c._scheduler, A = f ? c._componentsViews : c._chartsViews, p = f ? c._componentsMap : c._chartsMap, v = c._zr, y = c._api, m = 0; m < A.length; m++) A[m].__alive = false;
            f ? g.eachComponent(function(E, x) {
              E !== "series" && _(x);
            }) : g.eachSeries(_);
            function _(E) {
              var x = E.__requireNewView;
              E.__requireNewView = false;
              var w = "_ec_" + E.id + "_" + E.type, C = !x && p[w];
              if (!C) {
                var S = Ho(E.type), b = f ? un.getClass(S.main, S.sub) : qe.getClass(S.sub);
                It(b, S.sub + " does not exist."), C = new b(), C.init(g, y), p[w] = C, A.push(C), v.add(C.group);
              }
              E.__viewId = C.__id = w, C.__alive = true, C.__model = E, C.group.__ecComponentInfo = { mainType: E.mainType, index: E.componentIndex }, !f && d.prepareView(C, E, g, y);
            }
            for (var m = 0; m < A.length; ) {
              var I = A[m];
              I.__alive ? m++ : (!f && I.renderTask.dispose(), v.remove(I.group), I.dispose(g, y), A.splice(m, 1), p[I.__id] === I && delete p[I.__id], I.__id = I.group.__ecComponentInfo = null);
            }
          }, _E = function(c, f, g, d, A) {
            var p = c._model;
            if (p.setUpdatePayload(g), !d) {
              D([].concat(c._componentsViews).concat(c._chartsViews), I);
              return;
            }
            var v = {};
            v[d + "Id"] = g[d + "Id"], v[d + "Index"] = g[d + "Index"], v[d + "Name"] = g[d + "Name"];
            var y = { mainType: d, query: v };
            A && (y.subType = A);
            var m = g.excludeSeriesId, _;
            m != null && (_ = dt(), D(ze(m), function(E) {
              var x = Hn(E, null);
              x != null && _.set(x, true);
            })), p && p.eachComponent(y, function(E) {
              var x = _ && _.get(E.id) != null;
              if (!x) if (f8(g)) if (E instanceof tn) g.type === zh && !g.notBlur && !E.get(["emphasis", "disabled"]) && DIt(E, g, c._api);
              else {
                var w = $T(E.mainType, E.componentIndex, g.name, c._api), C = w.focusSelf, S = w.dispatchers;
                g.type === zh && C && !g.notBlur && XT(E.mainType, E.componentIndex, c._api), S && D(S, function(b) {
                  g.type === zh ? Ws(b) : Xs(b);
                });
              }
              else KT(g) && E instanceof tn && (PIt(E, g, c._api), h8(E), Sa(c));
            }, c), p && p.eachComponent(y, function(E) {
              var x = _ && _.get(E.id) != null;
              x || I(c[d === "series" ? "_chartsMap" : "_componentsMap"][E.__viewId]);
            }, c);
            function I(E) {
              E && E.__alive && E[f] && E[f](E.__model, p, c._api, g);
            }
          }, pu = { prepareAndUpdate: function(c) {
            hd(this), pu.update.call(this, c, { optionChanged: c.newOption != null });
          }, update: function(c, f) {
            var g = this._model, d = this._api, A = this._zr, p = this._coordSysMgr, v = this._scheduler;
            if (g) {
              g.setUpdatePayload(c), v.restoreData(g, c), v.performSeriesTasks(g), p.create(g, d), v.performDataProcessorTasks(g, c), iM(this, g), p.update(g, d), e(g), v.performVisualTasks(g, c), aM(this, g, d, c, f);
              var y = g.get("backgroundColor") || "transparent", m = g.get("darkMode");
              A.setBackgroundColor(y), m != null && m !== "auto" && A.setDarkMode(m), io.trigger("afterupdate", g, d);
            }
          }, updateTransform: function(c) {
            var f = this, g = this._model, d = this._api;
            if (g) {
              g.setUpdatePayload(c);
              var A = [];
              g.eachComponent(function(v, y) {
                if (v !== "series") {
                  var m = f.getViewOfComponentModel(y);
                  if (m && m.__alive) if (m.updateTransform) {
                    var _ = m.updateTransform(y, g, d, c);
                    _ && _.update && A.push(m);
                  } else A.push(m);
                }
              });
              var p = dt();
              g.eachSeries(function(v) {
                var y = f._chartsMap[v.__viewId];
                if (y.updateTransform) {
                  var m = y.updateTransform(v, g, d, c);
                  m && m.update && p.set(v.uid, 1);
                } else p.set(v.uid, 1);
              }), e(g), this._scheduler.performVisualTasks(g, c, { setDirty: true, dirtyMap: p }), EE(this, g, d, c, {}, p), io.trigger("afterupdate", g, d);
            }
          }, updateView: function(c) {
            var f = this._model;
            f && (f.setUpdatePayload(c), qe.markUpdateMethod(c, "updateView"), e(f), this._scheduler.performVisualTasks(f, c, { setDirty: true }), aM(this, f, this._api, c, {}), io.trigger("afterupdate", f, this._api));
          }, updateVisual: function(c) {
            var f = this, g = this._model;
            g && (g.setUpdatePayload(c), g.eachSeries(function(d) {
              d.getData().clearAllVisual();
            }), qe.markUpdateMethod(c, "updateVisual"), e(g), this._scheduler.performVisualTasks(g, c, { visualType: "visual", setDirty: true }), g.eachComponent(function(d, A) {
              if (d !== "series") {
                var p = f.getViewOfComponentModel(A);
                p && p.__alive && p.updateVisual(A, g, f._api, c);
              }
            }), g.eachSeries(function(d) {
              var A = f._chartsMap[d.__viewId];
              A.updateVisual(d, g, f._api, c);
            }), io.trigger("afterupdate", g, this._api));
          }, updateLayout: function(c) {
            pu.update.call(this, c);
          } }, nM = function(c, f, g, d) {
            if (c._disposed) {
              Wr(c.id);
              return;
            }
            for (var A = c._model, p = c._coordSysMgr.getCoordinateSystems(), v, y = ev(A, g), m = 0; m < p.length; m++) {
              var _ = p[m];
              if (_[f] && (v = _[f](A, y, d)) != null) return v;
            }
            gn("No coordinate system that supports " + f + " found by the given finder.");
          }, iM = function(c, f) {
            var g = c._chartsMap, d = c._scheduler;
            f.eachSeries(function(A) {
              d.updateStreamModes(A, g[A.__viewId]);
            });
          }, rM = function(c, f) {
            var g = this, d = this.getModel(), A = c.type, p = c.escapeConnect, v = IE[A], y = v.actionInfo, m = (y.update || "update").split(":"), _ = m.pop(), I = m[0] != null && Ho(m[0]);
            this[ki] = true;
            var E = [c], x = false;
            c.batch && (x = true, E = K(c.batch, function(R) {
              return R = wt(X({}, R), c), R.batch = null, R;
            }));
            var w = [], C, S = KT(c), b = f8(c);
            if (b && u8(this._api), D(E, function(R) {
              if (C = v.action(R, g._model, g._api), C = C || X({}, R), C.type = y.event || C.type, w.push(C), b) {
                var M = IT(c), L = M.queryOptionMap, N = M.mainTypeSpecified, F = N ? L.keys()[0] : "series";
                _E(g, _, R, F), Sa(g);
              } else S ? (_E(g, _, R, "series"), Sa(g)) : I && _E(g, _, R, I.main, I.sub);
            }), _ !== "none" && !b && !S && !I) try {
              this[br] ? (hd(this), pu.update.call(this, c), this[br] = null) : pu[_].call(this, c);
            } catch (R) {
              throw this[ki] = false, R;
            }
            if (x ? C = { type: y.event || A, escapeConnect: p, batch: w } : C = w[0], this[ki] = false, !f) {
              var T = this._messageCenter;
              if (T.trigger(C.type, C), S) {
                var B = { type: "selectchanged", escapeConnect: p, selected: NIt(d), isFromClick: c.isFromClick || false, fromAction: c.type, fromActionPayload: c };
                T.trigger(B.type, B);
              }
            }
          }, Nv = function(c) {
            for (var f = this._pendingActions; f.length; ) {
              var g = f.shift();
              rM.call(this, g, c);
            }
          }, Fv = function(c) {
            !c && this.trigger("updated");
          }, lV = function(c, f) {
            c.on("rendered", function(g) {
              f.trigger("rendered", g), c.animation.isFinished() && !f[br] && !f._scheduler.unfinished && !f._pendingActions.length && f.trigger("finished");
            });
          }, uV = function(c, f) {
            c.on("mouseover", function(g) {
              var d = g.target, A = ec(d, lu);
              A && (RIt(A, g, f._api), Sa(f));
            }).on("mouseout", function(g) {
              var d = g.target, A = ec(d, lu);
              A && (LIt(A, g, f._api), Sa(f));
            }).on("click", function(g) {
              var d = g.target, A = ec(d, function(y) {
                return Nt(y).dataIndex != null;
              }, true);
              if (A) {
                var p = A.selected ? "unselect" : "select", v = Nt(A);
                f._api.dispatchAction({ type: p, dataType: v.dataType, dataIndexInside: v.dataIndex, seriesIndex: v.seriesIndex, isFromClick: true });
              }
            });
          };
          function e(c) {
            c.clearColorPalette(), c.eachSeries(function(f) {
              f.clearColorPalette();
            });
          }
          function i(c) {
            var f = [], g = [], d = false;
            if (c.eachComponent(function(y, m) {
              var _ = m.get("zlevel") || 0, I = m.get("z") || 0, E = m.getZLevelKey();
              d = d || !!E, (y === "series" ? g : f).push({ zlevel: _, z: I, idx: m.componentIndex, type: y, key: E });
            }), d) {
              var A = f.concat(g), p, v;
              W_(A, function(y, m) {
                return y.zlevel === m.zlevel ? y.z - m.z : y.zlevel - m.zlevel;
              }), D(A, function(y) {
                var m = c.getComponent(y.type, y.idx), _ = y.zlevel, I = y.key;
                p != null && (_ = Math.max(p, _)), I ? (_ === p && I !== v && _++, v = I) : v && (_ === p && _++, v = ""), p = _, m.setZLevel(_);
              });
            }
          }
          aM = function(c, f, g, d, A) {
            i(f), hV(c, f, g, d, A), D(c._chartsViews, function(p) {
              p.__alive = false;
            }), EE(c, f, g, d, A), D(c._chartsViews, function(p) {
              p.__alive || p.remove(f, g);
            });
          }, hV = function(c, f, g, d, A, p) {
            D(p || c._componentsViews, function(v) {
              var y = v.__model;
              u(y, v), v.render(y, f, g, d), s(y, v), h(y, v);
            });
          }, EE = function(c, f, g, d, A, p) {
            var v = c._scheduler;
            A = X(A || {}, { updatedSeries: f.getSeries() }), io.trigger("series:beforeupdate", f, g, A);
            var y = false;
            f.eachSeries(function(m) {
              var _ = c._chartsMap[m.__viewId];
              _.__alive = true;
              var I = _.renderTask;
              v.updatePayload(I, d), u(m, _), p && p.get(m.uid) && I.dirty(), I.perform(v.getPerformArgs(I)) && (y = true), _.group.silent = !!m.get("silent"), o(m, _), h8(m);
            }), v.unfinished = y || v.unfinished, io.trigger("series:layoutlabels", f, g, A), io.trigger("series:transition", f, g, A), f.eachSeries(function(m) {
              var _ = c._chartsMap[m.__viewId];
              s(m, _), h(m, _);
            }), a(c, f), io.trigger("series:afterupdate", f, g, A);
          }, Sa = function(c) {
            c[JB] = true, c.getZr().wakeUp();
          }, gV = function(c) {
            c[JB] && (c.getZr().storage.traverse(function(f) {
              Vg(f) || r(f);
            }), c[JB] = false);
          };
          function r(c) {
            for (var f = [], g = c.currentStates, d = 0; d < g.length; d++) {
              var A = g[d];
              A === "emphasis" || A === "blur" || A === "select" || f.push(A);
            }
            c.selected && c.states.select && f.push("select"), c.hoverState === S1 && c.states.emphasis ? f.push("emphasis") : c.hoverState === av && c.states.blur && f.push("blur"), c.useStates(f);
          }
          function a(c, f) {
            var g = c._zr, d = g.storage, A = 0;
            d.traverse(function(p) {
              p.isGroup || A++;
            }), A > f.get("hoverLayerThreshold") && !re.node && !re.worker && f.eachSeries(function(p) {
              if (!p.preventUsingHoverLayer) {
                var v = c._chartsMap[p.__viewId];
                v.__alive && v.eachRendered(function(y) {
                  y.states.emphasis && (y.states.emphasis.hoverLayer = true);
                });
              }
            });
          }
          function o(c, f) {
            var g = c.get("blendMode") || null;
            f.eachRendered(function(d) {
              d.isGroup || (d.style.blend = g);
            });
          }
          function s(c, f) {
            if (!c.preventAutoZ) {
              var g = c.get("z") || 0, d = c.get("zlevel") || 0;
              f.eachRendered(function(A) {
                return l(A, g, d, -1 / 0), true;
              });
            }
          }
          function l(c, f, g, d) {
            var A = c.getTextContent(), p = c.getTextGuideLine(), v = c.isGroup;
            if (v) for (var y = c.childrenRef(), m = 0; m < y.length; m++) d = Math.max(l(y[m], f, g, d), d);
            else c.z = f, c.zlevel = g, d = Math.max(c.z2, d);
            if (A && (A.z = f, A.zlevel = g, isFinite(d) && (A.z2 = d + 2)), p) {
              var _ = c.textGuideLineConfig;
              p.z = f, p.zlevel = g, isFinite(d) && (p.z2 = d + (_ && _.showAbove ? 1 : -1));
            }
            return d;
          }
          function u(c, f) {
            f.eachRendered(function(g) {
              if (!Vg(g)) {
                var d = g.getTextContent(), A = g.getTextGuideLine();
                g.stateTransition && (g.stateTransition = null), d && d.stateTransition && (d.stateTransition = null), A && A.stateTransition && (A.stateTransition = null), g.hasState() ? (g.prevStates = g.currentStates, g.clearStates()) : g.prevStates && (g.prevStates = null);
              }
            });
          }
          function h(c, f) {
            var g = c.getModel("stateAnimation"), d = c.isAnimationEnabled(), A = g.get("duration"), p = A > 0 ? { duration: A, delay: g.get("delay"), easing: g.get("easing") } : null;
            f.eachRendered(function(v) {
              if (v.states && v.states.emphasis) {
                if (Vg(v)) return;
                if (v instanceof ne && zIt(v), v.__dirty) {
                  var y = v.prevStates;
                  y && v.useStates(y);
                }
                if (d) {
                  v.stateTransition = p;
                  var m = v.getTextContent(), _ = v.getTextGuideLine();
                  m && (m.stateTransition = p), _ && (_.stateTransition = p);
                }
                v.__dirty && r(v);
              }
            });
          }
          cV = function(c) {
            return new (function(f) {
              V(g, f);
              function g() {
                return f !== null && f.apply(this, arguments) || this;
              }
              return g.prototype.getCoordinateSystems = function() {
                return c._coordSysMgr.getCoordinateSystems();
              }, g.prototype.getComponentByElement = function(d) {
                for (; d; ) {
                  var A = d.__ecComponentInfo;
                  if (A != null) return c._model.getComponent(A.mainType, A.index);
                  d = d.parent;
                }
              }, g.prototype.enterEmphasis = function(d, A) {
                Ws(d, A), Sa(c);
              }, g.prototype.leaveEmphasis = function(d, A) {
                Xs(d, A), Sa(c);
              }, g.prototype.enterBlur = function(d) {
                a8(d), Sa(c);
              }, g.prototype.leaveBlur = function(d) {
                YT(d), Sa(c);
              }, g.prototype.enterSelect = function(d) {
                o8(d), Sa(c);
              }, g.prototype.leaveSelect = function(d) {
                s8(d), Sa(c);
              }, g.prototype.getModel = function() {
                return c.getModel();
              }, g.prototype.getViewOfComponentModel = function(d) {
                return c.getViewOfComponentModel(d);
              }, g.prototype.getViewOfSeriesModel = function(d) {
                return c.getViewOfSeriesModel(d);
              }, g;
            }(w6))(c);
          }, fV = function(c) {
            function f(g, d) {
              for (var A = 0; A < g.length; A++) {
                var p = g[A];
                p[tM] = d;
              }
            }
            D(kv, function(g, d) {
              c._messageCenter.on(d, function(A) {
                if (pV[c.group] && c[tM] !== nV) {
                  if (A && A.escapeConnect) return;
                  var p = c.makeActionFromEvent(A), v = [];
                  D(Ov, function(y) {
                    y !== c && y.group === c.group && v.push(y);
                  }), f(v, nV), D(v, function(y) {
                    y[tM] !== gSt && y.dispatchAction(p);
                  }), f(v, dSt);
                }
              });
            });
          };
        }(), t;
      }(ga), oM = dV.prototype;
      oM.on = iV("on"), oM.off = iV("off"), oM.one = function(n, t, e) {
        var i = this;
        Ka("ECharts#one is deprecated.");
        function r() {
          for (var a = [], o = 0; o < arguments.length; o++) a[o] = arguments[o];
          t && t.apply && t.apply(this, a), i.off(n, r);
        }
        this.on.call(this, n, r, e);
      };
      var ASt = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
      function Wr(n) {
        gn("Instance " + n + " has been disposed");
      }
      var IE = {}, kv = {}, sM = [], lM = [], xE = [], AV = {}, uM = {}, Ov = {}, pV = {}, pSt = +/* @__PURE__ */ new Date() - 0, hM = "_echarts_instance_";
      function vSt(n, t, e) {
        {
          if (!n) throw new Error("Initialize failed: invalid dom.");
          var i = ySt(n);
          if (i) return gn("There is a chart instance already initialized on the dom."), i;
          Ah(n) && n.nodeName.toUpperCase() !== "CANVAS" && (!n.clientWidth && !e || !n.clientHeight && !e) && gn("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
        }
        var r = new dV(n, t, e);
        return r.id = "ec_" + pSt++, Ov[r.id] = r, E4(n, hM, r.id), fV(r), io.trigger("afterinit", r), r;
      }
      function ySt(n) {
        return Ov[TEt(n, hM)];
      }
      function vV(n, t) {
        AV[n] = t;
      }
      function yV(n) {
        $t(lM, n) < 0 && lM.push(n);
      }
      function mV(n, t) {
        fM(sM, n, t, aSt);
      }
      function mSt(n) {
        cM("afterinit", n);
      }
      function _St(n) {
        cM("afterupdate", n);
      }
      function cM(n, t) {
        io.on(n, t);
      }
      function ts(n, t, e) {
        yt(t) && (e = t, t = "");
        var i = Et(n) ? n.type : [n, n = { event: t }][0];
        n.event = (n.event || i).toLowerCase(), t = n.event, !kv[t] && (It(eV.test(i) && eV.test(t)), IE[i] || (IE[i] = { action: e, actionInfo: n }), kv[t] = i);
      }
      function _V(n, t) {
        ed.register(n, t);
      }
      function ESt(n, t) {
        fM(xE, n, t, KU, "layout");
      }
      function ac(n, t) {
        fM(xE, n, t, JU, "visual");
      }
      var EV = [];
      function fM(n, t, e, i, r) {
        if ((yt(t) || Et(t)) && (e = t, t = i), true) {
          if (isNaN(t) || t == null) throw new Error("Illegal priority");
          D(n, function(o) {
            It(o.__raw !== e);
          });
        }
        if (!($t(EV, e) >= 0)) {
          EV.push(e);
          var a = xU.wrapStageHandler(e, r);
          a.__prio = t, a.__raw = e, n.push(a);
        }
      }
      function IV(n, t) {
        uM[n] = t;
      }
      function ISt(n, t, e) {
        var i = tSt("registerMap");
        i && i(n, t, e);
      }
      var xSt = kwt;
      ac(KB, lCt), ac(mE, uCt), ac(mE, hCt), ac(KB, xCt), ac(mE, wCt), ac(tV, KCt), yV(D6), mV(iSt, vwt), IV("default", cCt), ts({ type: zh, event: zh, update: zh }, bn), ts({ type: b1, event: b1, update: b1 }, bn), ts({ type: sv, event: sv, update: sv }, bn), ts({ type: T1, event: T1, update: T1 }, bn), ts({ type: lv, event: lv, update: lv }, bn), vV("light", ECt), vV("dark", MU);
      var xV = [], wSt = { registerPreprocessor: yV, registerProcessor: mV, registerPostInit: mSt, registerPostUpdate: _St, registerUpdateLifecycle: cM, registerAction: ts, registerCoordinateSystem: _V, registerLayout: ESt, registerVisual: ac, registerTransform: xSt, registerLoading: IV, registerMap: ISt, registerImpl: JCt, PRIORITY: fSt, ComponentModel: ae, ComponentView: un, SeriesModel: tn, ChartView: qe, registerComponentModel: function(n) {
        ae.registerClass(n);
      }, registerComponentView: function(n) {
        un.registerClass(n);
      }, registerSeriesModel: function(n) {
        tn.registerClass(n);
      }, registerChartView: function(n) {
        qe.registerClass(n);
      }, registerSubTypeDefaulter: function(n, t) {
        ae.registerSubTypeDefaulter(n, t);
      }, registerPainter: function(n, t) {
        aEt(n, t);
      } };
      function Kt(n) {
        if (Z(n)) {
          D(n, function(t) {
            Kt(t);
          });
          return;
        }
        $t(xV, n) >= 0 || (xV.push(n), yt(n) && (n = { install: n }), n.install(wSt));
      }
      function Qv(n) {
        return n == null ? 0 : n.length || 1;
      }
      function wV(n) {
        return n;
      }
      var Js = function() {
        function n(t, e, i, r, a, o) {
          this._old = t, this._new = e, this._oldKeyGetter = i || wV, this._newKeyGetter = r || wV, this.context = a, this._diffModeMultiple = o === "multiple";
        }
        return n.prototype.add = function(t) {
          return this._add = t, this;
        }, n.prototype.update = function(t) {
          return this._update = t, this;
        }, n.prototype.updateManyToOne = function(t) {
          return this._updateManyToOne = t, this;
        }, n.prototype.updateOneToMany = function(t) {
          return this._updateOneToMany = t, this;
        }, n.prototype.updateManyToMany = function(t) {
          return this._updateManyToMany = t, this;
        }, n.prototype.remove = function(t) {
          return this._remove = t, this;
        }, n.prototype.execute = function() {
          this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
        }, n.prototype._executeOneToOne = function() {
          var t = this._old, e = this._new, i = {}, r = new Array(t.length), a = new Array(e.length);
          this._initIndexMap(t, null, r, "_oldKeyGetter"), this._initIndexMap(e, i, a, "_newKeyGetter");
          for (var o = 0; o < t.length; o++) {
            var s = r[o], l = i[s], u = Qv(l);
            if (u > 1) {
              var h = l.shift();
              l.length === 1 && (i[s] = l[0]), this._update && this._update(h, o);
            } else u === 1 ? (i[s] = null, this._update && this._update(l, o)) : this._remove && this._remove(o);
          }
          this._performRestAdd(a, i);
        }, n.prototype._executeMultiple = function() {
          var t = this._old, e = this._new, i = {}, r = {}, a = [], o = [];
          this._initIndexMap(t, i, a, "_oldKeyGetter"), this._initIndexMap(e, r, o, "_newKeyGetter");
          for (var s = 0; s < a.length; s++) {
            var l = a[s], u = i[l], h = r[l], c = Qv(u), f = Qv(h);
            if (c > 1 && f === 1) this._updateManyToOne && this._updateManyToOne(h, u), r[l] = null;
            else if (c === 1 && f > 1) this._updateOneToMany && this._updateOneToMany(h, u), r[l] = null;
            else if (c === 1 && f === 1) this._update && this._update(h, u), r[l] = null;
            else if (c > 1 && f > 1) this._updateManyToMany && this._updateManyToMany(h, u), r[l] = null;
            else if (c > 1) for (var g = 0; g < c; g++) this._remove && this._remove(u[g]);
            else this._remove && this._remove(u);
          }
          this._performRestAdd(o, r);
        }, n.prototype._performRestAdd = function(t, e) {
          for (var i = 0; i < t.length; i++) {
            var r = t[i], a = e[r], o = Qv(a);
            if (o > 1) for (var s = 0; s < o; s++) this._add && this._add(a[s]);
            else o === 1 && this._add && this._add(a);
            e[r] = null;
          }
        }, n.prototype._initIndexMap = function(t, e, i, r) {
          for (var a = this._diffModeMultiple, o = 0; o < t.length; o++) {
            var s = "_ec_" + this[r](t[o], o);
            if (a || (i[o] = s), !!e) {
              var l = e[s], u = Qv(l);
              u === 0 ? (e[s] = o, a && i.push(s)) : u === 1 ? e[s] = [l, o] : l.push(o);
            }
          }
        }, n;
      }(), CSt = function() {
        function n(t, e) {
          this._encode = t, this._schema = e;
        }
        return n.prototype.get = function() {
          return { fullDimensions: this._getFullDimensionNames(), encode: this._encode };
        }, n.prototype._getFullDimensionNames = function() {
          return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
        }, n;
      }();
      function SSt(n, t) {
        var e = {}, i = e.encode = {}, r = dt(), a = [], o = [], s = {};
        D(n.dimensions, function(f) {
          var g = n.getDimensionInfo(f), d = g.coordDim;
          if (d) {
            It(IB.get(d) == null);
            var A = g.coordDimIndex;
            gM(i, d)[A] = f, g.isExtraCoord || (r.set(d, 1), bSt(g.type) && (a[0] = f), gM(s, d)[A] = n.getDimensionIndex(g.name)), g.defaultTooltip && o.push(f);
          }
          IB.each(function(p, v) {
            var y = gM(i, v), m = g.otherDims[v];
            m != null && m !== false && (y[m] = g.name);
          });
        });
        var l = [], u = {};
        r.each(function(f, g) {
          var d = i[g];
          u[g] = d[0], l = l.concat(d);
        }), e.dataDimsOnCoord = l, e.dataDimIndicesOnCoord = K(l, function(f) {
          return n.getDimensionInfo(f).storeDimIndex;
        }), e.encodeFirstDimNotExtra = u;
        var h = i.label;
        h && h.length && (a = h.slice());
        var c = i.tooltip;
        return c && c.length ? o = c.slice() : o.length || (o = a.slice()), i.defaultedLabel = a, i.defaultedTooltip = o, e.userOutput = new CSt(s, t), e;
      }
      function gM(n, t) {
        return n.hasOwnProperty(t) || (n[t] = []), n[t];
      }
      function wE(n) {
        return n === "category" ? "ordinal" : n === "time" ? "time" : "float";
      }
      function bSt(n) {
        return !(n === "ordinal" || n === "time");
      }
      var CE = /* @__PURE__ */ function() {
        function n(t) {
          this.otherDims = {}, t != null && X(this, t);
        }
        return n;
      }(), TSt = ce(), BSt = { float: "f", int: "i", ordinal: "o", number: "n", time: "t" }, CV = function() {
        function n(t) {
          this.dimensions = t.dimensions, this._dimOmitted = t.dimensionOmitted, this.source = t.source, this._fullDimCount = t.fullDimensionCount, this._updateDimOmitted(t.dimensionOmitted);
        }
        return n.prototype.isDimensionOmitted = function() {
          return this._dimOmitted;
        }, n.prototype._updateDimOmitted = function(t) {
          this._dimOmitted = t, t && (this._dimNameMap || (this._dimNameMap = TV(this.source)));
        }, n.prototype.getSourceDimensionIndex = function(t) {
          return kt(this._dimNameMap.get(t), -1);
        }, n.prototype.getSourceDimension = function(t) {
          var e = this.source.dimensionsDefine;
          if (e) return e[t];
        }, n.prototype.makeStoreSchema = function() {
          for (var t = this._fullDimCount, e = N6(this.source), i = !BV(t), r = "", a = [], o = 0, s = 0; o < t; o++) {
            var l = void 0, u = void 0, h = void 0, c = this.dimensions[s];
            if (c && c.storeDimIndex === o) l = e ? c.name : null, u = c.type, h = c.ordinalMeta, s++;
            else {
              var f = this.getSourceDimension(o);
              f && (l = e ? f.name : null, u = f.type);
            }
            a.push({ property: l, type: u, ordinalMeta: h }), e && l != null && (!c || !c.isCalculationCoord) && (r += i ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), r += "$", r += BSt[u] || "f", h && (r += h.uid), r += "$";
          }
          var g = this.source, d = [g.seriesLayoutBy, g.startIndex, r].join("$$");
          return { dimensions: a, hash: d };
        }, n.prototype.makeOutputDimensionNames = function() {
          for (var t = [], e = 0, i = 0; e < this._fullDimCount; e++) {
            var r = void 0, a = this.dimensions[i];
            if (a && a.storeDimIndex === e) a.isCalculationCoord || (r = a.name), i++;
            else {
              var o = this.getSourceDimension(e);
              o && (r = o.name);
            }
            t.push(r);
          }
          return t;
        }, n.prototype.appendCalculationDimension = function(t) {
          this.dimensions.push(t), t.isCalculationCoord = true, this._fullDimCount++, this._updateDimOmitted(true);
        }, n;
      }();
      function SV(n) {
        return n instanceof CV;
      }
      function bV(n) {
        for (var t = dt(), e = 0; e < (n || []).length; e++) {
          var i = n[e], r = Et(i) ? i.name : i;
          r != null && t.get(r) == null && t.set(r, e);
        }
        return t;
      }
      function TV(n) {
        var t = TSt(n);
        return t.dimNameMap || (t.dimNameMap = bV(n.dimensionsDefine));
      }
      function BV(n) {
        return n > 30;
      }
      var zv = Et, vu = K, MSt = typeof Int32Array == "undefined" ? Array : Int32Array, DSt = "e\0\0", MV = -1, RSt = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], LSt = ["_approximateExtent"], DV, SE, Gv, cd, dM, bE, AM, er = function() {
        function n(t, e) {
          this.type = "list", this._dimOmitted = false, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = false, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"];
          var i, r = false;
          SV(t) ? (i = t.dimensions, this._dimOmitted = t.isDimensionOmitted(), this._schema = t) : (r = true, i = t), i = i || ["x", "y"];
          for (var a = {}, o = [], s = {}, l = false, u = {}, h = 0; h < i.length; h++) {
            var c = i[h], f = ht(c) ? new CE({ name: c }) : c instanceof CE ? c : new CE(c), g = f.name;
            f.type = f.type || "float", f.coordDim || (f.coordDim = g, f.coordDimIndex = 0);
            var d = f.otherDims = f.otherDims || {};
            o.push(g), a[g] = f, u[g] != null && (l = true), f.createInvertedIndices && (s[g] = []), d.itemName === 0 && (this._nameDimIdx = h), d.itemId === 0 && (this._idDimIdx = h), It(r || f.storeDimIndex >= 0), r && (f.storeDimIndex = h);
          }
          if (this.dimensions = o, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = e, this._invertedIndicesMap = s, this._dimOmitted) {
            var A = this._dimIdxToName = dt();
            D(o, function(p) {
              A.set(a[p].storeDimIndex, p);
            });
          }
        }
        return n.prototype.getDimension = function(t) {
          var e = this._recognizeDimIndex(t);
          if (e == null) return t;
          if (e = t, !this._dimOmitted) return this.dimensions[e];
          var i = this._dimIdxToName.get(e);
          if (i != null) return i;
          var r = this._schema.getSourceDimension(e);
          if (r) return r.name;
        }, n.prototype.getDimensionIndex = function(t) {
          var e = this._recognizeDimIndex(t);
          if (e != null) return e;
          if (t == null) return -1;
          var i = this._getDimInfo(t);
          return i ? i.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(t) : -1;
        }, n.prototype._recognizeDimIndex = function(t) {
          if (ye(t) || t != null && !isNaN(t) && !this._getDimInfo(t) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(t) < 0)) return +t;
        }, n.prototype._getStoreDimIndex = function(t) {
          var e = this.getDimensionIndex(t);
          if (e == null) throw new Error("Unknown dimension " + t);
          return e;
        }, n.prototype.getDimensionInfo = function(t) {
          return this._getDimInfo(this.getDimension(t));
        }, n.prototype._initGetDimensionInfo = function(t) {
          var e = this._dimInfos;
          this._getDimInfo = t ? function(i) {
            return e.hasOwnProperty(i) ? e[i] : void 0;
          } : function(i) {
            return e[i];
          };
        }, n.prototype.getDimensionsOnCoord = function() {
          return this._dimSummary.dataDimsOnCoord.slice();
        }, n.prototype.mapDimension = function(t, e) {
          var i = this._dimSummary;
          if (e == null) return i.encodeFirstDimNotExtra[t];
          var r = i.encode[t];
          return r ? r[e] : null;
        }, n.prototype.mapDimensionsAll = function(t) {
          var e = this._dimSummary, i = e.encode[t];
          return (i || []).slice();
        }, n.prototype.getStore = function() {
          return this._store;
        }, n.prototype.initData = function(t, e, i) {
          var r = this, a;
          if (t instanceof zB && (a = t), !a) {
            var o = this.dimensions, s = LB(t) || Li(t) ? new O6(t, o.length) : t;
            a = new zB();
            var l = vu(o, function(u) {
              return { type: r._dimInfos[u].type, property: u };
            });
            a.initData(s, l, i);
          }
          this._store = a, this._nameList = (e || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = SSt(this, this._schema), this.userOutput = this._dimSummary.userOutput;
        }, n.prototype.appendData = function(t) {
          var e = this._store.appendData(t);
          this._doInit(e[0], e[1]);
        }, n.prototype.appendValues = function(t, e) {
          var i = this._store.appendValues(t, e.length), r = i.start, a = i.end, o = this._shouldMakeIdFromName();
          if (this._updateOrdinalMeta(), e) for (var s = r; s < a; s++) {
            var l = s - r;
            this._nameList[s] = e[l], o && AM(this, s);
          }
        }, n.prototype._updateOrdinalMeta = function() {
          for (var t = this._store, e = this.dimensions, i = 0; i < e.length; i++) {
            var r = this._dimInfos[e[i]];
            r.ordinalMeta && t.collectOrdinalMeta(r.storeDimIndex, r.ordinalMeta);
          }
        }, n.prototype._shouldMakeIdFromName = function() {
          var t = this._store.getProvider();
          return this._idDimIdx == null && t.getSource().sourceFormat !== Zs && !t.fillStorage;
        }, n.prototype._doInit = function(t, e) {
          if (!(t >= e)) {
            var i = this._store, r = i.getProvider();
            this._updateOrdinalMeta();
            var a = this._nameList, o = this._idList, s = r.getSource().sourceFormat, l = s === Ia;
            if (l && !r.pure) for (var u = [], h = t; h < e; h++) {
              var c = r.getItem(h, u);
              if (!this.hasItemOption && AEt(c) && (this.hasItemOption = true), c) {
                var f = c.name;
                a[h] == null && f != null && (a[h] = Hn(f, null));
                var g = c.id;
                o[h] == null && g != null && (o[h] = Hn(g, null));
              }
            }
            if (this._shouldMakeIdFromName()) for (var h = t; h < e; h++) AM(this, h);
            DV(this);
          }
        }, n.prototype.getApproximateExtent = function(t) {
          return this._approximateExtent[t] || this._store.getDataExtent(this._getStoreDimIndex(t));
        }, n.prototype.setApproximateExtent = function(t, e) {
          e = this.getDimension(e), this._approximateExtent[e] = t.slice();
        }, n.prototype.getCalculationInfo = function(t) {
          return this._calculationInfo[t];
        }, n.prototype.setCalculationInfo = function(t, e) {
          zv(t) ? X(this._calculationInfo, t) : this._calculationInfo[t] = e;
        }, n.prototype.getName = function(t) {
          var e = this.getRawIndex(t), i = this._nameList[e];
          return i == null && this._nameDimIdx != null && (i = Gv(this, this._nameDimIdx, e)), i == null && (i = ""), i;
        }, n.prototype._getCategory = function(t, e) {
          var i = this._store.get(t, e), r = this._store.getOrdinalMeta(t);
          return r ? r.categories[i] : i;
        }, n.prototype.getId = function(t) {
          return SE(this, this.getRawIndex(t));
        }, n.prototype.count = function() {
          return this._store.count();
        }, n.prototype.get = function(t, e) {
          var i = this._store, r = this._dimInfos[t];
          if (r) return i.get(r.storeDimIndex, e);
        }, n.prototype.getByRawIndex = function(t, e) {
          var i = this._store, r = this._dimInfos[t];
          if (r) return i.getByRawIndex(r.storeDimIndex, e);
        }, n.prototype.getIndices = function() {
          return this._store.getIndices();
        }, n.prototype.getDataExtent = function(t) {
          return this._store.getDataExtent(this._getStoreDimIndex(t));
        }, n.prototype.getSum = function(t) {
          return this._store.getSum(this._getStoreDimIndex(t));
        }, n.prototype.getMedian = function(t) {
          return this._store.getMedian(this._getStoreDimIndex(t));
        }, n.prototype.getValues = function(t, e) {
          var i = this, r = this._store;
          return Z(t) ? r.getValues(vu(t, function(a) {
            return i._getStoreDimIndex(a);
          }), e) : r.getValues(t);
        }, n.prototype.hasValue = function(t) {
          for (var e = this._dimSummary.dataDimIndicesOnCoord, i = 0, r = e.length; i < r; i++) if (isNaN(this._store.get(e[i], t))) return false;
          return true;
        }, n.prototype.indexOfName = function(t) {
          for (var e = 0, i = this._store.count(); e < i; e++) if (this.getName(e) === t) return e;
          return -1;
        }, n.prototype.getRawIndex = function(t) {
          return this._store.getRawIndex(t);
        }, n.prototype.indexOfRawIndex = function(t) {
          return this._store.indexOfRawIndex(t);
        }, n.prototype.rawIndexOf = function(t, e) {
          var i = t && this._invertedIndicesMap[t];
          if (!i) throw new Error("Do not supported yet");
          var r = i[e];
          return r == null || isNaN(r) ? MV : r;
        }, n.prototype.indicesOfNearest = function(t, e, i) {
          return this._store.indicesOfNearest(this._getStoreDimIndex(t), e, i);
        }, n.prototype.each = function(t, e, i) {
          yt(t) && (i = e, e = t, t = []);
          var r = i || this, a = vu(cd(t), this._getStoreDimIndex, this);
          this._store.each(a, r ? ct(e, r) : e);
        }, n.prototype.filterSelf = function(t, e, i) {
          yt(t) && (i = e, e = t, t = []);
          var r = i || this, a = vu(cd(t), this._getStoreDimIndex, this);
          return this._store = this._store.filter(a, r ? ct(e, r) : e), this;
        }, n.prototype.selectRange = function(t) {
          var e = this, i = {}, r = oe(t);
          return D(r, function(a) {
            var o = e._getStoreDimIndex(a);
            i[o] = t[a];
          }), this._store = this._store.selectRange(i), this;
        }, n.prototype.mapArray = function(t, e, i) {
          yt(t) && (i = e, e = t, t = []), i = i || this;
          var r = [];
          return this.each(t, function() {
            r.push(e && e.apply(this, arguments));
          }, i), r;
        }, n.prototype.map = function(t, e, i, r) {
          var a = i || r || this, o = vu(cd(t), this._getStoreDimIndex, this), s = bE(this);
          return s._store = this._store.map(o, a ? ct(e, a) : e), s;
        }, n.prototype.modify = function(t, e, i, r) {
          var a = this, o = i || r || this;
          D(cd(t), function(l) {
            var u = a.getDimensionInfo(l);
            u.isCalculationCoord;
          });
          var s = vu(cd(t), this._getStoreDimIndex, this);
          this._store.modify(s, o ? ct(e, o) : e);
        }, n.prototype.downSample = function(t, e, i, r) {
          var a = bE(this);
          return a._store = this._store.downSample(this._getStoreDimIndex(t), e, i, r), a;
        }, n.prototype.lttbDownSample = function(t, e) {
          var i = bE(this);
          return i._store = this._store.lttbDownSample(this._getStoreDimIndex(t), e), i;
        }, n.prototype.getRawDataItem = function(t) {
          return this._store.getRawDataItem(t);
        }, n.prototype.getItemModel = function(t) {
          var e = this.hostModel, i = this.getRawDataItem(t);
          return new De(i, e, e && e.ecModel);
        }, n.prototype.diff = function(t) {
          var e = this;
          return new Js(t ? t.getStore().getIndices() : [], this.getStore().getIndices(), function(i) {
            return SE(t, i);
          }, function(i) {
            return SE(e, i);
          });
        }, n.prototype.getVisual = function(t) {
          var e = this._visual;
          return e && e[t];
        }, n.prototype.setVisual = function(t, e) {
          this._visual = this._visual || {}, zv(t) ? X(this._visual, t) : this._visual[t] = e;
        }, n.prototype.getItemVisual = function(t, e) {
          var i = this._itemVisuals[t], r = i && i[e];
          return r == null ? this.getVisual(e) : r;
        }, n.prototype.hasItemVisual = function() {
          return this._itemVisuals.length > 0;
        }, n.prototype.ensureUniqueItemVisual = function(t, e) {
          var i = this._itemVisuals, r = i[t];
          r || (r = i[t] = {});
          var a = r[e];
          return a == null && (a = this.getVisual(e), Z(a) ? a = a.slice() : zv(a) && (a = X({}, a)), r[e] = a), a;
        }, n.prototype.setItemVisual = function(t, e, i) {
          var r = this._itemVisuals[t] || {};
          this._itemVisuals[t] = r, zv(e) ? X(r, e) : r[e] = i;
        }, n.prototype.clearAllVisual = function() {
          this._visual = {}, this._itemVisuals = [];
        }, n.prototype.setLayout = function(t, e) {
          zv(t) ? X(this._layout, t) : this._layout[t] = e;
        }, n.prototype.getLayout = function(t) {
          return this._layout[t];
        }, n.prototype.getItemLayout = function(t) {
          return this._itemLayouts[t];
        }, n.prototype.setItemLayout = function(t, e, i) {
          this._itemLayouts[t] = i ? X(this._itemLayouts[t] || {}, e) : e;
        }, n.prototype.clearItemLayouts = function() {
          this._itemLayouts.length = 0;
        }, n.prototype.setItemGraphicEl = function(t, e) {
          var i = this.hostModel && this.hostModel.seriesIndex;
          UT(i, this.dataType, t, e), this._graphicEls[t] = e;
        }, n.prototype.getItemGraphicEl = function(t) {
          return this._graphicEls[t];
        }, n.prototype.eachItemGraphicEl = function(t, e) {
          D(this._graphicEls, function(i, r) {
            i && t && t.call(e, i, r);
          });
        }, n.prototype.cloneShallow = function(t) {
          return t || (t = new n(this._schema ? this._schema : vu(this.dimensions, this._getDimInfo, this), this.hostModel)), dM(t, this), t._store = this._store, t;
        }, n.prototype.wrapMethod = function(t, e) {
          var i = this[t];
          yt(i) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
            var r = i.apply(this, arguments);
            return e.apply(this, [r].concat(E2(arguments)));
          });
        }, n.internalField = function() {
          DV = function(t) {
            var e = t._invertedIndicesMap;
            D(e, function(i, r) {
              var a = t._dimInfos[r], o = a.ordinalMeta, s = t._store;
              if (o) {
                i = e[r] = new MSt(o.categories.length);
                for (var l = 0; l < i.length; l++) i[l] = MV;
                for (var l = 0; l < s.count(); l++) i[s.get(a.storeDimIndex, l)] = l;
              }
            });
          }, Gv = function(t, e, i) {
            return Hn(t._getCategory(e, i), null);
          }, SE = function(t, e) {
            var i = t._idList[e];
            return i == null && t._idDimIdx != null && (i = Gv(t, t._idDimIdx, e)), i == null && (i = DSt + e), i;
          }, cd = function(t) {
            return Z(t) || (t = t != null ? [t] : []), t;
          }, bE = function(t) {
            var e = new n(t._schema ? t._schema : vu(t.dimensions, t._getDimInfo, t), t.hostModel);
            return dM(e, t), e;
          }, dM = function(t, e) {
            D(RSt.concat(e.__wrappedMethods || []), function(i) {
              e.hasOwnProperty(i) && (t[i] = e[i]);
            }), t.__wrappedMethods = e.__wrappedMethods, D(LSt, function(i) {
              t[i] = Ct(e[i]);
            }), t._calculationInfo = X({}, e._calculationInfo);
          }, AM = function(t, e) {
            var i = t._nameList, r = t._idList, a = t._nameDimIdx, o = t._idDimIdx, s = i[e], l = r[e];
            if (s == null && a != null && (i[e] = s = Gv(t, a, e)), l == null && o != null && (r[e] = l = Gv(t, o, e)), l == null && s != null) {
              var u = t._nameRepeatCount, h = u[s] = (u[s] || 0) + 1;
              l = s, h > 1 && (l += "__ec__" + h), r[e] = l;
            }
          };
        }(), n;
      }();
      function Uv(n, t) {
        LB(n) || (n = NB(n)), t = t || {};
        var e = t.coordDimensions || [], i = t.dimensionsDefine || n.dimensionsDefine || [], r = dt(), a = [], o = NSt(n, e, i, t.dimensionsCount), s = t.canOmitUnusedDimensions && BV(o), l = i === n.dimensionsDefine, u = l ? TV(n) : bV(i), h = t.encodeDefine;
        !h && t.encodeDefaulter && (h = t.encodeDefaulter(n, o));
        for (var c = dt(h), f = new $6(o), g = 0; g < f.length; g++) f[g] = -1;
        function d(C) {
          var S = f[C];
          if (S < 0) {
            var b = i[C], T = Et(b) ? b : { name: b }, B = new CE(), R = T.name;
            R != null && u.get(R) != null && (B.name = B.displayName = R), T.type != null && (B.type = T.type), T.displayName != null && (B.displayName = T.displayName);
            var M = a.length;
            return f[C] = M, B.storeDimIndex = C, a.push(B), B;
          }
          return a[S];
        }
        if (!s) for (var g = 0; g < o; g++) d(g);
        c.each(function(C, S) {
          var b = ze(C).slice();
          if (b.length === 1 && !ht(b[0]) && b[0] < 0) {
            c.set(S, false);
            return;
          }
          var T = c.set(S, []);
          D(b, function(B, R) {
            var M = ht(B) ? u.get(B) : B;
            M != null && M < o && (T[R] = M, p(d(M), S, R));
          });
        });
        var A = 0;
        D(e, function(C) {
          var S, b, T, B;
          if (ht(C)) S = C, B = {};
          else {
            B = C, S = B.name;
            var R = B.ordinalMeta;
            B.ordinalMeta = null, B = X({}, B), B.ordinalMeta = R, b = B.dimsDef, T = B.otherDims, B.name = B.coordDim = B.coordDimIndex = B.dimsDef = B.otherDims = null;
          }
          var M = c.get(S);
          if (M !== false) {
            if (M = ze(M), !M.length) for (var L = 0; L < (b && b.length || 1); L++) {
              for (; A < o && d(A).coordDim != null; ) A++;
              A < o && M.push(A++);
            }
            D(M, function(N, F) {
              var k = d(N);
              if (l && B.type != null && (k.type = B.type), p(wt(k, B), S, F), k.name == null && b) {
                var O = b[F];
                !Et(O) && (O = { name: O }), k.name = k.displayName = O.name, k.defaultTooltip = O.defaultTooltip;
              }
              T && wt(k.otherDims, T);
            });
          }
        });
        function p(C, S, b) {
          IB.get(S) != null ? C.otherDims[S] = b : (C.coordDim = S, C.coordDimIndex = b, r.set(S, true));
        }
        var v = t.generateCoord, y = t.generateCoordCount, m = y != null;
        y = v ? y || 1 : 0;
        var _ = v || "value";
        function I(C) {
          C.name == null && (C.name = C.coordDim);
        }
        if (s) D(a, function(C) {
          I(C);
        }), a.sort(function(C, S) {
          return C.storeDimIndex - S.storeDimIndex;
        });
        else for (var E = 0; E < o; E++) {
          var x = d(E), w = x.coordDim;
          w == null && (x.coordDim = FSt(_, r, m), x.coordDimIndex = 0, (!v || y <= 0) && (x.isExtraCoord = true), y--), I(x), x.type == null && (A6(n, E) === wi.Must || x.isExtraCoord && (x.otherDims.itemName != null || x.otherDims.seriesName != null)) && (x.type = "ordinal");
        }
        return PSt(a), new CV({ source: n, dimensions: a, fullDimensionCount: o, dimensionOmitted: s });
      }
      function PSt(n) {
        for (var t = dt(), e = 0; e < n.length; e++) {
          var i = n[e], r = i.name, a = t.get(r) || 0;
          a > 0 && (i.name = r + (a - 1)), a++, t.set(r, a);
        }
      }
      function NSt(n, t, e, i) {
        var r = Math.max(n.dimensionsDetectedCount || 1, t.length, e.length, i || 0);
        return D(t, function(a) {
          var o;
          Et(a) && (o = a.dimsDef) && (r = Math.max(r, o.length));
        }), r;
      }
      function FSt(n, t, e) {
        if (e || t.hasKey(n)) {
          for (var i = 0; t.hasKey(n + i); ) i++;
          n += i;
        }
        return t.set(n, true), n;
      }
      var kSt = /* @__PURE__ */ function() {
        function n(t) {
          this.coordSysDims = [], this.axisMap = dt(), this.categoryAxisMap = dt(), this.coordSysName = t;
        }
        return n;
      }();
      function OSt(n) {
        var t = n.get("coordinateSystem"), e = new kSt(t), i = QSt[t];
        if (i) return i(n, e, e.axisMap, e.categoryAxisMap), e;
      }
      var QSt = { cartesian2d: function(n, t, e, i) {
        var r = n.getReferringComponents("xAxis", zn).models[0], a = n.getReferringComponents("yAxis", zn).models[0];
        if (true) {
          if (!r) throw new Error('xAxis "' + On(n.get("xAxisIndex"), n.get("xAxisId"), 0) + '" not found');
          if (!a) throw new Error('yAxis "' + On(n.get("xAxisIndex"), n.get("yAxisId"), 0) + '" not found');
        }
        t.coordSysDims = ["x", "y"], e.set("x", r), e.set("y", a), fd(r) && (i.set("x", r), t.firstCategoryDimIndex = 0), fd(a) && (i.set("y", a), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
      }, singleAxis: function(n, t, e, i) {
        var r = n.getReferringComponents("singleAxis", zn).models[0];
        if (!r) throw new Error("singleAxis should be specified.");
        t.coordSysDims = ["single"], e.set("single", r), fd(r) && (i.set("single", r), t.firstCategoryDimIndex = 0);
      }, polar: function(n, t, e, i) {
        var r = n.getReferringComponents("polar", zn).models[0], a = r.findAxisModel("radiusAxis"), o = r.findAxisModel("angleAxis");
        if (true) {
          if (!o) throw new Error("angleAxis option not found");
          if (!a) throw new Error("radiusAxis option not found");
        }
        t.coordSysDims = ["radius", "angle"], e.set("radius", a), e.set("angle", o), fd(a) && (i.set("radius", a), t.firstCategoryDimIndex = 0), fd(o) && (i.set("angle", o), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
      }, geo: function(n, t, e, i) {
        t.coordSysDims = ["lng", "lat"];
      }, parallel: function(n, t, e, i) {
        var r = n.ecModel, a = r.getComponent("parallel", n.get("parallelIndex")), o = t.coordSysDims = a.dimensions.slice();
        D(a.parallelAxisIndex, function(s, l) {
          var u = r.getComponent("parallelAxis", s), h = o[l];
          e.set(h, u), fd(u) && (i.set(h, u), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = l));
        });
      } };
      function fd(n) {
        return n.get("type") === "category";
      }
      function zSt(n, t, e) {
        e = e || {};
        var i = e.byIndex, r = e.stackedCoordDimension, a, o, s;
        GSt(t) ? a = t : (o = t.schema, a = o.dimensions, s = t.store);
        var l = !!(n && n.get("stack")), u, h, c, f;
        if (D(a, function(y, m) {
          ht(y) && (a[m] = y = { name: y }), l && !y.isExtraCoord && (!i && !u && y.ordinalMeta && (u = y), !h && y.type !== "ordinal" && y.type !== "time" && (!r || r === y.coordDim) && (h = y));
        }), h && !i && !u && (i = true), h) {
          c = "__\0ecstackresult_" + n.id, f = "__\0ecstackedover_" + n.id, u && (u.createInvertedIndices = true);
          var g = h.coordDim, d = h.type, A = 0;
          D(a, function(y) {
            y.coordDim === g && A++;
          });
          var p = { name: c, coordDim: g, coordDimIndex: A, type: d, isExtraCoord: true, isCalculationCoord: true, storeDimIndex: a.length }, v = { name: f, coordDim: f, coordDimIndex: A + 1, type: d, isExtraCoord: true, isCalculationCoord: true, storeDimIndex: a.length + 1 };
          o ? (s && (p.storeDimIndex = s.ensureCalculationDimension(f, d), v.storeDimIndex = s.ensureCalculationDimension(c, d)), o.appendCalculationDimension(p), o.appendCalculationDimension(v)) : (a.push(p), a.push(v));
        }
        return { stackedDimension: h && h.name, stackedByDimension: u && u.name, isStackedByIndex: i, stackedOverDimension: f, stackResultDimension: c };
      }
      function GSt(n) {
        return !SV(n.schema);
      }
      function yu(n, t) {
        return !!t && t === n.getCalculationInfo("stackedDimension");
      }
      function RV(n, t) {
        return yu(n, t) ? n.getCalculationInfo("stackResultDimension") : t;
      }
      function USt(n, t) {
        var e = n.get("coordinateSystem"), i = ed.get(e), r;
        return t && t.coordSysDims && (r = K(t.coordSysDims, function(a) {
          var o = { name: a }, s = t.axisMap.get(a);
          if (s) {
            var l = s.get("type");
            o.type = wE(l);
          }
          return o;
        })), r || (r = i && (i.getDimensionsInfo ? i.getDimensionsInfo() : i.dimensions.slice()) || ["x", "y"]), r;
      }
      function VSt(n, t, e) {
        var i, r;
        return e && D(n, function(a, o) {
          var s = a.coordDim, l = e.categoryAxisMap.get(s);
          l && (i == null && (i = o), a.ordinalMeta = l.getOrdinalMeta(), t && (a.createInvertedIndices = true)), a.otherDims.itemName != null && (r = true);
        }), !r && i != null && (n[i].otherDims.itemName = 0), i;
      }
      function tl(n, t, e) {
        e = e || {};
        var i = t.getSourceManager(), r, a = false;
        n ? (a = true, r = NB(n)) : (r = i.getSource(), a = r.sourceFormat === Ia);
        var o = OSt(t), s = USt(t, o), l = e.useEncodeDefaulter, u = yt(l) ? l : l ? Gt(d6, s, t) : null, h = { coordDimensions: s, generateCoord: e.generateCoord, encodeDefine: t.getEncode(), encodeDefaulter: u, canOmitUnusedDimensions: !a }, c = Uv(r, h), f = VSt(c.dimensions, e.createInvertedIndices, o), g = a ? null : i.getSharedDataStore(c), d = zSt(t, { schema: c, store: g }), A = new er(c, t);
        A.setCalculationInfo(d);
        var p = f != null && jSt(r) ? function(v, y, m, _) {
          return _ === f ? m : this.defaultDimValueGetter(v, y, m, _);
        } : null;
        return A.hasItemOption = false, A.initData(a ? r : g, null, p), A;
      }
      function jSt(n) {
        if (n.sourceFormat === Ia) {
          var t = qSt(n.data || []);
          return !Z(Pg(t));
        }
      }
      function qSt(n) {
        for (var t = 0; t < n.length && n[t] == null; ) t++;
        return n[t];
      }
      var es = function() {
        function n(t) {
          this._setting = t || {}, this._extent = [1 / 0, -1 / 0];
        }
        return n.prototype.getSetting = function(t) {
          return this._setting[t];
        }, n.prototype.unionExtent = function(t) {
          var e = this._extent;
          t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]);
        }, n.prototype.unionExtentFromData = function(t, e) {
          this.unionExtent(t.getApproximateExtent(e));
        }, n.prototype.getExtent = function() {
          return this._extent.slice();
        }, n.prototype.setExtent = function(t, e) {
          var i = this._extent;
          isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e);
        }, n.prototype.isInExtentRange = function(t) {
          return this._extent[0] <= t && this._extent[1] >= t;
        }, n.prototype.isBlank = function() {
          return this._isBlank;
        }, n.prototype.setBlank = function(t) {
          this._isBlank = t;
        }, n;
      }();
      y1(es);
      var HSt = 0, pM = function() {
        function n(t) {
          this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, this.uid = ++HSt;
        }
        return n.createByAxisModel = function(t) {
          var e = t.option, i = e.data, r = i && K(i, YSt);
          return new n({ categories: r, needCollect: !r, deduplication: e.dedplication !== false });
        }, n.prototype.getOrdinal = function(t) {
          return this._getOrCreateMap().get(t);
        }, n.prototype.parseAndCollect = function(t) {
          var e, i = this._needCollect;
          if (!ht(t) && !i) return t;
          if (i && !this._deduplication) return e = this.categories.length, this.categories[e] = t, e;
          var r = this._getOrCreateMap();
          return e = r.get(t), e == null && (i ? (e = this.categories.length, this.categories[e] = t, r.set(t, e)) : e = NaN), e;
        }, n.prototype._getOrCreateMap = function() {
          return this._map || (this._map = dt(this.categories));
        }, n;
      }();
      function YSt(n) {
        return Et(n) && n.value != null ? n.value : n + "";
      }
      function WSt(n) {
        var t = Math.pow(10, p1(Math.abs(n))), e = Math.abs(n / t);
        return e === 0 || e === 1 || e === 2 || e === 3 || e === 5;
      }
      function vM(n) {
        return n.type === "interval" || n.type === "log";
      }
      function XSt(n, t, e, i) {
        var r = {}, a = n[1] - n[0], o = r.interval = s4(a / t);
        e != null && o < e && (o = r.interval = e), i != null && o > i && (o = r.interval = i);
        var s = r.intervalPrecision = LV(o), l = r.niceTickExtent = [En(Math.ceil(n[0] / o) * o, s), En(Math.floor(n[1] / o) * o, s)];
        return $St(l, n), r;
      }
      function yM(n) {
        var t = Math.pow(10, p1(n)), e = n / t;
        return e ? e === 2 ? e = 3 : e === 3 ? e = 5 : e *= 2 : e = 1, En(e * t);
      }
      function LV(n) {
        return jo(n) + 2;
      }
      function PV(n, t, e) {
        n[t] = Math.max(Math.min(n[t], e[1]), e[0]);
      }
      function $St(n, t) {
        !isFinite(n[0]) && (n[0] = t[0]), !isFinite(n[1]) && (n[1] = t[1]), PV(n, 0, t), PV(n, 1, t), n[0] > n[1] && (n[0] = n[1]);
      }
      function TE(n, t) {
        return n >= t[0] && n <= t[1];
      }
      function BE(n, t) {
        return t[1] === t[0] ? 0.5 : (n - t[0]) / (t[1] - t[0]);
      }
      function ME(n, t) {
        return n * (t[1] - t[0]) + t[0];
      }
      var DE = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          i.type = "ordinal";
          var r = i.getSetting("ordinalMeta");
          return r || (r = new pM({})), Z(r) && (r = new pM({ categories: K(r, function(a) {
            return Et(a) ? a.value : a;
          }) })), i._ordinalMeta = r, i._extent = i.getSetting("extent") || [0, r.categories.length - 1], i;
        }
        return t.prototype.parse = function(e) {
          return e == null ? NaN : ht(e) ? this._ordinalMeta.getOrdinal(e) : Math.round(e);
        }, t.prototype.contain = function(e) {
          return e = this.parse(e), TE(e, this._extent) && this._ordinalMeta.categories[e] != null;
        }, t.prototype.normalize = function(e) {
          return e = this._getTickNumber(this.parse(e)), BE(e, this._extent);
        }, t.prototype.scale = function(e) {
          return e = Math.round(ME(e, this._extent)), this.getRawOrdinalNumber(e);
        }, t.prototype.getTicks = function() {
          for (var e = [], i = this._extent, r = i[0]; r <= i[1]; ) e.push({ value: r }), r++;
          return e;
        }, t.prototype.getMinorTicks = function(e) {
        }, t.prototype.setSortInfo = function(e) {
          if (e == null) {
            this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
            return;
          }
          for (var i = e.ordinalNumbers, r = this._ordinalNumbersByTick = [], a = this._ticksByOrdinalNumber = [], o = 0, s = this._ordinalMeta.categories.length, l = Math.min(s, i.length); o < l; ++o) {
            var u = i[o];
            r[o] = u, a[u] = o;
          }
          for (var h = 0; o < s; ++o) {
            for (; a[h] != null; ) h++;
            r.push(h), a[h] = o;
          }
        }, t.prototype._getTickNumber = function(e) {
          var i = this._ticksByOrdinalNumber;
          return i && e >= 0 && e < i.length ? i[e] : e;
        }, t.prototype.getRawOrdinalNumber = function(e) {
          var i = this._ordinalNumbersByTick;
          return i && e >= 0 && e < i.length ? i[e] : e;
        }, t.prototype.getLabel = function(e) {
          if (!this.isBlank()) {
            var i = this.getRawOrdinalNumber(e.value), r = this._ordinalMeta.categories[i];
            return r == null ? "" : r + "";
          }
        }, t.prototype.count = function() {
          return this._extent[1] - this._extent[0] + 1;
        }, t.prototype.unionExtentFromData = function(e, i) {
          this.unionExtent(e.getApproximateExtent(i));
        }, t.prototype.isInExtentRange = function(e) {
          return e = this._getTickNumber(e), this._extent[0] <= e && this._extent[1] >= e;
        }, t.prototype.getOrdinalMeta = function() {
          return this._ordinalMeta;
        }, t.prototype.calcNiceTicks = function() {
        }, t.prototype.calcNiceExtent = function() {
        }, t.type = "ordinal", t;
      }(es);
      es.registerClass(DE);
      var oc = En, el = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "interval", e._interval = 0, e._intervalPrecision = 2, e;
        }
        return t.prototype.parse = function(e) {
          return e;
        }, t.prototype.contain = function(e) {
          return TE(e, this._extent);
        }, t.prototype.normalize = function(e) {
          return BE(e, this._extent);
        }, t.prototype.scale = function(e) {
          return ME(e, this._extent);
        }, t.prototype.setExtent = function(e, i) {
          var r = this._extent;
          isNaN(e) || (r[0] = parseFloat(e)), isNaN(i) || (r[1] = parseFloat(i));
        }, t.prototype.unionExtent = function(e) {
          var i = this._extent;
          e[0] < i[0] && (i[0] = e[0]), e[1] > i[1] && (i[1] = e[1]), this.setExtent(i[0], i[1]);
        }, t.prototype.getInterval = function() {
          return this._interval;
        }, t.prototype.setInterval = function(e) {
          this._interval = e, this._niceExtent = this._extent.slice(), this._intervalPrecision = LV(e);
        }, t.prototype.getTicks = function(e) {
          var i = this._interval, r = this._extent, a = this._niceExtent, o = this._intervalPrecision, s = [];
          if (!i) return s;
          var l = 1e4;
          r[0] < a[0] && (e ? s.push({ value: oc(a[0] - i, o) }) : s.push({ value: r[0] }));
          for (var u = a[0]; u <= a[1] && (s.push({ value: u }), u = oc(u + i, o), u !== s[s.length - 1].value); ) if (s.length > l) return [];
          var h = s.length ? s[s.length - 1].value : a[1];
          return r[1] > h && (e ? s.push({ value: oc(h + i, o) }) : s.push({ value: r[1] })), s;
        }, t.prototype.getMinorTicks = function(e) {
          for (var i = this.getTicks(true), r = [], a = this.getExtent(), o = 1; o < i.length; o++) {
            for (var s = i[o], l = i[o - 1], u = 0, h = [], c = s.value - l.value, f = c / e; u < e - 1; ) {
              var g = oc(l.value + (u + 1) * f);
              g > a[0] && g < a[1] && h.push(g), u++;
            }
            r.push(h);
          }
          return r;
        }, t.prototype.getLabel = function(e, i) {
          if (e == null) return "";
          var r = i && i.precision;
          r == null ? r = jo(e.value) || 0 : r === "auto" && (r = this._intervalPrecision);
          var a = oc(e.value, r, true);
          return a6(a);
        }, t.prototype.calcNiceTicks = function(e, i, r) {
          e = e || 5;
          var a = this._extent, o = a[1] - a[0];
          if (isFinite(o)) {
            o < 0 && (o = -o, a.reverse());
            var s = XSt(a, e, i, r);
            this._intervalPrecision = s.intervalPrecision, this._interval = s.interval, this._niceExtent = s.niceTickExtent;
          }
        }, t.prototype.calcNiceExtent = function(e) {
          var i = this._extent;
          if (i[0] === i[1]) if (i[0] !== 0) {
            var r = Math.abs(i[0]);
            e.fixMax || (i[1] += r / 2), i[0] -= r / 2;
          } else i[1] = 1;
          var a = i[1] - i[0];
          isFinite(a) || (i[0] = 0, i[1] = 1), this.calcNiceTicks(e.splitNumber, e.minInterval, e.maxInterval);
          var o = this._interval;
          e.fixMin || (i[0] = oc(Math.floor(i[0] / o) * o)), e.fixMax || (i[1] = oc(Math.ceil(i[1] / o) * o));
        }, t.prototype.setNiceExtent = function(e, i) {
          this._niceExtent = [e, i];
        }, t.type = "interval", t;
      }(es);
      es.registerClass(el);
      var NV = typeof Float32Array != "undefined", ZSt = NV ? Float32Array : Array;
      function ns(n) {
        return Z(n) ? NV ? new Float32Array(n) : n : new ZSt(n);
      }
      var mM = "__ec_stack_";
      function _M(n) {
        return n.get("stack") || mM + n.seriesIndex;
      }
      function EM(n) {
        return n.dim + n.index;
      }
      function KSt(n) {
        var t = [], e = n.axis, i = "axis0";
        if (e.type === "category") {
          for (var r = e.getBandWidth(), a = 0; a < n.count; a++) t.push(wt({ bandWidth: r, axisKey: i, stackId: mM + a }, n));
          for (var o = OV(t), s = [], a = 0; a < n.count; a++) {
            var l = o[i][mM + a];
            l.offsetCenter = l.offset + l.width / 2, s.push(l);
          }
          return s;
        }
      }
      function FV(n, t) {
        var e = [];
        return t.eachSeriesByType(n, function(i) {
          GV(i) && e.push(i);
        }), e;
      }
      function JSt(n) {
        var t = {};
        D(n, function(l) {
          var u = l.coordinateSystem, h = u.getBaseAxis();
          if (!(h.type !== "time" && h.type !== "value")) for (var c = l.getData(), f = h.dim + "_" + h.index, g = c.getDimensionIndex(c.mapDimension(h.dim)), d = c.getStore(), A = 0, p = d.count(); A < p; ++A) {
            var v = d.get(g, A);
            t[f] ? t[f].push(v) : t[f] = [v];
          }
        });
        var e = {};
        for (var i in t) if (t.hasOwnProperty(i)) {
          var r = t[i];
          if (r) {
            r.sort(function(l, u) {
              return l - u;
            });
            for (var a = null, o = 1; o < r.length; ++o) {
              var s = r[o] - r[o - 1];
              s > 0 && (a = a === null ? s : Math.min(a, s));
            }
            e[i] = a;
          }
        }
        return e;
      }
      function kV(n) {
        var t = JSt(n), e = [];
        return D(n, function(i) {
          var r = i.coordinateSystem, a = r.getBaseAxis(), o = a.getExtent(), s;
          if (a.type === "category") s = a.getBandWidth();
          else if (a.type === "value" || a.type === "time") {
            var l = a.dim + "_" + a.index, u = t[l], h = Math.abs(o[1] - o[0]), c = a.scale.getExtent(), f = Math.abs(c[1] - c[0]);
            s = u ? h / f * u : h;
          } else {
            var g = i.getData();
            s = Math.abs(o[1] - o[0]) / g.count();
          }
          var d = st(i.get("barWidth"), s), A = st(i.get("barMaxWidth"), s), p = st(i.get("barMinWidth") || (UV(i) ? 0.5 : 1), s), v = i.get("barGap"), y = i.get("barCategoryGap");
          e.push({ bandWidth: s, barWidth: d, barMaxWidth: A, barMinWidth: p, barGap: v, barCategoryGap: y, axisKey: EM(a), stackId: _M(i) });
        }), OV(e);
      }
      function OV(n) {
        var t = {};
        D(n, function(i, r) {
          var a = i.axisKey, o = i.bandWidth, s = t[a] || { bandWidth: o, remainedWidth: o, autoWidthCount: 0, categoryGap: null, gap: "20%", stacks: {} }, l = s.stacks;
          t[a] = s;
          var u = i.stackId;
          l[u] || s.autoWidthCount++, l[u] = l[u] || { width: 0, maxWidth: 0 };
          var h = i.barWidth;
          h && !l[u].width && (l[u].width = h, h = Math.min(s.remainedWidth, h), s.remainedWidth -= h);
          var c = i.barMaxWidth;
          c && (l[u].maxWidth = c);
          var f = i.barMinWidth;
          f && (l[u].minWidth = f);
          var g = i.barGap;
          g != null && (s.gap = g);
          var d = i.barCategoryGap;
          d != null && (s.categoryGap = d);
        });
        var e = {};
        return D(t, function(i, r) {
          e[r] = {};
          var a = i.stacks, o = i.bandWidth, s = i.categoryGap;
          if (s == null) {
            var l = oe(a).length;
            s = Math.max(35 - l * 4, 15) + "%";
          }
          var u = st(s, o), h = st(i.gap, 1), c = i.remainedWidth, f = i.autoWidthCount, g = (c - u) / (f + (f - 1) * h);
          g = Math.max(g, 0), D(a, function(v) {
            var y = v.maxWidth, m = v.minWidth;
            if (v.width) {
              var _ = v.width;
              y && (_ = Math.min(_, y)), m && (_ = Math.max(_, m)), v.width = _, c -= _ + h * _, f--;
            } else {
              var _ = g;
              y && y < _ && (_ = Math.min(y, c)), m && m > _ && (_ = m), _ !== g && (v.width = _, c -= _ + h * _, f--);
            }
          }), g = (c - u) / (f + (f - 1) * h), g = Math.max(g, 0);
          var d = 0, A;
          D(a, function(v, y) {
            v.width || (v.width = g), A = v, d += v.width * (1 + h);
          }), A && (d -= A.width * h);
          var p = -d / 2;
          D(a, function(v, y) {
            e[r][y] = e[r][y] || { bandWidth: o, offset: p, width: v.width }, p += v.width * (1 + h);
          });
        }), e;
      }
      function tbt(n, t, e) {
        if (n && t) {
          var i = n[EM(t)];
          return i != null && e != null ? i[_M(e)] : i;
        }
      }
      function QV(n, t) {
        var e = FV(n, t), i = kV(e);
        D(e, function(r) {
          var a = r.getData(), o = r.coordinateSystem, s = o.getBaseAxis(), l = _M(r), u = i[EM(s)][l], h = u.offset, c = u.width;
          a.setLayout({ bandWidth: u.bandWidth, offset: h, size: c });
        });
      }
      function zV(n) {
        return { seriesType: n, plan: rd(), reset: function(t) {
          if (GV(t)) {
            var e = t.getData(), i = t.coordinateSystem, r = i.getBaseAxis(), a = i.getOtherAxis(r), o = e.getDimensionIndex(e.mapDimension(a.dim)), s = e.getDimensionIndex(e.mapDimension(r.dim)), l = t.get("showBackground", true), u = e.mapDimension(a.dim), h = e.getCalculationInfo("stackResultDimension"), c = yu(e, u) && !!e.getCalculationInfo("stackedOnSeries"), f = a.isHorizontal(), g = ebt(r, a), d = UV(t), A = t.get("barMinHeight") || 0, p = h && e.getDimensionIndex(h), v = e.getLayout("size"), y = e.getLayout("offset");
            return { progress: function(m, _) {
              for (var I = m.count, E = d && ns(I * 3), x = d && l && ns(I * 3), w = d && ns(I), C = i.master.getRect(), S = f ? C.width : C.height, b, T = _.getStore(), B = 0; (b = m.next()) != null; ) {
                var R = T.get(c ? p : o, b), M = T.get(s, b), L = g, N = void 0;
                c && (N = +R - T.get(o, b));
                var F = void 0, k = void 0, O = void 0, Q = void 0;
                if (f) {
                  var j = i.dataToPoint([R, M]);
                  if (c) {
                    var Y = i.dataToPoint([N, M]);
                    L = Y[0];
                  }
                  F = L, k = j[1] + y, O = j[0] - L, Q = v, Math.abs(O) < A && (O = (O < 0 ? -1 : 1) * A);
                } else {
                  var j = i.dataToPoint([M, R]);
                  if (c) {
                    var Y = i.dataToPoint([M, N]);
                    L = Y[1];
                  }
                  F = j[0] + y, k = L, O = v, Q = j[1] - L, Math.abs(Q) < A && (Q = (Q <= 0 ? -1 : 1) * A);
                }
                d ? (E[B] = F, E[B + 1] = k, E[B + 2] = f ? O : Q, x && (x[B] = f ? C.x : F, x[B + 1] = f ? k : C.y, x[B + 2] = S), w[b] = b) : _.setItemLayout(b, { x: F, y: k, width: O, height: Q }), B += 3;
              }
              d && _.setLayout({ largePoints: E, largeDataIndices: w, largeBackgroundPoints: x, valueAxisHorizontal: f });
            } };
          }
        } };
      }
      function GV(n) {
        return n.coordinateSystem && n.coordinateSystem.type === "cartesian2d";
      }
      function UV(n) {
        return n.pipelineContext && n.pipelineContext.large;
      }
      function ebt(n, t) {
        var e = t.model.get("startValue");
        return e || (e = 0), t.toGlobalCoord(t.dataToCoord(t.type === "log" ? e > 0 ? e : 1 : e));
      }
      var nbt = function(n, t, e, i) {
        for (; e < i; ) {
          var r = e + i >>> 1;
          n[r][1] < t ? e = r + 1 : i = r;
        }
        return e;
      }, IM = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "time", i;
        }
        return t.prototype.getLabel = function(e) {
          var i = this.getSetting("useUTC");
          return X1(e.value, X8[Nxt(Xg(this._minLevelUnit))] || X8.second, i, this.getSetting("locale"));
        }, t.prototype.getFormattedLabel = function(e, i, r) {
          var a = this.getSetting("useUTC"), o = this.getSetting("locale");
          return Fxt(e, i, r, o, a);
        }, t.prototype.getTicks = function() {
          var e = this._interval, i = this._extent, r = [];
          if (!e) return r;
          r.push({ value: i[0], level: 0 });
          var a = this.getSetting("useUTC"), o = ubt(this._minLevelUnit, this._approxInterval, a, i);
          return r = r.concat(o), r.push({ value: i[1], level: 0 }), r;
        }, t.prototype.calcNiceExtent = function(e) {
          var i = this._extent;
          if (i[0] === i[1] && (i[0] -= Ea, i[1] += Ea), i[1] === -1 / 0 && i[0] === 1 / 0) {
            var r = /* @__PURE__ */ new Date();
            i[1] = +new Date(r.getFullYear(), r.getMonth(), r.getDate()), i[0] = i[1] - Ea;
          }
          this.calcNiceTicks(e.splitNumber, e.minInterval, e.maxInterval);
        }, t.prototype.calcNiceTicks = function(e, i, r) {
          e = e || 10;
          var a = this._extent, o = a[1] - a[0];
          this._approxInterval = o / e, i != null && this._approxInterval < i && (this._approxInterval = i), r != null && this._approxInterval > r && (this._approxInterval = r);
          var s = RE.length, l = Math.min(nbt(RE, this._approxInterval, 0, s), s - 1);
          this._interval = RE[l][1], this._minLevelUnit = RE[Math.max(l - 1, 0)][0];
        }, t.prototype.parse = function(e) {
          return ye(e) ? e : +qo(e);
        }, t.prototype.contain = function(e) {
          return TE(this.parse(e), this._extent);
        }, t.prototype.normalize = function(e) {
          return BE(this.parse(e), this._extent);
        }, t.prototype.scale = function(e) {
          return ME(e, this._extent);
        }, t.type = "time", t;
      }(el), RE = [["second", AB], ["minute", pB], ["hour", mv], ["quarter-day", mv * 6], ["half-day", mv * 12], ["day", Ea * 1.2], ["half-week", Ea * 3.5], ["week", Ea * 7], ["month", Ea * 31], ["quarter", Ea * 95], ["half-year", W8 / 2], ["year", W8]];
      function ibt(n, t, e, i) {
        var r = qo(t), a = qo(e), o = function(d) {
          return K8(r, d, i) === K8(a, d, i);
        }, s = function() {
          return o("year");
        }, l = function() {
          return s() && o("month");
        }, u = function() {
          return l() && o("day");
        }, h = function() {
          return u() && o("hour");
        }, c = function() {
          return h() && o("minute");
        }, f = function() {
          return c() && o("second");
        }, g = function() {
          return f() && o("millisecond");
        };
        switch (n) {
          case "year":
            return s();
          case "month":
            return l();
          case "day":
            return u();
          case "hour":
            return h();
          case "minute":
            return c();
          case "second":
            return f();
          case "millisecond":
            return g();
        }
      }
      function rbt(n, t) {
        return n /= Ea, n > 16 ? 16 : n > 7.5 ? 7 : n > 3.5 ? 4 : n > 1.5 ? 2 : 1;
      }
      function abt(n) {
        var t = 30 * Ea;
        return n /= t, n > 6 ? 6 : n > 3 ? 3 : n > 2 ? 2 : 1;
      }
      function obt(n) {
        return n /= mv, n > 12 ? 12 : n > 6 ? 6 : n > 3.5 ? 4 : n > 2 ? 2 : 1;
      }
      function VV(n, t) {
        return n /= t ? pB : AB, n > 30 ? 30 : n > 20 ? 20 : n > 15 ? 15 : n > 10 ? 10 : n > 5 ? 5 : n > 2 ? 2 : 1;
      }
      function sbt(n) {
        return s4(n);
      }
      function lbt(n, t, e) {
        var i = new Date(n);
        switch (Xg(t)) {
          case "year":
          case "month":
            i[J8(e)](0);
          case "day":
            i[t6(e)](1);
          case "hour":
            i[e6(e)](0);
          case "minute":
            i[n6(e)](0);
          case "second":
            i[i6(e)](0), i[r6(e)](0);
        }
        return i.getTime();
      }
      function ubt(n, t, e, i) {
        var r = 1e4, a = $8, o = 0;
        function s(S, b, T, B, R, M, L) {
          for (var N = new Date(b), F = b, k = N[B](); F < T && F <= i[1]; ) L.push({ value: F }), k += S, N[R](k), F = N.getTime();
          L.push({ value: F, notAdd: true });
        }
        function l(S, b, T) {
          var B = [], R = !b.length;
          if (!ibt(Xg(S), i[0], i[1], e)) {
            R && (b = [{ value: lbt(new Date(i[0]), S, e) }, { value: i[1] }]);
            for (var M = 0; M < b.length - 1; M++) {
              var L = b[M].value, N = b[M + 1].value;
              if (L !== N) {
                var F = void 0, k = void 0, O = void 0, Q = false;
                switch (S) {
                  case "year":
                    F = Math.max(1, Math.round(t / Ea / 365)), k = yB(e), O = kxt(e);
                    break;
                  case "half-year":
                  case "quarter":
                  case "month":
                    F = abt(t), k = $g(e), O = J8(e);
                    break;
                  case "week":
                  case "half-week":
                  case "day":
                    F = rbt(t), k = $1(e), O = t6(e), Q = true;
                    break;
                  case "half-day":
                  case "quarter-day":
                  case "hour":
                    F = obt(t), k = Ev(e), O = e6(e);
                    break;
                  case "minute":
                    F = VV(t, true), k = Z1(e), O = n6(e);
                    break;
                  case "second":
                    F = VV(t, false), k = K1(e), O = i6(e);
                    break;
                  case "millisecond":
                    F = sbt(t), k = J1(e), O = r6(e);
                    break;
                }
                s(F, L, N, k, O, Q, B), S === "year" && T.length > 1 && M === 0 && T.unshift({ value: T[0].value - F });
              }
            }
            for (var M = 0; M < B.length; M++) T.push(B[M]);
            return B;
          }
        }
        for (var u = [], h = [], c = 0, f = 0, g = 0; g < a.length && o++ < r; ++g) {
          var d = Xg(a[g]);
          if (Pxt(a[g])) {
            l(a[g], u[u.length - 1] || [], h);
            var A = a[g + 1] ? Xg(a[g + 1]) : null;
            if (d !== A) {
              if (h.length) {
                f = c, h.sort(function(S, b) {
                  return S.value - b.value;
                });
                for (var p = [], v = 0; v < h.length; ++v) {
                  var y = h[v].value;
                  (v === 0 || h[v - 1].value !== y) && (p.push(h[v]), y >= i[0] && y <= i[1] && c++);
                }
                var m = (i[1] - i[0]) / t;
                if (c > m * 1.5 && f > m / 1.5 || (u.push(p), c > m || n === a[g])) break;
              }
              h = [];
            }
          }
        }
        o >= r && gn("Exceed safe limit.");
        for (var _ = Fe(K(u, function(S) {
          return Fe(S, function(b) {
            return b.value >= i[0] && b.value <= i[1] && !b.notAdd;
          });
        }), function(S) {
          return S.length > 0;
        }), I = [], E = _.length - 1, g = 0; g < _.length; ++g) for (var x = _[g], w = 0; w < x.length; ++w) I.push({ value: x[w].value, level: E - g });
        I.sort(function(S, b) {
          return S.value - b.value;
        });
        for (var C = [], g = 0; g < I.length; ++g) (g === 0 || I[g].value !== I[g - 1].value) && C.push(I[g]);
        return C;
      }
      es.registerClass(IM);
      var jV = es.prototype, Vv = el.prototype, hbt = En, cbt = Math.floor, fbt = Math.ceil, LE = Math.pow, ro = Math.log, xM = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "log", e.base = 10, e._originalScale = new el(), e._interval = 0, e;
        }
        return t.prototype.getTicks = function(e) {
          var i = this._originalScale, r = this._extent, a = i.getExtent(), o = Vv.getTicks.call(this, e);
          return K(o, function(s) {
            var l = s.value, u = En(LE(this.base, l));
            return u = l === r[0] && this._fixMin ? PE(u, a[0]) : u, u = l === r[1] && this._fixMax ? PE(u, a[1]) : u, { value: u };
          }, this);
        }, t.prototype.setExtent = function(e, i) {
          var r = ro(this.base);
          e = ro(Math.max(0, e)) / r, i = ro(Math.max(0, i)) / r, Vv.setExtent.call(this, e, i);
        }, t.prototype.getExtent = function() {
          var e = this.base, i = jV.getExtent.call(this);
          i[0] = LE(e, i[0]), i[1] = LE(e, i[1]);
          var r = this._originalScale, a = r.getExtent();
          return this._fixMin && (i[0] = PE(i[0], a[0])), this._fixMax && (i[1] = PE(i[1], a[1])), i;
        }, t.prototype.unionExtent = function(e) {
          this._originalScale.unionExtent(e);
          var i = this.base;
          e[0] = ro(e[0]) / ro(i), e[1] = ro(e[1]) / ro(i), jV.unionExtent.call(this, e);
        }, t.prototype.unionExtentFromData = function(e, i) {
          this.unionExtent(e.getApproximateExtent(i));
        }, t.prototype.calcNiceTicks = function(e) {
          e = e || 10;
          var i = this._extent, r = i[1] - i[0];
          if (!(r === 1 / 0 || r <= 0)) {
            var a = fEt(r), o = e / r * a;
            for (o <= 0.5 && (a *= 10); !isNaN(a) && Math.abs(a) < 1 && Math.abs(a) > 0; ) a *= 10;
            var s = [En(fbt(i[0] / a) * a), En(cbt(i[1] / a) * a)];
            this._interval = a, this._niceExtent = s;
          }
        }, t.prototype.calcNiceExtent = function(e) {
          Vv.calcNiceExtent.call(this, e), this._fixMin = e.fixMin, this._fixMax = e.fixMax;
        }, t.prototype.parse = function(e) {
          return e;
        }, t.prototype.contain = function(e) {
          return e = ro(e) / ro(this.base), TE(e, this._extent);
        }, t.prototype.normalize = function(e) {
          return e = ro(e) / ro(this.base), BE(e, this._extent);
        }, t.prototype.scale = function(e) {
          return e = ME(e, this._extent), LE(this.base, e);
        }, t.type = "log", t;
      }(es), qV = xM.prototype;
      qV.getMinorTicks = Vv.getMinorTicks, qV.getLabel = Vv.getLabel;
      function PE(n, t) {
        return hbt(n, jo(t));
      }
      es.registerClass(xM);
      var gbt = function() {
        function n(t, e, i) {
          this._prepareParams(t, e, i);
        }
        return n.prototype._prepareParams = function(t, e, i) {
          i[1] < i[0] && (i = [NaN, NaN]), this._dataMin = i[0], this._dataMax = i[1];
          var r = this._isOrdinal = t.type === "ordinal";
          this._needCrossZero = t.type === "interval" && e.getNeedCrossZero && e.getNeedCrossZero();
          var a = e.get("min", true);
          a == null && (a = e.get("startValue", true));
          var o = this._modelMinRaw = a;
          yt(o) ? this._modelMinNum = NE(t, o({ min: i[0], max: i[1] })) : o !== "dataMin" && (this._modelMinNum = NE(t, o));
          var s = this._modelMaxRaw = e.get("max", true);
          if (yt(s) ? this._modelMaxNum = NE(t, s({ min: i[0], max: i[1] })) : s !== "dataMax" && (this._modelMaxNum = NE(t, s)), r) this._axisDataLen = e.getCategories().length;
          else {
            var l = e.get("boundaryGap"), u = Z(l) ? l : [l || 0, l || 0];
            typeof u[0] == "boolean" || typeof u[1] == "boolean" ? ("development", this._boundaryGapInner = [0, 0]) : this._boundaryGapInner = [Za(u[0], 1), Za(u[1], 1)];
          }
        }, n.prototype.calculate = function() {
          var t = this._isOrdinal, e = this._dataMin, i = this._dataMax, r = this._axisDataLen, a = this._boundaryGapInner, o = t ? null : i - e || Math.abs(e), s = this._modelMinRaw === "dataMin" ? e : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? i : this._modelMaxNum, u = s != null, h = l != null;
          s == null && (s = t ? r ? 0 : NaN : e - a[0] * o), l == null && (l = t ? r ? r - 1 : NaN : i + a[1] * o), (s == null || !isFinite(s)) && (s = NaN), (l == null || !isFinite(l)) && (l = NaN);
          var c = ph(s) || ph(l) || t && !r;
          this._needCrossZero && (s > 0 && l > 0 && !u && (s = 0), s < 0 && l < 0 && !h && (l = 0));
          var f = this._determinedMin, g = this._determinedMax;
          return f != null && (s = f, u = true), g != null && (l = g, h = true), { min: s, max: l, minFixed: u, maxFixed: h, isBlank: c };
        }, n.prototype.modifyDataMinMax = function(t, e) {
          It(!this.frozen), this[Abt[t]] = e;
        }, n.prototype.setDeterminedMinMax = function(t, e) {
          var i = dbt[t];
          It(!this.frozen && this[i] == null), this[i] = e;
        }, n.prototype.freeze = function() {
          this.frozen = true;
        }, n;
      }(), dbt = { min: "_determinedMin", max: "_determinedMax" }, Abt = { min: "_dataMin", max: "_dataMax" };
      function HV(n, t, e) {
        var i = n.rawExtentInfo;
        return i || (i = new gbt(n, t, e), n.rawExtentInfo = i, i);
      }
      function NE(n, t) {
        return t == null ? null : ph(t) ? NaN : n.parse(t);
      }
      function YV(n, t) {
        var e = n.type, i = HV(n, t, n.getExtent()).calculate();
        n.setBlank(i.isBlank);
        var r = i.min, a = i.max, o = t.ecModel;
        if (o && e === "time") {
          var s = FV("bar", o), l = false;
          if (D(s, function(c) {
            l = l || c.getBaseAxis() === t.axis;
          }), l) {
            var u = kV(s), h = pbt(r, a, t, u);
            r = h.min, a = h.max;
          }
        }
        return { extent: [r, a], fixMin: i.minFixed, fixMax: i.maxFixed };
      }
      function pbt(n, t, e, i) {
        var r = e.axis.getExtent(), a = r[1] - r[0], o = tbt(i, e.axis);
        if (o === void 0) return { min: n, max: t };
        var s = 1 / 0;
        D(o, function(g) {
          s = Math.min(g.offset, s);
        });
        var l = -1 / 0;
        D(o, function(g) {
          l = Math.max(g.offset + g.width, l);
        }), s = Math.abs(s), l = Math.abs(l);
        var u = s + l, h = t - n, c = 1 - (s + l) / a, f = h / c - h;
        return t += f * (l / u), n -= f * (s / u), { min: n, max: t };
      }
      function gd(n, t) {
        var e = t, i = YV(n, e), r = i.extent, a = e.get("splitNumber");
        n instanceof xM && (n.base = e.get("logBase"));
        var o = n.type, s = e.get("interval"), l = o === "interval" || o === "time";
        n.setExtent(r[0], r[1]), n.calcNiceExtent({ splitNumber: a, fixMin: i.fixMin, fixMax: i.fixMax, minInterval: l ? e.get("minInterval") : null, maxInterval: l ? e.get("maxInterval") : null }), s != null && n.setInterval && n.setInterval(s);
      }
      function FE(n, t) {
        if (t = t || n.get("type"), t) switch (t) {
          case "category":
            return new DE({ ordinalMeta: n.getOrdinalMeta ? n.getOrdinalMeta() : n.getCategories(), extent: [1 / 0, -1 / 0] });
          case "time":
            return new IM({ locale: n.ecModel.getLocaleModel(), useUTC: n.ecModel.get("useUTC") });
          default:
            return new (es.getClass(t) || el)();
        }
      }
      function vbt(n) {
        var t = n.scale.getExtent(), e = t[0], i = t[1];
        return !(e > 0 && i > 0 || e < 0 && i < 0);
      }
      function dd(n) {
        var t = n.getLabelModel().get("formatter"), e = n.type === "category" ? n.scale.getExtent()[0] : null;
        return n.scale.type === "time" ? /* @__PURE__ */ function(i) {
          return function(r, a) {
            return n.scale.getFormattedLabel(r, a, i);
          };
        }(t) : ht(t) ? /* @__PURE__ */ function(i) {
          return function(r) {
            var a = n.scale.getLabel(r), o = i.replace("{value}", a != null ? a : "");
            return o;
          };
        }(t) : yt(t) ? /* @__PURE__ */ function(i) {
          return function(r, a) {
            return e != null && (a = r.value - e), i(wM(n, r), a, r.level != null ? { level: r.level } : null);
          };
        }(t) : function(i) {
          return n.scale.getLabel(i);
        };
      }
      function wM(n, t) {
        return n.type === "category" ? n.scale.getLabel(t) : t.value;
      }
      function ybt(n) {
        var t = n.model, e = n.scale;
        if (!(!t.get(["axisLabel", "show"]) || e.isBlank())) {
          var i, r, a = e.getExtent();
          e instanceof DE ? r = e.count() : (i = e.getTicks(), r = i.length);
          var o = n.getLabelModel(), s = dd(n), l, u = 1;
          r > 40 && (u = Math.ceil(r / 40));
          for (var h = 0; h < r; h += u) {
            var c = i ? i[h] : { value: a[0] + h }, f = s(c, h), g = o.getTextRect(f), d = mbt(g, o.get("rotate") || 0);
            l ? l.union(d) : l = d;
          }
          return l;
        }
      }
      function mbt(n, t) {
        var e = t * Math.PI / 180, i = n.width, r = n.height, a = i * Math.abs(Math.cos(e)) + Math.abs(r * Math.sin(e)), o = i * Math.abs(Math.sin(e)) + Math.abs(r * Math.cos(e)), s = new Wt(n.x, n.y, a, o);
        return s;
      }
      function CM(n) {
        var t = n.get("interval");
        return t == null ? "auto" : t;
      }
      function WV(n) {
        return n.type === "category" && CM(n.getLabelModel()) === 0;
      }
      function kE(n, t) {
        var e = {};
        return D(n.mapDimensionsAll(t), function(i) {
          e[RV(n, i)] = true;
        }), oe(e);
      }
      function _bt(n, t, e) {
        t && D(kE(t, e), function(i) {
          var r = t.getApproximateExtent(i);
          r[0] < n[0] && (n[0] = r[0]), r[1] > n[1] && (n[1] = r[1]);
        });
      }
      var jv = function() {
        function n() {
        }
        return n.prototype.getNeedCrossZero = function() {
          var t = this.option;
          return !t.scale;
        }, n.prototype.getCoordSysModel = function() {
        }, n;
      }(), Ebt = 1e-8;
      function XV(n, t) {
        return Math.abs(n - t) < Ebt;
      }
      function sc(n, t, e) {
        var i = 0, r = n[0];
        if (!r) return false;
        for (var a = 1; a < n.length; a++) {
          var o = n[a];
          i += Hs(r[0], r[1], o[0], o[1], t, e), r = o;
        }
        var s = n[0];
        return (!XV(r[0], s[0]) || !XV(r[1], s[1])) && (i += Hs(r[0], r[1], s[0], s[1], t, e)), i !== 0;
      }
      var Ibt = [];
      function SM(n, t) {
        for (var e = 0; e < n.length; e++) _i(n[e], n[e], t);
      }
      function $V(n, t, e, i) {
        for (var r = 0; r < n.length; r++) {
          var a = n[r];
          i && (a = i.project(a)), a && isFinite(a[0]) && isFinite(a[1]) && (Zl(t, t, a), Kl(e, e, a));
        }
      }
      function xbt(n) {
        for (var t = 0, e = 0, i = 0, r = n.length, a = n[r - 1][0], o = n[r - 1][1], s = 0; s < r; s++) {
          var l = n[s][0], u = n[s][1], h = a * u - l * o;
          t += h, e += (a + l) * h, i += (o + u) * h, a = l, o = u;
        }
        return t ? [e / t / 3, i / t / 3, t] : [n[0][0] || 0, n[0][1] || 0];
      }
      var ZV = function() {
        function n(t) {
          this.name = t;
        }
        return n.prototype.setCenter = function(t) {
          this._center = t;
        }, n.prototype.getCenter = function() {
          var t = this._center;
          return t || (t = this._center = this.calcCenter()), t;
        }, n;
      }(), KV = /* @__PURE__ */ function() {
        function n(t, e) {
          this.type = "polygon", this.exterior = t, this.interiors = e;
        }
        return n;
      }(), JV = /* @__PURE__ */ function() {
        function n(t) {
          this.type = "linestring", this.points = t;
        }
        return n;
      }(), tj = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this, e) || this;
          return a.type = "geoJSON", a.geometries = i, a._center = r && [r[0], r[1]], a;
        }
        return t.prototype.calcCenter = function() {
          for (var e = this.geometries, i, r = 0, a = 0; a < e.length; a++) {
            var o = e[a], s = o.exterior, l = s && s.length;
            l > r && (i = o, r = l);
          }
          if (i) return xbt(i.exterior);
          var u = this.getBoundingRect();
          return [u.x + u.width / 2, u.y + u.height / 2];
        }, t.prototype.getBoundingRect = function(e) {
          var i = this._rect;
          if (i && !e) return i;
          var r = [1 / 0, 1 / 0], a = [-1 / 0, -1 / 0], o = this.geometries;
          return D(o, function(s) {
            s.type === "polygon" ? $V(s.exterior, r, a, e) : D(s.points, function(l) {
              $V(l, r, a, e);
            });
          }), isFinite(r[0]) && isFinite(r[1]) && isFinite(a[0]) && isFinite(a[1]) || (r[0] = r[1] = a[0] = a[1] = 0), i = new Wt(r[0], r[1], a[0] - r[0], a[1] - r[1]), e || (this._rect = i), i;
        }, t.prototype.contain = function(e) {
          var i = this.getBoundingRect(), r = this.geometries;
          if (!i.contain(e[0], e[1])) return false;
          t: for (var a = 0, o = r.length; a < o; a++) {
            var s = r[a];
            if (s.type === "polygon") {
              var l = s.exterior, u = s.interiors;
              if (sc(l, e[0], e[1])) {
                for (var h = 0; h < (u ? u.length : 0); h++) if (sc(u[h], e[0], e[1])) continue t;
                return true;
              }
            }
          }
          return false;
        }, t.prototype.transformTo = function(e, i, r, a) {
          var o = this.getBoundingRect(), s = o.width / o.height;
          r ? a || (a = r / s) : r = s * a;
          for (var l = new Wt(e, i, r, a), u = o.calculateTransform(l), h = this.geometries, c = 0; c < h.length; c++) {
            var f = h[c];
            f.type === "polygon" ? (SM(f.exterior, u), D(f.interiors, function(g) {
              SM(g, u);
            })) : D(f.points, function(g) {
              SM(g, u);
            });
          }
          o = this._rect, o.copy(l), this._center = [o.x + o.width / 2, o.y + o.height / 2];
        }, t.prototype.cloneShallow = function(e) {
          e == null && (e = this.name);
          var i = new t(e, this.geometries, this._center);
          return i._rect = this._rect, i.transformTo = null, i;
        }, t;
      }(ZV), wbt = function(n) {
        V(t, n);
        function t(e, i) {
          var r = n.call(this, e) || this;
          return r.type = "geoSVG", r._elOnlyForCalculate = i, r;
        }
        return t.prototype.calcCenter = function() {
          for (var e = this._elOnlyForCalculate, i = e.getBoundingRect(), r = [i.x + i.width / 2, i.y + i.height / 2], a = q_(Ibt), o = e; o && !o.isGeoSVGGraphicRoot; ) zs(a, o.getLocalTransform(), a), o = o.parent;
          return Sg(a, a), _i(r, r, a), r;
        }, t;
      }(ZV);
      function Cbt(n) {
        if (!n.UTF8Encoding) return n;
        var t = n, e = t.UTF8Scale;
        e == null && (e = 1024);
        var i = t.features;
        return D(i, function(r) {
          var a = r.geometry, o = a.encodeOffsets, s = a.coordinates;
          if (o) switch (a.type) {
            case "LineString":
              a.coordinates = ej(s, o, e);
              break;
            case "Polygon":
              bM(s, o, e);
              break;
            case "MultiLineString":
              bM(s, o, e);
              break;
            case "MultiPolygon":
              D(s, function(l, u) {
                return bM(l, o[u], e);
              });
          }
        }), t.UTF8Encoding = false, t;
      }
      function bM(n, t, e) {
        for (var i = 0; i < n.length; i++) n[i] = ej(n[i], t[i], e);
      }
      function ej(n, t, e) {
        for (var i = [], r = t[0], a = t[1], o = 0; o < n.length; o += 2) {
          var s = n.charCodeAt(o) - 64, l = n.charCodeAt(o + 1) - 64;
          s = s >> 1 ^ -(s & 1), l = l >> 1 ^ -(l & 1), s += r, l += a, r = s, a = l, i.push([s / e, l / e]);
        }
        return i;
      }
      function Sbt(n, t) {
        return n = Cbt(n), K(Fe(n.features, function(e) {
          return e.geometry && e.properties && e.geometry.coordinates.length > 0;
        }), function(e) {
          var i = e.properties, r = e.geometry, a = [];
          switch (r.type) {
            case "Polygon":
              var o = r.coordinates;
              a.push(new KV(o[0], o.slice(1)));
              break;
            case "MultiPolygon":
              D(r.coordinates, function(l) {
                l[0] && a.push(new KV(l[0], l.slice(1)));
              });
              break;
            case "LineString":
              a.push(new JV([r.coordinates]));
              break;
            case "MultiLineString":
              a.push(new JV(r.coordinates));
          }
          var s = new tj(i[t || "name"], a, i.cp);
          return s.properties = i, s;
        });
      }
      var qv = ce();
      function nj(n, t) {
        var e = K(t, function(i) {
          return n.scale.parse(i);
        });
        return n.type === "time" && e.length > 0 && (e.sort(), e.unshift(e[0]), e.push(e[e.length - 1])), e;
      }
      function bbt(n) {
        var t = n.getLabelModel().get("customValues");
        if (t) {
          var e = dd(n);
          return { labels: nj(n, t).map(function(i) {
            var r = { value: i };
            return { formattedLabel: e(r), rawLabel: n.scale.getLabel(r), tickValue: i };
          }) };
        }
        return n.type === "category" ? Bbt(n) : Dbt(n);
      }
      function Tbt(n, t) {
        var e = n.getTickModel().get("customValues");
        return e ? { ticks: nj(n, e) } : n.type === "category" ? Mbt(n, t) : { ticks: K(n.scale.getTicks(), function(i) {
          return i.value;
        }) };
      }
      function Bbt(n) {
        var t = n.getLabelModel(), e = ij(n, t);
        return !t.get("show") || n.scale.isBlank() ? { labels: [], labelCategoryInterval: e.labelCategoryInterval } : e;
      }
      function ij(n, t) {
        var e = rj(n, "labels"), i = CM(t), r = aj(e, i);
        if (r) return r;
        var a, o;
        return yt(i) ? a = lj(n, i) : (o = i === "auto" ? Rbt(n) : i, a = sj(n, o)), oj(e, i, { labels: a, labelCategoryInterval: o });
      }
      function Mbt(n, t) {
        var e = rj(n, "ticks"), i = CM(t), r = aj(e, i);
        if (r) return r;
        var a, o;
        if ((!t.get("show") || n.scale.isBlank()) && (a = []), yt(i)) a = lj(n, i, true);
        else if (i === "auto") {
          var s = ij(n, n.getLabelModel());
          o = s.labelCategoryInterval, a = K(s.labels, function(l) {
            return l.tickValue;
          });
        } else o = i, a = sj(n, o, true);
        return oj(e, i, { ticks: a, tickCategoryInterval: o });
      }
      function Dbt(n) {
        var t = n.scale.getTicks(), e = dd(n);
        return { labels: K(t, function(i, r) {
          return { level: i.level, formattedLabel: e(i, r), rawLabel: n.scale.getLabel(i), tickValue: i.value };
        }) };
      }
      function rj(n, t) {
        return qv(n)[t] || (qv(n)[t] = []);
      }
      function aj(n, t) {
        for (var e = 0; e < n.length; e++) if (n[e].key === t) return n[e].value;
      }
      function oj(n, t, e) {
        return n.push({ key: t, value: e }), e;
      }
      function Rbt(n) {
        var t = qv(n).autoInterval;
        return t != null ? t : qv(n).autoInterval = n.calculateCategoryInterval();
      }
      function Lbt(n) {
        var t = Pbt(n), e = dd(n), i = (t.axisRotate - t.labelRotate) / 180 * Math.PI, r = n.scale, a = r.getExtent(), o = r.count();
        if (a[1] - a[0] < 1) return 0;
        var s = 1;
        o > 40 && (s = Math.max(1, Math.floor(o / 40)));
        for (var l = a[0], u = n.dataToCoord(l + 1) - n.dataToCoord(l), h = Math.abs(u * Math.cos(i)), c = Math.abs(u * Math.sin(i)), f = 0, g = 0; l <= a[1]; l += s) {
          var d = 0, A = 0, p = $p(e({ value: l }), t.font, "center", "top");
          d = p.width * 1.3, A = p.height * 1.3, f = Math.max(f, d, 7), g = Math.max(g, A, 7);
        }
        var v = f / h, y = g / c;
        isNaN(v) && (v = 1 / 0), isNaN(y) && (y = 1 / 0);
        var m = Math.max(0, Math.floor(Math.min(v, y))), _ = qv(n.model), I = n.getExtent(), E = _.lastAutoInterval, x = _.lastTickCount;
        return E != null && x != null && Math.abs(E - m) <= 1 && Math.abs(x - o) <= 1 && E > m && _.axisExtent0 === I[0] && _.axisExtent1 === I[1] ? m = E : (_.lastTickCount = o, _.lastAutoInterval = m, _.axisExtent0 = I[0], _.axisExtent1 = I[1]), m;
      }
      function Pbt(n) {
        var t = n.getLabelModel();
        return { axisRotate: n.getRotate ? n.getRotate() : n.isHorizontal && !n.isHorizontal() ? 90 : 0, labelRotate: t.get("rotate") || 0, font: t.getFont() };
      }
      function sj(n, t, e) {
        var i = dd(n), r = n.scale, a = r.getExtent(), o = n.getLabelModel(), s = [], l = Math.max((t || 0) + 1, 1), u = a[0], h = r.count();
        u !== 0 && l > 1 && h / l > 2 && (u = Math.round(Math.ceil(u / l) * l));
        var c = WV(n), f = o.get("showMinLabel") || c, g = o.get("showMaxLabel") || c;
        f && u !== a[0] && A(a[0]);
        for (var d = u; d <= a[1]; d += l) A(d);
        g && d - l !== a[1] && A(a[1]);
        function A(p) {
          var v = { value: p };
          s.push(e ? p : { formattedLabel: i(v), rawLabel: r.getLabel(v), tickValue: p });
        }
        return s;
      }
      function lj(n, t, e) {
        var i = n.scale, r = dd(n), a = [];
        return D(i.getTicks(), function(o) {
          var s = i.getLabel(o), l = o.value;
          t(o.value, s) && a.push(e ? l : { formattedLabel: r(o), rawLabel: s, tickValue: l });
        }), a;
      }
      var uj = [0, 1], ao = function() {
        function n(t, e, i) {
          this.onBand = false, this.inverse = false, this.dim = t, this.scale = e, this._extent = i || [0, 0];
        }
        return n.prototype.contain = function(t) {
          var e = this._extent, i = Math.min(e[0], e[1]), r = Math.max(e[0], e[1]);
          return t >= i && t <= r;
        }, n.prototype.containData = function(t) {
          return this.scale.contain(t);
        }, n.prototype.getExtent = function() {
          return this._extent.slice();
        }, n.prototype.getPixelPrecision = function(t) {
          return r4(t || this.scale.getExtent(), this._extent);
        }, n.prototype.setExtent = function(t, e) {
          var i = this._extent;
          i[0] = t, i[1] = e;
        }, n.prototype.dataToCoord = function(t, e) {
          var i = this._extent, r = this.scale;
          return t = r.normalize(t), this.onBand && r.type === "ordinal" && (i = i.slice(), hj(i, r.count())), Ne(t, uj, i, e);
        }, n.prototype.coordToData = function(t, e) {
          var i = this._extent, r = this.scale;
          this.onBand && r.type === "ordinal" && (i = i.slice(), hj(i, r.count()));
          var a = Ne(t, i, uj, e);
          return this.scale.scale(a);
        }, n.prototype.pointToData = function(t, e) {
        }, n.prototype.getTicksCoords = function(t) {
          t = t || {};
          var e = t.tickModel || this.getTickModel(), i = Tbt(this, e), r = i.ticks, a = K(r, function(s) {
            return { coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(s) : s), tickValue: s };
          }, this), o = e.get("alignWithLabel");
          return Nbt(this, a, o, t.clamp), a;
        }, n.prototype.getMinorTicksCoords = function() {
          if (this.scale.type === "ordinal") return [];
          var t = this.model.getModel("minorTick"), e = t.get("splitNumber");
          e > 0 && e < 100 || (e = 5);
          var i = this.scale.getMinorTicks(e), r = K(i, function(a) {
            return K(a, function(o) {
              return { coord: this.dataToCoord(o), tickValue: o };
            }, this);
          }, this);
          return r;
        }, n.prototype.getViewLabels = function() {
          return bbt(this).labels;
        }, n.prototype.getLabelModel = function() {
          return this.model.getModel("axisLabel");
        }, n.prototype.getTickModel = function() {
          return this.model.getModel("axisTick");
        }, n.prototype.getBandWidth = function() {
          var t = this._extent, e = this.scale.getExtent(), i = e[1] - e[0] + (this.onBand ? 1 : 0);
          i === 0 && (i = 1);
          var r = Math.abs(t[1] - t[0]);
          return Math.abs(r) / i;
        }, n.prototype.calculateCategoryInterval = function() {
          return Lbt(this);
        }, n;
      }();
      function hj(n, t) {
        var e = n[1] - n[0], i = t, r = e / i / 2;
        n[0] += r, n[1] -= r;
      }
      function Nbt(n, t, e, i) {
        var r = t.length;
        if (!n.onBand || e || !r) return;
        var a = n.getExtent(), o, s;
        if (r === 1) t[0].coord = a[0], o = t[1] = { coord: a[1] };
        else {
          var l = t[r - 1].tickValue - t[0].tickValue, u = (t[r - 1].coord - t[0].coord) / l;
          D(t, function(g) {
            g.coord -= u / 2;
          });
          var h = n.scale.getExtent();
          s = 1 + h[1] - t[r - 1].tickValue, o = { coord: t[r - 1].coord + u * s }, t.push(o);
        }
        var c = a[0] > a[1];
        f(t[0].coord, a[0]) && (i ? t[0].coord = a[0] : t.shift()), i && f(a[0], t[0].coord) && t.unshift({ coord: a[0] }), f(a[1], o.coord) && (i ? o.coord = a[1] : t.pop()), i && f(o.coord, a[1]) && t.push({ coord: a[1] });
        function f(g, d) {
          return g = En(g), d = En(d), c ? g > d : g < d;
        }
      }
      var Hv = Math.PI * 2, lc = $o.CMD, Fbt = ["top", "right", "bottom", "left"];
      function kbt(n, t, e, i, r) {
        var a = e.width, o = e.height;
        switch (n) {
          case "top":
            i.set(e.x + a / 2, e.y - t), r.set(0, -1);
            break;
          case "bottom":
            i.set(e.x + a / 2, e.y + o + t), r.set(0, 1);
            break;
          case "left":
            i.set(e.x - t, e.y + o / 2), r.set(-1, 0);
            break;
          case "right":
            i.set(e.x + a + t, e.y + o / 2), r.set(1, 0);
            break;
        }
      }
      function Obt(n, t, e, i, r, a, o, s, l) {
        o -= n, s -= t;
        var u = Math.sqrt(o * o + s * s);
        o /= u, s /= u;
        var h = o * e + n, c = s * e + t;
        if (Math.abs(i - r) % Hv < 1e-4) return l[0] = h, l[1] = c, u - e;
        if (a) {
          var f = i;
          i = Yr(r), r = Yr(f);
        } else i = Yr(i), r = Yr(r);
        i > r && (r += Hv);
        var g = Math.atan2(s, o);
        if (g < 0 && (g += Hv), g >= i && g <= r || g + Hv >= i && g + Hv <= r) return l[0] = h, l[1] = c, u - e;
        var d = e * Math.cos(i) + n, A = e * Math.sin(i) + t, p = e * Math.cos(r) + n, v = e * Math.sin(r) + t, y = (d - o) * (d - o) + (A - s) * (A - s), m = (p - o) * (p - o) + (v - s) * (v - s);
        return y < m ? (l[0] = d, l[1] = A, Math.sqrt(y)) : (l[0] = p, l[1] = v, Math.sqrt(m));
      }
      function OE(n, t, e, i, r, a, o, s) {
        var l = r - n, u = a - t, h = e - n, c = i - t, f = Math.sqrt(h * h + c * c);
        h /= f, c /= f;
        var g = l * h + u * c, d = g / f;
        s && (d = Math.min(Math.max(d, 0), 1)), d *= f;
        var A = o[0] = n + d * h, p = o[1] = t + d * c;
        return Math.sqrt((A - r) * (A - r) + (p - a) * (p - a));
      }
      function cj(n, t, e, i, r, a, o) {
        e < 0 && (n = n + e, e = -e), i < 0 && (t = t + i, i = -i);
        var s = n + e, l = t + i, u = o[0] = Math.min(Math.max(r, n), s), h = o[1] = Math.min(Math.max(a, t), l);
        return Math.sqrt((u - r) * (u - r) + (h - a) * (h - a));
      }
      var oo = [];
      function Qbt(n, t, e) {
        var i = cj(t.x, t.y, t.width, t.height, n.x, n.y, oo);
        return e.set(oo[0], oo[1]), i;
      }
      function zbt(n, t, e) {
        for (var i = 0, r = 0, a = 0, o = 0, s, l, u = 1 / 0, h = t.data, c = n.x, f = n.y, g = 0; g < h.length; ) {
          var d = h[g++];
          g === 1 && (i = h[g], r = h[g + 1], a = i, o = r);
          var A = u;
          switch (d) {
            case lc.M:
              a = h[g++], o = h[g++], i = a, r = o;
              break;
            case lc.L:
              A = OE(i, r, h[g], h[g + 1], c, f, oo, true), i = h[g++], r = h[g++];
              break;
            case lc.C:
              A = C5(i, r, h[g++], h[g++], h[g++], h[g++], h[g], h[g + 1], c, f, oo), i = h[g++], r = h[g++];
              break;
            case lc.Q:
              A = b5(i, r, h[g++], h[g++], h[g], h[g + 1], c, f, oo), i = h[g++], r = h[g++];
              break;
            case lc.A:
              var p = h[g++], v = h[g++], y = h[g++], m = h[g++], _ = h[g++], I = h[g++];
              g += 1;
              var E = !!(1 - h[g++]);
              s = Math.cos(_) * y + p, l = Math.sin(_) * m + v, g <= 1 && (a = s, o = l);
              var x = (c - p) * m / y + p;
              A = Obt(p, v, m, _, _ + I, E, x, f, oo), i = Math.cos(_ + I) * y + p, r = Math.sin(_ + I) * m + v;
              break;
            case lc.R:
              a = i = h[g++], o = r = h[g++];
              var w = h[g++], C = h[g++];
              A = cj(a, o, w, C, c, f, oo);
              break;
            case lc.Z:
              A = OE(i, r, a, o, c, f, oo, true), i = a, r = o;
              break;
          }
          A < u && (u = A, e.set(oo[0], oo[1]));
        }
        return u;
      }
      var so = new jt(), en = new jt(), Tn = new jt(), is = new jt(), rs = new jt();
      function fj(n, t) {
        if (n) {
          var e = n.getTextGuideLine(), i = n.getTextContent();
          if (i && e) {
            var r = n.textGuideLineConfig || {}, a = [[0, 0], [0, 0], [0, 0]], o = r.candidates || Fbt, s = i.getBoundingRect().clone();
            s.applyTransform(i.getComputedTransform());
            var l = 1 / 0, u = r.anchor, h = n.getComputedTransform(), c = h && Sg([], h), f = t.get("length2") || 0;
            u && Tn.copy(u);
            for (var g = 0; g < o.length; g++) {
              var d = o[g];
              kbt(d, 0, s, so, is), jt.scaleAndAdd(en, so, is, f), en.transform(c);
              var A = n.getBoundingRect(), p = u ? u.distance(en) : n instanceof ne ? zbt(en, n.path, Tn) : Qbt(en, A, Tn);
              p < l && (l = p, en.transform(h), Tn.transform(h), Tn.toArray(a[0]), en.toArray(a[1]), so.toArray(a[2]));
            }
            gj(a, t.get("minTurnAngle")), e.setShape({ points: a });
          }
        }
      }
      var QE = [], nr = new jt();
      function gj(n, t) {
        if (t <= 180 && t > 0) {
          t = t / 180 * Math.PI, so.fromArray(n[0]), en.fromArray(n[1]), Tn.fromArray(n[2]), jt.sub(is, so, en), jt.sub(rs, Tn, en);
          var e = is.len(), i = rs.len();
          if (!(e < 1e-3 || i < 1e-3)) {
            is.scale(1 / e), rs.scale(1 / i);
            var r = is.dot(rs), a = Math.cos(t);
            if (a < r) {
              var o = OE(en.x, en.y, Tn.x, Tn.y, so.x, so.y, QE, false);
              nr.fromArray(QE), nr.scaleAndAdd(rs, o / Math.tan(Math.PI - t));
              var s = Tn.x !== en.x ? (nr.x - en.x) / (Tn.x - en.x) : (nr.y - en.y) / (Tn.y - en.y);
              if (isNaN(s)) return;
              s < 0 ? jt.copy(nr, en) : s > 1 && jt.copy(nr, Tn), nr.toArray(n[1]);
            }
          }
        }
      }
      function Gbt(n, t, e) {
        if (e <= 180 && e > 0) {
          e = e / 180 * Math.PI, so.fromArray(n[0]), en.fromArray(n[1]), Tn.fromArray(n[2]), jt.sub(is, en, so), jt.sub(rs, Tn, en);
          var i = is.len(), r = rs.len();
          if (!(i < 1e-3 || r < 1e-3)) {
            is.scale(1 / i), rs.scale(1 / r);
            var a = is.dot(t), o = Math.cos(e);
            if (a < o) {
              var s = OE(en.x, en.y, Tn.x, Tn.y, so.x, so.y, QE, false);
              nr.fromArray(QE);
              var l = Math.PI / 2, u = Math.acos(rs.dot(t)), h = l + u - e;
              if (h >= l) jt.copy(nr, Tn);
              else {
                nr.scaleAndAdd(rs, s / Math.tan(Math.PI / 2 - h));
                var c = Tn.x !== en.x ? (nr.x - en.x) / (Tn.x - en.x) : (nr.y - en.y) / (Tn.y - en.y);
                if (isNaN(c)) return;
                c < 0 ? jt.copy(nr, en) : c > 1 && jt.copy(nr, Tn);
              }
              nr.toArray(n[1]);
            }
          }
        }
      }
      function TM(n, t, e, i) {
        var r = e === "normal", a = r ? n : n.ensureState(e);
        a.ignore = t;
        var o = i.get("smooth");
        o && o === true && (o = 0.3), a.shape = a.shape || {}, o > 0 && (a.shape.smooth = o);
        var s = i.getModel("lineStyle").getLineStyle();
        r ? n.useStyle(s) : a.style = s;
      }
      function Ubt(n, t) {
        var e = t.smooth, i = t.points;
        if (i) if (n.moveTo(i[0][0], i[0][1]), e > 0 && i.length >= 3) {
          var r = $l(i[0], i[1]), a = $l(i[1], i[2]);
          if (!r || !a) {
            n.lineTo(i[1][0], i[1][1]), n.lineTo(i[2][0], i[2][1]);
            return;
          }
          var o = Math.min(r, a) * e, s = j_([], i[1], i[0], o / r), l = j_([], i[1], i[2], o / a), u = j_([], s, l, 0.5);
          n.bezierCurveTo(s[0], s[1], s[0], s[1], u[0], u[1]), n.bezierCurveTo(l[0], l[1], l[0], l[1], i[2][0], i[2][1]);
        } else for (var h = 1; h < i.length; h++) n.lineTo(i[h][0], i[h][1]);
      }
      function BM(n, t, e) {
        var i = n.getTextGuideLine(), r = n.getTextContent();
        if (!r) {
          i && n.removeTextGuideLine();
          return;
        }
        for (var a = t.normal, o = a.get("show"), s = r.ignore, l = 0; l < ov.length; l++) {
          var u = ov[l], h = t[u], c = u === "normal";
          if (h) {
            var f = h.get("show"), g = c ? s : kt(r.states[u] && r.states[u].ignore, s);
            if (g || !kt(f, o)) {
              var d = c ? i : i && i.states[u];
              d && (d.ignore = true), i && TM(i, true, u, h);
              continue;
            }
            i || (i = new Ji(), n.setTextGuideLine(i), !c && (s || !o) && TM(i, true, "normal", t.normal), n.stateProxy && (i.stateProxy = n.stateProxy)), TM(i, false, u, h);
          }
        }
        if (i) {
          wt(i.style, e), i.style.fill = null;
          var A = a.get("showAbove"), p = n.textGuideLineConfig = n.textGuideLineConfig || {};
          p.showAbove = A || false, i.buildPath = Ubt;
        }
      }
      function MM(n, t) {
        t = t || "labelLine";
        for (var e = { normal: n.getModel(t) }, i = 0; i < $i.length; i++) {
          var r = $i[i];
          e[r] = n.getModel([r, t]);
        }
        return e;
      }
      function dj(n) {
        for (var t = [], e = 0; e < n.length; e++) {
          var i = n[e];
          if (!i.defaultAttr.ignore) {
            var r = i.label, a = r.getComputedTransform(), o = r.getBoundingRect(), s = !a || a[1] < 1e-5 && a[2] < 1e-5, l = r.style.margin || 0, u = o.clone();
            u.applyTransform(a), u.x -= l / 2, u.y -= l / 2, u.width += l, u.height += l;
            var h = s ? new O1(o, a) : null;
            t.push({ label: r, labelLine: i.labelLine, rect: u, localRect: o, obb: h, priority: i.priority, defaultAttr: i.defaultAttr, layoutOption: i.computedLayoutOption, axisAligned: s, transform: a });
          }
        }
        return t;
      }
      function Aj(n, t, e, i, r, a) {
        var o = n.length;
        if (o < 2) return;
        n.sort(function(w, C) {
          return w.rect[t] - C.rect[t];
        });
        for (var s = 0, l, u = false, h = 0, c = 0; c < o; c++) {
          var f = n[c], g = f.rect;
          l = g[t] - s, l < 0 && (g[t] -= l, f.label[t] -= l, u = true);
          var d = Math.max(-l, 0);
          h += d, s = g[t] + g[e];
        }
        h > 0 && a && I(-h / o, 0, o);
        var A = n[0], p = n[o - 1], v, y;
        m(), v < 0 && E(-v, 0.8), y < 0 && E(y, 0.8), m(), _(v, y, 1), _(y, v, -1), m(), v < 0 && x(-v), y < 0 && x(y);
        function m() {
          v = A.rect[t] - i, y = r - p.rect[t] - p.rect[e];
        }
        function _(w, C, S) {
          if (w < 0) {
            var b = Math.min(C, -w);
            if (b > 0) {
              I(b * S, 0, o);
              var T = b + w;
              T < 0 && E(-T * S, 1);
            } else E(-w * S, 1);
          }
        }
        function I(w, C, S) {
          w !== 0 && (u = true);
          for (var b = C; b < S; b++) {
            var T = n[b], B = T.rect;
            B[t] += w, T.label[t] += w;
          }
        }
        function E(w, C) {
          for (var S = [], b = 0, T = 1; T < o; T++) {
            var B = n[T - 1].rect, R = Math.max(n[T].rect[t] - B[t] - B[e], 0);
            S.push(R), b += R;
          }
          if (b) {
            var M = Math.min(Math.abs(w) / b, C);
            if (w > 0) for (var T = 0; T < o - 1; T++) {
              var L = S[T] * M;
              I(L, 0, T + 1);
            }
            else for (var T = o - 1; T > 0; T--) {
              var L = S[T - 1] * M;
              I(-L, T, o);
            }
          }
        }
        function x(w) {
          var C = w < 0 ? -1 : 1;
          w = Math.abs(w);
          for (var S = Math.ceil(w / (o - 1)), b = 0; b < o - 1; b++) if (C > 0 ? I(S, 0, b + 1) : I(-S, o - b - 1, o), w -= S, w <= 0) return;
        }
        return u;
      }
      function Vbt(n, t, e, i) {
        return Aj(n, "x", "width", t, e, i);
      }
      function pj(n, t, e, i) {
        return Aj(n, "y", "height", t, e, i);
      }
      function vj(n) {
        var t = [];
        n.sort(function(A, p) {
          return p.priority - A.priority;
        });
        var e = new Wt(0, 0, 0, 0);
        function i(A) {
          if (!A.ignore) {
            var p = A.ensureState("emphasis");
            p.ignore == null && (p.ignore = false);
          }
          A.ignore = true;
        }
        for (var r = 0; r < n.length; r++) {
          var a = n[r], o = a.axisAligned, s = a.localRect, l = a.transform, u = a.label, h = a.labelLine;
          e.copy(a.rect), e.width -= 0.1, e.height -= 0.1, e.x += 0.05, e.y += 0.05;
          for (var c = a.obb, f = false, g = 0; g < t.length; g++) {
            var d = t[g];
            if (e.intersect(d.rect)) {
              if (o && d.axisAligned) {
                f = true;
                break;
              }
              if (d.obb || (d.obb = new O1(d.localRect, d.transform)), c || (c = new O1(s, l)), c.intersect(d.obb)) {
                f = true;
                break;
              }
            }
          }
          f ? (i(u), h && i(h)) : (u.attr("ignore", a.defaultAttr.ignore), h && h.attr("ignore", a.defaultAttr.labelGuideIgnore), t.push(a));
        }
      }
      function jbt(n) {
        if (n) {
          for (var t = [], e = 0; e < n.length; e++) t.push(n[e].slice());
          return t;
        }
      }
      function qbt(n, t) {
        var e = n.label, i = t && t.getTextGuideLine();
        return { dataIndex: n.dataIndex, dataType: n.dataType, seriesIndex: n.seriesModel.seriesIndex, text: n.label.style.text, rect: n.hostRect, labelRect: n.rect, align: e.style.align, verticalAlign: e.style.verticalAlign, labelLinePoints: jbt(i && i.shape.points) };
      }
      var yj = ["align", "verticalAlign", "width", "height", "fontSize"], ir = new Vs(), DM = ce(), Hbt = ce();
      function zE(n, t, e) {
        for (var i = 0; i < e.length; i++) {
          var r = e[i];
          t[r] != null && (n[r] = t[r]);
        }
      }
      var GE = ["x", "y", "rotation"], Ybt = function() {
        function n() {
          this._labelList = [], this._chartViewList = [];
        }
        return n.prototype.clearLabels = function() {
          this._labelList = [], this._chartViewList = [];
        }, n.prototype._addLabel = function(t, e, i, r, a) {
          var o = r.style, s = r.__hostTarget, l = s.textConfig || {}, u = r.getComputedTransform(), h = r.getBoundingRect().plain();
          Wt.applyTransform(h, h, u), u ? ir.setLocalTransform(u) : (ir.x = ir.y = ir.rotation = ir.originX = ir.originY = 0, ir.scaleX = ir.scaleY = 1), ir.rotation = Yr(ir.rotation);
          var c = r.__hostTarget, f;
          if (c) {
            f = c.getBoundingRect().plain();
            var g = c.getComputedTransform();
            Wt.applyTransform(f, f, g);
          }
          var d = f && c.getTextGuideLine();
          this._labelList.push({ label: r, labelLine: d, seriesModel: i, dataIndex: t, dataType: e, layoutOption: a, computedLayoutOption: null, rect: h, hostRect: f, priority: f ? f.width * f.height : 0, defaultAttr: { ignore: r.ignore, labelGuideIgnore: d && d.ignore, x: ir.x, y: ir.y, scaleX: ir.scaleX, scaleY: ir.scaleY, rotation: ir.rotation, style: { x: o.x, y: o.y, align: o.align, verticalAlign: o.verticalAlign, width: o.width, height: o.height, fontSize: o.fontSize }, cursor: r.cursor, attachedPos: l.position, attachedRot: l.rotation } });
        }, n.prototype.addLabelsOfSeries = function(t) {
          var e = this;
          this._chartViewList.push(t);
          var i = t.__model, r = i.get("labelLayout");
          (yt(r) || oe(r).length) && t.group.traverse(function(a) {
            if (a.ignore) return true;
            var o = a.getTextContent(), s = Nt(a);
            o && !o.disableLabelLayout && e._addLabel(s.dataIndex, s.dataType, i, o, r);
          });
        }, n.prototype.updateLayoutConfig = function(t) {
          var e = t.getWidth(), i = t.getHeight();
          function r(m, _) {
            return function() {
              fj(m, _);
            };
          }
          for (var a = 0; a < this._labelList.length; a++) {
            var o = this._labelList[a], s = o.label, l = s.__hostTarget, u = o.defaultAttr, h = void 0;
            yt(o.layoutOption) ? h = o.layoutOption(qbt(o, l)) : h = o.layoutOption, h = h || {}, o.computedLayoutOption = h;
            var c = Math.PI / 180;
            l && l.setTextConfig({ local: false, position: h.x != null || h.y != null ? null : u.attachedPos, rotation: h.rotate != null ? h.rotate * c : u.attachedRot, offset: [h.dx || 0, h.dy || 0] });
            var f = false;
            if (h.x != null ? (s.x = st(h.x, e), s.setStyle("x", 0), f = true) : (s.x = u.x, s.setStyle("x", u.style.x)), h.y != null ? (s.y = st(h.y, i), s.setStyle("y", 0), f = true) : (s.y = u.y, s.setStyle("y", u.style.y)), h.labelLinePoints) {
              var g = l.getTextGuideLine();
              g && (g.setShape({ points: h.labelLinePoints }), f = false);
            }
            var d = DM(s);
            d.needsUpdateLabelLine = f, s.rotation = h.rotate != null ? h.rotate * c : u.rotation, s.scaleX = u.scaleX, s.scaleY = u.scaleY;
            for (var A = 0; A < yj.length; A++) {
              var p = yj[A];
              s.setStyle(p, h[p] != null ? h[p] : u.style[p]);
            }
            if (h.draggable) {
              if (s.draggable = true, s.cursor = "move", l) {
                var v = o.seriesModel;
                if (o.dataIndex != null) {
                  var y = o.seriesModel.getData(o.dataType);
                  v = y.getItemModel(o.dataIndex);
                }
                s.on("drag", r(l, v.getModel("labelLine")));
              }
            } else s.off("drag"), s.cursor = u.cursor;
          }
        }, n.prototype.layout = function(t) {
          var e = t.getWidth(), i = t.getHeight(), r = dj(this._labelList), a = Fe(r, function(l) {
            return l.layoutOption.moveOverlap === "shiftX";
          }), o = Fe(r, function(l) {
            return l.layoutOption.moveOverlap === "shiftY";
          });
          Vbt(a, 0, e), pj(o, 0, i);
          var s = Fe(r, function(l) {
            return l.layoutOption.hideOverlap;
          });
          vj(s);
        }, n.prototype.processLabelsOverall = function() {
          var t = this;
          D(this._chartViewList, function(e) {
            var i = e.__model, r = e.ignoreLabelLineUpdate, a = i.isAnimationEnabled();
            e.group.traverse(function(o) {
              if (o.ignore && !o.forceLabelAnimation) return true;
              var s = !r, l = o.getTextContent();
              !s && l && (s = DM(l).needsUpdateLabelLine), s && t._updateLabelLine(o, i), a && t._animateLabels(o, i);
            });
          });
        }, n.prototype._updateLabelLine = function(t, e) {
          var i = t.getTextContent(), r = Nt(t), a = r.dataIndex;
          if (i && a != null) {
            var o = e.getData(r.dataType), s = o.getItemModel(a), l = {}, u = o.getItemVisual(a, "style");
            if (u) {
              var h = o.getVisual("drawType");
              l.stroke = u[h];
            }
            var c = s.getModel("labelLine");
            BM(t, MM(s), l), fj(t, c);
          }
        }, n.prototype._animateLabels = function(t, e) {
          var i = t.getTextContent(), r = t.getTextGuideLine();
          if (i && (t.forceLabelAnimation || !i.ignore && !i.invisible && !t.disableLabelAnimation && !Vg(t))) {
            var a = DM(i), o = a.oldLayout, s = Nt(t), l = s.dataIndex, u = { x: i.x, y: i.y, rotation: i.rotation }, h = e.getData(s.dataType);
            if (o) {
              i.attr(o);
              var f = t.prevStates;
              f && ($t(f, "select") >= 0 && i.attr(a.oldLayoutSelect), $t(f, "emphasis") >= 0 && i.attr(a.oldLayoutEmphasis)), Ee(i, u, e, l);
            } else if (i.attr(u), !Hg(i).valueAnimation) {
              var c = kt(i.style.opacity, 1);
              i.style.opacity = 0, on(i, { style: { opacity: c } }, e, l);
            }
            if (a.oldLayout = u, i.states.select) {
              var g = a.oldLayoutSelect = {};
              zE(g, u, GE), zE(g, i.states.select, GE);
            }
            if (i.states.emphasis) {
              var d = a.oldLayoutEmphasis = {};
              zE(d, u, GE), zE(d, i.states.emphasis, GE);
            }
            V8(i, l, h, e, e);
          }
          if (r && !r.ignore && !r.invisible) {
            var a = Hbt(r), o = a.oldLayout, A = { points: r.shape.points };
            o ? (r.attr({ shape: o }), Ee(r, { shape: A }, e)) : (r.setShape(A), r.style.strokePercent = 0, on(r, { style: { strokePercent: 1 } }, e)), a.oldLayout = A;
          }
        }, n;
      }(), RM = ce();
      function Wbt(n) {
        n.registerUpdateLifecycle("series:beforeupdate", function(t, e, i) {
          var r = RM(e).labelManager;
          r || (r = RM(e).labelManager = new Ybt()), r.clearLabels();
        }), n.registerUpdateLifecycle("series:layoutlabels", function(t, e, i) {
          var r = RM(e).labelManager;
          i.updatedSeries.forEach(function(a) {
            r.addLabelsOfSeries(e.getViewOfSeriesModel(a));
          }), r.updateLayoutConfig(e), r.layout(e), r.processLabelsOverall();
        });
      }
      var LM = Math.sin, PM = Math.cos, mj = Math.PI, uc = Math.PI * 2, Xbt = 180 / mj, _j = function() {
        function n() {
        }
        return n.prototype.reset = function(t) {
          this._start = true, this._d = [], this._str = "", this._p = Math.pow(10, t || 4);
        }, n.prototype.moveTo = function(t, e) {
          this._add("M", t, e);
        }, n.prototype.lineTo = function(t, e) {
          this._add("L", t, e);
        }, n.prototype.bezierCurveTo = function(t, e, i, r, a, o) {
          this._add("C", t, e, i, r, a, o);
        }, n.prototype.quadraticCurveTo = function(t, e, i, r) {
          this._add("Q", t, e, i, r);
        }, n.prototype.arc = function(t, e, i, r, a, o) {
          this.ellipse(t, e, i, i, 0, r, a, o);
        }, n.prototype.ellipse = function(t, e, i, r, a, o, s, l) {
          var u = s - o, h = !l, c = Math.abs(u), f = iu(c - uc) || (h ? u >= uc : -u >= uc), g = u > 0 ? u % uc : u % uc + uc, d = false;
          f ? d = true : iu(c) ? d = false : d = g >= mj == !!h;
          var A = t + i * PM(o), p = e + r * LM(o);
          this._start && this._add("M", A, p);
          var v = Math.round(a * Xbt);
          if (f) {
            var y = 1 / this._p, m = (h ? 1 : -1) * (uc - y);
            this._add("A", i, r, v, 1, +h, t + i * PM(o + m), e + r * LM(o + m)), y > 0.01 && this._add("A", i, r, v, 0, +h, A, p);
          } else {
            var _ = t + i * PM(s), I = e + r * LM(s);
            this._add("A", i, r, v, +d, +h, _, I);
          }
        }, n.prototype.rect = function(t, e, i, r) {
          this._add("M", t, e), this._add("l", i, 0), this._add("l", 0, r), this._add("l", -i, 0), this._add("Z");
        }, n.prototype.closePath = function() {
          this._d.length > 0 && this._add("Z");
        }, n.prototype._add = function(t, e, i, r, a, o, s, l, u) {
          for (var h = [], c = this._p, f = 1; f < arguments.length; f++) {
            var g = arguments[f];
            if (isNaN(g)) {
              this._invalid = true;
              return;
            }
            h.push(Math.round(g * c) / c);
          }
          this._d.push(t + h.join(" ")), this._start = t === "Z";
        }, n.prototype.generateStr = function() {
          this._str = this._invalid ? "" : this._d.join(""), this._d = [];
        }, n.prototype.getStr = function() {
          return this._str;
        }, n;
      }(), NM = "none", $bt = Math.round;
      function Zbt(n) {
        var t = n.fill;
        return t != null && t !== NM;
      }
      function Kbt(n) {
        var t = n.stroke;
        return t != null && t !== NM;
      }
      var FM = ["lineCap", "miterLimit", "lineJoin"], Jbt = K(FM, function(n) {
        return "stroke-" + n.toLowerCase();
      });
      function t2t(n, t, e, i) {
        var r = t.opacity == null ? 1 : t.opacity;
        if (e instanceof gi) {
          n("opacity", r);
          return;
        }
        if (Zbt(t)) {
          var a = Hp(t.fill);
          n("fill", a.color);
          var o = t.fillOpacity != null ? t.fillOpacity * a.opacity * r : a.opacity * r;
          o < 1 && n("fill-opacity", o);
        } else n("fill", NM);
        if (Kbt(t)) {
          var s = Hp(t.stroke);
          n("stroke", s.color);
          var l = t.strokeNoScale ? e.getLineScale() : 1, u = l ? (t.lineWidth || 0) / l : 0, h = t.strokeOpacity != null ? t.strokeOpacity * s.opacity * r : s.opacity * r, c = t.strokeFirst;
          if (u !== 1 && n("stroke-width", u), c && n("paint-order", c ? "stroke" : "fill"), h < 1 && n("stroke-opacity", h), t.lineDash) {
            var f = XB(e), g = f[0], d = f[1];
            g && (d = $bt(d || 0), n("stroke-dasharray", g.join(",")), (d || i) && n("stroke-dashoffset", d));
          }
          for (var A = 0; A < FM.length; A++) {
            var p = FM[A];
            if (t[p] !== C1[p]) {
              var v = t[p] || C1[p];
              v && n(Jbt[A], v);
            }
          }
        }
      }
      var Ej = "http://www.w3.org/2000/svg", Ij = "http://www.w3.org/1999/xlink", e2t = "http://www.w3.org/2000/xmlns/", n2t = "http://www.w3.org/XML/1998/namespace", xj = "ecmeta_";
      function wj(n) {
        return document.createElementNS(Ej, n);
      }
      function ei(n, t, e, i, r) {
        return { tag: n, attrs: e || {}, children: i, text: r, key: t };
      }
      function i2t(n, t) {
        var e = [];
        if (t) for (var i in t) {
          var r = t[i], a = i;
          r !== false && (r !== true && r != null && (a += '="' + r + '"'), e.push(a));
        }
        return "<" + n + " " + e.join(" ") + ">";
      }
      function r2t(n) {
        return "</" + n + ">";
      }
      function kM(n, t) {
        t = t || {};
        var e = t.newline ? `
` : "";
        function i(r) {
          var a = r.children, o = r.tag, s = r.attrs, l = r.text;
          return i2t(o, s) + (o !== "style" ? Er(l) : l || "") + (a ? "" + e + K(a, function(u) {
            return i(u);
          }).join(e) + e : "") + r2t(o);
        }
        return i(n);
      }
      function a2t(n, t, e) {
        e = e || {};
        var i = e.newline ? `
` : "", r = " {" + i, a = i + "}", o = K(oe(n), function(l) {
          return l + r + K(oe(n[l]), function(u) {
            return u + ":" + n[l][u] + ";";
          }).join(i) + a;
        }).join(i), s = K(oe(t), function(l) {
          return "@keyframes " + l + r + K(oe(t[l]), function(u) {
            return u + r + K(oe(t[l][u]), function(h) {
              var c = t[l][u][h];
              return h === "d" && (c = 'path("' + c + '")'), h + ":" + c + ";";
            }).join(i) + a;
          }).join(i) + a;
        }).join(i);
        return !o && !s ? "" : ["<![CDATA[", o, s, "]]>"].join(i);
      }
      function OM(n) {
        return { zrId: n, shadowCache: {}, patternCache: {}, gradientCache: {}, clipPathCache: {}, defs: {}, cssNodes: {}, cssAnims: {}, cssStyleCache: {}, cssAnimIdx: 0, shadowIdx: 0, gradientIdx: 0, patternIdx: 0, clipPathIdx: 0 };
      }
      function Cj(n, t, e, i) {
        return ei("svg", "root", { width: n, height: t, xmlns: Ej, "xmlns:xlink": Ij, version: "1.1", baseProfile: "full", viewBox: i ? "0 0 " + n + " " + t : false }, e);
      }
      var o2t = 0;
      function Sj() {
        return o2t++;
      }
      var bj = { cubicIn: "0.32,0,0.67,0", cubicOut: "0.33,1,0.68,1", cubicInOut: "0.65,0,0.35,1", quadraticIn: "0.11,0,0.5,0", quadraticOut: "0.5,1,0.89,1", quadraticInOut: "0.45,0,0.55,1", quarticIn: "0.5,0,0.75,0", quarticOut: "0.25,1,0.5,1", quarticInOut: "0.76,0,0.24,1", quinticIn: "0.64,0,0.78,0", quinticOut: "0.22,1,0.36,1", quinticInOut: "0.83,0,0.17,1", sinusoidalIn: "0.12,0,0.39,0", sinusoidalOut: "0.61,1,0.88,1", sinusoidalInOut: "0.37,0,0.63,1", exponentialIn: "0.7,0,0.84,0", exponentialOut: "0.16,1,0.3,1", exponentialInOut: "0.87,0,0.13,1", circularIn: "0.55,0,1,0.45", circularOut: "0,0.55,0.45,1", circularInOut: "0.85,0,0.15,1" }, hc = "transform-origin";
      function s2t(n, t, e) {
        var i = X({}, n.shape);
        X(i, t), n.buildPath(e, i);
        var r = new _j();
        return r.reset(k5(n)), e.rebuildPath(r, 1), r.generateStr(), r.getStr();
      }
      function l2t(n, t) {
        var e = t.originX, i = t.originY;
        (e || i) && (n[hc] = e + "px " + i + "px");
      }
      var u2t = { fill: "fill", opacity: "opacity", lineWidth: "stroke-width", lineDashOffset: "stroke-dashoffset" };
      function Tj(n, t) {
        var e = t.zrId + "-ani-" + t.cssAnimIdx++;
        return t.cssAnims[e] = n, e;
      }
      function h2t(n, t, e) {
        var i = n.shape.paths, r = {}, a, o;
        if (D(i, function(l) {
          var u = OM(e.zrId);
          u.animation = true, UE(l, {}, u, true);
          var h = u.cssAnims, c = u.cssNodes, f = oe(h), g = f.length;
          if (g) {
            o = f[g - 1];
            var d = h[o];
            for (var A in d) {
              var p = d[A];
              r[A] = r[A] || { d: "" }, r[A].d += p.d || "";
            }
            for (var v in c) {
              var y = c[v].animation;
              y.indexOf(o) >= 0 && (a = y);
            }
          }
        }), !!a) {
          t.d = false;
          var s = Tj(r, e);
          return a.replace(o, s);
        }
      }
      function Bj(n) {
        return ht(n) ? bj[n] ? "cubic-bezier(" + bj[n] + ")" : G2(n) ? n : "" : "";
      }
      function UE(n, t, e, i) {
        var r = n.animators, a = r.length, o = [];
        if (n instanceof iB) {
          var s = h2t(n, t, e);
          if (s) o.push(s);
          else if (!a) return;
        } else if (!a) return;
        for (var l = {}, u = 0; u < a; u++) {
          var h = r[u], c = [h.getMaxTime() / 1e3 + "s"], f = Bj(h.getClip().easing), g = h.getDelay();
          f ? c.push(f) : c.push("linear"), g && c.push(g / 1e3 + "s"), h.getLoop() && c.push("infinite");
          var d = c.join(" ");
          l[d] = l[d] || [d, []], l[d][1].push(h);
        }
        function A(y) {
          var m = y[1], _ = m.length, I = {}, E = {}, x = {}, w = "animation-timing-function";
          function C(nt, gt, q) {
            for (var W = nt.getTracks(), it = nt.getMaxTime(), Ot = 0; Ot < W.length; Ot++) {
              var pt = W[Ot];
              if (pt.needsAnimate()) {
                var St = pt.keyframes, bt = pt.propName;
                if (q && (bt = q(bt)), bt) for (var xe = 0; xe < St.length; xe++) {
                  var sn = St[xe], Ie = Math.round(sn.time / it * 100) + "%", yn = Bj(sn.easing), ln = sn.rawValue;
                  (ht(ln) || ye(ln)) && (gt[Ie] = gt[Ie] || {}, gt[Ie][bt] = sn.rawValue, yn && (gt[Ie][w] = yn));
                }
              }
            }
          }
          for (var S = 0; S < _; S++) {
            var b = m[S], T = b.targetName;
            T ? T === "shape" && C(b, E) : !i && C(b, I);
          }
          for (var B in I) {
            var R = {};
            $5(R, n), X(R, I[B]);
            var M = O5(R), L = I[B][w];
            x[B] = M ? { transform: M } : {}, l2t(x[B], R), L && (x[B][w] = L);
          }
          var N, F = true;
          for (var B in E) {
            x[B] = x[B] || {};
            var k = !N, L = E[B][w];
            k && (N = new $o());
            var O = N.len();
            N.reset(), x[B].d = s2t(n, E[B], N);
            var Q = N.len();
            if (!k && O !== Q) {
              F = false;
              break;
            }
            L && (x[B][w] = L);
          }
          if (!F) for (var B in x) delete x[B].d;
          if (!i) for (var S = 0; S < _; S++) {
            var b = m[S], T = b.targetName;
            T === "style" && C(b, x, function(W) {
              return u2t[W];
            });
          }
          for (var j = oe(x), Y = true, G, S = 1; S < j.length; S++) {
            var $ = j[S - 1], J = j[S];
            if (x[$][hc] !== x[J][hc]) {
              Y = false;
              break;
            }
            G = x[$][hc];
          }
          if (Y && G) {
            for (var B in x) x[B][hc] && delete x[B][hc];
            t[hc] = G;
          }
          if (Fe(j, function(nt) {
            return oe(x[nt]).length > 0;
          }).length) {
            var et = Tj(x, e);
            return et + " " + y[0] + " both";
          }
        }
        for (var p in l) {
          var s = A(l[p]);
          s && o.push(s);
        }
        if (o.length) {
          var v = e.zrId + "-cls-" + Sj();
          e.cssNodes["." + v] = { animation: o.join(",") }, t.class = v;
        }
      }
      function c2t(n, t, e) {
        if (!n.ignore) if (n.isSilent()) {
          var i = { "pointer-events": "none" };
          Mj(i, t, e);
        } else {
          var r = n.states.emphasis && n.states.emphasis.style ? n.states.emphasis.style : {}, a = r.fill;
          if (!a) {
            var o = n.style && n.style.fill, s = n.states.select && n.states.select.style && n.states.select.style.fill, l = n.currentStates.indexOf("select") >= 0 && s || o;
            l && (a = W2(l));
          }
          var u = r.lineWidth;
          if (u) {
            var h = !r.strokeNoScale && n.transform ? n.transform[0] : 1;
            u = u / h;
          }
          var i = { cursor: "pointer" };
          a && (i.fill = a), r.stroke && (i.stroke = r.stroke), u && (i["stroke-width"] = u), Mj(i, t, e);
        }
      }
      function Mj(n, t, e, i) {
        var r = JSON.stringify(n), a = e.cssStyleCache[r];
        a || (a = e.zrId + "-cls-" + Sj(), e.cssStyleCache[r] = a, e.cssNodes["." + a + ":hover"] = n), t.class = t.class ? t.class + " " + a : a;
      }
      var Yv = Math.round;
      function Dj(n) {
        return n && ht(n.src);
      }
      function Rj(n) {
        return n && yt(n.toDataURL);
      }
      function QM(n, t, e, i) {
        t2t(function(r, a) {
          var o = r === "fill" || r === "stroke";
          o && F5(a) ? Oj(t, n, r, i) : o && $2(a) ? Qj(e, n, r, i) : o && a === "none" ? n[r] = "transparent" : n[r] = a;
        }, t, e, false), y2t(e, n, i);
      }
      function zM(n, t) {
        var e = oEt(t);
        e && (e.each(function(i, r) {
          i != null && (n[(xj + r).toLowerCase()] = i + "");
        }), t.isSilent() && (n[xj + "silent"] = "true"));
      }
      function Lj(n) {
        return iu(n[0] - 1) && iu(n[1]) && iu(n[2]) && iu(n[3] - 1);
      }
      function f2t(n) {
        return iu(n[4]) && iu(n[5]);
      }
      function GM(n, t, e) {
        if (t && !(f2t(t) && Lj(t))) {
          var i = 1e4;
          n.transform = Lj(t) ? "translate(" + Yv(t[4] * i) / i + " " + Yv(t[5] * i) / i + ")" : B1t(t);
        }
      }
      function Pj(n, t, e) {
        for (var i = n.points, r = [], a = 0; a < i.length; a++) r.push(Yv(i[a][0] * e) / e), r.push(Yv(i[a][1] * e) / e);
        t.points = r.join(" ");
      }
      function Nj(n) {
        return !n.smooth;
      }
      function g2t(n) {
        var t = K(n, function(e) {
          return typeof e == "string" ? [e, e] : e;
        });
        return function(e, i, r) {
          for (var a = 0; a < t.length; a++) {
            var o = t[a], s = e[o[0]];
            s != null && (i[o[1]] = Yv(s * r) / r);
          }
        };
      }
      var d2t = { circle: [g2t(["cx", "cy", "r"])], polyline: [Pj, Nj], polygon: [Pj, Nj] };
      function A2t(n) {
        for (var t = n.animators, e = 0; e < t.length; e++) if (t[e].targetName === "shape") return true;
        return false;
      }
      function Fj(n, t) {
        var e = n.style, i = n.shape, r = d2t[n.type], a = {}, o = t.animation, s = "path", l = n.style.strokePercent, u = t.compress && k5(n) || 4;
        if (r && !t.willUpdate && !(r[1] && !r[1](i)) && !(o && A2t(n)) && !(l < 1)) {
          s = n.type;
          var h = Math.pow(10, u);
          r[0](i, a, h);
        } else {
          var c = !n.path || n.shapeChanged();
          n.path || n.createPathProxy();
          var f = n.path;
          c && (f.beginPath(), n.buildPath(f, n.shape), n.pathUpdated());
          var g = f.getVersion(), d = n, A = d.__svgPathBuilder;
          (d.__svgPathVersion !== g || !A || l !== d.__svgPathStrokePercent) && (A || (A = d.__svgPathBuilder = new _j()), A.reset(u), f.rebuildPath(A, l), A.generateStr(), d.__svgPathVersion = g, d.__svgPathStrokePercent = l), a.d = A.getStr();
        }
        return GM(a, n.transform), QM(a, e, n, t), zM(a, n), t.animation && UE(n, a, t), t.emphasis && c2t(n, a, t), ei(s, n.id + "", a);
      }
      function p2t(n, t) {
        var e = n.style, i = e.image;
        if (i && !ht(i) && (Dj(i) ? i = i.src : Rj(i) && (i = i.toDataURL())), !!i) {
          var r = e.x || 0, a = e.y || 0, o = e.width, s = e.height, l = { href: i, width: o, height: s };
          return r && (l.x = r), a && (l.y = a), GM(l, n.transform), QM(l, e, n, t), zM(l, n), t.animation && UE(n, l, t), ei("image", n.id + "", l);
        }
      }
      function v2t(n, t) {
        var e = n.style, i = e.text;
        if (i != null && (i += ""), !(!i || isNaN(e.x) || isNaN(e.y))) {
          var r = e.font || Wl, a = e.x || 0, o = D1t(e.y || 0, g1(r), e.textBaseline), s = M1t[e.textAlign] || e.textAlign, l = { "dominant-baseline": "central", "text-anchor": s };
          if (j4(e)) {
            var u = "", h = e.fontStyle, c = U4(e.fontSize);
            if (!parseFloat(c)) return;
            var f = e.fontFamily || WG, g = e.fontWeight;
            u += "font-size:" + c + ";font-family:" + f + ";", h && h !== "normal" && (u += "font-style:" + h + ";"), g && g !== "normal" && (u += "font-weight:" + g + ";"), l.style = u;
          } else l.style = "font: " + r;
          return i.match(/\s/) && (l["xml:space"] = "preserve"), a && (l.x = a), o && (l.y = o), GM(l, n.transform), QM(l, e, n, t), zM(l, n), t.animation && UE(n, l, t), ei("text", n.id + "", l, void 0, i);
        }
      }
      function kj(n, t) {
        if (n instanceof ne) return Fj(n, t);
        if (n instanceof gi) return p2t(n, t);
        if (n instanceof Fg) return v2t(n, t);
      }
      function y2t(n, t, e) {
        var i = n.style;
        if (R1t(i)) {
          var r = L1t(n), a = e.shadowCache, o = a[r];
          if (!o) {
            var s = n.getGlobalScale(), l = s[0], u = s[1];
            if (!l || !u) return;
            var h = i.shadowOffsetX || 0, c = i.shadowOffsetY || 0, f = i.shadowBlur, g = Hp(i.shadowColor), d = g.opacity, A = g.color, p = f / 2 / l, v = f / 2 / u, y = p + " " + v;
            o = e.zrId + "-s" + e.shadowIdx++, e.defs[o] = ei("filter", o, { id: o, x: "-100%", y: "-100%", width: "300%", height: "300%" }, [ei("feDropShadow", "", { dx: h / l, dy: c / u, stdDeviation: y, "flood-color": A, "flood-opacity": d })]), a[r] = o;
          }
          t.filter = a1(o);
        }
      }
      function Oj(n, t, e, i) {
        var r = n[e], a, o = { gradientUnits: r.global ? "userSpaceOnUse" : "objectBoundingBox" };
        if (P5(r)) a = "linearGradient", o.x1 = r.x, o.y1 = r.y, o.x2 = r.x2, o.y2 = r.y2;
        else if (N5(r)) a = "radialGradient", o.cx = kt(r.x, 0.5), o.cy = kt(r.y, 0.5), o.r = kt(r.r, 0.5);
        else {
          Ya("Illegal gradient type.");
          return;
        }
        for (var s = r.colorStops, l = [], u = 0, h = s.length; u < h; ++u) {
          var c = X2(s[u].offset) * 100 + "%", f = s[u].color, g = Hp(f), d = g.color, A = g.opacity, p = { offset: c };
          p["stop-color"] = d, A < 1 && (p["stop-opacity"] = A), l.push(ei("stop", u + "", p));
        }
        var v = ei(a, "", o, l), y = kM(v), m = i.gradientCache, _ = m[y];
        _ || (_ = i.zrId + "-g" + i.gradientIdx++, m[y] = _, o.id = _, i.defs[_] = ei(a, _, o, l)), t[e] = a1(_);
      }
      function Qj(n, t, e, i) {
        var r = n.style[e], a = n.getBoundingRect(), o = {}, s = r.repeat, l = s === "no-repeat", u = s === "repeat-x", h = s === "repeat-y", c;
        if (L5(r)) {
          var f = r.imageWidth, g = r.imageHeight, d = void 0, A = r.image;
          if (ht(A) ? d = A : Dj(A) ? d = A.src : Rj(A) && (d = A.toDataURL()), typeof Image == "undefined") {
            var p = "Image width/height must been given explictly in svg-ssr renderer.";
            It(f, p), It(g, p);
          } else if (f == null || g == null) {
            var v = function(S, b) {
              if (S) {
                var T = S.elm, B = f || b.width, R = g || b.height;
                S.tag === "pattern" && (u ? (R = 1, B /= a.width) : h && (B = 1, R /= a.height)), S.attrs.width = B, S.attrs.height = R, T && (T.setAttribute("width", B), T.setAttribute("height", R));
              }
            }, y = ST(d, null, n, function(S) {
              l || v(E, S), v(c, S);
            });
            y && y.width && y.height && (f = f || y.width, g = g || y.height);
          }
          c = ei("image", "img", { href: d, width: f, height: g }), o.width = f, o.height = g;
        } else r.svgElement && (c = Ct(r.svgElement), o.width = r.svgWidth, o.height = r.svgHeight);
        if (c) {
          var m, _;
          l ? m = _ = 1 : u ? (_ = 1, m = o.width / a.width) : h ? (m = 1, _ = o.height / a.height) : o.patternUnits = "userSpaceOnUse", m != null && !isNaN(m) && (o.width = m), _ != null && !isNaN(_) && (o.height = _);
          var I = O5(r);
          I && (o.patternTransform = I);
          var E = ei("pattern", "", o, [c]), x = kM(E), w = i.patternCache, C = w[x];
          C || (C = i.zrId + "-p" + i.patternIdx++, w[x] = C, o.id = C, E = i.defs[C] = ei("pattern", C, o, [c])), t[e] = a1(C);
        }
      }
      function m2t(n, t, e) {
        var i = e.clipPathCache, r = e.defs, a = i[n.id];
        if (!a) {
          a = e.zrId + "-c" + e.clipPathIdx++;
          var o = { id: a };
          i[n.id] = a, r[a] = ei("clipPath", a, o, [Fj(n, e)]);
        }
        t["clip-path"] = a1(a);
      }
      function zj(n) {
        return document.createTextNode(n);
      }
      function cc(n, t, e) {
        n.insertBefore(t, e);
      }
      function Gj(n, t) {
        n.removeChild(t);
      }
      function Uj(n, t) {
        n.appendChild(t);
      }
      function Vj(n) {
        return n.parentNode;
      }
      function jj(n) {
        return n.nextSibling;
      }
      function UM(n, t) {
        n.textContent = t;
      }
      var qj = 58, _2t = 120, E2t = ei("", "");
      function VM(n) {
        return n === void 0;
      }
      function as(n) {
        return n !== void 0;
      }
      function I2t(n, t, e) {
        for (var i = {}, r = t; r <= e; ++r) {
          var a = n[r].key;
          a !== void 0 && (i[a] != null, i[a] = r);
        }
        return i;
      }
      function Wv(n, t) {
        var e = n.key === t.key, i = n.tag === t.tag;
        return i && e;
      }
      function Xv(n) {
        var t, e = n.children, i = n.tag;
        if (as(i)) {
          var r = n.elm = wj(i);
          if (jM(E2t, n), Z(e)) for (t = 0; t < e.length; ++t) {
            var a = e[t];
            a != null && Uj(r, Xv(a));
          }
          else as(n.text) && !Et(n.text) && Uj(r, zj(n.text));
        } else n.elm = zj(n.text);
        return n.elm;
      }
      function Hj(n, t, e, i, r) {
        for (; i <= r; ++i) {
          var a = e[i];
          a != null && cc(n, Xv(a), t);
        }
      }
      function VE(n, t, e, i) {
        for (; e <= i; ++e) {
          var r = t[e];
          if (r != null) if (as(r.tag)) {
            var a = Vj(r.elm);
            Gj(a, r.elm);
          } else Gj(n, r.elm);
        }
      }
      function jM(n, t) {
        var e, i = t.elm, r = n && n.attrs || {}, a = t.attrs || {};
        if (r !== a) {
          for (e in a) {
            var o = a[e], s = r[e];
            s !== o && (o === true ? i.setAttribute(e, "") : o === false ? i.removeAttribute(e) : e === "style" ? i.style.cssText = o : e.charCodeAt(0) !== _2t ? i.setAttribute(e, o) : e === "xmlns:xlink" || e === "xmlns" ? i.setAttributeNS(e2t, e, o) : e.charCodeAt(3) === qj ? i.setAttributeNS(n2t, e, o) : e.charCodeAt(5) === qj ? i.setAttributeNS(Ij, e, o) : i.setAttribute(e, o));
          }
          for (e in r) e in a || i.removeAttribute(e);
        }
      }
      function x2t(n, t, e) {
        for (var i = 0, r = 0, a = t.length - 1, o = t[0], s = t[a], l = e.length - 1, u = e[0], h = e[l], c, f, g, d; i <= a && r <= l; ) o == null ? o = t[++i] : s == null ? s = t[--a] : u == null ? u = e[++r] : h == null ? h = e[--l] : Wv(o, u) ? (Ad(o, u), o = t[++i], u = e[++r]) : Wv(s, h) ? (Ad(s, h), s = t[--a], h = e[--l]) : Wv(o, h) ? (Ad(o, h), cc(n, o.elm, jj(s.elm)), o = t[++i], h = e[--l]) : Wv(s, u) ? (Ad(s, u), cc(n, s.elm, o.elm), s = t[--a], u = e[++r]) : (VM(c) && (c = I2t(t, i, a)), f = c[u.key], VM(f) ? cc(n, Xv(u), o.elm) : (g = t[f], g.tag !== u.tag ? cc(n, Xv(u), o.elm) : (Ad(g, u), t[f] = void 0, cc(n, g.elm, o.elm))), u = e[++r]);
        (i <= a || r <= l) && (i > a ? (d = e[l + 1] == null ? null : e[l + 1].elm, Hj(n, d, e, r, l)) : VE(n, t, i, a));
      }
      function Ad(n, t) {
        var e = t.elm = n.elm, i = n.children, r = t.children;
        n !== t && (jM(n, t), VM(t.text) ? as(i) && as(r) ? i !== r && x2t(e, i, r) : as(r) ? (as(n.text) && UM(e, ""), Hj(e, null, r, 0, r.length - 1)) : as(i) ? VE(e, i, 0, i.length - 1) : as(n.text) && UM(e, "") : n.text !== t.text && (as(i) && VE(e, i, 0, i.length - 1), UM(e, t.text)));
      }
      function w2t(n, t) {
        if (Wv(n, t)) Ad(n, t);
        else {
          var e = n.elm, i = Vj(e);
          Xv(t), i !== null && (cc(i, t.elm, jj(e)), VE(i, [n], 0, 0));
        }
        return t;
      }
      var C2t = 0, S2t = function() {
        function n(t, e, i) {
          if (this.type = "svg", this.refreshHover = Yj("refreshHover"), this.configLayer = Yj("configLayer"), this.storage = e, this._opts = i = X({}, i), this.root = t, this._id = "zr" + C2t++, this._oldVNode = Cj(i.width, i.height), t && !i.ssr) {
            var r = this._viewport = document.createElement("div");
            r.style.cssText = "position:relative;overflow:hidden";
            var a = this._svgDom = this._oldVNode.elm = wj("svg");
            jM(null, this._oldVNode), r.appendChild(a), t.appendChild(r);
          }
          this.resize(i.width, i.height);
        }
        return n.prototype.getType = function() {
          return this.type;
        }, n.prototype.getViewportRoot = function() {
          return this._viewport;
        }, n.prototype.getViewportRootOffset = function() {
          var t = this.getViewportRoot();
          if (t) return { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 };
        }, n.prototype.getSvgDom = function() {
          return this._svgDom;
        }, n.prototype.refresh = function() {
          if (this.root) {
            var t = this.renderToVNode({ willUpdate: true });
            t.attrs.style = "position:absolute;left:0;top:0;user-select:none", w2t(this._oldVNode, t), this._oldVNode = t;
          }
        }, n.prototype.renderOneToVNode = function(t) {
          return kj(t, OM(this._id));
        }, n.prototype.renderToVNode = function(t) {
          t = t || {};
          var e = this.storage.getDisplayList(true), i = this._width, r = this._height, a = OM(this._id);
          a.animation = t.animation, a.willUpdate = t.willUpdate, a.compress = t.compress, a.emphasis = t.emphasis;
          var o = [], s = this._bgVNode = b2t(i, r, this._backgroundColor, a);
          s && o.push(s);
          var l = t.compress ? null : this._mainVNode = ei("g", "main", {}, []);
          this._paintList(e, a, l ? l.children : o), l && o.push(l);
          var u = K(oe(a.defs), function(f) {
            return a.defs[f];
          });
          if (u.length && o.push(ei("defs", "defs", {}, u)), t.animation) {
            var h = a2t(a.cssNodes, a.cssAnims, { newline: true });
            if (h) {
              var c = ei("style", "stl", {}, [], h);
              o.push(c);
            }
          }
          return Cj(i, r, o, t.useViewBox);
        }, n.prototype.renderToString = function(t) {
          return t = t || {}, kM(this.renderToVNode({ animation: kt(t.cssAnimation, true), emphasis: kt(t.cssEmphasis, true), willUpdate: false, compress: true, useViewBox: kt(t.useViewBox, true) }), { newline: true });
        }, n.prototype.setBackgroundColor = function(t) {
          this._backgroundColor = t;
        }, n.prototype.getSvgRoot = function() {
          return this._mainVNode && this._mainVNode.elm;
        }, n.prototype._paintList = function(t, e, i) {
          for (var r = t.length, a = [], o = 0, s, l, u = 0, h = 0; h < r; h++) {
            var c = t[h];
            if (!c.invisible) {
              var f = c.__clipPaths, g = f && f.length || 0, d = l && l.length || 0, A = void 0;
              for (A = Math.max(g - 1, d - 1); A >= 0 && !(f && l && f[A] === l[A]); A--) ;
              for (var p = d - 1; p > A; p--) o--, s = a[o - 1];
              for (var v = A + 1; v < g; v++) {
                var y = {};
                m2t(f[v], y, e);
                var m = ei("g", "clip-g-" + u++, y, []);
                (s ? s.children : i).push(m), a[o++] = m, s = m;
              }
              l = f;
              var _ = kj(c, e);
              _ && (s ? s.children : i).push(_);
            }
          }
        }, n.prototype.resize = function(t, e) {
          var i = this._opts, r = this.root, a = this._viewport;
          if (t != null && (i.width = t), e != null && (i.height = e), r && a && (a.style.display = "none", t = ld(r, 0, i), e = ld(r, 1, i), a.style.display = ""), this._width !== t || this._height !== e) {
            if (this._width = t, this._height = e, a) {
              var o = a.style;
              o.width = t + "px", o.height = e + "px";
            }
            if ($2(this._backgroundColor)) this.refresh();
            else {
              var s = this._svgDom;
              s && (s.setAttribute("width", t), s.setAttribute("height", e));
              var l = this._bgVNode && this._bgVNode.elm;
              l && (l.setAttribute("width", t), l.setAttribute("height", e));
            }
          }
        }, n.prototype.getWidth = function() {
          return this._width;
        }, n.prototype.getHeight = function() {
          return this._height;
        }, n.prototype.dispose = function() {
          this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
        }, n.prototype.clear = function() {
          this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
        }, n.prototype.toDataURL = function(t) {
          var e = this.renderToString(), i = "data:image/svg+xml;";
          return t ? (e = N1t(e), e && i + "base64," + e) : i + "charset=UTF-8," + encodeURIComponent(e);
        }, n;
      }();
      function Yj(n) {
        return function() {
          Ya('In SVG mode painter not support method "' + n + '"');
        };
      }
      function b2t(n, t, e, i) {
        var r;
        if (e && e !== "none") if (r = ei("rect", "bg", { width: n, height: t, x: "0", y: "0" }), F5(e)) Oj({ fill: e }, r.attrs, "fill", i);
        else if ($2(e)) Qj({ style: { fill: e }, dirty: bn, getBoundingRect: function() {
          return { width: n, height: t };
        } }, r.attrs, "fill", i);
        else {
          var a = Hp(e), o = a.color, s = a.opacity;
          r.attrs.fill = o, s < 1 && (r.attrs["fill-opacity"] = s);
        }
        return r;
      }
      function T2t(n) {
        n.registerPainter("svg", S2t);
      }
      function Wj(n, t, e) {
        var i = Xl.createCanvas(), r = t.getWidth(), a = t.getHeight(), o = i.style;
        return o && (o.position = "absolute", o.left = "0", o.top = "0", o.width = r + "px", o.height = a + "px", i.setAttribute("data-zr-dom-id", n)), i.width = r * e, i.height = a * e, i;
      }
      var qM = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this) || this;
          a.motionBlur = false, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = false, a.config = {}, a.incremental = false, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = true, a.__firstTimePaint = true, a.__used = false, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
          var o;
          r = r || f1, typeof e == "string" ? o = Wj(e, i, r) : Et(e) && (o = e, e = o.id), a.id = e, a.dom = o;
          var s = o.style;
          return s && (i5(o), o.onselectstart = function() {
            return false;
          }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), a.painter = i, a.dpr = r, a;
        }
        return t.prototype.getElementCount = function() {
          return this.__endIndex - this.__startIndex;
        }, t.prototype.afterBrush = function() {
          this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
        }, t.prototype.initContext = function() {
          this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
        }, t.prototype.setUnpainted = function() {
          this.__firstTimePaint = true;
        }, t.prototype.createBackBuffer = function() {
          var e = this.dpr;
          this.domBack = Wj("back-" + this.id, this.painter, e), this.ctxBack = this.domBack.getContext("2d"), e !== 1 && this.ctxBack.scale(e, e);
        }, t.prototype.createRepaintRects = function(e, i, r, a) {
          if (this.__firstTimePaint) return this.__firstTimePaint = false, null;
          var o = [], s = this.maxRepaintRectCount, l = false, u = new Wt(0, 0, 0, 0);
          function h(y) {
            if (!(!y.isFinite() || y.isZero())) if (o.length === 0) {
              var m = new Wt(0, 0, 0, 0);
              m.copy(y), o.push(m);
            } else {
              for (var _ = false, I = 1 / 0, E = 0, x = 0; x < o.length; ++x) {
                var w = o[x];
                if (w.intersect(y)) {
                  var C = new Wt(0, 0, 0, 0);
                  C.copy(w), C.union(y), o[x] = C, _ = true;
                  break;
                } else if (l) {
                  u.copy(y), u.union(w);
                  var S = y.width * y.height, b = w.width * w.height, T = u.width * u.height, B = T - S - b;
                  B < I && (I = B, E = x);
                }
              }
              if (l && (o[E].union(y), _ = true), !_) {
                var m = new Wt(0, 0, 0, 0);
                m.copy(y), o.push(m);
              }
              l || (l = o.length >= s);
            }
          }
          for (var c = this.__startIndex; c < this.__endIndex; ++c) {
            var f = e[c];
            if (f) {
              var g = f.shouldBePainted(r, a, true, true), d = f.__isRendered && (f.__dirty & jr || !g) ? f.getPrevPaintRect() : null;
              d && h(d);
              var A = g && (f.__dirty & jr || !f.__isRendered) ? f.getPaintRect() : null;
              A && h(A);
            }
          }
          for (var c = this.__prevStartIndex; c < this.__prevEndIndex; ++c) {
            var f = i[c], g = f && f.shouldBePainted(r, a, true, true);
            if (f && (!g || !f.__zr) && f.__isRendered) {
              var d = f.getPrevPaintRect();
              d && h(d);
            }
          }
          var p;
          do {
            p = false;
            for (var c = 0; c < o.length; ) {
              if (o[c].isZero()) {
                o.splice(c, 1);
                continue;
              }
              for (var v = c + 1; v < o.length; ) o[c].intersect(o[v]) ? (p = true, o[c].union(o[v]), o.splice(v, 1)) : v++;
              c++;
            }
          } while (p);
          return this._paintRects = o, o;
        }, t.prototype.debugGetPaintRects = function() {
          return (this._paintRects || []).slice();
        }, t.prototype.resize = function(e, i) {
          var r = this.dpr, a = this.dom, o = a.style, s = this.domBack;
          o && (o.width = e + "px", o.height = i + "px"), a.width = e * r, a.height = i * r, s && (s.width = e * r, s.height = i * r, r !== 1 && this.ctxBack.scale(r, r));
        }, t.prototype.clear = function(e, i, r) {
          var a = this.dom, o = this.ctx, s = a.width, l = a.height;
          i = i || this.clearColor;
          var u = this.motionBlur && !e, h = this.lastFrameAlpha, c = this.dpr, f = this;
          u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, s / c, l / c));
          var g = this.domBack;
          function d(A, p, v, y) {
            if (o.clearRect(A, p, v, y), i && i !== "transparent") {
              var m = void 0;
              if (O_(i)) {
                var _ = i.global || i.__width === v && i.__height === y;
                m = _ && i.__canvasGradient || WB(o, i, { x: 0, y: 0, width: v, height: y }), i.__canvasGradient = m, i.__width = v, i.__height = y;
              } else j_t(i) && (i.scaleX = i.scaleX || c, i.scaleY = i.scaleY || c, m = $B(o, i, { dirty: function() {
                f.setUnpainted(), f.painter.refresh();
              } }));
              o.save(), o.fillStyle = m || i, o.fillRect(A, p, v, y), o.restore();
            }
            u && (o.save(), o.globalAlpha = h, o.drawImage(g, A, p, v, y), o.restore());
          }
          !r || u ? d(0, 0, s, l) : r.length && D(r, function(A) {
            d(A.x * c, A.y * c, A.width * c, A.height * c);
          });
        }, t;
      }(ga), Xj = 1e5, fc = 314159, jE = 0.01, B2t = 1e-3;
      function M2t(n) {
        return n ? n.__builtin__ ? true : !(typeof n.resize != "function" || typeof n.refresh != "function") : false;
      }
      function D2t(n, t) {
        var e = document.createElement("div");
        return e.style.cssText = ["position:relative", "width:" + n + "px", "height:" + t + "px", "padding:0", "margin:0", "border-width:0"].join(";") + ";", e;
      }
      var R2t = function() {
        function n(t, e, i, r) {
          this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = false, this.type = "canvas";
          var a = !t.nodeName || t.nodeName.toUpperCase() === "CANVAS";
          this._opts = i = X({}, i || {}), this.dpr = i.devicePixelRatio || f1, this._singleCanvas = a, this.root = t;
          var o = t.style;
          o && (i5(t), t.innerHTML = ""), this.storage = e;
          var s = this._zlevelList;
          this._prevDisplayList = [];
          var l = this._layers;
          if (a) {
            var h = t, c = h.width, f = h.height;
            i.width != null && (c = i.width), i.height != null && (f = i.height), this.dpr = i.devicePixelRatio || 1, h.width = c * this.dpr, h.height = f * this.dpr, this._width = c, this._height = f;
            var g = new qM(h, this, this.dpr);
            g.__builtin__ = true, g.initContext(), l[fc] = g, g.zlevel = fc, s.push(fc), this._domRoot = t;
          } else {
            this._width = ld(t, 0, i), this._height = ld(t, 1, i);
            var u = this._domRoot = D2t(this._width, this._height);
            t.appendChild(u);
          }
        }
        return n.prototype.getType = function() {
          return "canvas";
        }, n.prototype.isSingleCanvas = function() {
          return this._singleCanvas;
        }, n.prototype.getViewportRoot = function() {
          return this._domRoot;
        }, n.prototype.getViewportRootOffset = function() {
          var t = this.getViewportRoot();
          if (t) return { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 };
        }, n.prototype.refresh = function(t) {
          var e = this.storage.getDisplayList(true), i = this._prevDisplayList, r = this._zlevelList;
          this._redrawId = Math.random(), this._paintList(e, i, t, this._redrawId);
          for (var a = 0; a < r.length; a++) {
            var o = r[a], s = this._layers[o];
            if (!s.__builtin__ && s.refresh) {
              var l = a === 0 ? this._backgroundColor : null;
              s.refresh(l);
            }
          }
          return this._opts.useDirtyRect && (this._prevDisplayList = e.slice()), this;
        }, n.prototype.refreshHover = function() {
          this._paintHoverList(this.storage.getDisplayList(false));
        }, n.prototype._paintHoverList = function(t) {
          var e = t.length, i = this._hoverlayer;
          if (i && i.clear(), !!e) {
            for (var r = { inHover: true, viewWidth: this._width, viewHeight: this._height }, a, o = 0; o < e; o++) {
              var s = t[o];
              s.__inHover && (i || (i = this._hoverlayer = this.getLayer(Xj)), a || (a = i.ctx, a.save()), rc(a, s, r, o === e - 1));
            }
            a && a.restore();
          }
        }, n.prototype.getHoverLayer = function() {
          return this.getLayer(Xj);
        }, n.prototype.paintOne = function(t, e) {
          HU(t, e);
        }, n.prototype._paintList = function(t, e, i, r) {
          if (this._redrawId === r) {
            i = i || false, this._updateLayerStatus(t);
            var a = this._doPaintList(t, e, i), o = a.finished, s = a.needsRefreshHover;
            if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(t), o) this.eachLayer(function(u) {
              u.afterBrush && u.afterBrush();
            });
            else {
              var l = this;
              X_(function() {
                l._paintList(t, e, i, r);
              });
            }
          }
        }, n.prototype._compositeManually = function() {
          var t = this.getLayer(fc).ctx, e = this._domRoot.width, i = this._domRoot.height;
          t.clearRect(0, 0, e, i), this.eachBuiltinLayer(function(r) {
            r.virtual && t.drawImage(r.dom, 0, 0, e, i);
          });
        }, n.prototype._doPaintList = function(t, e, i) {
          for (var r = this, a = [], o = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
            var l = this._zlevelList[s], u = this._layers[l];
            u.__builtin__ && u !== this._hoverlayer && (u.__dirty || i) && a.push(u);
          }
          for (var h = true, c = false, f = function(A) {
            var p = a[A], v = p.ctx, y = o && p.createRepaintRects(t, e, g._width, g._height), m = i ? p.__startIndex : p.__drawIndex, _ = !i && p.incremental && Date.now, I = _ && Date.now(), E = p.zlevel === g._zlevelList[0] ? g._backgroundColor : null;
            if (p.__startIndex === p.__endIndex) p.clear(false, E, y);
            else if (m === p.__startIndex) {
              var x = t[m];
              (!x.incremental || !x.notClear || i) && p.clear(false, E, y);
            }
            m === -1 && (m = p.__startIndex);
            var w, C = function(B) {
              var R = { inHover: false, allClipped: false, prevEl: null, viewWidth: r._width, viewHeight: r._height };
              for (w = m; w < p.__endIndex; w++) {
                var M = t[w];
                if (M.__inHover && (c = true), r._doPaintEl(M, p, o, B, R, w === p.__endIndex - 1), _) {
                  var L = Date.now() - I;
                  if (L > 15) break;
                }
              }
              R.prevElClipPaths && v.restore();
            };
            if (y) if (y.length === 0) w = p.__endIndex;
            else for (var S = g.dpr, b = 0; b < y.length; ++b) {
              var T = y[b];
              v.save(), v.beginPath(), v.rect(T.x * S, T.y * S, T.width * S, T.height * S), v.clip(), C(T), v.restore();
            }
            else v.save(), C(), v.restore();
            p.__drawIndex = w, p.__drawIndex < p.__endIndex && (h = false);
          }, g = this, d = 0; d < a.length; d++) f(d);
          return re.wxa && D(this._layers, function(A) {
            A && A.ctx && A.ctx.draw && A.ctx.draw();
          }), { finished: h, needsRefreshHover: c };
        }, n.prototype._doPaintEl = function(t, e, i, r, a, o) {
          var s = e.ctx;
          if (i) {
            var l = t.getPaintRect();
            (!r || l && l.intersect(r)) && (rc(s, t, a, o), t.setPrevPaintRect(l));
          } else rc(s, t, a, o);
        }, n.prototype.getLayer = function(t, e) {
          this._singleCanvas && !this._needsManuallyCompositing && (t = fc);
          var i = this._layers[t];
          return i || (i = new qM("zr_" + t, this, this.dpr), i.zlevel = t, i.__builtin__ = true, this._layerConfig[t] ? Yt(i, this._layerConfig[t], true) : this._layerConfig[t - jE] && Yt(i, this._layerConfig[t - jE], true), e && (i.virtual = e), this.insertLayer(t, i), i.initContext()), i;
        }, n.prototype.insertLayer = function(t, e) {
          var i = this._layers, r = this._zlevelList, a = r.length, o = this._domRoot, s = null, l = -1;
          if (i[t]) {
            Ya("ZLevel " + t + " has been used already");
            return;
          }
          if (!M2t(e)) {
            Ya("Layer of zlevel " + t + " is not valid");
            return;
          }
          if (a > 0 && t > r[0]) {
            for (l = 0; l < a - 1 && !(r[l] < t && r[l + 1] > t); l++) ;
            s = i[r[l]];
          }
          if (r.splice(l + 1, 0, t), i[t] = e, !e.virtual) if (s) {
            var u = s.dom;
            u.nextSibling ? o.insertBefore(e.dom, u.nextSibling) : o.appendChild(e.dom);
          } else o.firstChild ? o.insertBefore(e.dom, o.firstChild) : o.appendChild(e.dom);
          e.painter || (e.painter = this);
        }, n.prototype.eachLayer = function(t, e) {
          for (var i = this._zlevelList, r = 0; r < i.length; r++) {
            var a = i[r];
            t.call(e, this._layers[a], a);
          }
        }, n.prototype.eachBuiltinLayer = function(t, e) {
          for (var i = this._zlevelList, r = 0; r < i.length; r++) {
            var a = i[r], o = this._layers[a];
            o.__builtin__ && t.call(e, o, a);
          }
        }, n.prototype.eachOtherLayer = function(t, e) {
          for (var i = this._zlevelList, r = 0; r < i.length; r++) {
            var a = i[r], o = this._layers[a];
            o.__builtin__ || t.call(e, o, a);
          }
        }, n.prototype.getLayers = function() {
          return this._layers;
        }, n.prototype._updateLayerStatus = function(t) {
          this.eachBuiltinLayer(function(c, f) {
            c.__dirty = c.__used = false;
          });
          function e(c) {
            a && (a.__endIndex !== c && (a.__dirty = true), a.__endIndex = c);
          }
          if (this._singleCanvas) for (var i = 1; i < t.length; i++) {
            var r = t[i];
            if (r.zlevel !== t[i - 1].zlevel || r.incremental) {
              this._needsManuallyCompositing = true;
              break;
            }
          }
          var a = null, o = 0, s, l;
          for (l = 0; l < t.length; l++) {
            var r = t[l], u = r.zlevel, h = void 0;
            s !== u && (s = u, o = 0), r.incremental ? (h = this.getLayer(u + B2t, this._needsManuallyCompositing), h.incremental = true, o = 1) : h = this.getLayer(u + (o > 0 ? jE : 0), this._needsManuallyCompositing), h.__builtin__ || Ya("ZLevel " + u + " has been used by unkown layer " + h.id), h !== a && (h.__used = true, h.__startIndex !== l && (h.__dirty = true), h.__startIndex = l, h.incremental ? h.__drawIndex = -1 : h.__drawIndex = l, e(l), a = h), r.__dirty & jr && !r.__inHover && (h.__dirty = true, h.incremental && h.__drawIndex < 0 && (h.__drawIndex = l));
          }
          e(l), this.eachBuiltinLayer(function(c, f) {
            !c.__used && c.getElementCount() > 0 && (c.__dirty = true, c.__startIndex = c.__endIndex = c.__drawIndex = 0), c.__dirty && c.__drawIndex < 0 && (c.__drawIndex = c.__startIndex);
          });
        }, n.prototype.clear = function() {
          return this.eachBuiltinLayer(this._clearLayer), this;
        }, n.prototype._clearLayer = function(t) {
          t.clear();
        }, n.prototype.setBackgroundColor = function(t) {
          this._backgroundColor = t, D(this._layers, function(e) {
            e.setUnpainted();
          });
        }, n.prototype.configLayer = function(t, e) {
          if (e) {
            var i = this._layerConfig;
            i[t] ? Yt(i[t], e, true) : i[t] = e;
            for (var r = 0; r < this._zlevelList.length; r++) {
              var a = this._zlevelList[r];
              if (a === t || a === t + jE) {
                var o = this._layers[a];
                Yt(o, i[t], true);
              }
            }
          }
        }, n.prototype.delLayer = function(t) {
          var e = this._layers, i = this._zlevelList, r = e[t];
          r && (r.dom.parentNode.removeChild(r.dom), delete e[t], i.splice($t(i, t), 1));
        }, n.prototype.resize = function(t, e) {
          if (this._domRoot.style) {
            var i = this._domRoot;
            i.style.display = "none";
            var r = this._opts, a = this.root;
            if (t != null && (r.width = t), e != null && (r.height = e), t = ld(a, 0, r), e = ld(a, 1, r), i.style.display = "", this._width !== t || e !== this._height) {
              i.style.width = t + "px", i.style.height = e + "px";
              for (var o in this._layers) this._layers.hasOwnProperty(o) && this._layers[o].resize(t, e);
              this.refresh(true);
            }
            this._width = t, this._height = e;
          } else {
            if (t == null || e == null) return;
            this._width = t, this._height = e, this.getLayer(fc).resize(t, e);
          }
          return this;
        }, n.prototype.clearLayer = function(t) {
          var e = this._layers[t];
          e && e.clear();
        }, n.prototype.dispose = function() {
          this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
        }, n.prototype.getRenderedCanvas = function(t) {
          if (t = t || {}, this._singleCanvas && !this._compositeManually) return this._layers[fc].dom;
          var e = new qM("image", this, t.pixelRatio || this.dpr);
          e.initContext(), e.clear(false, t.backgroundColor || this._backgroundColor);
          var i = e.ctx;
          if (t.pixelRatio <= this.dpr) {
            this.refresh();
            var r = e.dom.width, a = e.dom.height;
            this.eachLayer(function(c) {
              c.__builtin__ ? i.drawImage(c.dom, 0, 0, r, a) : c.renderToCanvas && (i.save(), c.renderToCanvas(i), i.restore());
            });
          } else for (var o = { inHover: false, viewWidth: this._width, viewHeight: this._height }, s = this.storage.getDisplayList(true), l = 0, u = s.length; l < u; l++) {
            var h = s[l];
            rc(i, h, o, l === u - 1);
          }
          return e.dom;
        }, n.prototype.getWidth = function() {
          return this._width;
        }, n.prototype.getHeight = function() {
          return this._height;
        }, n;
      }();
      function L2t(n) {
        n.registerPainter("canvas", R2t);
      }
      var P2t = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.hasSymbolVisual = true, e;
        }
        return t.prototype.getInitialData = function(e) {
          if (true) {
            var i = e.coordinateSystem;
            if (i !== "polar" && i !== "cartesian2d") throw new Error("Line not support coordinateSystem besides cartesian and polar");
          }
          return tl(null, this, { useEncodeDefaulter: true });
        }, t.prototype.getLegendIcon = function(e) {
          var i = new Dt(), r = Un("line", 0, e.itemHeight / 2, e.itemWidth, 0, e.lineStyle.stroke, false);
          i.add(r), r.setStyle(e.lineStyle);
          var a = this.getData().getVisual("symbol"), o = this.getData().getVisual("symbolRotate"), s = a === "none" ? "circle" : a, l = e.itemHeight * 0.8, u = Un(s, (e.itemWidth - l) / 2, (e.itemHeight - l) / 2, l, l, e.itemStyle.fill);
          i.add(u), u.setStyle(e.itemStyle);
          var h = e.iconRotate === "inherit" ? o : e.iconRotate || 0;
          return u.rotation = h * Math.PI / 180, u.setOrigin([e.itemWidth / 2, e.itemHeight / 2]), s.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = "#fff", u.style.lineWidth = 2), i;
        }, t.type = "series.line", t.dependencies = ["grid", "polar"], t.defaultOption = { z: 3, coordinateSystem: "cartesian2d", legendHoverLink: true, clip: true, label: { position: "top" }, endLabel: { show: false, valueAnimation: true, distance: 8 }, lineStyle: { width: 2, type: "solid" }, emphasis: { scale: true }, step: false, smooth: false, smoothMonotone: null, symbol: "emptyCircle", symbolSize: 4, symbolRotate: null, showSymbol: true, showAllSymbol: "auto", connectNulls: false, sampling: "none", animationEasing: "linear", progressive: 0, hoverLayerThreshold: 1 / 0, universalTransition: { divideShape: "clone" }, triggerLineEvent: false }, t;
      }(tn);
      function pd(n, t) {
        var e = n.mapDimensionsAll("defaultedLabel"), i = e.length;
        if (i === 1) {
          var r = nd(n, t, e[0]);
          return r != null ? r + "" : null;
        } else if (i) {
          for (var a = [], o = 0; o < e.length; o++) a.push(nd(n, t, e[o]));
          return a.join(" ");
        }
      }
      function $j(n, t) {
        var e = n.mapDimensionsAll("defaultedLabel");
        if (!Z(t)) return t + "";
        for (var i = [], r = 0; r < e.length; r++) {
          var a = n.getDimensionIndex(e[r]);
          a >= 0 && i.push(t[a]);
        }
        return i.join(" ");
      }
      var $v = function(n) {
        V(t, n);
        function t(e, i, r, a) {
          var o = n.call(this) || this;
          return o.updateData(e, i, r, a), o;
        }
        return t.prototype._createSymbol = function(e, i, r, a, o) {
          this.removeAll();
          var s = Un(e, -1, -1, 2, 2, null, o);
          s.attr({ z2: 100, culling: true, scaleX: a[0] / 2, scaleY: a[1] / 2 }), s.drift = N2t, this._symbolType = e, this.add(s);
        }, t.prototype.stopSymbolAnimation = function(e) {
          this.childAt(0).stopAnimation(null, e);
        }, t.prototype.getSymbolType = function() {
          return this._symbolType;
        }, t.prototype.getSymbolPath = function() {
          return this.childAt(0);
        }, t.prototype.highlight = function() {
          Ws(this.childAt(0));
        }, t.prototype.downplay = function() {
          Xs(this.childAt(0));
        }, t.prototype.setZ = function(e, i) {
          var r = this.childAt(0);
          r.zlevel = e, r.z = i;
        }, t.prototype.setDraggable = function(e, i) {
          var r = this.childAt(0);
          r.draggable = e, r.cursor = !i && e ? "move" : r.cursor;
        }, t.prototype.updateData = function(e, i, r, a) {
          this.silent = false;
          var o = e.getItemVisual(i, "symbol") || "circle", s = e.hostModel, l = t.getSymbolSize(e, i), u = o !== this._symbolType, h = a && a.disableAnimation;
          if (u) {
            var c = e.getItemVisual(i, "symbolKeepAspect");
            this._createSymbol(o, e, i, l, c);
          } else {
            var f = this.childAt(0);
            f.silent = false;
            var g = { scaleX: l[0] / 2, scaleY: l[1] / 2 };
            h ? f.attr(g) : Ee(f, g, s, i), to(f);
          }
          if (this._updateCommon(e, i, l, r, a), u) {
            var f = this.childAt(0);
            if (!h) {
              var g = { scaleX: this._sizeX, scaleY: this._sizeY, style: { opacity: f.style.opacity } };
              f.scaleX = f.scaleY = 0, f.style.opacity = 0, on(f, g, s, i);
            }
          }
          h && this.childAt(0).stopAnimation("leave");
        }, t.prototype._updateCommon = function(e, i, r, a, o) {
          var s = this.childAt(0), l = e.hostModel, u, h, c, f, g, d, A, p, v;
          if (a && (u = a.emphasisItemStyle, h = a.blurItemStyle, c = a.selectItemStyle, f = a.focus, g = a.blurScope, A = a.labelStatesModels, p = a.hoverScale, v = a.cursorStyle, d = a.emphasisDisabled), !a || e.hasItemOption) {
            var y = a && a.itemModel ? a.itemModel : e.getItemModel(i), m = y.getModel("emphasis");
            u = m.getModel("itemStyle").getItemStyle(), c = y.getModel(["select", "itemStyle"]).getItemStyle(), h = y.getModel(["blur", "itemStyle"]).getItemStyle(), f = m.get("focus"), g = m.get("blurScope"), d = m.get("disabled"), A = Jn(y), p = m.getShallow("scale"), v = y.getShallow("cursor");
          }
          var _ = e.getItemVisual(i, "symbolRotate");
          s.attr("rotation", (_ || 0) * Math.PI / 180 || 0);
          var I = nc(e.getItemVisual(i, "symbolOffset"), r);
          I && (s.x = I[0], s.y = I[1]), v && s.attr("cursor", v);
          var E = e.getItemVisual(i, "style"), x = E.fill;
          if (s instanceof gi) {
            var w = s.style;
            s.useStyle(X({ image: w.image, x: w.x, y: w.y, width: w.width, height: w.height }, E));
          } else s.__isEmptyBrush ? s.useStyle(X({}, E)) : s.useStyle(E), s.style.decal = null, s.setColor(x, o && o.symbolInnerColor), s.style.strokeNoScale = true;
          var C = e.getItemVisual(i, "liftZ"), S = this._z2;
          C != null ? S == null && (this._z2 = s.z2, s.z2 += C) : S != null && (s.z2 = S, this._z2 = null);
          var b = o && o.useNameLabel;
          xi(s, A, { labelFetcher: l, labelDataIndex: i, defaultText: T, inheritColor: x, defaultOpacity: E.opacity });
          function T(M) {
            return b ? e.getName(M) : pd(e, M);
          }
          this._sizeX = r[0] / 2, this._sizeY = r[1] / 2;
          var B = s.ensureState("emphasis");
          B.style = u, s.ensureState("select").style = c, s.ensureState("blur").style = h;
          var R = p == null || p === true ? Math.max(1.1, 3 / this._sizeY) : isFinite(p) && p > 0 ? +p : 1;
          B.scaleX = this._sizeX * R, B.scaleY = this._sizeY * R, this.setSymbolScale(1), pn(this, f, g, d);
        }, t.prototype.setSymbolScale = function(e) {
          this.scaleX = this.scaleY = e;
        }, t.prototype.fadeOut = function(e, i, r) {
          var a = this.childAt(0), o = Nt(this).dataIndex, s = r && r.animation;
          if (this.silent = a.silent = true, r && r.fadeLabel) {
            var l = a.getTextContent();
            l && uu(l, { style: { opacity: 0 } }, i, { dataIndex: o, removeOpt: s, cb: function() {
              a.removeTextContent();
            } });
          } else a.removeTextContent();
          uu(a, { style: { opacity: 0 }, scaleX: 0, scaleY: 0 }, i, { dataIndex: o, cb: e, removeOpt: s });
        }, t.getSymbolSize = function(e, i) {
          return sd(e.getItemVisual(i, "symbolSize"));
        }, t;
      }(Dt);
      function N2t(n, t) {
        this.parent.drift(n, t);
      }
      function HM(n, t, e, i) {
        return t && !isNaN(t[0]) && !isNaN(t[1]) && !(i.isIgnore && i.isIgnore(e)) && !(i.clipShape && !i.clipShape.contain(t[0], t[1])) && n.getItemVisual(e, "symbol") !== "none";
      }
      function Zj(n) {
        return n != null && !Et(n) && (n = { isIgnore: n }), n || {};
      }
      function Kj(n) {
        var t = n.hostModel, e = t.getModel("emphasis");
        return { emphasisItemStyle: e.getModel("itemStyle").getItemStyle(), blurItemStyle: t.getModel(["blur", "itemStyle"]).getItemStyle(), selectItemStyle: t.getModel(["select", "itemStyle"]).getItemStyle(), focus: e.get("focus"), blurScope: e.get("blurScope"), emphasisDisabled: e.get("disabled"), hoverScale: e.get("scale"), labelStatesModels: Jn(t), cursorStyle: t.get("cursor") };
      }
      var Zv = function() {
        function n(t) {
          this.group = new Dt(), this._SymbolCtor = t || $v;
        }
        return n.prototype.updateData = function(t, e) {
          this._progressiveEls = null, e = Zj(e);
          var i = this.group, r = t.hostModel, a = this._data, o = this._SymbolCtor, s = e.disableAnimation, l = Kj(t), u = { disableAnimation: s }, h = e.getSymbolPoint || function(c) {
            return t.getItemLayout(c);
          };
          a || i.removeAll(), t.diff(a).add(function(c) {
            var f = h(c);
            if (HM(t, f, c, e)) {
              var g = new o(t, c, l, u);
              g.setPosition(f), t.setItemGraphicEl(c, g), i.add(g);
            }
          }).update(function(c, f) {
            var g = a.getItemGraphicEl(f), d = h(c);
            if (!HM(t, d, c, e)) {
              i.remove(g);
              return;
            }
            var A = t.getItemVisual(c, "symbol") || "circle", p = g && g.getSymbolType && g.getSymbolType();
            if (!g || p && p !== A) i.remove(g), g = new o(t, c, l, u), g.setPosition(d);
            else {
              g.updateData(t, c, l, u);
              var v = { x: d[0], y: d[1] };
              s ? g.attr(v) : Ee(g, v, r);
            }
            i.add(g), t.setItemGraphicEl(c, g);
          }).remove(function(c) {
            var f = a.getItemGraphicEl(c);
            f && f.fadeOut(function() {
              i.remove(f);
            }, r);
          }).execute(), this._getSymbolPoint = h, this._data = t;
        }, n.prototype.updateLayout = function() {
          var t = this, e = this._data;
          e && e.eachItemGraphicEl(function(i, r) {
            var a = t._getSymbolPoint(r);
            i.setPosition(a), i.markRedraw();
          });
        }, n.prototype.incrementalPrepareUpdate = function(t) {
          this._seriesScope = Kj(t), this._data = null, this.group.removeAll();
        }, n.prototype.incrementalUpdate = function(t, e, i) {
          this._progressiveEls = [], i = Zj(i);
          function r(l) {
            l.isGroup || (l.incremental = true, l.ensureState("emphasis").hoverLayer = true);
          }
          for (var a = t.start; a < t.end; a++) {
            var o = e.getItemLayout(a);
            if (HM(e, o, a, i)) {
              var s = new this._SymbolCtor(e, a, this._seriesScope);
              s.traverse(r), s.setPosition(o), this.group.add(s), e.setItemGraphicEl(a, s), this._progressiveEls.push(s);
            }
          }
        }, n.prototype.eachRendered = function(t) {
          hu(this._progressiveEls || this.group, t);
        }, n.prototype.remove = function(t) {
          var e = this.group, i = this._data;
          i && t ? i.eachItemGraphicEl(function(r) {
            r.fadeOut(function() {
              e.remove(r);
            }, i.hostModel);
          }) : e.removeAll();
        }, n;
      }();
      function Jj(n, t, e) {
        var i = n.getBaseAxis(), r = n.getOtherAxis(i), a = F2t(r, e), o = i.dim, s = r.dim, l = t.mapDimension(s), u = t.mapDimension(o), h = s === "x" || s === "radius" ? 1 : 0, c = K(n.dimensions, function(d) {
          return t.mapDimension(d);
        }), f = false, g = t.getCalculationInfo("stackResultDimension");
        return yu(t, c[0]) && (f = true, c[0] = g), yu(t, c[1]) && (f = true, c[1] = g), { dataDimsForPoint: c, valueStart: a, valueAxisDim: s, baseAxisDim: o, stacked: !!f, valueDim: l, baseDim: u, baseDataOffset: h, stackedOverDimension: t.getCalculationInfo("stackedOverDimension") };
      }
      function F2t(n, t) {
        var e = 0, i = n.scale.getExtent();
        return t === "start" ? e = i[0] : t === "end" ? e = i[1] : ye(t) && !isNaN(t) ? e = t : i[0] > 0 ? e = i[0] : i[1] < 0 && (e = i[1]), e;
      }
      function t9(n, t, e, i) {
        var r = NaN;
        n.stacked && (r = e.get(e.getCalculationInfo("stackedOverDimension"), i)), isNaN(r) && (r = n.valueStart);
        var a = n.baseDataOffset, o = [];
        return o[a] = e.get(n.baseDim, i), o[1 - a] = r, t.dataToPoint(o);
      }
      function k2t(n, t) {
        var e = [];
        return t.diff(n).add(function(i) {
          e.push({ cmd: "+", idx: i });
        }).update(function(i, r) {
          e.push({ cmd: "=", idx: r, idx1: i });
        }).remove(function(i) {
          e.push({ cmd: "-", idx: i });
        }).execute(), e;
      }
      function O2t(n, t, e, i, r, a, o, s) {
        for (var l = k2t(n, t), u = [], h = [], c = [], f = [], g = [], d = [], A = [], p = Jj(r, t, o), v = n.getLayout("points") || [], y = t.getLayout("points") || [], m = 0; m < l.length; m++) {
          var _ = l[m], I = true, E = void 0, x = void 0;
          switch (_.cmd) {
            case "=":
              E = _.idx * 2, x = _.idx1 * 2;
              var w = v[E], C = v[E + 1], S = y[x], b = y[x + 1];
              (isNaN(w) || isNaN(C)) && (w = S, C = b), u.push(w, C), h.push(S, b), c.push(e[E], e[E + 1]), f.push(i[x], i[x + 1]), A.push(t.getRawIndex(_.idx1));
              break;
            case "+":
              var T = _.idx, B = p.dataDimsForPoint, R = r.dataToPoint([t.get(B[0], T), t.get(B[1], T)]);
              x = T * 2, u.push(R[0], R[1]), h.push(y[x], y[x + 1]);
              var M = t9(p, r, t, T);
              c.push(M[0], M[1]), f.push(i[x], i[x + 1]), A.push(t.getRawIndex(T));
              break;
            case "-":
              I = false;
          }
          I && (g.push(_), d.push(d.length));
        }
        d.sort(function($, J) {
          return A[$] - A[J];
        });
        for (var L = u.length, N = ns(L), F = ns(L), k = ns(L), O = ns(L), Q = [], m = 0; m < d.length; m++) {
          var j = d[m], Y = m * 2, G = j * 2;
          N[Y] = u[G], N[Y + 1] = u[G + 1], F[Y] = h[G], F[Y + 1] = h[G + 1], k[Y] = c[G], k[Y + 1] = c[G + 1], O[Y] = f[G], O[Y + 1] = f[G + 1], Q[m] = g[j];
        }
        return { current: N, next: F, stackedOnCurrent: k, stackedOnNext: O, status: Q };
      }
      var mu = Math.min, _u = Math.max;
      function gc(n, t) {
        return isNaN(n) || isNaN(t);
      }
      function YM(n, t, e, i, r, a, o, s, l) {
        for (var u, h, c, f, g, d, A = e, p = 0; p < i; p++) {
          var v = t[A * 2], y = t[A * 2 + 1];
          if (A >= r || A < 0) break;
          if (gc(v, y)) {
            if (l) {
              A += a;
              continue;
            }
            break;
          }
          if (A === e) n[a > 0 ? "moveTo" : "lineTo"](v, y), c = v, f = y;
          else {
            var m = v - u, _ = y - h;
            if (m * m + _ * _ < 0.5) {
              A += a;
              continue;
            }
            if (o > 0) {
              for (var I = A + a, E = t[I * 2], x = t[I * 2 + 1]; E === v && x === y && p < i; ) p++, I += a, A += a, E = t[I * 2], x = t[I * 2 + 1], v = t[A * 2], y = t[A * 2 + 1], m = v - u, _ = y - h;
              var w = p + 1;
              if (l) for (; gc(E, x) && w < i; ) w++, I += a, E = t[I * 2], x = t[I * 2 + 1];
              var C = 0.5, S = 0, b = 0, T = void 0, B = void 0;
              if (w >= i || gc(E, x)) g = v, d = y;
              else {
                S = E - u, b = x - h;
                var R = v - u, M = E - v, L = y - h, N = x - y, F = void 0, k = void 0;
                if (s === "x") {
                  F = Math.abs(R), k = Math.abs(M);
                  var O = S > 0 ? 1 : -1;
                  g = v - O * F * o, d = y, T = v + O * k * o, B = y;
                } else if (s === "y") {
                  F = Math.abs(L), k = Math.abs(N);
                  var Q = b > 0 ? 1 : -1;
                  g = v, d = y - Q * F * o, T = v, B = y + Q * k * o;
                } else F = Math.sqrt(R * R + L * L), k = Math.sqrt(M * M + N * N), C = k / (k + F), g = v - S * o * (1 - C), d = y - b * o * (1 - C), T = v + S * o * C, B = y + b * o * C, T = mu(T, _u(E, v)), B = mu(B, _u(x, y)), T = _u(T, mu(E, v)), B = _u(B, mu(x, y)), S = T - v, b = B - y, g = v - S * F / k, d = y - b * F / k, g = mu(g, _u(u, v)), d = mu(d, _u(h, y)), g = _u(g, mu(u, v)), d = _u(d, mu(h, y)), S = v - g, b = y - d, T = v + S * k / F, B = y + b * k / F;
              }
              n.bezierCurveTo(c, f, g, d, v, y), c = T, f = B;
            } else n.lineTo(v, y);
          }
          u = v, h = y, A += a;
        }
        return p;
      }
      var e9 = /* @__PURE__ */ function() {
        function n() {
          this.smooth = 0, this.smoothConstraint = true;
        }
        return n;
      }(), Q2t = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "ec-polyline", i;
        }
        return t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new e9();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.points, a = 0, o = r.length / 2;
          if (i.connectNulls) {
            for (; o > 0 && gc(r[o * 2 - 2], r[o * 2 - 1]); o--) ;
            for (; a < o && gc(r[a * 2], r[a * 2 + 1]); a++) ;
          }
          for (; a < o; ) a += YM(e, r, a, o, o, 1, i.smooth, i.smoothMonotone, i.connectNulls) + 1;
        }, t.prototype.getPointOn = function(e, i) {
          this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
          for (var r = this.path, a = r.data, o = $o.CMD, s, l, u = i === "x", h = [], c = 0; c < a.length; ) {
            var f = a[c++], g = void 0, d = void 0, A = void 0, p = void 0, v = void 0, y = void 0, m = void 0;
            switch (f) {
              case o.M:
                s = a[c++], l = a[c++];
                break;
              case o.L:
                if (g = a[c++], d = a[c++], m = u ? (e - s) / (g - s) : (e - l) / (d - l), m <= 1 && m >= 0) {
                  var _ = u ? (d - l) * m + l : (g - s) * m + s;
                  return u ? [e, _] : [_, e];
                }
                s = g, l = d;
                break;
              case o.C:
                g = a[c++], d = a[c++], A = a[c++], p = a[c++], v = a[c++], y = a[c++];
                var I = u ? J_(s, g, A, v, e, h) : J_(l, d, p, y, e, h);
                if (I > 0) for (var E = 0; E < I; E++) {
                  var x = h[E];
                  if (x <= 1 && x >= 0) {
                    var _ = u ? Zn(l, d, p, y, x) : Zn(s, g, A, v, x);
                    return u ? [e, _] : [_, e];
                  }
                }
                s = v, l = y;
                break;
            }
          }
        }, t;
      }(ne), z2t = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t;
      }(e9), n9 = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "ec-polygon", i;
        }
        return t.prototype.getDefaultShape = function() {
          return new z2t();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.points, a = i.stackedOnPoints, o = 0, s = r.length / 2, l = i.smoothMonotone;
          if (i.connectNulls) {
            for (; s > 0 && gc(r[s * 2 - 2], r[s * 2 - 1]); s--) ;
            for (; o < s && gc(r[o * 2], r[o * 2 + 1]); o++) ;
          }
          for (; o < s; ) {
            var u = YM(e, r, o, s, s, 1, i.smooth, l, i.connectNulls);
            YM(e, a, o + u - 1, u, s, -1, i.stackedOnSmooth, l, i.connectNulls), o += u + 1, e.closePath();
          }
        }, t;
      }(ne);
      function i9(n, t, e, i, r) {
        var a = n.getArea(), o = a.x, s = a.y, l = a.width, u = a.height, h = e.get(["lineStyle", "width"]) || 2;
        o -= h / 2, s -= h / 2, l += h, u += h, l = Math.ceil(l), o !== Math.floor(o) && (o = Math.floor(o), l++);
        var c = new fe({ shape: { x: o, y: s, width: l, height: u } });
        if (t) {
          var f = n.getBaseAxis(), g = f.isHorizontal(), d = f.inverse;
          g ? (d && (c.shape.x += l), c.shape.width = 0) : (d || (c.shape.y += u), c.shape.height = 0);
          var A = yt(r) ? function(p) {
            r(p, c);
          } : null;
          on(c, { shape: { width: l, height: u, x: o, y: s } }, e, null, i, A);
        }
        return c;
      }
      function r9(n, t, e) {
        var i = n.getArea(), r = En(i.r0, 1), a = En(i.r, 1), o = new Zi({ shape: { cx: En(n.cx, 1), cy: En(n.cy, 1), r0: r, r: a, startAngle: i.startAngle, endAngle: i.endAngle, clockwise: i.clockwise } });
        if (t) {
          var s = n.getBaseAxis().dim === "angle";
          s ? o.shape.endAngle = i.startAngle : o.shape.r = r, on(o, { shape: { endAngle: i.endAngle, r: a } }, e);
        }
        return o;
      }
      function Kv(n, t, e, i, r) {
        if (n) {
          if (n.type === "polar") return r9(n, t, e);
          if (n.type === "cartesian2d") return i9(n, t, e, i, r);
        } else return null;
        return null;
      }
      function dc(n, t) {
        return n.type === t;
      }
      function a9(n, t) {
        if (n.length === t.length) {
          for (var e = 0; e < n.length; e++) if (n[e] !== t[e]) return;
          return true;
        }
      }
      function o9(n) {
        for (var t = 1 / 0, e = 1 / 0, i = -1 / 0, r = -1 / 0, a = 0; a < n.length; ) {
          var o = n[a++], s = n[a++];
          isNaN(o) || (t = Math.min(o, t), i = Math.max(o, i)), isNaN(s) || (e = Math.min(s, e), r = Math.max(s, r));
        }
        return [[t, e], [i, r]];
      }
      function s9(n, t) {
        var e = o9(n), i = e[0], r = e[1], a = o9(t), o = a[0], s = a[1];
        return Math.max(Math.abs(i[0] - o[0]), Math.abs(i[1] - o[1]), Math.abs(r[0] - s[0]), Math.abs(r[1] - s[1]));
      }
      function l9(n) {
        return ye(n) ? n : n ? 0.5 : 0;
      }
      function G2t(n, t, e) {
        if (!e.valueDim) return [];
        for (var i = t.count(), r = ns(i * 2), a = 0; a < i; a++) {
          var o = t9(e, n, t, a);
          r[a * 2] = o[0], r[a * 2 + 1] = o[1];
        }
        return r;
      }
      function Eu(n, t, e, i) {
        var r = t.getBaseAxis(), a = r.dim === "x" || r.dim === "radius" ? 0 : 1, o = [], s = 0, l = [], u = [], h = [], c = [];
        if (i) {
          for (s = 0; s < n.length; s += 2) !isNaN(n[s]) && !isNaN(n[s + 1]) && c.push(n[s], n[s + 1]);
          n = c;
        }
        for (s = 0; s < n.length - 2; s += 2) switch (h[0] = n[s + 2], h[1] = n[s + 3], u[0] = n[s], u[1] = n[s + 1], o.push(u[0], u[1]), e) {
          case "end":
            l[a] = h[a], l[1 - a] = u[1 - a], o.push(l[0], l[1]);
            break;
          case "middle":
            var f = (u[a] + h[a]) / 2, g = [];
            l[a] = g[a] = f, l[1 - a] = u[1 - a], g[1 - a] = h[1 - a], o.push(l[0], l[1]), o.push(g[0], g[1]);
            break;
          default:
            l[a] = u[a], l[1 - a] = h[1 - a], o.push(l[0], l[1]);
        }
        return o.push(n[s++], n[s++]), o;
      }
      function U2t(n, t) {
        var e = [], i = n.length, r, a;
        function o(h, c, f) {
          var g = h.coord, d = (f - g) / (c.coord - g), A = T1t(d, [h.color, c.color]);
          return { coord: f, color: A };
        }
        for (var s = 0; s < i; s++) {
          var l = n[s], u = l.coord;
          if (u < 0) r = l;
          else if (u > t) {
            a ? e.push(o(a, l, t)) : r && e.push(o(r, l, 0), o(r, l, t));
            break;
          } else r && (e.push(o(r, l, 0)), r = null), e.push(l), a = l;
        }
        return e;
      }
      function V2t(n, t, e) {
        var i = n.getVisual("visualMeta");
        if (!(!i || !i.length || !n.count())) {
          if (t.type !== "cartesian2d") {
            return;
          }
          for (var r, a, o = i.length - 1; o >= 0; o--) {
            var s = n.getDimensionInfo(i[o].dimension);
            if (r = s && s.coordDim, r === "x" || r === "y") {
              a = i[o];
              break;
            }
          }
          if (!a) {
            return;
          }
          var l = t.getAxis(r), u = K(a.stops, function(m) {
            return { coord: l.toGlobalCoord(l.dataToCoord(m.value)), color: m.color };
          }), h = u.length, c = a.outerColors.slice();
          h && u[0].coord > u[h - 1].coord && (u.reverse(), c.reverse());
          var f = U2t(u, r === "x" ? e.getWidth() : e.getHeight()), g = f.length;
          if (!g && h) return u[0].coord < 0 ? c[1] ? c[1] : u[h - 1].color : c[0] ? c[0] : u[0].color;
          var d = 10, A = f[0].coord - d, p = f[g - 1].coord + d, v = p - A;
          if (v < 1e-3) return "transparent";
          D(f, function(m) {
            m.offset = (m.coord - A) / v;
          }), f.push({ offset: g ? f[g - 1].offset : 0.5, color: c[1] || "transparent" }), f.unshift({ offset: g ? f[0].offset : 0.5, color: c[0] || "transparent" });
          var y = new dv(0, 0, 0, 0, f, true);
          return y[r] = A, y[r + "2"] = p, y;
        }
      }
      function j2t(n, t, e) {
        var i = n.get("showAllSymbol"), r = i === "auto";
        if (!(i && !r)) {
          var a = e.getAxesByScale("ordinal")[0];
          if (a && !(r && q2t(a, t))) {
            var o = t.mapDimension(a.dim), s = {};
            return D(a.getViewLabels(), function(l) {
              var u = a.scale.getRawOrdinalNumber(l.tickValue);
              s[u] = 1;
            }), function(l) {
              return !s.hasOwnProperty(t.get(o, l));
            };
          }
        }
      }
      function q2t(n, t) {
        var e = n.getExtent(), i = Math.abs(e[1] - e[0]) / n.scale.count();
        isNaN(i) && (i = 0);
        for (var r = t.count(), a = Math.max(1, Math.round(r / 5)), o = 0; o < r; o += a) if ($v.getSymbolSize(t, o)[n.isHorizontal() ? 1 : 0] * 1.5 > i) return false;
        return true;
      }
      function H2t(n, t) {
        return isNaN(n) || isNaN(t);
      }
      function Y2t(n) {
        for (var t = n.length / 2; t > 0 && H2t(n[t * 2 - 2], n[t * 2 - 1]); t--) ;
        return t - 1;
      }
      function u9(n, t) {
        return [n[t * 2], n[t * 2 + 1]];
      }
      function W2t(n, t, e) {
        for (var i = n.length / 2, r = e === "x" ? 0 : 1, a, o, s = 0, l = -1, u = 0; u < i; u++) if (o = n[u * 2 + r], !(isNaN(o) || isNaN(n[u * 2 + 1 - r]))) {
          if (u === 0) {
            a = o;
            continue;
          }
          if (a <= t && o >= t || a >= t && o <= t) {
            l = u;
            break;
          }
          s = u, a = o;
        }
        return { range: [s, l], t: (t - a) / (o - a) };
      }
      function h9(n) {
        if (n.get(["endLabel", "show"])) return true;
        for (var t = 0; t < $i.length; t++) if (n.get([$i[t], "endLabel", "show"])) return true;
        return false;
      }
      function WM(n, t, e, i) {
        if (dc(t, "cartesian2d")) {
          var r = i.getModel("endLabel"), a = r.get("valueAnimation"), o = i.getData(), s = { lastFrameIndex: 0 }, l = h9(i) ? function(g, d) {
            n._endLabelOnDuring(g, d, o, s, a, r, t);
          } : null, u = t.getBaseAxis().isHorizontal(), h = i9(t, e, i, function() {
            var g = n._endLabel;
            g && e && s.originalX != null && g.attr({ x: s.originalX, y: s.originalY });
          }, l);
          if (!i.get("clip", true)) {
            var c = h.shape, f = Math.max(c.width, c.height);
            u ? (c.y -= f, c.height += f * 2) : (c.x -= f, c.width += f * 2);
          }
          return l && l(1, h), h;
        } else return i.get(["endLabel", "show"]), r9(t, e, i);
      }
      function X2t(n, t) {
        var e = t.getBaseAxis(), i = e.isHorizontal(), r = e.inverse, a = i ? r ? "right" : "left" : "center", o = i ? "middle" : r ? "top" : "bottom";
        return { normal: { align: n.get("align") || a, verticalAlign: n.get("verticalAlign") || o } };
      }
      var $2t = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.init = function() {
          var e = new Dt(), i = new Zv();
          this.group.add(i.group), this._symbolDraw = i, this._lineGroup = e;
        }, t.prototype.render = function(e, i, r) {
          var a = this, o = e.coordinateSystem, s = this.group, l = e.getData(), u = e.getModel("lineStyle"), h = e.getModel("areaStyle"), c = l.getLayout("points") || [], f = o.type === "polar", g = this._coordSys, d = this._symbolDraw, A = this._polyline, p = this._polygon, v = this._lineGroup, y = !i.ssr && e.get("animation"), m = !h.isEmpty(), _ = h.get("origin"), I = Jj(o, l, _), E = m && G2t(o, l, I), x = e.get("showSymbol"), w = e.get("connectNulls"), C = x && !f && j2t(e, l, o), S = this._data;
          S && S.eachItemGraphicEl(function(J, et) {
            J.__temp && (s.remove(J), S.setItemGraphicEl(et, null));
          }), x || d.remove(), s.add(v);
          var b = f ? false : e.get("step"), T;
          o && o.getArea && e.get("clip", true) && (T = o.getArea(), T.width != null ? (T.x -= 0.1, T.y -= 0.1, T.width += 0.2, T.height += 0.2) : T.r0 && (T.r0 -= 0.5, T.r += 0.5)), this._clipShapeForSymbol = T;
          var B = V2t(l, o, r) || l.getVisual("style")[l.getVisual("drawType")];
          if (!(A && g.type === o.type && b === this._step)) x && d.updateData(l, { isIgnore: C, clipShape: T, disableAnimation: true, getSymbolPoint: function(J) {
            return [c[J * 2], c[J * 2 + 1]];
          } }), y && this._initSymbolLabelAnimation(l, o, T), b && (c = Eu(c, o, b, w), E && (E = Eu(E, o, b, w))), A = this._newPolyline(c), m ? p = this._newPolygon(c, E) : p && (v.remove(p), p = this._polygon = null), f || this._initOrUpdateEndLabel(e, o, Xh(B)), v.setClipPath(WM(this, o, true, e));
          else {
            m && !p ? p = this._newPolygon(c, E) : p && !m && (v.remove(p), p = this._polygon = null), f || this._initOrUpdateEndLabel(e, o, Xh(B));
            var R = v.getClipPath();
            if (R) {
              var M = WM(this, o, false, e);
              on(R, { shape: M.shape }, e);
            } else v.setClipPath(WM(this, o, true, e));
            x && d.updateData(l, { isIgnore: C, clipShape: T, disableAnimation: true, getSymbolPoint: function(J) {
              return [c[J * 2], c[J * 2 + 1]];
            } }), (!a9(this._stackedOnPoints, E) || !a9(this._points, c)) && (y ? this._doUpdateAnimation(l, E, o, r, b, _, w) : (b && (c = Eu(c, o, b, w), E && (E = Eu(E, o, b, w))), A.setShape({ points: c }), p && p.setShape({ points: c, stackedOnPoints: E })));
          }
          var L = e.getModel("emphasis"), N = L.get("focus"), F = L.get("blurScope"), k = L.get("disabled");
          if (A.useStyle(wt(u.getLineStyle(), { fill: "none", stroke: B, lineJoin: "bevel" })), Ii(A, e, "lineStyle"), A.style.lineWidth > 0 && e.get(["emphasis", "lineStyle", "width"]) === "bolder") {
            var O = A.getState("emphasis").style;
            O.lineWidth = +A.style.lineWidth + 1;
          }
          Nt(A).seriesIndex = e.seriesIndex, pn(A, N, F, k);
          var Q = l9(e.get("smooth")), j = e.get("smoothMonotone");
          if (A.setShape({ smooth: Q, smoothMonotone: j, connectNulls: w }), p) {
            var Y = l.getCalculationInfo("stackedOnSeries"), G = 0;
            p.useStyle(wt(h.getAreaStyle(), { fill: B, opacity: 0.7, lineJoin: "bevel", decal: l.getVisual("style").decal })), Y && (G = l9(Y.get("smooth"))), p.setShape({ smooth: Q, stackedOnSmooth: G, smoothMonotone: j, connectNulls: w }), Ii(p, e, "areaStyle"), Nt(p).seriesIndex = e.seriesIndex, pn(p, N, F, k);
          }
          var $ = function(J) {
            a._changePolyState(J);
          };
          l.eachItemGraphicEl(function(J) {
            J && (J.onHoverStateChange = $);
          }), this._polyline.onHoverStateChange = $, this._data = l, this._coordSys = o, this._stackedOnPoints = E, this._points = c, this._step = b, this._valueOrigin = _, e.get("triggerLineEvent") && (this.packEventData(e, A), p && this.packEventData(e, p));
        }, t.prototype.packEventData = function(e, i) {
          Nt(i).eventData = { componentType: "series", componentSubType: "line", componentIndex: e.componentIndex, seriesIndex: e.seriesIndex, seriesName: e.name, seriesType: "line" };
        }, t.prototype.highlight = function(e, i, r, a) {
          var o = e.getData(), s = Bh(o, a);
          if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) {
            var l = o.getLayout("points"), u = o.getItemGraphicEl(s);
            if (!u) {
              var h = l[s * 2], c = l[s * 2 + 1];
              if (isNaN(h) || isNaN(c) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(h, c)) return;
              var f = e.get("zlevel") || 0, g = e.get("z") || 0;
              u = new $v(o, s), u.x = h, u.y = c, u.setZ(f, g);
              var d = u.getSymbolPath().getTextContent();
              d && (d.zlevel = f, d.z = g, d.z2 = this._polyline.z2 + 1), u.__temp = true, o.setItemGraphicEl(s, u), u.stopSymbolAnimation(true), this.group.add(u);
            }
            u.highlight();
          } else qe.prototype.highlight.call(this, e, i, r, a);
        }, t.prototype.downplay = function(e, i, r, a) {
          var o = e.getData(), s = Bh(o, a);
          if (this._changePolyState("normal"), s != null && s >= 0) {
            var l = o.getItemGraphicEl(s);
            l && (l.__temp ? (o.setItemGraphicEl(s, null), this.group.remove(l)) : l.downplay());
          } else qe.prototype.downplay.call(this, e, i, r, a);
        }, t.prototype._changePolyState = function(e) {
          var i = this._polygon;
          M1(this._polyline, e), i && M1(i, e);
        }, t.prototype._newPolyline = function(e) {
          var i = this._polyline;
          return i && this._lineGroup.remove(i), i = new Q2t({ shape: { points: e }, segmentIgnoreThreshold: 2, z2: 10 }), this._lineGroup.add(i), this._polyline = i, i;
        }, t.prototype._newPolygon = function(e, i) {
          var r = this._polygon;
          return r && this._lineGroup.remove(r), r = new n9({ shape: { points: e, stackedOnPoints: i }, segmentIgnoreThreshold: 2 }), this._lineGroup.add(r), this._polygon = r, r;
        }, t.prototype._initSymbolLabelAnimation = function(e, i, r) {
          var a, o, s = i.getBaseAxis(), l = s.inverse;
          i.type === "cartesian2d" ? (a = s.isHorizontal(), o = false) : i.type === "polar" && (a = s.dim === "angle", o = true);
          var u = e.hostModel, h = u.get("animationDuration");
          yt(h) && (h = h(null));
          var c = u.get("animationDelay") || 0, f = yt(c) ? c(null) : c;
          e.eachItemGraphicEl(function(g, d) {
            var A = g;
            if (A) {
              var p = [g.x, g.y], v = void 0, y = void 0, m = void 0;
              if (r) if (o) {
                var _ = r, I = i.pointToCoord(p);
                a ? (v = _.startAngle, y = _.endAngle, m = -I[1] / 180 * Math.PI) : (v = _.r0, y = _.r, m = I[0]);
              } else {
                var E = r;
                a ? (v = E.x, y = E.x + E.width, m = g.x) : (v = E.y + E.height, y = E.y, m = g.y);
              }
              var x = y === v ? 0 : (m - v) / (y - v);
              l && (x = 1 - x);
              var w = yt(c) ? c(d) : h * x + f, C = A.getSymbolPath(), S = C.getTextContent();
              A.attr({ scaleX: 0, scaleY: 0 }), A.animateTo({ scaleX: 1, scaleY: 1 }, { duration: 200, setToFinal: true, delay: w }), S && S.animateFrom({ style: { opacity: 0 } }, { duration: 300, delay: w }), C.disableLabelAnimation = true;
            }
          });
        }, t.prototype._initOrUpdateEndLabel = function(e, i, r) {
          var a = e.getModel("endLabel");
          if (h9(e)) {
            var o = e.getData(), s = this._polyline, l = o.getLayout("points");
            if (!l) {
              s.removeTextContent(), this._endLabel = null;
              return;
            }
            var u = this._endLabel;
            u || (u = this._endLabel = new Ae({ z2: 200 }), u.ignoreClip = true, s.setTextContent(this._endLabel), s.disableLabelAnimation = true);
            var h = Y2t(l);
            h >= 0 && (xi(s, Jn(e, "endLabel"), { inheritColor: r, labelFetcher: e, labelDataIndex: h, defaultText: function(c, f, g) {
              return g != null ? $j(o, g) : pd(o, c);
            }, enableTextSetter: true }, X2t(a, i)), s.textConfig.position = null);
          } else this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
        }, t.prototype._endLabelOnDuring = function(e, i, r, a, o, s, l) {
          var u = this._endLabel, h = this._polyline;
          if (u) {
            e < 1 && a.originalX == null && (a.originalX = u.x, a.originalY = u.y);
            var c = r.getLayout("points"), f = r.hostModel, g = f.get("connectNulls"), d = s.get("precision"), A = s.get("distance") || 0, p = l.getBaseAxis(), v = p.isHorizontal(), y = p.inverse, m = i.shape, _ = y ? v ? m.x : m.y + m.height : v ? m.x + m.width : m.y, I = (v ? A : 0) * (y ? -1 : 1), E = (v ? 0 : -A) * (y ? -1 : 1), x = v ? "x" : "y", w = W2t(c, _, x), C = w.range, S = C[1] - C[0], b = void 0;
            if (S >= 1) {
              if (S > 1 && !g) {
                var T = u9(c, C[0]);
                u.attr({ x: T[0] + I, y: T[1] + E }), o && (b = f.getRawValue(C[0]));
              } else {
                var T = h.getPointOn(_, x);
                T && u.attr({ x: T[0] + I, y: T[1] + E });
                var B = f.getRawValue(C[0]), R = f.getRawValue(C[1]);
                o && (b = I4(r, d, B, R, w.t));
              }
              a.lastFrameIndex = C[0];
            } else {
              var M = e === 1 || a.lastFrameIndex > 0 ? C[0] : 0, T = u9(c, M);
              o && (b = f.getRawValue(M)), u.attr({ x: T[0] + I, y: T[1] + E });
            }
            if (o) {
              var L = Hg(u);
              typeof L.setLabelText == "function" && L.setLabelText(b);
            }
          }
        }, t.prototype._doUpdateAnimation = function(e, i, r, a, o, s, l) {
          var u = this._polyline, h = this._polygon, c = e.hostModel, f = O2t(this._data, e, this._stackedOnPoints, i, this._coordSys, r, this._valueOrigin), g = f.current, d = f.stackedOnCurrent, A = f.next, p = f.stackedOnNext;
          if (o && (g = Eu(f.current, r, o, l), d = Eu(f.stackedOnCurrent, r, o, l), A = Eu(f.next, r, o, l), p = Eu(f.stackedOnNext, r, o, l)), s9(g, A) > 3e3 || h && s9(d, p) > 3e3) {
            u.stopAnimation(), u.setShape({ points: A }), h && (h.stopAnimation(), h.setShape({ points: A, stackedOnPoints: p }));
            return;
          }
          u.shape.__points = f.current, u.shape.points = g;
          var v = { shape: { points: A } };
          f.current !== g && (v.shape.__points = f.next), u.stopAnimation(), Ee(u, v, c), h && (h.setShape({ points: g, stackedOnPoints: d }), h.stopAnimation(), Ee(h, { shape: { stackedOnPoints: p } }, c), u.shape.points !== h.shape.points && (h.shape.points = u.shape.points));
          for (var y = [], m = f.status, _ = 0; _ < m.length; _++) {
            var I = m[_].cmd;
            if (I === "=") {
              var E = e.getItemGraphicEl(m[_].idx1);
              E && y.push({ el: E, ptIdx: _ });
            }
          }
          u.animators && u.animators.length && u.animators[0].during(function() {
            h && h.dirtyShape();
            for (var x = u.shape.__points, w = 0; w < y.length; w++) {
              var C = y[w].el, S = y[w].ptIdx * 2;
              C.x = x[S], C.y = x[S + 1], C.markRedraw();
            }
          });
        }, t.prototype.remove = function(e) {
          var i = this.group, r = this._data;
          this._lineGroup.removeAll(), this._symbolDraw.remove(true), r && r.eachItemGraphicEl(function(a, o) {
            a.__temp && (i.remove(a), r.setItemGraphicEl(o, null));
          }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
        }, t.type = "line", t;
      }(qe);
      function Jv(n, t) {
        return { seriesType: n, plan: rd(), reset: function(e) {
          var i = e.getData(), r = e.coordinateSystem, a = e.pipelineContext, o = t || a.large;
          if (r) {
            var s = K(r.dimensions, function(g) {
              return i.mapDimension(g);
            }).slice(0, 2), l = s.length, u = i.getCalculationInfo("stackResultDimension");
            yu(i, s[0]) && (s[0] = u), yu(i, s[1]) && (s[1] = u);
            var h = i.getStore(), c = i.getDimensionIndex(s[0]), f = i.getDimensionIndex(s[1]);
            return l && { progress: function(g, d) {
              for (var A = g.end - g.start, p = o && ns(A * l), v = [], y = [], m = g.start, _ = 0; m < g.end; m++) {
                var I = void 0;
                if (l === 1) {
                  var E = h.get(c, m);
                  I = r.dataToPoint(E, null, y);
                } else v[0] = h.get(c, m), v[1] = h.get(f, m), I = r.dataToPoint(v, null, y);
                o ? (p[_++] = I[0], p[_++] = I[1]) : d.setItemLayout(m, I.slice());
              }
              o && d.setLayout("points", p);
            } };
          }
        } };
      }
      var Z2t = { average: function(n) {
        for (var t = 0, e = 0, i = 0; i < n.length; i++) isNaN(n[i]) || (t += n[i], e++);
        return e === 0 ? NaN : t / e;
      }, sum: function(n) {
        for (var t = 0, e = 0; e < n.length; e++) t += n[e] || 0;
        return t;
      }, max: function(n) {
        for (var t = -1 / 0, e = 0; e < n.length; e++) n[e] > t && (t = n[e]);
        return isFinite(t) ? t : NaN;
      }, min: function(n) {
        for (var t = 1 / 0, e = 0; e < n.length; e++) n[e] < t && (t = n[e]);
        return isFinite(t) ? t : NaN;
      }, minmax: function(n) {
        for (var t = -1 / 0, e = -1 / 0, i = 0; i < n.length; i++) {
          var r = n[i], a = Math.abs(r);
          a > t && (t = a, e = r);
        }
        return isFinite(e) ? e : NaN;
      }, nearest: function(n) {
        return n[0];
      } }, K2t = function(n) {
        return Math.round(n.length / 2);
      };
      function c9(n) {
        return { seriesType: n, reset: function(t, e, i) {
          var r = t.getData(), a = t.get("sampling"), o = t.coordinateSystem, s = r.count();
          if (s > 10 && o.type === "cartesian2d" && a) {
            var l = o.getBaseAxis(), u = o.getOtherAxis(l), h = l.getExtent(), c = i.getDevicePixelRatio(), f = Math.abs(h[1] - h[0]) * (c || 1), g = Math.round(s / f);
            if (isFinite(g) && g > 1) {
              a === "lttb" && t.setData(r.lttbDownSample(r.mapDimension(u.dim), 1 / g));
              var d = void 0;
              ht(a) ? d = Z2t[a] : yt(a) && (d = a), d && t.setData(r.downSample(r.mapDimension(u.dim), 1 / g, d, K2t));
            }
          }
        } };
      }
      function J2t(n) {
        n.registerChartView($2t), n.registerSeriesModel(P2t), n.registerLayout(Jv("line", true)), n.registerVisual({ seriesType: "line", reset: function(t) {
          var e = t.getData(), i = t.getModel("lineStyle").getLineStyle();
          i && !i.stroke && (i.stroke = e.getVisual("style").fill), e.setVisual("legendLineStyle", i);
        } }), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, c9("line"));
      }
      var ty = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.getInitialData = function(e, i) {
          return tl(null, this, { useEncodeDefaulter: true });
        }, t.prototype.getMarkerPosition = function(e, i, r) {
          var a = this.coordinateSystem;
          if (a && a.clampData) {
            var o = a.clampData(e), s = a.dataToPoint(o);
            if (r) D(a.getAxes(), function(f, g) {
              if (f.type === "category" && i != null) {
                var d = f.getTicksCoords(), A = f.getTickModel().get("alignWithLabel"), p = o[g], v = i[g] === "x1" || i[g] === "y1";
                if (v && !A && (p += 1), d.length < 2) return;
                if (d.length === 2) {
                  s[g] = f.toGlobalCoord(f.getExtent()[v ? 1 : 0]);
                  return;
                }
                for (var y = void 0, m = void 0, _ = 1, I = 0; I < d.length; I++) {
                  var E = d[I].coord, x = I === d.length - 1 ? d[I - 1].tickValue + _ : d[I].tickValue;
                  if (x === p) {
                    m = E;
                    break;
                  } else if (x < p) y = E;
                  else if (y != null && x > p) {
                    m = (E + y) / 2;
                    break;
                  }
                  I === 1 && (_ = x - d[0].tickValue);
                }
                m == null && (y ? y && (m = d[d.length - 1].coord) : m = d[0].coord), s[g] = f.toGlobalCoord(m);
              }
            });
            else {
              var l = this.getData(), u = l.getLayout("offset"), h = l.getLayout("size"), c = a.getBaseAxis().isHorizontal() ? 0 : 1;
              s[c] += u + h / 2;
            }
            return s;
          }
          return [NaN, NaN];
        }, t.type = "series.__base_bar__", t.defaultOption = { z: 2, coordinateSystem: "cartesian2d", legendHoverLink: true, barMinHeight: 0, barMinAngle: 0, large: false, largeThreshold: 400, progressive: 3e3, progressiveChunkMode: "mod" }, t;
      }(tn);
      tn.registerClass(ty);
      var tTt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.getInitialData = function() {
          return tl(null, this, { useEncodeDefaulter: true, createInvertedIndices: !!this.get("realtimeSort", true) || null });
        }, t.prototype.getProgressive = function() {
          return this.get("large") ? this.get("progressive") : false;
        }, t.prototype.getProgressiveThreshold = function() {
          var e = this.get("progressiveThreshold"), i = this.get("largeThreshold");
          return i > e && (e = i), e;
        }, t.prototype.brushSelector = function(e, i, r) {
          return r.rect(i.getItemLayout(e));
        }, t.type = "series.bar", t.dependencies = ["grid", "polar"], t.defaultOption = cu(ty.defaultOption, { clip: true, roundCap: false, showBackground: false, backgroundStyle: { color: "rgba(180, 180, 180, 0.2)", borderColor: null, borderWidth: 0, borderType: "solid", borderRadius: 0, shadowBlur: 0, shadowColor: null, shadowOffsetX: 0, shadowOffsetY: 0, opacity: 1 }, select: { itemStyle: { borderColor: "#212121" } }, realtimeSort: false }), t;
      }(ty), eTt = /* @__PURE__ */ function() {
        function n() {
          this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true;
        }
        return n;
      }(), qE = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "sausage", i;
        }
        return t.prototype.getDefaultShape = function() {
          return new eTt();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.cx, a = i.cy, o = Math.max(i.r0 || 0, 0), s = Math.max(i.r, 0), l = (s - o) * 0.5, u = o + l, h = i.startAngle, c = i.endAngle, f = i.clockwise, g = Math.PI * 2, d = f ? c - h < g : h - c < g;
          d || (h = c - (f ? g : -g));
          var A = Math.cos(h), p = Math.sin(h), v = Math.cos(c), y = Math.sin(c);
          d ? (e.moveTo(A * o + r, p * o + a), e.arc(A * u + r, p * u + a, l, -Math.PI + h, h, !f)) : e.moveTo(A * s + r, p * s + a), e.arc(r, a, s, h, c, !f), e.arc(v * u + r, y * u + a, l, c - Math.PI * 2, c - Math.PI, !f), o !== 0 && e.arc(r, a, o, c, h, f);
        }, t;
      }(ne);
      function nTt(n, t) {
        t = t || {};
        var e = t.isRoundCap;
        return function(i, r, a) {
          var o = r.position;
          if (!o || o instanceof Array) return d1(i, r, a);
          var s = n(o), l = r.distance != null ? r.distance : 5, u = this.shape, h = u.cx, c = u.cy, f = u.r, g = u.r0, d = (f + g) / 2, A = u.startAngle, p = u.endAngle, v = (A + p) / 2, y = e ? Math.abs(f - g) / 2 : 0, m = Math.cos, _ = Math.sin, I = h + f * m(A), E = c + f * _(A), x = "left", w = "top";
          switch (s) {
            case "startArc":
              I = h + (g - l) * m(v), E = c + (g - l) * _(v), x = "center", w = "top";
              break;
            case "insideStartArc":
              I = h + (g + l) * m(v), E = c + (g + l) * _(v), x = "center", w = "bottom";
              break;
            case "startAngle":
              I = h + d * m(A) + HE(A, l + y, false), E = c + d * _(A) + YE(A, l + y, false), x = "right", w = "middle";
              break;
            case "insideStartAngle":
              I = h + d * m(A) + HE(A, -l + y, false), E = c + d * _(A) + YE(A, -l + y, false), x = "left", w = "middle";
              break;
            case "middle":
              I = h + d * m(v), E = c + d * _(v), x = "center", w = "middle";
              break;
            case "endArc":
              I = h + (f + l) * m(v), E = c + (f + l) * _(v), x = "center", w = "bottom";
              break;
            case "insideEndArc":
              I = h + (f - l) * m(v), E = c + (f - l) * _(v), x = "center", w = "top";
              break;
            case "endAngle":
              I = h + d * m(p) + HE(p, l + y, true), E = c + d * _(p) + YE(p, l + y, true), x = "left", w = "middle";
              break;
            case "insideEndAngle":
              I = h + d * m(p) + HE(p, -l + y, true), E = c + d * _(p) + YE(p, -l + y, true), x = "right", w = "middle";
              break;
            default:
              return d1(i, r, a);
          }
          return i = i || {}, i.x = I, i.y = E, i.align = x, i.verticalAlign = w, i;
        };
      }
      function iTt(n, t, e, i) {
        if (ye(i)) {
          n.setTextConfig({ rotation: i });
          return;
        } else if (Z(t)) {
          n.setTextConfig({ rotation: 0 });
          return;
        }
        var r = n.shape, a = r.clockwise ? r.startAngle : r.endAngle, o = r.clockwise ? r.endAngle : r.startAngle, s = (a + o) / 2, l, u = e(t);
        switch (u) {
          case "startArc":
          case "insideStartArc":
          case "middle":
          case "insideEndArc":
          case "endArc":
            l = s;
            break;
          case "startAngle":
          case "insideStartAngle":
            l = a;
            break;
          case "endAngle":
          case "insideEndAngle":
            l = o;
            break;
          default:
            n.setTextConfig({ rotation: 0 });
            return;
        }
        var h = Math.PI * 1.5 - l;
        u === "middle" && h > Math.PI / 2 && h < Math.PI * 1.5 && (h -= Math.PI), n.setTextConfig({ rotation: h });
      }
      function HE(n, t, e) {
        return t * Math.sin(n) * (e ? -1 : 1);
      }
      function YE(n, t, e) {
        return t * Math.cos(n) * (e ? 1 : -1);
      }
      function Ac(n, t, e) {
        var i = n.get("borderRadius");
        if (i == null) return e ? { cornerRadius: 0 } : null;
        Z(i) || (i = [i, i, i, i]);
        var r = Math.abs(t.r || 0 - t.r0 || 0);
        return { cornerRadius: K(i, function(a) {
          return Za(a, r);
        }) };
      }
      var XM = Math.max, $M = Math.min;
      function rTt(n, t) {
        var e = n.getArea && n.getArea();
        if (dc(n, "cartesian2d")) {
          var i = n.getBaseAxis();
          if (i.type !== "category" || !i.onBand) {
            var r = t.getLayout("bandWidth");
            i.isHorizontal() ? (e.x -= r, e.width += r * 2) : (e.y -= r, e.height += r * 2);
          }
        }
        return e;
      }
      var aTt = function(n) {
        V(t, n);
        function t() {
          var e = n.call(this) || this;
          return e.type = t.type, e._isFirstFrame = true, e;
        }
        return t.prototype.render = function(e, i, r, a) {
          this._model = e, this._removeOnRenderedListener(r), this._updateDrawMode(e);
          var o = e.get("coordinateSystem");
          o === "cartesian2d" || o === "polar" ? (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(e, i, r) : this._renderNormal(e, i, r, a)) : gn("Only cartesian2d and polar supported for bar.");
        }, t.prototype.incrementalPrepareRender = function(e) {
          this._clear(), this._updateDrawMode(e), this._updateLargeClip(e);
        }, t.prototype.incrementalRender = function(e, i) {
          this._progressiveEls = [], this._incrementalRenderLarge(e, i);
        }, t.prototype.eachRendered = function(e) {
          hu(this._progressiveEls || this.group, e);
        }, t.prototype._updateDrawMode = function(e) {
          var i = e.pipelineContext.large;
          (this._isLargeDraw == null || i !== this._isLargeDraw) && (this._isLargeDraw = i, this._clear());
        }, t.prototype._renderNormal = function(e, i, r, a) {
          var o = this.group, s = e.getData(), l = this._data, u = e.coordinateSystem, h = u.getBaseAxis(), c;
          u.type === "cartesian2d" ? c = h.isHorizontal() : u.type === "polar" && (c = h.dim === "angle");
          var f = e.isAnimationEnabled() ? e : null, g = oTt(e, u);
          g && this._enableRealtimeSort(g, s, r);
          var d = e.get("clip", true) || g, A = rTt(u, s);
          o.removeClipPath();
          var p = e.get("roundCap", true), v = e.get("showBackground", true), y = e.getModel("backgroundStyle"), m = y.get("borderRadius") || 0, _ = [], I = this._backgroundEls, E = a && a.isInitSort, x = a && a.type === "changeAxisOrder";
          function w(b) {
            var T = WE[u.type](s, b), B = gTt(u, c, T);
            return B.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? B.setShape("r", m) : B.setShape("cornerRadius", m), _[b] = B, B;
          }
          s.diff(l).add(function(b) {
            var T = s.getItemModel(b), B = WE[u.type](s, b, T);
            if (v && w(b), !(!s.hasValue(b) || !p9[u.type](B))) {
              var R = false;
              d && (R = f9[u.type](A, B));
              var M = g9[u.type](e, s, b, B, c, f, h.model, false, p);
              g && (M.forceLabelAnimation = true), y9(M, s, b, T, B, e, c, u.type === "polar"), E ? M.attr({ shape: B }) : g ? d9(g, f, M, B, b, c, false, false) : on(M, { shape: B }, e, b), s.setItemGraphicEl(b, M), o.add(M), M.ignore = R;
            }
          }).update(function(b, T) {
            var B = s.getItemModel(b), R = WE[u.type](s, b, B);
            if (v) {
              var M = void 0;
              I.length === 0 ? M = w(T) : (M = I[T], M.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? M.setShape("r", m) : M.setShape("cornerRadius", m), _[b] = M);
              var L = WE[u.type](s, b), N = I9(c, L, u);
              Ee(M, { shape: N }, f, b);
            }
            var F = l.getItemGraphicEl(T);
            if (!s.hasValue(b) || !p9[u.type](R)) {
              o.remove(F);
              return;
            }
            var k = false;
            if (d && (k = f9[u.type](A, R), k && o.remove(F)), F ? to(F) : F = g9[u.type](e, s, b, R, c, f, h.model, !!F, p), g && (F.forceLabelAnimation = true), x) {
              var O = F.getTextContent();
              if (O) {
                var Q = Hg(O);
                Q.prevValue != null && (Q.prevValue = Q.value);
              }
            } else y9(F, s, b, B, R, e, c, u.type === "polar");
            E ? F.attr({ shape: R }) : g ? d9(g, f, F, R, b, c, true, x) : Ee(F, { shape: R }, e, b, null), s.setItemGraphicEl(b, F), F.ignore = k, o.add(F);
          }).remove(function(b) {
            var T = l.getItemGraphicEl(b);
            T && Av(T, e, b);
          }).execute();
          var C = this._backgroundGroup || (this._backgroundGroup = new Dt());
          C.removeAll();
          for (var S = 0; S < _.length; ++S) C.add(_[S]);
          o.add(C), this._backgroundEls = _, this._data = s;
        }, t.prototype._renderLarge = function(e, i, r) {
          this._clear(), _9(e, this.group), this._updateLargeClip(e);
        }, t.prototype._incrementalRenderLarge = function(e, i) {
          this._removeBackground(), _9(i, this.group, this._progressiveEls, true);
        }, t.prototype._updateLargeClip = function(e) {
          var i = e.get("clip", true) && Kv(e.coordinateSystem, false, e), r = this.group;
          i ? r.setClipPath(i) : r.removeClipPath();
        }, t.prototype._enableRealtimeSort = function(e, i, r) {
          var a = this;
          if (i.count()) {
            var o = e.baseAxis;
            if (this._isFirstFrame) this._dispatchInitSort(i, e, r), this._isFirstFrame = false;
            else {
              var s = function(l) {
                var u = i.getItemGraphicEl(l), h = u && u.shape;
                return h && Math.abs(o.isHorizontal() ? h.height : h.width) || 0;
              };
              this._onRendered = function() {
                a._updateSortWithinSameData(i, s, o, r);
              }, r.getZr().on("rendered", this._onRendered);
            }
          }
        }, t.prototype._dataSort = function(e, i, r) {
          var a = [];
          return e.each(e.mapDimension(i.dim), function(o, s) {
            var l = r(s);
            l = l == null ? NaN : l, a.push({ dataIndex: s, mappedValue: l, ordinalNumber: o });
          }), a.sort(function(o, s) {
            return s.mappedValue - o.mappedValue;
          }), { ordinalNumbers: K(a, function(o) {
            return o.ordinalNumber;
          }) };
        }, t.prototype._isOrderChangedWithinSameData = function(e, i, r) {
          for (var a = r.scale, o = e.mapDimension(r.dim), s = Number.MAX_VALUE, l = 0, u = a.getOrdinalMeta().categories.length; l < u; ++l) {
            var h = e.rawIndexOf(o, a.getRawOrdinalNumber(l)), c = h < 0 ? Number.MIN_VALUE : i(e.indexOfRawIndex(h));
            if (c > s) return true;
            s = c;
          }
          return false;
        }, t.prototype._isOrderDifferentInView = function(e, i) {
          for (var r = i.scale, a = r.getExtent(), o = Math.max(0, a[0]), s = Math.min(a[1], r.getOrdinalMeta().categories.length - 1); o <= s; ++o) if (e.ordinalNumbers[o] !== r.getRawOrdinalNumber(o)) return true;
        }, t.prototype._updateSortWithinSameData = function(e, i, r, a) {
          if (this._isOrderChangedWithinSameData(e, i, r)) {
            var o = this._dataSort(e, r, i);
            this._isOrderDifferentInView(o, r) && (this._removeOnRenderedListener(a), a.dispatchAction({ type: "changeAxisOrder", componentType: r.dim + "Axis", axisId: r.index, sortInfo: o }));
          }
        }, t.prototype._dispatchInitSort = function(e, i, r) {
          var a = i.baseAxis, o = this._dataSort(e, a, function(s) {
            return e.get(e.mapDimension(i.otherAxis.dim), s);
          });
          r.dispatchAction({ type: "changeAxisOrder", componentType: a.dim + "Axis", isInitSort: true, axisId: a.index, sortInfo: o });
        }, t.prototype.remove = function(e, i) {
          this._clear(this._model), this._removeOnRenderedListener(i);
        }, t.prototype.dispose = function(e, i) {
          this._removeOnRenderedListener(i);
        }, t.prototype._removeOnRenderedListener = function(e) {
          this._onRendered && (e.getZr().off("rendered", this._onRendered), this._onRendered = null);
        }, t.prototype._clear = function(e) {
          var i = this.group, r = this._data;
          e && e.isAnimationEnabled() && r && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], r.eachItemGraphicEl(function(a) {
            Av(a, e, Nt(a).dataIndex);
          })) : i.removeAll(), this._data = null, this._isFirstFrame = true;
        }, t.prototype._removeBackground = function() {
          this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
        }, t.type = "bar", t;
      }(qe), f9 = { cartesian2d: function(n, t) {
        var e = t.width < 0 ? -1 : 1, i = t.height < 0 ? -1 : 1;
        e < 0 && (t.x += t.width, t.width = -t.width), i < 0 && (t.y += t.height, t.height = -t.height);
        var r = n.x + n.width, a = n.y + n.height, o = XM(t.x, n.x), s = $M(t.x + t.width, r), l = XM(t.y, n.y), u = $M(t.y + t.height, a), h = s < o, c = u < l;
        return t.x = h && o > r ? s : o, t.y = c && l > a ? u : l, t.width = h ? 0 : s - o, t.height = c ? 0 : u - l, e < 0 && (t.x += t.width, t.width = -t.width), i < 0 && (t.y += t.height, t.height = -t.height), h || c;
      }, polar: function(n, t) {
        var e = t.r0 <= t.r ? 1 : -1;
        if (e < 0) {
          var i = t.r;
          t.r = t.r0, t.r0 = i;
        }
        var r = $M(t.r, n.r), a = XM(t.r0, n.r0);
        t.r = r, t.r0 = a;
        var o = r - a < 0;
        if (e < 0) {
          var i = t.r;
          t.r = t.r0, t.r0 = i;
        }
        return o;
      } }, g9 = { cartesian2d: function(n, t, e, i, r, a, o, s, l) {
        var u = new fe({ shape: X({}, i), z2: 1 });
        if (u.__dataIndex = e, u.name = "item", a) {
          var h = u.shape, c = r ? "height" : "width";
          h[c] = 0;
        }
        return u;
      }, polar: function(n, t, e, i, r, a, o, s, l) {
        var u = !r && l ? qE : Zi, h = new u({ shape: i, z2: 1 });
        h.name = "item";
        var c = v9(r);
        if (h.calculateTextPosition = nTt(c, { isRoundCap: u === qE }), a) {
          var f = h.shape, g = r ? "r" : "endAngle", d = {};
          f[g] = r ? i.r0 : i.startAngle, d[g] = i[g], (s ? Ee : on)(h, { shape: d }, a);
        }
        return h;
      } };
      function oTt(n, t) {
        var e = n.get("realtimeSort", true), i = t.getBaseAxis();
        if (e && (i.type !== "category" && gn("`realtimeSort` will not work because this bar series is not based on a category axis."), t.type !== "cartesian2d" && gn("`realtimeSort` will not work because this bar series is not on cartesian2d.")), e && i.type === "category" && t.type === "cartesian2d") return { baseAxis: i, otherAxis: t.getOtherAxis(i) };
      }
      function d9(n, t, e, i, r, a, o, s) {
        var l, u;
        a ? (u = { x: i.x, width: i.width }, l = { y: i.y, height: i.height }) : (u = { y: i.y, height: i.height }, l = { x: i.x, width: i.width }), s || (o ? Ee : on)(e, { shape: l }, t, r, null);
        var h = t ? n.baseAxis.model : null;
        (o ? Ee : on)(e, { shape: u }, h, r);
      }
      function A9(n, t) {
        for (var e = 0; e < t.length; e++) if (!isFinite(n[t[e]])) return true;
        return false;
      }
      var sTt = ["x", "y", "width", "height"], lTt = ["cx", "cy", "r", "startAngle", "endAngle"], p9 = { cartesian2d: function(n) {
        return !A9(n, sTt);
      }, polar: function(n) {
        return !A9(n, lTt);
      } }, WE = { cartesian2d: function(n, t, e) {
        var i = n.getItemLayout(t), r = e ? hTt(e, i) : 0, a = i.width > 0 ? 1 : -1, o = i.height > 0 ? 1 : -1;
        return { x: i.x + a * r / 2, y: i.y + o * r / 2, width: i.width - a * r, height: i.height - o * r };
      }, polar: function(n, t, e) {
        var i = n.getItemLayout(t);
        return { cx: i.cx, cy: i.cy, r0: i.r0, r: i.r, startAngle: i.startAngle, endAngle: i.endAngle, clockwise: i.clockwise };
      } };
      function uTt(n) {
        return n.startAngle != null && n.endAngle != null && n.startAngle === n.endAngle;
      }
      function v9(n) {
        return /* @__PURE__ */ function(t) {
          var e = t ? "Arc" : "Angle";
          return function(i) {
            switch (i) {
              case "start":
              case "insideStart":
              case "end":
              case "insideEnd":
                return i + e;
              default:
                return i;
            }
          };
        }(n);
      }
      function y9(n, t, e, i, r, a, o, s) {
        var l = t.getItemVisual(e, "style");
        if (s) {
          if (!a.get("roundCap")) {
            var h = n.shape, c = Ac(i.getModel("itemStyle"), h, true);
            X(h, c), n.setShape(h);
          }
        } else {
          var u = i.get(["itemStyle", "borderRadius"]) || 0;
          n.setShape("r", u);
        }
        n.useStyle(l);
        var f = i.getShallow("cursor");
        f && n.attr("cursor", f);
        var g = s ? o ? r.r >= r.r0 ? "endArc" : "startArc" : r.endAngle >= r.startAngle ? "endAngle" : "startAngle" : o ? r.height >= 0 ? "bottom" : "top" : r.width >= 0 ? "right" : "left", d = Jn(i);
        xi(n, d, { labelFetcher: a, labelDataIndex: e, defaultText: pd(a.getData(), e), inheritColor: l.fill, defaultOpacity: l.opacity, defaultOutsidePosition: g });
        var A = n.getTextContent();
        if (s && A) {
          var p = i.get(["label", "position"]);
          n.textConfig.inside = p === "middle" ? true : null, iTt(n, p === "outside" ? g : p, v9(o), i.get(["label", "rotate"]));
        }
        U8(A, d, a.getRawValue(e), function(y) {
          return $j(t, y);
        });
        var v = i.getModel(["emphasis"]);
        pn(n, v.get("focus"), v.get("blurScope"), v.get("disabled")), Ii(n, i), uTt(r) && (n.style.fill = "none", n.style.stroke = "none", D(n.states, function(y) {
          y.style && (y.style.fill = y.style.stroke = "none");
        }));
      }
      function hTt(n, t) {
        var e = n.get(["itemStyle", "borderColor"]);
        if (!e || e === "none") return 0;
        var i = n.get(["itemStyle", "borderWidth"]) || 0, r = isNaN(t.width) ? Number.MAX_VALUE : Math.abs(t.width), a = isNaN(t.height) ? Number.MAX_VALUE : Math.abs(t.height);
        return Math.min(i, r, a);
      }
      var cTt = /* @__PURE__ */ function() {
        function n() {
        }
        return n;
      }(), m9 = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "largeBar", i;
        }
        return t.prototype.getDefaultShape = function() {
          return new cTt();
        }, t.prototype.buildPath = function(e, i) {
          for (var r = i.points, a = this.baseDimIdx, o = 1 - this.baseDimIdx, s = [], l = [], u = this.barWidth, h = 0; h < r.length; h += 3) l[a] = u, l[o] = r[h + 2], s[a] = r[h + a], s[o] = r[h + o], e.rect(s[0], s[1], l[0], l[1]);
        }, t;
      }(ne);
      function _9(n, t, e, i) {
        var r = n.getData(), a = r.getLayout("valueAxisHorizontal") ? 1 : 0, o = r.getLayout("largeDataIndices"), s = r.getLayout("size"), l = n.getModel("backgroundStyle"), u = r.getLayout("largeBackgroundPoints");
        if (u) {
          var h = new m9({ shape: { points: u }, incremental: !!i, silent: true, z2: 0 });
          h.baseDimIdx = a, h.largeDataIndices = o, h.barWidth = s, h.useStyle(l.getItemStyle()), t.add(h), e && e.push(h);
        }
        var c = new m9({ shape: { points: r.getLayout("largePoints") }, incremental: !!i, ignoreCoarsePointer: true, z2: 1 });
        c.baseDimIdx = a, c.largeDataIndices = o, c.barWidth = s, t.add(c), c.useStyle(r.getVisual("style")), Nt(c).seriesIndex = n.seriesIndex, n.get("silent") || (c.on("mousedown", E9), c.on("mousemove", E9)), e && e.push(c);
      }
      var E9 = qB(function(n) {
        var t = this, e = fTt(t, n.offsetX, n.offsetY);
        Nt(t).dataIndex = e >= 0 ? e : null;
      }, 30, false);
      function fTt(n, t, e) {
        for (var i = n.baseDimIdx, r = 1 - i, a = n.shape.points, o = n.largeDataIndices, s = [], l = [], u = n.barWidth, h = 0, c = a.length / 3; h < c; h++) {
          var f = h * 3;
          if (l[i] = u, l[r] = a[f + 2], s[i] = a[f + i], s[r] = a[f + r], l[r] < 0 && (s[r] += l[r], l[r] = -l[r]), t >= s[0] && t <= s[0] + l[0] && e >= s[1] && e <= s[1] + l[1]) return o[h];
        }
        return -1;
      }
      function I9(n, t, e) {
        if (dc(e, "cartesian2d")) {
          var i = t, r = e.getArea();
          return { x: n ? i.x : r.x, y: n ? r.y : i.y, width: n ? i.width : r.width, height: n ? r.height : i.height };
        } else {
          var r = e.getArea(), a = t;
          return { cx: r.cx, cy: r.cy, r0: n ? r.r0 : a.r0, r: n ? r.r : a.r, startAngle: n ? a.startAngle : 0, endAngle: n ? a.endAngle : Math.PI * 2 };
        }
      }
      function gTt(n, t, e) {
        var i = n.type === "polar" ? Zi : fe;
        return new i({ shape: I9(t, e, n), silent: true, z2: 0 });
      }
      function dTt(n) {
        n.registerChartView(aTt), n.registerSeriesModel(tTt), n.registerLayout(n.PRIORITY.VISUAL.LAYOUT, Gt(QV, "bar")), n.registerLayout(n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, zV("bar")), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, c9("bar")), n.registerAction({ type: "changeAxisOrder", event: "changeAxisOrder", update: "update" }, function(t, e) {
          var i = t.componentType || "series";
          e.eachComponent({ mainType: i, query: t }, function(r) {
            t.sortInfo && r.axis.setCategorySortInfo(t.sortInfo);
          });
        });
      }
      var x9 = Math.PI * 2, XE = Math.PI / 180;
      function w9(n, t) {
        return Yn(n.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() });
      }
      function C9(n, t) {
        var e = w9(n, t), i = n.get("center"), r = n.get("radius");
        Z(r) || (r = [0, r]);
        var a = st(e.width, t.getWidth()), o = st(e.height, t.getHeight()), s = Math.min(a, o), l = st(r[0], s / 2), u = st(r[1], s / 2), h, c, f = n.coordinateSystem;
        if (f) {
          var g = f.dataToPoint(i);
          h = g[0] || 0, c = g[1] || 0;
        } else Z(i) || (i = [i, i]), h = st(i[0], a) + e.x, c = st(i[1], o) + e.y;
        return { cx: h, cy: c, r0: l, r: u };
      }
      function ATt(n, t, e) {
        t.eachSeriesByType(n, function(i) {
          var r = i.getData(), a = r.mapDimension("value"), o = w9(i, e), s = C9(i, e), l = s.cx, u = s.cy, h = s.r, c = s.r0, f = -i.get("startAngle") * XE, g = i.get("endAngle"), d = i.get("padAngle") * XE;
          g = g === "auto" ? f - x9 : -g * XE;
          var A = i.get("minAngle") * XE, p = A + d, v = 0;
          r.each(a, function(N) {
            !isNaN(N) && v++;
          });
          var y = r.getSum(a), m = Math.PI / (y || v) * 2, _ = i.get("clockwise"), I = i.get("roseType"), E = i.get("stillShowZeroSum"), x = r.getDataExtent(a);
          x[0] = 0;
          var w = _ ? 1 : -1, C = [f, g], S = w * d / 2;
          QT(C, !_), f = C[0], g = C[1];
          var b = S9(i);
          b.startAngle = f, b.endAngle = g, b.clockwise = _;
          var T = Math.abs(g - f), B = T, R = 0, M = f;
          if (r.setLayout({ viewRect: o, r: h }), r.each(a, function(N, F) {
            var k;
            if (isNaN(N)) {
              r.setItemLayout(F, { angle: NaN, startAngle: NaN, endAngle: NaN, clockwise: _, cx: l, cy: u, r0: c, r: I ? NaN : h });
              return;
            }
            I !== "area" ? k = y === 0 && E ? m : N * m : k = T / v, k < p ? (k = p, B -= p) : R += N;
            var O = M + w * k, Q = 0, j = 0;
            d > k ? (Q = M + w * k / 2, j = Q) : (Q = M + S, j = O - S), r.setItemLayout(F, { angle: k, startAngle: Q, endAngle: j, clockwise: _, cx: l, cy: u, r0: c, r: I ? Ne(N, x, [c, h]) : h }), M = O;
          }), B < x9 && v) if (B <= 1e-3) {
            var L = T / v;
            r.each(a, function(N, F) {
              if (!isNaN(N)) {
                var k = r.getItemLayout(F);
                k.angle = L;
                var O = 0, Q = 0;
                L < d ? (O = f + w * (F + 1 / 2) * L, Q = O) : (O = f + w * F * L + S, Q = f + w * (F + 1) * L - S), k.startAngle = O, k.endAngle = Q;
              }
            });
          } else m = B / R, M = f, r.each(a, function(N, F) {
            if (!isNaN(N)) {
              var k = r.getItemLayout(F), O = k.angle === p ? p : N * m, Q = 0, j = 0;
              O < d ? (Q = M + w * O / 2, j = Q) : (Q = M + S, j = M + w * O - S), k.startAngle = Q, k.endAngle = j, M += w * O;
            }
          });
        });
      }
      var S9 = ce();
      function ey(n) {
        return { seriesType: n, reset: function(t, e) {
          var i = e.findComponents({ mainType: "legend" });
          if (!(!i || !i.length)) {
            var r = t.getData();
            r.filterSelf(function(a) {
              for (var o = r.getName(a), s = 0; s < i.length; s++) if (!i[s].isSelected(o)) return false;
              return true;
            });
          }
        } };
      }
      var pTt = Math.PI / 180;
      function b9(n, t, e, i, r, a, o, s, l, u) {
        if (n.length < 2) return;
        function h(A) {
          for (var p = A.rB, v = p * p, y = 0; y < A.list.length; y++) {
            var m = A.list[y], _ = Math.abs(m.label.y - e), I = i + m.len, E = I * I, x = Math.sqrt((1 - Math.abs(_ * _ / v)) * E), w = t + (x + m.len2) * r, C = w - m.label.x, S = m.targetTextWidth - C * r;
            T9(m, S, true), m.label.x = w;
          }
        }
        function c(A) {
          for (var p = { list: [], maxY: 0 }, v = { list: [], maxY: 0 }, y = 0; y < A.length; y++) if (A[y].labelAlignTo === "none") {
            var m = A[y], _ = m.label.y > e ? v : p, I = Math.abs(m.label.y - e);
            if (I >= _.maxY) {
              var E = m.label.x - t - m.len2 * r, x = i + m.len, w = Math.abs(E) < x ? Math.sqrt(I * I / (1 - E * E / x / x)) : x;
              _.rB = w, _.maxY = I;
            }
            _.list.push(m);
          }
          h(p), h(v);
        }
        for (var f = n.length, g = 0; g < f; g++) if (n[g].position === "outer" && n[g].labelAlignTo === "labelLine") {
          var d = n[g].label.x - u;
          n[g].linePoints[1][0] += d, n[g].label.x = u;
        }
        pj(n, l, l + o) && c(n);
      }
      function vTt(n, t, e, i, r, a, o, s) {
        for (var l = [], u = [], h = Number.MAX_VALUE, c = -Number.MAX_VALUE, f = 0; f < n.length; f++) {
          var g = n[f].label;
          ZM(n[f]) || (g.x < t ? (h = Math.min(h, g.x), l.push(n[f])) : (c = Math.max(c, g.x), u.push(n[f])));
        }
        for (var f = 0; f < n.length; f++) {
          var d = n[f];
          if (!ZM(d) && d.linePoints) {
            if (d.labelStyleWidth != null) continue;
            var g = d.label, A = d.linePoints, p = void 0;
            d.labelAlignTo === "edge" ? g.x < t ? p = A[2][0] - d.labelDistance - o - d.edgeDistance : p = o + r - d.edgeDistance - A[2][0] - d.labelDistance : d.labelAlignTo === "labelLine" ? g.x < t ? p = h - o - d.bleedMargin : p = o + r - c - d.bleedMargin : g.x < t ? p = g.x - o - d.bleedMargin : p = o + r - g.x - d.bleedMargin, d.targetTextWidth = p, T9(d, p);
          }
        }
        b9(u, t, e, i, 1, r, a, o, s, c), b9(l, t, e, i, -1, r, a, o, s, h);
        for (var f = 0; f < n.length; f++) {
          var d = n[f];
          if (!ZM(d) && d.linePoints) {
            var g = d.label, A = d.linePoints, v = d.labelAlignTo === "edge", y = g.style.padding, m = y ? y[1] + y[3] : 0, _ = g.style.backgroundColor ? 0 : m, I = d.rect.width + _, E = A[1][0] - A[2][0];
            v ? g.x < t ? A[2][0] = o + d.edgeDistance + I + d.labelDistance : A[2][0] = o + r - d.edgeDistance - I - d.labelDistance : (g.x < t ? A[2][0] = g.x + d.labelDistance : A[2][0] = g.x - d.labelDistance, A[1][0] = A[2][0] + E), A[1][1] = A[2][1] = g.y;
          }
        }
      }
      function T9(n, t, e) {
        if (e === void 0 && (e = false), n.labelStyleWidth == null) {
          var i = n.label, r = i.style, a = n.rect, o = r.backgroundColor, s = r.padding, l = s ? s[1] + s[3] : 0, u = r.overflow, h = a.width + (o ? 0 : l);
          if (t < h || e) {
            var c = a.height;
            if (u && u.match("break")) {
              i.setStyle("backgroundColor", null), i.setStyle("width", t - l);
              var f = i.getBoundingRect();
              i.setStyle("width", Math.ceil(f.width)), i.setStyle("backgroundColor", o);
            } else {
              var g = t - l, d = t < h ? g : e ? g > n.unconstrainedWidth ? null : g : null;
              i.setStyle("width", d);
            }
            var A = i.getBoundingRect();
            a.width = A.width;
            var p = (i.style.margin || 0) + 2.1;
            a.height = A.height + p, a.y -= (a.height - c) / 2;
          }
        }
      }
      function ZM(n) {
        return n.position === "center";
      }
      function yTt(n) {
        var t = n.getData(), e = [], i, r, a = false, o = (n.get("minShowLabelAngle") || 0) * pTt, s = t.getLayout("viewRect"), l = t.getLayout("r"), u = s.width, h = s.x, c = s.y, f = s.height;
        function g(E) {
          E.ignore = true;
        }
        function d(E) {
          if (!E.ignore) return true;
          for (var x in E.states) if (E.states[x].ignore === false) return true;
          return false;
        }
        t.each(function(E) {
          var x = t.getItemGraphicEl(E), w = x.shape, C = x.getTextContent(), S = x.getTextGuideLine(), b = t.getItemModel(E), T = b.getModel("label"), B = T.get("position") || b.get(["emphasis", "label", "position"]), R = T.get("distanceToLabelLine"), M = T.get("alignTo"), L = st(T.get("edgeDistance"), u), N = T.get("bleedMargin"), F = b.getModel("labelLine"), k = F.get("length");
          k = st(k, u);
          var O = F.get("length2");
          if (O = st(O, u), Math.abs(w.endAngle - w.startAngle) < o) {
            D(C.states, g), C.ignore = true, S && (D(S.states, g), S.ignore = true);
            return;
          }
          if (d(C)) {
            var Q = (w.startAngle + w.endAngle) / 2, j = Math.cos(Q), Y = Math.sin(Q), G, $, J, et;
            i = w.cx, r = w.cy;
            var nt = B === "inside" || B === "inner";
            if (B === "center") G = w.cx, $ = w.cy, et = "center";
            else {
              var gt = (nt ? (w.r + w.r0) / 2 * j : w.r * j) + i, q = (nt ? (w.r + w.r0) / 2 * Y : w.r * Y) + r;
              if (G = gt + j * 3, $ = q + Y * 3, !nt) {
                var W = gt + j * (k + l - w.r), it = q + Y * (k + l - w.r), Ot = W + (j < 0 ? -1 : 1) * O, pt = it;
                M === "edge" ? G = j < 0 ? h + L : h + u - L : G = Ot + (j < 0 ? -R : R), $ = pt, J = [[gt, q], [W, it], [Ot, pt]];
              }
              et = nt ? "center" : M === "edge" ? j > 0 ? "right" : "left" : j > 0 ? "left" : "right";
            }
            var St = Math.PI, bt = 0, xe = T.get("rotate");
            if (ye(xe)) bt = xe * (St / 180);
            else if (B === "center") bt = 0;
            else if (xe === "radial" || xe === true) {
              var sn = j < 0 ? -Q + St : -Q;
              bt = sn;
            } else if (xe === "tangential" && B !== "outside" && B !== "outer") {
              var Ie = Math.atan2(j, Y);
              Ie < 0 && (Ie = St * 2 + Ie);
              var yn = Y > 0;
              yn && (Ie = St + Ie), bt = Ie - St;
            }
            if (a = !!bt, C.x = G, C.y = $, C.rotation = bt, C.setStyle({ verticalAlign: "middle" }), nt) {
              C.setStyle({ align: et });
              var Mr = C.states.select;
              Mr && (Mr.x += C.x, Mr.y += C.y);
            } else {
              var ln = C.getBoundingRect().clone();
              ln.applyTransform(C.getComputedTransform());
              var Br = (C.style.margin || 0) + 2.1;
              ln.y -= Br / 2, ln.height += Br, e.push({ label: C, labelLine: S, position: B, len: k, len2: O, minTurnAngle: F.get("minTurnAngle"), maxSurfaceAngle: F.get("maxSurfaceAngle"), surfaceNormal: new jt(j, Y), linePoints: J, textAlign: et, labelDistance: R, labelAlignTo: M, edgeDistance: L, bleedMargin: N, rect: ln, unconstrainedWidth: ln.width, labelStyleWidth: C.style.width });
            }
            x.setTextConfig({ inside: nt });
          }
        }), !a && n.get("avoidLabelOverlap") && vTt(e, i, r, l, u, f, h, c);
        for (var A = 0; A < e.length; A++) {
          var p = e[A], v = p.label, y = p.labelLine, m = isNaN(v.x) || isNaN(v.y);
          if (v) {
            v.setStyle({ align: p.textAlign }), m && (D(v.states, g), v.ignore = true);
            var _ = v.states.select;
            _ && (_.x += v.x, _.y += v.y);
          }
          if (y) {
            var I = p.linePoints;
            m || !I ? (D(y.states, g), y.ignore = true) : (gj(I, p.minTurnAngle), Gbt(I, p.surfaceNormal, p.maxSurfaceAngle), y.setShape({ points: I }), v.__hostTarget.textGuideLineConfig = { anchor: new jt(I[0][0], I[0][1]) });
          }
        }
      }
      var mTt = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this) || this;
          a.z2 = 2;
          var o = new Ae();
          return a.setTextContent(o), a.updateData(e, i, r, true), a;
        }
        return t.prototype.updateData = function(e, i, r, a) {
          var o = this, s = e.hostModel, l = e.getItemModel(i), u = l.getModel("emphasis"), h = e.getItemLayout(i), c = X(Ac(l.getModel("itemStyle"), h, true), h);
          if (isNaN(c.startAngle)) {
            o.setShape(c);
            return;
          }
          if (a) {
            o.setShape(c);
            var f = s.getShallow("animationType");
            s.ecModel.ssr ? (on(o, { scaleX: 0, scaleY: 0 }, s, { dataIndex: i, isFrom: true }), o.originX = c.cx, o.originY = c.cy) : f === "scale" ? (o.shape.r = h.r0, on(o, { shape: { r: h.r } }, s, i)) : r != null ? (o.setShape({ startAngle: r, endAngle: r }), on(o, { shape: { startAngle: h.startAngle, endAngle: h.endAngle } }, s, i)) : (o.shape.endAngle = h.startAngle, Ee(o, { shape: { endAngle: h.endAngle } }, s, i));
          } else to(o), Ee(o, { shape: c }, s, i);
          o.useStyle(e.getItemVisual(i, "style")), Ii(o, l);
          var g = (h.startAngle + h.endAngle) / 2, d = s.get("selectedOffset"), A = Math.cos(g) * d, p = Math.sin(g) * d, v = l.getShallow("cursor");
          v && o.attr("cursor", v), this._updateLabel(s, e, i), o.ensureState("emphasis").shape = X({ r: h.r + (u.get("scale") && u.get("scaleSize") || 0) }, Ac(u.getModel("itemStyle"), h)), X(o.ensureState("select"), { x: A, y: p, shape: Ac(l.getModel(["select", "itemStyle"]), h) }), X(o.ensureState("blur"), { shape: Ac(l.getModel(["blur", "itemStyle"]), h) });
          var y = o.getTextGuideLine(), m = o.getTextContent();
          y && X(y.ensureState("select"), { x: A, y: p }), X(m.ensureState("select"), { x: A, y: p }), pn(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
        }, t.prototype._updateLabel = function(e, i, r) {
          var a = this, o = i.getItemModel(r), s = o.getModel("labelLine"), l = i.getItemVisual(r, "style"), u = l && l.fill, h = l && l.opacity;
          xi(a, Jn(o), { labelFetcher: i.hostModel, labelDataIndex: r, inheritColor: u, defaultOpacity: h, defaultText: e.getFormattedLabel(r, "normal") || i.getName(r) });
          var c = a.getTextContent();
          a.setTextConfig({ position: null, rotation: null }), c.attr({ z2: 10 });
          var f = e.get(["label", "position"]);
          if (f !== "outside" && f !== "outer") a.removeTextGuideLine();
          else {
            var g = this.getTextGuideLine();
            g || (g = new Ji(), this.setTextGuideLine(g)), BM(this, MM(o), { stroke: u, opacity: fa(s.get(["lineStyle", "opacity"]), h, 1) });
          }
        }, t;
      }(Zi), _Tt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.ignoreLabelLineUpdate = true, e;
        }
        return t.prototype.render = function(e, i, r, a) {
          var o = e.getData(), s = this._data, l = this.group, u;
          if (!s && o.count() > 0) {
            for (var h = o.getItemLayout(0), c = 1; isNaN(h && h.startAngle) && c < o.count(); ++c) h = o.getItemLayout(c);
            h && (u = h.startAngle);
          }
          if (this._emptyCircleSector && l.remove(this._emptyCircleSector), o.count() === 0 && e.get("showEmptyCircle")) {
            var f = S9(e), g = new Zi({ shape: X(C9(e, r), f) });
            g.useStyle(e.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = g, l.add(g);
          }
          o.diff(s).add(function(d) {
            var A = new mTt(o, d, u);
            o.setItemGraphicEl(d, A), l.add(A);
          }).update(function(d, A) {
            var p = s.getItemGraphicEl(A);
            p.updateData(o, d, u), p.off("click"), l.add(p), o.setItemGraphicEl(d, p);
          }).remove(function(d) {
            var A = s.getItemGraphicEl(d);
            Av(A, e, d);
          }).execute(), yTt(e), e.get("animationTypeUpdate") !== "expansion" && (this._data = o);
        }, t.prototype.dispose = function() {
        }, t.prototype.containPoint = function(e, i) {
          var r = i.getData(), a = r.getItemLayout(0);
          if (a) {
            var o = e[0] - a.cx, s = e[1] - a.cy, l = Math.sqrt(o * o + s * s);
            return l <= a.r && l >= a.r0;
          }
        }, t.type = "pie", t;
      }(qe);
      function vd(n, t, e) {
        t = Z(t) && { coordDimensions: t } || X({ encodeDefine: n.getEncode() }, t);
        var i = n.getSource(), r = Uv(i, t).dimensions, a = new er(r, n);
        return a.initData(i, e), a;
      }
      var ny = function() {
        function n(t, e) {
          this._getDataWithEncodedVisual = t, this._getRawData = e;
        }
        return n.prototype.getAllNames = function() {
          var t = this._getRawData();
          return t.mapArray(t.getName);
        }, n.prototype.containName = function(t) {
          var e = this._getRawData();
          return e.indexOfName(t) >= 0;
        }, n.prototype.indexOfName = function(t) {
          var e = this._getDataWithEncodedVisual();
          return e.indexOfName(t);
        }, n.prototype.getItemVisual = function(t, e) {
          var i = this._getDataWithEncodedVisual();
          return i.getItemVisual(t, e);
        }, n;
      }(), ETt = ce(), ITt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.init = function(e) {
          n.prototype.init.apply(this, arguments), this.legendVisualProvider = new ny(ct(this.getData, this), ct(this.getRawData, this)), this._defaultLabelLine(e);
        }, t.prototype.mergeOption = function() {
          n.prototype.mergeOption.apply(this, arguments);
        }, t.prototype.getInitialData = function() {
          return vd(this, { coordDimensions: ["value"], encodeDefaulter: Gt(xB, this) });
        }, t.prototype.getDataParams = function(e) {
          var i = this.getData(), r = ETt(i), a = r.seats;
          if (!a) {
            var o = [];
            i.each(i.mapDimension("value"), function(l) {
              o.push(l);
            }), a = r.seats = uEt(o, i.hostModel.get("percentPrecision"));
          }
          var s = n.prototype.getDataParams.call(this, e);
          return s.percent = a[e] || 0, s.$vars.push("percent"), s;
        }, t.prototype._defaultLabelLine = function(e) {
          Th(e, "labelLine", ["show"]);
          var i = e.labelLine, r = e.emphasis.labelLine;
          i.show = i.show && e.label.show, r.show = r.show && e.emphasis.label.show;
        }, t.type = "series.pie", t.defaultOption = { z: 2, legendHoverLink: true, colorBy: "data", center: ["50%", "50%"], radius: [0, "75%"], clockwise: true, startAngle: 90, endAngle: "auto", padAngle: 0, minAngle: 0, minShowLabelAngle: 0, selectedOffset: 10, percentPrecision: 2, stillShowZeroSum: true, left: 0, top: 0, right: 0, bottom: 0, width: null, height: null, label: { rotate: 0, show: true, overflow: "truncate", position: "outer", alignTo: "none", edgeDistance: "25%", bleedMargin: 10, distanceToLabelLine: 5 }, labelLine: { show: true, length: 15, length2: 15, smooth: false, minTurnAngle: 90, maxSurfaceAngle: 90, lineStyle: { width: 1, type: "solid" } }, itemStyle: { borderWidth: 1, borderJoin: "round" }, showEmptyCircle: true, emptyCircleStyle: { color: "lightgray", opacity: 1 }, labelLayout: { hideOverlap: true }, emphasis: { scale: true, scaleSize: 5 }, avoidLabelOverlap: true, animationType: "expansion", animationDuration: 1e3, animationTypeUpdate: "transition", animationEasingUpdate: "cubicInOut", animationDurationUpdate: 500, animationEasing: "cubicInOut" }, t;
      }(tn);
      function xTt(n) {
        return { seriesType: n, reset: function(t, e) {
          var i = t.getData();
          i.filterSelf(function(r) {
            var a = i.mapDimension("value"), o = i.get(a, r);
            return !(ye(o) && !isNaN(o) && o < 0);
          });
        } };
      }
      function wTt(n) {
        n.registerChartView(_Tt), n.registerSeriesModel(ITt), LU("pie", n.registerAction), n.registerLayout(Gt(ATt, "pie")), n.registerProcessor(ey("pie")), n.registerProcessor(xTt("pie"));
      }
      var CTt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.hasSymbolVisual = true, e;
        }
        return t.prototype.getInitialData = function(e, i) {
          return tl(null, this, { useEncodeDefaulter: true });
        }, t.prototype.getProgressive = function() {
          var e = this.option.progressive;
          return e == null ? this.option.large ? 5e3 : this.get("progressive") : e;
        }, t.prototype.getProgressiveThreshold = function() {
          var e = this.option.progressiveThreshold;
          return e == null ? this.option.large ? 1e4 : this.get("progressiveThreshold") : e;
        }, t.prototype.brushSelector = function(e, i, r) {
          return r.point(i.getItemLayout(e));
        }, t.prototype.getZLevelKey = function() {
          return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
        }, t.type = "series.scatter", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], t.defaultOption = { coordinateSystem: "cartesian2d", z: 2, legendHoverLink: true, symbolSize: 10, large: false, largeThreshold: 2e3, itemStyle: { opacity: 0.8 }, emphasis: { scale: true }, clip: true, select: { itemStyle: { borderColor: "#212121" } }, universalTransition: { divideShape: "clone" } }, t;
      }(tn), B9 = 4, STt = /* @__PURE__ */ function() {
        function n() {
        }
        return n;
      }(), bTt = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i._off = 0, i.hoverDataIdx = -1, i;
        }
        return t.prototype.getDefaultShape = function() {
          return new STt();
        }, t.prototype.reset = function() {
          this.notClear = false, this._off = 0;
        }, t.prototype.buildPath = function(e, i) {
          var r = i.points, a = i.size, o = this.symbolProxy, s = o.shape, l = e.getContext ? e.getContext() : e, u = l && a[0] < B9, h = this.softClipShape, c;
          if (u) {
            this._ctx = l;
            return;
          }
          for (this._ctx = null, c = this._off; c < r.length; ) {
            var f = r[c++], g = r[c++];
            isNaN(f) || isNaN(g) || h && !h.contain(f, g) || (s.x = f - a[0] / 2, s.y = g - a[1] / 2, s.width = a[0], s.height = a[1], o.buildPath(e, s, true));
          }
          this.incremental && (this._off = c, this.notClear = true);
        }, t.prototype.afterBrush = function() {
          var e = this.shape, i = e.points, r = e.size, a = this._ctx, o = this.softClipShape, s;
          if (a) {
            for (s = this._off; s < i.length; ) {
              var l = i[s++], u = i[s++];
              isNaN(l) || isNaN(u) || o && !o.contain(l, u) || a.fillRect(l - r[0] / 2, u - r[1] / 2, r[0], r[1]);
            }
            this.incremental && (this._off = s, this.notClear = true);
          }
        }, t.prototype.findDataIndex = function(e, i) {
          for (var r = this.shape, a = r.points, o = r.size, s = Math.max(o[0], 4), l = Math.max(o[1], 4), u = a.length / 2 - 1; u >= 0; u--) {
            var h = u * 2, c = a[h] - s / 2, f = a[h + 1] - l / 2;
            if (e >= c && i >= f && e <= c + s && i <= f + l) return u;
          }
          return -1;
        }, t.prototype.contain = function(e, i) {
          var r = this.transformCoordToLocal(e, i), a = this.getBoundingRect();
          if (e = r[0], i = r[1], a.contain(e, i)) {
            var o = this.hoverDataIdx = this.findDataIndex(e, i);
            return o >= 0;
          }
          return this.hoverDataIdx = -1, false;
        }, t.prototype.getBoundingRect = function() {
          var e = this._rect;
          if (!e) {
            for (var i = this.shape, r = i.points, a = i.size, o = a[0], s = a[1], l = 1 / 0, u = 1 / 0, h = -1 / 0, c = -1 / 0, f = 0; f < r.length; ) {
              var g = r[f++], d = r[f++];
              l = Math.min(g, l), h = Math.max(g, h), u = Math.min(d, u), c = Math.max(d, c);
            }
            e = this._rect = new Wt(l - o / 2, u - s / 2, h - l + o, c - u + s);
          }
          return e;
        }, t;
      }(ne), TTt = function() {
        function n() {
          this.group = new Dt();
        }
        return n.prototype.updateData = function(t, e) {
          this._clear();
          var i = this._create();
          i.setShape({ points: t.getLayout("points") }), this._setCommon(i, t, e);
        }, n.prototype.updateLayout = function(t) {
          var e = t.getLayout("points");
          this.group.eachChild(function(i) {
            if (i.startIndex != null) {
              var r = (i.endIndex - i.startIndex) * 2, a = i.startIndex * 4 * 2;
              e = new Float32Array(e.buffer, a, r);
            }
            i.setShape("points", e), i.reset();
          });
        }, n.prototype.incrementalPrepareUpdate = function(t) {
          this._clear();
        }, n.prototype.incrementalUpdate = function(t, e, i) {
          var r = this._newAdded[0], a = e.getLayout("points"), o = r && r.shape.points;
          if (o && o.length < 2e4) {
            var s = o.length, l = new Float32Array(s + a.length);
            l.set(o), l.set(a, s), r.endIndex = t.end, r.setShape({ points: l });
          } else {
            this._newAdded = [];
            var u = this._create();
            u.startIndex = t.start, u.endIndex = t.end, u.incremental = true, u.setShape({ points: a }), this._setCommon(u, e, i);
          }
        }, n.prototype.eachRendered = function(t) {
          this._newAdded[0] && t(this._newAdded[0]);
        }, n.prototype._create = function() {
          var t = new bTt({ cursor: "default" });
          return t.ignoreCoarsePointer = true, this.group.add(t), this._newAdded.push(t), t;
        }, n.prototype._setCommon = function(t, e, i) {
          var r = e.hostModel;
          i = i || {};
          var a = e.getVisual("symbolSize");
          t.setShape("size", a instanceof Array ? a : [a, a]), t.softClipShape = i.clipShape || null, t.symbolProxy = Un(e.getVisual("symbol"), 0, 0, 0, 0), t.setColor = t.symbolProxy.setColor;
          var o = t.shape.size[0] < B9;
          t.useStyle(r.getModel("itemStyle").getItemStyle(o ? ["color", "shadowBlur", "shadowColor"] : ["color"]));
          var s = e.getVisual("style"), l = s && s.fill;
          l && t.setColor(l);
          var u = Nt(t);
          u.seriesIndex = r.seriesIndex, t.on("mousemove", function(h) {
            u.dataIndex = null;
            var c = t.hoverDataIdx;
            c >= 0 && (u.dataIndex = c + (t.startIndex || 0));
          });
        }, n.prototype.remove = function() {
          this._clear();
        }, n.prototype._clear = function() {
          this._newAdded = [], this.group.removeAll();
        }, n;
      }(), BTt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = e.getData(), o = this._updateSymbolDraw(a, e);
          o.updateData(a, { clipShape: this._getClipShape(e) }), this._finished = true;
        }, t.prototype.incrementalPrepareRender = function(e, i, r) {
          var a = e.getData(), o = this._updateSymbolDraw(a, e);
          o.incrementalPrepareUpdate(a), this._finished = false;
        }, t.prototype.incrementalRender = function(e, i, r) {
          this._symbolDraw.incrementalUpdate(e, i.getData(), { clipShape: this._getClipShape(i) }), this._finished = e.end === i.getData().count();
        }, t.prototype.updateTransform = function(e, i, r) {
          var a = e.getData();
          if (this.group.dirty(), !this._finished || a.count() > 1e4) return { update: true };
          var o = Jv("").reset(e, i, r);
          o.progress && o.progress({ start: 0, end: a.count(), count: a.count() }, a), this._symbolDraw.updateLayout(a);
        }, t.prototype.eachRendered = function(e) {
          this._symbolDraw && this._symbolDraw.eachRendered(e);
        }, t.prototype._getClipShape = function(e) {
          if (e.get("clip", true)) {
            var i = e.coordinateSystem;
            return i && i.getArea && i.getArea(0.1);
          }
        }, t.prototype._updateSymbolDraw = function(e, i) {
          var r = this._symbolDraw, a = i.pipelineContext, o = a.large;
          return (!r || o !== this._isLargeDraw) && (r && r.remove(), r = this._symbolDraw = o ? new TTt() : new Zv(), this._isLargeDraw = o, this.group.removeAll()), this.group.add(r.group), r;
        }, t.prototype.remove = function(e, i) {
          this._symbolDraw && this._symbolDraw.remove(true), this._symbolDraw = null;
        }, t.prototype.dispose = function() {
        }, t.type = "scatter", t;
      }(qe), MTt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.type = "grid", t.dependencies = ["xAxis", "yAxis"], t.layoutMode = "box", t.defaultOption = { show: false, z: 0, left: "10%", top: 60, right: "10%", bottom: 70, containLabel: false, backgroundColor: "rgba(0,0,0,0)", borderWidth: 1, borderColor: "#ccc" }, t;
      }(ae), KM = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.getCoordSysModel = function() {
          return this.getReferringComponents("grid", zn).models[0];
        }, t.type = "cartesian2dAxis", t;
      }(ae);
      kn(KM, jv);
      var M9 = { show: true, z: 0, inverse: false, name: "", nameLocation: "end", nameRotate: null, nameTruncate: { maxWidth: null, ellipsis: "...", placeholder: "." }, nameTextStyle: {}, nameGap: 15, silent: false, triggerEvent: false, tooltip: { show: false }, axisPointer: {}, axisLine: { show: true, onZero: true, onZeroAxisIndex: null, lineStyle: { color: "#6E7079", width: 1, type: "solid" }, symbol: ["none", "none"], symbolSize: [10, 15] }, axisTick: { show: true, inside: false, length: 5, lineStyle: { width: 1 } }, axisLabel: { show: true, inside: false, rotate: 0, showMinLabel: null, showMaxLabel: null, margin: 8, fontSize: 12 }, splitLine: { show: true, lineStyle: { color: ["#E0E6F1"], width: 1, type: "solid" } }, splitArea: { show: false, areaStyle: { color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"] } } }, DTt = Yt({ boundaryGap: true, deduplication: null, splitLine: { show: false }, axisTick: { alignWithLabel: false, interval: "auto" }, axisLabel: { interval: "auto" } }, M9), JM = Yt({ boundaryGap: [0, 0], axisLine: { show: "auto" }, axisTick: { show: "auto" }, splitNumber: 5, minorTick: { show: false, splitNumber: 5, length: 3, lineStyle: {} }, minorSplitLine: { show: false, lineStyle: { color: "#F4F7FD", width: 1 } } }, M9), RTt = Yt({ splitNumber: 6, axisLabel: { showMinLabel: false, showMaxLabel: false, rich: { primary: { fontWeight: "bold" } } }, splitLine: { show: false } }, JM), LTt = wt({ logBase: 10 }, JM);
      const D9 = { category: DTt, value: JM, time: RTt, log: LTt };
      var PTt = { value: 1, category: 1, time: 1, log: 1 };
      function yd(n, t, e, i) {
        D(PTt, function(r, a) {
          var o = Yt(Yt({}, D9[a], true), i, true), s = function(l) {
            V(u, l);
            function u() {
              var h = l !== null && l.apply(this, arguments) || this;
              return h.type = t + "Axis." + a, h;
            }
            return u.prototype.mergeDefaultAndTheme = function(h, c) {
              var f = Iv(this), g = f ? Kg(h) : {}, d = c.getTheme();
              Yt(h, d.get(a + "Axis")), Yt(h, this.getDefaultOption()), h.type = R9(h), f && gu(h, g, f);
            }, u.prototype.optionUpdated = function() {
              var h = this.option;
              h.type === "category" && (this.__ordinalMeta = pM.createByAxisModel(this));
            }, u.prototype.getCategories = function(h) {
              var c = this.option;
              if (c.type === "category") return h ? c.data : this.__ordinalMeta.categories;
            }, u.prototype.getOrdinalMeta = function() {
              return this.__ordinalMeta;
            }, u.type = t + "Axis." + a, u.defaultOption = o, u;
          }(e);
          n.registerComponentModel(s);
        }), n.registerSubTypeDefaulter(t + "Axis", R9);
      }
      function R9(n) {
        return n.type || (n.data ? "category" : "value");
      }
      var NTt = function() {
        function n(t) {
          this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = t || "";
        }
        return n.prototype.getAxis = function(t) {
          return this._axes[t];
        }, n.prototype.getAxes = function() {
          return K(this._dimList, function(t) {
            return this._axes[t];
          }, this);
        }, n.prototype.getAxesByScale = function(t) {
          return t = t.toLowerCase(), Fe(this.getAxes(), function(e) {
            return e.scale.type === t;
          });
        }, n.prototype.addAxis = function(t) {
          var e = t.dim;
          this._axes[e] = t, this._dimList.push(e);
        }, n;
      }(), tD = ["x", "y"];
      function L9(n) {
        return n.type === "interval" || n.type === "time";
      }
      var FTt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "cartesian2d", e.dimensions = tD, e;
        }
        return t.prototype.calcAffineTransform = function() {
          this._transform = this._invTransform = null;
          var e = this.getAxis("x").scale, i = this.getAxis("y").scale;
          if (!(!L9(e) || !L9(i))) {
            var r = e.getExtent(), a = i.getExtent(), o = this.dataToPoint([r[0], a[0]]), s = this.dataToPoint([r[1], a[1]]), l = r[1] - r[0], u = a[1] - a[0];
            if (!(!l || !u)) {
              var h = (s[0] - o[0]) / l, c = (s[1] - o[1]) / u, f = o[0] - r[0] * h, g = o[1] - a[0] * c, d = this._transform = [h, 0, 0, c, f, g];
              this._invTransform = Sg([], d);
            }
          }
        }, t.prototype.getBaseAxis = function() {
          return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
        }, t.prototype.containPoint = function(e) {
          var i = this.getAxis("x"), r = this.getAxis("y");
          return i.contain(i.toLocalCoord(e[0])) && r.contain(r.toLocalCoord(e[1]));
        }, t.prototype.containData = function(e) {
          return this.getAxis("x").containData(e[0]) && this.getAxis("y").containData(e[1]);
        }, t.prototype.containZone = function(e, i) {
          var r = this.dataToPoint(e), a = this.dataToPoint(i), o = this.getArea(), s = new Wt(r[0], r[1], a[0] - r[0], a[1] - r[1]);
          return o.intersect(s);
        }, t.prototype.dataToPoint = function(e, i, r) {
          r = r || [];
          var a = e[0], o = e[1];
          if (this._transform && a != null && isFinite(a) && o != null && isFinite(o)) return _i(r, e, this._transform);
          var s = this.getAxis("x"), l = this.getAxis("y");
          return r[0] = s.toGlobalCoord(s.dataToCoord(a, i)), r[1] = l.toGlobalCoord(l.dataToCoord(o, i)), r;
        }, t.prototype.clampData = function(e, i) {
          var r = this.getAxis("x").scale, a = this.getAxis("y").scale, o = r.getExtent(), s = a.getExtent(), l = r.parse(e[0]), u = a.parse(e[1]);
          return i = i || [], i[0] = Math.min(Math.max(Math.min(o[0], o[1]), l), Math.max(o[0], o[1])), i[1] = Math.min(Math.max(Math.min(s[0], s[1]), u), Math.max(s[0], s[1])), i;
        }, t.prototype.pointToData = function(e, i) {
          var r = [];
          if (this._invTransform) return _i(r, e, this._invTransform);
          var a = this.getAxis("x"), o = this.getAxis("y");
          return r[0] = a.coordToData(a.toLocalCoord(e[0]), i), r[1] = o.coordToData(o.toLocalCoord(e[1]), i), r;
        }, t.prototype.getOtherAxis = function(e) {
          return this.getAxis(e.dim === "x" ? "y" : "x");
        }, t.prototype.getArea = function(e) {
          e = e || 0;
          var i = this.getAxis("x").getGlobalExtent(), r = this.getAxis("y").getGlobalExtent(), a = Math.min(i[0], i[1]) - e, o = Math.min(r[0], r[1]) - e, s = Math.max(i[0], i[1]) - a + e, l = Math.max(r[0], r[1]) - o + e;
          return new Wt(a, o, s, l);
        }, t;
      }(NTt), kTt = function(n) {
        V(t, n);
        function t(e, i, r, a, o) {
          var s = n.call(this, e, i, r) || this;
          return s.index = 0, s.type = a || "value", s.position = o || "bottom", s;
        }
        return t.prototype.isHorizontal = function() {
          var e = this.position;
          return e === "top" || e === "bottom";
        }, t.prototype.getGlobalExtent = function(e) {
          var i = this.getExtent();
          return i[0] = this.toGlobalCoord(i[0]), i[1] = this.toGlobalCoord(i[1]), e && i[0] > i[1] && i.reverse(), i;
        }, t.prototype.pointToData = function(e, i) {
          return this.coordToData(this.toLocalCoord(e[this.dim === "x" ? 0 : 1]), i);
        }, t.prototype.setCategorySortInfo = function(e) {
          if (this.type !== "category") return false;
          this.model.option.categorySortInfo = e, this.scale.setSortInfo(e);
        }, t;
      }(ao);
      function eD(n, t, e) {
        e = e || {};
        var i = n.coordinateSystem, r = t.axis, a = {}, o = r.getAxesOnZeroOf()[0], s = r.position, l = o ? "onZero" : s, u = r.dim, h = i.getRect(), c = [h.x, h.x + h.width, h.y, h.y + h.height], f = { left: 0, right: 1, top: 0, bottom: 1, onZero: 2 }, g = t.get("offset") || 0, d = u === "x" ? [c[2] - g, c[3] + g] : [c[0] - g, c[1] + g];
        if (o) {
          var A = o.toGlobalCoord(o.dataToCoord(0));
          d[f.onZero] = Math.max(Math.min(A, d[1]), d[0]);
        }
        a.position = [u === "y" ? d[f[l]] : c[0], u === "x" ? d[f[l]] : c[3]], a.rotation = Math.PI / 2 * (u === "x" ? 0 : 1);
        var p = { top: -1, bottom: 1, left: -1, right: 1 };
        a.labelDirection = a.tickDirection = a.nameDirection = p[s], a.labelOffset = o ? d[f[s]] - d[f.onZero] : 0, t.get(["axisTick", "inside"]) && (a.tickDirection = -a.tickDirection), On(e.labelInside, t.get(["axisLabel", "inside"])) && (a.labelDirection = -a.labelDirection);
        var v = t.get(["axisLabel", "rotate"]);
        return a.labelRotate = l === "top" ? -v : v, a.z2 = 1, a;
      }
      function P9(n) {
        return n.get("coordinateSystem") === "cartesian2d";
      }
      function N9(n) {
        var t = { xAxisModel: null, yAxisModel: null };
        return D(t, function(e, i) {
          var r = i.replace(/Model$/, ""), a = n.getReferringComponents(r, zn).models[0];
          if (!a) throw new Error(r + ' "' + fa(n.get(r + "Index"), n.get(r + "Id"), 0) + '" not found');
          t[i] = a;
        }), t;
      }
      var nD = Math.log;
      function F9(n, t, e) {
        var i = el.prototype, r = i.getTicks.call(e), a = i.getTicks.call(e, true), o = r.length - 1, s = i.getInterval.call(e), l = YV(n, t), u = l.extent, h = l.fixMin, c = l.fixMax;
        if (n.type === "log") {
          var f = nD(n.base);
          u = [nD(u[0]) / f, nD(u[1]) / f];
        }
        n.setExtent(u[0], u[1]), n.calcNiceExtent({ splitNumber: o, fixMin: h, fixMax: c });
        var g = i.getExtent.call(n);
        h && (u[0] = g[0]), c && (u[1] = g[1]);
        var d = i.getInterval.call(n), A = u[0], p = u[1];
        if (h && c) d = (p - A) / o;
        else if (h) for (p = u[0] + d * o; p < u[1] && isFinite(p) && isFinite(u[1]); ) d = yM(d), p = u[0] + d * o;
        else if (c) for (A = u[1] - d * o; A > u[0] && isFinite(A) && isFinite(u[0]); ) d = yM(d), A = u[1] - d * o;
        else {
          var v = n.getTicks().length - 1;
          v > o && (d = yM(d));
          var y = d * o;
          p = Math.ceil(u[1] / d) * d, A = En(p - y), A < 0 && u[0] >= 0 ? (A = 0, p = En(y)) : p > 0 && u[1] <= 0 && (p = 0, A = -En(y));
        }
        var m = (r[0].value - a[0].value) / s, _ = (r[o].value - a[o].value) / s;
        if (i.setExtent.call(n, A + d * m, p + d * _), i.setInterval.call(n, d), (m || _) && i.setNiceExtent.call(n, A + d, p - d), true) {
          var I = i.getTicks.call(n);
          I[1] && (!WSt(d) || yT(I[1].value) > yT(d)) && gn("The ticks may be not readable when set min: " + t.get("min") + ", max: " + t.get("max") + " and alignTicks: true");
        }
      }
      var OTt = function() {
        function n(t, e, i) {
          this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = true, this.dimensions = tD, this._initCartesian(t, e, i), this.model = t;
        }
        return n.prototype.getRect = function() {
          return this._rect;
        }, n.prototype.update = function(t, e) {
          var i = this._axesMap;
          this._updateScale(t, this.model);
          function r(o) {
            var s, l = oe(o), u = l.length;
            if (u) {
              for (var h = [], c = u - 1; c >= 0; c--) {
                var f = +l[c], g = o[f], d = g.model, A = g.scale;
                vM(A) && d.get("alignTicks") && d.get("interval") == null ? h.push(g) : (gd(A, d), vM(A) && (s = g));
              }
              h.length && (s || (s = h.pop(), gd(s.scale, s.model)), D(h, function(p) {
                F9(p.scale, p.model, s.scale);
              }));
            }
          }
          r(i.x), r(i.y);
          var a = {};
          D(i.x, function(o) {
            k9(i, "y", o, a);
          }), D(i.y, function(o) {
            k9(i, "x", o, a);
          }), this.resize(this.model, e);
        }, n.prototype.resize = function(t, e, i) {
          var r = t.getBoxLayoutParams(), a = !i && t.get("containLabel"), o = Yn(r, { width: e.getWidth(), height: e.getHeight() });
          this._rect = o;
          var s = this._axesList;
          l(), a && (D(s, function(u) {
            if (!u.model.get(["axisLabel", "inside"])) {
              var h = ybt(u);
              if (h) {
                var c = u.isHorizontal() ? "height" : "width", f = u.model.get(["axisLabel", "margin"]);
                o[c] -= h[c] + f, u.position === "top" ? o.y += h.height + f : u.position === "left" && (o.x += h.width + f);
              }
            }
          }), l()), D(this._coordsList, function(u) {
            u.calcAffineTransform();
          });
          function l() {
            D(s, function(u) {
              var h = u.isHorizontal(), c = h ? [0, o.width] : [0, o.height], f = u.inverse ? 1 : 0;
              u.setExtent(c[f], c[1 - f]), QTt(u, h ? o.x : o.y);
            });
          }
        }, n.prototype.getAxis = function(t, e) {
          var i = this._axesMap[t];
          if (i != null) return i[e || 0];
        }, n.prototype.getAxes = function() {
          return this._axesList.slice();
        }, n.prototype.getCartesian = function(t, e) {
          if (t != null && e != null) {
            var i = "x" + t + "y" + e;
            return this._coordsMap[i];
          }
          Et(t) && (e = t.yAxisIndex, t = t.xAxisIndex);
          for (var r = 0, a = this._coordsList; r < a.length; r++) if (a[r].getAxis("x").index === t || a[r].getAxis("y").index === e) return a[r];
        }, n.prototype.getCartesians = function() {
          return this._coordsList.slice();
        }, n.prototype.convertToPixel = function(t, e, i) {
          var r = this._findConvertTarget(e);
          return r.cartesian ? r.cartesian.dataToPoint(i) : r.axis ? r.axis.toGlobalCoord(r.axis.dataToCoord(i)) : null;
        }, n.prototype.convertFromPixel = function(t, e, i) {
          var r = this._findConvertTarget(e);
          return r.cartesian ? r.cartesian.pointToData(i) : r.axis ? r.axis.coordToData(r.axis.toLocalCoord(i)) : null;
        }, n.prototype._findConvertTarget = function(t) {
          var e = t.seriesModel, i = t.xAxisModel || e && e.getReferringComponents("xAxis", zn).models[0], r = t.yAxisModel || e && e.getReferringComponents("yAxis", zn).models[0], a = t.gridModel, o = this._coordsList, s, l;
          if (e) s = e.coordinateSystem, $t(o, s) < 0 && (s = null);
          else if (i && r) s = this.getCartesian(i.componentIndex, r.componentIndex);
          else if (i) l = this.getAxis("x", i.componentIndex);
          else if (r) l = this.getAxis("y", r.componentIndex);
          else if (a) {
            var u = a.coordinateSystem;
            u === this && (s = this._coordsList[0]);
          }
          return { cartesian: s, axis: l };
        }, n.prototype.containPoint = function(t) {
          var e = this._coordsList[0];
          if (e) return e.containPoint(t);
        }, n.prototype._initCartesian = function(t, e, i) {
          var r = this, a = this, o = { left: false, right: false, top: false, bottom: false }, s = { x: {}, y: {} }, l = { x: 0, y: 0 };
          if (e.eachComponent("xAxis", u("x"), this), e.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
            this._axesMap = {}, this._axesList = [];
            return;
          }
          this._axesMap = s, D(s.x, function(h, c) {
            D(s.y, function(f, g) {
              var d = "x" + c + "y" + g, A = new FTt(d);
              A.master = r, A.model = t, r._coordsMap[d] = A, r._coordsList.push(A), A.addAxis(h), A.addAxis(f);
            });
          });
          function u(h) {
            return function(c, f) {
              if (iD(c, t)) {
                var g = c.get("position");
                h === "x" ? g !== "top" && g !== "bottom" && (g = o.bottom ? "top" : "bottom") : g !== "left" && g !== "right" && (g = o.left ? "right" : "left"), o[g] = true;
                var d = new kTt(h, FE(c), [0, 0], c.get("type"), g), A = d.type === "category";
                d.onBand = A && c.get("boundaryGap"), d.inverse = c.get("inverse"), c.axis = d, d.model = c, d.grid = a, d.index = f, a._axesList.push(d), s[h][f] = d, l[h]++;
              }
            };
          }
        }, n.prototype._updateScale = function(t, e) {
          D(this._axesList, function(r) {
            if (r.scale.setExtent(1 / 0, -1 / 0), r.type === "category") {
              var a = r.model.get("categorySortInfo");
              r.scale.setSortInfo(a);
            }
          }), t.eachSeries(function(r) {
            if (P9(r)) {
              var a = N9(r), o = a.xAxisModel, s = a.yAxisModel;
              if (!iD(o, e) || !iD(s, e)) return;
              var l = this.getCartesian(o.componentIndex, s.componentIndex), u = r.getData(), h = l.getAxis("x"), c = l.getAxis("y");
              i(u, h), i(u, c);
            }
          }, this);
          function i(r, a) {
            D(kE(r, a.dim), function(o) {
              a.scale.unionExtentFromData(r, o);
            });
          }
        }, n.prototype.getTooltipAxes = function(t) {
          var e = [], i = [];
          return D(this.getCartesians(), function(r) {
            var a = t != null && t !== "auto" ? r.getAxis(t) : r.getBaseAxis(), o = r.getOtherAxis(a);
            $t(e, a) < 0 && e.push(a), $t(i, o) < 0 && i.push(o);
          }), { baseAxes: e, otherAxes: i };
        }, n.create = function(t, e) {
          var i = [];
          return t.eachComponent("grid", function(r, a) {
            var o = new n(r, t, e);
            o.name = "grid_" + a, o.resize(r, e, true), r.coordinateSystem = o, i.push(o);
          }), t.eachSeries(function(r) {
            if (P9(r)) {
              var a = N9(r), o = a.xAxisModel, s = a.yAxisModel, l = o.getCoordSysModel();
              if (true) {
                if (!l) throw new Error('Grid "' + fa(o.get("gridIndex"), o.get("gridId"), 0) + '" not found');
                if (o.getCoordSysModel() !== s.getCoordSysModel()) throw new Error("xAxis and yAxis must use the same grid");
              }
              var u = l.coordinateSystem;
              r.coordinateSystem = u.getCartesian(o.componentIndex, s.componentIndex);
            }
          }), i;
        }, n.dimensions = tD, n;
      }();
      function iD(n, t) {
        return n.getCoordSysModel() === t;
      }
      function k9(n, t, e, i) {
        e.getAxesOnZeroOf = function() {
          return a ? [a] : [];
        };
        var r = n[t], a, o = e.model, s = o.get(["axisLine", "onZero"]), l = o.get(["axisLine", "onZeroAxisIndex"]);
        if (!s) return;
        if (l != null) O9(r[l]) && (a = r[l]);
        else for (var u in r) if (r.hasOwnProperty(u) && O9(r[u]) && !i[h(r[u])]) {
          a = r[u];
          break;
        }
        a && (i[h(a)] = true);
        function h(c) {
          return c.dim + "_" + c.index;
        }
      }
      function O9(n) {
        return n && n.type !== "category" && n.type !== "time" && vbt(n);
      }
      function QTt(n, t) {
        var e = n.getExtent(), i = e[0] + e[1];
        n.toGlobalCoord = n.dim === "x" ? function(r) {
          return r + t;
        } : function(r) {
          return i - r + t;
        }, n.toLocalCoord = n.dim === "x" ? function(r) {
          return r - t;
        } : function(r) {
          return i - r + t;
        };
      }
      var Iu = Math.PI, rr = function() {
        function n(t, e) {
          this.group = new Dt(), this.opt = e, this.axisModel = t, wt(e, { labelOffset: 0, nameDirection: 1, tickDirection: 1, labelDirection: 1, silent: true, handleAutoShown: function() {
            return true;
          } });
          var i = new Dt({ x: e.position[0], y: e.position[1], rotation: e.rotation });
          i.updateTransform(), this._transformGroup = i;
        }
        return n.prototype.hasBuilder = function(t) {
          return !!Q9[t];
        }, n.prototype.add = function(t) {
          Q9[t](this.opt, this.axisModel, this.group, this._transformGroup);
        }, n.prototype.getGroup = function() {
          return this.group;
        }, n.innerTextLayout = function(t, e, i) {
          var r = o4(e - t), a, o;
          return Jp(r) ? (o = i > 0 ? "top" : "bottom", a = "center") : Jp(r - Iu) ? (o = i > 0 ? "bottom" : "top", a = "center") : (o = "middle", r > 0 && r < Iu ? a = i > 0 ? "right" : "left" : a = i > 0 ? "left" : "right"), { rotation: r, textAlign: a, textVerticalAlign: o };
        }, n.makeAxisEventDataBase = function(t) {
          var e = { componentType: t.mainType, componentIndex: t.componentIndex };
          return e[t.mainType + "Index"] = t.componentIndex, e;
        }, n.isLabelSilent = function(t) {
          var e = t.get("tooltip");
          return t.get("silent") || !(t.get("triggerEvent") || e && e.show);
        }, n;
      }(), Q9 = { axisLine: function(n, t, e, i) {
        var r = t.get(["axisLine", "show"]);
        if (r === "auto" && n.handleAutoShown && (r = n.handleAutoShown("axisLine")), !!r) {
          var a = t.axis.getExtent(), o = i.transform, s = [a[0], 0], l = [a[1], 0], u = s[0] > l[0];
          o && (_i(s, s, o), _i(l, l, o));
          var h = X({ lineCap: "round" }, t.getModel(["axisLine", "lineStyle"]).getLineStyle()), c = new Kn({ shape: { x1: s[0], y1: s[1], x2: l[0], y2: l[1] }, style: h, strokeContainThreshold: n.strokeContainThreshold || 5, silent: true, z2: 1 });
          jg(c.shape, c.style.lineWidth), c.anid = "line", e.add(c);
          var f = t.get(["axisLine", "symbol"]);
          if (f != null) {
            var g = t.get(["axisLine", "symbolSize"]);
            ht(f) && (f = [f, f]), (ht(g) || ye(g)) && (g = [g, g]);
            var d = nc(t.get(["axisLine", "symbolOffset"]) || 0, g), A = g[0], p = g[1];
            D([{ rotate: n.rotation + Math.PI / 2, offset: d[0], r: 0 }, { rotate: n.rotation - Math.PI / 2, offset: d[1], r: Math.sqrt((s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1])) }], function(v, y) {
              if (f[y] !== "none" && f[y] != null) {
                var m = Un(f[y], -A / 2, -p / 2, A, p, h.stroke, true), _ = v.r + v.offset, I = u ? l : s;
                m.attr({ rotation: v.rotate, x: I[0] + _ * Math.cos(n.rotation), y: I[1] - _ * Math.sin(n.rotation), silent: true, z2: 11 }), e.add(m);
              }
            });
          }
        }
      }, axisTickLabel: function(n, t, e, i) {
        var r = UTt(e, i, t, n), a = jTt(e, i, t, n);
        if (GTt(t, a, r), VTt(e, i, t, n.tickDirection), t.get(["axisLabel", "hideOverlap"])) {
          var o = dj(K(a, function(s) {
            return { label: s, priority: s.z2, defaultAttr: { ignore: s.ignore } };
          }));
          vj(o);
        }
      }, axisName: function(n, t, e, i) {
        var r = On(n.axisName, t.get("name"));
        if (r) {
          var a = t.get("nameLocation"), o = n.nameDirection, s = t.getModel("nameTextStyle"), l = t.get("nameGap") || 0, u = t.axis.getExtent(), h = u[0] > u[1] ? -1 : 1, c = [a === "start" ? u[0] - h * l : a === "end" ? u[1] + h * l : (u[0] + u[1]) / 2, G9(a) ? n.labelOffset + o * l : 0], f, g = t.get("nameRotate");
          g != null && (g = g * Iu / 180);
          var d;
          G9(a) ? f = rr.innerTextLayout(n.rotation, g != null ? g : n.rotation, o) : (f = zTt(n.rotation, a, g || 0, u), d = n.axisNameAvailableWidth, d != null && (d = Math.abs(d / Math.sin(f.rotation)), !isFinite(d) && (d = null)));
          var A = s.getFont(), p = t.get("nameTruncate", true) || {}, v = p.ellipsis, y = On(n.nameTruncateMaxWidth, p.maxWidth, d), m = new Ae({ x: c[0], y: c[1], rotation: f.rotation, silent: rr.isLabelSilent(t), style: Je(s, { text: r, font: A, overflow: "truncate", width: y, ellipsis: v, fill: s.getTextColor() || t.get(["axisLine", "lineStyle", "color"]), align: s.get("align") || f.textAlign, verticalAlign: s.get("verticalAlign") || f.textVerticalAlign }), z2: 1 });
          if (qg({ el: m, componentModel: t, itemName: r }), m.__fullText = r, m.anid = "name", t.get("triggerEvent")) {
            var _ = rr.makeAxisEventDataBase(t);
            _.targetType = "axisName", _.name = r, Nt(m).eventData = _;
          }
          i.add(m), m.updateTransform(), e.add(m), m.decomposeTransform();
        }
      } };
      function zTt(n, t, e, i) {
        var r = o4(e - n), a, o, s = i[0] > i[1], l = t === "start" && !s || t !== "start" && s;
        return Jp(r - Iu / 2) ? (o = l ? "bottom" : "top", a = "center") : Jp(r - Iu * 1.5) ? (o = l ? "top" : "bottom", a = "center") : (o = "middle", r < Iu * 1.5 && r > Iu / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), { rotation: r, textAlign: a, textVerticalAlign: o };
      }
      function GTt(n, t, e) {
        if (!WV(n.axis)) {
          var i = n.get(["axisLabel", "showMinLabel"]), r = n.get(["axisLabel", "showMaxLabel"]);
          t = t || [], e = e || [];
          var a = t[0], o = t[1], s = t[t.length - 1], l = t[t.length - 2], u = e[0], h = e[1], c = e[e.length - 1], f = e[e.length - 2];
          i === false ? (ba(a), ba(u)) : z9(a, o) && (i ? (ba(o), ba(h)) : (ba(a), ba(u))), r === false ? (ba(s), ba(c)) : z9(l, s) && (r ? (ba(l), ba(f)) : (ba(s), ba(c)));
        }
      }
      function ba(n) {
        n && (n.ignore = true);
      }
      function z9(n, t) {
        var e = n && n.getBoundingRect().clone(), i = t && t.getBoundingRect().clone();
        if (!(!e || !i)) {
          var r = q_([]);
          return _h(r, r, -n.rotation), e.applyTransform(zs([], r, n.getLocalTransform())), i.applyTransform(zs([], r, t.getLocalTransform())), e.intersect(i);
        }
      }
      function G9(n) {
        return n === "middle" || n === "center";
      }
      function U9(n, t, e, i, r) {
        for (var a = [], o = [], s = [], l = 0; l < n.length; l++) {
          var u = n[l].coord;
          o[0] = u, o[1] = 0, s[0] = u, s[1] = e, t && (_i(o, o, t), _i(s, s, t));
          var h = new Kn({ shape: { x1: o[0], y1: o[1], x2: s[0], y2: s[1] }, style: i, z2: 2, autoBatch: true, silent: true });
          jg(h.shape, h.style.lineWidth), h.anid = r + "_" + n[l].tickValue, a.push(h);
        }
        return a;
      }
      function UTt(n, t, e, i) {
        var r = e.axis, a = e.getModel("axisTick"), o = a.get("show");
        if (o === "auto" && i.handleAutoShown && (o = i.handleAutoShown("axisTick")), !(!o || r.scale.isBlank())) {
          for (var s = a.getModel("lineStyle"), l = i.tickDirection * a.get("length"), u = r.getTicksCoords(), h = U9(u, t.transform, l, wt(s.getLineStyle(), { stroke: e.get(["axisLine", "lineStyle", "color"]) }), "ticks"), c = 0; c < h.length; c++) n.add(h[c]);
          return h;
        }
      }
      function VTt(n, t, e, i) {
        var r = e.axis, a = e.getModel("minorTick");
        if (!(!a.get("show") || r.scale.isBlank())) {
          var o = r.getMinorTicksCoords();
          if (o.length) for (var s = a.getModel("lineStyle"), l = i * a.get("length"), u = wt(s.getLineStyle(), wt(e.getModel("axisTick").getLineStyle(), { stroke: e.get(["axisLine", "lineStyle", "color"]) })), h = 0; h < o.length; h++) for (var c = U9(o[h], t.transform, l, u, "minorticks_" + h), f = 0; f < c.length; f++) n.add(c[f]);
        }
      }
      function jTt(n, t, e, i) {
        var r = e.axis, a = On(i.axisLabelShow, e.get(["axisLabel", "show"]));
        if (!(!a || r.scale.isBlank())) {
          var o = e.getModel("axisLabel"), s = o.get("margin"), l = r.getViewLabels(), u = (On(i.labelRotate, o.get("rotate")) || 0) * Iu / 180, h = rr.innerTextLayout(i.rotation, u, i.labelDirection), c = e.getCategories && e.getCategories(true), f = [], g = rr.isLabelSilent(e), d = e.get("triggerEvent");
          return D(l, function(A, p) {
            var v = r.scale.type === "ordinal" ? r.scale.getRawOrdinalNumber(A.tickValue) : A.tickValue, y = A.formattedLabel, m = A.rawLabel, _ = o;
            if (c && c[v]) {
              var I = c[v];
              Et(I) && I.textStyle && (_ = new De(I.textStyle, o, e.ecModel));
            }
            var E = _.getTextColor() || e.get(["axisLine", "lineStyle", "color"]), x = r.dataToCoord(v), w = _.getShallow("align", true) || h.textAlign, C = kt(_.getShallow("alignMinLabel", true), w), S = kt(_.getShallow("alignMaxLabel", true), w), b = _.getShallow("verticalAlign", true) || _.getShallow("baseline", true) || h.textVerticalAlign, T = kt(_.getShallow("verticalAlignMinLabel", true), b), B = kt(_.getShallow("verticalAlignMaxLabel", true), b), R = new Ae({ x, y: i.labelOffset + i.labelDirection * s, rotation: h.rotation, silent: g, z2: 10 + (A.level || 0), style: Je(_, { text: y, align: p === 0 ? C : p === l.length - 1 ? S : w, verticalAlign: p === 0 ? T : p === l.length - 1 ? B : b, fill: yt(E) ? E(r.type === "category" ? m : r.type === "value" ? v + "" : v, p) : E }) });
            if (R.anid = "label_" + v, d) {
              var M = rr.makeAxisEventDataBase(e);
              M.targetType = "axisLabel", M.value = m, M.tickIndex = p, r.type === "category" && (M.dataIndex = v), Nt(R).eventData = M;
            }
            t.add(R), R.updateTransform(), f.push(R), n.add(R), R.decomposeTransform();
          }), f;
        }
      }
      function qTt(n, t) {
        var e = { axesInfo: {}, seriesInvolved: false, coordSysAxesInfo: {}, coordSysMap: {} };
        return HTt(e, n, t), e.seriesInvolved && WTt(e, n), e;
      }
      function HTt(n, t, e) {
        var i = t.getComponent("tooltip"), r = t.getComponent("axisPointer"), a = r.get("link", true) || [], o = [];
        D(e.getCoordinateSystems(), function(s) {
          if (!s.axisPointerEnabled) return;
          var l = iy(s.model), u = n.coordSysAxesInfo[l] = {};
          n.coordSysMap[l] = s;
          var h = s.model, c = h.getModel("tooltip", i);
          if (D(s.getAxes(), Gt(A, false, null)), s.getTooltipAxes && i && c.get("show")) {
            var f = c.get("trigger") === "axis", g = c.get(["axisPointer", "type"]) === "cross", d = s.getTooltipAxes(c.get(["axisPointer", "axis"]));
            (f || g) && D(d.baseAxes, Gt(A, g ? "cross" : true, f)), g && D(d.otherAxes, Gt(A, "cross", false));
          }
          function A(p, v, y) {
            var m = y.model.getModel("axisPointer", r), _ = m.get("show");
            if (!(!_ || _ === "auto" && !p && !oD(m))) {
              v == null && (v = m.get("triggerTooltip")), m = p ? YTt(y, c, r, t, p, v) : m;
              var I = m.get("snap"), E = m.get("triggerEmphasis"), x = iy(y.model), w = v || I || y.type === "category", C = n.axesInfo[x] = { key: x, axis: y, coordSys: s, axisPointerModel: m, triggerTooltip: v, triggerEmphasis: E, involveSeries: w, snap: I, useHandle: oD(m), seriesModels: [], linkGroup: null };
              u[x] = C, n.seriesInvolved = n.seriesInvolved || w;
              var S = XTt(a, y);
              if (S != null) {
                var b = o[S] || (o[S] = { axesInfo: {} });
                b.axesInfo[x] = C, b.mapper = a[S].mapper, C.linkGroup = b;
              }
            }
          }
        });
      }
      function YTt(n, t, e, i, r, a) {
        var o = t.getModel("axisPointer"), s = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
        D(s, function(f) {
          l[f] = Ct(o.get(f));
        }), l.snap = n.type !== "category" && !!a, o.get("type") === "cross" && (l.type = "line");
        var u = l.label || (l.label = {});
        if (u.show == null && (u.show = false), r === "cross") {
          var h = o.get(["label", "show"]);
          if (u.show = h != null ? h : true, !a) {
            var c = l.lineStyle = o.get("crossStyle");
            c && wt(u, c.textStyle);
          }
        }
        return n.model.getModel("axisPointer", new De(l, e, i));
      }
      function WTt(n, t) {
        t.eachSeries(function(e) {
          var i = e.coordinateSystem, r = e.get(["tooltip", "trigger"], true), a = e.get(["tooltip", "show"], true);
          !i || r === "none" || r === false || r === "item" || a === false || e.get(["axisPointer", "show"], true) === false || D(n.coordSysAxesInfo[iy(i.model)], function(o) {
            var s = o.axis;
            i.getAxis(s.dim) === s && (o.seriesModels.push(e), o.seriesDataCount == null && (o.seriesDataCount = 0), o.seriesDataCount += e.getData().count());
          });
        });
      }
      function XTt(n, t) {
        for (var e = t.model, i = t.dim, r = 0; r < n.length; r++) {
          var a = n[r] || {};
          if (rD(a[i + "AxisId"], e.id) || rD(a[i + "AxisIndex"], e.componentIndex) || rD(a[i + "AxisName"], e.name)) return r;
        }
      }
      function rD(n, t) {
        return n === "all" || Z(n) && $t(n, t) >= 0 || n === t;
      }
      function $Tt(n) {
        var t = aD(n);
        if (t) {
          var e = t.axisPointerModel, i = t.axis.scale, r = e.option, a = e.get("status"), o = e.get("value");
          o != null && (o = i.parse(o));
          var s = oD(e);
          a == null && (r.status = s ? "show" : "hide");
          var l = i.getExtent().slice();
          l[0] > l[1] && l.reverse(), (o == null || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), r.value = o, s && (r.status = t.axis.scale.isBlank() ? "hide" : "show");
        }
      }
      function aD(n) {
        var t = (n.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
        return t && t.axesInfo[iy(n)];
      }
      function ZTt(n) {
        var t = aD(n);
        return t && t.axisPointerModel;
      }
      function oD(n) {
        return !!n.get(["handle", "show"]);
      }
      function iy(n) {
        return n.type + "||" + n.id;
      }
      var sD = {}, pc = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r, a) {
          this.axisPointerClass && $Tt(e), n.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(e, r, true);
        }, t.prototype.updateAxisPointer = function(e, i, r, a) {
          this._doUpdateAxisPointerClass(e, r, false);
        }, t.prototype.remove = function(e, i) {
          var r = this._axisPointer;
          r && r.remove(i);
        }, t.prototype.dispose = function(e, i) {
          this._disposeAxisPointer(i), n.prototype.dispose.apply(this, arguments);
        }, t.prototype._doUpdateAxisPointerClass = function(e, i, r) {
          var a = t.getAxisPointerClass(this.axisPointerClass);
          if (a) {
            var o = ZTt(e);
            o ? (this._axisPointer || (this._axisPointer = new a())).render(e, o, i, r) : this._disposeAxisPointer(i);
          }
        }, t.prototype._disposeAxisPointer = function(e) {
          this._axisPointer && this._axisPointer.dispose(e), this._axisPointer = null;
        }, t.registerAxisPointerClass = function(e, i) {
          if (sD[e]) throw new Error("axisPointer " + e + " exists");
          sD[e] = i;
        }, t.getAxisPointerClass = function(e) {
          return e && sD[e];
        }, t.type = "axis", t;
      }(un), lD = ce();
      function V9(n, t, e, i) {
        var r = e.axis;
        if (!r.scale.isBlank()) {
          var a = e.getModel("splitArea"), o = a.getModel("areaStyle"), s = o.get("color"), l = i.coordinateSystem.getRect(), u = r.getTicksCoords({ tickModel: a, clamp: true });
          if (u.length) {
            var h = s.length, c = lD(n).splitAreaColors, f = dt(), g = 0;
            if (c) for (var d = 0; d < u.length; d++) {
              var A = c.get(u[d].tickValue);
              if (A != null) {
                g = (A + (h - 1) * d) % h;
                break;
              }
            }
            var p = r.toGlobalCoord(u[0].coord), v = o.getAreaStyle();
            s = Z(s) ? s : [s];
            for (var d = 1; d < u.length; d++) {
              var y = r.toGlobalCoord(u[d].coord), m = void 0, _ = void 0, I = void 0, E = void 0;
              r.isHorizontal() ? (m = p, _ = l.y, I = y - m, E = l.height, p = m + I) : (m = l.x, _ = p, I = l.width, E = y - _, p = _ + E);
              var x = u[d - 1].tickValue;
              x != null && f.set(x, g), t.add(new fe({ anid: x != null ? "area_" + x : null, shape: { x: m, y: _, width: I, height: E }, style: wt({ fill: s[g] }, v), autoBatch: true, silent: true })), g = (g + 1) % h;
            }
            lD(n).splitAreaColors = f;
          }
        }
      }
      function j9(n) {
        lD(n).splitAreaColors = null;
      }
      var KTt = ["axisLine", "axisTickLabel", "axisName"], JTt = ["splitArea", "splitLine", "minorSplitLine"], q9 = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.axisPointerClass = "CartesianAxisPointer", e;
        }
        return t.prototype.render = function(e, i, r, a) {
          this.group.removeAll();
          var o = this._axisGroup;
          if (this._axisGroup = new Dt(), this.group.add(this._axisGroup), !!e.get("show")) {
            var s = e.getCoordSysModel(), l = eD(s, e), u = new rr(e, X({ handleAutoShown: function(c) {
              for (var f = s.coordinateSystem.getCartesians(), g = 0; g < f.length; g++) if (vM(f[g].getOtherAxis(e.axis).scale)) return true;
              return false;
            } }, l));
            D(KTt, u.add, u), this._axisGroup.add(u.getGroup()), D(JTt, function(c) {
              e.get([c, "show"]) && tBt[c](this, this._axisGroup, e, s);
            }, this);
            var h = a && a.type === "changeAxisOrder" && a.isInitSort;
            h || pv(o, this._axisGroup, e), n.prototype.render.call(this, e, i, r, a);
          }
        }, t.prototype.remove = function() {
          j9(this);
        }, t.type = "cartesianAxis", t;
      }(pc), tBt = { splitLine: function(n, t, e, i) {
        var r = e.axis;
        if (!r.scale.isBlank()) {
          var a = e.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color");
          s = Z(s) ? s : [s];
          for (var l = i.coordinateSystem.getRect(), u = r.isHorizontal(), h = 0, c = r.getTicksCoords({ tickModel: a }), f = [], g = [], d = o.getLineStyle(), A = 0; A < c.length; A++) {
            var p = r.toGlobalCoord(c[A].coord);
            u ? (f[0] = p, f[1] = l.y, g[0] = p, g[1] = l.y + l.height) : (f[0] = l.x, f[1] = p, g[0] = l.x + l.width, g[1] = p);
            var v = h++ % s.length, y = c[A].tickValue, m = new Kn({ anid: y != null ? "line_" + c[A].tickValue : null, autoBatch: true, shape: { x1: f[0], y1: f[1], x2: g[0], y2: g[1] }, style: wt({ stroke: s[v] }, d), silent: true });
            jg(m.shape, d.lineWidth), t.add(m);
          }
        }
      }, minorSplitLine: function(n, t, e, i) {
        var r = e.axis, a = e.getModel("minorSplitLine"), o = a.getModel("lineStyle"), s = i.coordinateSystem.getRect(), l = r.isHorizontal(), u = r.getMinorTicksCoords();
        if (u.length) for (var h = [], c = [], f = o.getLineStyle(), g = 0; g < u.length; g++) for (var d = 0; d < u[g].length; d++) {
          var A = r.toGlobalCoord(u[g][d].coord);
          l ? (h[0] = A, h[1] = s.y, c[0] = A, c[1] = s.y + s.height) : (h[0] = s.x, h[1] = A, c[0] = s.x + s.width, c[1] = A);
          var p = new Kn({ anid: "minor_line_" + u[g][d].tickValue, autoBatch: true, shape: { x1: h[0], y1: h[1], x2: c[0], y2: c[1] }, style: f, silent: true });
          jg(p.shape, f.lineWidth), t.add(p);
        }
      }, splitArea: function(n, t, e, i) {
        V9(n, t, e, i);
      } }, H9 = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "xAxis", t;
      }(q9), eBt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = H9.type, e;
        }
        return t.type = "yAxis", t;
      }(q9), nBt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "grid", e;
        }
        return t.prototype.render = function(e, i) {
          this.group.removeAll(), e.get("show") && this.group.add(new fe({ shape: e.coordinateSystem.getRect(), style: wt({ fill: e.get("backgroundColor") }, e.getItemStyle()), silent: true, z2: -1 }));
        }, t.type = "grid", t;
      }(un), Y9 = { offset: 0 };
      function W9(n) {
        n.registerComponentView(nBt), n.registerComponentModel(MTt), n.registerCoordinateSystem("cartesian2d", OTt), yd(n, "x", KM, Y9), yd(n, "y", KM, Y9), n.registerComponentView(H9), n.registerComponentView(eBt), n.registerPreprocessor(function(t) {
          t.xAxis && t.yAxis && !t.grid && (t.grid = {});
        });
      }
      function iBt(n) {
        Kt(W9), n.registerSeriesModel(CTt), n.registerChartView(BTt), n.registerLayout(Jv("scatter"));
      }
      function rBt(n) {
        n.eachSeriesByType("radar", function(t) {
          var e = t.getData(), i = [], r = t.coordinateSystem;
          if (r) {
            var a = r.getIndicatorAxes();
            D(a, function(o, s) {
              e.each(e.mapDimension(a[s].dim), function(l, u) {
                i[u] = i[u] || [];
                var h = r.dataToPoint(l, s);
                i[u][s] = X9(h) ? h : $9(r);
              });
            }), e.each(function(o) {
              var s = U_t(i[o], function(l) {
                return X9(l);
              }) || $9(r);
              i[o].push(s.slice()), e.setItemLayout(o, i[o]);
            });
          }
        });
      }
      function X9(n) {
        return !isNaN(n[0]) && !isNaN(n[1]);
      }
      function $9(n) {
        return [n.cx, n.cy];
      }
      function aBt(n) {
        var t = n.polar;
        if (t) {
          Z(t) || (t = [t]);
          var e = [];
          D(t, function(i, r) {
            i.indicator ? (i.type && !i.shape && (i.shape = i.type), n.radar = n.radar || [], Z(n.radar) || (n.radar = [n.radar]), n.radar.push(i)) : e.push(i);
          }), n.polar = e;
        }
        D(n.series, function(i) {
          i && i.type === "radar" && i.polarIndex && (i.radarIndex = i.polarIndex);
        });
      }
      var oBt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = e.coordinateSystem, o = this.group, s = e.getData(), l = this._data;
          function u(f, g) {
            var d = f.getItemVisual(g, "symbol") || "circle";
            if (d !== "none") {
              var A = sd(f.getItemVisual(g, "symbolSize")), p = Un(d, -1, -1, 2, 2), v = f.getItemVisual(g, "symbolRotate") || 0;
              return p.attr({ style: { strokeNoScale: true }, z2: 100, scaleX: A[0] / 2, scaleY: A[1] / 2, rotation: v * Math.PI / 180 || 0 }), p;
            }
          }
          function h(f, g, d, A, p, v) {
            d.removeAll();
            for (var y = 0; y < g.length - 1; y++) {
              var m = u(A, p);
              m && (m.__dimIdx = y, f[y] ? (m.setPosition(f[y]), Wh[v ? "initProps" : "updateProps"](m, { x: g[y][0], y: g[y][1] }, e, p)) : m.setPosition(g[y]), d.add(m));
            }
          }
          function c(f) {
            return K(f, function(g) {
              return [a.cx, a.cy];
            });
          }
          s.diff(l).add(function(f) {
            var g = s.getItemLayout(f);
            if (g) {
              var d = new Ki(), A = new Ji(), p = { shape: { points: g } };
              d.shape.points = c(g), A.shape.points = c(g), on(d, p, e, f), on(A, p, e, f);
              var v = new Dt(), y = new Dt();
              v.add(A), v.add(d), v.add(y), h(A.shape.points, g, y, s, f, true), s.setItemGraphicEl(f, v);
            }
          }).update(function(f, g) {
            var d = l.getItemGraphicEl(g), A = d.childAt(0), p = d.childAt(1), v = d.childAt(2), y = { shape: { points: s.getItemLayout(f) } };
            y.shape.points && (h(A.shape.points, y.shape.points, v, s, f, false), to(p), to(A), Ee(A, y, e), Ee(p, y, e), s.setItemGraphicEl(f, d));
          }).remove(function(f) {
            o.remove(l.getItemGraphicEl(f));
          }).execute(), s.eachItemGraphicEl(function(f, g) {
            var d = s.getItemModel(g), A = f.childAt(0), p = f.childAt(1), v = f.childAt(2), y = s.getItemVisual(g, "style"), m = y.fill;
            o.add(f), A.useStyle(wt(d.getModel("lineStyle").getLineStyle(), { fill: "none", stroke: m })), Ii(A, d, "lineStyle"), Ii(p, d, "areaStyle");
            var _ = d.getModel("areaStyle"), I = _.isEmpty() && _.parentModel.isEmpty();
            p.ignore = I, D(["emphasis", "select", "blur"], function(w) {
              var C = d.getModel([w, "areaStyle"]), S = C.isEmpty() && C.parentModel.isEmpty();
              p.ensureState(w).ignore = S && I;
            }), p.useStyle(wt(_.getAreaStyle(), { fill: m, opacity: 0.7, decal: y.decal }));
            var E = d.getModel("emphasis"), x = E.getModel("itemStyle").getItemStyle();
            v.eachChild(function(w) {
              if (w instanceof gi) {
                var C = w.style;
                w.useStyle(X({ image: C.image, x: C.x, y: C.y, width: C.width, height: C.height }, y));
              } else w.useStyle(y), w.setColor(m), w.style.strokeNoScale = true;
              var S = w.ensureState("emphasis");
              S.style = Ct(x);
              var b = s.getStore().get(s.getDimensionIndex(w.__dimIdx), g);
              (b == null || isNaN(b)) && (b = ""), xi(w, Jn(d), { labelFetcher: s.hostModel, labelDataIndex: g, labelDimIndex: w.__dimIdx, defaultText: b, inheritColor: m, defaultOpacity: y.opacity });
            }), pn(f, E.get("focus"), E.get("blurScope"), E.get("disabled"));
          }), this._data = s;
        }, t.prototype.remove = function() {
          this.group.removeAll(), this._data = null;
        }, t.type = "radar", t;
      }(qe), sBt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.hasSymbolVisual = true, e;
        }
        return t.prototype.init = function(e) {
          n.prototype.init.apply(this, arguments), this.legendVisualProvider = new ny(ct(this.getData, this), ct(this.getRawData, this));
        }, t.prototype.getInitialData = function(e, i) {
          return vd(this, { generateCoord: "indicator_", generateCoordCount: 1 / 0 });
        }, t.prototype.formatTooltip = function(e, i, r) {
          var a = this.getData(), o = this.coordinateSystem, s = o.getIndicatorAxes(), l = this.getData().getName(e), u = l === "" ? this.name : l, h = uU(this, e);
          return ti("section", { header: u, sortBlocks: true, blocks: K(s, function(c) {
            var f = a.get(a.mapDimension(c.dim), e);
            return ti("nameValue", { markerType: "subItem", markerColor: h, name: c.name, value: f, sortParam: f });
          }) });
        }, t.prototype.getTooltipPosition = function(e) {
          if (e != null) {
            for (var i = this.getData(), r = this.coordinateSystem, a = i.getValues(K(r.dimensions, function(u) {
              return i.mapDimension(u);
            }), e), o = 0, s = a.length; o < s; o++) if (!isNaN(a[o])) {
              var l = r.getIndicatorAxes();
              return r.coordToPoint(l[o].dataToCoord(a[o]), o);
            }
          }
        }, t.type = "series.radar", t.dependencies = ["radar"], t.defaultOption = { z: 2, colorBy: "data", coordinateSystem: "radar", legendHoverLink: true, radarIndex: 0, lineStyle: { width: 2, type: "solid", join: "round" }, label: { position: "top" }, symbolSize: 8 }, t;
      }(tn), ry = D9.value;
      function $E(n, t) {
        return wt({ show: t }, n);
      }
      var lBt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.optionUpdated = function() {
          var e = this.get("boundaryGap"), i = this.get("splitNumber"), r = this.get("scale"), a = this.get("axisLine"), o = this.get("axisTick"), s = this.get("axisLabel"), l = this.get("axisName"), u = this.get(["axisName", "show"]), h = this.get(["axisName", "formatter"]), c = this.get("axisNameGap"), f = this.get("triggerEvent"), g = K(this.get("indicator") || [], function(d) {
            d.max != null && d.max > 0 && !d.min ? d.min = 0 : d.min != null && d.min < 0 && !d.max && (d.max = 0);
            var A = l;
            d.color != null && (A = wt({ color: d.color }, l));
            var p = Yt(Ct(d), { boundaryGap: e, splitNumber: i, scale: r, axisLine: a, axisTick: o, axisLabel: s, name: d.text, showName: u, nameLocation: "end", nameGap: c, nameTextStyle: A, triggerEvent: f }, false);
            if (ht(h)) {
              var v = p.name;
              p.name = h.replace("{value}", v != null ? v : "");
            } else yt(h) && (p.name = h(p.name, p));
            var y = new De(p, null, this.ecModel);
            return kn(y, jv.prototype), y.mainType = "radar", y.componentIndex = this.componentIndex, y;
          }, this);
          this._indicatorModels = g;
        }, t.prototype.getIndicatorModels = function() {
          return this._indicatorModels;
        }, t.type = "radar", t.defaultOption = { z: 0, center: ["50%", "50%"], radius: "75%", startAngle: 90, axisName: { show: true }, boundaryGap: [0, 0], splitNumber: 5, axisNameGap: 15, scale: false, shape: "polygon", axisLine: Yt({ lineStyle: { color: "#bbb" } }, ry.axisLine), axisLabel: $E(ry.axisLabel, false), axisTick: $E(ry.axisTick, false), splitLine: $E(ry.splitLine, true), splitArea: $E(ry.splitArea, true), indicator: [] }, t;
      }(ae), uBt = ["axisLine", "axisTickLabel", "axisName"], hBt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = this.group;
          a.removeAll(), this._buildAxes(e), this._buildSplitLineAndArea(e);
        }, t.prototype._buildAxes = function(e) {
          var i = e.coordinateSystem, r = i.getIndicatorAxes(), a = K(r, function(o) {
            var s = o.model.get("showName") ? o.name : "", l = new rr(o.model, { axisName: s, position: [i.cx, i.cy], rotation: o.angle, labelDirection: -1, tickDirection: -1, nameDirection: 1 });
            return l;
          });
          D(a, function(o) {
            D(uBt, o.add, o), this.group.add(o.getGroup());
          }, this);
        }, t.prototype._buildSplitLineAndArea = function(e) {
          var i = e.coordinateSystem, r = i.getIndicatorAxes();
          if (!r.length) return;
          var a = e.get("shape"), o = e.getModel("splitLine"), s = e.getModel("splitArea"), l = o.getModel("lineStyle"), u = s.getModel("areaStyle"), h = o.get("show"), c = s.get("show"), f = l.get("color"), g = u.get("color"), d = Z(f) ? f : [f], A = Z(g) ? g : [g], p = [], v = [];
          function y(M, L, N) {
            var F = N % L.length;
            return M[F] = M[F] || [], F;
          }
          if (a === "circle") for (var m = r[0].getTicksCoords(), _ = i.cx, I = i.cy, E = 0; E < m.length; E++) {
            if (h) {
              var x = y(p, d, E);
              p[x].push(new $s({ shape: { cx: _, cy: I, r: m[E].coord } }));
            }
            if (c && E < m.length - 1) {
              var x = y(v, A, E);
              v[x].push(new fv({ shape: { cx: _, cy: I, r0: m[E].coord, r: m[E + 1].coord } }));
            }
          }
          else for (var w, C = K(r, function(M, L) {
            var N = M.getTicksCoords();
            return w = w == null ? N.length - 1 : Math.min(N.length - 1, w), K(N, function(F) {
              return i.coordToPoint(F.coord, L);
            });
          }), S = [], E = 0; E <= w; E++) {
            for (var b = [], T = 0; T < r.length; T++) b.push(C[T][E]);
            if (b[0] ? b.push(b[0].slice()) : "development", h) {
              var x = y(p, d, E);
              p[x].push(new Ji({ shape: { points: b } }));
            }
            if (c && S) {
              var x = y(v, A, E - 1);
              v[x].push(new Ki({ shape: { points: b.concat(S) } }));
            }
            S = b.slice().reverse();
          }
          var B = l.getLineStyle(), R = u.getAreaStyle();
          D(v, function(M, L) {
            this.group.add(_a(M, { style: wt({ stroke: "none", fill: A[L % A.length] }, R), silent: true }));
          }, this), D(p, function(M, L) {
            this.group.add(_a(M, { style: wt({ fill: "none", stroke: d[L % d.length] }, B), silent: true }));
          }, this);
        }, t.type = "radar", t;
      }(un), cBt = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this, e, i, r) || this;
          return a.type = "value", a.angle = 0, a.name = "", a;
        }
        return t;
      }(ao), fBt = function() {
        function n(t, e, i) {
          this.dimensions = [], this._model = t, this._indicatorAxes = K(t.getIndicatorModels(), function(r, a) {
            var o = "indicator_" + a, s = new cBt(o, new el());
            return s.name = r.get("name"), s.model = r, r.axis = s, this.dimensions.push(o), s;
          }, this), this.resize(t, i);
        }
        return n.prototype.getIndicatorAxes = function() {
          return this._indicatorAxes;
        }, n.prototype.dataToPoint = function(t, e) {
          var i = this._indicatorAxes[e];
          return this.coordToPoint(i.dataToCoord(t), e);
        }, n.prototype.coordToPoint = function(t, e) {
          var i = this._indicatorAxes[e], r = i.angle, a = this.cx + t * Math.cos(r), o = this.cy - t * Math.sin(r);
          return [a, o];
        }, n.prototype.pointToData = function(t) {
          var e = t[0] - this.cx, i = t[1] - this.cy, r = Math.sqrt(e * e + i * i);
          e /= r, i /= r;
          for (var a = Math.atan2(-i, e), o = 1 / 0, s, l = -1, u = 0; u < this._indicatorAxes.length; u++) {
            var h = this._indicatorAxes[u], c = Math.abs(a - h.angle);
            c < o && (s = h, l = u, o = c);
          }
          return [l, +(s && s.coordToData(r))];
        }, n.prototype.resize = function(t, e) {
          var i = t.get("center"), r = e.getWidth(), a = e.getHeight(), o = Math.min(r, a) / 2;
          this.cx = st(i[0], r), this.cy = st(i[1], a), this.startAngle = t.get("startAngle") * Math.PI / 180;
          var s = t.get("radius");
          (ht(s) || ye(s)) && (s = [0, s]), this.r0 = st(s[0], o), this.r = st(s[1], o), D(this._indicatorAxes, function(l, u) {
            l.setExtent(this.r0, this.r);
            var h = this.startAngle + u * Math.PI * 2 / this._indicatorAxes.length;
            h = Math.atan2(Math.sin(h), Math.cos(h)), l.angle = h;
          }, this);
        }, n.prototype.update = function(t, e) {
          var i = this._indicatorAxes, r = this._model;
          D(i, function(s) {
            s.scale.setExtent(1 / 0, -1 / 0);
          }), t.eachSeriesByType("radar", function(s, l) {
            if (!(s.get("coordinateSystem") !== "radar" || t.getComponent("radar", s.get("radarIndex")) !== r)) {
              var u = s.getData();
              D(i, function(h) {
                h.scale.unionExtentFromData(u, u.mapDimension(h.dim));
              });
            }
          }, this);
          var a = r.get("splitNumber"), o = new el();
          o.setExtent(0, a), o.setInterval(1), D(i, function(s, l) {
            F9(s.scale, s.model, o);
          });
        }, n.prototype.convertToPixel = function(t, e, i) {
          return null;
        }, n.prototype.convertFromPixel = function(t, e, i) {
          return null;
        }, n.prototype.containPoint = function(t) {
          return false;
        }, n.create = function(t, e) {
          var i = [];
          return t.eachComponent("radar", function(r) {
            var a = new n(r, t, e);
            i.push(a), r.coordinateSystem = a;
          }), t.eachSeriesByType("radar", function(r) {
            r.get("coordinateSystem") === "radar" && (r.coordinateSystem = i[r.get("radarIndex") || 0]);
          }), i;
        }, n.dimensions = [], n;
      }();
      function gBt(n) {
        n.registerCoordinateSystem("radar", fBt), n.registerComponentModel(lBt), n.registerComponentView(hBt), n.registerVisual({ seriesType: "radar", reset: function(t) {
          var e = t.getData();
          e.each(function(i) {
            e.setItemVisual(i, "legendIcon", "roundRect");
          }), e.setVisual("legendIcon", "roundRect");
        } });
      }
      function dBt(n) {
        Kt(gBt), n.registerChartView(oBt), n.registerSeriesModel(sBt), n.registerLayout(rBt), n.registerProcessor(ey("radar")), n.registerPreprocessor(aBt);
      }
      var Z9 = "\0_ec_interaction_mutex";
      function ABt(n, t, e) {
        var i = uD(n);
        i[t] = e;
      }
      function pBt(n, t, e) {
        var i = uD(n), r = i[t];
        r === e && (i[t] = null);
      }
      function K9(n, t) {
        return !!uD(n)[t];
      }
      function uD(n) {
        return n[Z9] || (n[Z9] = {});
      }
      ts({ type: "takeGlobalCursor", event: "globalCursorTaken", update: "update" }, bn);
      var ay = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this) || this;
          i._zr = e;
          var r = ct(i._mousedownHandler, i), a = ct(i._mousemoveHandler, i), o = ct(i._mouseupHandler, i), s = ct(i._mousewheelHandler, i), l = ct(i._pinchHandler, i);
          return i.enable = function(u, h) {
            this.disable(), this._opt = wt(Ct(h) || {}, { zoomOnMouseWheel: true, moveOnMouseMove: true, moveOnMouseWheel: false, preventDefaultMouseMove: true }), u == null && (u = true), (u === true || u === "move" || u === "pan") && (e.on("mousedown", r), e.on("mousemove", a), e.on("mouseup", o)), (u === true || u === "scale" || u === "zoom") && (e.on("mousewheel", s), e.on("pinch", l));
          }, i.disable = function() {
            e.off("mousedown", r), e.off("mousemove", a), e.off("mouseup", o), e.off("mousewheel", s), e.off("pinch", l);
          }, i;
        }
        return t.prototype.isDragging = function() {
          return this._dragging;
        }, t.prototype.isPinching = function() {
          return this._pinching;
        }, t.prototype.setPointerChecker = function(e) {
          this.pointerChecker = e;
        }, t.prototype.dispose = function() {
          this.disable();
        }, t.prototype._mousedownHandler = function(e) {
          if (!u5(e)) {
            for (var i = e.target; i; ) {
              if (i.draggable) return;
              i = i.__hostTarget || i.parent;
            }
            var r = e.offsetX, a = e.offsetY;
            this.pointerChecker && this.pointerChecker(e, r, a) && (this._x = r, this._y = a, this._dragging = true);
          }
        }, t.prototype._mousemoveHandler = function(e) {
          if (!(!this._dragging || !ZE("moveOnMouseMove", e, this._opt) || e.gestureEvent === "pinch" || K9(this._zr, "globalPan"))) {
            var i = e.offsetX, r = e.offsetY, a = this._x, o = this._y, s = i - a, l = r - o;
            this._x = i, this._y = r, this._opt.preventDefaultMouseMove && Qs(e.event), J9(this, "pan", "moveOnMouseMove", e, { dx: s, dy: l, oldX: a, oldY: o, newX: i, newY: r, isAvailableBehavior: null });
          }
        }, t.prototype._mouseupHandler = function(e) {
          u5(e) || (this._dragging = false);
        }, t.prototype._mousewheelHandler = function(e) {
          var i = ZE("zoomOnMouseWheel", e, this._opt), r = ZE("moveOnMouseWheel", e, this._opt), a = e.wheelDelta, o = Math.abs(a), s = e.offsetX, l = e.offsetY;
          if (!(a === 0 || !i && !r)) {
            if (i) {
              var u = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1, h = a > 0 ? u : 1 / u;
              hD(this, "zoom", "zoomOnMouseWheel", e, { scale: h, originX: s, originY: l, isAvailableBehavior: null });
            }
            if (r) {
              var c = Math.abs(a), f = (a > 0 ? 1 : -1) * (c > 3 ? 0.4 : c > 1 ? 0.15 : 0.05);
              hD(this, "scrollMove", "moveOnMouseWheel", e, { scrollDelta: f, originX: s, originY: l, isAvailableBehavior: null });
            }
          }
        }, t.prototype._pinchHandler = function(e) {
          if (!K9(this._zr, "globalPan")) {
            var i = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
            hD(this, "zoom", null, e, { scale: i, originX: e.pinchX, originY: e.pinchY, isAvailableBehavior: null });
          }
        }, t;
      }(ga);
      function hD(n, t, e, i, r) {
        n.pointerChecker && n.pointerChecker(i, r.originX, r.originY) && (Qs(i.event), J9(n, t, e, i, r));
      }
      function J9(n, t, e, i, r) {
        r.isAvailableBehavior = ct(ZE, null, e, i), n.trigger(t, r);
      }
      function ZE(n, t, e) {
        var i = e[n];
        return !n || i && (!ht(i) || t.event[i + "Key"]);
      }
      function cD(n, t, e) {
        var i = n.target;
        i.x += t, i.y += e, i.dirty();
      }
      function fD(n, t, e, i) {
        var r = n.target, a = n.zoomLimit, o = n.zoom = n.zoom || 1;
        if (o *= t, a) {
          var s = a.min || 0, l = a.max || 1 / 0;
          o = Math.max(Math.min(l, o), s);
        }
        var u = o / n.zoom;
        n.zoom = o, r.x -= (e - r.x) * (u - 1), r.y -= (i - r.y) * (u - 1), r.scaleX *= u, r.scaleY *= u, r.dirty();
      }
      var vBt = { axisPointer: 1, tooltip: 1, brush: 1 };
      function KE(n, t, e) {
        var i = t.getComponentByElement(n.topTarget), r = i && i.coordinateSystem;
        return i && i !== e && !vBt.hasOwnProperty(i.mainType) && r && r.model !== e;
      }
      function tq(n) {
        if (ht(n)) {
          var t = new DOMParser();
          n = t.parseFromString(n, "text/xml");
        }
        var e = n;
        for (e.nodeType === 9 && (e = e.firstChild); e.nodeName.toLowerCase() !== "svg" || e.nodeType !== 1; ) e = e.nextSibling;
        return e;
      }
      var gD, JE = { fill: "fill", stroke: "stroke", "stroke-width": "lineWidth", opacity: "opacity", "fill-opacity": "fillOpacity", "stroke-opacity": "strokeOpacity", "stroke-dasharray": "lineDash", "stroke-dashoffset": "lineDashOffset", "stroke-linecap": "lineCap", "stroke-linejoin": "lineJoin", "stroke-miterlimit": "miterLimit", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "text-anchor": "textAlign", visibility: "visibility", display: "display" }, eq = oe(JE), tI = { "alignment-baseline": "textBaseline", "stop-color": "stopColor" }, nq = oe(tI), yBt = function() {
        function n() {
          this._defs = {}, this._root = null;
        }
        return n.prototype.parse = function(t, e) {
          e = e || {};
          var i = tq(t);
          if (!i) throw new Error("Illegal svg");
          this._defsUsePending = [];
          var r = new Dt();
          this._root = r;
          var a = [], o = i.getAttribute("viewBox") || "", s = parseFloat(i.getAttribute("width") || e.width), l = parseFloat(i.getAttribute("height") || e.height);
          isNaN(s) && (s = null), isNaN(l) && (l = null), Xr(i, r, null, true, false);
          for (var u = i.firstChild; u; ) this._parseNode(u, r, a, null, false, false), u = u.nextSibling;
          EBt(this._defs, this._defsUsePending), this._defsUsePending = [];
          var h, c;
          if (o) {
            var f = eI(o);
            f.length >= 4 && (h = { x: parseFloat(f[0] || 0), y: parseFloat(f[1] || 0), width: parseFloat(f[2]), height: parseFloat(f[3]) });
          }
          if (h && s != null && l != null && (c = hq(h, { x: 0, y: 0, width: s, height: l }), !e.ignoreViewBox)) {
            var g = r;
            r = new Dt(), r.add(g), g.scaleX = g.scaleY = c.scale, g.x = c.x, g.y = c.y;
          }
          return !e.ignoreRootClip && s != null && l != null && r.setClipPath(new fe({ shape: { x: 0, y: 0, width: s, height: l } })), { root: r, width: s, height: l, viewBoxRect: h, viewBoxTransform: c, named: a };
        }, n.prototype._parseNode = function(t, e, i, r, a, o) {
          var s = t.nodeName.toLowerCase(), l, u = r;
          if (s === "defs" && (a = true), s === "text" && (o = true), s === "defs" || s === "switch") l = e;
          else {
            if (!a) {
              var h = gD[s];
              if (h && ft(gD, s)) {
                l = h.call(this, t, e);
                var c = t.getAttribute("name");
                if (c) {
                  var f = { name: c, namedFrom: null, svgNodeTagLower: s, el: l };
                  i.push(f), s === "g" && (u = f);
                } else r && i.push({ name: r.name, namedFrom: r, svgNodeTagLower: s, el: l });
                e.add(l);
              }
            }
            var g = iq[s];
            if (g && ft(iq, s)) {
              var d = g.call(this, t), A = t.getAttribute("id");
              A && (this._defs[A] = d);
            }
          }
          if (l && l.isGroup) for (var p = t.firstChild; p; ) p.nodeType === 1 ? this._parseNode(p, l, i, u, a, o) : p.nodeType === 3 && o && this._parseText(p, l), p = p.nextSibling;
        }, n.prototype._parseText = function(t, e) {
          var i = new Fg({ style: { text: t.textContent }, silent: true, x: this._textX || 0, y: this._textY || 0 });
          Ta(e, i), Xr(t, i, this._defsUsePending, false, false), mBt(i, e);
          var r = i.style, a = r.fontSize;
          a && a < 9 && (r.fontSize = 9, i.scaleX *= a / 9, i.scaleY *= a / 9);
          var o = (r.fontSize || r.fontFamily) && [r.fontStyle, r.fontWeight, (r.fontSize || 12) + "px", r.fontFamily || "sans-serif"].join(" ");
          r.font = o;
          var s = i.getBoundingRect();
          return this._textX += s.width, e.add(i), i;
        }, n.internalField = function() {
          gD = { g: function(t, e) {
            var i = new Dt();
            return Ta(e, i), Xr(t, i, this._defsUsePending, false, false), i;
          }, rect: function(t, e) {
            var i = new fe();
            return Ta(e, i), Xr(t, i, this._defsUsePending, false, false), i.setShape({ x: parseFloat(t.getAttribute("x") || "0"), y: parseFloat(t.getAttribute("y") || "0"), width: parseFloat(t.getAttribute("width") || "0"), height: parseFloat(t.getAttribute("height") || "0") }), i.silent = true, i;
          }, circle: function(t, e) {
            var i = new $s();
            return Ta(e, i), Xr(t, i, this._defsUsePending, false, false), i.setShape({ cx: parseFloat(t.getAttribute("cx") || "0"), cy: parseFloat(t.getAttribute("cy") || "0"), r: parseFloat(t.getAttribute("r") || "0") }), i.silent = true, i;
          }, line: function(t, e) {
            var i = new Kn();
            return Ta(e, i), Xr(t, i, this._defsUsePending, false, false), i.setShape({ x1: parseFloat(t.getAttribute("x1") || "0"), y1: parseFloat(t.getAttribute("y1") || "0"), x2: parseFloat(t.getAttribute("x2") || "0"), y2: parseFloat(t.getAttribute("y2") || "0") }), i.silent = true, i;
          }, ellipse: function(t, e) {
            var i = new L1();
            return Ta(e, i), Xr(t, i, this._defsUsePending, false, false), i.setShape({ cx: parseFloat(t.getAttribute("cx") || "0"), cy: parseFloat(t.getAttribute("cy") || "0"), rx: parseFloat(t.getAttribute("rx") || "0"), ry: parseFloat(t.getAttribute("ry") || "0") }), i.silent = true, i;
          }, polygon: function(t, e) {
            var i = t.getAttribute("points"), r;
            i && (r = oq(i));
            var a = new Ki({ shape: { points: r || [] }, silent: true });
            return Ta(e, a), Xr(t, a, this._defsUsePending, false, false), a;
          }, polyline: function(t, e) {
            var i = t.getAttribute("points"), r;
            i && (r = oq(i));
            var a = new Ji({ shape: { points: r || [] }, silent: true });
            return Ta(e, a), Xr(t, a, this._defsUsePending, false, false), a;
          }, image: function(t, e) {
            var i = new gi();
            return Ta(e, i), Xr(t, i, this._defsUsePending, false, false), i.setStyle({ image: t.getAttribute("xlink:href") || t.getAttribute("href"), x: +t.getAttribute("x"), y: +t.getAttribute("y"), width: +t.getAttribute("width"), height: +t.getAttribute("height") }), i.silent = true, i;
          }, text: function(t, e) {
            var i = t.getAttribute("x") || "0", r = t.getAttribute("y") || "0", a = t.getAttribute("dx") || "0", o = t.getAttribute("dy") || "0";
            this._textX = parseFloat(i) + parseFloat(a), this._textY = parseFloat(r) + parseFloat(o);
            var s = new Dt();
            return Ta(e, s), Xr(t, s, this._defsUsePending, false, true), s;
          }, tspan: function(t, e) {
            var i = t.getAttribute("x"), r = t.getAttribute("y");
            i != null && (this._textX = parseFloat(i)), r != null && (this._textY = parseFloat(r));
            var a = t.getAttribute("dx") || "0", o = t.getAttribute("dy") || "0", s = new Dt();
            return Ta(e, s), Xr(t, s, this._defsUsePending, false, true), this._textX += parseFloat(a), this._textY += parseFloat(o), s;
          }, path: function(t, e) {
            var i = t.getAttribute("d") || "", r = E8(i);
            return Ta(e, r), Xr(t, r, this._defsUsePending, false, false), r.silent = true, r;
          } };
        }(), n;
      }(), iq = { lineargradient: function(n) {
        var t = parseInt(n.getAttribute("x1") || "0", 10), e = parseInt(n.getAttribute("y1") || "0", 10), i = parseInt(n.getAttribute("x2") || "10", 10), r = parseInt(n.getAttribute("y2") || "0", 10), a = new dv(t, e, i, r);
        return rq(n, a), aq(n, a), a;
      }, radialgradient: function(n) {
        var t = parseInt(n.getAttribute("cx") || "0", 10), e = parseInt(n.getAttribute("cy") || "0", 10), i = parseInt(n.getAttribute("r") || "0", 10), r = new b8(t, e, i);
        return rq(n, r), aq(n, r), r;
      } };
      function rq(n, t) {
        var e = n.getAttribute("gradientUnits");
        e === "userSpaceOnUse" && (t.global = true);
      }
      function aq(n, t) {
        for (var e = n.firstChild; e; ) {
          if (e.nodeType === 1 && e.nodeName.toLocaleLowerCase() === "stop") {
            var i = e.getAttribute("offset"), r = void 0;
            i && i.indexOf("%") > 0 ? r = parseInt(i, 10) / 100 : i ? r = parseFloat(i) : r = 0;
            var a = {};
            uq(e, a, a);
            var o = a.stopColor || e.getAttribute("stop-color") || "#000000";
            t.colorStops.push({ offset: r, color: o });
          }
          e = e.nextSibling;
        }
      }
      function Ta(n, t) {
        n && n.__inheritedStyle && (t.__inheritedStyle || (t.__inheritedStyle = {}), wt(t.__inheritedStyle, n.__inheritedStyle));
      }
      function oq(n) {
        for (var t = eI(n), e = [], i = 0; i < t.length; i += 2) {
          var r = parseFloat(t[i]), a = parseFloat(t[i + 1]);
          e.push([r, a]);
        }
        return e;
      }
      function Xr(n, t, e, i, r) {
        var a = t, o = a.__inheritedStyle = a.__inheritedStyle || {}, s = {};
        n.nodeType === 1 && (wBt(n, t), uq(n, o, s), i || CBt(n, o, s)), a.style = a.style || {}, o.fill != null && (a.style.fill = sq(a, "fill", o.fill, e)), o.stroke != null && (a.style.stroke = sq(a, "stroke", o.stroke, e)), D(["lineWidth", "opacity", "fillOpacity", "strokeOpacity", "miterLimit", "fontSize"], function(l) {
          o[l] != null && (a.style[l] = parseFloat(o[l]));
        }), D(["lineDashOffset", "lineCap", "lineJoin", "fontWeight", "fontFamily", "fontStyle", "textAlign"], function(l) {
          o[l] != null && (a.style[l] = o[l]);
        }), r && (a.__selfStyle = s), o.lineDash && (a.style.lineDash = K(eI(o.lineDash), function(l) {
          return parseFloat(l);
        })), (o.visibility === "hidden" || o.visibility === "collapse") && (a.invisible = true), o.display === "none" && (a.ignore = true);
      }
      function mBt(n, t) {
        var e = t.__selfStyle;
        if (e) {
          var i = e.textBaseline, r = i;
          !i || i === "auto" || i === "baseline" ? r = "alphabetic" : i === "before-edge" || i === "text-before-edge" ? r = "top" : i === "after-edge" || i === "text-after-edge" ? r = "bottom" : (i === "central" || i === "mathematical") && (r = "middle"), n.style.textBaseline = r;
        }
        var a = t.__inheritedStyle;
        if (a) {
          var o = a.textAlign, s = o;
          o && (o === "middle" && (s = "center"), n.style.textAlign = s);
        }
      }
      var _Bt = /^url\(\s*#(.*?)\)/;
      function sq(n, t, e, i) {
        var r = e && e.match(_Bt);
        if (r) {
          var a = Wa(r[1]);
          i.push([n, t, a]);
          return;
        }
        return e === "none" && (e = null), e;
      }
      function EBt(n, t) {
        for (var e = 0; e < t.length; e++) {
          var i = t[e];
          i[0].style[i[1]] = n[i[2]];
        }
      }
      var IBt = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
      function eI(n) {
        return n.match(IBt) || [];
      }
      var xBt = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, dD = Math.PI / 180;
      function wBt(n, t) {
        var e = n.getAttribute("transform");
        if (e) {
          e = e.replace(/,/g, " ");
          var i = [], r = null;
          e.replace(xBt, function(c, f, g) {
            return i.push(f, g), "";
          });
          for (var a = i.length - 1; a > 0; a -= 2) {
            var o = i[a], s = i[a - 1], l = eI(o);
            switch (r = r || Vr(), s) {
              case "translate":
                Go(r, r, [parseFloat(l[0]), parseFloat(l[1] || "0")]);
                break;
              case "scale":
                N2(r, r, [parseFloat(l[0]), parseFloat(l[1] || l[0])]);
                break;
              case "rotate":
                _h(r, r, -parseFloat(l[0]) * dD, [parseFloat(l[1] || "0"), parseFloat(l[2] || "0")]);
                break;
              case "skewX":
                var u = Math.tan(parseFloat(l[0]) * dD);
                zs(r, [1, 0, u, 1, 0, 0], r);
                break;
              case "skewY":
                var h = Math.tan(parseFloat(l[0]) * dD);
                zs(r, [1, h, 0, 1, 0, 0], r);
                break;
              case "matrix":
                r[0] = parseFloat(l[0]), r[1] = parseFloat(l[1]), r[2] = parseFloat(l[2]), r[3] = parseFloat(l[3]), r[4] = parseFloat(l[4]), r[5] = parseFloat(l[5]);
                break;
            }
          }
          t.setLocalTransform(r);
        }
      }
      var lq = /([^\s:;]+)\s*:\s*([^:;]+)/g;
      function uq(n, t, e) {
        var i = n.getAttribute("style");
        if (i) {
          lq.lastIndex = 0;
          for (var r; (r = lq.exec(i)) != null; ) {
            var a = r[1], o = ft(JE, a) ? JE[a] : null;
            o && (t[o] = r[2]);
            var s = ft(tI, a) ? tI[a] : null;
            s && (e[s] = r[2]);
          }
        }
      }
      function CBt(n, t, e) {
        for (var i = 0; i < eq.length; i++) {
          var r = eq[i], a = n.getAttribute(r);
          a != null && (t[JE[r]] = a);
        }
        for (var i = 0; i < nq.length; i++) {
          var r = nq[i], a = n.getAttribute(r);
          a != null && (e[tI[r]] = a);
        }
      }
      function hq(n, t) {
        var e = t.width / n.width, i = t.height / n.height, r = Math.min(e, i);
        return { scale: r, x: -(n.x + n.width / 2) * r + (t.x + t.width / 2), y: -(n.y + n.height / 2) * r + (t.y + t.height / 2) };
      }
      function SBt(n, t) {
        var e = new yBt();
        return e.parse(n, t);
      }
      var bBt = dt(["rect", "circle", "line", "ellipse", "polygon", "polyline", "path", "text", "tspan", "g"]), TBt = function() {
        function n(t, e) {
          this.type = "geoSVG", this._usedGraphicMap = dt(), this._freedGraphics = [], this._mapName = t, this._parsedXML = tq(e);
        }
        return n.prototype.load = function() {
          var t = this._firstGraphic;
          if (!t) {
            t = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(t), this._boundingRect = this._firstGraphic.boundingRect.clone();
            var e = MBt(t.named), i = e.regions, r = e.regionsMap;
            this._regions = i, this._regionsMap = r;
          }
          return { boundingRect: this._boundingRect, regions: this._regions, regionsMap: this._regionsMap };
        }, n.prototype._buildGraphic = function(t) {
          var e, i;
          try {
            e = t && SBt(t, { ignoreViewBox: true, ignoreRootClip: true }) || {}, i = e.root, It(i != null);
          } catch (p) {
            throw new Error(`Invalid svg format
` + p.message);
          }
          var r = new Dt();
          r.add(i), r.isGeoSVGGraphicRoot = true;
          var a = e.width, o = e.height, s = e.viewBoxRect, l = this._boundingRect;
          if (!l) {
            var u = void 0, h = void 0, c = void 0, f = void 0;
            if (a != null ? (u = 0, c = a) : s && (u = s.x, c = s.width), o != null ? (h = 0, f = o) : s && (h = s.y, f = s.height), u == null || h == null) {
              var g = i.getBoundingRect();
              u == null && (u = g.x, c = g.width), h == null && (h = g.y, f = g.height);
            }
            l = this._boundingRect = new Wt(u, h, c, f);
          }
          if (s) {
            var d = hq(s, l);
            i.scaleX = i.scaleY = d.scale, i.x = d.x, i.y = d.y;
          }
          r.setClipPath(new fe({ shape: l.plain() }));
          var A = [];
          return D(e.named, function(p) {
            bBt.get(p.svgNodeTagLower) != null && (A.push(p), BBt(p.el));
          }), { root: r, boundingRect: l, named: A };
        }, n.prototype.useGraphic = function(t) {
          var e = this._usedGraphicMap, i = e.get(t);
          return i || (i = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), e.set(t, i), i);
        }, n.prototype.freeGraphic = function(t) {
          var e = this._usedGraphicMap, i = e.get(t);
          i && (e.removeKey(t), this._freedGraphics.push(i));
        }, n;
      }();
      function BBt(n) {
        n.silent = false, n.isGroup && n.traverse(function(t) {
          t.silent = false;
        });
      }
      function MBt(n) {
        var t = [], e = dt();
        return D(n, function(i) {
          if (i.namedFrom == null) {
            var r = new wbt(i.name, i.el);
            t.push(r), e.set(i.name, r);
          }
        }), { regions: t, regionsMap: e };
      }
      for (var AD = [126, 25], cq = "", vc = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]], yc = 0; yc < vc.length; yc++) for (var md = 0; md < vc[yc].length; md++) vc[yc][md][0] /= 10.5, vc[yc][md][1] /= -10.5 / 0.75, vc[yc][md][0] += AD[0], vc[yc][md][1] += AD[1];
      function DBt(n, t) {
        if (n === "china") {
          for (var e = 0; e < t.length; e++) if (t[e].name === cq) return;
          t.push(new tj(cq, K(vc, function(i) {
            return { type: "polygon", exterior: i };
          }), AD));
        }
      }
      var RBt = { : [32, 80], : [0, -10], : [10, 5], : [-10, 10], : [5, 5] };
      function LBt(n, t) {
        if (n === "china") {
          var e = RBt[t.name];
          if (e) {
            var i = t.getCenter();
            i[0] += e[0] / 10.5, i[1] += -e[1] / (10.5 / 0.75), t.setCenter(i);
          }
        }
      }
      var PBt = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
      function NBt(n, t) {
        n === "china" && t.name === "" && t.geometries.push({ type: "polygon", exterior: PBt[0] });
      }
      var FBt = "name", kBt = function() {
        function n(t, e, i) {
          this.type = "geoJSON", this._parsedMap = dt(), this._mapName = t, this._specialAreas = i, this._geoJSON = QBt(e);
        }
        return n.prototype.load = function(t, e) {
          e = e || FBt;
          var i = this._parsedMap.get(e);
          if (!i) {
            var r = this._parseToRegions(e);
            i = this._parsedMap.set(e, { regions: r, boundingRect: OBt(r) });
          }
          var a = dt(), o = [];
          return D(i.regions, function(s) {
            var l = s.name;
            t && ft(t, l) && (s = s.cloneShallow(l = t[l])), o.push(s), a.set(l, s);
          }), { regions: o, boundingRect: i.boundingRect || new Wt(0, 0, 0, 0), regionsMap: a };
        }, n.prototype._parseToRegions = function(t) {
          var e = this._mapName, i = this._geoJSON, r;
          try {
            r = i ? Sbt(i, t) : [];
          } catch (a) {
            throw new Error(`Invalid geoJson format
` + a.message);
          }
          return DBt(e, r), D(r, function(a) {
            var o = a.name;
            LBt(e, a), NBt(e, a);
            var s = this._specialAreas && this._specialAreas[o];
            s && a.transformTo(s.left, s.top, s.width, s.height);
          }, this), r;
        }, n.prototype.getMapForUser = function() {
          return { geoJson: this._geoJSON, geoJSON: this._geoJSON, specialAreas: this._specialAreas };
        }, n;
      }();
      function OBt(n) {
        for (var t, e = 0; e < n.length; e++) {
          var i = n[e].getBoundingRect();
          t = t || i.clone(), t.union(i);
        }
        return t;
      }
      function QBt(n) {
        return ht(n) ? typeof JSON != "undefined" && JSON.parse ? JSON.parse(n) : new Function("return (" + n + ");")() : n;
      }
      var oy = dt();
      const nl = { registerMap: function(n, t, e) {
        if (t.svg) {
          var i = new TBt(n, t.svg);
          oy.set(n, i);
        } else {
          var r = t.geoJson || t.geoJSON;
          r && !t.features ? e = t.specialAreas : r = t;
          var i = new kBt(n, r, e);
          oy.set(n, i);
        }
      }, getGeoResource: function(n) {
        return oy.get(n);
      }, getMapForUser: function(n) {
        var t = oy.get(n);
        return t && t.type === "geoJSON" && t.getMapForUser();
      }, load: function(n, t, e) {
        var i = oy.get(n);
        if (!i) {
          return;
        }
        return i.load(t, e);
      } };
      var pD = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"], zBt = dt(pD), GBt = dt(pD.concat(["g"])), UBt = dt(pD.concat(["g"])), fq = ce();
      function nI(n) {
        var t = n.getItemStyle(), e = n.get("areaColor");
        return e != null && (t.fill = e), t;
      }
      function gq(n) {
        var t = n.style;
        t && (t.stroke = t.stroke || t.fill, t.fill = null);
      }
      var dq = function() {
        function n(t) {
          var e = new Dt();
          this.uid = Yg("ec_map_draw"), this._controller = new ay(t.getZr()), this._controllerHost = { target: e }, this.group = e, e.add(this._regionsGroup = new Dt()), e.add(this._svgGroup = new Dt());
        }
        return n.prototype.draw = function(t, e, i, r, a) {
          var o = t.mainType === "geo", s = t.getData && t.getData();
          o && e.eachComponent({ mainType: "series", subType: "map" }, function(v) {
            !s && v.getHostGeoModel() === t && (s = v.getData());
          });
          var l = t.coordinateSystem, u = this._regionsGroup, h = this.group, c = l.getTransformInfo(), f = c.raw, g = c.roam, d = !u.childAt(0) || a;
          d ? (h.x = g.x, h.y = g.y, h.scaleX = g.scaleX, h.scaleY = g.scaleY, h.dirty()) : Ee(h, g, t);
          var A = s && s.getVisual("visualMeta") && s.getVisual("visualMeta").length > 0, p = { api: i, geo: l, mapOrGeoModel: t, data: s, isVisualEncodedByVisualMap: A, isGeo: o, transformInfoRaw: f };
          l.resourceType === "geoJSON" ? this._buildGeoJSON(p) : l.resourceType === "geoSVG" && this._buildSVG(p), this._updateController(t, e, i), this._updateMapSelectHandler(t, u, i, r);
        }, n.prototype._buildGeoJSON = function(t) {
          var e = this._regionsGroupByName = dt(), i = dt(), r = this._regionsGroup, a = t.transformInfoRaw, o = t.mapOrGeoModel, s = t.data, l = t.geo.projection, u = l && l.stream;
          function h(g, d) {
            return d && (g = d(g)), g && [g[0] * a.scaleX + a.x, g[1] * a.scaleY + a.y];
          }
          function c(g) {
            for (var d = [], A = !u && l && l.project, p = 0; p < g.length; ++p) {
              var v = h(g[p], A);
              v && d.push(v);
            }
            return d;
          }
          function f(g) {
            return { shape: { points: c(g) } };
          }
          r.removeAll(), D(t.geo.regions, function(g) {
            var d = g.name, A = e.get(d), p = i.get(d) || {}, v = p.dataIdx, y = p.regionModel;
            A || (A = e.set(d, new Dt()), r.add(A), v = s ? s.indexOfName(d) : null, y = t.isGeo ? o.getRegionModel(d) : s ? s.getItemModel(v) : null, i.set(d, { dataIdx: v, regionModel: y }));
            var m = [], _ = [];
            D(g.geometries, function(x) {
              if (x.type === "polygon") {
                var w = [x.exterior].concat(x.interiors || []);
                u && (w = _q(w, u)), D(w, function(S) {
                  m.push(new Ki(f(S)));
                });
              } else {
                var C = x.points;
                u && (C = _q(C, u, true)), D(C, function(S) {
                  _.push(new Ji(f(S)));
                });
              }
            });
            var I = h(g.getCenter(), l && l.project);
            function E(x, w) {
              if (x.length) {
                var C = new iB({ culling: true, segmentIgnoreThreshold: 1, shape: { paths: x } });
                A.add(C), Aq(t, C, v, y), pq(t, C, d, y, o, v, I), w && (gq(C), D(C.states, gq));
              }
            }
            E(m), E(_, true);
          }), e.each(function(g, d) {
            var A = i.get(d), p = A.dataIdx, v = A.regionModel;
            vq(t, g, d, v, o, p), yq(t, g, d, v, o), mq(t, g, d, v, o);
          }, this);
        }, n.prototype._buildSVG = function(t) {
          var e = t.geo.map, i = t.transformInfoRaw;
          this._svgGroup.x = i.x, this._svgGroup.y = i.y, this._svgGroup.scaleX = i.scaleX, this._svgGroup.scaleY = i.scaleY, this._svgResourceChanged(e) && (this._freeSVG(), this._useSVG(e));
          var r = this._svgDispatcherMap = dt(), a = false;
          D(this._svgGraphicRecord.named, function(o) {
            var s = o.name, l = t.mapOrGeoModel, u = t.data, h = o.svgNodeTagLower, c = o.el, f = u ? u.indexOfName(s) : null, g = l.getRegionModel(s);
            if (zBt.get(h) != null && c instanceof ya && Aq(t, c, f, g), c instanceof ya && (c.culling = true), c.z2EmphasisLift = 0, !o.namedFrom && (UBt.get(h) != null && pq(t, c, s, g, l, f, null), vq(t, c, s, g, l, f), yq(t, c, s, g, l), GBt.get(h) != null)) {
              var d = mq(t, c, s, g, l);
              d === "self" && (a = true);
              var A = r.get(s) || r.set(s, []);
              A.push(c);
            }
          }, this), this._enableBlurEntireSVG(a, t);
        }, n.prototype._enableBlurEntireSVG = function(t, e) {
          if (t && e.isGeo) {
            var i = e.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle(), r = i.opacity;
            this._svgGraphicRecord.root.traverse(function(a) {
              if (!a.isGroup) {
                Gh(a);
                var o = a.ensureState("blur").style || {};
                o.opacity == null && r != null && (o.opacity = r), a.ensureState("emphasis");
              }
            });
          }
        }, n.prototype.remove = function() {
          this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
        }, n.prototype.findHighDownDispatchers = function(t, e) {
          if (t == null) return [];
          var i = e.coordinateSystem;
          if (i.resourceType === "geoJSON") {
            var r = this._regionsGroupByName;
            if (r) {
              var a = r.get(t);
              return a ? [a] : [];
            }
          } else if (i.resourceType === "geoSVG") return this._svgDispatcherMap && this._svgDispatcherMap.get(t) || [];
        }, n.prototype._svgResourceChanged = function(t) {
          return this._svgMapName !== t;
        }, n.prototype._useSVG = function(t) {
          var e = nl.getGeoResource(t);
          if (e && e.type === "geoSVG") {
            var i = e.useGraphic(this.uid);
            this._svgGroup.add(i.root), this._svgGraphicRecord = i, this._svgMapName = t;
          }
        }, n.prototype._freeSVG = function() {
          var t = this._svgMapName;
          if (t != null) {
            var e = nl.getGeoResource(t);
            e && e.type === "geoSVG" && e.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
          }
        }, n.prototype._updateController = function(t, e, i) {
          var r = t.coordinateSystem, a = this._controller, o = this._controllerHost;
          o.zoomLimit = t.get("scaleLimit"), o.zoom = r.getZoom(), a.enable(t.get("roam") || false);
          var s = t.mainType;
          function l() {
            var u = { type: "geoRoam", componentType: s };
            return u[s + "Id"] = t.id, u;
          }
          a.off("pan").on("pan", function(u) {
            this._mouseDownFlag = false, cD(o, u.dx, u.dy), i.dispatchAction(X(l(), { dx: u.dx, dy: u.dy, animation: { duration: 0 } }));
          }, this), a.off("zoom").on("zoom", function(u) {
            this._mouseDownFlag = false, fD(o, u.scale, u.originX, u.originY), i.dispatchAction(X(l(), { totalZoom: o.zoom, zoom: u.scale, originX: u.originX, originY: u.originY, animation: { duration: 0 } }));
          }, this), a.setPointerChecker(function(u, h, c) {
            return r.containPoint([h, c]) && !KE(u, i, t);
          });
        }, n.prototype.resetForLabelLayout = function() {
          this.group.traverse(function(t) {
            var e = t.getTextContent();
            e && (e.ignore = fq(e).ignore);
          });
        }, n.prototype._updateMapSelectHandler = function(t, e, i, r) {
          var a = this;
          e.off("mousedown"), e.off("click"), t.get("selectedMode") && (e.on("mousedown", function() {
            a._mouseDownFlag = true;
          }), e.on("click", function(o) {
            a._mouseDownFlag && (a._mouseDownFlag = false);
          }));
        }, n;
      }();
      function Aq(n, t, e, i) {
        var r = i.getModel("itemStyle"), a = i.getModel(["emphasis", "itemStyle"]), o = i.getModel(["blur", "itemStyle"]), s = i.getModel(["select", "itemStyle"]), l = nI(r), u = nI(a), h = nI(s), c = nI(o), f = n.data;
        if (f) {
          var g = f.getItemVisual(e, "style"), d = f.getItemVisual(e, "decal");
          n.isVisualEncodedByVisualMap && g.fill && (l.fill = g.fill), d && (l.decal = ud(d, n.api));
        }
        t.setStyle(l), t.style.strokeNoScale = true, t.ensureState("emphasis").style = u, t.ensureState("select").style = h, t.ensureState("blur").style = c, Gh(t);
      }
      function pq(n, t, e, i, r, a, o) {
        var s = n.data, l = n.isGeo, u = s && isNaN(s.get(s.mapDimension("value"), a)), h = s && s.getItemLayout(a);
        if (l || u || h && h.showLabel) {
          var c = l ? e : a, f = void 0;
          (!s || a >= 0) && (f = r);
          var g = o ? { normal: { align: "center", verticalAlign: "middle" } } : null;
          xi(t, Jn(i), { labelFetcher: f, labelDataIndex: c, defaultText: e }, g);
          var d = t.getTextContent();
          if (d && (fq(d).ignore = d.ignore, t.textConfig && o)) {
            var A = t.getBoundingRect().clone();
            t.textConfig.layoutRect = A, t.textConfig.position = [(o[0] - A.x) / A.width * 100 + "%", (o[1] - A.y) / A.height * 100 + "%"];
          }
          t.disableLabelAnimation = true;
        } else t.removeTextContent(), t.removeTextConfig(), t.disableLabelAnimation = null;
      }
      function vq(n, t, e, i, r, a) {
        n.data ? n.data.setItemGraphicEl(a, t) : Nt(t).eventData = { componentType: "geo", componentIndex: r.componentIndex, geoIndex: r.componentIndex, name: e, region: i && i.option || {} };
      }
      function yq(n, t, e, i, r) {
        n.data || qg({ el: t, componentModel: r, itemName: e, itemTooltipOption: i.get("tooltip") });
      }
      function mq(n, t, e, i, r) {
        t.highDownSilentOnTouch = !!r.get("selectedMode");
        var a = i.getModel("emphasis"), o = a.get("focus");
        return pn(t, o, a.get("blurScope"), a.get("disabled")), n.isGeo && OIt(t, r, e), o;
      }
      function _q(n, t, e) {
        var i = [], r;
        function a() {
          r = [];
        }
        function o() {
          r.length && (i.push(r), r = []);
        }
        var s = t({ polygonStart: a, polygonEnd: o, lineStart: a, lineEnd: o, point: function(l, u) {
          isFinite(l) && isFinite(u) && r.push([l, u]);
        }, sphere: function() {
        } });
        return !e && s.polygonStart(), D(n, function(l) {
          s.lineStart();
          for (var u = 0; u < l.length; u++) s.point(l[u][0], l[u][1]);
          s.lineEnd();
        }), !e && s.polygonEnd(), i;
      }
      var VBt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r, a) {
          if (!(a && a.type === "mapToggleSelect" && a.from === this.uid)) {
            var o = this.group;
            if (o.removeAll(), !e.getHostGeoModel()) {
              if (this._mapDraw && a && a.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), a && a.type === "geoRoam" && a.componentType === "series" && a.seriesId === e.id) {
                var s = this._mapDraw;
                s && o.add(s.group);
              } else if (e.needsDrawMap) {
                var s = this._mapDraw || new dq(r);
                o.add(s.group), s.draw(e, i, r, this, a), this._mapDraw = s;
              } else this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
              e.get("showLegendSymbol") && i.getComponent("legend") && this._renderSymbols(e, i, r);
            }
          }
        }, t.prototype.remove = function() {
          this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
        }, t.prototype.dispose = function() {
          this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        }, t.prototype._renderSymbols = function(e, i, r) {
          var a = e.originalData, o = this.group;
          a.each(a.mapDimension("value"), function(s, l) {
            if (!isNaN(s)) {
              var u = a.getItemLayout(l);
              if (!(!u || !u.point)) {
                var h = u.point, c = u.offset, f = new $s({ style: { fill: e.getData().getVisual("style").fill }, shape: { cx: h[0] + c * 9, cy: h[1], r: 3 }, silent: true, z2: 8 + (c ? 0 : Og + 1) });
                if (!c) {
                  var g = e.mainSeries.getData(), d = a.getName(l), A = g.indexOfName(d), p = a.getItemModel(l), v = p.getModel("label"), y = g.getItemGraphicEl(A);
                  xi(f, Jn(p), { labelFetcher: { getFormattedLabel: function(m, _) {
                    return e.getFormattedLabel(A, _);
                  } }, defaultText: d }), f.disableLabelAnimation = true, v.get("position") || f.setTextConfig({ position: "bottom" }), y.onHoverStateChange = function(m) {
                    M1(f, m);
                  };
                }
                o.add(f);
              }
            }
          });
        }, t.type = "map", t;
      }(qe), jBt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.needsDrawMap = false, e.seriesGroup = [], e.getTooltipPosition = function(i) {
            if (i != null) {
              var r = this.getData().getName(i), a = this.coordinateSystem, o = a.getRegion(r);
              return o && a.dataToPoint(o.getCenter());
            }
          }, e;
        }
        return t.prototype.getInitialData = function(e) {
          for (var i = vd(this, { coordDimensions: ["value"], encodeDefaulter: Gt(xB, this) }), r = dt(), a = [], o = 0, s = i.count(); o < s; o++) {
            var l = i.getName(o);
            r.set(l, true);
          }
          var u = nl.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
          return D(u.regions, function(h) {
            var c = h.name;
            r.get(c) || a.push(c);
          }), i.appendValues([], a), i;
        }, t.prototype.getHostGeoModel = function() {
          var e = this.option.geoIndex;
          return e != null ? this.ecModel.getComponent("geo", e) : null;
        }, t.prototype.getMapType = function() {
          return (this.getHostGeoModel() || this).option.map;
        }, t.prototype.getRawValue = function(e) {
          var i = this.getData();
          return i.get(i.mapDimension("value"), e);
        }, t.prototype.getRegionModel = function(e) {
          var i = this.getData();
          return i.getItemModel(i.indexOfName(e));
        }, t.prototype.formatTooltip = function(e, i, r) {
          for (var a = this.getData(), o = this.getRawValue(e), s = a.getName(e), l = this.seriesGroup, u = [], h = 0; h < l.length; h++) {
            var c = l[h].originalData.indexOfName(s), f = a.mapDimension("value");
            isNaN(l[h].originalData.get(f, c)) || u.push(l[h].name);
          }
          return ti("section", { header: u.join(", "), noHeader: !u.length, blocks: [ti("nameValue", { name: s, value: o })] });
        }, t.prototype.setZoom = function(e) {
          this.option.zoom = e;
        }, t.prototype.setCenter = function(e) {
          this.option.center = e;
        }, t.prototype.getLegendIcon = function(e) {
          var i = e.icon || "roundRect", r = Un(i, 0, 0, e.itemWidth, e.itemHeight, e.itemStyle.fill);
          return r.setStyle(e.itemStyle), r.style.stroke = "none", i.indexOf("empty") > -1 && (r.style.stroke = r.style.fill, r.style.fill = "#fff", r.style.lineWidth = 2), r;
        }, t.type = "series.map", t.dependencies = ["geo"], t.layoutMode = "box", t.defaultOption = { z: 2, coordinateSystem: "geo", map: "", left: "center", top: "center", aspectScale: null, showLegendSymbol: true, boundingCoords: null, center: null, zoom: 1, scaleLimit: null, selectedMode: true, label: { show: false, color: "#000" }, itemStyle: { borderWidth: 0.5, borderColor: "#444", areaColor: "#eee" }, emphasis: { label: { show: true, color: "rgb(100,0,0)" }, itemStyle: { areaColor: "rgba(255,215,0,0.8)" } }, select: { label: { show: true, color: "rgb(100,0,0)" }, itemStyle: { color: "rgba(255,215,0,0.8)" } }, nameProperty: "name" }, t;
      }(tn);
      function qBt(n, t) {
        var e = {};
        return D(n, function(i) {
          i.each(i.mapDimension("value"), function(r, a) {
            var o = "ec-" + i.getName(a);
            e[o] = e[o] || [], isNaN(r) || e[o].push(r);
          });
        }), n[0].map(n[0].mapDimension("value"), function(i, r) {
          for (var a = "ec-" + n[0].getName(r), o = 0, s = 1 / 0, l = -1 / 0, u = e[a].length, h = 0; h < u; h++) s = Math.min(s, e[a][h]), l = Math.max(l, e[a][h]), o += e[a][h];
          var c;
          return t === "min" ? c = s : t === "max" ? c = l : t === "average" ? c = o / u : c = o, u === 0 ? NaN : c;
        });
      }
      function HBt(n) {
        var t = {};
        n.eachSeriesByType("map", function(e) {
          var i = e.getHostGeoModel(), r = i ? "o" + i.id : "i" + e.getMapType();
          (t[r] = t[r] || []).push(e);
        }), D(t, function(e, i) {
          for (var r = qBt(K(e, function(o) {
            return o.getData();
          }), e[0].get("mapValueCalculation")), a = 0; a < e.length; a++) e[a].originalData = e[a].getData();
          for (var a = 0; a < e.length; a++) e[a].seriesGroup = e, e[a].needsDrawMap = a === 0 && !e[a].getHostGeoModel(), e[a].setData(r.cloneShallow()), e[a].mainSeries = e[0];
        });
      }
      function YBt(n) {
        var t = {};
        n.eachSeriesByType("map", function(e) {
          var i = e.getMapType();
          if (!(e.getHostGeoModel() || t[i])) {
            var r = {};
            D(e.seriesGroup, function(o) {
              var s = o.coordinateSystem, l = o.originalData;
              o.get("showLegendSymbol") && n.getComponent("legend") && l.each(l.mapDimension("value"), function(u, h) {
                var c = l.getName(h), f = s.getRegion(c);
                if (!(!f || isNaN(u))) {
                  var g = r[c] || 0, d = s.dataToPoint(f.getCenter());
                  r[c] = g + 1, l.setItemLayout(h, { point: d, offset: g });
                }
              });
            });
            var a = e.getData();
            a.each(function(o) {
              var s = a.getName(o), l = a.getItemLayout(o) || {};
              l.showLabel = !r[s], a.setItemLayout(o, l);
            }), t[i] = true;
          }
        });
      }
      var Eq = _i, sy = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this) || this;
          return i.type = "view", i.dimensions = ["x", "y"], i._roamTransformable = new Vs(), i._rawTransformable = new Vs(), i.name = e, i;
        }
        return t.prototype.setBoundingRect = function(e, i, r, a) {
          return this._rect = new Wt(e, i, r, a), this._rect;
        }, t.prototype.getBoundingRect = function() {
          return this._rect;
        }, t.prototype.setViewRect = function(e, i, r, a) {
          this._transformTo(e, i, r, a), this._viewRect = new Wt(e, i, r, a);
        }, t.prototype._transformTo = function(e, i, r, a) {
          var o = this.getBoundingRect(), s = this._rawTransformable;
          s.transform = o.calculateTransform(new Wt(e, i, r, a));
          var l = s.parent;
          s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform();
        }, t.prototype.setCenter = function(e, i) {
          e && (this._center = [st(e[0], i.getWidth()), st(e[1], i.getHeight())], this._updateCenterAndZoom());
        }, t.prototype.setZoom = function(e) {
          e = e || 1;
          var i = this.zoomLimit;
          i && (i.max != null && (e = Math.min(i.max, e)), i.min != null && (e = Math.max(i.min, e))), this._zoom = e, this._updateCenterAndZoom();
        }, t.prototype.getDefaultCenter = function() {
          var e = this.getBoundingRect(), i = e.x + e.width / 2, r = e.y + e.height / 2;
          return [i, r];
        }, t.prototype.getCenter = function() {
          return this._center || this.getDefaultCenter();
        }, t.prototype.getZoom = function() {
          return this._zoom || 1;
        }, t.prototype.getRoamTransform = function() {
          return this._roamTransformable.getLocalTransform();
        }, t.prototype._updateCenterAndZoom = function() {
          var e = this._rawTransformable.getLocalTransform(), i = this._roamTransformable, r = this.getDefaultCenter(), a = this.getCenter(), o = this.getZoom();
          a = _i([], a, e), r = _i([], r, e), i.originX = a[0], i.originY = a[1], i.x = r[0] - a[0], i.y = r[1] - a[1], i.scaleX = i.scaleY = o, this._updateTransform();
        }, t.prototype._updateTransform = function() {
          var e = this._roamTransformable, i = this._rawTransformable;
          i.parent = e, e.updateTransform(), i.updateTransform(), P2(this.transform || (this.transform = []), i.transform || Vr()), this._rawTransform = i.getLocalTransform(), this.invTransform = this.invTransform || [], Sg(this.invTransform, this.transform), this.decomposeTransform();
        }, t.prototype.getTransformInfo = function() {
          var e = this._rawTransformable, i = this._roamTransformable, r = new Vs();
          return r.transform = i.transform, r.decomposeTransform(), { roam: { x: r.x, y: r.y, scaleX: r.scaleX, scaleY: r.scaleY }, raw: { x: e.x, y: e.y, scaleX: e.scaleX, scaleY: e.scaleY } };
        }, t.prototype.getViewRect = function() {
          return this._viewRect;
        }, t.prototype.getViewRectAfterRoam = function() {
          var e = this.getBoundingRect().clone();
          return e.applyTransform(this.transform), e;
        }, t.prototype.dataToPoint = function(e, i, r) {
          var a = i ? this._rawTransform : this.transform;
          return r = r || [], a ? Eq(r, e, a) : Wi(r, e);
        }, t.prototype.pointToData = function(e) {
          var i = this.invTransform;
          return i ? Eq([], e, i) : [e[0], e[1]];
        }, t.prototype.convertToPixel = function(e, i, r) {
          var a = Iq(i);
          return a === this ? a.dataToPoint(r) : null;
        }, t.prototype.convertFromPixel = function(e, i, r) {
          var a = Iq(i);
          return a === this ? a.pointToData(r) : null;
        }, t.prototype.containPoint = function(e) {
          return this.getViewRectAfterRoam().contain(e[0], e[1]);
        }, t.dimensions = ["x", "y"], t;
      }(Vs);
      function Iq(n) {
        var t = n.seriesModel;
        return t ? t.coordinateSystem : null;
      }
      var WBt = { geoJSON: { aspectScale: 0.75, invertLongitute: true }, geoSVG: { aspectScale: 1, invertLongitute: false } }, xq = ["lng", "lat"], vD = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this, e) || this;
          a.dimensions = xq, a.type = "geo", a._nameCoordMap = dt(), a.map = i;
          var o = r.projection, s = nl.load(i, r.nameMap, r.nameProperty), l = nl.getGeoResource(i), u = a.resourceType = l ? l.type : null, h = a.regions = s.regions, c = WBt[l.type];
          a._regionsMap = s.regionsMap, a.regions = s.regions, o && (u === "geoSVG" && (gn("Map " + i + " with SVG source can't use projection. Only GeoJSON source supports projection."), o = null), o.project && o.unproject || (gn("project and unproject must be both provided in the projeciton."), o = null)), a.projection = o;
          var f;
          if (o) for (var g = 0; g < h.length; g++) {
            var d = h[g].getBoundingRect(o);
            f = f || d.clone(), f.union(d);
          }
          else f = s.boundingRect;
          return a.setBoundingRect(f.x, f.y, f.width, f.height), a.aspectScale = o ? 1 : kt(r.aspectScale, c.aspectScale), a._invertLongitute = o ? false : c.invertLongitute, a;
        }
        return t.prototype._transformTo = function(e, i, r, a) {
          var o = this.getBoundingRect(), s = this._invertLongitute;
          o = o.clone(), s && (o.y = -o.y - o.height);
          var l = this._rawTransformable;
          l.transform = o.calculateTransform(new Wt(e, i, r, a));
          var u = l.parent;
          l.parent = null, l.decomposeTransform(), l.parent = u, s && (l.scaleY = -l.scaleY), this._updateTransform();
        }, t.prototype.getRegion = function(e) {
          return this._regionsMap.get(e);
        }, t.prototype.getRegionByCoord = function(e) {
          for (var i = this.regions, r = 0; r < i.length; r++) {
            var a = i[r];
            if (a.type === "geoJSON" && a.contain(e)) return i[r];
          }
        }, t.prototype.addGeoCoord = function(e, i) {
          this._nameCoordMap.set(e, i);
        }, t.prototype.getGeoCoord = function(e) {
          var i = this._regionsMap.get(e);
          return this._nameCoordMap.get(e) || i && i.getCenter();
        }, t.prototype.dataToPoint = function(e, i, r) {
          if (ht(e) && (e = this.getGeoCoord(e)), e) {
            var a = this.projection;
            return a && (e = a.project(e)), e && this.projectedToPoint(e, i, r);
          }
        }, t.prototype.pointToData = function(e) {
          var i = this.projection;
          return i && (e = i.unproject(e)), e && this.pointToProjected(e);
        }, t.prototype.pointToProjected = function(e) {
          return n.prototype.pointToData.call(this, e);
        }, t.prototype.projectedToPoint = function(e, i, r) {
          return n.prototype.dataToPoint.call(this, e, i, r);
        }, t.prototype.convertToPixel = function(e, i, r) {
          var a = wq(i);
          return a === this ? a.dataToPoint(r) : null;
        }, t.prototype.convertFromPixel = function(e, i, r) {
          var a = wq(i);
          return a === this ? a.pointToData(r) : null;
        }, t;
      }(sy);
      kn(vD, sy);
      function wq(n) {
        var t = n.geoModel, e = n.seriesModel;
        return t ? t.coordinateSystem : e ? e.coordinateSystem || (e.getReferringComponents("geo", zn).models[0] || {}).coordinateSystem : null;
      }
      function Cq(n, t) {
        var e = n.get("boundingCoords");
        if (e != null) {
          var i = e[0], r = e[1];
          if (!(isFinite(i[0]) && isFinite(i[1]) && isFinite(r[0]) && isFinite(r[1]))) ;
          else {
            var a = this.projection;
            if (a) {
              var o = i[0], s = i[1], l = r[0], u = r[1];
              i = [1 / 0, 1 / 0], r = [-1 / 0, -1 / 0];
              var h = function(E, x, w, C) {
                for (var S = w - E, b = C - x, T = 0; T <= 100; T++) {
                  var B = T / 100, R = a.project([E + S * B, x + b * B]);
                  Zl(i, i, R), Kl(r, r, R);
                }
              };
              h(o, s, l, s), h(l, s, l, u), h(l, u, o, u), h(o, u, l, s);
            }
            this.setBoundingRect(i[0], i[1], r[0] - i[0], r[1] - i[1]);
          }
        }
        var c = this.getBoundingRect(), f = n.get("layoutCenter"), g = n.get("layoutSize"), d = t.getWidth(), A = t.getHeight(), p = c.width / c.height * this.aspectScale, v = false, y, m;
        f && g && (y = [st(f[0], d), st(f[1], A)], m = st(g, Math.min(d, A)), !isNaN(y[0]) && !isNaN(y[1]) && !isNaN(m) ? v = true : "development");
        var _;
        if (v) _ = {}, p > 1 ? (_.width = m, _.height = m / p) : (_.height = m, _.width = m * p), _.y = y[1] - _.height / 2, _.x = y[0] - _.width / 2;
        else {
          var I = n.getBoxLayoutParams();
          I.aspect = p, _ = Yn(I, { width: d, height: A });
        }
        this.setViewRect(_.x, _.y, _.width, _.height), this.setCenter(n.get("center"), t), this.setZoom(n.get("zoom"));
      }
      function XBt(n, t) {
        D(t.get("geoCoord"), function(e, i) {
          n.addGeoCoord(i, e);
        });
      }
      var $Bt = function() {
        function n() {
          this.dimensions = xq;
        }
        return n.prototype.create = function(t, e) {
          var i = [];
          function r(o) {
            return { nameProperty: o.get("nameProperty"), aspectScale: o.get("aspectScale"), projection: o.get("projection") };
          }
          t.eachComponent("geo", function(o, s) {
            var l = o.get("map"), u = new vD(l + s, l, X({ nameMap: o.get("nameMap") }, r(o)));
            u.zoomLimit = o.get("scaleLimit"), i.push(u), o.coordinateSystem = u, u.model = o, u.resize = Cq, u.resize(o, e);
          }), t.eachSeries(function(o) {
            var s = o.get("coordinateSystem");
            if (s === "geo") {
              var l = o.get("geoIndex") || 0;
              o.coordinateSystem = i[l];
            }
          });
          var a = {};
          return t.eachSeriesByType("map", function(o) {
            if (!o.getHostGeoModel()) {
              var s = o.getMapType();
              a[s] = a[s] || [], a[s].push(o);
            }
          }), D(a, function(o, s) {
            var l = K(o, function(h) {
              return h.get("nameMap");
            }), u = new vD(s, s, X({ nameMap: _2(l) }, r(o[0])));
            u.zoomLimit = On.apply(null, K(o, function(h) {
              return h.get("scaleLimit");
            })), i.push(u), u.resize = Cq, u.resize(o[0], e), D(o, function(h) {
              h.coordinateSystem = u, XBt(u, h);
            });
          }), i;
        }, n.prototype.getFilledRegions = function(t, e, i, r) {
          for (var a = (t || []).slice(), o = dt(), s = 0; s < a.length; s++) o.set(a[s].name, a[s]);
          var l = nl.load(e, i, r);
          return D(l.regions, function(u) {
            var h = u.name;
            !o.get(h) && a.push({ name: h });
          }), a;
        }, n;
      }(), Sq = new $Bt(), ZBt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e, i, r) {
          var a = nl.getGeoResource(e.map);
          if (a && a.type === "geoJSON") {
            var o = e.itemStyle = e.itemStyle || {};
            "color" in o || (o.color = "#eee");
          }
          this.mergeDefaultAndTheme(e, r), Th(e, "label", ["show"]);
        }, t.prototype.optionUpdated = function() {
          var e = this, i = this.option;
          i.regions = Sq.getFilledRegions(i.regions, i.map, i.nameMap, i.nameProperty);
          var r = {};
          this._optionModelMap = zo(i.regions || [], function(a, o) {
            var s = o.name;
            return s && (a.set(s, new De(o, e, e.ecModel)), o.selected && (r[s] = true)), a;
          }, dt()), i.selectedMap || (i.selectedMap = r);
        }, t.prototype.getRegionModel = function(e) {
          return this._optionModelMap.get(e) || new De(null, this, this.ecModel);
        }, t.prototype.getFormattedLabel = function(e, i) {
          var r = this.getRegionModel(e), a = i === "normal" ? r.get(["label", "formatter"]) : r.get(["emphasis", "label", "formatter"]), o = { name: e };
          if (yt(a)) return o.status = i, a(o);
          if (ht(a)) return a.replace("{a}", e != null ? e : "");
        }, t.prototype.setZoom = function(e) {
          this.option.zoom = e;
        }, t.prototype.setCenter = function(e) {
          this.option.center = e;
        }, t.prototype.select = function(e) {
          var i = this.option, r = i.selectedMode;
          if (r) {
            r !== "multiple" && (i.selectedMap = null);
            var a = i.selectedMap || (i.selectedMap = {});
            a[e] = true;
          }
        }, t.prototype.unSelect = function(e) {
          var i = this.option.selectedMap;
          i && (i[e] = false);
        }, t.prototype.toggleSelected = function(e) {
          this[this.isSelected(e) ? "unSelect" : "select"](e);
        }, t.prototype.isSelected = function(e) {
          var i = this.option.selectedMap;
          return !!(i && i[e]);
        }, t.type = "geo", t.layoutMode = "box", t.defaultOption = { z: 0, show: true, left: "center", top: "center", aspectScale: null, silent: false, map: "", boundingCoords: null, center: null, zoom: 1, scaleLimit: null, label: { show: false, color: "#000" }, itemStyle: { borderWidth: 0.5, borderColor: "#444" }, emphasis: { label: { show: true, color: "rgb(100,0,0)" }, itemStyle: { color: "rgba(255,215,0,0.8)" } }, select: { label: { show: true, color: "rgb(100,0,0)" }, itemStyle: { color: "rgba(255,215,0,0.8)" } }, regions: [] }, t;
      }(ae);
      function bq(n, t) {
        return n.pointToProjected ? n.pointToProjected(t) : n.pointToData(t);
      }
      function yD(n, t, e, i) {
        var r = n.getZoom(), a = n.getCenter(), o = t.zoom, s = n.projectedToPoint ? n.projectedToPoint(a) : n.dataToPoint(a);
        if (t.dx != null && t.dy != null && (s[0] -= t.dx, s[1] -= t.dy, n.setCenter(bq(n, s), i)), o != null) {
          if (e) {
            var l = e.min || 0, u = e.max || 1 / 0;
            o = Math.max(Math.min(r * o, u), l) / r;
          }
          n.scaleX *= o, n.scaleY *= o;
          var h = (t.originX - n.x) * (o - 1), c = (t.originY - n.y) * (o - 1);
          n.x -= h, n.y -= c, n.updateTransform(), n.setCenter(bq(n, s), i), n.setZoom(o * r);
        }
        return { center: n.getCenter(), zoom: n.getZoom() };
      }
      var KBt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.focusBlurEnabled = true, e;
        }
        return t.prototype.init = function(e, i) {
          this._api = i;
        }, t.prototype.render = function(e, i, r, a) {
          if (this._model = e, !e.get("show")) {
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
            return;
          }
          this._mapDraw || (this._mapDraw = new dq(r));
          var o = this._mapDraw;
          o.draw(e, i, r, this, a), o.group.on("click", this._handleRegionClick, this), o.group.silent = e.get("silent"), this.group.add(o.group), this.updateSelectStatus(e, i, r);
        }, t.prototype._handleRegionClick = function(e) {
          var i;
          ec(e.target, function(r) {
            return (i = Nt(r).eventData) != null;
          }, true), i && this._api.dispatchAction({ type: "geoToggleSelect", geoId: this._model.id, name: i.name });
        }, t.prototype.updateSelectStatus = function(e, i, r) {
          var a = this;
          this._mapDraw.group.traverse(function(o) {
            var s = Nt(o).eventData;
            if (s) return a._model.isSelected(s.name) ? r.enterSelect(o) : r.leaveSelect(o), true;
          });
        }, t.prototype.findHighDownDispatchers = function(e) {
          return this._mapDraw && this._mapDraw.findHighDownDispatchers(e, this._model);
        }, t.prototype.dispose = function() {
          this._mapDraw && this._mapDraw.remove();
        }, t.type = "geo", t;
      }(un);
      function JBt(n, t, e) {
        nl.registerMap(n, t, e);
      }
      function Tq(n) {
        n.registerCoordinateSystem("geo", Sq), n.registerComponentModel(ZBt), n.registerComponentView(KBt), n.registerImpl("registerMap", JBt), n.registerImpl("getMap", function(e) {
          return nl.getMapForUser(e);
        });
        function t(e, i) {
          i.update = "geo:updateSelectStatus", n.registerAction(i, function(r, a) {
            var o = {}, s = [];
            return a.eachComponent({ mainType: "geo", query: r }, function(l) {
              l[e](r.name);
              var u = l.coordinateSystem;
              D(u.regions, function(c) {
                o[c.name] = l.isSelected(c.name) || false;
              });
              var h = [];
              D(o, function(c, f) {
                o[f] && h.push(f);
              }), s.push({ geoIndex: l.componentIndex, name: h });
            }), { selected: o, allSelected: s, name: r.name };
          });
        }
        t("toggleSelected", { type: "geoToggleSelect", event: "geoselectchanged" }), t("select", { type: "geoSelect", event: "geoselected" }), t("unSelect", { type: "geoUnSelect", event: "geounselected" }), n.registerAction({ type: "geoRoam", event: "geoRoam", update: "updateTransform" }, function(e, i, r) {
          var a = e.componentType || "series";
          i.eachComponent({ mainType: a, query: e }, function(o) {
            var s = o.coordinateSystem;
            if (s.type === "geo") {
              var l = yD(s, e, o.get("scaleLimit"), r);
              o.setCenter && o.setCenter(l.center), o.setZoom && o.setZoom(l.zoom), a === "series" && D(o.seriesGroup, function(u) {
                u.setCenter(l.center), u.setZoom(l.zoom);
              });
            }
          });
        });
      }
      function tMt(n) {
        Kt(Tq), n.registerChartView(VBt), n.registerSeriesModel(jBt), n.registerLayout(YBt), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, HBt), LU("map", n.registerAction);
      }
      function eMt(n) {
        var t = n;
        t.hierNode = { defaultAncestor: null, ancestor: t, prelim: 0, modifier: 0, change: 0, shift: 0, i: 0, thread: null };
        for (var e = [t], i, r; i = e.pop(); ) if (r = i.children, i.isExpand && r.length) for (var a = r.length, o = a - 1; o >= 0; o--) {
          var s = r[o];
          s.hierNode = { defaultAncestor: null, ancestor: s, prelim: 0, modifier: 0, change: 0, shift: 0, i: o, thread: null }, e.push(s);
        }
      }
      function nMt(n, t) {
        var e = n.isExpand ? n.children : [], i = n.parentNode.children, r = n.hierNode.i ? i[n.hierNode.i - 1] : null;
        if (e.length) {
          aMt(n);
          var a = (e[0].hierNode.prelim + e[e.length - 1].hierNode.prelim) / 2;
          r ? (n.hierNode.prelim = r.hierNode.prelim + t(n, r), n.hierNode.modifier = n.hierNode.prelim - a) : n.hierNode.prelim = a;
        } else r && (n.hierNode.prelim = r.hierNode.prelim + t(n, r));
        n.parentNode.hierNode.defaultAncestor = oMt(n, r, n.parentNode.hierNode.defaultAncestor || i[0], t);
      }
      function iMt(n) {
        var t = n.hierNode.prelim + n.parentNode.hierNode.modifier;
        n.setLayout({ x: t }, true), n.hierNode.modifier += n.parentNode.hierNode.modifier;
      }
      function Bq(n) {
        return arguments.length ? n : uMt;
      }
      function ly(n, t) {
        return n -= Math.PI / 2, { x: t * Math.cos(n), y: t * Math.sin(n) };
      }
      function rMt(n, t) {
        return Yn(n.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() });
      }
      function aMt(n) {
        for (var t = n.children, e = t.length, i = 0, r = 0; --e >= 0; ) {
          var a = t[e];
          a.hierNode.prelim += i, a.hierNode.modifier += i, r += a.hierNode.change, i += a.hierNode.shift + r;
        }
      }
      function oMt(n, t, e, i) {
        if (t) {
          for (var r = n, a = n, o = a.parentNode.children[0], s = t, l = r.hierNode.modifier, u = a.hierNode.modifier, h = o.hierNode.modifier, c = s.hierNode.modifier; s = mD(s), a = _D(a), s && a; ) {
            r = mD(r), o = _D(o), r.hierNode.ancestor = n;
            var f = s.hierNode.prelim + c - a.hierNode.prelim - u + i(s, a);
            f > 0 && (lMt(sMt(s, n, e), n, f), u += f, l += f), c += s.hierNode.modifier, u += a.hierNode.modifier, l += r.hierNode.modifier, h += o.hierNode.modifier;
          }
          s && !mD(r) && (r.hierNode.thread = s, r.hierNode.modifier += c - l), a && !_D(o) && (o.hierNode.thread = a, o.hierNode.modifier += u - h, e = n);
        }
        return e;
      }
      function mD(n) {
        var t = n.children;
        return t.length && n.isExpand ? t[t.length - 1] : n.hierNode.thread;
      }
      function _D(n) {
        var t = n.children;
        return t.length && n.isExpand ? t[0] : n.hierNode.thread;
      }
      function sMt(n, t, e) {
        return n.hierNode.ancestor.parentNode === t.parentNode ? n.hierNode.ancestor : e;
      }
      function lMt(n, t, e) {
        var i = e / (t.hierNode.i - n.hierNode.i);
        t.hierNode.change -= i, t.hierNode.shift += e, t.hierNode.modifier += e, t.hierNode.prelim += e, n.hierNode.change += i;
      }
      function uMt(n, t) {
        return n.parentNode === t.parentNode ? 1 : 2;
      }
      var hMt = /* @__PURE__ */ function() {
        function n() {
          this.parentPoint = [], this.childPoints = [];
        }
        return n;
      }(), cMt = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new hMt();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.childPoints, a = r.length, o = i.parentPoint, s = r[0], l = r[a - 1];
          if (a === 1) {
            e.moveTo(o[0], o[1]), e.lineTo(s[0], s[1]);
            return;
          }
          var u = i.orient, h = u === "TB" || u === "BT" ? 0 : 1, c = 1 - h, f = st(i.forkPosition, 1), g = [];
          g[h] = o[h], g[c] = o[c] + (l[c] - o[c]) * f, e.moveTo(o[0], o[1]), e.lineTo(g[0], g[1]), e.moveTo(s[0], s[1]), g[h] = s[h], e.lineTo(g[0], g[1]), g[h] = l[h], e.lineTo(g[0], g[1]), e.lineTo(l[0], l[1]);
          for (var d = 1; d < a - 1; d++) {
            var A = r[d];
            e.moveTo(A[0], A[1]), g[h] = A[h], e.lineTo(g[0], g[1]);
          }
        }, t;
      }(ne), fMt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._mainGroup = new Dt(), e;
        }
        return t.prototype.init = function(e, i) {
          this._controller = new ay(i.getZr()), this._controllerHost = { target: this.group }, this.group.add(this._mainGroup);
        }, t.prototype.render = function(e, i, r) {
          var a = e.getData(), o = e.layoutInfo, s = this._mainGroup, l = e.get("layout");
          l === "radial" ? (s.x = o.x + o.width / 2, s.y = o.y + o.height / 2) : (s.x = o.x, s.y = o.y), this._updateViewCoordSys(e, r), this._updateController(e, i, r);
          var u = this._data;
          a.diff(u).add(function(h) {
            Mq(a, h) && Dq(a, h, null, s, e);
          }).update(function(h, c) {
            var f = u.getItemGraphicEl(c);
            if (!Mq(a, h)) {
              f && Pq(u, c, f, s, e);
              return;
            }
            Dq(a, h, f, s, e);
          }).remove(function(h) {
            var c = u.getItemGraphicEl(h);
            c && Pq(u, h, c, s, e);
          }).execute(), this._nodeScaleRatio = e.get("nodeScaleRatio"), this._updateNodeAndLinkScale(e), e.get("expandAndCollapse") === true && a.eachItemGraphicEl(function(h, c) {
            h.off("click").on("click", function() {
              r.dispatchAction({ type: "treeExpandAndCollapse", seriesId: e.id, dataIndex: c });
            });
          }), this._data = a;
        }, t.prototype._updateViewCoordSys = function(e, i) {
          var r = e.getData(), a = [];
          r.each(function(c) {
            var f = r.getItemLayout(c);
            f && !isNaN(f.x) && !isNaN(f.y) && a.push([+f.x, +f.y]);
          });
          var o = [], s = [];
          w1(a, o, s);
          var l = this._min, u = this._max;
          s[0] - o[0] === 0 && (o[0] = l ? l[0] : o[0] - 1, s[0] = u ? u[0] : s[0] + 1), s[1] - o[1] === 0 && (o[1] = l ? l[1] : o[1] - 1, s[1] = u ? u[1] : s[1] + 1);
          var h = e.coordinateSystem = new sy();
          h.zoomLimit = e.get("scaleLimit"), h.setBoundingRect(o[0], o[1], s[0] - o[0], s[1] - o[1]), h.setCenter(e.get("center"), i), h.setZoom(e.get("zoom")), this.group.attr({ x: h.x, y: h.y, scaleX: h.scaleX, scaleY: h.scaleY }), this._min = o, this._max = s;
        }, t.prototype._updateController = function(e, i, r) {
          var a = this, o = this._controller, s = this._controllerHost, l = this.group;
          o.setPointerChecker(function(u, h, c) {
            var f = l.getBoundingRect();
            return f.applyTransform(l.transform), f.contain(h, c) && !KE(u, r, e);
          }), o.enable(e.get("roam")), s.zoomLimit = e.get("scaleLimit"), s.zoom = e.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(u) {
            cD(s, u.dx, u.dy), r.dispatchAction({ seriesId: e.id, type: "treeRoam", dx: u.dx, dy: u.dy });
          }).on("zoom", function(u) {
            fD(s, u.scale, u.originX, u.originY), r.dispatchAction({ seriesId: e.id, type: "treeRoam", zoom: u.scale, originX: u.originX, originY: u.originY }), a._updateNodeAndLinkScale(e), r.updateLabelLayout();
          });
        }, t.prototype._updateNodeAndLinkScale = function(e) {
          var i = e.getData(), r = this._getNodeGlobalScale(e);
          i.eachItemGraphicEl(function(a, o) {
            a.setSymbolScale(r);
          });
        }, t.prototype._getNodeGlobalScale = function(e) {
          var i = e.coordinateSystem;
          if (i.type !== "view") return 1;
          var r = this._nodeScaleRatio, a = i.scaleX || 1, o = i.getZoom(), s = (o - 1) * r + 1;
          return s / a;
        }, t.prototype.dispose = function() {
          this._controller && this._controller.dispose(), this._controllerHost = null;
        }, t.prototype.remove = function() {
          this._mainGroup.removeAll(), this._data = null;
        }, t.type = "tree", t;
      }(qe);
      function Mq(n, t) {
        var e = n.getItemLayout(t);
        return e && !isNaN(e.x) && !isNaN(e.y);
      }
      function Dq(n, t, e, i, r) {
        var a = !e, o = n.tree.getNodeByDataIndex(t), s = o.getModel(), l = o.getVisual("style").fill, u = o.isExpand === false && o.children.length !== 0 ? l : "#fff", h = n.tree.root, c = o.parentNode === h ? o : o.parentNode || o, f = n.getItemGraphicEl(c.dataIndex), g = c.getLayout(), d = f ? { x: f.__oldX, y: f.__oldY, rawX: f.__radialOldRawX, rawY: f.__radialOldRawY } : g, A = o.getLayout();
        a ? (e = new $v(n, t, null, { symbolInnerColor: u, useNameLabel: true }), e.x = d.x, e.y = d.y) : e.updateData(n, t, null, { symbolInnerColor: u, useNameLabel: true }), e.__radialOldRawX = e.__radialRawX, e.__radialOldRawY = e.__radialRawY, e.__radialRawX = A.rawX, e.__radialRawY = A.rawY, i.add(e), n.setItemGraphicEl(t, e), e.__oldX = e.x, e.__oldY = e.y, Ee(e, { x: A.x, y: A.y }, r);
        var p = e.getSymbolPath();
        if (r.get("layout") === "radial") {
          var v = h.children[0], y = v.getLayout(), m = v.children.length, _ = void 0, I = void 0;
          if (A.x === y.x && o.isExpand === true && v.children.length) {
            var E = { x: (v.children[0].getLayout().x + v.children[m - 1].getLayout().x) / 2, y: (v.children[0].getLayout().y + v.children[m - 1].getLayout().y) / 2 };
            _ = Math.atan2(E.y - y.y, E.x - y.x), _ < 0 && (_ = Math.PI * 2 + _), I = E.x < y.x, I && (_ = _ - Math.PI);
          } else _ = Math.atan2(A.y - y.y, A.x - y.x), _ < 0 && (_ = Math.PI * 2 + _), o.children.length === 0 || o.children.length !== 0 && o.isExpand === false ? (I = A.x < y.x, I && (_ = _ - Math.PI)) : (I = A.x > y.x, I || (_ = _ - Math.PI));
          var x = I ? "left" : "right", w = s.getModel("label"), C = w.get("rotate"), S = C * (Math.PI / 180), b = p.getTextContent();
          b && (p.setTextConfig({ position: w.get("position") || x, rotation: C == null ? -_ : S, origin: "center" }), b.setStyle("verticalAlign", "middle"));
        }
        var T = s.get(["emphasis", "focus"]), B = T === "relative" ? z_(o.getAncestorsIndices(), o.getDescendantIndices()) : T === "ancestor" ? o.getAncestorsIndices() : T === "descendant" ? o.getDescendantIndices() : null;
        B && (Nt(e).focus = B), gMt(r, o, h, e, d, g, A, i), e.__edge && (e.onHoverStateChange = function(R) {
          if (R !== "blur") {
            var M = o.parentNode && n.getItemGraphicEl(o.parentNode.dataIndex);
            M && M.hoverState === av || M1(e.__edge, R);
          }
        });
      }
      function gMt(n, t, e, i, r, a, o, s) {
        var l = t.getModel(), u = n.get("edgeShape"), h = n.get("layout"), c = n.getOrient(), f = n.get(["lineStyle", "curveness"]), g = n.get("edgeForkPosition"), d = l.getModel("lineStyle").getLineStyle(), A = i.__edge;
        if (u === "curve") t.parentNode && t.parentNode !== e && (A || (A = i.__edge = new gv({ shape: ED(h, c, f, r, r) })), Ee(A, { shape: ED(h, c, f, a, o) }, n));
        else if (u === "polyline") {
          if (h === "orthogonal") {
            if (t !== e && t.children && t.children.length !== 0 && t.isExpand === true) {
              for (var p = t.children, v = [], y = 0; y < p.length; y++) {
                var m = p[y].getLayout();
                v.push([m.x, m.y]);
              }
              A || (A = i.__edge = new cMt({ shape: { parentPoint: [o.x, o.y], childPoints: [[o.x, o.y]], orient: c, forkPosition: g } })), Ee(A, { shape: { parentPoint: [o.x, o.y], childPoints: v } }, n);
            }
          } else if (true) throw new Error("The polyline edgeShape can only be used in orthogonal layout");
        }
        A && !(u === "polyline" && !t.isExpand) && (A.useStyle(wt({ strokeNoScale: true, fill: null }, d)), Ii(A, l, "lineStyle"), Gh(A), s.add(A));
      }
      function Rq(n, t, e, i, r) {
        var a = t.tree.root, o = Lq(a, n), s = o.source, l = o.sourceLayout, u = t.getItemGraphicEl(n.dataIndex);
        if (u) {
          var h = t.getItemGraphicEl(s.dataIndex), c = h.__edge, f = u.__edge || (s.isExpand === false || s.children.length === 1 ? c : void 0), g = i.get("edgeShape"), d = i.get("layout"), A = i.get("orient"), p = i.get(["lineStyle", "curveness"]);
          f && (g === "curve" ? uu(f, { shape: ED(d, A, p, l, l), style: { opacity: 0 } }, i, { cb: function() {
            e.remove(f);
          }, removeOpt: r }) : g === "polyline" && i.get("layout") === "orthogonal" && uu(f, { shape: { parentPoint: [l.x, l.y], childPoints: [[l.x, l.y]] }, style: { opacity: 0 } }, i, { cb: function() {
            e.remove(f);
          }, removeOpt: r }));
        }
      }
      function Lq(n, t) {
        for (var e = t.parentNode === n ? t : t.parentNode || t, i; i = e.getLayout(), i == null; ) e = e.parentNode === n ? e : e.parentNode || e;
        return { source: e, sourceLayout: i };
      }
      function Pq(n, t, e, i, r) {
        var a = n.tree.getNodeByDataIndex(t), o = n.tree.root, s = Lq(o, a).sourceLayout, l = { duration: r.get("animationDurationUpdate"), easing: r.get("animationEasingUpdate") };
        uu(e, { x: s.x + 1, y: s.y + 1 }, r, { cb: function() {
          i.remove(e), n.setItemGraphicEl(t, null);
        }, removeOpt: l }), e.fadeOut(null, n.hostModel, { fadeLabel: true, animation: l }), a.children.forEach(function(u) {
          Rq(u, n, i, r, l);
        }), Rq(a, n, i, r, l);
      }
      function ED(n, t, e, i, r) {
        var a, o, s, l, u, h, c, f;
        if (n === "radial") {
          u = i.rawX, c = i.rawY, h = r.rawX, f = r.rawY;
          var g = ly(u, c), d = ly(u, c + (f - c) * e), A = ly(h, f + (c - f) * e), p = ly(h, f);
          return { x1: g.x || 0, y1: g.y || 0, x2: p.x || 0, y2: p.y || 0, cpx1: d.x || 0, cpy1: d.y || 0, cpx2: A.x || 0, cpy2: A.y || 0 };
        } else u = i.x, c = i.y, h = r.x, f = r.y, (t === "LR" || t === "RL") && (a = u + (h - u) * e, o = c, s = h + (u - h) * e, l = f), (t === "TB" || t === "BT") && (a = u, o = c + (f - c) * e, s = h, l = f + (c - f) * e);
        return { x1: u, y1: c, x2: h, y2: f, cpx1: a, cpy1: o, cpx2: s, cpy2: l };
      }
      var Ba = ce();
      function Nq(n) {
        var t = n.mainData, e = n.datas;
        e || (e = { main: t }, n.datasAttr = { main: "data" }), n.datas = n.mainData = null, Fq(t, e, n), D(e, function(i) {
          D(t.TRANSFERABLE_METHODS, function(r) {
            i.wrapMethod(r, Gt(dMt, n));
          });
        }), t.wrapMethod("cloneShallow", Gt(pMt, n)), D(t.CHANGABLE_METHODS, function(i) {
          t.wrapMethod(i, Gt(AMt, n));
        }), It(e[t.dataType] === t);
      }
      function dMt(n, t) {
        if (mMt(this)) {
          var e = X({}, Ba(this).datas);
          e[this.dataType] = t, Fq(t, e, n);
        } else ID(t, this.dataType, Ba(this).mainData, n);
        return t;
      }
      function AMt(n, t) {
        return n.struct && n.struct.update(), t;
      }
      function pMt(n, t) {
        return D(Ba(t).datas, function(e, i) {
          e !== t && ID(e.cloneShallow(), i, t, n);
        }), t;
      }
      function vMt(n) {
        var t = Ba(this).mainData;
        return n == null || t == null ? t : Ba(t).datas[n];
      }
      function yMt() {
        var n = Ba(this).mainData;
        return n == null ? [{ data: n }] : K(oe(Ba(n).datas), function(t) {
          return { type: t, data: Ba(n).datas[t] };
        });
      }
      function mMt(n) {
        return Ba(n).mainData === n;
      }
      function Fq(n, t, e) {
        Ba(n).datas = {}, D(t, function(i, r) {
          ID(i, r, n, e);
        });
      }
      function ID(n, t, e, i) {
        Ba(e).datas[t] = n, Ba(n).mainData = e, n.dataType = t, i.struct && (n[i.structAttr] = i.struct, i.struct[i.datasAttr[t]] = n), n.getLinkedData = vMt, n.getLinkedDataAll = yMt;
      }
      var _Mt = function() {
        function n(t, e) {
          this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = false, this.name = t || "", this.hostTree = e;
        }
        return n.prototype.isRemoved = function() {
          return this.dataIndex < 0;
        }, n.prototype.eachNode = function(t, e, i) {
          yt(t) && (i = e, e = t, t = null), t = t || {}, ht(t) && (t = { order: t });
          var r = t.order || "preorder", a = this[t.attr || "children"], o;
          r === "preorder" && (o = e.call(i, this));
          for (var s = 0; !o && s < a.length; s++) a[s].eachNode(t, e, i);
          r === "postorder" && e.call(i, this);
        }, n.prototype.updateDepthAndHeight = function(t) {
          var e = 0;
          this.depth = t;
          for (var i = 0; i < this.children.length; i++) {
            var r = this.children[i];
            r.updateDepthAndHeight(t + 1), r.height > e && (e = r.height);
          }
          this.height = e + 1;
        }, n.prototype.getNodeById = function(t) {
          if (this.getId() === t) return this;
          for (var e = 0, i = this.children, r = i.length; e < r; e++) {
            var a = i[e].getNodeById(t);
            if (a) return a;
          }
        }, n.prototype.contains = function(t) {
          if (t === this) return true;
          for (var e = 0, i = this.children, r = i.length; e < r; e++) {
            var a = i[e].contains(t);
            if (a) return a;
          }
        }, n.prototype.getAncestors = function(t) {
          for (var e = [], i = t ? this : this.parentNode; i; ) e.push(i), i = i.parentNode;
          return e.reverse(), e;
        }, n.prototype.getAncestorsIndices = function() {
          for (var t = [], e = this; e; ) t.push(e.dataIndex), e = e.parentNode;
          return t.reverse(), t;
        }, n.prototype.getDescendantIndices = function() {
          var t = [];
          return this.eachNode(function(e) {
            t.push(e.dataIndex);
          }), t;
        }, n.prototype.getValue = function(t) {
          var e = this.hostTree.data;
          return e.getStore().get(e.getDimensionIndex(t || "value"), this.dataIndex);
        }, n.prototype.setLayout = function(t, e) {
          this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, t, e);
        }, n.prototype.getLayout = function() {
          return this.hostTree.data.getItemLayout(this.dataIndex);
        }, n.prototype.getModel = function(t) {
          if (!(this.dataIndex < 0)) {
            var e = this.hostTree, i = e.data.getItemModel(this.dataIndex);
            return i.getModel(t);
          }
        }, n.prototype.getLevelModel = function() {
          return (this.hostTree.levelModels || [])[this.depth];
        }, n.prototype.setVisual = function(t, e) {
          this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, t, e);
        }, n.prototype.getVisual = function(t) {
          return this.hostTree.data.getItemVisual(this.dataIndex, t);
        }, n.prototype.getRawIndex = function() {
          return this.hostTree.data.getRawIndex(this.dataIndex);
        }, n.prototype.getId = function() {
          return this.hostTree.data.getId(this.dataIndex);
        }, n.prototype.getChildIndex = function() {
          if (this.parentNode) {
            for (var t = this.parentNode.children, e = 0; e < t.length; ++e) if (t[e] === this) return e;
            return -1;
          }
          return -1;
        }, n.prototype.isAncestorOf = function(t) {
          for (var e = t.parentNode; e; ) {
            if (e === this) return true;
            e = e.parentNode;
          }
          return false;
        }, n.prototype.isDescendantOf = function(t) {
          return t !== this && t.isAncestorOf(this);
        }, n;
      }(), xD = function() {
        function n(t) {
          this.type = "tree", this._nodes = [], this.hostModel = t;
        }
        return n.prototype.eachNode = function(t, e, i) {
          this.root.eachNode(t, e, i);
        }, n.prototype.getNodeByDataIndex = function(t) {
          var e = this.data.getRawIndex(t);
          return this._nodes[e];
        }, n.prototype.getNodeById = function(t) {
          return this.root.getNodeById(t);
        }, n.prototype.update = function() {
          for (var t = this.data, e = this._nodes, i = 0, r = e.length; i < r; i++) e[i].dataIndex = -1;
          for (var i = 0, r = t.count(); i < r; i++) e[t.getRawIndex(i)].dataIndex = i;
        }, n.prototype.clearLayouts = function() {
          this.data.clearItemLayouts();
        }, n.createTree = function(t, e, i) {
          var r = new n(e), a = [], o = 1;
          s(t);
          function s(h, c) {
            var f = h.value;
            o = Math.max(o, Z(f) ? f.length : 1), a.push(h);
            var g = new _Mt(Hn(h.name, ""), r);
            c ? EMt(g, c) : r.root = g, r._nodes.push(g);
            var d = h.children;
            if (d) for (var A = 0; A < d.length; A++) s(d[A], g);
          }
          r.root.updateDepthAndHeight(0);
          var l = Uv(a, { coordDimensions: ["value"], dimensionsCount: o }).dimensions, u = new er(l, e);
          return u.initData(a), i && i(u), Nq({ mainData: u, struct: r, structAttr: "tree" }), r.update(), r;
        }, n;
      }();
      function EMt(n, t) {
        var e = t.children;
        n.parentNode !== t && (e.push(n), n.parentNode = t);
      }
      function uy(n, t, e) {
        if (n && $t(t, n.type) >= 0) {
          var i = e.getData().tree.root, r = n.targetNode;
          if (ht(r) && (r = i.getNodeById(r)), r && i.contains(r)) return { node: r };
          var a = n.targetNodeId;
          if (a != null && (r = i.getNodeById(a))) return { node: r };
        }
      }
      function kq(n) {
        for (var t = []; n; ) n = n.parentNode, n && t.push(n);
        return t.reverse();
      }
      function wD(n, t) {
        var e = kq(n);
        return $t(e, t) >= 0;
      }
      function iI(n, t) {
        for (var e = []; n; ) {
          var i = n.dataIndex;
          e.push({ name: n.name, dataIndex: i, value: t.getRawValue(i) }), n = n.parentNode;
        }
        return e.reverse(), e;
      }
      var IMt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.hasSymbolVisual = true, e.ignoreStyleOnData = true, e;
        }
        return t.prototype.getInitialData = function(e) {
          var i = { name: e.name, children: e.data }, r = e.leaves || {}, a = new De(r, this, this.ecModel), o = xD.createTree(i, this, s);
          function s(c) {
            c.wrapMethod("getItemModel", function(f, g) {
              var d = o.getNodeByDataIndex(g);
              return d && d.children.length && d.isExpand || (f.parentModel = a), f;
            });
          }
          var l = 0;
          o.eachNode("preorder", function(c) {
            c.depth > l && (l = c.depth);
          });
          var u = e.expandAndCollapse, h = u && e.initialTreeDepth >= 0 ? e.initialTreeDepth : l;
          return o.root.eachNode("preorder", function(c) {
            var f = c.hostTree.data.getRawDataItem(c.dataIndex);
            c.isExpand = f && f.collapsed != null ? !f.collapsed : c.depth <= h;
          }), o.data;
        }, t.prototype.getOrient = function() {
          var e = this.get("orient");
          return e === "horizontal" ? e = "LR" : e === "vertical" && (e = "TB"), e;
        }, t.prototype.setZoom = function(e) {
          this.option.zoom = e;
        }, t.prototype.setCenter = function(e) {
          this.option.center = e;
        }, t.prototype.formatTooltip = function(e, i, r) {
          for (var a = this.getData().tree, o = a.root.children[0], s = a.getNodeByDataIndex(e), l = s.getValue(), u = s.name; s && s !== o; ) u = s.parentNode.name + "." + u, s = s.parentNode;
          return ti("nameValue", { name: u, value: l, noValue: isNaN(l) || l == null });
        }, t.prototype.getDataParams = function(e) {
          var i = n.prototype.getDataParams.apply(this, arguments), r = this.getData().tree.getNodeByDataIndex(e);
          return i.treeAncestors = iI(r, this), i.collapsed = !r.isExpand, i;
        }, t.type = "series.tree", t.layoutMode = "box", t.defaultOption = { z: 2, coordinateSystem: "view", left: "12%", top: "12%", right: "12%", bottom: "12%", layout: "orthogonal", edgeShape: "curve", edgeForkPosition: "50%", roam: false, nodeScaleRatio: 0.4, center: null, zoom: 1, orient: "LR", symbol: "emptyCircle", symbolSize: 7, expandAndCollapse: true, initialTreeDepth: 2, lineStyle: { color: "#ccc", width: 1.5, curveness: 0.5 }, itemStyle: { color: "lightsteelblue", borderWidth: 1.5 }, label: { show: true }, animationEasing: "linear", animationDuration: 700, animationDurationUpdate: 500 }, t;
      }(tn);
      function xMt(n, t, e) {
        for (var i = [n], r = [], a; a = i.pop(); ) if (r.push(a), a.isExpand) {
          var o = a.children;
          if (o.length) for (var s = 0; s < o.length; s++) i.push(o[s]);
        }
        for (; a = r.pop(); ) t(a, e);
      }
      function hy(n, t) {
        for (var e = [n], i; i = e.pop(); ) if (t(i), i.isExpand) {
          var r = i.children;
          if (r.length) for (var a = r.length - 1; a >= 0; a--) e.push(r[a]);
        }
      }
      function wMt(n, t) {
        n.eachSeriesByType("tree", function(e) {
          CMt(e, t);
        });
      }
      function CMt(n, t) {
        var e = rMt(n, t);
        n.layoutInfo = e;
        var i = n.get("layout"), r = 0, a = 0, o = null;
        i === "radial" ? (r = 2 * Math.PI, a = Math.min(e.height, e.width) / 2, o = Bq(function(m, _) {
          return (m.parentNode === _.parentNode ? 1 : 2) / m.depth;
        })) : (r = e.width, a = e.height, o = Bq());
        var s = n.getData().tree.root, l = s.children[0];
        if (l) {
          eMt(s), xMt(l, nMt, o), s.hierNode.modifier = -l.hierNode.prelim, hy(l, iMt);
          var u = l, h = l, c = l;
          hy(l, function(m) {
            var _ = m.getLayout().x;
            _ < u.getLayout().x && (u = m), _ > h.getLayout().x && (h = m), m.depth > c.depth && (c = m);
          });
          var f = u === h ? 1 : o(u, h) / 2, g = f - u.getLayout().x, d = 0, A = 0, p = 0, v = 0;
          if (i === "radial") d = r / (h.getLayout().x + f + g), A = a / (c.depth - 1 || 1), hy(l, function(m) {
            p = (m.getLayout().x + g) * d, v = (m.depth - 1) * A;
            var _ = ly(p, v);
            m.setLayout({ x: _.x, y: _.y, rawX: p, rawY: v }, true);
          });
          else {
            var y = n.getOrient();
            y === "RL" || y === "LR" ? (A = a / (h.getLayout().x + f + g), d = r / (c.depth - 1 || 1), hy(l, function(m) {
              v = (m.getLayout().x + g) * A, p = y === "LR" ? (m.depth - 1) * d : r - (m.depth - 1) * d, m.setLayout({ x: p, y: v }, true);
            })) : (y === "TB" || y === "BT") && (d = r / (h.getLayout().x + f + g), A = a / (c.depth - 1 || 1), hy(l, function(m) {
              p = (m.getLayout().x + g) * d, v = y === "TB" ? (m.depth - 1) * A : a - (m.depth - 1) * A, m.setLayout({ x: p, y: v }, true);
            }));
          }
        }
      }
      function SMt(n) {
        n.eachSeriesByType("tree", function(t) {
          var e = t.getData(), i = e.tree;
          i.eachNode(function(r) {
            var a = r.getModel(), o = a.getModel("itemStyle").getItemStyle(), s = e.ensureUniqueItemVisual(r.dataIndex, "style");
            X(s, o);
          });
        });
      }
      function bMt(n) {
        n.registerAction({ type: "treeExpandAndCollapse", event: "treeExpandAndCollapse", update: "update" }, function(t, e) {
          e.eachComponent({ mainType: "series", subType: "tree", query: t }, function(i) {
            var r = t.dataIndex, a = i.getData().tree, o = a.getNodeByDataIndex(r);
            o.isExpand = !o.isExpand;
          });
        }), n.registerAction({ type: "treeRoam", event: "treeRoam", update: "none" }, function(t, e, i) {
          e.eachComponent({ mainType: "series", subType: "tree", query: t }, function(r) {
            var a = r.coordinateSystem, o = yD(a, t, void 0, i);
            r.setCenter && r.setCenter(o.center), r.setZoom && r.setZoom(o.zoom);
          });
        });
      }
      function TMt(n) {
        n.registerChartView(fMt), n.registerSeriesModel(IMt), n.registerLayout(wMt), n.registerVisual(SMt), bMt(n);
      }
      var Oq = ["treemapZoomToNode", "treemapRender", "treemapMove"];
      function BMt(n) {
        for (var t = 0; t < Oq.length; t++) n.registerAction({ type: Oq[t], update: "updateView" }, bn);
        n.registerAction({ type: "treemapRootToNode", update: "updateView" }, function(e, i) {
          i.eachComponent({ mainType: "series", subType: "treemap", query: e }, r);
          function r(a, o) {
            var s = ["treemapZoomToNode", "treemapRootToNode"], l = uy(e, s, a);
            if (l) {
              var u = a.getViewRoot();
              u && (e.direction = wD(u, l.node) ? "rollUp" : "drillDown"), a.resetViewRoot(l.node);
            }
          }
        });
      }
      function Qq(n) {
        var t = n.getData(), e = t.tree, i = {};
        e.eachNode(function(r) {
          for (var a = r; a && a.depth > 1; ) a = a.parentNode;
          var o = bB(n.ecModel, a.name || a.dataIndex + "", i);
          r.setVisual("decal", o);
        });
      }
      var MMt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.preventUsingHoverLayer = true, e;
        }
        return t.prototype.getInitialData = function(e, i) {
          var r = { name: e.name, children: e.data };
          zq(r);
          var a = e.levels || [], o = this.designatedVisualItemStyle = {}, s = new De({ itemStyle: o }, this, i);
          a = e.levels = DMt(a, i);
          var l = K(a || [], function(c) {
            return new De(c, s, i);
          }, this), u = xD.createTree(r, this, h);
          function h(c) {
            c.wrapMethod("getItemModel", function(f, g) {
              var d = u.getNodeByDataIndex(g), A = d ? l[d.depth] : null;
              return f.parentModel = A || s, f;
            });
          }
          return u.data;
        }, t.prototype.optionUpdated = function() {
          this.resetViewRoot();
        }, t.prototype.formatTooltip = function(e, i, r) {
          var a = this.getData(), o = this.getRawValue(e), s = a.getName(e);
          return ti("nameValue", { name: s, value: o });
        }, t.prototype.getDataParams = function(e) {
          var i = n.prototype.getDataParams.apply(this, arguments), r = this.getData().tree.getNodeByDataIndex(e);
          return i.treeAncestors = iI(r, this), i.treePathInfo = i.treeAncestors, i;
        }, t.prototype.setLayoutInfo = function(e) {
          this.layoutInfo = this.layoutInfo || {}, X(this.layoutInfo, e);
        }, t.prototype.mapIdToIndex = function(e) {
          var i = this._idIndexMap;
          i || (i = this._idIndexMap = dt(), this._idIndexMapCount = 0);
          var r = i.get(e);
          return r == null && i.set(e, r = this._idIndexMapCount++), r;
        }, t.prototype.getViewRoot = function() {
          return this._viewRoot;
        }, t.prototype.resetViewRoot = function(e) {
          e ? this._viewRoot = e : e = this._viewRoot;
          var i = this.getRawData().tree.root;
          (!e || e !== i && !i.contains(e)) && (this._viewRoot = i);
        }, t.prototype.enableAriaDecal = function() {
          Qq(this);
        }, t.type = "series.treemap", t.layoutMode = "box", t.defaultOption = { progressive: 0, left: "center", top: "middle", width: "80%", height: "80%", sort: true, clipWindow: "origin", squareRatio: 0.5 * (1 + Math.sqrt(5)), leafDepth: null, drillDownIcon: "", zoomToNodeRatio: 0.32 * 0.32, scaleLimit: null, roam: true, nodeClick: "zoomToNode", animation: true, animationDurationUpdate: 900, animationEasing: "quinticInOut", breadcrumb: { show: true, height: 22, left: "center", top: "bottom", emptyItemWidth: 25, itemStyle: { color: "rgba(0,0,0,0.7)", textStyle: { color: "#fff" } }, emphasis: { itemStyle: { color: "rgba(0,0,0,0.9)" } } }, label: { show: true, distance: 0, padding: 5, position: "inside", color: "#fff", overflow: "truncate" }, upperLabel: { show: false, position: [0, "50%"], height: 20, overflow: "truncate", verticalAlign: "middle" }, itemStyle: { color: null, colorAlpha: null, colorSaturation: null, borderWidth: 0, gapWidth: 0, borderColor: "#fff", borderColorSaturation: null }, emphasis: { upperLabel: { show: true, position: [0, "50%"], overflow: "truncate", verticalAlign: "middle" } }, visualDimension: 0, visualMin: null, visualMax: null, color: [], colorAlpha: null, colorSaturation: null, colorMappingBy: "index", visibleMin: 10, childrenVisibleMin: null, levels: [] }, t;
      }(tn);
      function zq(n) {
        var t = 0;
        D(n.children, function(i) {
          zq(i);
          var r = i.value;
          Z(r) && (r = r[0]), t += r;
        });
        var e = n.value;
        Z(e) && (e = e[0]), (e == null || isNaN(e)) && (e = t), e < 0 && (e = 0), Z(n.value) ? n.value[0] = e : n.value = e;
      }
      function DMt(n, t) {
        var e = ze(t.get("color")), i = ze(t.get(["aria", "decal", "decals"]));
        if (e) {
          n = n || [];
          var r, a;
          D(n, function(s) {
            var l = new De(s), u = l.get("color"), h = l.get("decal");
            (l.get(["itemStyle", "color"]) || u && u !== "none") && (r = true), (l.get(["itemStyle", "decal"]) || h && h !== "none") && (a = true);
          });
          var o = n[0] || (n[0] = {});
          return r || (o.color = e.slice()), !a && i && (o.decal = i.slice()), n;
        }
      }
      var RMt = 8, Gq = 8, CD = 5, LMt = function() {
        function n(t) {
          this.group = new Dt(), t.add(this.group);
        }
        return n.prototype.render = function(t, e, i, r) {
          var a = t.getModel("breadcrumb"), o = this.group;
          if (o.removeAll(), !(!a.get("show") || !i)) {
            var s = a.getModel("itemStyle"), l = a.getModel("emphasis"), u = s.getModel("textStyle"), h = l.getModel(["itemStyle", "textStyle"]), c = { pos: { left: a.get("left"), right: a.get("right"), top: a.get("top"), bottom: a.get("bottom") }, box: { width: e.getWidth(), height: e.getHeight() }, emptyItemWidth: a.get("emptyItemWidth"), totalWidth: 0, renderList: [] };
            this._prepare(i, c, u), this._renderContent(t, c, s, l, u, h, r), nE(o, c.pos, c.box);
          }
        }, n.prototype._prepare = function(t, e, i) {
          for (var r = t; r; r = r.parentNode) {
            var a = Hn(r.getModel().get("name"), ""), o = i.getTextRect(a), s = Math.max(o.width + RMt * 2, e.emptyItemWidth);
            e.totalWidth += s + Gq, e.renderList.push({ node: r, text: a, width: s });
          }
        }, n.prototype._renderContent = function(t, e, i, r, a, o, s) {
          for (var l = 0, u = e.emptyItemWidth, h = t.get(["breadcrumb", "height"]), c = zxt(e.pos, e.box), f = e.totalWidth, g = e.renderList, d = r.getModel("itemStyle").getItemStyle(), A = g.length - 1; A >= 0; A--) {
            var p = g[A], v = p.node, y = p.width, m = p.text;
            f > c.width && (f -= y - u, y = u, m = null);
            var _ = new Ki({ shape: { points: PMt(l, 0, y, h, A === g.length - 1, A === 0) }, style: wt(i.getItemStyle(), { lineJoin: "bevel" }), textContent: new Ae({ style: Je(a, { text: m }) }), textConfig: { position: "inside" }, z2: Og * 1e4, onclick: Gt(s, v) });
            _.disableLabelAnimation = true, _.getTextContent().ensureState("emphasis").style = Je(o, { text: m }), _.ensureState("emphasis").style = d, pn(_, r.get("focus"), r.get("blurScope"), r.get("disabled")), this.group.add(_), NMt(_, t, v), l += y + Gq;
          }
        }, n.prototype.remove = function() {
          this.group.removeAll();
        }, n;
      }();
      function PMt(n, t, e, i, r, a) {
        var o = [[r ? n : n - CD, t], [n + e, t], [n + e, t + i], [r ? n : n - CD, t + i]];
        return !a && o.splice(2, 0, [n + e + CD, t + i / 2]), !r && o.push([n, t + i / 2]), o;
      }
      function NMt(n, t, e) {
        Nt(n).eventData = { componentType: "series", componentSubType: "treemap", componentIndex: t.componentIndex, seriesIndex: t.seriesIndex, seriesName: t.name, seriesType: "treemap", selfType: "breadcrumb", nodeData: { dataIndex: e && e.dataIndex, name: e && e.name }, treePathInfo: e && iI(e, t) };
      }
      var FMt = function() {
        function n() {
          this._storage = [], this._elExistsMap = {};
        }
        return n.prototype.add = function(t, e, i, r, a) {
          return this._elExistsMap[t.id] ? false : (this._elExistsMap[t.id] = true, this._storage.push({ el: t, target: e, duration: i, delay: r, easing: a }), true);
        }, n.prototype.finished = function(t) {
          return this._finishedCallback = t, this;
        }, n.prototype.start = function() {
          for (var t = this, e = this._storage.length, i = function() {
            e--, e <= 0 && (t._storage.length = 0, t._elExistsMap = {}, t._finishedCallback && t._finishedCallback());
          }, r = 0, a = this._storage.length; r < a; r++) {
            var o = this._storage[r];
            o.el.animateTo(o.target, { duration: o.duration, delay: o.delay, easing: o.easing, setToFinal: true, done: i, aborted: i });
          }
          return this;
        }, n;
      }();
      function kMt() {
        return new FMt();
      }
      var SD = Dt, Uq = fe, Vq = 3, jq = "label", qq = "upperLabel", OMt = Og * 10, QMt = Og * 2, zMt = Og * 3, mc = Dh([["fill", "color"], ["stroke", "strokeColor"], ["lineWidth", "strokeWidth"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]), Hq = function(n) {
        var t = mc(n);
        return t.stroke = t.fill = t.lineWidth = null, t;
      }, rI = ce(), GMt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._state = "ready", e._storage = cy(), e;
        }
        return t.prototype.render = function(e, i, r, a) {
          var o = i.findComponents({ mainType: "series", subType: "treemap", query: a });
          if (!($t(o, e) < 0)) {
            this.seriesModel = e, this.api = r, this.ecModel = i;
            var s = ["treemapZoomToNode", "treemapRootToNode"], l = uy(a, s, e), u = a && a.type, h = e.layoutInfo, c = !this._oldTree, f = this._storage, g = u === "treemapRootToNode" && l && f ? { rootNodeGroup: f.nodeGroup[l.node.getRawIndex()], direction: a.direction } : null, d = this._giveContainerGroup(h), A = e.get("animation"), p = this._doRender(d, e, g);
            A && !c && (!u || u === "treemapZoomToNode" || u === "treemapRootToNode") ? this._doAnimation(d, p, e, g) : p.renderFinally(), this._resetController(r), this._renderBreadcrumb(e, r, l);
          }
        }, t.prototype._giveContainerGroup = function(e) {
          var i = this._containerGroup;
          return i || (i = this._containerGroup = new SD(), this._initEvents(i), this.group.add(i)), i.x = e.x, i.y = e.y, i;
        }, t.prototype._doRender = function(e, i, r) {
          var a = i.getData().tree, o = this._oldTree, s = cy(), l = cy(), u = this._storage, h = [];
          function c(y, m, _, I) {
            return UMt(i, l, u, r, s, h, y, m, _, I);
          }
          A(a.root ? [a.root] : [], o && o.root ? [o.root] : [], e, a === o || !o, 0);
          var f = p(u);
          if (this._oldTree = a, this._storage = l, this._controllerHost) {
            var g = this.seriesModel.layoutInfo, d = a.root.getLayout();
            d.width === g.width && d.height === g.height && (this._controllerHost.zoom = 1);
          }
          return { lastsForAnimation: s, willDeleteEls: f, renderFinally: v };
          function A(y, m, _, I, E) {
            I ? (m = y, D(y, function(C, S) {
              !C.isRemoved() && w(S, S);
            })) : new Js(m, y, x, x).add(w).update(w).remove(Gt(w, null)).execute();
            function x(C) {
              return C.getId();
            }
            function w(C, S) {
              var b = C != null ? y[C] : null, T = S != null ? m[S] : null, B = c(b, T, _, E);
              B && A(b && b.viewChildren || [], T && T.viewChildren || [], B, I, E + 1);
            }
          }
          function p(y) {
            var m = cy();
            return y && D(y, function(_, I) {
              var E = m[I];
              D(_, function(x) {
                x && (E.push(x), rI(x).willDelete = true);
              });
            }), m;
          }
          function v() {
            D(f, function(y) {
              D(y, function(m) {
                m.parent && m.parent.remove(m);
              });
            }), D(h, function(y) {
              y.invisible = true, y.dirty();
            });
          }
        }, t.prototype._doAnimation = function(e, i, r, a) {
          var o = r.get("animationDurationUpdate"), s = r.get("animationEasing"), l = (yt(o) ? 0 : o) || 0, u = (yt(s) ? null : s) || "cubicOut", h = kMt();
          D(i.willDeleteEls, function(c, f) {
            D(c, function(g, d) {
              if (!g.invisible) {
                var A = g.parent, p, v = rI(A);
                if (a && a.direction === "drillDown") p = A === a.rootNodeGroup ? { shape: { x: 0, y: 0, width: v.nodeWidth, height: v.nodeHeight }, style: { opacity: 0 } } : { style: { opacity: 0 } };
                else {
                  var y = 0, m = 0;
                  v.willDelete || (y = v.nodeWidth / 2, m = v.nodeHeight / 2), p = f === "nodeGroup" ? { x: y, y: m, style: { opacity: 0 } } : { shape: { x: y, y: m, width: 0, height: 0 }, style: { opacity: 0 } };
                }
                p && h.add(g, p, l, 0, u);
              }
            });
          }), D(this._storage, function(c, f) {
            D(c, function(g, d) {
              var A = i.lastsForAnimation[f][d], p = {};
              A && (g instanceof Dt ? A.oldX != null && (p.x = g.x, p.y = g.y, g.x = A.oldX, g.y = A.oldY) : (A.oldShape && (p.shape = X({}, g.shape), g.setShape(A.oldShape)), A.fadein ? (g.setStyle("opacity", 0), p.style = { opacity: 1 }) : g.style.opacity !== 1 && (p.style = { opacity: 1 })), h.add(g, p, l, 0, u));
            });
          }, this), this._state = "animating", h.finished(ct(function() {
            this._state = "ready", i.renderFinally();
          }, this)).start();
        }, t.prototype._resetController = function(e) {
          var i = this._controller, r = this._controllerHost;
          r || (this._controllerHost = { target: this.group }, r = this._controllerHost), i || (i = this._controller = new ay(e.getZr()), i.enable(this.seriesModel.get("roam")), r.zoomLimit = this.seriesModel.get("scaleLimit"), r.zoom = this.seriesModel.get("zoom"), i.on("pan", ct(this._onPan, this)), i.on("zoom", ct(this._onZoom, this)));
          var a = new Wt(0, 0, e.getWidth(), e.getHeight());
          i.setPointerChecker(function(o, s, l) {
            return a.contain(s, l);
          });
        }, t.prototype._clearController = function() {
          var e = this._controller;
          this._controllerHost = null, e && (e.dispose(), e = null);
        }, t.prototype._onPan = function(e) {
          if (this._state !== "animating" && (Math.abs(e.dx) > Vq || Math.abs(e.dy) > Vq)) {
            var i = this.seriesModel.getData().tree.root;
            if (!i) return;
            var r = i.getLayout();
            if (!r) return;
            this.api.dispatchAction({ type: "treemapMove", from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: r.x + e.dx, y: r.y + e.dy, width: r.width, height: r.height } });
          }
        }, t.prototype._onZoom = function(e) {
          var i = e.originX, r = e.originY, a = e.scale;
          if (this._state !== "animating") {
            var o = this.seriesModel.getData().tree.root;
            if (!o) return;
            var s = o.getLayout();
            if (!s) return;
            var l = new Wt(s.x, s.y, s.width, s.height), u = null, h = this._controllerHost;
            u = h.zoomLimit;
            var c = h.zoom = h.zoom || 1;
            if (c *= a, u) {
              var f = u.min || 0, g = u.max || 1 / 0;
              c = Math.max(Math.min(g, c), f);
            }
            var d = c / h.zoom;
            h.zoom = c;
            var A = this.seriesModel.layoutInfo;
            i -= A.x, r -= A.y;
            var p = Vr();
            Go(p, p, [-i, -r]), N2(p, p, [d, d]), Go(p, p, [i, r]), l.applyTransform(p), this.api.dispatchAction({ type: "treemapRender", from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: l.x, y: l.y, width: l.width, height: l.height } });
          }
        }, t.prototype._initEvents = function(e) {
          var i = this;
          e.on("click", function(r) {
            if (i._state === "ready") {
              var a = i.seriesModel.get("nodeClick", true);
              if (a) {
                var o = i.findTarget(r.offsetX, r.offsetY);
                if (o) {
                  var s = o.node;
                  if (s.getLayout().isLeafRoot) i._rootToNode(o);
                  else if (a === "zoomToNode") i._zoomToNode(o);
                  else if (a === "link") {
                    var l = s.hostTree.data.getItemModel(s.dataIndex), u = l.get("link", true), h = l.get("target", true) || "blank";
                    u && tE(u, h);
                  }
                }
              }
            }
          }, this);
        }, t.prototype._renderBreadcrumb = function(e, i, r) {
          var a = this;
          r || (r = e.get("leafDepth", true) != null ? { node: e.getViewRoot() } : this.findTarget(i.getWidth() / 2, i.getHeight() / 2), r || (r = { node: e.getData().tree.root })), (this._breadcrumb || (this._breadcrumb = new LMt(this.group))).render(e, i, r.node, function(o) {
            a._state !== "animating" && (wD(e.getViewRoot(), o) ? a._rootToNode({ node: o }) : a._zoomToNode({ node: o }));
          });
        }, t.prototype.remove = function() {
          this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = cy(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
        }, t.prototype.dispose = function() {
          this._clearController();
        }, t.prototype._zoomToNode = function(e) {
          this.api.dispatchAction({ type: "treemapZoomToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: e.node });
        }, t.prototype._rootToNode = function(e) {
          this.api.dispatchAction({ type: "treemapRootToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: e.node });
        }, t.prototype.findTarget = function(e, i) {
          var r, a = this.seriesModel.getViewRoot();
          return a.eachNode({ attr: "viewChildren", order: "preorder" }, function(o) {
            var s = this._storage.background[o.getRawIndex()];
            if (s) {
              var l = s.transformCoordToLocal(e, i), u = s.shape;
              if (u.x <= l[0] && l[0] <= u.x + u.width && u.y <= l[1] && l[1] <= u.y + u.height) r = { node: o, offsetX: l[0], offsetY: l[1] };
              else return false;
            }
          }, this), r;
        }, t.type = "treemap", t;
      }(qe);
      function cy() {
        return { nodeGroup: [], background: [], content: [] };
      }
      function UMt(n, t, e, i, r, a, o, s, l, u) {
        if (!o) return;
        var h = o.getLayout(), c = n.getData(), f = o.getModel();
        if (c.setItemGraphicEl(o.dataIndex, null), !h || !h.isInView) return;
        var g = h.width, d = h.height, A = h.borderWidth, p = h.invisible, v = o.getRawIndex(), y = s && s.getRawIndex(), m = o.viewChildren, _ = h.upperHeight, I = m && m.length, E = f.getModel("itemStyle"), x = f.getModel(["emphasis", "itemStyle"]), w = f.getModel(["blur", "itemStyle"]), C = f.getModel(["select", "itemStyle"]), S = E.get("borderRadius") || 0, b = G("nodeGroup", SD);
        if (!b) return;
        if (l.add(b), b.x = h.x || 0, b.y = h.y || 0, b.markRedraw(), rI(b).nodeWidth = g, rI(b).nodeHeight = d, h.isAboveViewRoot) return b;
        var T = G("background", Uq, u, QMt);
        T && k(b, T, I && h.upperLabelHeight);
        var B = f.getModel("emphasis"), R = B.get("focus"), M = B.get("blurScope"), L = B.get("disabled"), N = R === "ancestor" ? o.getAncestorsIndices() : R === "descendant" ? o.getDescendantIndices() : R;
        if (I) lu(b) && Vh(b, false), T && (Vh(T, !L), c.setItemGraphicEl(o.dataIndex, T), ZT(T, N, M));
        else {
          var F = G("content", Uq, u, zMt);
          F && O(b, F), T.disableMorphing = true, T && lu(T) && Vh(T, false), Vh(b, !L), c.setItemGraphicEl(o.dataIndex, b), ZT(b, N, M);
        }
        return b;
        function k(et, nt, gt) {
          var q = Nt(nt);
          if (q.dataIndex = o.dataIndex, q.seriesIndex = n.seriesIndex, nt.setShape({ x: 0, y: 0, width: g, height: d, r: S }), p) Q(nt);
          else {
            nt.invisible = false;
            var W = o.getVisual("style"), it = W.stroke, Ot = Hq(E);
            Ot.fill = it;
            var pt = mc(x);
            pt.fill = x.get("borderColor");
            var St = mc(w);
            St.fill = w.get("borderColor");
            var bt = mc(C);
            if (bt.fill = C.get("borderColor"), gt) {
              var xe = g - 2 * A;
              j(nt, it, W.opacity, { x: A, y: 0, width: xe, height: _ });
            } else nt.removeTextContent();
            nt.setStyle(Ot), nt.ensureState("emphasis").style = pt, nt.ensureState("blur").style = St, nt.ensureState("select").style = bt, Gh(nt);
          }
          et.add(nt);
        }
        function O(et, nt) {
          var gt = Nt(nt);
          gt.dataIndex = o.dataIndex, gt.seriesIndex = n.seriesIndex;
          var q = Math.max(g - 2 * A, 0), W = Math.max(d - 2 * A, 0);
          if (nt.culling = true, nt.setShape({ x: A, y: A, width: q, height: W, r: S }), p) Q(nt);
          else {
            nt.invisible = false;
            var it = o.getVisual("style"), Ot = it.fill, pt = Hq(E);
            pt.fill = Ot, pt.decal = it.decal;
            var St = mc(x), bt = mc(w), xe = mc(C);
            j(nt, Ot, it.opacity, null), nt.setStyle(pt), nt.ensureState("emphasis").style = St, nt.ensureState("blur").style = bt, nt.ensureState("select").style = xe, Gh(nt);
          }
          et.add(nt);
        }
        function Q(et) {
          !et.invisible && a.push(et);
        }
        function j(et, nt, gt, q) {
          var W = f.getModel(q ? qq : jq), it = Hn(f.get("name"), null), Ot = W.getShallow("show");
          xi(et, Jn(f, q ? qq : jq), { defaultText: Ot ? it : null, inheritColor: nt, defaultOpacity: gt, labelFetcher: n, labelDataIndex: o.dataIndex });
          var pt = et.getTextContent();
          if (pt) {
            var St = pt.style, bt = I2(St.padding || 0);
            q && (et.setTextConfig({ layoutRect: q }), pt.disableLabelLayout = true), pt.beforeUpdate = function() {
              var sn = Math.max((q ? q.width : et.shape.width) - bt[1] - bt[3], 0), Ie = Math.max((q ? q.height : et.shape.height) - bt[0] - bt[2], 0);
              (St.width !== sn || St.height !== Ie) && pt.setStyle({ width: sn, height: Ie });
            }, St.truncateMinChar = 2, St.lineOverflow = "truncate", Y(St, q, h);
            var xe = pt.getState("emphasis");
            Y(xe ? xe.style : null, q, h);
          }
        }
        function Y(et, nt, gt) {
          var q = et ? et.text : null;
          if (!nt && gt.isLeafRoot && q != null) {
            var W = n.get("drillDownIcon", true);
            et.text = W ? W + " " + q : q;
          }
        }
        function G(et, nt, gt, q) {
          var W = y != null && e[et][y], it = r[et];
          return W ? (e[et][y] = null, $(it, W)) : p || (W = new nt(), W instanceof ya && (W.z2 = VMt(gt, q)), J(it, W)), t[et][v] = W;
        }
        function $(et, nt) {
          var gt = et[v] = {};
          nt instanceof SD ? (gt.oldX = nt.x, gt.oldY = nt.y) : gt.oldShape = X({}, nt.shape);
        }
        function J(et, nt) {
          var gt = et[v] = {}, q = o.parentNode, W = nt instanceof Dt;
          if (q && (!i || i.direction === "drillDown")) {
            var it = 0, Ot = 0, pt = r.background[q.getRawIndex()];
            !i && pt && pt.oldShape && (it = pt.oldShape.width, Ot = pt.oldShape.height), W ? (gt.oldX = 0, gt.oldY = Ot) : gt.oldShape = { x: it, y: Ot, width: 0, height: 0 };
          }
          gt.fadein = !W;
        }
      }
      function VMt(n, t) {
        return n * OMt + t;
      }
      var fy = D, jMt = Et, aI = -1, ni = function() {
        function n(t) {
          var e = t.mappingMethod, i = t.type, r = this.option = Ct(t);
          this.type = i, this.mappingMethod = e, this._normalizeData = YMt[e];
          var a = n.visualHandlers[i];
          this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[e], e === "piecewise" ? (bD(r), qMt(r)) : e === "category" ? r.categories ? HMt(r) : bD(r, true) : (It(e !== "linear" || r.dataExtent), bD(r));
        }
        return n.prototype.mapValueToVisual = function(t) {
          var e = this._normalizeData(t);
          return this._normalizedToVisual(e, t);
        }, n.prototype.getNormalizer = function() {
          return ct(this._normalizeData, this);
        }, n.listVisualTypes = function() {
          return oe(n.visualHandlers);
        }, n.isValidType = function(t) {
          return n.visualHandlers.hasOwnProperty(t);
        }, n.eachVisual = function(t, e, i) {
          Et(t) ? D(t, e, i) : e.call(i, t);
        }, n.mapVisual = function(t, e, i) {
          var r, a = Z(t) ? [] : Et(t) ? {} : (r = true, null);
          return n.eachVisual(t, function(o, s) {
            var l = e.call(i, o, s);
            r ? a = l : a[s] = l;
          }), a;
        }, n.retrieveVisuals = function(t) {
          var e = {}, i;
          return t && fy(n.visualHandlers, function(r, a) {
            t.hasOwnProperty(a) && (e[a] = t[a], i = true);
          }), i ? e : null;
        }, n.prepareVisualTypes = function(t) {
          if (Z(t)) t = t.slice();
          else if (jMt(t)) {
            var e = [];
            fy(t, function(i, r) {
              e.push(r);
            }), t = e;
          } else return [];
          return t.sort(function(i, r) {
            return r === "color" && i !== "color" && i.indexOf("color") === 0 ? 1 : -1;
          }), t;
        }, n.dependsOn = function(t, e) {
          return e === "color" ? !!(t && t.indexOf(e) === 0) : t === e;
        }, n.findPieceIndex = function(t, e, i) {
          for (var r, a = 1 / 0, o = 0, s = e.length; o < s; o++) {
            var l = e[o].value;
            if (l != null) {
              if (l === t || ht(l) && l === t + "") return o;
              i && f(l, o);
            }
          }
          for (var o = 0, s = e.length; o < s; o++) {
            var u = e[o], h = u.interval, c = u.close;
            if (h) {
              if (h[0] === -1 / 0) {
                if (sI(c[1], t, h[1])) return o;
              } else if (h[1] === 1 / 0) {
                if (sI(c[0], h[0], t)) return o;
              } else if (sI(c[0], h[0], t) && sI(c[1], t, h[1])) return o;
              i && f(h[0], o), i && f(h[1], o);
            }
          }
          if (i) return t === 1 / 0 ? e.length - 1 : t === -1 / 0 ? 0 : r;
          function f(g, d) {
            var A = Math.abs(g - t);
            A < a && (a = A, r = d);
          }
        }, n.visualHandlers = { color: { applyVisual: gy("color"), getColorMapper: function() {
          var t = this.option;
          return ct(t.mappingMethod === "category" ? function(e, i) {
            return !i && (e = this._normalizeData(e)), dy.call(this, e);
          } : function(e, i, r) {
            var a = !!r;
            return !i && (e = this._normalizeData(e)), r = Y2(e, t.parsedVisual, r), a ? r : Gs(r, "rgba");
          }, this);
        }, _normalizedToVisual: { linear: function(t) {
          return Gs(Y2(t, this.option.parsedVisual), "rgba");
        }, category: dy, piecewise: function(t, e) {
          var i = BD.call(this, e);
          return i == null && (i = Gs(Y2(t, this.option.parsedVisual), "rgba")), i;
        }, fixed: _c } }, colorHue: oI(function(t, e) {
          return qp(t, e);
        }), colorSaturation: oI(function(t, e) {
          return qp(t, null, e);
        }), colorLightness: oI(function(t, e) {
          return qp(t, null, null, e);
        }), colorAlpha: oI(function(t, e) {
          return e1(t, e);
        }), decal: { applyVisual: gy("decal"), _normalizedToVisual: { linear: null, category: dy, piecewise: null, fixed: null } }, opacity: { applyVisual: gy("opacity"), _normalizedToVisual: TD([0, 1]) }, liftZ: { applyVisual: gy("liftZ"), _normalizedToVisual: { linear: _c, category: _c, piecewise: _c, fixed: _c } }, symbol: { applyVisual: function(t, e, i) {
          var r = this.mapValueToVisual(t);
          i("symbol", r);
        }, _normalizedToVisual: { linear: Yq, category: dy, piecewise: function(t, e) {
          var i = BD.call(this, e);
          return i == null && (i = Yq.call(this, t)), i;
        }, fixed: _c } }, symbolSize: { applyVisual: gy("symbolSize"), _normalizedToVisual: TD([0, 1]) } }, n;
      }();
      function qMt(n) {
        var t = n.pieceList;
        n.hasSpecialVisual = false, D(t, function(e, i) {
          e.originIndex = i, e.visual != null && (n.hasSpecialVisual = true);
        });
      }
      function HMt(n) {
        var t = n.categories, e = n.categoryMap = {}, i = n.visual;
        if (fy(t, function(o, s) {
          e[o] = s;
        }), !Z(i)) {
          var r = [];
          Et(i) ? fy(i, function(o, s) {
            var l = e[s];
            r[l != null ? l : aI] = o;
          }) : r[aI] = i, i = Wq(n, r);
        }
        for (var a = t.length - 1; a >= 0; a--) i[a] == null && (delete e[t[a]], t.pop());
      }
      function bD(n, t) {
        var e = n.visual, i = [];
        Et(e) ? fy(e, function(a) {
          i.push(a);
        }) : e != null && i.push(e);
        var r = { color: 1, symbol: 1 };
        !t && i.length === 1 && !r.hasOwnProperty(n.type) && (i[1] = i[0]), Wq(n, i);
      }
      function oI(n) {
        return { applyVisual: function(t, e, i) {
          var r = this.mapValueToVisual(t);
          i("color", n(e("color"), r));
        }, _normalizedToVisual: TD([0, 1]) };
      }
      function Yq(n) {
        var t = this.option.visual;
        return t[Math.round(Ne(n, [0, 1], [0, t.length - 1], true))] || {};
      }
      function gy(n) {
        return function(t, e, i) {
          i(n, this.mapValueToVisual(t));
        };
      }
      function dy(n) {
        var t = this.option.visual;
        return t[this.option.loop && n !== aI ? n % t.length : n];
      }
      function _c() {
        return this.option.visual[0];
      }
      function TD(n) {
        return { linear: function(t) {
          return Ne(t, n, this.option.visual, true);
        }, category: dy, piecewise: function(t, e) {
          var i = BD.call(this, e);
          return i == null && (i = Ne(t, n, this.option.visual, true)), i;
        }, fixed: _c };
      }
      function BD(n) {
        var t = this.option, e = t.pieceList;
        if (t.hasSpecialVisual) {
          var i = ni.findPieceIndex(n, e), r = e[i];
          if (r && r.visual) return r.visual[this.type];
        }
      }
      function Wq(n, t) {
        return n.visual = t, n.type === "color" && (n.parsedVisual = K(t, function(e) {
          var i = qr(e);
          return !i && true && gn("'" + e + "' is an illegal color, fallback to '#000000'", true), i || [0, 0, 0, 1];
        })), t;
      }
      var YMt = { linear: function(n) {
        return Ne(n, this.option.dataExtent, [0, 1], true);
      }, piecewise: function(n) {
        var t = this.option.pieceList, e = ni.findPieceIndex(n, t, true);
        if (e != null) return Ne(e, [0, t.length - 1], [0, 1], true);
      }, category: function(n) {
        var t = this.option.categories ? this.option.categoryMap[n] : n;
        return t == null ? aI : t;
      }, fixed: bn };
      function sI(n, t, e) {
        return n ? t <= e : t < e;
      }
      var WMt = "itemStyle", Xq = ce();
      const XMt = { seriesType: "treemap", reset: function(n) {
        var t = n.getData().tree, e = t.root;
        e.isRemoved() || $q(e, {}, n.getViewRoot().getAncestors(), n);
      } };
      function $q(n, t, e, i) {
        var r = n.getModel(), a = n.getLayout(), o = n.hostTree.data;
        if (!(!a || a.invisible || !a.isInView)) {
          var s = r.getModel(WMt), l = $Mt(s, t, i), u = o.ensureUniqueItemVisual(n.dataIndex, "style"), h = s.get("borderColor"), c = s.get("borderColorSaturation"), f;
          c != null && (f = Zq(l), h = ZMt(c, f)), u.stroke = h;
          var g = n.viewChildren;
          if (!g || !g.length) f = Zq(l), u.fill = f;
          else {
            var d = KMt(n, r, a, s, l, g);
            D(g, function(A, p) {
              if (A.depth >= e.length || A === e[A.depth]) {
                var v = JMt(r, l, A, p, d, i);
                $q(A, v, e, i);
              }
            });
          }
        }
      }
      function $Mt(n, t, e) {
        var i = X({}, t), r = e.designatedVisualItemStyle;
        return D(["color", "colorAlpha", "colorSaturation"], function(a) {
          r[a] = t[a];
          var o = n.get(a);
          r[a] = null, o != null && (i[a] = o);
        }), i;
      }
      function Zq(n) {
        var t = MD(n, "color");
        if (t) {
          var e = MD(n, "colorAlpha"), i = MD(n, "colorSaturation");
          return i && (t = qp(t, null, null, i)), e && (t = e1(t, e)), t;
        }
      }
      function ZMt(n, t) {
        return t != null ? qp(t, null, null, n) : null;
      }
      function MD(n, t) {
        var e = n[t];
        if (e != null && e !== "none") return e;
      }
      function KMt(n, t, e, i, r, a) {
        if (!(!a || !a.length)) {
          var o = DD(t, "color") || r.color != null && r.color !== "none" && (DD(t, "colorAlpha") || DD(t, "colorSaturation"));
          if (o) {
            var s = t.get("visualMin"), l = t.get("visualMax"), u = e.dataExtent.slice();
            s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l);
            var h = t.get("colorMappingBy"), c = { type: o.name, dataExtent: u, visual: o.range };
            c.type === "color" && (h === "index" || h === "id") ? (c.mappingMethod = "category", c.loop = true) : c.mappingMethod = "linear";
            var f = new ni(c);
            return Xq(f).drColorMappingBy = h, f;
          }
        }
      }
      function DD(n, t) {
        var e = n.get(t);
        return Z(e) && e.length ? { name: t, range: e } : null;
      }
      function JMt(n, t, e, i, r, a) {
        var o = X({}, t);
        if (r) {
          var s = r.type, l = s === "color" && Xq(r).drColorMappingBy, u = l === "index" ? i : l === "id" ? a.mapIdToIndex(e.getId()) : e.getValue(n.get("visualDimension"));
          o[s] = r.mapValueToVisual(u);
        }
        return o;
      }
      var Ay = Math.max, lI = Math.min, Kq = On, RD = D, Jq = ["itemStyle", "borderWidth"], tDt = ["itemStyle", "gapWidth"], eDt = ["upperLabel", "show"], nDt = ["upperLabel", "height"];
      const iDt = { seriesType: "treemap", reset: function(n, t, e, i) {
        var r = e.getWidth(), a = e.getHeight(), o = n.option, s = Yn(n.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }), l = o.size || [], u = st(Kq(s.width, l[0]), r), h = st(Kq(s.height, l[1]), a), c = i && i.type, f = ["treemapZoomToNode", "treemapRootToNode"], g = uy(i, f, n), d = c === "treemapRender" || c === "treemapMove" ? i.rootRect : null, A = n.getViewRoot(), p = kq(A);
        if (c !== "treemapMove") {
          var v = c === "treemapZoomToNode" ? uDt(n, g, A, u, h) : d ? [d.width, d.height] : [u, h], y = o.sort;
          y && y !== "asc" && y !== "desc" && (y = "desc");
          var m = { squareRatio: o.squareRatio, sort: y, leafDepth: o.leafDepth };
          A.hostTree.clearLayouts();
          var _ = { x: 0, y: 0, width: v[0], height: v[1], area: v[0] * v[1] };
          A.setLayout(_), t7(A, m, false, 0), _ = A.getLayout(), RD(p, function(E, x) {
            var w = (p[x + 1] || A).getValue();
            E.setLayout(X({ dataExtent: [w, w], borderWidth: 0, upperHeight: 0 }, _));
          });
        }
        var I = n.getData().tree.root;
        I.setLayout(hDt(s, d, g), true), n.setLayoutInfo(s), n7(I, new Wt(-s.x, -s.y, r, a), p, A, 0);
      } };
      function t7(n, t, e, i) {
        var r, a;
        if (!n.isRemoved()) {
          var o = n.getLayout();
          r = o.width, a = o.height;
          var s = n.getModel(), l = s.get(Jq), u = s.get(tDt) / 2, h = i7(s), c = Math.max(l, h), f = l - u, g = c - u;
          n.setLayout({ borderWidth: l, upperHeight: c, upperLabelHeight: h }, true), r = Ay(r - 2 * f, 0), a = Ay(a - f - g, 0);
          var d = r * a, A = rDt(n, s, d, t, e, i);
          if (A.length) {
            var p = { x: f, y: g, width: r, height: a }, v = lI(r, a), y = 1 / 0, m = [];
            m.area = 0;
            for (var _ = 0, I = A.length; _ < I; ) {
              var E = A[_];
              m.push(E), m.area += E.getLayout().area;
              var x = lDt(m, v, t.squareRatio);
              x <= y ? (_++, y = x) : (m.area -= m.pop().getLayout().area, e7(m, v, p, u, false), v = lI(p.width, p.height), m.length = m.area = 0, y = 1 / 0);
            }
            if (m.length && e7(m, v, p, u, true), !e) {
              var w = s.get("childrenVisibleMin");
              w != null && d < w && (e = true);
            }
            for (var _ = 0, I = A.length; _ < I; _++) t7(A[_], t, e, i + 1);
          }
        }
      }
      function rDt(n, t, e, i, r, a) {
        var o = n.children || [], s = i.sort;
        s !== "asc" && s !== "desc" && (s = null);
        var l = i.leafDepth != null && i.leafDepth <= a;
        if (r && !l) return n.viewChildren = [];
        o = Fe(o, function(g) {
          return !g.isRemoved();
        }), oDt(o, s);
        var u = sDt(t, o, s);
        if (u.sum === 0) return n.viewChildren = [];
        if (u.sum = aDt(t, e, u.sum, s, o), u.sum === 0) return n.viewChildren = [];
        for (var h = 0, c = o.length; h < c; h++) {
          var f = o[h].getValue() / u.sum * e;
          o[h].setLayout({ area: f });
        }
        return l && (o.length && n.setLayout({ isLeafRoot: true }, true), o.length = 0), n.viewChildren = o, n.setLayout({ dataExtent: u.dataExtent }, true), o;
      }
      function aDt(n, t, e, i, r) {
        if (!i) return e;
        for (var a = n.get("visibleMin"), o = r.length, s = o, l = o - 1; l >= 0; l--) {
          var u = r[i === "asc" ? o - l - 1 : l].getValue();
          u / e * t < a && (s = l, e -= u);
        }
        return i === "asc" ? r.splice(0, o - s) : r.splice(s, o - s), e;
      }
      function oDt(n, t) {
        return t && n.sort(function(e, i) {
          var r = t === "asc" ? e.getValue() - i.getValue() : i.getValue() - e.getValue();
          return r === 0 ? t === "asc" ? e.dataIndex - i.dataIndex : i.dataIndex - e.dataIndex : r;
        }), n;
      }
      function sDt(n, t, e) {
        for (var i = 0, r = 0, a = t.length; r < a; r++) i += t[r].getValue();
        var o = n.get("visualDimension"), s;
        return !t || !t.length ? s = [NaN, NaN] : o === "value" && e ? (s = [t[t.length - 1].getValue(), t[0].getValue()], e === "asc" && s.reverse()) : (s = [1 / 0, -1 / 0], RD(t, function(l) {
          var u = l.getValue(o);
          u < s[0] && (s[0] = u), u > s[1] && (s[1] = u);
        })), { sum: i, dataExtent: s };
      }
      function lDt(n, t, e) {
        for (var i = 0, r = 1 / 0, a = 0, o = void 0, s = n.length; a < s; a++) o = n[a].getLayout().area, o && (o < r && (r = o), o > i && (i = o));
        var l = n.area * n.area, u = t * t * e;
        return l ? Ay(u * i / l, l / (u * r)) : 1 / 0;
      }
      function e7(n, t, e, i, r) {
        var a = t === e.width ? 0 : 1, o = 1 - a, s = ["x", "y"], l = ["width", "height"], u = e[s[a]], h = t ? n.area / t : 0;
        (r || h > e[l[o]]) && (h = e[l[o]]);
        for (var c = 0, f = n.length; c < f; c++) {
          var g = n[c], d = {}, A = h ? g.getLayout().area / h : 0, p = d[l[o]] = Ay(h - 2 * i, 0), v = e[s[a]] + e[l[a]] - u, y = c === f - 1 || v < A ? v : A, m = d[l[a]] = Ay(y - 2 * i, 0);
          d[s[o]] = e[s[o]] + lI(i, p / 2), d[s[a]] = u + lI(i, m / 2), u += y, g.setLayout(d, true);
        }
        e[s[o]] += h, e[l[o]] -= h;
      }
      function uDt(n, t, e, i, r) {
        var a = (t || {}).node, o = [i, r];
        if (!a || a === e) return o;
        for (var s, l = i * r, u = l * n.option.zoomToNodeRatio; s = a.parentNode; ) {
          for (var h = 0, c = s.children, f = 0, g = c.length; f < g; f++) h += c[f].getValue();
          var d = a.getValue();
          if (d === 0) return o;
          u *= h / d;
          var A = s.getModel(), p = A.get(Jq), v = Math.max(p, i7(A));
          u += 4 * p * p + (3 * p + v) * Math.pow(u, 0.5), u > a4 && (u = a4), a = s;
        }
        u < l && (u = l);
        var y = Math.pow(u / l, 0.5);
        return [i * y, r * y];
      }
      function hDt(n, t, e) {
        if (t) return { x: t.x, y: t.y };
        var i = { x: 0, y: 0 };
        if (!e) return i;
        var r = e.node, a = r.getLayout();
        if (!a) return i;
        for (var o = [a.width / 2, a.height / 2], s = r; s; ) {
          var l = s.getLayout();
          o[0] += l.x, o[1] += l.y, s = s.parentNode;
        }
        return { x: n.width / 2 - o[0], y: n.height / 2 - o[1] };
      }
      function n7(n, t, e, i, r) {
        var a = n.getLayout(), o = e[r], s = o && o === n;
        if (!(o && !s || r === e.length && n !== i)) {
          n.setLayout({ isInView: true, invisible: !s && !t.intersect(a), isAboveViewRoot: s }, true);
          var l = new Wt(t.x - a.x, t.y - a.y, t.width, t.height);
          RD(n.viewChildren || [], function(u) {
            n7(u, l, e, i, r + 1);
          });
        }
      }
      function i7(n) {
        return n.get(eDt) ? n.get(nDt) : 0;
      }
      function cDt(n) {
        n.registerSeriesModel(MMt), n.registerChartView(GMt), n.registerVisual(XMt), n.registerLayout(iDt), BMt(n);
      }
      function fDt(n) {
        var t = n.findComponents({ mainType: "legend" });
        !t || !t.length || n.eachSeriesByType("graph", function(e) {
          var i = e.getCategoriesData(), r = e.getGraph(), a = r.data, o = i.mapArray(i.getName);
          a.filterSelf(function(s) {
            var l = a.getItemModel(s), u = l.getShallow("category");
            if (u != null) {
              ye(u) && (u = o[u]);
              for (var h = 0; h < t.length; h++) if (!t[h].isSelected(u)) return false;
            }
            return true;
          });
        });
      }
      function gDt(n) {
        var t = {};
        n.eachSeriesByType("graph", function(e) {
          var i = e.getCategoriesData(), r = e.getData(), a = {};
          i.each(function(o) {
            var s = i.getName(o);
            a["ec-" + s] = o;
            var l = i.getItemModel(o), u = l.getModel("itemStyle").getItemStyle();
            u.fill || (u.fill = e.getColorFromPalette(s, t)), i.setItemVisual(o, "style", u);
            for (var h = ["symbol", "symbolSize", "symbolKeepAspect"], c = 0; c < h.length; c++) {
              var f = l.getShallow(h[c], true);
              f != null && i.setItemVisual(o, h[c], f);
            }
          }), i.count() && r.each(function(o) {
            var s = r.getItemModel(o), l = s.getShallow("category");
            if (l != null) {
              ht(l) && (l = a["ec-" + l]);
              var u = i.getItemVisual(l, "style"), h = r.ensureUniqueItemVisual(o, "style");
              X(h, u);
              for (var c = ["symbol", "symbolSize", "symbolKeepAspect"], f = 0; f < c.length; f++) r.setItemVisual(o, c[f], i.getItemVisual(l, c[f]));
            }
          });
        });
      }
      function uI(n) {
        return n instanceof Array || (n = [n, n]), n;
      }
      function dDt(n) {
        n.eachSeriesByType("graph", function(t) {
          var e = t.getGraph(), i = t.getEdgeData(), r = uI(t.get("edgeSymbol")), a = uI(t.get("edgeSymbolSize"));
          i.setVisual("fromSymbol", r && r[0]), i.setVisual("toSymbol", r && r[1]), i.setVisual("fromSymbolSize", a && a[0]), i.setVisual("toSymbolSize", a && a[1]), i.setVisual("style", t.getModel("lineStyle").getLineStyle()), i.each(function(o) {
            var s = i.getItemModel(o), l = e.getEdgeByIndex(o), u = uI(s.getShallow("symbol", true)), h = uI(s.getShallow("symbolSize", true)), c = s.getModel("lineStyle").getLineStyle(), f = i.ensureUniqueItemVisual(o, "style");
            switch (X(f, c), f.stroke) {
              case "source": {
                var g = l.node1.getVisual("style");
                f.stroke = g && g.fill;
                break;
              }
              case "target": {
                var g = l.node2.getVisual("style");
                f.stroke = g && g.fill;
                break;
              }
            }
            u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), h[0] && l.setVisual("fromSymbolSize", h[0]), h[1] && l.setVisual("toSymbolSize", h[1]);
          });
        });
      }
      var LD = "-->", hI = function(n) {
        return n.get("autoCurveness") || null;
      }, r7 = function(n, t) {
        var e = hI(n), i = 20, r = [];
        if (ye(e)) i = e;
        else if (Z(e)) {
          n.__curvenessList = e;
          return;
        }
        t > i && (i = t);
        var a = i % 2 ? i + 2 : i + 3;
        r = [];
        for (var o = 0; o < a; o++) r.push((o % 2 ? o + 1 : o) / 10 * (o % 2 ? -1 : 1));
        n.__curvenessList = r;
      }, py = function(n, t, e) {
        var i = [n.id, n.dataIndex].join("."), r = [t.id, t.dataIndex].join(".");
        return [e.uid, i, r].join(LD);
      }, a7 = function(n) {
        var t = n.split(LD);
        return [t[0], t[2], t[1]].join(LD);
      }, ADt = function(n, t) {
        var e = py(n.node1, n.node2, t);
        return t.__edgeMap[e];
      }, pDt = function(n, t) {
        var e = PD(py(n.node1, n.node2, t), t), i = PD(py(n.node2, n.node1, t), t);
        return e + i;
      }, PD = function(n, t) {
        var e = t.__edgeMap;
        return e[n] ? e[n].length : 0;
      };
      function vDt(n) {
        hI(n) && (n.__curvenessList = [], n.__edgeMap = {}, r7(n));
      }
      function yDt(n, t, e, i) {
        if (hI(e)) {
          var r = py(n, t, e), a = e.__edgeMap, o = a[a7(r)];
          a[r] && !o ? a[r].isForward = true : o && a[r] && (o.isForward = true, a[r].isForward = false), a[r] = a[r] || [], a[r].push(i);
        }
      }
      function ND(n, t, e, i) {
        var r = hI(t), a = Z(r);
        if (!r) return null;
        var o = ADt(n, t);
        if (!o) return null;
        for (var s = -1, l = 0; l < o.length; l++) if (o[l] === e) {
          s = l;
          break;
        }
        var u = pDt(n, t);
        r7(t, u), n.lineStyle = n.lineStyle || {};
        var h = py(n.node1, n.node2, t), c = t.__curvenessList, f = a || u % 2 ? 0 : 1;
        if (o.isForward) return c[f + s];
        var g = a7(h), d = PD(g, t), A = c[s + d + f];
        return i ? a ? r && r[0] === 0 ? (d + f) % 2 ? A : -A : ((d % 2 ? 0 : 1) + f) % 2 ? A : -A : (d + f) % 2 ? A : -A : c[s + d + f];
      }
      function o7(n) {
        var t = n.coordinateSystem;
        if (!(t && t.type !== "view")) {
          var e = n.getGraph();
          e.eachNode(function(i) {
            var r = i.getModel();
            i.setLayout([+r.get("x"), +r.get("y")]);
          }), FD(e, n);
        }
      }
      function FD(n, t) {
        n.eachEdge(function(e, i) {
          var r = fa(e.getModel().get(["lineStyle", "curveness"]), -ND(e, t, i, true), 0), a = Os(e.node1.getLayout()), o = Os(e.node2.getLayout()), s = [a, o];
          +r && s.push([(a[0] + o[0]) / 2 - (a[1] - o[1]) * r, (a[1] + o[1]) / 2 - (o[0] - a[0]) * r]), e.setLayout(s);
        });
      }
      function mDt(n, t) {
        n.eachSeriesByType("graph", function(e) {
          var i = e.get("layout"), r = e.coordinateSystem;
          if (r && r.type !== "view") {
            var a = e.getData(), o = [];
            D(r.dimensions, function(f) {
              o = o.concat(a.mapDimensionsAll(f));
            });
            for (var s = 0; s < a.count(); s++) {
              for (var l = [], u = false, h = 0; h < o.length; h++) {
                var c = a.get(o[h], s);
                isNaN(c) || (u = true), l.push(c);
              }
              u ? a.setItemLayout(s, r.dataToPoint(l)) : a.setItemLayout(s, [NaN, NaN]);
            }
            FD(a.graph, e);
          } else (!i || i === "none") && o7(e);
        });
      }
      function vy(n) {
        var t = n.coordinateSystem;
        if (t.type !== "view") return 1;
        var e = n.option.nodeScaleRatio, i = t.scaleX, r = t.getZoom(), a = (r - 1) * e + 1;
        return a / i;
      }
      function yy(n) {
        var t = n.getVisual("symbolSize");
        return t instanceof Array && (t = (t[0] + t[1]) / 2), +t;
      }
      var s7 = Math.PI, kD = [];
      function OD(n, t, e, i) {
        var r = n.coordinateSystem;
        if (!(r && r.type !== "view")) {
          var a = r.getBoundingRect(), o = n.getData(), s = o.graph, l = a.width / 2 + a.x, u = a.height / 2 + a.y, h = Math.min(a.width, a.height) / 2, c = o.count();
          if (o.setLayout({ cx: l, cy: u }), !!c) {
            if (e) {
              var f = r.pointToData(i), g = f[0], d = f[1], A = [g - l, d - u];
              wg(A, A), V_(A, A, h), e.setLayout([l + A[0], u + A[1]], true);
              var p = n.get(["circular", "rotateLabel"]);
              l7(e, p, l, u);
            }
            _Dt[t](n, s, o, h, l, u, c), s.eachEdge(function(v, y) {
              var m = fa(v.getModel().get(["lineStyle", "curveness"]), ND(v, n, y), 0), _ = Os(v.node1.getLayout()), I = Os(v.node2.getLayout()), E, x = (_[0] + I[0]) / 2, w = (_[1] + I[1]) / 2;
              +m && (m *= 3, E = [l * m + x * (1 - m), u * m + w * (1 - m)]), v.setLayout([_, I, E]);
            });
          }
        }
      }
      var _Dt = { value: function(n, t, e, i, r, a, o) {
        var s = 0, l = e.getSum("value"), u = Math.PI * 2 / (l || o);
        t.eachNode(function(h) {
          var c = h.getValue("value"), f = u * (l ? c : 1) / 2;
          s += f, h.setLayout([i * Math.cos(s) + r, i * Math.sin(s) + a]), s += f;
        });
      }, symbolSize: function(n, t, e, i, r, a, o) {
        var s = 0;
        kD.length = o;
        var l = vy(n);
        t.eachNode(function(c) {
          var f = yy(c);
          isNaN(f) && (f = 2), f < 0 && (f = 0), f *= l;
          var g = Math.asin(f / 2 / i);
          isNaN(g) && (g = s7 / 2), kD[c.dataIndex] = g, s += g * 2;
        });
        var u = (2 * s7 - s) / o / 2, h = 0;
        t.eachNode(function(c) {
          var f = u + kD[c.dataIndex];
          h += f, (!c.getLayout() || !c.getLayout().fixed) && c.setLayout([i * Math.cos(h) + r, i * Math.sin(h) + a]), h += f;
        });
      } };
      function l7(n, t, e, i) {
        var r = n.getGraphicEl();
        if (r) {
          var a = n.getModel(), o = a.get(["label", "rotate"]) || 0, s = r.getSymbolPath();
          if (t) {
            var l = n.getLayout(), u = Math.atan2(l[1] - i, l[0] - e);
            u < 0 && (u = Math.PI * 2 + u);
            var h = l[0] < e;
            h && (u = u - Math.PI);
            var c = h ? "left" : "right";
            s.setTextConfig({ rotation: -u, position: c, origin: "center" });
            var f = s.ensureState("emphasis");
            X(f.textConfig || (f.textConfig = {}), { position: c });
          } else s.setTextConfig({ rotation: o *= Math.PI / 180 });
        }
      }
      function EDt(n) {
        n.eachSeriesByType("graph", function(t) {
          t.get("layout") === "circular" && OD(t, "symbolSize");
        });
      }
      var _d = x2;
      function IDt(n, t, e) {
        for (var i = n, r = t, a = e.rect, o = a.width, s = a.height, l = [a.x + o / 2, a.y + s / 2], u = e.gravity == null ? 0.1 : e.gravity, h = 0; h < i.length; h++) {
          var c = i[h];
          c.p || (c.p = vh(o * (Math.random() - 0.5) + l[0], s * (Math.random() - 0.5) + l[1])), c.pp = Os(c.p), c.edges = null;
        }
        var f = e.friction == null ? 0.6 : e.friction, g = f, d, A;
        return { warmUp: function() {
          g = f * 0.8;
        }, setFixed: function(p) {
          i[p].fixed = true;
        }, setUnfixed: function(p) {
          i[p].fixed = false;
        }, beforeStep: function(p) {
          d = p;
        }, afterStep: function(p) {
          A = p;
        }, step: function(p) {
          d && d(i, r);
          for (var v = [], y = i.length, m = 0; m < r.length; m++) {
            var _ = r[m];
            if (!_.ignoreForceLayout) {
              var I = _.n1, E = _.n2;
              yh(v, E.p, I.p);
              var x = w2(v) - _.d, w = E.w / (I.w + E.w);
              isNaN(w) && (w = 0), wg(v, v), !I.fixed && _d(I.p, I.p, v, w * x * g), !E.fixed && _d(E.p, E.p, v, -(1 - w) * x * g);
            }
          }
          for (var m = 0; m < y; m++) {
            var C = i[m];
            C.fixed || (yh(v, l, C.p), _d(C.p, C.p, v, u * g));
          }
          for (var m = 0; m < y; m++) for (var I = i[m], S = m + 1; S < y; S++) {
            var E = i[S];
            yh(v, E.p, I.p);
            var x = w2(v);
            x === 0 && (W_t(v, Math.random() - 0.5, Math.random() - 0.5), x = 1);
            var b = (I.rep + E.rep) / x / x;
            !I.fixed && _d(I.pp, I.pp, v, b), !E.fixed && _d(E.pp, E.pp, v, -b);
          }
          for (var T = [], m = 0; m < y; m++) {
            var C = i[m];
            C.fixed || (yh(T, C.p, C.pp), _d(C.p, C.p, T, g), Wi(C.pp, C.p));
          }
          g = g * 0.992;
          var B = g < 0.01;
          A && A(i, r, B), p && p(B);
        } };
      }
      function xDt(n) {
        n.eachSeriesByType("graph", function(t) {
          var e = t.coordinateSystem;
          if (!(e && e.type !== "view")) if (t.get("layout") === "force") {
            var i = t.preservedPoints || {}, r = t.getGraph(), a = r.data, o = r.edgeData, s = t.getModel("force"), l = s.get("initLayout");
            t.preservedPoints ? a.each(function(m) {
              var _ = a.getId(m);
              a.setItemLayout(m, i[_] || [NaN, NaN]);
            }) : !l || l === "none" ? o7(t) : l === "circular" && OD(t, "value");
            var u = a.getDataExtent("value"), h = o.getDataExtent("value"), c = s.get("repulsion"), f = s.get("edgeLength"), g = Z(c) ? c : [c, c], d = Z(f) ? f : [f, f];
            d = [d[1], d[0]];
            var A = a.mapArray("value", function(m, _) {
              var I = a.getItemLayout(_), E = Ne(m, u, g);
              return isNaN(E) && (E = (g[0] + g[1]) / 2), { w: E, rep: E, fixed: a.getItemModel(_).get("fixed"), p: !I || isNaN(I[0]) || isNaN(I[1]) ? null : I };
            }), p = o.mapArray("value", function(m, _) {
              var I = r.getEdgeByIndex(_), E = Ne(m, h, d);
              isNaN(E) && (E = (d[0] + d[1]) / 2);
              var x = I.getModel(), w = fa(I.getModel().get(["lineStyle", "curveness"]), -ND(I, t, _, true), 0);
              return { n1: A[I.node1.dataIndex], n2: A[I.node2.dataIndex], d: E, curveness: w, ignoreForceLayout: x.get("ignoreForceLayout") };
            }), v = e.getBoundingRect(), y = IDt(A, p, { rect: v, gravity: s.get("gravity"), friction: s.get("friction") });
            y.beforeStep(function(m, _) {
              for (var I = 0, E = m.length; I < E; I++) m[I].fixed && Wi(m[I].p, r.getNodeByIndex(I).getLayout());
            }), y.afterStep(function(m, _, I) {
              for (var E = 0, x = m.length; E < x; E++) m[E].fixed || r.getNodeByIndex(E).setLayout(m[E].p), i[a.getId(E)] = m[E].p;
              for (var E = 0, x = _.length; E < x; E++) {
                var w = _[E], C = r.getEdgeByIndex(E), S = w.n1.p, b = w.n2.p, T = C.getLayout();
                T = T ? T.slice() : [], T[0] = T[0] || [], T[1] = T[1] || [], Wi(T[0], S), Wi(T[1], b), +w.curveness && (T[2] = [(S[0] + b[0]) / 2 - (S[1] - b[1]) * w.curveness, (S[1] + b[1]) / 2 - (b[0] - S[0]) * w.curveness]), C.setLayout(T);
              }
            }), t.forceLayout = y, t.preservedPoints = i, y.step();
          } else t.forceLayout = null;
        });
      }
      function wDt(n, t, e) {
        var i = X(n.getBoxLayoutParams(), { aspect: e });
        return Yn(i, { width: t.getWidth(), height: t.getHeight() });
      }
      function CDt(n, t) {
        var e = [];
        return n.eachSeriesByType("graph", function(i) {
          var r = i.get("coordinateSystem");
          if (!r || r === "view") {
            var a = i.getData(), o = a.mapArray(function(p) {
              var v = a.getItemModel(p);
              return [+v.get("x"), +v.get("y")];
            }), s = [], l = [];
            w1(o, s, l), l[0] - s[0] === 0 && (l[0] += 1, s[0] -= 1), l[1] - s[1] === 0 && (l[1] += 1, s[1] -= 1);
            var u = (l[0] - s[0]) / (l[1] - s[1]), h = wDt(i, t, u);
            isNaN(u) && (s = [h.x, h.y], l = [h.x + h.width, h.y + h.height]);
            var c = l[0] - s[0], f = l[1] - s[1], g = h.width, d = h.height, A = i.coordinateSystem = new sy();
            A.zoomLimit = i.get("scaleLimit"), A.setBoundingRect(s[0], s[1], c, f), A.setViewRect(h.x, h.y, g, d), A.setCenter(i.get("center"), t), A.setZoom(i.get("zoom")), e.push(A);
          }
        }), e;
      }
      var u7 = Kn.prototype, QD = gv.prototype, h7 = /* @__PURE__ */ function() {
        function n() {
          this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
        }
        return n;
      }();
      (function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t;
      })(h7);
      function zD(n) {
        return isNaN(+n.cpx1) || isNaN(+n.cpy1);
      }
      var SDt = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "ec-line", i;
        }
        return t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new h7();
        }, t.prototype.buildPath = function(e, i) {
          zD(i) ? u7.buildPath.call(this, e, i) : QD.buildPath.call(this, e, i);
        }, t.prototype.pointAt = function(e) {
          return zD(this.shape) ? u7.pointAt.call(this, e) : QD.pointAt.call(this, e);
        }, t.prototype.tangentAt = function(e) {
          var i = this.shape, r = zD(i) ? [i.x2 - i.x1, i.y2 - i.y1] : QD.tangentAt.call(this, e);
          return wg(r, r);
        }, t;
      }(ne), GD = ["fromSymbol", "toSymbol"];
      function c7(n) {
        return "_" + n + "Type";
      }
      function f7(n, t, e) {
        var i = t.getItemVisual(e, n);
        if (!i || i === "none") return i;
        var r = t.getItemVisual(e, n + "Size"), a = t.getItemVisual(e, n + "Rotate"), o = t.getItemVisual(e, n + "Offset"), s = t.getItemVisual(e, n + "KeepAspect"), l = sd(r), u = nc(o || 0, l);
        return i + l + u + (a || "") + (s || "");
      }
      function g7(n, t, e) {
        var i = t.getItemVisual(e, n);
        if (!(!i || i === "none")) {
          var r = t.getItemVisual(e, n + "Size"), a = t.getItemVisual(e, n + "Rotate"), o = t.getItemVisual(e, n + "Offset"), s = t.getItemVisual(e, n + "KeepAspect"), l = sd(r), u = nc(o || 0, l), h = Un(i, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s);
          return h.__specifiedRotation = a == null || isNaN(a) ? void 0 : +a * Math.PI / 180 || 0, h.name = n, h;
        }
      }
      function bDt(n) {
        var t = new SDt({ name: "line", subPixelOptimize: true });
        return UD(t.shape, n), t;
      }
      function UD(n, t) {
        n.x1 = t[0][0], n.y1 = t[0][1], n.x2 = t[1][0], n.y2 = t[1][1], n.percent = 1;
        var e = t[2];
        e ? (n.cpx1 = e[0], n.cpy1 = e[1]) : (n.cpx1 = NaN, n.cpy1 = NaN);
      }
      var VD = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this) || this;
          return a._createLine(e, i, r), a;
        }
        return t.prototype._createLine = function(e, i, r) {
          var a = e.hostModel, o = e.getItemLayout(i), s = bDt(o);
          s.shape.percent = 0, on(s, { shape: { percent: 1 } }, a, i), this.add(s), D(GD, function(l) {
            var u = g7(l, e, i);
            this.add(u), this[c7(l)] = f7(l, e, i);
          }, this), this._updateCommonStl(e, i, r);
        }, t.prototype.updateData = function(e, i, r) {
          var a = e.hostModel, o = this.childOfName("line"), s = e.getItemLayout(i), l = { shape: {} };
          UD(l.shape, s), Ee(o, l, a, i), D(GD, function(u) {
            var h = f7(u, e, i), c = c7(u);
            if (this[c] !== h) {
              this.remove(this.childOfName(u));
              var f = g7(u, e, i);
              this.add(f);
            }
            this[c] = h;
          }, this), this._updateCommonStl(e, i, r);
        }, t.prototype.getLinePath = function() {
          return this.childAt(0);
        }, t.prototype._updateCommonStl = function(e, i, r) {
          var a = e.hostModel, o = this.childOfName("line"), s = r && r.emphasisLineStyle, l = r && r.blurLineStyle, u = r && r.selectLineStyle, h = r && r.labelStatesModels, c = r && r.emphasisDisabled, f = r && r.focus, g = r && r.blurScope;
          if (!r || e.hasItemOption) {
            var d = e.getItemModel(i), A = d.getModel("emphasis");
            s = A.getModel("lineStyle").getLineStyle(), l = d.getModel(["blur", "lineStyle"]).getLineStyle(), u = d.getModel(["select", "lineStyle"]).getLineStyle(), c = A.get("disabled"), f = A.get("focus"), g = A.get("blurScope"), h = Jn(d);
          }
          var p = e.getItemVisual(i, "style"), v = p.stroke;
          o.useStyle(p), o.style.fill = null, o.style.strokeNoScale = true, o.ensureState("emphasis").style = s, o.ensureState("blur").style = l, o.ensureState("select").style = u, D(GD, function(E) {
            var x = this.childOfName(E);
            if (x) {
              x.setColor(v), x.style.opacity = p.opacity;
              for (var w = 0; w < $i.length; w++) {
                var C = $i[w], S = o.getState(C);
                if (S) {
                  var b = S.style || {}, T = x.ensureState(C), B = T.style || (T.style = {});
                  b.stroke != null && (B[x.__isEmptyBrush ? "stroke" : "fill"] = b.stroke), b.opacity != null && (B.opacity = b.opacity);
                }
              }
              x.markRedraw();
            }
          }, this);
          var y = a.getRawValue(i);
          xi(this, h, { labelDataIndex: i, labelFetcher: { getFormattedLabel: function(E, x) {
            return a.getFormattedLabel(E, x, e.dataType);
          } }, inheritColor: v || "#000", defaultOpacity: p.opacity, defaultText: (y == null ? e.getName(i) : isFinite(y) ? En(y) : y) + "" });
          var m = this.getTextContent();
          if (m) {
            var _ = h.normal;
            m.__align = m.style.align, m.__verticalAlign = m.style.verticalAlign, m.__position = _.get("position") || "middle";
            var I = _.get("distance");
            Z(I) || (I = [I, I]), m.__labelDistance = I;
          }
          this.setTextConfig({ position: null, local: true, inside: false }), pn(this, f, g, c);
        }, t.prototype.highlight = function() {
          Ws(this);
        }, t.prototype.downplay = function() {
          Xs(this);
        }, t.prototype.updateLayout = function(e, i) {
          this.setLinePoints(e.getItemLayout(i));
        }, t.prototype.setLinePoints = function(e) {
          var i = this.childOfName("line");
          UD(i.shape, e), i.dirty();
        }, t.prototype.beforeUpdate = function() {
          var e = this, i = e.childOfName("fromSymbol"), r = e.childOfName("toSymbol"), a = e.getTextContent();
          if (!i && !r && (!a || a.ignore)) return;
          for (var o = 1, s = this.parent; s; ) s.scaleX && (o /= s.scaleX), s = s.parent;
          var l = e.childOfName("line");
          if (!this.__dirty && !l.__dirty) return;
          var u = l.shape.percent, h = l.pointAt(0), c = l.pointAt(u), f = yh([], c, h);
          wg(f, f);
          function g(S, b) {
            var T = S.__specifiedRotation;
            if (T == null) {
              var B = l.tangentAt(b);
              S.attr("rotation", (b === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(B[1], B[0]));
            } else S.attr("rotation", T);
          }
          if (i && (i.setPosition(h), g(i, 0), i.scaleX = i.scaleY = o * u, i.markRedraw()), r && (r.setPosition(c), g(r, 1), r.scaleX = r.scaleY = o * u, r.markRedraw()), a && !a.ignore) {
            a.x = a.y = 0, a.originX = a.originY = 0;
            var d = void 0, A = void 0, p = a.__labelDistance, v = p[0] * o, y = p[1] * o, m = u / 2, _ = l.tangentAt(m), I = [_[1], -_[0]], E = l.pointAt(m);
            I[1] > 0 && (I[0] = -I[0], I[1] = -I[1]);
            var x = _[0] < 0 ? -1 : 1;
            if (a.__position !== "start" && a.__position !== "end") {
              var w = -Math.atan2(_[1], _[0]);
              c[0] < h[0] && (w = Math.PI + w), a.rotation = w;
            }
            var C = void 0;
            switch (a.__position) {
              case "insideStartTop":
              case "insideMiddleTop":
              case "insideEndTop":
              case "middle":
                C = -y, A = "bottom";
                break;
              case "insideStartBottom":
              case "insideMiddleBottom":
              case "insideEndBottom":
                C = y, A = "top";
                break;
              default:
                C = 0, A = "middle";
            }
            switch (a.__position) {
              case "end":
                a.x = f[0] * v + c[0], a.y = f[1] * y + c[1], d = f[0] > 0.8 ? "left" : f[0] < -0.8 ? "right" : "center", A = f[1] > 0.8 ? "top" : f[1] < -0.8 ? "bottom" : "middle";
                break;
              case "start":
                a.x = -f[0] * v + h[0], a.y = -f[1] * y + h[1], d = f[0] > 0.8 ? "right" : f[0] < -0.8 ? "left" : "center", A = f[1] > 0.8 ? "bottom" : f[1] < -0.8 ? "top" : "middle";
                break;
              case "insideStartTop":
              case "insideStart":
              case "insideStartBottom":
                a.x = v * x + h[0], a.y = h[1] + C, d = _[0] < 0 ? "right" : "left", a.originX = -v * x, a.originY = -C;
                break;
              case "insideMiddleTop":
              case "insideMiddle":
              case "insideMiddleBottom":
              case "middle":
                a.x = E[0], a.y = E[1] + C, d = "center", a.originY = -C;
                break;
              case "insideEndTop":
              case "insideEnd":
              case "insideEndBottom":
                a.x = -v * x + c[0], a.y = c[1] + C, d = _[0] >= 0 ? "right" : "left", a.originX = v * x, a.originY = -C;
                break;
            }
            a.scaleX = a.scaleY = o, a.setStyle({ verticalAlign: a.__verticalAlign || A, align: a.__align || d });
          }
        }, t;
      }(Dt), jD = function() {
        function n(t) {
          this.group = new Dt(), this._LineCtor = t || VD;
        }
        return n.prototype.updateData = function(t) {
          var e = this;
          this._progressiveEls = null;
          var i = this, r = i.group, a = i._lineData;
          i._lineData = t, a || r.removeAll();
          var o = d7(t);
          t.diff(a).add(function(s) {
            e._doAdd(t, s, o);
          }).update(function(s, l) {
            e._doUpdate(a, t, l, s, o);
          }).remove(function(s) {
            r.remove(a.getItemGraphicEl(s));
          }).execute();
        }, n.prototype.updateLayout = function() {
          var t = this._lineData;
          t && t.eachItemGraphicEl(function(e, i) {
            e.updateLayout(t, i);
          }, this);
        }, n.prototype.incrementalPrepareUpdate = function(t) {
          this._seriesScope = d7(t), this._lineData = null, this.group.removeAll();
        }, n.prototype.incrementalUpdate = function(t, e) {
          this._progressiveEls = [];
          function i(s) {
            !s.isGroup && !TDt(s) && (s.incremental = true, s.ensureState("emphasis").hoverLayer = true);
          }
          for (var r = t.start; r < t.end; r++) {
            var a = e.getItemLayout(r);
            if (qD(a)) {
              var o = new this._LineCtor(e, r, this._seriesScope);
              o.traverse(i), this.group.add(o), e.setItemGraphicEl(r, o), this._progressiveEls.push(o);
            }
          }
        }, n.prototype.remove = function() {
          this.group.removeAll();
        }, n.prototype.eachRendered = function(t) {
          hu(this._progressiveEls || this.group, t);
        }, n.prototype._doAdd = function(t, e, i) {
          var r = t.getItemLayout(e);
          if (qD(r)) {
            var a = new this._LineCtor(t, e, i);
            t.setItemGraphicEl(e, a), this.group.add(a);
          }
        }, n.prototype._doUpdate = function(t, e, i, r, a) {
          var o = t.getItemGraphicEl(i);
          if (!qD(e.getItemLayout(r))) {
            this.group.remove(o);
            return;
          }
          o ? o.updateData(e, r, a) : o = new this._LineCtor(e, r, a), e.setItemGraphicEl(r, o), this.group.add(o);
        }, n;
      }();
      function TDt(n) {
        return n.animators && n.animators.length > 0;
      }
      function d7(n) {
        var t = n.hostModel, e = t.getModel("emphasis");
        return { lineStyle: t.getModel("lineStyle").getLineStyle(), emphasisLineStyle: e.getModel(["lineStyle"]).getLineStyle(), blurLineStyle: t.getModel(["blur", "lineStyle"]).getLineStyle(), selectLineStyle: t.getModel(["select", "lineStyle"]).getLineStyle(), emphasisDisabled: e.get("disabled"), blurScope: e.get("blurScope"), focus: e.get("focus"), labelStatesModels: Jn(t) };
      }
      function A7(n) {
        return isNaN(n[0]) || isNaN(n[1]);
      }
      function qD(n) {
        return n && !A7(n[0]) && !A7(n[1]);
      }
      var HD = [], YD = [], WD = [], Ed = fi, XD = mh, p7 = Math.abs;
      function v7(n, t, e) {
        for (var i = n[0], r = n[1], a = n[2], o = 1 / 0, s, l = e * e, u = 0.1, h = 0.1; h <= 0.9; h += 0.1) {
          HD[0] = Ed(i[0], r[0], a[0], h), HD[1] = Ed(i[1], r[1], a[1], h);
          var c = p7(XD(HD, t) - l);
          c < o && (o = c, s = h);
        }
        for (var f = 0; f < 32; f++) {
          var g = s + u;
          YD[0] = Ed(i[0], r[0], a[0], s), YD[1] = Ed(i[1], r[1], a[1], s), WD[0] = Ed(i[0], r[0], a[0], g), WD[1] = Ed(i[1], r[1], a[1], g);
          var c = XD(YD, t) - l;
          if (p7(c) < 0.01) break;
          var d = XD(WD, t) - l;
          u /= 2, c < 0 ? d >= 0 ? s = s + u : s = s - u : d >= 0 ? s = s - u : s = s + u;
        }
        return s;
      }
      function $D(n, t) {
        var e = [], i = Up, r = [[], [], []], a = [[], []], o = [];
        t /= 2, n.eachEdge(function(s, l) {
          var u = s.getLayout(), h = s.getVisual("fromSymbol"), c = s.getVisual("toSymbol");
          u.__original || (u.__original = [Os(u[0]), Os(u[1])], u[2] && u.__original.push(Os(u[2])));
          var f = u.__original;
          if (u[2] != null) {
            if (Wi(r[0], f[0]), Wi(r[1], f[2]), Wi(r[2], f[1]), h && h !== "none") {
              var g = yy(s.node1), d = v7(r, f[0], g * t);
              i(r[0][0], r[1][0], r[2][0], d, e), r[0][0] = e[3], r[1][0] = e[4], i(r[0][1], r[1][1], r[2][1], d, e), r[0][1] = e[3], r[1][1] = e[4];
            }
            if (c && c !== "none") {
              var g = yy(s.node2), d = v7(r, f[1], g * t);
              i(r[0][0], r[1][0], r[2][0], d, e), r[1][0] = e[1], r[2][0] = e[2], i(r[0][1], r[1][1], r[2][1], d, e), r[1][1] = e[1], r[2][1] = e[2];
            }
            Wi(u[0], r[0]), Wi(u[1], r[2]), Wi(u[2], r[1]);
          } else {
            if (Wi(a[0], f[0]), Wi(a[1], f[1]), yh(o, a[1], a[0]), wg(o, o), h && h !== "none") {
              var g = yy(s.node1);
              x2(a[0], a[0], o, g * t);
            }
            if (c && c !== "none") {
              var g = yy(s.node2);
              x2(a[1], a[1], o, -g * t);
            }
            Wi(u[0], a[0]), Wi(u[1], a[1]);
          }
        });
      }
      function y7(n) {
        return n.type === "view";
      }
      var BDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e, i) {
          var r = new Zv(), a = new jD(), o = this.group;
          this._controller = new ay(i.getZr()), this._controllerHost = { target: o }, o.add(r.group), o.add(a.group), this._symbolDraw = r, this._lineDraw = a, this._firstRender = true;
        }, t.prototype.render = function(e, i, r) {
          var a = this, o = e.coordinateSystem;
          this._model = e;
          var s = this._symbolDraw, l = this._lineDraw, u = this.group;
          if (y7(o)) {
            var h = { x: o.x, y: o.y, scaleX: o.scaleX, scaleY: o.scaleY };
            this._firstRender ? u.attr(h) : Ee(u, h, e);
          }
          $D(e.getGraph(), vy(e));
          var c = e.getData();
          s.updateData(c);
          var f = e.getEdgeData();
          l.updateData(f), this._updateNodeAndLinkScale(), this._updateController(e, i, r), clearTimeout(this._layoutTimeout);
          var g = e.forceLayout, d = e.get(["force", "layoutAnimation"]);
          g && this._startForceLayoutIteration(g, d);
          var A = e.get("layout");
          c.graph.eachNode(function(m) {
            var _ = m.dataIndex, I = m.getGraphicEl(), E = m.getModel();
            if (I) {
              I.off("drag").off("dragend");
              var x = E.get("draggable");
              x && I.on("drag", function(C) {
                switch (A) {
                  case "force":
                    g.warmUp(), !a._layouting && a._startForceLayoutIteration(g, d), g.setFixed(_), c.setItemLayout(_, [I.x, I.y]);
                    break;
                  case "circular":
                    c.setItemLayout(_, [I.x, I.y]), m.setLayout({ fixed: true }, true), OD(e, "symbolSize", m, [C.offsetX, C.offsetY]), a.updateLayout(e);
                    break;
                  case "none":
                  default:
                    c.setItemLayout(_, [I.x, I.y]), FD(e.getGraph(), e), a.updateLayout(e);
                    break;
                }
              }).on("dragend", function() {
                g && g.setUnfixed(_);
              }), I.setDraggable(x, !!E.get("cursor"));
              var w = E.get(["emphasis", "focus"]);
              w === "adjacency" && (Nt(I).focus = m.getAdjacentDataIndices());
            }
          }), c.graph.eachEdge(function(m) {
            var _ = m.getGraphicEl(), I = m.getModel().get(["emphasis", "focus"]);
            _ && I === "adjacency" && (Nt(_).focus = { edge: [m.dataIndex], node: [m.node1.dataIndex, m.node2.dataIndex] });
          });
          var p = e.get("layout") === "circular" && e.get(["circular", "rotateLabel"]), v = c.getLayout("cx"), y = c.getLayout("cy");
          c.graph.eachNode(function(m) {
            l7(m, p, v, y);
          }), this._firstRender = false;
        }, t.prototype.dispose = function() {
          this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null;
        }, t.prototype._startForceLayoutIteration = function(e, i) {
          var r = this;
          (function a() {
            e.step(function(o) {
              r.updateLayout(r._model), (r._layouting = !o) && (i ? r._layoutTimeout = setTimeout(a, 16) : a());
            });
          })();
        }, t.prototype._updateController = function(e, i, r) {
          var a = this, o = this._controller, s = this._controllerHost, l = this.group;
          if (o.setPointerChecker(function(u, h, c) {
            var f = l.getBoundingRect();
            return f.applyTransform(l.transform), f.contain(h, c) && !KE(u, r, e);
          }), !y7(e.coordinateSystem)) {
            o.disable();
            return;
          }
          o.enable(e.get("roam")), s.zoomLimit = e.get("scaleLimit"), s.zoom = e.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(u) {
            cD(s, u.dx, u.dy), r.dispatchAction({ seriesId: e.id, type: "graphRoam", dx: u.dx, dy: u.dy });
          }).on("zoom", function(u) {
            fD(s, u.scale, u.originX, u.originY), r.dispatchAction({ seriesId: e.id, type: "graphRoam", zoom: u.scale, originX: u.originX, originY: u.originY }), a._updateNodeAndLinkScale(), $D(e.getGraph(), vy(e)), a._lineDraw.updateLayout(), r.updateLabelLayout();
          });
        }, t.prototype._updateNodeAndLinkScale = function() {
          var e = this._model, i = e.getData(), r = vy(e);
          i.eachItemGraphicEl(function(a, o) {
            a && a.setSymbolScale(r);
          });
        }, t.prototype.updateLayout = function(e) {
          $D(e.getGraph(), vy(e)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
        }, t.prototype.remove = function() {
          clearTimeout(this._layoutTimeout), this._layouting = false, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
        }, t.type = "graph", t;
      }(qe);
      function Id(n) {
        return "_EC_" + n;
      }
      var MDt = function() {
        function n(t) {
          this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = t || false;
        }
        return n.prototype.isDirected = function() {
          return this._directed;
        }, n.prototype.addNode = function(t, e) {
          t = t == null ? "" + e : "" + t;
          var i = this._nodesMap;
          if (i[Id(t)]) {
            return;
          }
          var r = new Ec(t, e);
          return r.hostGraph = this, this.nodes.push(r), i[Id(t)] = r, r;
        }, n.prototype.getNodeByIndex = function(t) {
          var e = this.data.getRawIndex(t);
          return this.nodes[e];
        }, n.prototype.getNodeById = function(t) {
          return this._nodesMap[Id(t)];
        }, n.prototype.addEdge = function(t, e, i) {
          var r = this._nodesMap, a = this._edgesMap;
          if (ye(t) && (t = this.nodes[t]), ye(e) && (e = this.nodes[e]), t instanceof Ec || (t = r[Id(t)]), e instanceof Ec || (e = r[Id(e)]), !(!t || !e)) {
            var o = t.id + "-" + e.id, s = new m7(t, e, i);
            return s.hostGraph = this, this._directed && (t.outEdges.push(s), e.inEdges.push(s)), t.edges.push(s), t !== e && e.edges.push(s), this.edges.push(s), a[o] = s, s;
          }
        }, n.prototype.getEdgeByIndex = function(t) {
          var e = this.edgeData.getRawIndex(t);
          return this.edges[e];
        }, n.prototype.getEdge = function(t, e) {
          t instanceof Ec && (t = t.id), e instanceof Ec && (e = e.id);
          var i = this._edgesMap;
          return this._directed ? i[t + "-" + e] : i[t + "-" + e] || i[e + "-" + t];
        }, n.prototype.eachNode = function(t, e) {
          for (var i = this.nodes, r = i.length, a = 0; a < r; a++) i[a].dataIndex >= 0 && t.call(e, i[a], a);
        }, n.prototype.eachEdge = function(t, e) {
          for (var i = this.edges, r = i.length, a = 0; a < r; a++) i[a].dataIndex >= 0 && i[a].node1.dataIndex >= 0 && i[a].node2.dataIndex >= 0 && t.call(e, i[a], a);
        }, n.prototype.breadthFirstTraverse = function(t, e, i, r) {
          if (e instanceof Ec || (e = this._nodesMap[Id(e)]), !!e) {
            for (var a = i === "out" ? "outEdges" : i === "in" ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++) this.nodes[o].__visited = false;
            if (!t.call(r, e, null)) for (var s = [e]; s.length; ) for (var l = s.shift(), u = l[a], o = 0; o < u.length; o++) {
              var h = u[o], c = h.node1 === l ? h.node2 : h.node1;
              if (!c.__visited) {
                if (t.call(r, c, l)) return;
                s.push(c), c.__visited = true;
              }
            }
          }
        }, n.prototype.update = function() {
          for (var t = this.data, e = this.edgeData, i = this.nodes, r = this.edges, a = 0, o = i.length; a < o; a++) i[a].dataIndex = -1;
          for (var a = 0, o = t.count(); a < o; a++) i[t.getRawIndex(a)].dataIndex = a;
          e.filterSelf(function(s) {
            var l = r[e.getRawIndex(s)];
            return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
          });
          for (var a = 0, o = r.length; a < o; a++) r[a].dataIndex = -1;
          for (var a = 0, o = e.count(); a < o; a++) r[e.getRawIndex(a)].dataIndex = a;
        }, n.prototype.clone = function() {
          for (var t = new n(this._directed), e = this.nodes, i = this.edges, r = 0; r < e.length; r++) t.addNode(e[r].id, e[r].dataIndex);
          for (var r = 0; r < i.length; r++) {
            var a = i[r];
            t.addEdge(a.node1.id, a.node2.id, a.dataIndex);
          }
          return t;
        }, n;
      }(), Ec = function() {
        function n(t, e) {
          this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = t == null ? "" : t, this.dataIndex = e == null ? -1 : e;
        }
        return n.prototype.degree = function() {
          return this.edges.length;
        }, n.prototype.inDegree = function() {
          return this.inEdges.length;
        }, n.prototype.outDegree = function() {
          return this.outEdges.length;
        }, n.prototype.getModel = function(t) {
          if (!(this.dataIndex < 0)) {
            var e = this.hostGraph, i = e.data.getItemModel(this.dataIndex);
            return i.getModel(t);
          }
        }, n.prototype.getAdjacentDataIndices = function() {
          for (var t = { edge: [], node: [] }, e = 0; e < this.edges.length; e++) {
            var i = this.edges[e];
            i.dataIndex < 0 || (t.edge.push(i.dataIndex), t.node.push(i.node1.dataIndex, i.node2.dataIndex));
          }
          return t;
        }, n.prototype.getTrajectoryDataIndices = function() {
          for (var t = dt(), e = dt(), i = 0; i < this.edges.length; i++) {
            var r = this.edges[i];
            if (!(r.dataIndex < 0)) {
              t.set(r.dataIndex, true);
              for (var a = [r.node1], o = [r.node2], s = 0; s < a.length; ) {
                var l = a[s];
                s++, e.set(l.dataIndex, true);
                for (var u = 0; u < l.inEdges.length; u++) t.set(l.inEdges[u].dataIndex, true), a.push(l.inEdges[u].node1);
              }
              for (s = 0; s < o.length; ) {
                var h = o[s];
                s++, e.set(h.dataIndex, true);
                for (var u = 0; u < h.outEdges.length; u++) t.set(h.outEdges[u].dataIndex, true), o.push(h.outEdges[u].node2);
              }
            }
          }
          return { edge: t.keys(), node: e.keys() };
        }, n;
      }(), m7 = function() {
        function n(t, e, i) {
          this.dataIndex = -1, this.node1 = t, this.node2 = e, this.dataIndex = i == null ? -1 : i;
        }
        return n.prototype.getModel = function(t) {
          if (!(this.dataIndex < 0)) {
            var e = this.hostGraph, i = e.edgeData.getItemModel(this.dataIndex);
            return i.getModel(t);
          }
        }, n.prototype.getAdjacentDataIndices = function() {
          return { edge: [this.dataIndex], node: [this.node1.dataIndex, this.node2.dataIndex] };
        }, n.prototype.getTrajectoryDataIndices = function() {
          var t = dt(), e = dt();
          t.set(this.dataIndex, true);
          for (var i = [this.node1], r = [this.node2], a = 0; a < i.length; ) {
            var o = i[a];
            a++, e.set(o.dataIndex, true);
            for (var s = 0; s < o.inEdges.length; s++) t.set(o.inEdges[s].dataIndex, true), i.push(o.inEdges[s].node1);
          }
          for (a = 0; a < r.length; ) {
            var l = r[a];
            a++, e.set(l.dataIndex, true);
            for (var s = 0; s < l.outEdges.length; s++) t.set(l.outEdges[s].dataIndex, true), r.push(l.outEdges[s].node2);
          }
          return { edge: t.keys(), node: e.keys() };
        }, n;
      }();
      function _7(n, t) {
        return { getValue: function(e) {
          var i = this[n][t];
          return i.getStore().get(i.getDimensionIndex(e || "value"), this.dataIndex);
        }, setVisual: function(e, i) {
          this.dataIndex >= 0 && this[n][t].setItemVisual(this.dataIndex, e, i);
        }, getVisual: function(e) {
          return this[n][t].getItemVisual(this.dataIndex, e);
        }, setLayout: function(e, i) {
          this.dataIndex >= 0 && this[n][t].setItemLayout(this.dataIndex, e, i);
        }, getLayout: function() {
          return this[n][t].getItemLayout(this.dataIndex);
        }, getGraphicEl: function() {
          return this[n][t].getItemGraphicEl(this.dataIndex);
        }, getRawIndex: function() {
          return this[n][t].getRawIndex(this.dataIndex);
        } };
      }
      kn(Ec, _7("hostGraph", "data")), kn(m7, _7("hostGraph", "edgeData"));
      function E7(n, t, e, i, r) {
        for (var a = new MDt(i), o = 0; o < n.length; o++) a.addNode(On(n[o].id, n[o].name, o), o);
        for (var s = [], l = [], u = 0, o = 0; o < t.length; o++) {
          var h = t[o], c = h.source, f = h.target;
          a.addEdge(c, f, u) && (l.push(h), s.push(On(Hn(h.id, null), c + " > " + f)), u++);
        }
        var g = e.get("coordinateSystem"), d;
        if (g === "cartesian2d" || g === "polar") d = tl(n, e);
        else {
          var A = ed.get(g), p = A ? A.dimensions || [] : [];
          $t(p, "value") < 0 && p.concat(["value"]);
          var v = Uv(n, { coordDimensions: p, encodeDefine: e.getEncode() }).dimensions;
          d = new er(v, e), d.initData(n);
        }
        var y = new er(["value"], e);
        return y.initData(l, s), r && r(d, y), Nq({ mainData: d, struct: a, structAttr: "graph", datas: { node: d, edge: y }, datasAttr: { node: "data", edge: "edgeData" } }), a.update(), a;
      }
      var DDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.hasSymbolVisual = true, e;
        }
        return t.prototype.init = function(e) {
          n.prototype.init.apply(this, arguments);
          var i = this;
          function r() {
            return i._categoriesData;
          }
          this.legendVisualProvider = new ny(r, r), this.fillDataTextStyle(e.edges || e.links), this._updateCategoriesData();
        }, t.prototype.mergeOption = function(e) {
          n.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(e.edges || e.links), this._updateCategoriesData();
        }, t.prototype.mergeDefaultAndTheme = function(e) {
          n.prototype.mergeDefaultAndTheme.apply(this, arguments), Th(e, "edgeLabel", ["show"]);
        }, t.prototype.getInitialData = function(e, i) {
          var r = e.edges || e.links || [], a = e.data || e.nodes || [], o = this;
          if (a && r) {
            vDt(this);
            var s = E7(a, r, this, true, l);
            return D(s.edges, function(u) {
              yDt(u.node1, u.node2, this, u.dataIndex);
            }, this), s.data;
          }
          function l(u, h) {
            u.wrapMethod("getItemModel", function(d) {
              var A = o._categoriesModels, p = d.getShallow("category"), v = A[p];
              return v && (v.parentModel = d.parentModel, d.parentModel = v), d;
            });
            var c = De.prototype.getModel;
            function f(d, A) {
              var p = c.call(this, d, A);
              return p.resolveParentPath = g, p;
            }
            h.wrapMethod("getItemModel", function(d) {
              return d.resolveParentPath = g, d.getModel = f, d;
            });
            function g(d) {
              if (d && (d[0] === "label" || d[1] === "label")) {
                var A = d.slice();
                return d[0] === "label" ? A[0] = "edgeLabel" : d[1] === "label" && (A[1] = "edgeLabel"), A;
              }
              return d;
            }
          }
        }, t.prototype.getGraph = function() {
          return this.getData().graph;
        }, t.prototype.getEdgeData = function() {
          return this.getGraph().edgeData;
        }, t.prototype.getCategoriesData = function() {
          return this._categoriesData;
        }, t.prototype.formatTooltip = function(e, i, r) {
          if (r === "edge") {
            var a = this.getData(), o = this.getDataParams(e, r), s = a.graph.getEdgeByIndex(e), l = a.getName(s.node1.dataIndex), u = a.getName(s.node2.dataIndex), h = [];
            return l != null && h.push(l), u != null && h.push(u), ti("nameValue", { name: h.join(" > "), value: o.value, noValue: o.value == null });
          }
          var c = cU({ series: this, dataIndex: e, multipleSeries: i });
          return c;
        }, t.prototype._updateCategoriesData = function() {
          var e = K(this.option.categories || [], function(r) {
            return r.value != null ? r : X({ value: 0 }, r);
          }), i = new er(["value"], this);
          i.initData(e), this._categoriesData = i, this._categoriesModels = i.mapArray(function(r) {
            return i.getItemModel(r);
          });
        }, t.prototype.setZoom = function(e) {
          this.option.zoom = e;
        }, t.prototype.setCenter = function(e) {
          this.option.center = e;
        }, t.prototype.isAnimationEnabled = function() {
          return n.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
        }, t.type = "series.graph", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], t.defaultOption = { z: 2, coordinateSystem: "view", legendHoverLink: true, layout: null, circular: { rotateLabel: false }, force: { initLayout: null, repulsion: [0, 50], gravity: 0.1, friction: 0.6, edgeLength: 30, layoutAnimation: true }, left: "center", top: "center", symbol: "circle", symbolSize: 10, edgeSymbol: ["none", "none"], edgeSymbolSize: 10, edgeLabel: { position: "middle", distance: 5 }, draggable: false, roam: false, center: null, zoom: 1, nodeScaleRatio: 0.6, label: { show: false, formatter: "{b}" }, itemStyle: {}, lineStyle: { color: "#aaa", width: 1, opacity: 0.5 }, emphasis: { scale: true, label: { show: true } }, select: { itemStyle: { borderColor: "#212121" } } }, t;
      }(tn), RDt = { type: "graphRoam", event: "graphRoam", update: "none" };
      function LDt(n) {
        n.registerChartView(BDt), n.registerSeriesModel(DDt), n.registerProcessor(fDt), n.registerVisual(gDt), n.registerVisual(dDt), n.registerLayout(mDt), n.registerLayout(n.PRIORITY.VISUAL.POST_CHART_LAYOUT, EDt), n.registerLayout(xDt), n.registerCoordinateSystem("graphView", { dimensions: sy.dimensions, create: CDt }), n.registerAction({ type: "focusNodeAdjacency", event: "focusNodeAdjacency", update: "series:focusNodeAdjacency" }, bn), n.registerAction({ type: "unfocusNodeAdjacency", event: "unfocusNodeAdjacency", update: "series:unfocusNodeAdjacency" }, bn), n.registerAction(RDt, function(t, e, i) {
          e.eachComponent({ mainType: "series", query: t }, function(r) {
            var a = r.coordinateSystem, o = yD(a, t, void 0, i);
            r.setCenter && r.setCenter(o.center), r.setZoom && r.setZoom(o.zoom);
          });
        });
      }
      var PDt = /* @__PURE__ */ function() {
        function n() {
          this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
        }
        return n;
      }(), NDt = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "pointer", i;
        }
        return t.prototype.getDefaultShape = function() {
          return new PDt();
        }, t.prototype.buildPath = function(e, i) {
          var r = Math.cos, a = Math.sin, o = i.r, s = i.width, l = i.angle, u = i.x - r(l) * s * (s >= o / 3 ? 1 : 2), h = i.y - a(l) * s * (s >= o / 3 ? 1 : 2);
          l = i.angle - Math.PI / 2, e.moveTo(u, h), e.lineTo(i.x + r(l) * s, i.y + a(l) * s), e.lineTo(i.x + r(i.angle) * o, i.y + a(i.angle) * o), e.lineTo(i.x - r(l) * s, i.y - a(l) * s), e.lineTo(u, h);
        }, t;
      }(ne);
      function FDt(n, t) {
        var e = n.get("center"), i = t.getWidth(), r = t.getHeight(), a = Math.min(i, r), o = st(e[0], t.getWidth()), s = st(e[1], t.getHeight()), l = st(n.get("radius"), a / 2);
        return { cx: o, cy: s, r: l };
      }
      function cI(n, t) {
        var e = n == null ? "" : n + "";
        return t && (ht(t) ? e = t.replace("{value}", e) : yt(t) && (e = t(n))), e;
      }
      var kDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          this.group.removeAll();
          var a = e.get(["axisLine", "lineStyle", "color"]), o = FDt(e, r);
          this._renderMain(e, i, r, a, o), this._data = e.getData();
        }, t.prototype.dispose = function() {
        }, t.prototype._renderMain = function(e, i, r, a, o) {
          var s = this.group, l = e.get("clockwise"), u = -e.get("startAngle") / 180 * Math.PI, h = -e.get("endAngle") / 180 * Math.PI, c = e.getModel("axisLine"), f = c.get("roundCap"), g = f ? qE : Zi, d = c.get("show"), A = c.getModel("lineStyle"), p = A.get("width"), v = [u, h];
          QT(v, !l), u = v[0], h = v[1];
          for (var y = h - u, m = u, _ = [], I = 0; d && I < a.length; I++) {
            var E = Math.min(Math.max(a[I][0], 0), 1);
            h = u + y * E;
            var x = new g({ shape: { startAngle: m, endAngle: h, cx: o.cx, cy: o.cy, clockwise: l, r0: o.r - p, r: o.r }, silent: true });
            x.setStyle({ fill: a[I][1] }), x.setStyle(A.getLineStyle(["color", "width"])), _.push(x), m = h;
          }
          _.reverse(), D(_, function(C) {
            return s.add(C);
          });
          var w = function(C) {
            if (C <= 0) return a[0][1];
            var S;
            for (S = 0; S < a.length; S++) if (a[S][0] >= C && (S === 0 ? 0 : a[S - 1][0]) < C) return a[S][1];
            return a[S - 1][1];
          };
          this._renderTicks(e, i, r, w, o, u, h, l, p), this._renderTitleAndDetail(e, i, r, w, o), this._renderAnchor(e, o), this._renderPointer(e, i, r, w, o, u, h, l, p);
        }, t.prototype._renderTicks = function(e, i, r, a, o, s, l, u, h) {
          for (var c = this.group, f = o.cx, g = o.cy, d = o.r, A = +e.get("min"), p = +e.get("max"), v = e.getModel("splitLine"), y = e.getModel("axisTick"), m = e.getModel("axisLabel"), _ = e.get("splitNumber"), I = y.get("splitNumber"), E = st(v.get("length"), d), x = st(y.get("length"), d), w = s, C = (l - s) / _, S = C / I, b = v.getModel("lineStyle").getLineStyle(), T = y.getModel("lineStyle").getLineStyle(), B = v.get("distance"), R, M, L = 0; L <= _; L++) {
            if (R = Math.cos(w), M = Math.sin(w), v.get("show")) {
              var N = B ? B + h : h, F = new Kn({ shape: { x1: R * (d - N) + f, y1: M * (d - N) + g, x2: R * (d - E - N) + f, y2: M * (d - E - N) + g }, style: b, silent: true });
              b.stroke === "auto" && F.setStyle({ stroke: a(L / _) }), c.add(F);
            }
            if (m.get("show")) {
              var N = m.get("distance") + B, k = cI(En(L / _ * (p - A) + A), m.get("formatter")), O = a(L / _), Q = R * (d - E - N) + f, j = M * (d - E - N) + g, Y = m.get("rotate"), G = 0;
              Y === "radial" ? (G = -w + 2 * Math.PI, G > Math.PI / 2 && (G += Math.PI)) : Y === "tangential" ? G = -w - Math.PI / 2 : ye(Y) && (G = Y * Math.PI / 180), G === 0 ? c.add(new Ae({ style: Je(m, { text: k, x: Q, y: j, verticalAlign: M < -0.8 ? "top" : M > 0.8 ? "bottom" : "middle", align: R < -0.4 ? "left" : R > 0.4 ? "right" : "center" }, { inheritColor: O }), silent: true })) : c.add(new Ae({ style: Je(m, { text: k, x: Q, y: j, verticalAlign: "middle", align: "center" }, { inheritColor: O }), silent: true, originX: Q, originY: j, rotation: G }));
            }
            if (y.get("show") && L !== _) {
              var N = y.get("distance");
              N = N ? N + h : h;
              for (var $ = 0; $ <= I; $++) {
                R = Math.cos(w), M = Math.sin(w);
                var J = new Kn({ shape: { x1: R * (d - N) + f, y1: M * (d - N) + g, x2: R * (d - x - N) + f, y2: M * (d - x - N) + g }, silent: true, style: T });
                T.stroke === "auto" && J.setStyle({ stroke: a((L + $ / I) / _) }), c.add(J), w += S;
              }
              w -= S;
            } else w += C;
          }
        }, t.prototype._renderPointer = function(e, i, r, a, o, s, l, u, h) {
          var c = this.group, f = this._data, g = this._progressEls, d = [], A = e.get(["pointer", "show"]), p = e.getModel("progress"), v = p.get("show"), y = e.getData(), m = y.mapDimension("value"), _ = +e.get("min"), I = +e.get("max"), E = [_, I], x = [s, l];
          function w(S, b) {
            var T = y.getItemModel(S), B = T.getModel("pointer"), R = st(B.get("width"), o.r), M = st(B.get("length"), o.r), L = e.get(["pointer", "icon"]), N = B.get("offsetCenter"), F = st(N[0], o.r), k = st(N[1], o.r), O = B.get("keepAspect"), Q;
            return L ? Q = Un(L, F - R / 2, k - M, R, M, null, O) : Q = new NDt({ shape: { angle: -Math.PI / 2, width: R, r: M, x: F, y: k } }), Q.rotation = -(b + Math.PI / 2), Q.x = o.cx, Q.y = o.cy, Q;
          }
          function C(S, b) {
            var T = p.get("roundCap"), B = T ? qE : Zi, R = p.get("overlap"), M = R ? p.get("width") : h / y.count(), L = R ? o.r - M : o.r - (S + 1) * M, N = R ? o.r : o.r - S * M, F = new B({ shape: { startAngle: s, endAngle: b, cx: o.cx, cy: o.cy, clockwise: u, r0: L, r: N } });
            return R && (F.z2 = I - y.get(m, S) % I), F;
          }
          (v || A) && (y.diff(f).add(function(S) {
            var b = y.get(m, S);
            if (A) {
              var T = w(S, s);
              on(T, { rotation: -((isNaN(+b) ? x[0] : Ne(b, E, x, true)) + Math.PI / 2) }, e), c.add(T), y.setItemGraphicEl(S, T);
            }
            if (v) {
              var B = C(S, s), R = p.get("clip");
              on(B, { shape: { endAngle: Ne(b, E, x, R) } }, e), c.add(B), UT(e.seriesIndex, y.dataType, S, B), d[S] = B;
            }
          }).update(function(S, b) {
            var T = y.get(m, S);
            if (A) {
              var B = f.getItemGraphicEl(b), R = B ? B.rotation : s, M = w(S, R);
              M.rotation = R, Ee(M, { rotation: -((isNaN(+T) ? x[0] : Ne(T, E, x, true)) + Math.PI / 2) }, e), c.add(M), y.setItemGraphicEl(S, M);
            }
            if (v) {
              var L = g[b], N = L ? L.shape.endAngle : s, F = C(S, N), k = p.get("clip");
              Ee(F, { shape: { endAngle: Ne(T, E, x, k) } }, e), c.add(F), UT(e.seriesIndex, y.dataType, S, F), d[S] = F;
            }
          }).execute(), y.each(function(S) {
            var b = y.getItemModel(S), T = b.getModel("emphasis"), B = T.get("focus"), R = T.get("blurScope"), M = T.get("disabled");
            if (A) {
              var L = y.getItemGraphicEl(S), N = y.getItemVisual(S, "style"), F = N.fill;
              if (L instanceof gi) {
                var k = L.style;
                L.useStyle(X({ image: k.image, x: k.x, y: k.y, width: k.width, height: k.height }, N));
              } else L.useStyle(N), L.type !== "pointer" && L.setColor(F);
              L.setStyle(b.getModel(["pointer", "itemStyle"]).getItemStyle()), L.style.fill === "auto" && L.setStyle("fill", a(Ne(y.get(m, S), E, [0, 1], true))), L.z2EmphasisLift = 0, Ii(L, b), pn(L, B, R, M);
            }
            if (v) {
              var O = d[S];
              O.useStyle(y.getItemVisual(S, "style")), O.setStyle(b.getModel(["progress", "itemStyle"]).getItemStyle()), O.z2EmphasisLift = 0, Ii(O, b), pn(O, B, R, M);
            }
          }), this._progressEls = d);
        }, t.prototype._renderAnchor = function(e, i) {
          var r = e.getModel("anchor"), a = r.get("show");
          if (a) {
            var o = r.get("size"), s = r.get("icon"), l = r.get("offsetCenter"), u = r.get("keepAspect"), h = Un(s, i.cx - o / 2 + st(l[0], i.r), i.cy - o / 2 + st(l[1], i.r), o, o, null, u);
            h.z2 = r.get("showAbove") ? 1 : 0, h.setStyle(r.getModel("itemStyle").getItemStyle()), this.group.add(h);
          }
        }, t.prototype._renderTitleAndDetail = function(e, i, r, a, o) {
          var s = this, l = e.getData(), u = l.mapDimension("value"), h = +e.get("min"), c = +e.get("max"), f = new Dt(), g = [], d = [], A = e.isAnimationEnabled(), p = e.get(["pointer", "showAbove"]);
          l.diff(this._data).add(function(v) {
            g[v] = new Ae({ silent: true }), d[v] = new Ae({ silent: true });
          }).update(function(v, y) {
            g[v] = s._titleEls[y], d[v] = s._detailEls[y];
          }).execute(), l.each(function(v) {
            var y = l.getItemModel(v), m = l.get(u, v), _ = new Dt(), I = a(Ne(m, [h, c], [0, 1], true)), E = y.getModel("title");
            if (E.get("show")) {
              var x = E.get("offsetCenter"), w = o.cx + st(x[0], o.r), C = o.cy + st(x[1], o.r), S = g[v];
              S.attr({ z2: p ? 0 : 2, style: Je(E, { x: w, y: C, text: l.getName(v), align: "center", verticalAlign: "middle" }, { inheritColor: I }) }), _.add(S);
            }
            var b = y.getModel("detail");
            if (b.get("show")) {
              var T = b.get("offsetCenter"), B = o.cx + st(T[0], o.r), R = o.cy + st(T[1], o.r), M = st(b.get("width"), o.r), L = st(b.get("height"), o.r), N = e.get(["progress", "show"]) ? l.getItemVisual(v, "style").fill : I, S = d[v], F = b.get("formatter");
              S.attr({ z2: p ? 0 : 2, style: Je(b, { x: B, y: R, text: cI(m, F), width: isNaN(M) ? null : M, height: isNaN(L) ? null : L, align: "center", verticalAlign: "middle" }, { inheritColor: N }) }), U8(S, { normal: b }, m, function(O) {
                return cI(O, F);
              }), A && V8(S, v, l, e, { getFormattedLabel: function(O, Q, j, Y, G, $) {
                return cI($ ? $.interpolatedValue : m, F);
              } }), _.add(S);
            }
            f.add(_);
          }), this.group.add(f), this._titleEls = g, this._detailEls = d;
        }, t.type = "gauge", t;
      }(qe), ODt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.visualStyleAccessPath = "itemStyle", e;
        }
        return t.prototype.getInitialData = function(e, i) {
          return vd(this, ["value"]);
        }, t.type = "series.gauge", t.defaultOption = { z: 2, colorBy: "data", center: ["50%", "50%"], legendHoverLink: true, radius: "75%", startAngle: 225, endAngle: -45, clockwise: true, min: 0, max: 100, splitNumber: 10, axisLine: { show: true, roundCap: false, lineStyle: { color: [[1, "#E6EBF8"]], width: 10 } }, progress: { show: false, overlap: true, width: 10, roundCap: false, clip: true }, splitLine: { show: true, length: 10, distance: 10, lineStyle: { color: "#63677A", width: 3, type: "solid" } }, axisTick: { show: true, splitNumber: 5, length: 6, distance: 10, lineStyle: { color: "#63677A", width: 1, type: "solid" } }, axisLabel: { show: true, distance: 15, color: "#464646", fontSize: 12, rotate: 0 }, pointer: { icon: null, offsetCenter: [0, 0], show: true, showAbove: true, length: "60%", width: 6, keepAspect: false }, anchor: { show: false, showAbove: false, size: 6, icon: "circle", offsetCenter: [0, 0], keepAspect: false, itemStyle: { color: "#fff", borderWidth: 0, borderColor: "#5470c6" } }, title: { show: true, offsetCenter: [0, "20%"], color: "#464646", fontSize: 16, valueAnimation: false }, detail: { show: true, backgroundColor: "rgba(0,0,0,0)", borderWidth: 0, borderColor: "#ccc", width: 100, height: null, padding: [5, 10], offsetCenter: [0, "40%"], color: "#464646", fontSize: 30, fontWeight: "bold", lineHeight: 30, valueAnimation: false } }, t;
      }(tn);
      function QDt(n) {
        n.registerChartView(kDt), n.registerSeriesModel(ODt);
      }
      var zDt = ["itemStyle", "opacity"], GDt = function(n) {
        V(t, n);
        function t(e, i) {
          var r = n.call(this) || this, a = r, o = new Ji(), s = new Ae();
          return a.setTextContent(s), r.setTextGuideLine(o), r.updateData(e, i, true), r;
        }
        return t.prototype.updateData = function(e, i, r) {
          var a = this, o = e.hostModel, s = e.getItemModel(i), l = e.getItemLayout(i), u = s.getModel("emphasis"), h = s.get(zDt);
          h = h == null ? 1 : h, r || to(a), a.useStyle(e.getItemVisual(i, "style")), a.style.lineJoin = "round", r ? (a.setShape({ points: l.points }), a.style.opacity = 0, on(a, { style: { opacity: h } }, o, i)) : Ee(a, { style: { opacity: h }, shape: { points: l.points } }, o, i), Ii(a, s), this._updateLabel(e, i), pn(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
        }, t.prototype._updateLabel = function(e, i) {
          var r = this, a = this.getTextGuideLine(), o = r.getTextContent(), s = e.hostModel, l = e.getItemModel(i), u = e.getItemLayout(i), h = u.label, c = e.getItemVisual(i, "style"), f = c.fill;
          xi(o, Jn(l), { labelFetcher: e.hostModel, labelDataIndex: i, defaultOpacity: c.opacity, defaultText: e.getName(i) }, { normal: { align: h.textAlign, verticalAlign: h.verticalAlign } }), r.setTextConfig({ local: true, inside: !!h.inside, insideStroke: f, outsideFill: f });
          var g = h.linePoints;
          a.setShape({ points: g }), r.textGuideLineConfig = { anchor: g ? new jt(g[0][0], g[0][1]) : null }, Ee(o, { style: { x: h.x, y: h.y } }, s, i), o.attr({ rotation: h.rotation, originX: h.x, originY: h.y, z2: 10 }), BM(r, MM(l), { stroke: f });
        }, t;
      }(Ki), UDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.ignoreLabelLineUpdate = true, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = e.getData(), o = this._data, s = this.group;
          a.diff(o).add(function(l) {
            var u = new GDt(a, l);
            a.setItemGraphicEl(l, u), s.add(u);
          }).update(function(l, u) {
            var h = o.getItemGraphicEl(u);
            h.updateData(a, l), s.add(h), a.setItemGraphicEl(l, h);
          }).remove(function(l) {
            var u = o.getItemGraphicEl(l);
            Av(u, e, l);
          }).execute(), this._data = a;
        }, t.prototype.remove = function() {
          this.group.removeAll(), this._data = null;
        }, t.prototype.dispose = function() {
        }, t.type = "funnel", t;
      }(qe), VDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e) {
          n.prototype.init.apply(this, arguments), this.legendVisualProvider = new ny(ct(this.getData, this), ct(this.getRawData, this)), this._defaultLabelLine(e);
        }, t.prototype.getInitialData = function(e, i) {
          return vd(this, { coordDimensions: ["value"], encodeDefaulter: Gt(xB, this) });
        }, t.prototype._defaultLabelLine = function(e) {
          Th(e, "labelLine", ["show"]);
          var i = e.labelLine, r = e.emphasis.labelLine;
          i.show = i.show && e.label.show, r.show = r.show && e.emphasis.label.show;
        }, t.prototype.getDataParams = function(e) {
          var i = this.getData(), r = n.prototype.getDataParams.call(this, e), a = i.mapDimension("value"), o = i.getSum(a);
          return r.percent = o ? +(i.get(a, e) / o * 100).toFixed(2) : 0, r.$vars.push("percent"), r;
        }, t.type = "series.funnel", t.defaultOption = { z: 2, legendHoverLink: true, colorBy: "data", left: 80, top: 60, right: 80, bottom: 60, minSize: "0%", maxSize: "100%", sort: "descending", orient: "vertical", gap: 0, funnelAlign: "center", label: { show: true, position: "outer" }, labelLine: { show: true, length: 20, lineStyle: { width: 1 } }, itemStyle: { borderColor: "#fff", borderWidth: 1 }, emphasis: { label: { show: true } }, select: { itemStyle: { borderColor: "#212121" } } }, t;
      }(tn);
      function jDt(n, t) {
        return Yn(n.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() });
      }
      function qDt(n, t) {
        for (var e = n.mapDimension("value"), i = n.mapArray(e, function(l) {
          return l;
        }), r = [], a = t === "ascending", o = 0, s = n.count(); o < s; o++) r[o] = o;
        return yt(t) ? r.sort(t) : t !== "none" && r.sort(function(l, u) {
          return a ? i[l] - i[u] : i[u] - i[l];
        }), r;
      }
      function HDt(n) {
        var t = n.hostModel, e = t.get("orient");
        n.each(function(i) {
          var r = n.getItemModel(i), a = r.getModel("label"), o = a.get("position"), s = r.getModel("labelLine"), l = n.getItemLayout(i), u = l.points, h = o === "inner" || o === "inside" || o === "center" || o === "insideLeft" || o === "insideRight", c, f, g, d;
          if (h) o === "insideLeft" ? (f = (u[0][0] + u[3][0]) / 2 + 5, g = (u[0][1] + u[3][1]) / 2, c = "left") : o === "insideRight" ? (f = (u[1][0] + u[2][0]) / 2 - 5, g = (u[1][1] + u[2][1]) / 2, c = "right") : (f = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, g = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, c = "center"), d = [[f, g], [f, g]];
          else {
            var A = void 0, p = void 0, v = void 0, y = void 0, m = s.get("length");
            e === "vertical" && ["top", "bottom"].indexOf(o) > -1 && (o = "left"), e === "horizontal" && ["left", "right"].indexOf(o) > -1 && (o = "bottom"), o === "left" ? (A = (u[3][0] + u[0][0]) / 2, p = (u[3][1] + u[0][1]) / 2, v = A - m, f = v - 5, c = "right") : o === "right" ? (A = (u[1][0] + u[2][0]) / 2, p = (u[1][1] + u[2][1]) / 2, v = A + m, f = v + 5, c = "left") : o === "top" ? (A = (u[3][0] + u[0][0]) / 2, p = (u[3][1] + u[0][1]) / 2, y = p - m, g = y - 5, c = "center") : o === "bottom" ? (A = (u[1][0] + u[2][0]) / 2, p = (u[1][1] + u[2][1]) / 2, y = p + m, g = y + 5, c = "center") : o === "rightTop" ? (A = e === "horizontal" ? u[3][0] : u[1][0], p = e === "horizontal" ? u[3][1] : u[1][1], e === "horizontal" ? (y = p - m, g = y - 5, c = "center") : (v = A + m, f = v + 5, c = "top")) : o === "rightBottom" ? (A = u[2][0], p = u[2][1], e === "horizontal" ? (y = p + m, g = y + 5, c = "center") : (v = A + m, f = v + 5, c = "bottom")) : o === "leftTop" ? (A = u[0][0], p = e === "horizontal" ? u[0][1] : u[1][1], e === "horizontal" ? (y = p - m, g = y - 5, c = "center") : (v = A - m, f = v - 5, c = "right")) : o === "leftBottom" ? (A = e === "horizontal" ? u[1][0] : u[3][0], p = e === "horizontal" ? u[1][1] : u[2][1], e === "horizontal" ? (y = p + m, g = y + 5, c = "center") : (v = A - m, f = v - 5, c = "right")) : (A = (u[1][0] + u[2][0]) / 2, p = (u[1][1] + u[2][1]) / 2, e === "horizontal" ? (y = p + m, g = y + 5, c = "center") : (v = A + m, f = v + 5, c = "left")), e === "horizontal" ? (v = A, f = v) : (y = p, g = y), d = [[A, p], [v, y]];
          }
          l.label = { linePoints: d, x: f, y: g, verticalAlign: "middle", textAlign: c, inside: h };
        });
      }
      function YDt(n, t) {
        n.eachSeriesByType("funnel", function(e) {
          var i = e.getData(), r = i.mapDimension("value"), a = e.get("sort"), o = jDt(e, t), s = e.get("orient"), l = o.width, u = o.height, h = qDt(i, a), c = o.x, f = o.y, g = s === "horizontal" ? [st(e.get("minSize"), u), st(e.get("maxSize"), u)] : [st(e.get("minSize"), l), st(e.get("maxSize"), l)], d = i.getDataExtent(r), A = e.get("min"), p = e.get("max");
          A == null && (A = Math.min(d[0], 0)), p == null && (p = d[1]);
          var v = e.get("funnelAlign"), y = e.get("gap"), m = s === "horizontal" ? l : u, _ = (m - y * (i.count() - 1)) / i.count(), I = function(R, M) {
            if (s === "horizontal") {
              var L = i.get(r, R) || 0, N = Ne(L, [A, p], g, true), F = void 0;
              switch (v) {
                case "top":
                  F = f;
                  break;
                case "center":
                  F = f + (u - N) / 2;
                  break;
                case "bottom":
                  F = f + (u - N);
                  break;
              }
              return [[M, F], [M, F + N]];
            }
            var k = i.get(r, R) || 0, O = Ne(k, [A, p], g, true), Q;
            switch (v) {
              case "left":
                Q = c;
                break;
              case "center":
                Q = c + (l - O) / 2;
                break;
              case "right":
                Q = c + l - O;
                break;
            }
            return [[Q, M], [Q + O, M]];
          };
          a === "ascending" && (_ = -_, y = -y, s === "horizontal" ? c += l : f += u, h = h.reverse());
          for (var E = 0; E < h.length; E++) {
            var x = h[E], w = h[E + 1], C = i.getItemModel(x);
            if (s === "horizontal") {
              var S = C.get(["itemStyle", "width"]);
              S == null ? S = _ : (S = st(S, l), a === "ascending" && (S = -S));
              var b = I(x, c), T = I(w, c + S);
              c += S + y, i.setItemLayout(x, { points: b.concat(T.slice().reverse()) });
            } else {
              var B = C.get(["itemStyle", "height"]);
              B == null ? B = _ : (B = st(B, u), a === "ascending" && (B = -B));
              var b = I(x, f), T = I(w, f + B);
              f += B + y, i.setItemLayout(x, { points: b.concat(T.slice().reverse()) });
            }
          }
          HDt(i);
        });
      }
      function WDt(n) {
        n.registerChartView(UDt), n.registerSeriesModel(VDt), n.registerLayout(YDt), n.registerProcessor(ey("funnel"));
      }
      var XDt = 0.3, $Dt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._dataGroup = new Dt(), e._initialized = false, e;
        }
        return t.prototype.init = function() {
          this.group.add(this._dataGroup);
        }, t.prototype.render = function(e, i, r, a) {
          this._progressiveEls = null;
          var o = this._dataGroup, s = e.getData(), l = this._data, u = e.coordinateSystem, h = u.dimensions, c = w7(e);
          s.diff(l).add(f).update(g).remove(d).execute();
          function f(p) {
            var v = x7(s, o, p, h, u);
            ZD(v, s, p, c);
          }
          function g(p, v) {
            var y = l.getItemGraphicEl(v), m = I7(s, p, h, u);
            s.setItemGraphicEl(p, y), Ee(y, { shape: { points: m } }, e, p), to(y), ZD(y, s, p, c);
          }
          function d(p) {
            var v = l.getItemGraphicEl(p);
            o.remove(v);
          }
          if (!this._initialized) {
            this._initialized = true;
            var A = ZDt(u, e, function() {
              setTimeout(function() {
                o.removeClipPath();
              });
            });
            o.setClipPath(A);
          }
          this._data = s;
        }, t.prototype.incrementalPrepareRender = function(e, i, r) {
          this._initialized = true, this._data = null, this._dataGroup.removeAll();
        }, t.prototype.incrementalRender = function(e, i, r) {
          for (var a = i.getData(), o = i.coordinateSystem, s = o.dimensions, l = w7(i), u = this._progressiveEls = [], h = e.start; h < e.end; h++) {
            var c = x7(a, this._dataGroup, h, s, o);
            c.incremental = true, ZD(c, a, h, l), u.push(c);
          }
        }, t.prototype.remove = function() {
          this._dataGroup && this._dataGroup.removeAll(), this._data = null;
        }, t.type = "parallel", t;
      }(qe);
      function ZDt(n, t, e) {
        var i = n.model, r = n.getRect(), a = new fe({ shape: { x: r.x, y: r.y, width: r.width, height: r.height } }), o = i.get("layout") === "horizontal" ? "width" : "height";
        return a.setShape(o, 0), on(a, { shape: { width: r.width, height: r.height } }, t, e), a;
      }
      function I7(n, t, e, i) {
        for (var r = [], a = 0; a < e.length; a++) {
          var o = e[a], s = n.get(n.mapDimension(o), t);
          KDt(s, i.getAxis(o).type) || r.push(i.dataToPoint(s, o));
        }
        return r;
      }
      function x7(n, t, e, i, r) {
        var a = I7(n, e, i, r), o = new Ji({ shape: { points: a }, z2: 10 });
        return t.add(o), n.setItemGraphicEl(e, o), o;
      }
      function w7(n) {
        var t = n.get("smooth", true);
        return t === true && (t = XDt), t = js(t), ph(t) && (t = 0), { smooth: t };
      }
      function ZD(n, t, e, i) {
        n.useStyle(t.getItemVisual(e, "style")), n.style.fill = null, n.setShape("smooth", i.smooth);
        var r = t.getItemModel(e), a = r.getModel("emphasis");
        Ii(n, r, "lineStyle"), pn(n, a.get("focus"), a.get("blurScope"), a.get("disabled"));
      }
      function KDt(n, t) {
        return t === "category" ? n == null : n == null || isNaN(n);
      }
      var JDt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.visualStyleAccessPath = "lineStyle", e.visualDrawType = "stroke", e;
        }
        return t.prototype.getInitialData = function(e, i) {
          return tl(null, this, { useEncodeDefaulter: ct(tRt, null, this) });
        }, t.prototype.getRawIndicesByActiveState = function(e) {
          var i = this.coordinateSystem, r = this.getData(), a = [];
          return i.eachActiveState(r, function(o, s) {
            e === o && a.push(r.getRawIndex(s));
          }), a;
        }, t.type = "series.parallel", t.dependencies = ["parallel"], t.defaultOption = { z: 2, coordinateSystem: "parallel", parallelIndex: 0, label: { show: false }, inactiveOpacity: 0.05, activeOpacity: 1, lineStyle: { width: 1, opacity: 0.45, type: "solid" }, emphasis: { label: { show: false } }, progressive: 500, smooth: false, animationEasing: "linear" }, t;
      }(tn);
      function tRt(n) {
        var t = n.ecModel.getComponent("parallel", n.get("parallelIndex"));
        if (t) {
          var e = {};
          return D(t.dimensions, function(i) {
            var r = eRt(i);
            e[i] = r;
          }), e;
        }
      }
      function eRt(n) {
        return +n.replace("dim", "");
      }
      var nRt = ["lineStyle", "opacity"], iRt = { seriesType: "parallel", reset: function(n, t) {
        var e = n.coordinateSystem, i = { normal: n.get(["lineStyle", "opacity"]), active: n.get("activeOpacity"), inactive: n.get("inactiveOpacity") };
        return { progress: function(r, a) {
          e.eachActiveState(a, function(o, s) {
            var l = i[o];
            if (o === "normal" && a.hasItemOption) {
              var u = a.getItemModel(s).get(nRt, true);
              u != null && (l = u);
            }
            var h = a.ensureUniqueItemVisual(s, "style");
            h.opacity = l;
          }, r.start, r.end);
        } };
      } };
      function rRt(n) {
        aRt(n), oRt(n);
      }
      function aRt(n) {
        if (!n.parallel) {
          var t = false;
          D(n.series, function(e) {
            e && e.type === "parallel" && (t = true);
          }), t && (n.parallel = [{}]);
        }
      }
      function oRt(n) {
        var t = ze(n.parallelAxis);
        D(t, function(e) {
          if (Et(e)) {
            var i = e.parallelIndex || 0, r = ze(n.parallel)[i];
            r && r.parallelAxisDefault && Yt(e, r.parallelAxisDefault, false);
          }
        });
      }
      var sRt = 5, lRt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          this._model = e, this._api = r, this._handlers || (this._handlers = {}, D(uRt, function(a, o) {
            r.getZr().on(o, this._handlers[o] = ct(a, this));
          }, this)), ad(this, "_throttledDispatchExpand", e.get("axisExpandRate"), "fixRate");
        }, t.prototype.dispose = function(e, i) {
          Mv(this, "_throttledDispatchExpand"), D(this._handlers, function(r, a) {
            i.getZr().off(a, r);
          }), this._handlers = null;
        }, t.prototype._throttledDispatchExpand = function(e) {
          this._dispatchExpand(e);
        }, t.prototype._dispatchExpand = function(e) {
          e && this._api.dispatchAction(X({ type: "parallelAxisExpand" }, e));
        }, t.type = "parallel", t;
      }(un), uRt = { mousedown: function(n) {
        KD(this, "click") && (this._mouseDownPoint = [n.offsetX, n.offsetY]);
      }, mouseup: function(n) {
        var t = this._mouseDownPoint;
        if (KD(this, "click") && t) {
          var e = [n.offsetX, n.offsetY], i = Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2);
          if (i > sRt) return;
          var r = this._model.coordinateSystem.getSlidedAxisExpandWindow([n.offsetX, n.offsetY]);
          r.behavior !== "none" && this._dispatchExpand({ axisExpandWindow: r.axisExpandWindow });
        }
        this._mouseDownPoint = null;
      }, mousemove: function(n) {
        if (!(this._mouseDownPoint || !KD(this, "mousemove"))) {
          var t = this._model, e = t.coordinateSystem.getSlidedAxisExpandWindow([n.offsetX, n.offsetY]), i = e.behavior;
          i === "jump" && this._throttledDispatchExpand.debounceNextCall(t.get("axisExpandDebounce")), this._throttledDispatchExpand(i === "none" ? null : { axisExpandWindow: e.axisExpandWindow, animation: i === "jump" ? null : { duration: 0 } });
        }
      } };
      function KD(n, t) {
        var e = n._model;
        return e.get("axisExpandable") && e.get("axisExpandTriggerOn") === t;
      }
      var hRt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function() {
          n.prototype.init.apply(this, arguments), this.mergeOption({});
        }, t.prototype.mergeOption = function(e) {
          var i = this.option;
          e && Yt(i, e, true), this._initDimensions();
        }, t.prototype.contains = function(e, i) {
          var r = e.get("parallelIndex");
          return r != null && i.getComponent("parallel", r) === this;
        }, t.prototype.setAxisExpand = function(e) {
          D(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(i) {
            e.hasOwnProperty(i) && (this.option[i] = e[i]);
          }, this);
        }, t.prototype._initDimensions = function() {
          var e = this.dimensions = [], i = this.parallelAxisIndex = [], r = Fe(this.ecModel.queryComponents({ mainType: "parallelAxis" }), function(a) {
            return (a.get("parallelIndex") || 0) === this.componentIndex;
          }, this);
          D(r, function(a) {
            e.push("dim" + a.get("dim")), i.push(a.componentIndex);
          });
        }, t.type = "parallel", t.dependencies = ["parallelAxis"], t.layoutMode = "box", t.defaultOption = { z: 0, left: 80, top: 60, right: 80, bottom: 60, layout: "horizontal", axisExpandable: false, axisExpandCenter: null, axisExpandCount: 0, axisExpandWidth: 50, axisExpandRate: 17, axisExpandDebounce: 50, axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4], axisExpandTriggerOn: "click", parallelAxisDefault: null }, t;
      }(ae), cRt = function(n) {
        V(t, n);
        function t(e, i, r, a, o) {
          var s = n.call(this, e, i, r) || this;
          return s.type = a || "value", s.axisIndex = o, s;
        }
        return t.prototype.isHorizontal = function() {
          return this.coordinateSystem.getModel().get("layout") !== "horizontal";
        }, t;
      }(ao);
      function Ic(n, t, e, i, r, a) {
        n = n || 0;
        var o = e[1] - e[0];
        if (r != null && (r = xd(r, [0, o])), a != null && (a = Math.max(a, r != null ? r : 0)), i === "all") {
          var s = Math.abs(t[1] - t[0]);
          s = xd(s, [0, o]), r = a = xd(s, [r, a]), i = 0;
        }
        t[0] = xd(t[0], e), t[1] = xd(t[1], e);
        var l = JD(t, i);
        t[i] += n;
        var u = r || 0, h = e.slice();
        l.sign < 0 ? h[0] += u : h[1] -= u, t[i] = xd(t[i], h);
        var c;
        return c = JD(t, i), r != null && (c.sign !== l.sign || c.span < r) && (t[1 - i] = t[i] + l.sign * r), c = JD(t, i), a != null && c.span > a && (t[1 - i] = t[i] + c.sign * a), t;
      }
      function JD(n, t) {
        var e = n[t] - n[1 - t];
        return { span: Math.abs(e), sign: e > 0 ? -1 : e < 0 ? 1 : t ? -1 : 1 };
      }
      function xd(n, t) {
        return Math.min(t[1] != null ? t[1] : 1 / 0, Math.max(t[0] != null ? t[0] : -1 / 0, n));
      }
      var tR = D, C7 = Math.min, S7 = Math.max, b7 = Math.floor, fRt = Math.ceil, T7 = En, gRt = Math.PI, dRt = function() {
        function n(t, e, i) {
          this.type = "parallel", this._axesMap = dt(), this._axesLayout = {}, this.dimensions = t.dimensions, this._model = t, this._init(t, e, i);
        }
        return n.prototype._init = function(t, e, i) {
          var r = t.dimensions, a = t.parallelAxisIndex;
          tR(r, function(o, s) {
            var l = a[s], u = e.getComponent("parallelAxis", l), h = this._axesMap.set(o, new cRt(o, FE(u), [0, 0], u.get("type"), l)), c = h.type === "category";
            h.onBand = c && u.get("boundaryGap"), h.inverse = u.get("inverse"), u.axis = h, h.model = u, h.coordinateSystem = u.coordinateSystem = this;
          }, this);
        }, n.prototype.update = function(t, e) {
          this._updateAxesFromSeries(this._model, t);
        }, n.prototype.containPoint = function(t) {
          var e = this._makeLayoutInfo(), i = e.axisBase, r = e.layoutBase, a = e.pixelDimIndex, o = t[1 - a], s = t[a];
          return o >= i && o <= i + e.axisLength && s >= r && s <= r + e.layoutLength;
        }, n.prototype.getModel = function() {
          return this._model;
        }, n.prototype._updateAxesFromSeries = function(t, e) {
          e.eachSeries(function(i) {
            if (t.contains(i, e)) {
              var r = i.getData();
              tR(this.dimensions, function(a) {
                var o = this._axesMap.get(a);
                o.scale.unionExtentFromData(r, r.mapDimension(a)), gd(o.scale, o.model);
              }, this);
            }
          }, this);
        }, n.prototype.resize = function(t, e) {
          this._rect = Yn(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }), this._layoutAxes();
        }, n.prototype.getRect = function() {
          return this._rect;
        }, n.prototype._makeLayoutInfo = function() {
          var t = this._model, e = this._rect, i = ["x", "y"], r = ["width", "height"], a = t.get("layout"), o = a === "horizontal" ? 0 : 1, s = e[r[o]], l = [0, s], u = this.dimensions.length, h = fI(t.get("axisExpandWidth"), l), c = fI(t.get("axisExpandCount") || 0, [0, u]), f = t.get("axisExpandable") && u > 3 && u > c && c > 1 && h > 0 && s > 0, g = t.get("axisExpandWindow"), d;
          if (g) d = fI(g[1] - g[0], l), g[1] = g[0] + d;
          else {
            d = fI(h * (c - 1), l);
            var A = t.get("axisExpandCenter") || b7(u / 2);
            g = [h * A - d / 2], g[1] = g[0] + d;
          }
          var p = (s - d) / (u - c);
          p < 3 && (p = 0);
          var v = [b7(T7(g[0] / h, 1)) + 1, fRt(T7(g[1] / h, 1)) - 1], y = p / h * g[0];
          return { layout: a, pixelDimIndex: o, layoutBase: e[i[o]], layoutLength: s, axisBase: e[i[1 - o]], axisLength: e[r[1 - o]], axisExpandable: f, axisExpandWidth: h, axisCollapseWidth: p, axisExpandWindow: g, axisCount: u, winInnerIndices: v, axisExpandWindow0Pos: y };
        }, n.prototype._layoutAxes = function() {
          var t = this._rect, e = this._axesMap, i = this.dimensions, r = this._makeLayoutInfo(), a = r.layout;
          e.each(function(o) {
            var s = [0, r.axisLength], l = o.inverse ? 1 : 0;
            o.setExtent(s[l], s[1 - l]);
          }), tR(i, function(o, s) {
            var l = (r.axisExpandable ? pRt : ARt)(s, r), u = { horizontal: { x: l.position, y: r.axisLength }, vertical: { x: 0, y: l.position } }, h = { horizontal: gRt / 2, vertical: 0 }, c = [u[a].x + t.x, u[a].y + t.y], f = h[a], g = Vr();
            _h(g, g, f), Go(g, g, c), this._axesLayout[o] = { position: c, rotation: f, transform: g, axisNameAvailableWidth: l.axisNameAvailableWidth, axisLabelShow: l.axisLabelShow, nameTruncateMaxWidth: l.nameTruncateMaxWidth, tickDirection: 1, labelDirection: 1 };
          }, this);
        }, n.prototype.getAxis = function(t) {
          return this._axesMap.get(t);
        }, n.prototype.dataToPoint = function(t, e) {
          return this.axisCoordToPoint(this._axesMap.get(e).dataToCoord(t), e);
        }, n.prototype.eachActiveState = function(t, e, i, r) {
          i == null && (i = 0), r == null && (r = t.count());
          var a = this._axesMap, o = this.dimensions, s = [], l = [];
          D(o, function(p) {
            s.push(t.mapDimension(p)), l.push(a.get(p).model);
          });
          for (var u = this.hasAxisBrushed(), h = i; h < r; h++) {
            var c = void 0;
            if (!u) c = "normal";
            else {
              c = "active";
              for (var f = t.getValues(s, h), g = 0, d = o.length; g < d; g++) {
                var A = l[g].getActiveState(f[g]);
                if (A === "inactive") {
                  c = "inactive";
                  break;
                }
              }
            }
            e(c, h);
          }
        }, n.prototype.hasAxisBrushed = function() {
          for (var t = this.dimensions, e = this._axesMap, i = false, r = 0, a = t.length; r < a; r++) e.get(t[r]).model.getActiveState() !== "normal" && (i = true);
          return i;
        }, n.prototype.axisCoordToPoint = function(t, e) {
          var i = this._axesLayout[e];
          return no([t, 0], i.transform);
        }, n.prototype.getAxisLayout = function(t) {
          return Ct(this._axesLayout[t]);
        }, n.prototype.getSlidedAxisExpandWindow = function(t) {
          var e = this._makeLayoutInfo(), i = e.pixelDimIndex, r = e.axisExpandWindow.slice(), a = r[1] - r[0], o = [0, e.axisExpandWidth * (e.axisCount - 1)];
          if (!this.containPoint(t)) return { behavior: "none", axisExpandWindow: r };
          var s = t[i] - e.layoutBase - e.axisExpandWindow0Pos, l, u = "slide", h = e.axisCollapseWidth, c = this._model.get("axisExpandSlideTriggerArea"), f = c[0] != null;
          if (h) f && h && s < a * c[0] ? (u = "jump", l = s - a * c[2]) : f && h && s > a * (1 - c[0]) ? (u = "jump", l = s - a * (1 - c[2])) : (l = s - a * c[1]) >= 0 && (l = s - a * (1 - c[1])) <= 0 && (l = 0), l *= e.axisExpandWidth / h, l ? Ic(l, r, o, "all") : u = "none";
          else {
            var g = r[1] - r[0], d = o[1] * s / g;
            r = [S7(0, d - g / 2)], r[1] = C7(o[1], r[0] + g), r[0] = r[1] - g;
          }
          return { axisExpandWindow: r, behavior: u };
        }, n;
      }();
      function fI(n, t) {
        return C7(S7(n, t[0]), t[1]);
      }
      function ARt(n, t) {
        var e = t.layoutLength / (t.axisCount - 1);
        return { position: e * n, axisNameAvailableWidth: e, axisLabelShow: true };
      }
      function pRt(n, t) {
        var e = t.layoutLength, i = t.axisExpandWidth, r = t.axisCount, a = t.axisCollapseWidth, o = t.winInnerIndices, s, l = a, u = false, h;
        return n < o[0] ? (s = n * a, h = a) : n <= o[1] ? (s = t.axisExpandWindow0Pos + n * i - t.axisExpandWindow[0], l = i, u = true) : (s = e - (r - 1 - n) * a, h = a), { position: s, axisNameAvailableWidth: l, axisLabelShow: u, nameTruncateMaxWidth: h };
      }
      function vRt(n, t) {
        var e = [];
        return n.eachComponent("parallel", function(i, r) {
          var a = new dRt(i, n, t);
          a.name = "parallel_" + r, a.resize(i, t), i.coordinateSystem = a, a.model = i, e.push(a);
        }), n.eachSeries(function(i) {
          if (i.get("coordinateSystem") === "parallel") {
            var r = i.getReferringComponents("parallel", zn).models[0];
            i.coordinateSystem = r.coordinateSystem;
          }
        }), e;
      }
      var yRt = { create: vRt }, eR = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.activeIntervals = [], e;
        }
        return t.prototype.getAreaSelectStyle = function() {
          return Dh([["fill", "color"], ["lineWidth", "borderWidth"], ["stroke", "borderColor"], ["width", "width"], ["opacity", "opacity"]])(this.getModel("areaSelectStyle"));
        }, t.prototype.setActiveIntervals = function(e) {
          var i = this.activeIntervals = Ct(e);
          if (i) for (var r = i.length - 1; r >= 0; r--) va(i[r]);
        }, t.prototype.getActiveState = function(e) {
          var i = this.activeIntervals;
          if (!i.length) return "normal";
          if (e == null || isNaN(+e)) return "inactive";
          if (i.length === 1) {
            var r = i[0];
            if (r[0] <= e && e <= r[1]) return "active";
          } else for (var a = 0, o = i.length; a < o; a++) if (i[a][0] <= e && e <= i[a][1]) return "active";
          return "inactive";
        }, t;
      }(ae);
      kn(eR, jv);
      var xc = true, my = Math.min, wd = Math.max, mRt = Math.pow, _Rt = 1e4, ERt = 6, IRt = 6, B7 = "globalPan", xRt = { w: [0, 0], e: [0, 1], n: [1, 0], s: [1, 1] }, wRt = { w: "ew", e: "ew", n: "ns", s: "ns", ne: "nesw", sw: "nesw", nw: "nwse", se: "nwse" }, M7 = { brushStyle: { lineWidth: 2, stroke: "rgba(210,219,238,0.3)", fill: "#D2DBEE" }, transformable: true, brushMode: "single", removeOnClick: false }, CRt = 0, nR = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this) || this;
          return i._track = [], i._covers = [], i._handlers = {}, It(e), i._zr = e, i.group = new Dt(), i._uid = "brushController_" + CRt++, D(RRt, function(r, a) {
            this._handlers[a] = ct(r, this);
          }, i), i;
        }
        return t.prototype.enableBrush = function(e) {
          return It(this._mounted), this._brushType && this._doDisableBrush(), e.brushType && this._doEnableBrush(e), this;
        }, t.prototype._doEnableBrush = function(e) {
          var i = this._zr;
          this._enableGlobalPan || ABt(i, B7, this._uid), D(this._handlers, function(r, a) {
            i.on(a, r);
          }), this._brushType = e.brushType, this._brushOption = Yt(Ct(M7), e, true);
        }, t.prototype._doDisableBrush = function() {
          var e = this._zr;
          pBt(e, B7, this._uid), D(this._handlers, function(i, r) {
            e.off(r, i);
          }), this._brushType = this._brushOption = null;
        }, t.prototype.setPanels = function(e) {
          if (e && e.length) {
            var i = this._panels = {};
            D(e, function(r) {
              i[r.panelId] = Ct(r);
            });
          } else this._panels = null;
          return this;
        }, t.prototype.mount = function(e) {
          e = e || {}, this._mounted = true, this._enableGlobalPan = e.enableGlobalPan;
          var i = this.group;
          return this._zr.add(i), i.attr({ x: e.x || 0, y: e.y || 0, rotation: e.rotation || 0, scaleX: e.scaleX || 1, scaleY: e.scaleY || 1 }), this._transform = i.getLocalTransform(), this;
        }, t.prototype.updateCovers = function(e) {
          It(this._mounted), e = K(e, function(f) {
            return Yt(Ct(M7), f, true);
          });
          var i = "\0-brush-index-", r = this._covers, a = this._covers = [], o = this, s = this._creatingCover;
          return new Js(r, e, u, l).add(h).update(h).remove(c).execute(), this;
          function l(f, g) {
            return (f.id != null ? f.id : i + g) + "-" + f.brushType;
          }
          function u(f, g) {
            return l(f.__brushOption, g);
          }
          function h(f, g) {
            var d = e[f];
            if (g != null && r[g] === s) a[f] = r[g];
            else {
              var A = a[f] = g != null ? (r[g].__brushOption = d, r[g]) : R7(o, D7(o, d));
              iR(o, A);
            }
          }
          function c(f) {
            r[f] !== s && o.group.remove(r[f]);
          }
        }, t.prototype.unmount = function() {
          if (!!this._mounted) return this.enableBrush(false), oR(this), this._zr.remove(this.group), this._mounted = false, this;
        }, t.prototype.dispose = function() {
          this.unmount(), this.off();
        }, t;
      }(ga);
      function D7(n, t) {
        var e = gI[t.brushType].createCover(n, t);
        return e.__brushOption = t, P7(e, t), n.group.add(e), e;
      }
      function R7(n, t) {
        var e = rR(t);
        return e.endCreating && (e.endCreating(n, t), P7(t, t.__brushOption)), t;
      }
      function L7(n, t) {
        var e = t.__brushOption;
        rR(t).updateCoverShape(n, t, e.range, e);
      }
      function P7(n, t) {
        var e = t.z;
        e == null && (e = _Rt), n.traverse(function(i) {
          i.z = e, i.z2 = e;
        });
      }
      function iR(n, t) {
        rR(t).updateCommon(n, t), L7(n, t);
      }
      function rR(n) {
        return gI[n.__brushOption.brushType];
      }
      function aR(n, t, e) {
        var i = n._panels;
        if (!i) return xc;
        var r, a = n._transform;
        return D(i, function(o) {
          o.isTargetByCursor(t, e, a) && (r = o);
        }), r;
      }
      function N7(n, t) {
        var e = n._panels;
        if (!e) return xc;
        var i = t.__brushOption.panelId;
        return i != null ? e[i] : xc;
      }
      function oR(n) {
        var t = n._covers, e = t.length;
        return D(t, function(i) {
          n.group.remove(i);
        }, n), t.length = 0, !!e;
      }
      function wc(n, t) {
        var e = K(n._covers, function(i) {
          var r = i.__brushOption, a = Ct(r.range);
          return { brushType: r.brushType, panelId: r.panelId, range: a };
        });
        n.trigger("brush", { areas: e, isEnd: !!t.isEnd, removeOnClick: !!t.removeOnClick });
      }
      function SRt(n) {
        var t = n._track;
        if (!t.length) return false;
        var e = t[t.length - 1], i = t[0], r = e[0] - i[0], a = e[1] - i[1], o = mRt(r * r + a * a, 0.5);
        return o > ERt;
      }
      function F7(n) {
        var t = n.length - 1;
        return t < 0 && (t = 0), [n[0], n[t]];
      }
      function k7(n, t, e, i) {
        var r = new Dt();
        return r.add(new fe({ name: "main", style: lR(e), silent: true, draggable: true, cursor: "move", drift: Gt(z7, n, t, r, ["n", "s", "w", "e"]), ondragend: Gt(wc, t, { isEnd: true }) })), D(i, function(a) {
          r.add(new fe({ name: a.join(""), style: { opacity: 0 }, draggable: true, silent: true, invisible: true, drift: Gt(z7, n, t, r, a), ondragend: Gt(wc, t, { isEnd: true }) }));
        }), r;
      }
      function O7(n, t, e, i) {
        var r = i.brushStyle.lineWidth || 0, a = wd(r, IRt), o = e[0][0], s = e[1][0], l = o - r / 2, u = s - r / 2, h = e[0][1], c = e[1][1], f = h - a + r / 2, g = c - a + r / 2, d = h - o, A = c - s, p = d + r, v = A + r;
        il(n, t, "main", o, s, d, A), i.transformable && (il(n, t, "w", l, u, a, v), il(n, t, "e", f, u, a, v), il(n, t, "n", l, u, p, a), il(n, t, "s", l, g, p, a), il(n, t, "nw", l, u, a, a), il(n, t, "ne", f, u, a, a), il(n, t, "sw", l, g, a, a), il(n, t, "se", f, g, a, a));
      }
      function sR(n, t) {
        var e = t.__brushOption, i = e.transformable, r = t.childAt(0);
        r.useStyle(lR(e)), r.attr({ silent: !i, cursor: i ? "move" : "default" }), D([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(a) {
          var o = t.childOfName(a.join("")), s = a.length === 1 ? uR(n, a[0]) : TRt(n, a);
          o && o.attr({ silent: !i, invisible: !i, cursor: i ? wRt[s] + "-resize" : null });
        });
      }
      function il(n, t, e, i, r, a, o) {
        var s = t.childOfName(e);
        s && s.setShape(MRt(hR(n, t, [[i, r], [i + a, r + o]])));
      }
      function lR(n) {
        return wt({ strokeNoScale: true }, n.brushStyle);
      }
      function Q7(n, t, e, i) {
        var r = [my(n, e), my(t, i)], a = [wd(n, e), wd(t, i)];
        return [[r[0], a[0]], [r[1], a[1]]];
      }
      function bRt(n) {
        return Yh(n.group);
      }
      function uR(n, t) {
        var e = { w: "left", e: "right", n: "top", s: "bottom" }, i = { left: "w", right: "e", top: "n", bottom: "s" }, r = V1(e[t], bRt(n));
        return i[r];
      }
      function TRt(n, t) {
        var e = [uR(n, t[0]), uR(n, t[1])];
        return (e[0] === "e" || e[0] === "w") && e.reverse(), e.join("");
      }
      function z7(n, t, e, i, r, a) {
        var o = e.__brushOption, s = n.toRectRange(o.range), l = G7(t, r, a);
        D(i, function(u) {
          var h = xRt[u];
          s[h[0]][h[1]] += l[h[0]];
        }), o.range = n.fromRectRange(Q7(s[0][0], s[1][0], s[0][1], s[1][1])), iR(t, e), wc(t, { isEnd: false });
      }
      function BRt(n, t, e, i) {
        var r = t.__brushOption.range, a = G7(n, e, i);
        D(r, function(o) {
          o[0] += a[0], o[1] += a[1];
        }), iR(n, t), wc(n, { isEnd: false });
      }
      function G7(n, t, e) {
        var i = n.group, r = i.transformCoordToLocal(t, e), a = i.transformCoordToLocal(0, 0);
        return [r[0] - a[0], r[1] - a[1]];
      }
      function hR(n, t, e) {
        var i = N7(n, t);
        return i && i !== xc ? i.clipPath(e, n._transform) : Ct(e);
      }
      function MRt(n) {
        var t = my(n[0][0], n[1][0]), e = my(n[0][1], n[1][1]), i = wd(n[0][0], n[1][0]), r = wd(n[0][1], n[1][1]);
        return { x: t, y: e, width: i - t, height: r - e };
      }
      function DRt(n, t, e) {
        if (!(!n._brushType || LRt(n, t.offsetX, t.offsetY))) {
          var i = n._zr, r = n._covers, a = aR(n, t, e);
          if (!n._dragging) for (var o = 0; o < r.length; o++) {
            var s = r[o].__brushOption;
            if (a && (a === xc || s.panelId === a.panelId) && gI[s.brushType].contain(r[o], e[0], e[1])) return;
          }
          a && i.setCursorStyle("crosshair");
        }
      }
      function cR(n) {
        var t = n.event;
        t.preventDefault && t.preventDefault();
      }
      function fR(n, t, e) {
        return n.childOfName("main").contain(t, e);
      }
      function U7(n, t, e, i) {
        var r = n._creatingCover, a = n._creatingPanel, o = n._brushOption, s;
        if (n._track.push(e.slice()), SRt(n) || r) {
          if (a && !r) {
            o.brushMode === "single" && oR(n);
            var l = Ct(o);
            l.brushType = V7(l.brushType, a), l.panelId = a === xc ? null : a.panelId, r = n._creatingCover = D7(n, l), n._covers.push(r);
          }
          if (r) {
            var u = gI[V7(n._brushType, a)], h = r.__brushOption;
            h.range = u.getCreatingRange(hR(n, r, n._track)), i && (R7(n, r), u.updateCommon(n, r)), L7(n, r), s = { isEnd: i };
          }
        } else i && o.brushMode === "single" && o.removeOnClick && aR(n, t, e) && oR(n) && (s = { isEnd: i, removeOnClick: true });
        return s;
      }
      function V7(n, t) {
        return n === "auto" ? (It(t && t.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"'), t.defaultBrushType) : n;
      }
      var RRt = { mousedown: function(n) {
        if (this._dragging) j7(this, n);
        else if (!n.target || !n.target.draggable) {
          cR(n);
          var t = this.group.transformCoordToLocal(n.offsetX, n.offsetY);
          this._creatingCover = null;
          var e = this._creatingPanel = aR(this, n, t);
          e && (this._dragging = true, this._track = [t.slice()]);
        }
      }, mousemove: function(n) {
        var t = n.offsetX, e = n.offsetY, i = this.group.transformCoordToLocal(t, e);
        if (DRt(this, n, i), this._dragging) {
          cR(n);
          var r = U7(this, n, i, false);
          r && wc(this, r);
        }
      }, mouseup: function(n) {
        j7(this, n);
      } };
      function j7(n, t) {
        if (n._dragging) {
          cR(t);
          var e = t.offsetX, i = t.offsetY, r = n.group.transformCoordToLocal(e, i), a = U7(n, t, r, true);
          n._dragging = false, n._track = [], n._creatingCover = null, a && wc(n, a);
        }
      }
      function LRt(n, t, e) {
        var i = n._zr;
        return t < 0 || t > i.getWidth() || e < 0 || e > i.getHeight();
      }
      var gI = { lineX: q7(0), lineY: q7(1), rect: { createCover: function(n, t) {
        function e(i) {
          return i;
        }
        return k7({ toRectRange: e, fromRectRange: e }, n, t, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
      }, getCreatingRange: function(n) {
        var t = F7(n);
        return Q7(t[1][0], t[1][1], t[0][0], t[0][1]);
      }, updateCoverShape: function(n, t, e, i) {
        O7(n, t, e, i);
      }, updateCommon: sR, contain: fR }, polygon: { createCover: function(n, t) {
        var e = new Dt();
        return e.add(new Ji({ name: "main", style: lR(t), silent: true })), e;
      }, getCreatingRange: function(n) {
        return n;
      }, endCreating: function(n, t) {
        t.remove(t.childAt(0)), t.add(new Ki({ name: "main", draggable: true, drift: Gt(BRt, n, t), ondragend: Gt(wc, n, { isEnd: true }) }));
      }, updateCoverShape: function(n, t, e, i) {
        t.childAt(0).setShape({ points: hR(n, t, e) });
      }, updateCommon: sR, contain: fR } };
      function q7(n) {
        return { createCover: function(t, e) {
          return k7({ toRectRange: function(i) {
            var r = [i, [0, 100]];
            return n && r.reverse(), r;
          }, fromRectRange: function(i) {
            return i[n];
          } }, t, e, [[["w"], ["e"]], [["n"], ["s"]]][n]);
        }, getCreatingRange: function(t) {
          var e = F7(t), i = my(e[0][n], e[1][n]), r = wd(e[0][n], e[1][n]);
          return [i, r];
        }, updateCoverShape: function(t, e, i, r) {
          var a, o = N7(t, e);
          if (o !== xc && o.getLinearBrushOtherExtent) a = o.getLinearBrushOtherExtent(n);
          else {
            var s = t._zr;
            a = [0, [s.getWidth(), s.getHeight()][1 - n]];
          }
          var l = [i, a];
          n && l.reverse(), O7(t, e, l, r);
        }, updateCommon: sR, contain: fR };
      }
      function H7(n) {
        return n = gR(n), function(t) {
          return P8(t, n);
        };
      }
      function Y7(n, t) {
        return n = gR(n), function(e) {
          var i = t != null ? t : e, r = i ? n.width : n.height, a = i ? n.x : n.y;
          return [a, a + (r || 0)];
        };
      }
      function W7(n, t, e) {
        var i = gR(n);
        return function(r, a) {
          return i.contain(a[0], a[1]) && !KE(r, t, e);
        };
      }
      function gR(n) {
        return Wt.create(n);
      }
      var PRt = ["axisLine", "axisTickLabel", "axisName"], NRt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e, i) {
          n.prototype.init.apply(this, arguments), (this._brushController = new nR(i.getZr())).on("brush", ct(this._onBrush, this));
        }, t.prototype.render = function(e, i, r, a) {
          if (!FRt(e, i, a)) {
            this.axisModel = e, this.api = r, this.group.removeAll();
            var o = this._axisGroup;
            if (this._axisGroup = new Dt(), this.group.add(this._axisGroup), !!e.get("show")) {
              var s = ORt(e, i), l = s.coordinateSystem, u = e.getAreaSelectStyle(), h = u.width, c = e.axis.dim, f = l.getAxisLayout(c), g = X({ strokeContainThreshold: h }, f), d = new rr(e, g);
              D(PRt, d.add, d), this._axisGroup.add(d.getGroup()), this._refreshBrushController(g, u, e, s, h, r), pv(o, this._axisGroup, e);
            }
          }
        }, t.prototype._refreshBrushController = function(e, i, r, a, o, s) {
          var l = r.axis.getExtent(), u = l[1] - l[0], h = Math.min(30, Math.abs(u) * 0.1), c = Wt.create({ x: l[0], y: -o / 2, width: u, height: o });
          c.x -= h, c.width += 2 * h, this._brushController.mount({ enableGlobalPan: true, rotation: e.rotation, x: e.position[0], y: e.position[1] }).setPanels([{ panelId: "pl", clipPath: H7(c), isTargetByCursor: W7(c, s, a), getLinearBrushOtherExtent: Y7(c, 0) }]).enableBrush({ brushType: "lineX", brushStyle: i, removeOnClick: true }).updateCovers(kRt(r));
        }, t.prototype._onBrush = function(e) {
          var i = e.areas, r = this.axisModel, a = r.axis, o = K(i, function(s) {
            return [a.coordToData(s.range[0], true), a.coordToData(s.range[1], true)];
          });
          (!r.option.realtime === e.isEnd || e.removeOnClick) && this.api.dispatchAction({ type: "axisAreaSelect", parallelAxisId: r.id, intervals: o });
        }, t.prototype.dispose = function() {
          this._brushController.dispose();
        }, t.type = "parallelAxis", t;
      }(un);
      function FRt(n, t, e) {
        return e && e.type === "axisAreaSelect" && t.findComponents({ mainType: "parallelAxis", query: e })[0] === n;
      }
      function kRt(n) {
        var t = n.axis;
        return K(n.activeIntervals, function(e) {
          return { brushType: "lineX", panelId: "pl", range: [t.dataToCoord(e[0], true), t.dataToCoord(e[1], true)] };
        });
      }
      function ORt(n, t) {
        return t.getComponent("parallel", n.get("parallelIndex"));
      }
      var QRt = { type: "axisAreaSelect", event: "axisAreaSelected" };
      function zRt(n) {
        n.registerAction(QRt, function(t, e) {
          e.eachComponent({ mainType: "parallelAxis", query: t }, function(i) {
            i.axis.model.setActiveIntervals(t.intervals);
          });
        }), n.registerAction("parallelAxisExpand", function(t, e) {
          e.eachComponent({ mainType: "parallel", query: t }, function(i) {
            i.setAxisExpand(t);
          });
        });
      }
      var GRt = { type: "value", areaSelectStyle: { width: 20, borderWidth: 1, borderColor: "rgba(160,197,232)", color: "rgba(160,197,232)", opacity: 0.3 }, realtime: true, z: 10 };
      function X7(n) {
        n.registerComponentView(lRt), n.registerComponentModel(hRt), n.registerCoordinateSystem("parallel", yRt), n.registerPreprocessor(rRt), n.registerComponentModel(eR), n.registerComponentView(NRt), yd(n, "parallel", eR, GRt), zRt(n);
      }
      function URt(n) {
        Kt(X7), n.registerChartView($Dt), n.registerSeriesModel(JDt), n.registerVisual(n.PRIORITY.VISUAL.BRUSH, iRt);
      }
      var VRt = /* @__PURE__ */ function() {
        function n() {
          this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
        }
        return n;
      }(), jRt = function(n) {
        V(t, n);
        function t(e) {
          return n.call(this, e) || this;
        }
        return t.prototype.getDefaultShape = function() {
          return new VRt();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.extent;
          e.moveTo(i.x1, i.y1), e.bezierCurveTo(i.cpx1, i.cpy1, i.cpx2, i.cpy2, i.x2, i.y2), i.orient === "vertical" ? (e.lineTo(i.x2 + r, i.y2), e.bezierCurveTo(i.cpx2 + r, i.cpy2, i.cpx1 + r, i.cpy1, i.x1 + r, i.y1)) : (e.lineTo(i.x2, i.y2 + r), e.bezierCurveTo(i.cpx2, i.cpy2 + r, i.cpx1, i.cpy1 + r, i.x1, i.y1 + r)), e.closePath();
        }, t.prototype.highlight = function() {
          Ws(this);
        }, t.prototype.downplay = function() {
          Xs(this);
        }, t;
      }(ne), qRt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._focusAdjacencyDisabled = false, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = this, o = e.getGraph(), s = this.group, l = e.layoutInfo, u = l.width, h = l.height, c = e.getData(), f = e.getData("edge"), g = e.get("orient");
          this._model = e, s.removeAll(), s.x = l.x, s.y = l.y, o.eachEdge(function(d) {
            var A = new jRt(), p = Nt(A);
            p.dataIndex = d.dataIndex, p.seriesIndex = e.seriesIndex, p.dataType = "edge";
            var v = d.getModel(), y = v.getModel("lineStyle"), m = y.get("curveness"), _ = d.node1.getLayout(), I = d.node1.getModel(), E = I.get("localX"), x = I.get("localY"), w = d.node2.getLayout(), C = d.node2.getModel(), S = C.get("localX"), b = C.get("localY"), T = d.getLayout(), B, R, M, L, N, F, k, O;
            A.shape.extent = Math.max(1, T.dy), A.shape.orient = g, g === "vertical" ? (B = (E != null ? E * u : _.x) + T.sy, R = (x != null ? x * h : _.y) + _.dy, M = (S != null ? S * u : w.x) + T.ty, L = b != null ? b * h : w.y, N = B, F = R * (1 - m) + L * m, k = M, O = R * m + L * (1 - m)) : (B = (E != null ? E * u : _.x) + _.dx, R = (x != null ? x * h : _.y) + T.sy, M = S != null ? S * u : w.x, L = (b != null ? b * h : w.y) + T.ty, N = B * (1 - m) + M * m, F = R, k = B * m + M * (1 - m), O = L), A.setShape({ x1: B, y1: R, x2: M, y2: L, cpx1: N, cpy1: F, cpx2: k, cpy2: O }), A.useStyle(y.getItemStyle()), $7(A.style, g, d);
            var Q = "" + v.get("value"), j = Jn(v, "edgeLabel");
            xi(A, j, { labelFetcher: { getFormattedLabel: function($, J, et, nt, gt, q) {
              return e.getFormattedLabel($, J, "edge", nt, fa(gt, j.normal && j.normal.get("formatter"), Q), q);
            } }, labelDataIndex: d.dataIndex, defaultText: Q }), A.setTextConfig({ position: "inside" });
            var Y = v.getModel("emphasis");
            Ii(A, v, "lineStyle", function($) {
              var J = $.getItemStyle();
              return $7(J, g, d), J;
            }), s.add(A), f.setItemGraphicEl(d.dataIndex, A);
            var G = Y.get("focus");
            pn(A, G === "adjacency" ? d.getAdjacentDataIndices() : G === "trajectory" ? d.getTrajectoryDataIndices() : G, Y.get("blurScope"), Y.get("disabled"));
          }), o.eachNode(function(d) {
            var A = d.getLayout(), p = d.getModel(), v = p.get("localX"), y = p.get("localY"), m = p.getModel("emphasis"), _ = p.get(["itemStyle", "borderRadius"]) || 0, I = new fe({ shape: { x: v != null ? v * u : A.x, y: y != null ? y * h : A.y, width: A.dx, height: A.dy, r: _ }, style: p.getModel("itemStyle").getItemStyle(), z2: 10 });
            xi(I, Jn(p), { labelFetcher: { getFormattedLabel: function(x, w) {
              return e.getFormattedLabel(x, w, "node");
            } }, labelDataIndex: d.dataIndex, defaultText: d.id }), I.disableLabelAnimation = true, I.setStyle("fill", d.getVisual("color")), I.setStyle("decal", d.getVisual("style").decal), Ii(I, p), s.add(I), c.setItemGraphicEl(d.dataIndex, I), Nt(I).dataType = "node";
            var E = m.get("focus");
            pn(I, E === "adjacency" ? d.getAdjacentDataIndices() : E === "trajectory" ? d.getTrajectoryDataIndices() : E, m.get("blurScope"), m.get("disabled"));
          }), c.eachItemGraphicEl(function(d, A) {
            var p = c.getItemModel(A);
            p.get("draggable") && (d.drift = function(v, y) {
              a._focusAdjacencyDisabled = true, this.shape.x += v, this.shape.y += y, this.dirty(), r.dispatchAction({ type: "dragNode", seriesId: e.id, dataIndex: c.getRawIndex(A), localX: this.shape.x / u, localY: this.shape.y / h });
            }, d.ondragend = function() {
              a._focusAdjacencyDisabled = false;
            }, d.draggable = true, d.cursor = "move");
          }), !this._data && e.isAnimationEnabled() && s.setClipPath(HRt(s.getBoundingRect(), e, function() {
            s.removeClipPath();
          })), this._data = e.getData();
        }, t.prototype.dispose = function() {
        }, t.type = "sankey", t;
      }(qe);
      function $7(n, t, e) {
        switch (n.fill) {
          case "source":
            n.fill = e.node1.getVisual("color"), n.decal = e.node1.getVisual("style").decal;
            break;
          case "target":
            n.fill = e.node2.getVisual("color"), n.decal = e.node2.getVisual("style").decal;
            break;
          case "gradient":
            var i = e.node1.getVisual("color"), r = e.node2.getVisual("color");
            ht(i) && ht(r) && (n.fill = new dv(0, 0, +(t === "horizontal"), +(t === "vertical"), [{ color: i, offset: 0 }, { color: r, offset: 1 }]));
        }
      }
      function HRt(n, t, e) {
        var i = new fe({ shape: { x: n.x - 10, y: n.y - 10, width: 0, height: n.height + 20 } });
        return on(i, { shape: { width: n.width + 20 } }, t, e), i;
      }
      var YRt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.getInitialData = function(e, i) {
          var r = e.edges || e.links, a = e.data || e.nodes, o = e.levels;
          this.levelModels = [];
          for (var s = this.levelModels, l = 0; l < o.length; l++) if (o[l].depth != null && o[l].depth >= 0) s[o[l].depth] = new De(o[l], this, i);
          else if (true) throw new Error("levels[i].depth is mandatory and should be natural number");
          if (a && r) {
            var u = E7(a, r, this, true, h);
            return u.data;
          }
          function h(c, f) {
            c.wrapMethod("getItemModel", function(g, d) {
              var A = g.parentModel, p = A.getData().getItemLayout(d);
              if (p) {
                var v = p.depth, y = A.levelModels[v];
                y && (g.parentModel = y);
              }
              return g;
            }), f.wrapMethod("getItemModel", function(g, d) {
              var A = g.parentModel, p = A.getGraph().getEdgeByIndex(d), v = p.node1.getLayout();
              if (v) {
                var y = v.depth, m = A.levelModels[y];
                m && (g.parentModel = m);
              }
              return g;
            });
          }
        }, t.prototype.setNodePosition = function(e, i) {
          var r = this.option.data || this.option.nodes, a = r[e];
          a.localX = i[0], a.localY = i[1];
        }, t.prototype.getGraph = function() {
          return this.getData().graph;
        }, t.prototype.getEdgeData = function() {
          return this.getGraph().edgeData;
        }, t.prototype.formatTooltip = function(e, i, r) {
          function a(g) {
            return isNaN(g) || g == null;
          }
          if (r === "edge") {
            var o = this.getDataParams(e, r), s = o.data, l = o.value, u = s.source + " -- " + s.target;
            return ti("nameValue", { name: u, value: l, noValue: a(l) });
          } else {
            var h = this.getGraph().getNodeByIndex(e), c = h.getLayout().value, f = this.getDataParams(e, r).data.name;
            return ti("nameValue", { name: f != null ? f + "" : null, value: c, noValue: a(c) });
          }
        }, t.prototype.optionUpdated = function() {
        }, t.prototype.getDataParams = function(e, i) {
          var r = n.prototype.getDataParams.call(this, e, i);
          if (r.value == null && i === "node") {
            var a = this.getGraph().getNodeByIndex(e), o = a.getLayout().value;
            r.value = o;
          }
          return r;
        }, t.type = "series.sankey", t.defaultOption = { z: 2, coordinateSystem: "view", left: "5%", top: "5%", right: "20%", bottom: "5%", orient: "horizontal", nodeWidth: 20, nodeGap: 8, draggable: true, layoutIterations: 32, label: { show: true, position: "right", fontSize: 12 }, edgeLabel: { show: false, fontSize: 12 }, levels: [], nodeAlign: "justify", lineStyle: { color: "#314656", opacity: 0.2, curveness: 0.5 }, emphasis: { label: { show: true }, lineStyle: { opacity: 0.5 } }, select: { itemStyle: { borderColor: "#212121" } }, animationEasing: "linear", animationDuration: 1e3 }, t;
      }(tn);
      function WRt(n, t) {
        n.eachSeriesByType("sankey", function(e) {
          var i = e.get("nodeWidth"), r = e.get("nodeGap"), a = XRt(e, t);
          e.layoutInfo = a;
          var o = a.width, s = a.height, l = e.getGraph(), u = l.nodes, h = l.edges;
          ZRt(u);
          var c = Fe(u, function(A) {
            return A.getLayout().value === 0;
          }), f = c.length !== 0 ? 0 : e.get("layoutIterations"), g = e.get("orient"), d = e.get("nodeAlign");
          $Rt(u, h, i, r, o, s, f, g, d);
        });
      }
      function XRt(n, t) {
        return Yn(n.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() });
      }
      function $Rt(n, t, e, i, r, a, o, s, l) {
        KRt(n, t, e, r, a, s, l), nLt(n, t, a, r, i, o, s), cLt(n, s);
      }
      function ZRt(n) {
        D(n, function(t) {
          var e = wu(t.outEdges, dI), i = wu(t.inEdges, dI), r = t.getValue() || 0, a = Math.max(e, i, r);
          t.setLayout({ value: a }, true);
        });
      }
      function KRt(n, t, e, i, r, a, o) {
        for (var s = [], l = [], u = [], h = [], c = 0, f = 0; f < t.length; f++) s[f] = 1;
        for (var f = 0; f < n.length; f++) l[f] = n[f].inEdges.length, l[f] === 0 && u.push(n[f]);
        for (var g = -1; u.length; ) {
          for (var d = 0; d < u.length; d++) {
            var A = u[d], p = A.hostGraph.data.getRawDataItem(A.dataIndex), v = p.depth != null && p.depth >= 0;
            v && p.depth > g && (g = p.depth), A.setLayout({ depth: v ? p.depth : c }, true), a === "vertical" ? A.setLayout({ dy: e }, true) : A.setLayout({ dx: e }, true);
            for (var y = 0; y < A.outEdges.length; y++) {
              var m = A.outEdges[y], _ = t.indexOf(m);
              s[_] = 0;
              var I = m.node2, E = n.indexOf(I);
              --l[E] === 0 && h.indexOf(I) < 0 && h.push(I);
            }
          }
          ++c, u = h, h = [];
        }
        for (var f = 0; f < s.length; f++) if (s[f] === 1) throw new Error("Sankey is a DAG, the original data has cycle!");
        var x = g > c - 1 ? g : c - 1;
        o && o !== "left" && JRt(n, o, a, x);
        var w = a === "vertical" ? (r - e) / x : (i - e) / x;
        eLt(n, w, a);
      }
      function Z7(n) {
        var t = n.hostGraph.data.getRawDataItem(n.dataIndex);
        return t.depth != null && t.depth >= 0;
      }
      function JRt(n, t, e, i) {
        if (t === "right") {
          for (var r = [], a = n, o = 0; a.length; ) {
            for (var s = 0; s < a.length; s++) {
              var l = a[s];
              l.setLayout({ skNodeHeight: o }, true);
              for (var u = 0; u < l.inEdges.length; u++) {
                var h = l.inEdges[u];
                r.indexOf(h.node1) < 0 && r.push(h.node1);
              }
            }
            a = r, r = [], ++o;
          }
          D(n, function(c) {
            Z7(c) || c.setLayout({ depth: Math.max(0, i - c.getLayout().skNodeHeight) }, true);
          });
        } else t === "justify" && tLt(n, i);
      }
      function tLt(n, t) {
        D(n, function(e) {
          !Z7(e) && !e.outEdges.length && e.setLayout({ depth: t }, true);
        });
      }
      function eLt(n, t, e) {
        D(n, function(i) {
          var r = i.getLayout().depth * t;
          e === "vertical" ? i.setLayout({ y: r }, true) : i.setLayout({ x: r }, true);
        });
      }
      function nLt(n, t, e, i, r, a, o) {
        var s = iLt(n, o);
        rLt(s, t, e, i, r, o), dR(s, r, e, i, o);
        for (var l = 1; a > 0; a--) l *= 0.99, aLt(s, l, o), dR(s, r, e, i, o), hLt(s, l, o), dR(s, r, e, i, o);
      }
      function iLt(n, t) {
        var e = [], i = t === "vertical" ? "y" : "x", r = xT(n, function(a) {
          return a.getLayout()[i];
        });
        return r.keys.sort(function(a, o) {
          return a - o;
        }), D(r.keys, function(a) {
          e.push(r.buckets.get(a));
        }), e;
      }
      function rLt(n, t, e, i, r, a) {
        var o = 1 / 0;
        D(n, function(s) {
          var l = s.length, u = 0;
          D(s, function(c) {
            u += c.getLayout().value;
          });
          var h = a === "vertical" ? (i - (l - 1) * r) / u : (e - (l - 1) * r) / u;
          h < o && (o = h);
        }), D(n, function(s) {
          D(s, function(l, u) {
            var h = l.getLayout().value * o;
            a === "vertical" ? (l.setLayout({ x: u }, true), l.setLayout({ dx: h }, true)) : (l.setLayout({ y: u }, true), l.setLayout({ dy: h }, true));
          });
        }), D(t, function(s) {
          var l = +s.getValue() * o;
          s.setLayout({ dy: l }, true);
        });
      }
      function dR(n, t, e, i, r) {
        var a = r === "vertical" ? "x" : "y";
        D(n, function(o) {
          o.sort(function(A, p) {
            return A.getLayout()[a] - p.getLayout()[a];
          });
          for (var s, l, u, h = 0, c = o.length, f = r === "vertical" ? "dx" : "dy", g = 0; g < c; g++) l = o[g], u = h - l.getLayout()[a], u > 0 && (s = l.getLayout()[a] + u, r === "vertical" ? l.setLayout({ x: s }, true) : l.setLayout({ y: s }, true)), h = l.getLayout()[a] + l.getLayout()[f] + t;
          var d = r === "vertical" ? i : e;
          if (u = h - t - d, u > 0) {
            s = l.getLayout()[a] - u, r === "vertical" ? l.setLayout({ x: s }, true) : l.setLayout({ y: s }, true), h = s;
            for (var g = c - 2; g >= 0; --g) l = o[g], u = l.getLayout()[a] + l.getLayout()[f] + t - h, u > 0 && (s = l.getLayout()[a] - u, r === "vertical" ? l.setLayout({ x: s }, true) : l.setLayout({ y: s }, true)), h = l.getLayout()[a];
          }
        });
      }
      function aLt(n, t, e) {
        D(n.slice().reverse(), function(i) {
          D(i, function(r) {
            if (r.outEdges.length) {
              var a = wu(r.outEdges, oLt, e) / wu(r.outEdges, dI);
              if (isNaN(a)) {
                var o = r.outEdges.length;
                a = o ? wu(r.outEdges, sLt, e) / o : 0;
              }
              if (e === "vertical") {
                var s = r.getLayout().x + (a - xu(r, e)) * t;
                r.setLayout({ x: s }, true);
              } else {
                var l = r.getLayout().y + (a - xu(r, e)) * t;
                r.setLayout({ y: l }, true);
              }
            }
          });
        });
      }
      function oLt(n, t) {
        return xu(n.node2, t) * n.getValue();
      }
      function sLt(n, t) {
        return xu(n.node2, t);
      }
      function lLt(n, t) {
        return xu(n.node1, t) * n.getValue();
      }
      function uLt(n, t) {
        return xu(n.node1, t);
      }
      function xu(n, t) {
        return t === "vertical" ? n.getLayout().x + n.getLayout().dx / 2 : n.getLayout().y + n.getLayout().dy / 2;
      }
      function dI(n) {
        return n.getValue();
      }
      function wu(n, t, e) {
        for (var i = 0, r = n.length, a = -1; ++a < r; ) {
          var o = +t(n[a], e);
          isNaN(o) || (i += o);
        }
        return i;
      }
      function hLt(n, t, e) {
        D(n, function(i) {
          D(i, function(r) {
            if (r.inEdges.length) {
              var a = wu(r.inEdges, lLt, e) / wu(r.inEdges, dI);
              if (isNaN(a)) {
                var o = r.inEdges.length;
                a = o ? wu(r.inEdges, uLt, e) / o : 0;
              }
              if (e === "vertical") {
                var s = r.getLayout().x + (a - xu(r, e)) * t;
                r.setLayout({ x: s }, true);
              } else {
                var l = r.getLayout().y + (a - xu(r, e)) * t;
                r.setLayout({ y: l }, true);
              }
            }
          });
        });
      }
      function cLt(n, t) {
        var e = t === "vertical" ? "x" : "y";
        D(n, function(i) {
          i.outEdges.sort(function(r, a) {
            return r.node2.getLayout()[e] - a.node2.getLayout()[e];
          }), i.inEdges.sort(function(r, a) {
            return r.node1.getLayout()[e] - a.node1.getLayout()[e];
          });
        }), D(n, function(i) {
          var r = 0, a = 0;
          D(i.outEdges, function(o) {
            o.setLayout({ sy: r }, true), r += o.getLayout().dy;
          }), D(i.inEdges, function(o) {
            o.setLayout({ ty: a }, true), a += o.getLayout().dy;
          });
        });
      }
      function fLt(n) {
        n.eachSeriesByType("sankey", function(t) {
          var e = t.getGraph(), i = e.nodes, r = e.edges;
          if (i.length) {
            var a = 1 / 0, o = -1 / 0;
            D(i, function(s) {
              var l = s.getLayout().value;
              l < a && (a = l), l > o && (o = l);
            }), D(i, function(s) {
              var l = new ni({ type: "color", mappingMethod: "linear", dataExtent: [a, o], visual: t.get("color") }), u = l.mapValueToVisual(s.getLayout().value), h = s.getModel().get(["itemStyle", "color"]);
              h != null ? (s.setVisual("color", h), s.setVisual("style", { fill: h })) : (s.setVisual("color", u), s.setVisual("style", { fill: u }));
            });
          }
          r.length && D(r, function(s) {
            var l = s.getModel().get("lineStyle");
            s.setVisual("style", l);
          });
        });
      }
      function gLt(n) {
        n.registerChartView(qRt), n.registerSeriesModel(YRt), n.registerLayout(WRt), n.registerVisual(fLt), n.registerAction({ type: "dragNode", event: "dragnode", update: "update" }, function(t, e) {
          e.eachComponent({ mainType: "series", subType: "sankey", query: t }, function(i) {
            i.setNodePosition(t.dataIndex, [t.localX, t.localY]);
          });
        });
      }
      var K7 = function() {
        function n() {
        }
        return n.prototype.getInitialData = function(t, e) {
          var i, r = e.getComponent("xAxis", this.get("xAxisIndex")), a = e.getComponent("yAxis", this.get("yAxisIndex")), o = r.get("type"), s = a.get("type"), l;
          o === "category" ? (t.layout = "horizontal", i = r.getOrdinalMeta(), l = true) : s === "category" ? (t.layout = "vertical", i = a.getOrdinalMeta(), l = true) : t.layout = t.layout || "horizontal";
          var u = ["x", "y"], h = t.layout === "horizontal" ? 0 : 1, c = this._baseAxisDim = u[h], f = u[1 - h], g = [r, a], d = g[h].get("type"), A = g[1 - h].get("type"), p = t.data;
          if (p && l) {
            var v = [];
            D(p, function(_, I) {
              var E;
              Z(_) ? (E = _.slice(), _.unshift(I)) : Z(_.value) ? (E = X({}, _), E.value = E.value.slice(), _.value.unshift(I)) : E = _, v.push(E);
            }), t.data = v;
          }
          var y = this.defaultValueDimensions, m = [{ name: c, type: wE(d), ordinalMeta: i, otherDims: { tooltip: false, itemName: 0 }, dimsDef: ["base"] }, { name: f, type: wE(A), dimsDef: y.slice() }];
          return vd(this, { coordDimensions: m, dimensionsCount: y.length + 1, encodeDefaulter: Gt(d6, m, this) });
        }, n.prototype.getBaseAxis = function() {
          var t = this._baseAxisDim;
          return this.ecModel.getComponent(t + "Axis", this.get(t + "AxisIndex")).axis;
        }, n;
      }(), J7 = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.defaultValueDimensions = [{ name: "min", defaultTooltip: true }, { name: "Q1", defaultTooltip: true }, { name: "median", defaultTooltip: true }, { name: "Q3", defaultTooltip: true }, { name: "max", defaultTooltip: true }], e.visualDrawType = "stroke", e;
        }
        return t.type = "series.boxplot", t.dependencies = ["xAxis", "yAxis", "grid"], t.defaultOption = { z: 2, coordinateSystem: "cartesian2d", legendHoverLink: true, layout: null, boxWidth: [7, 50], itemStyle: { color: "#fff", borderWidth: 1 }, emphasis: { scale: true, itemStyle: { borderWidth: 2, shadowBlur: 5, shadowOffsetX: 1, shadowOffsetY: 1, shadowColor: "rgba(0,0,0,0.2)" } }, animationDuration: 800 }, t;
      }(tn);
      kn(J7, K7, true);
      var dLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = e.getData(), o = this.group, s = this._data;
          this._data || o.removeAll();
          var l = e.get("layout") === "horizontal" ? 1 : 0;
          a.diff(s).add(function(u) {
            if (a.hasValue(u)) {
              var h = a.getItemLayout(u), c = tH(h, a, u, l, true);
              a.setItemGraphicEl(u, c), o.add(c);
            }
          }).update(function(u, h) {
            var c = s.getItemGraphicEl(h);
            if (!a.hasValue(u)) {
              o.remove(c);
              return;
            }
            var f = a.getItemLayout(u);
            c ? (to(c), eH(f, c, a, u)) : c = tH(f, a, u, l), o.add(c), a.setItemGraphicEl(u, c);
          }).remove(function(u) {
            var h = s.getItemGraphicEl(u);
            h && o.remove(h);
          }).execute(), this._data = a;
        }, t.prototype.remove = function(e) {
          var i = this.group, r = this._data;
          this._data = null, r && r.eachItemGraphicEl(function(a) {
            a && i.remove(a);
          });
        }, t.type = "boxplot", t;
      }(qe), ALt = /* @__PURE__ */ function() {
        function n() {
        }
        return n;
      }(), pLt = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "boxplotBoxPath", i;
        }
        return t.prototype.getDefaultShape = function() {
          return new ALt();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.points, a = 0;
          for (e.moveTo(r[a][0], r[a][1]), a++; a < 4; a++) e.lineTo(r[a][0], r[a][1]);
          for (e.closePath(); a < r.length; a++) e.moveTo(r[a][0], r[a][1]), a++, e.lineTo(r[a][0], r[a][1]);
        }, t;
      }(ne);
      function tH(n, t, e, i, r) {
        var a = n.ends, o = new pLt({ shape: { points: r ? vLt(a, i, n) : a } });
        return eH(n, o, t, e, r), o;
      }
      function eH(n, t, e, i, r) {
        var a = e.hostModel, o = Wh[r ? "initProps" : "updateProps"];
        o(t, { shape: { points: n.ends } }, a, i), t.useStyle(e.getItemVisual(i, "style")), t.style.strokeNoScale = true, t.z2 = 100;
        var s = e.getItemModel(i), l = s.getModel("emphasis");
        Ii(t, s), pn(t, l.get("focus"), l.get("blurScope"), l.get("disabled"));
      }
      function vLt(n, t, e) {
        return K(n, function(i) {
          return i = i.slice(), i[t] = e.initBaseline, i;
        });
      }
      var _y = D;
      function yLt(n) {
        var t = mLt(n);
        _y(t, function(e) {
          var i = e.seriesModels;
          i.length && (_Lt(e), _y(i, function(r, a) {
            ELt(r, e.boxOffsetList[a], e.boxWidthList[a]);
          }));
        });
      }
      function mLt(n) {
        var t = [], e = [];
        return n.eachSeriesByType("boxplot", function(i) {
          var r = i.getBaseAxis(), a = $t(e, r);
          a < 0 && (a = e.length, e[a] = r, t[a] = { axis: r, seriesModels: [] }), t[a].seriesModels.push(i);
        }), t;
      }
      function _Lt(n) {
        var t = n.axis, e = n.seriesModels, i = e.length, r = n.boxWidthList = [], a = n.boxOffsetList = [], o = [], s;
        if (t.type === "category") s = t.getBandWidth();
        else {
          var l = 0;
          _y(e, function(d) {
            l = Math.max(l, d.getData().count());
          });
          var u = t.getExtent();
          s = Math.abs(u[1] - u[0]) / l;
        }
        _y(e, function(d) {
          var A = d.get("boxWidth");
          Z(A) || (A = [A, A]), o.push([st(A[0], s) || 0, st(A[1], s) || 0]);
        });
        var h = s * 0.8 - 2, c = h / i * 0.3, f = (h - c * (i - 1)) / i, g = f / 2 - h / 2;
        _y(e, function(d, A) {
          a.push(g), g += c + f, r.push(Math.min(Math.max(f, o[A][0]), o[A][1]));
        });
      }
      function ELt(n, t, e) {
        var i = n.coordinateSystem, r = n.getData(), a = e / 2, o = n.get("layout") === "horizontal" ? 0 : 1, s = 1 - o, l = ["x", "y"], u = r.mapDimension(l[o]), h = r.mapDimensionsAll(l[s]);
        if (u == null || h.length < 5) return;
        for (var c = 0; c < r.count(); c++) {
          var f = r.get(u, c), g = m(f, h[2], c), d = m(f, h[0], c), A = m(f, h[1], c), p = m(f, h[3], c), v = m(f, h[4], c), y = [];
          _(y, A, false), _(y, p, true), y.push(d, A, v, p), I(y, d), I(y, v), I(y, g), r.setItemLayout(c, { initBaseline: g[s], ends: y });
        }
        function m(E, x, w) {
          var C = r.get(x, w), S = [];
          S[o] = E, S[s] = C;
          var b;
          return isNaN(E) || isNaN(C) ? b = [NaN, NaN] : (b = i.dataToPoint(S), b[o] += t), b;
        }
        function _(E, x, w) {
          var C = x.slice(), S = x.slice();
          C[o] += a, S[o] -= a, w ? E.push(C, S) : E.push(S, C);
        }
        function I(E, x) {
          var w = x.slice(), C = x.slice();
          w[o] -= a, C[o] += a, E.push(w, C);
        }
      }
      function ILt(n, t) {
        t = t || {};
        for (var e = [], i = [], r = t.boundIQR, a = r === "none" || r === 0, o = 0; o < n.length; o++) {
          var s = va(n[o].slice()), l = mT(s, 0.25), u = mT(s, 0.5), h = mT(s, 0.75), c = s[0], f = s[s.length - 1], g = (r == null ? 1.5 : r) * (h - l), d = a ? c : Math.max(c, l - g), A = a ? f : Math.min(f, h + g), p = t.itemNameFormatter, v = yt(p) ? p({ value: o }) : ht(p) ? p.replace("{value}", o + "") : o + "";
          e.push([v, d, l, u, h, A]);
          for (var y = 0; y < s.length; y++) {
            var m = s[y];
            if (m < d || m > A) {
              var _ = [v, m];
              i.push(_);
            }
          }
        }
        return { boxData: e, outliers: i };
      }
      var xLt = { type: "echarts:boxplot", transform: function(t) {
        var e = t.upstream;
        if (e.sourceFormat !== Ni) {
          var i = "";
          i = Ir("source data is not applicable for this boxplot transform. Expect number[][]."), be(i);
        }
        var r = ILt(e.getRawData(), t.config);
        return [{ dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"], data: r.boxData }, { data: r.outliers }];
      } };
      function wLt(n) {
        n.registerSeriesModel(J7), n.registerChartView(dLt), n.registerLayout(yLt), n.registerTransform(xLt);
      }
      var CLt = ["color", "borderColor"], SLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(e), this._isLargeDraw ? this._renderLarge(e) : this._renderNormal(e);
        }, t.prototype.incrementalPrepareRender = function(e, i, r) {
          this._clear(), this._updateDrawMode(e);
        }, t.prototype.incrementalRender = function(e, i, r, a) {
          this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(e, i) : this._incrementalRenderNormal(e, i);
        }, t.prototype.eachRendered = function(e) {
          hu(this._progressiveEls || this.group, e);
        }, t.prototype._updateDrawMode = function(e) {
          var i = e.pipelineContext.large;
          (this._isLargeDraw == null || i !== this._isLargeDraw) && (this._isLargeDraw = i, this._clear());
        }, t.prototype._renderNormal = function(e) {
          var i = e.getData(), r = this._data, a = this.group, o = i.getLayout("isSimpleBox"), s = e.get("clip", true), l = e.coordinateSystem, u = l.getArea && l.getArea();
          this._data || a.removeAll(), i.diff(r).add(function(h) {
            if (i.hasValue(h)) {
              var c = i.getItemLayout(h);
              if (s && nH(u, c)) return;
              var f = AR(c, h, true);
              on(f, { shape: { points: c.ends } }, e, h), pR(f, i, h, o), a.add(f), i.setItemGraphicEl(h, f);
            }
          }).update(function(h, c) {
            var f = r.getItemGraphicEl(c);
            if (!i.hasValue(h)) {
              a.remove(f);
              return;
            }
            var g = i.getItemLayout(h);
            if (s && nH(u, g)) {
              a.remove(f);
              return;
            }
            f ? (Ee(f, { shape: { points: g.ends } }, e, h), to(f)) : f = AR(g), pR(f, i, h, o), a.add(f), i.setItemGraphicEl(h, f);
          }).remove(function(h) {
            var c = r.getItemGraphicEl(h);
            c && a.remove(c);
          }).execute(), this._data = i;
        }, t.prototype._renderLarge = function(e) {
          this._clear(), iH(e, this.group);
          var i = e.get("clip", true) ? Kv(e.coordinateSystem, false, e) : null;
          i ? this.group.setClipPath(i) : this.group.removeClipPath();
        }, t.prototype._incrementalRenderNormal = function(e, i) {
          for (var r = i.getData(), a = r.getLayout("isSimpleBox"), o; (o = e.next()) != null; ) {
            var s = r.getItemLayout(o), l = AR(s);
            pR(l, r, o, a), l.incremental = true, this.group.add(l), this._progressiveEls.push(l);
          }
        }, t.prototype._incrementalRenderLarge = function(e, i) {
          iH(i, this.group, this._progressiveEls, true);
        }, t.prototype.remove = function(e) {
          this._clear();
        }, t.prototype._clear = function() {
          this.group.removeAll(), this._data = null;
        }, t.type = "candlestick", t;
      }(qe), bLt = /* @__PURE__ */ function() {
        function n() {
        }
        return n;
      }(), TLt = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "normalCandlestickBox", i;
        }
        return t.prototype.getDefaultShape = function() {
          return new bLt();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.points;
          this.__simpleBox ? (e.moveTo(r[4][0], r[4][1]), e.lineTo(r[6][0], r[6][1])) : (e.moveTo(r[0][0], r[0][1]), e.lineTo(r[1][0], r[1][1]), e.lineTo(r[2][0], r[2][1]), e.lineTo(r[3][0], r[3][1]), e.closePath(), e.moveTo(r[4][0], r[4][1]), e.lineTo(r[5][0], r[5][1]), e.moveTo(r[6][0], r[6][1]), e.lineTo(r[7][0], r[7][1]));
        }, t;
      }(ne);
      function AR(n, t, e) {
        var i = n.ends;
        return new TLt({ shape: { points: e ? BLt(i, n) : i }, z2: 100 });
      }
      function nH(n, t) {
        for (var e = true, i = 0; i < t.ends.length; i++) if (n.contain(t.ends[i][0], t.ends[i][1])) {
          e = false;
          break;
        }
        return e;
      }
      function pR(n, t, e, i) {
        var r = t.getItemModel(e);
        n.useStyle(t.getItemVisual(e, "style")), n.style.strokeNoScale = true, n.__simpleBox = i, Ii(n, r);
      }
      function BLt(n, t) {
        return K(n, function(e) {
          return e = e.slice(), e[1] = t.initBaseline, e;
        });
      }
      var MLt = /* @__PURE__ */ function() {
        function n() {
        }
        return n;
      }(), vR = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i.type = "largeCandlestickBox", i;
        }
        return t.prototype.getDefaultShape = function() {
          return new MLt();
        }, t.prototype.buildPath = function(e, i) {
          for (var r = i.points, a = 0; a < r.length; ) if (this.__sign === r[a++]) {
            var o = r[a++];
            e.moveTo(o, r[a++]), e.lineTo(o, r[a++]);
          } else a += 3;
        }, t;
      }(ne);
      function iH(n, t, e, i) {
        var r = n.getData(), a = r.getLayout("largePoints"), o = new vR({ shape: { points: a }, __sign: 1, ignoreCoarsePointer: true });
        t.add(o);
        var s = new vR({ shape: { points: a }, __sign: -1, ignoreCoarsePointer: true });
        t.add(s);
        var l = new vR({ shape: { points: a }, __sign: 0, ignoreCoarsePointer: true });
        t.add(l), yR(1, o, n), yR(-1, s, n), yR(0, l, n), i && (o.incremental = true, s.incremental = true), e && e.push(o, s);
      }
      function yR(n, t, e, i) {
        var r = e.get(["itemStyle", n > 0 ? "borderColor" : "borderColor0"]) || e.get(["itemStyle", n > 0 ? "color" : "color0"]);
        n === 0 && (r = e.get(["itemStyle", "borderColorDoji"]));
        var a = e.getModel("itemStyle").getItemStyle(CLt);
        t.useStyle(a), t.style.fill = null, t.style.stroke = r;
      }
      var rH = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.defaultValueDimensions = [{ name: "open", defaultTooltip: true }, { name: "close", defaultTooltip: true }, { name: "lowest", defaultTooltip: true }, { name: "highest", defaultTooltip: true }], e;
        }
        return t.prototype.getShadowDim = function() {
          return "open";
        }, t.prototype.brushSelector = function(e, i, r) {
          var a = i.getItemLayout(e);
          return a && r.rect(a.brushRect);
        }, t.type = "series.candlestick", t.dependencies = ["xAxis", "yAxis", "grid"], t.defaultOption = { z: 2, coordinateSystem: "cartesian2d", legendHoverLink: true, layout: null, clip: true, itemStyle: { color: "#eb5454", color0: "#47b262", borderColor: "#eb5454", borderColor0: "#47b262", borderColorDoji: null, borderWidth: 1 }, emphasis: { scale: true, itemStyle: { borderWidth: 2 } }, barMaxWidth: null, barMinWidth: null, barWidth: null, large: true, largeThreshold: 600, progressive: 3e3, progressiveThreshold: 1e4, progressiveChunkMode: "mod", animationEasing: "linear", animationDuration: 300 }, t;
      }(tn);
      kn(rH, K7, true);
      function DLt(n) {
        !n || !Z(n.series) || D(n.series, function(t) {
          Et(t) && t.type === "k" && (t.type = "candlestick");
        });
      }
      var RLt = ["itemStyle", "borderColor"], LLt = ["itemStyle", "borderColor0"], PLt = ["itemStyle", "borderColorDoji"], NLt = ["itemStyle", "color"], FLt = ["itemStyle", "color0"], kLt = { seriesType: "candlestick", plan: rd(), performRawSeries: true, reset: function(n, t) {
        function e(a, o) {
          return o.get(a > 0 ? NLt : FLt);
        }
        function i(a, o) {
          return o.get(a === 0 ? PLt : a > 0 ? RLt : LLt);
        }
        if (!t.isSeriesFiltered(n)) {
          var r = n.pipelineContext.large;
          return !r && { progress: function(a, o) {
            for (var s; (s = a.next()) != null; ) {
              var l = o.getItemModel(s), u = o.getItemLayout(s).sign, h = l.getItemStyle();
              h.fill = e(u, l), h.stroke = i(u, l) || h.fill;
              var c = o.ensureUniqueItemVisual(s, "style");
              X(c, h);
            }
          } };
        }
      } }, OLt = { seriesType: "candlestick", plan: rd(), reset: function(n) {
        var t = n.coordinateSystem, e = n.getData(), i = QLt(n, e), r = 0, a = 1, o = ["x", "y"], s = e.getDimensionIndex(e.mapDimension(o[r])), l = K(e.mapDimensionsAll(o[a]), e.getDimensionIndex, e), u = l[0], h = l[1], c = l[2], f = l[3];
        if (e.setLayout({ candleWidth: i, isSimpleBox: i <= 1.3 }), s < 0 || l.length < 4) return;
        return { progress: n.pipelineContext.large ? d : g };
        function g(A, p) {
          for (var v, y = p.getStore(); (v = A.next()) != null; ) {
            var m = y.get(s, v), _ = y.get(u, v), I = y.get(h, v), E = y.get(c, v), x = y.get(f, v), w = Math.min(_, I), C = Math.max(_, I), S = N(w, m), b = N(C, m), T = N(E, m), B = N(x, m), R = [];
            F(R, b, 0), F(R, S, 1), R.push(O(B), O(b), O(T), O(S));
            var M = p.getItemModel(v), L = !!M.get(["itemStyle", "borderColorDoji"]);
            p.setItemLayout(v, { sign: aH(y, v, _, I, h, L), initBaseline: _ > I ? b[a] : S[a], ends: R, brushRect: k(E, x, m) });
          }
          function N(Q, j) {
            var Y = [];
            return Y[r] = j, Y[a] = Q, isNaN(j) || isNaN(Q) ? [NaN, NaN] : t.dataToPoint(Y);
          }
          function F(Q, j, Y) {
            var G = j.slice(), $ = j.slice();
            G[r] = U1(G[r] + i / 2, 1, false), $[r] = U1($[r] - i / 2, 1, true), Y ? Q.push(G, $) : Q.push($, G);
          }
          function k(Q, j, Y) {
            var G = N(Q, Y), $ = N(j, Y);
            return G[r] -= i / 2, $[r] -= i / 2, { x: G[0], y: G[1], width: i, height: $[1] - G[1] };
          }
          function O(Q) {
            return Q[r] = U1(Q[r], 1), Q;
          }
        }
        function d(A, p) {
          for (var v = ns(A.count * 4), y = 0, m, _ = [], I = [], E, x = p.getStore(), w = !!n.get(["itemStyle", "borderColorDoji"]); (E = A.next()) != null; ) {
            var C = x.get(s, E), S = x.get(u, E), b = x.get(h, E), T = x.get(c, E), B = x.get(f, E);
            if (isNaN(C) || isNaN(T) || isNaN(B)) {
              v[y++] = NaN, y += 3;
              continue;
            }
            v[y++] = aH(x, E, S, b, h, w), _[r] = C, _[a] = T, m = t.dataToPoint(_, null, I), v[y++] = m ? m[0] : NaN, v[y++] = m ? m[1] : NaN, _[a] = B, m = t.dataToPoint(_, null, I), v[y++] = m ? m[1] : NaN;
          }
          p.setLayout("largePoints", v);
        }
      } };
      function aH(n, t, e, i, r, a) {
        var o;
        return e > i ? o = -1 : e < i ? o = 1 : o = a ? 0 : t > 0 ? n.get(r, t - 1) <= i ? 1 : -1 : 1, o;
      }
      function QLt(n, t) {
        var e = n.getBaseAxis(), i, r = e.type === "category" ? e.getBandWidth() : (i = e.getExtent(), Math.abs(i[1] - i[0]) / t.count()), a = st(kt(n.get("barMaxWidth"), r), r), o = st(kt(n.get("barMinWidth"), 1), r), s = n.get("barWidth");
        return s != null ? st(s, r) : Math.max(Math.min(r / 2, a), o);
      }
      function zLt(n) {
        n.registerChartView(SLt), n.registerSeriesModel(rH), n.registerPreprocessor(DLt), n.registerVisual(kLt), n.registerLayout(OLt);
      }
      function oH(n, t) {
        var e = t.rippleEffectColor || t.color;
        n.eachChild(function(i) {
          i.attr({ z: t.z, zlevel: t.zlevel, style: { stroke: t.brushType === "stroke" ? e : null, fill: t.brushType === "fill" ? e : null } });
        });
      }
      var GLt = function(n) {
        V(t, n);
        function t(e, i) {
          var r = n.call(this) || this, a = new $v(e, i), o = new Dt();
          return r.add(a), r.add(o), r.updateData(e, i), r;
        }
        return t.prototype.stopEffectAnimation = function() {
          this.childAt(1).removeAll();
        }, t.prototype.startEffectAnimation = function(e) {
          for (var i = e.symbolType, r = e.color, a = e.rippleNumber, o = this.childAt(1), s = 0; s < a; s++) {
            var l = Un(i, -1, -1, 2, 2, r);
            l.attr({ style: { strokeNoScale: true }, z2: 99, silent: true, scaleX: 0.5, scaleY: 0.5 });
            var u = -s / a * e.period + e.effectOffset;
            l.animate("", true).when(e.period, { scaleX: e.rippleScale / 2, scaleY: e.rippleScale / 2 }).delay(u).start(), l.animateStyle(true).when(e.period, { opacity: 0 }).delay(u).start(), o.add(l);
          }
          oH(o, e);
        }, t.prototype.updateEffectAnimation = function(e) {
          for (var i = this._effectCfg, r = this.childAt(1), a = ["symbolType", "period", "rippleScale", "rippleNumber"], o = 0; o < a.length; o++) {
            var s = a[o];
            if (i[s] !== e[s]) {
              this.stopEffectAnimation(), this.startEffectAnimation(e);
              return;
            }
          }
          oH(r, e);
        }, t.prototype.highlight = function() {
          Ws(this);
        }, t.prototype.downplay = function() {
          Xs(this);
        }, t.prototype.getSymbolType = function() {
          var e = this.childAt(0);
          return e && e.getSymbolType();
        }, t.prototype.updateData = function(e, i) {
          var r = this, a = e.hostModel;
          this.childAt(0).updateData(e, i);
          var o = this.childAt(1), s = e.getItemModel(i), l = e.getItemVisual(i, "symbol"), u = sd(e.getItemVisual(i, "symbolSize")), h = e.getItemVisual(i, "style"), c = h && h.fill, f = s.getModel("emphasis");
          o.setScale(u), o.traverse(function(p) {
            p.setStyle("fill", c);
          });
          var g = nc(e.getItemVisual(i, "symbolOffset"), u);
          g && (o.x = g[0], o.y = g[1]);
          var d = e.getItemVisual(i, "symbolRotate");
          o.rotation = (d || 0) * Math.PI / 180 || 0;
          var A = {};
          A.showEffectOn = a.get("showEffectOn"), A.rippleScale = s.get(["rippleEffect", "scale"]), A.brushType = s.get(["rippleEffect", "brushType"]), A.period = s.get(["rippleEffect", "period"]) * 1e3, A.effectOffset = i / e.count(), A.z = a.getShallow("z") || 0, A.zlevel = a.getShallow("zlevel") || 0, A.symbolType = l, A.color = c, A.rippleEffectColor = s.get(["rippleEffect", "color"]), A.rippleNumber = s.get(["rippleEffect", "number"]), A.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(A) : this.startEffectAnimation(A), this._effectCfg = A) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(p) {
            p === "emphasis" ? A.showEffectOn !== "render" && r.startEffectAnimation(A) : p === "normal" && A.showEffectOn !== "render" && r.stopEffectAnimation();
          }), this._effectCfg = A, pn(this, f.get("focus"), f.get("blurScope"), f.get("disabled"));
        }, t.prototype.fadeOut = function(e) {
          e && e();
        }, t;
      }(Dt), ULt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function() {
          this._symbolDraw = new Zv(GLt);
        }, t.prototype.render = function(e, i, r) {
          var a = e.getData(), o = this._symbolDraw;
          o.updateData(a, { clipShape: this._getClipShape(e) }), this.group.add(o.group);
        }, t.prototype._getClipShape = function(e) {
          var i = e.coordinateSystem, r = i && i.getArea && i.getArea();
          return e.get("clip", true) ? r : null;
        }, t.prototype.updateTransform = function(e, i, r) {
          var a = e.getData();
          this.group.dirty();
          var o = Jv("").reset(e, i, r);
          o.progress && o.progress({ start: 0, end: a.count(), count: a.count() }, a), this._symbolDraw.updateLayout();
        }, t.prototype._updateGroupTransform = function(e) {
          var i = e.coordinateSystem;
          i && i.getRoamTransform && (this.group.transform = h1t(i.getRoamTransform()), this.group.decomposeTransform());
        }, t.prototype.remove = function(e, i) {
          this._symbolDraw && this._symbolDraw.remove(true);
        }, t.type = "effectScatter", t;
      }(qe), VLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.hasSymbolVisual = true, e;
        }
        return t.prototype.getInitialData = function(e, i) {
          return tl(null, this, { useEncodeDefaulter: true });
        }, t.prototype.brushSelector = function(e, i, r) {
          return r.point(i.getItemLayout(e));
        }, t.type = "series.effectScatter", t.dependencies = ["grid", "polar"], t.defaultOption = { coordinateSystem: "cartesian2d", z: 2, legendHoverLink: true, effectType: "ripple", progressive: 0, showEffectOn: "render", clip: true, rippleEffect: { period: 4, scale: 2.5, brushType: "fill", number: 3 }, universalTransition: { divideShape: "clone" }, symbolSize: 10 }, t;
      }(tn);
      function jLt(n) {
        n.registerChartView(ULt), n.registerSeriesModel(VLt), n.registerLayout(Jv("effectScatter"));
      }
      var sH = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this) || this;
          return a.add(a.createLine(e, i, r)), a._updateEffectSymbol(e, i), a;
        }
        return t.prototype.createLine = function(e, i, r) {
          return new VD(e, i, r);
        }, t.prototype._updateEffectSymbol = function(e, i) {
          var r = e.getItemModel(i), a = r.getModel("effect"), o = a.get("symbolSize"), s = a.get("symbol");
          Z(o) || (o = [o, o]);
          var l = e.getItemVisual(i, "style"), u = a.get("color") || l && l.stroke, h = this.childAt(1);
          this._symbolType !== s && (this.remove(h), h = Un(s, -0.5, -0.5, 1, 1, u), h.z2 = 100, h.culling = true, this.add(h)), h && (h.setStyle("shadowColor", u), h.setStyle(a.getItemStyle(["color"])), h.scaleX = o[0], h.scaleY = o[1], h.setColor(u), this._symbolType = s, this._symbolScale = o, this._updateEffectAnimation(e, a, i));
        }, t.prototype._updateEffectAnimation = function(e, i, r) {
          var a = this.childAt(1);
          if (a) {
            var o = e.getItemLayout(r), s = i.get("period") * 1e3, l = i.get("loop"), u = i.get("roundTrip"), h = i.get("constantSpeed"), c = On(i.get("delay"), function(g) {
              return g / e.count() * s / 3;
            });
            if (a.ignore = true, this._updateAnimationPoints(a, o), h > 0 && (s = this._getLineLength(a) / h * 1e3), s !== this._period || l !== this._loop || u !== this._roundTrip) {
              a.stopAnimation();
              var f = void 0;
              yt(c) ? f = c(r) : f = c, a.__t > 0 && (f = -s * a.__t), this._animateSymbol(a, s, f, l, u);
            }
            this._period = s, this._loop = l, this._roundTrip = u;
          }
        }, t.prototype._animateSymbol = function(e, i, r, a, o) {
          if (i > 0) {
            e.__t = 0;
            var s = this, l = e.animate("", a).when(o ? i * 2 : i, { __t: o ? 2 : 1 }).delay(r).during(function() {
              s._updateSymbolPosition(e);
            });
            a || l.done(function() {
              s.remove(e);
            }), l.start();
          }
        }, t.prototype._getLineLength = function(e) {
          return $l(e.__p1, e.__cp1) + $l(e.__cp1, e.__p2);
        }, t.prototype._updateAnimationPoints = function(e, i) {
          e.__p1 = i[0], e.__p2 = i[1], e.__cp1 = i[2] || [(i[0][0] + i[1][0]) / 2, (i[0][1] + i[1][1]) / 2];
        }, t.prototype.updateData = function(e, i, r) {
          this.childAt(0).updateData(e, i, r), this._updateEffectSymbol(e, i);
        }, t.prototype._updateSymbolPosition = function(e) {
          var i = e.__p1, r = e.__p2, a = e.__cp1, o = e.__t < 1 ? e.__t : 2 - e.__t, s = [e.x, e.y], l = s.slice(), u = fi, h = z2;
          s[0] = u(i[0], a[0], r[0], o), s[1] = u(i[1], a[1], r[1], o);
          var c = e.__t < 1 ? h(i[0], a[0], r[0], o) : h(r[0], a[0], i[0], 1 - o), f = e.__t < 1 ? h(i[1], a[1], r[1], o) : h(r[1], a[1], i[1], 1 - o);
          e.rotation = -Math.atan2(f, c) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (e.__lastT !== void 0 && e.__lastT < e.__t ? (e.scaleY = $l(l, s) * 1.05, o === 1 && (s[0] = l[0] + (s[0] - l[0]) / 2, s[1] = l[1] + (s[1] - l[1]) / 2)) : e.__lastT === 1 ? e.scaleY = 2 * $l(i, s) : e.scaleY = this._symbolScale[1]), e.__lastT = e.__t, e.ignore = false, e.x = s[0], e.y = s[1];
        }, t.prototype.updateLayout = function(e, i) {
          this.childAt(0).updateLayout(e, i);
          var r = e.getItemModel(i).getModel("effect");
          this._updateEffectAnimation(e, r, i);
        }, t;
      }(Dt), lH = function(n) {
        V(t, n);
        function t(e, i, r) {
          var a = n.call(this) || this;
          return a._createPolyline(e, i, r), a;
        }
        return t.prototype._createPolyline = function(e, i, r) {
          var a = e.getItemLayout(i), o = new Ji({ shape: { points: a } });
          this.add(o), this._updateCommonStl(e, i, r);
        }, t.prototype.updateData = function(e, i, r) {
          var a = e.hostModel, o = this.childAt(0), s = { shape: { points: e.getItemLayout(i) } };
          Ee(o, s, a, i), this._updateCommonStl(e, i, r);
        }, t.prototype._updateCommonStl = function(e, i, r) {
          var a = this.childAt(0), o = e.getItemModel(i), s = r && r.emphasisLineStyle, l = r && r.focus, u = r && r.blurScope, h = r && r.emphasisDisabled;
          if (!r || e.hasItemOption) {
            var c = o.getModel("emphasis");
            s = c.getModel("lineStyle").getLineStyle(), h = c.get("disabled"), l = c.get("focus"), u = c.get("blurScope");
          }
          a.useStyle(e.getItemVisual(i, "style")), a.style.fill = null, a.style.strokeNoScale = true;
          var f = a.ensureState("emphasis");
          f.style = s, pn(this, l, u, h);
        }, t.prototype.updateLayout = function(e, i) {
          var r = this.childAt(0);
          r.setShape("points", e.getItemLayout(i));
        }, t;
      }(Dt), qLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e._lastFrame = 0, e._lastFramePercent = 0, e;
        }
        return t.prototype.createLine = function(e, i, r) {
          return new lH(e, i, r);
        }, t.prototype._updateAnimationPoints = function(e, i) {
          this._points = i;
          for (var r = [0], a = 0, o = 1; o < i.length; o++) {
            var s = i[o - 1], l = i[o];
            a += $l(s, l), r.push(a);
          }
          if (a === 0) {
            this._length = 0;
            return;
          }
          for (var o = 0; o < r.length; o++) r[o] /= a;
          this._offsets = r, this._length = a;
        }, t.prototype._getLineLength = function() {
          return this._length;
        }, t.prototype._updateSymbolPosition = function(e) {
          var i = e.__t < 1 ? e.__t : 2 - e.__t, r = this._points, a = this._offsets, o = r.length;
          if (a) {
            var s = this._lastFrame, l;
            if (i < this._lastFramePercent) {
              var u = Math.min(s + 1, o - 1);
              for (l = u; l >= 0 && !(a[l] <= i); l--) ;
              l = Math.min(l, o - 2);
            } else {
              for (l = s; l < o && !(a[l] > i); l++) ;
              l = Math.min(l - 1, o - 2);
            }
            var h = (i - a[l]) / (a[l + 1] - a[l]), c = r[l], f = r[l + 1];
            e.x = c[0] * (1 - h) + h * f[0], e.y = c[1] * (1 - h) + h * f[1];
            var g = e.__t < 1 ? f[0] - c[0] : c[0] - f[0], d = e.__t < 1 ? f[1] - c[1] : c[1] - f[1];
            e.rotation = -Math.atan2(d, g) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = i, e.ignore = false;
          }
        }, t;
      }(sH), HLt = /* @__PURE__ */ function() {
        function n() {
          this.polyline = false, this.curveness = 0, this.segs = [];
        }
        return n;
      }(), YLt = function(n) {
        V(t, n);
        function t(e) {
          var i = n.call(this, e) || this;
          return i._off = 0, i.hoverDataIdx = -1, i;
        }
        return t.prototype.reset = function() {
          this.notClear = false, this._off = 0;
        }, t.prototype.getDefaultStyle = function() {
          return { stroke: "#000", fill: null };
        }, t.prototype.getDefaultShape = function() {
          return new HLt();
        }, t.prototype.buildPath = function(e, i) {
          var r = i.segs, a = i.curveness, o;
          if (i.polyline) for (o = this._off; o < r.length; ) {
            var s = r[o++];
            if (s > 0) {
              e.moveTo(r[o++], r[o++]);
              for (var l = 1; l < s; l++) e.lineTo(r[o++], r[o++]);
            }
          }
          else for (o = this._off; o < r.length; ) {
            var u = r[o++], h = r[o++], c = r[o++], f = r[o++];
            if (e.moveTo(u, h), a > 0) {
              var g = (u + c) / 2 - (h - f) * a, d = (h + f) / 2 - (c - u) * a;
              e.quadraticCurveTo(g, d, c, f);
            } else e.lineTo(c, f);
          }
          this.incremental && (this._off = o, this.notClear = true);
        }, t.prototype.findDataIndex = function(e, i) {
          var r = this.shape, a = r.segs, o = r.curveness, s = this.style.lineWidth;
          if (r.polyline) for (var l = 0, u = 0; u < a.length; ) {
            var h = a[u++];
            if (h > 0) for (var c = a[u++], f = a[u++], g = 1; g < h; g++) {
              var d = a[u++], A = a[u++];
              if (ou(c, f, d, A, s, e, i)) return l;
            }
            l++;
          }
          else for (var l = 0, u = 0; u < a.length; ) {
            var c = a[u++], f = a[u++], d = a[u++], A = a[u++];
            if (o > 0) {
              var p = (c + d) / 2 - (f - A) * o, v = (f + A) / 2 - (d - c) * o;
              if (P4(c, f, p, v, d, A, s, e, i)) return l;
            } else if (ou(c, f, d, A, s, e, i)) return l;
            l++;
          }
          return -1;
        }, t.prototype.contain = function(e, i) {
          var r = this.transformCoordToLocal(e, i), a = this.getBoundingRect();
          if (e = r[0], i = r[1], a.contain(e, i)) {
            var o = this.hoverDataIdx = this.findDataIndex(e, i);
            return o >= 0;
          }
          return this.hoverDataIdx = -1, false;
        }, t.prototype.getBoundingRect = function() {
          var e = this._rect;
          if (!e) {
            for (var i = this.shape, r = i.segs, a = 1 / 0, o = 1 / 0, s = -1 / 0, l = -1 / 0, u = 0; u < r.length; ) {
              var h = r[u++], c = r[u++];
              a = Math.min(h, a), s = Math.max(h, s), o = Math.min(c, o), l = Math.max(c, l);
            }
            e = this._rect = new Wt(a, o, s, l);
          }
          return e;
        }, t;
      }(ne), WLt = function() {
        function n() {
          this.group = new Dt();
        }
        return n.prototype.updateData = function(t) {
          this._clear();
          var e = this._create();
          e.setShape({ segs: t.getLayout("linesPoints") }), this._setCommon(e, t);
        }, n.prototype.incrementalPrepareUpdate = function(t) {
          this.group.removeAll(), this._clear();
        }, n.prototype.incrementalUpdate = function(t, e) {
          var i = this._newAdded[0], r = e.getLayout("linesPoints"), a = i && i.shape.segs;
          if (a && a.length < 2e4) {
            var o = a.length, s = new Float32Array(o + r.length);
            s.set(a), s.set(r, o), i.setShape({ segs: s });
          } else {
            this._newAdded = [];
            var l = this._create();
            l.incremental = true, l.setShape({ segs: r }), this._setCommon(l, e), l.__startIndex = t.start;
          }
        }, n.prototype.remove = function() {
          this._clear();
        }, n.prototype.eachRendered = function(t) {
          this._newAdded[0] && t(this._newAdded[0]);
        }, n.prototype._create = function() {
          var t = new YLt({ cursor: "default", ignoreCoarsePointer: true });
          return this._newAdded.push(t), this.group.add(t), t;
        }, n.prototype._setCommon = function(t, e, i) {
          var r = e.hostModel;
          t.setShape({ polyline: r.get("polyline"), curveness: r.get(["lineStyle", "curveness"]) }), t.useStyle(r.getModel("lineStyle").getLineStyle()), t.style.strokeNoScale = true;
          var a = e.getVisual("style");
          a && a.stroke && t.setStyle("stroke", a.stroke), t.setStyle("fill", null);
          var o = Nt(t);
          o.seriesIndex = r.seriesIndex, t.on("mousemove", function(s) {
            o.dataIndex = null;
            var l = t.hoverDataIdx;
            l > 0 && (o.dataIndex = l + t.__startIndex);
          });
        }, n.prototype._clear = function() {
          this._newAdded = [], this.group.removeAll();
        }, n;
      }(), uH = { seriesType: "lines", plan: rd(), reset: function(n) {
        var t = n.coordinateSystem;
        if (!t) {
          Ei("The lines series must have a coordinate system.");
          return;
        }
        var e = n.get("polyline"), i = n.pipelineContext.large;
        return { progress: function(r, a) {
          var o = [];
          if (i) {
            var s = void 0, l = r.end - r.start;
            if (e) {
              for (var u = 0, h = r.start; h < r.end; h++) u += n.getLineCoordsCount(h);
              s = new Float32Array(l + u * 2);
            } else s = new Float32Array(l * 4);
            for (var c = 0, f = [], h = r.start; h < r.end; h++) {
              var g = n.getLineCoords(h, o);
              e && (s[c++] = g);
              for (var d = 0; d < g; d++) f = t.dataToPoint(o[d], false, f), s[c++] = f[0], s[c++] = f[1];
            }
            a.setLayout("linesPoints", s);
          } else for (var h = r.start; h < r.end; h++) {
            var A = a.getItemModel(h), g = n.getLineCoords(h, o), p = [];
            if (e) for (var v = 0; v < g; v++) p.push(t.dataToPoint(o[v]));
            else {
              p[0] = t.dataToPoint(o[0]), p[1] = t.dataToPoint(o[1]);
              var y = A.get(["lineStyle", "curveness"]);
              +y && (p[2] = [(p[0][0] + p[1][0]) / 2 - (p[0][1] - p[1][1]) * y, (p[0][1] + p[1][1]) / 2 - (p[1][0] - p[0][0]) * y]);
            }
            a.setItemLayout(h, p);
          }
        } };
      } }, XLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = e.getData(), o = this._updateLineDraw(a, e), s = e.get("zlevel"), l = e.get(["effect", "trailLength"]), u = r.getZr(), h = u.painter.getType() === "svg";
          h || u.painter.getLayer(s).clear(true), this._lastZlevel != null && !h && u.configLayer(this._lastZlevel, { motionBlur: false }), this._showEffect(e) && l > 0 && (h ? "development" : u.configLayer(s, { motionBlur: true, lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0) })), o.updateData(a);
          var c = e.get("clip", true) && Kv(e.coordinateSystem, false, e);
          c ? this.group.setClipPath(c) : this.group.removeClipPath(), this._lastZlevel = s, this._finished = true;
        }, t.prototype.incrementalPrepareRender = function(e, i, r) {
          var a = e.getData(), o = this._updateLineDraw(a, e);
          o.incrementalPrepareUpdate(a), this._clearLayer(r), this._finished = false;
        }, t.prototype.incrementalRender = function(e, i, r) {
          this._lineDraw.incrementalUpdate(e, i.getData()), this._finished = e.end === i.getData().count();
        }, t.prototype.eachRendered = function(e) {
          this._lineDraw && this._lineDraw.eachRendered(e);
        }, t.prototype.updateTransform = function(e, i, r) {
          var a = e.getData(), o = e.pipelineContext;
          if (!this._finished || o.large || o.progressiveRender) return { update: true };
          var s = uH.reset(e, i, r);
          s.progress && s.progress({ start: 0, end: a.count(), count: a.count() }, a), this._lineDraw.updateLayout(), this._clearLayer(r);
        }, t.prototype._updateLineDraw = function(e, i) {
          var r = this._lineDraw, a = this._showEffect(i), o = !!i.get("polyline"), s = i.pipelineContext, l = s.large;
          return "development", (!r || a !== this._hasEffet || o !== this._isPolyline || l !== this._isLargeDraw) && (r && r.remove(), r = this._lineDraw = l ? new WLt() : new jD(o ? a ? qLt : lH : a ? sH : VD), this._hasEffet = a, this._isPolyline = o, this._isLargeDraw = l), this.group.add(r.group), r;
        }, t.prototype._showEffect = function(e) {
          return !!e.get(["effect", "show"]);
        }, t.prototype._clearLayer = function(e) {
          var i = e.getZr(), r = i.painter.getType() === "svg";
          !r && this._lastZlevel != null && i.painter.getLayer(this._lastZlevel).clear(true);
        }, t.prototype.remove = function(e, i) {
          this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(i);
        }, t.prototype.dispose = function(e, i) {
          this.remove(e, i);
        }, t.type = "lines", t;
      }(qe), $Lt = typeof Uint32Array == "undefined" ? Array : Uint32Array, ZLt = typeof Float64Array == "undefined" ? Array : Float64Array;
      function hH(n) {
        var t = n.data;
        t && t[0] && t[0][0] && t[0][0].coord && ("development", n.data = K(t, function(e) {
          var i = [e[0].coord, e[1].coord], r = { coords: i };
          return e[0].name && (r.fromName = e[0].name), e[1].name && (r.toName = e[1].name), _2([r, e[0], e[1]]);
        }));
      }
      var KLt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.visualStyleAccessPath = "lineStyle", e.visualDrawType = "stroke", e;
        }
        return t.prototype.init = function(e) {
          e.data = e.data || [], hH(e);
          var i = this._processFlatCoordsArray(e.data);
          this._flatCoords = i.flatCoords, this._flatCoordsOffset = i.flatCoordsOffset, i.flatCoords && (e.data = new Float32Array(i.count)), n.prototype.init.apply(this, arguments);
        }, t.prototype.mergeOption = function(e) {
          if (hH(e), e.data) {
            var i = this._processFlatCoordsArray(e.data);
            this._flatCoords = i.flatCoords, this._flatCoordsOffset = i.flatCoordsOffset, i.flatCoords && (e.data = new Float32Array(i.count));
          }
          n.prototype.mergeOption.apply(this, arguments);
        }, t.prototype.appendData = function(e) {
          var i = this._processFlatCoordsArray(e.data);
          i.flatCoords && (this._flatCoords ? (this._flatCoords = z_(this._flatCoords, i.flatCoords), this._flatCoordsOffset = z_(this._flatCoordsOffset, i.flatCoordsOffset)) : (this._flatCoords = i.flatCoords, this._flatCoordsOffset = i.flatCoordsOffset), e.data = new Float32Array(i.count)), this.getRawData().appendData(e.data);
        }, t.prototype._getCoordsFromItemModel = function(e) {
          var i = this.getData().getItemModel(e), r = i.option instanceof Array ? i.option : i.getShallow("coords");
          if (!(r instanceof Array && r.length > 0 && r[0] instanceof Array)) throw new Error("Invalid coords " + JSON.stringify(r) + ". Lines must have 2d coords array in data item.");
          return r;
        }, t.prototype.getLineCoordsCount = function(e) {
          return this._flatCoordsOffset ? this._flatCoordsOffset[e * 2 + 1] : this._getCoordsFromItemModel(e).length;
        }, t.prototype.getLineCoords = function(e, i) {
          if (this._flatCoordsOffset) {
            for (var r = this._flatCoordsOffset[e * 2], a = this._flatCoordsOffset[e * 2 + 1], o = 0; o < a; o++) i[o] = i[o] || [], i[o][0] = this._flatCoords[r + o * 2], i[o][1] = this._flatCoords[r + o * 2 + 1];
            return a;
          } else {
            for (var s = this._getCoordsFromItemModel(e), o = 0; o < s.length; o++) i[o] = i[o] || [], i[o][0] = s[o][0], i[o][1] = s[o][1];
            return s.length;
          }
        }, t.prototype._processFlatCoordsArray = function(e) {
          var i = 0;
          if (this._flatCoords && (i = this._flatCoords.length), ye(e[0])) {
            for (var r = e.length, a = new $Lt(r), o = new ZLt(r), s = 0, l = 0, u = 0, h = 0; h < r; ) {
              u++;
              var c = e[h++];
              a[l++] = s + i, a[l++] = c;
              for (var f = 0; f < c; f++) {
                var g = e[h++], d = e[h++];
                if (o[s++] = g, o[s++] = d, h > r && true) throw new Error("Invalid data format.");
              }
            }
            return { flatCoordsOffset: new Uint32Array(a.buffer, 0, l), flatCoords: o, count: u };
          }
          return { flatCoordsOffset: null, flatCoords: null, count: e.length };
        }, t.prototype.getInitialData = function(e, i) {
          if (true) {
            var r = ed.get(e.coordinateSystem);
            if (!r) throw new Error("Unknown coordinate system " + e.coordinateSystem);
          }
          var a = new er(["value"], this);
          return a.hasItemOption = false, a.initData(e.data, [], function(o, s, l, u) {
            if (o instanceof Array) return NaN;
            a.hasItemOption = true;
            var h = o.value;
            if (h != null) return h instanceof Array ? h[u] : h;
          }), a;
        }, t.prototype.formatTooltip = function(e, i, r) {
          var a = this.getData(), o = a.getItemModel(e), s = o.get("name");
          if (s) return s;
          var l = o.get("fromName"), u = o.get("toName"), h = [];
          return l != null && h.push(l), u != null && h.push(u), ti("nameValue", { name: h.join(" > ") });
        }, t.prototype.preventIncremental = function() {
          return !!this.get(["effect", "show"]);
        }, t.prototype.getProgressive = function() {
          var e = this.option.progressive;
          return e == null ? this.option.large ? 1e4 : this.get("progressive") : e;
        }, t.prototype.getProgressiveThreshold = function() {
          var e = this.option.progressiveThreshold;
          return e == null ? this.option.large ? 2e4 : this.get("progressiveThreshold") : e;
        }, t.prototype.getZLevelKey = function() {
          var e = this.getModel("effect"), i = e.get("trailLength");
          return this.getData().count() > this.getProgressiveThreshold() ? this.id : e.get("show") && i > 0 ? i + "" : "";
        }, t.type = "series.lines", t.dependencies = ["grid", "polar", "geo", "calendar"], t.defaultOption = { coordinateSystem: "geo", z: 2, legendHoverLink: true, xAxisIndex: 0, yAxisIndex: 0, symbol: ["none", "none"], symbolSize: [10, 10], geoIndex: 0, effect: { show: false, period: 4, constantSpeed: 0, symbol: "circle", symbolSize: 3, loop: true, trailLength: 0.2 }, large: false, largeThreshold: 2e3, polyline: false, clip: true, label: { show: false, position: "end" }, lineStyle: { opacity: 0.5 } }, t;
      }(tn);
      function AI(n) {
        return n instanceof Array || (n = [n, n]), n;
      }
      var JLt = { seriesType: "lines", reset: function(n) {
        var t = AI(n.get("symbol")), e = AI(n.get("symbolSize")), i = n.getData();
        i.setVisual("fromSymbol", t && t[0]), i.setVisual("toSymbol", t && t[1]), i.setVisual("fromSymbolSize", e && e[0]), i.setVisual("toSymbolSize", e && e[1]);
        function r(a, o) {
          var s = a.getItemModel(o), l = AI(s.getShallow("symbol", true)), u = AI(s.getShallow("symbolSize", true));
          l[0] && a.setItemVisual(o, "fromSymbol", l[0]), l[1] && a.setItemVisual(o, "toSymbol", l[1]), u[0] && a.setItemVisual(o, "fromSymbolSize", u[0]), u[1] && a.setItemVisual(o, "toSymbolSize", u[1]);
        }
        return { dataEach: i.hasItemOption ? r : null };
      } };
      function tPt(n) {
        n.registerChartView(XLt), n.registerSeriesModel(KLt), n.registerLayout(uH), n.registerVisual(JLt);
      }
      var ePt = 256, nPt = function() {
        function n() {
          this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = { inRange: null, outOfRange: null };
          var t = Xl.createCanvas();
          this.canvas = t;
        }
        return n.prototype.update = function(t, e, i, r, a, o) {
          var s = this._getBrush(), l = this._getGradient(a, "inRange"), u = this._getGradient(a, "outOfRange"), h = this.pointSize + this.blurSize, c = this.canvas, f = c.getContext("2d"), g = t.length;
          c.width = e, c.height = i;
          for (var d = 0; d < g; ++d) {
            var A = t[d], p = A[0], v = A[1], y = A[2], m = r(y);
            f.globalAlpha = m, f.drawImage(s, p - h, v - h);
          }
          if (!c.width || !c.height) return c;
          for (var _ = f.getImageData(0, 0, c.width, c.height), I = _.data, E = 0, x = I.length, w = this.minOpacity, C = this.maxOpacity, S = C - w; E < x; ) {
            var m = I[E + 3] / 256, b = Math.floor(m * (ePt - 1)) * 4;
            if (m > 0) {
              var T = o(m) ? l : u;
              m > 0 && (m = m * S + w), I[E++] = T[b], I[E++] = T[b + 1], I[E++] = T[b + 2], I[E++] = T[b + 3] * m * 256;
            } else E += 4;
          }
          return f.putImageData(_, 0, 0), c;
        }, n.prototype._getBrush = function() {
          var t = this._brushCanvas || (this._brushCanvas = Xl.createCanvas()), e = this.pointSize + this.blurSize, i = e * 2;
          t.width = i, t.height = i;
          var r = t.getContext("2d");
          return r.clearRect(0, 0, i, i), r.shadowOffsetX = i, r.shadowBlur = this.blurSize, r.shadowColor = "#000", r.beginPath(), r.arc(-e, e, this.pointSize, 0, Math.PI * 2, true), r.closePath(), r.fill(), t;
        }, n.prototype._getGradient = function(t, e) {
          for (var i = this._gradientPixels, r = i[e] || (i[e] = new Uint8ClampedArray(256 * 4)), a = [0, 0, 0, 0], o = 0, s = 0; s < 256; s++) t[e](s / 255, true, a), r[o++] = a[0], r[o++] = a[1], r[o++] = a[2], r[o++] = a[3];
          return r;
        }, n;
      }();
      function iPt(n, t, e) {
        var i = n[1] - n[0];
        t = K(t, function(o) {
          return { interval: [(o.interval[0] - n[0]) / i, (o.interval[1] - n[0]) / i] };
        });
        var r = t.length, a = 0;
        return function(o) {
          var s;
          for (s = a; s < r; s++) {
            var l = t[s].interval;
            if (l[0] <= o && o <= l[1]) {
              a = s;
              break;
            }
          }
          if (s === r) for (s = a - 1; s >= 0; s--) {
            var l = t[s].interval;
            if (l[0] <= o && o <= l[1]) {
              a = s;
              break;
            }
          }
          return s >= 0 && s < r && e[s];
        };
      }
      function rPt(n, t) {
        var e = n[1] - n[0];
        return t = [(t[0] - n[0]) / e, (t[1] - n[0]) / e], function(i) {
          return i >= t[0] && i <= t[1];
        };
      }
      function cH(n) {
        var t = n.dimensions;
        return t[0] === "lng" && t[1] === "lat";
      }
      var aPt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a;
          if (i.eachComponent("visualMap", function(s) {
            s.eachTargetSeries(function(l) {
              l === e && (a = s);
            });
          }), !a) throw new Error("Heatmap must use with visualMap");
          this._progressiveEls = null, this.group.removeAll();
          var o = e.coordinateSystem;
          o.type === "cartesian2d" || o.type === "calendar" ? this._renderOnCartesianAndCalendar(e, r, 0, e.getData().count()) : cH(o) && this._renderOnGeo(o, e, a, r);
        }, t.prototype.incrementalPrepareRender = function(e, i, r) {
          this.group.removeAll();
        }, t.prototype.incrementalRender = function(e, i, r, a) {
          var o = i.coordinateSystem;
          o && (cH(o) ? this.render(i, r, a) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(i, a, e.start, e.end, true)));
        }, t.prototype.eachRendered = function(e) {
          hu(this._progressiveEls || this.group, e);
        }, t.prototype._renderOnCartesianAndCalendar = function(e, i, r, a, o) {
          var s = e.coordinateSystem, l = dc(s, "cartesian2d"), u, h, c, f;
          if (l) {
            var g = s.getAxis("x"), d = s.getAxis("y");
            if (true) {
              if (!(g.type === "category" && d.type === "category")) throw new Error("Heatmap on cartesian must have two category axes");
              if (!(g.onBand && d.onBand)) throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
            }
            u = g.getBandWidth() + 0.5, h = d.getBandWidth() + 0.5, c = g.scale.getExtent(), f = d.scale.getExtent();
          }
          for (var A = this.group, p = e.getData(), v = e.getModel(["emphasis", "itemStyle"]).getItemStyle(), y = e.getModel(["blur", "itemStyle"]).getItemStyle(), m = e.getModel(["select", "itemStyle"]).getItemStyle(), _ = e.get(["itemStyle", "borderRadius"]), I = Jn(e), E = e.getModel("emphasis"), x = E.get("focus"), w = E.get("blurScope"), C = E.get("disabled"), S = l ? [p.mapDimension("x"), p.mapDimension("y"), p.mapDimension("value")] : [p.mapDimension("time"), p.mapDimension("value")], b = r; b < a; b++) {
            var T = void 0, B = p.getItemVisual(b, "style");
            if (l) {
              var R = p.get(S[0], b), M = p.get(S[1], b);
              if (isNaN(p.get(S[2], b)) || isNaN(R) || isNaN(M) || R < c[0] || R > c[1] || M < f[0] || M > f[1]) continue;
              var L = s.dataToPoint([R, M]);
              T = new fe({ shape: { x: L[0] - u / 2, y: L[1] - h / 2, width: u, height: h }, style: B });
            } else {
              if (isNaN(p.get(S[1], b))) continue;
              T = new fe({ z2: 1, shape: s.dataToRect([p.get(S[0], b)]).contentShape, style: B });
            }
            if (p.hasItemOption) {
              var N = p.getItemModel(b), F = N.getModel("emphasis");
              v = F.getModel("itemStyle").getItemStyle(), y = N.getModel(["blur", "itemStyle"]).getItemStyle(), m = N.getModel(["select", "itemStyle"]).getItemStyle(), _ = N.get(["itemStyle", "borderRadius"]), x = F.get("focus"), w = F.get("blurScope"), C = F.get("disabled"), I = Jn(N);
            }
            T.shape.r = _;
            var k = e.getRawValue(b), O = "-";
            k && k[2] != null && (O = k[2] + ""), xi(T, I, { labelFetcher: e, labelDataIndex: b, defaultOpacity: B.opacity, defaultText: O }), T.ensureState("emphasis").style = v, T.ensureState("blur").style = y, T.ensureState("select").style = m, pn(T, x, w, C), T.incremental = o, o && (T.states.emphasis.hoverLayer = true), A.add(T), p.setItemGraphicEl(b, T), this._progressiveEls && this._progressiveEls.push(T);
          }
        }, t.prototype._renderOnGeo = function(e, i, r, a) {
          var o = r.targetVisuals.inRange, s = r.targetVisuals.outOfRange, l = i.getData(), u = this._hmLayer || this._hmLayer || new nPt();
          u.blurSize = i.get("blurSize"), u.pointSize = i.get("pointSize"), u.minOpacity = i.get("minOpacity"), u.maxOpacity = i.get("maxOpacity");
          var h = e.getViewRect().clone(), c = e.getRoamTransform();
          h.applyTransform(c);
          var f = Math.max(h.x, 0), g = Math.max(h.y, 0), d = Math.min(h.width + h.x, a.getWidth()), A = Math.min(h.height + h.y, a.getHeight()), p = d - f, v = A - g, y = [l.mapDimension("lng"), l.mapDimension("lat"), l.mapDimension("value")], m = l.mapArray(y, function(x, w, C) {
            var S = e.dataToPoint([x, w]);
            return S[0] -= f, S[1] -= g, S.push(C), S;
          }), _ = r.getExtent(), I = r.type === "visualMap.continuous" ? rPt(_, r.option.range) : iPt(_, r.getPieceList(), r.option.selected);
          u.update(m, p, v, o.color.getNormalizer(), { inRange: o.color.getColorMapper(), outOfRange: s.color.getColorMapper() }, I);
          var E = new gi({ style: { width: p, height: v, x: f, y: g, image: u.canvas }, silent: true });
          this.group.add(E);
        }, t.type = "heatmap", t;
      }(qe), oPt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.getInitialData = function(e, i) {
          return tl(null, this, { generateCoord: "value" });
        }, t.prototype.preventIncremental = function() {
          var e = ed.get(this.get("coordinateSystem"));
          if (e && e.dimensions) return e.dimensions[0] === "lng" && e.dimensions[1] === "lat";
        }, t.type = "series.heatmap", t.dependencies = ["grid", "geo", "calendar"], t.defaultOption = { coordinateSystem: "cartesian2d", z: 2, geoIndex: 0, blurSize: 30, pointSize: 20, maxOpacity: 1, minOpacity: 0, select: { itemStyle: { borderColor: "#212121" } } }, t;
      }(tn);
      function sPt(n) {
        n.registerChartView(aPt), n.registerSeriesModel(oPt);
      }
      var lPt = ["itemStyle", "borderWidth"], fH = [{ xy: "x", wh: "width", index: 0, posDesc: ["left", "right"] }, { xy: "y", wh: "height", index: 1, posDesc: ["top", "bottom"] }], mR = new $s(), uPt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = this.group, o = e.getData(), s = this._data, l = e.coordinateSystem, u = l.getBaseAxis(), h = u.isHorizontal(), c = l.master.getRect(), f = { ecSize: { width: r.getWidth(), height: r.getHeight() }, seriesModel: e, coordSys: l, coordSysExtent: [[c.x, c.x + c.width], [c.y, c.y + c.height]], isHorizontal: h, valueDim: fH[+h], categoryDim: fH[1 - +h] };
          o.diff(s).add(function(d) {
            if (o.hasValue(d)) {
              var A = mH(o, d), p = gH(o, d, A, f), v = _H(o, f, p);
              o.setItemGraphicEl(d, v), a.add(v), xH(v, f, p);
            }
          }).update(function(d, A) {
            var p = s.getItemGraphicEl(A);
            if (!o.hasValue(d)) {
              a.remove(p);
              return;
            }
            var v = mH(o, d), y = gH(o, d, v, f), m = IH(o, y);
            p && m !== p.__pictorialShapeStr && (a.remove(p), o.setItemGraphicEl(d, null), p = null), p ? pPt(p, f, y) : p = _H(o, f, y, true), o.setItemGraphicEl(d, p), p.__pictorialSymbolMeta = y, a.add(p), xH(p, f, y);
          }).remove(function(d) {
            var A = s.getItemGraphicEl(d);
            A && EH(s, d, A.__pictorialSymbolMeta.animationModel, A);
          }).execute();
          var g = e.get("clip", true) ? Kv(e.coordinateSystem, false, e) : null;
          return g ? a.setClipPath(g) : a.removeClipPath(), this._data = o, this.group;
        }, t.prototype.remove = function(e, i) {
          var r = this.group, a = this._data;
          e.get("animation") ? a && a.eachItemGraphicEl(function(o) {
            EH(a, Nt(o).dataIndex, e, o);
          }) : r.removeAll();
        }, t.type = "pictorialBar", t;
      }(qe);
      function gH(n, t, e, i) {
        var r = n.getItemLayout(t), a = e.get("symbolRepeat"), o = e.get("symbolClip"), s = e.get("symbolPosition") || "start", l = e.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0, h = e.get("symbolPatternSize") || 2, c = e.isAnimationEnabled(), f = { dataIndex: t, layout: r, itemModel: e, symbolType: n.getItemVisual(t, "symbol") || "circle", style: n.getItemVisual(t, "style"), symbolClip: o, symbolRepeat: a, symbolRepeatDirection: e.get("symbolRepeatDirection"), symbolPatternSize: h, rotation: u, animationModel: c ? e : null, hoverScale: c && e.get(["emphasis", "scale"]), z2: e.getShallow("z", true) || 0 };
        hPt(e, a, r, i, f), cPt(n, t, r, a, o, f.boundingLength, f.pxSign, h, i, f), fPt(e, f.symbolScale, u, i, f);
        var g = f.symbolSize, d = nc(e.get("symbolOffset"), g);
        return gPt(e, g, r, a, o, d, s, f.valueLineWidth, f.boundingLength, f.repeatCutLength, i, f), f;
      }
      function hPt(n, t, e, i, r) {
        var a = i.valueDim, o = n.get("symbolBoundingData"), s = i.coordSys.getOtherAxis(i.coordSys.getBaseAxis()), l = s.toGlobalCoord(s.dataToCoord(0)), u = 1 - +(e[a.wh] <= 0), h;
        if (Z(o)) {
          var c = [_R(s, o[0]) - l, _R(s, o[1]) - l];
          c[1] < c[0] && c.reverse(), h = c[u];
        } else o != null ? h = _R(s, o) - l : t ? h = i.coordSysExtent[a.index][u] - l : h = e[a.wh];
        r.boundingLength = h, t && (r.repeatCutLength = e[a.wh]), r.pxSign = h > 0 ? 1 : -1;
      }
      function _R(n, t) {
        return n.toGlobalCoord(n.dataToCoord(n.scale.parse(t)));
      }
      function cPt(n, t, e, i, r, a, o, s, l, u) {
        var h = l.valueDim, c = l.categoryDim, f = Math.abs(e[c.wh]), g = n.getItemVisual(t, "symbolSize"), d;
        Z(g) ? d = g.slice() : g == null ? d = ["100%", "100%"] : d = [g, g], d[c.index] = st(d[c.index], f), d[h.index] = st(d[h.index], i ? f : Math.abs(a)), u.symbolSize = d;
        var A = u.symbolScale = [d[0] / s, d[1] / s];
        A[h.index] *= (l.isHorizontal ? -1 : 1) * o;
      }
      function fPt(n, t, e, i, r) {
        var a = n.get(lPt) || 0;
        a && (mR.attr({ scaleX: t[0], scaleY: t[1], rotation: e }), mR.updateTransform(), a /= mR.getLineScale(), a *= t[i.valueDim.index]), r.valueLineWidth = a || 0;
      }
      function gPt(n, t, e, i, r, a, o, s, l, u, h, c) {
        var f = h.categoryDim, g = h.valueDim, d = c.pxSign, A = Math.max(t[g.index] + s, 0), p = A;
        if (i) {
          var v = Math.abs(l), y = On(n.get("symbolMargin"), "15%") + "", m = false;
          y.lastIndexOf("!") === y.length - 1 && (m = true, y = y.slice(0, y.length - 1));
          var _ = st(y, t[g.index]), I = Math.max(A + _ * 2, 0), E = m ? 0 : _ * 2, x = _T(i), w = x ? i : wH((v + E) / I), C = v - w * A;
          _ = C / 2 / (m ? w : Math.max(w - 1, 1)), I = A + _ * 2, E = m ? 0 : _ * 2, !x && i !== "fixed" && (w = u ? wH((Math.abs(u) + E) / I) : 0), p = w * I - E, c.repeatTimes = w, c.symbolMargin = _;
        }
        var S = d * (p / 2), b = c.pathPosition = [];
        b[f.index] = e[f.wh] / 2, b[g.index] = o === "start" ? S : o === "end" ? l - S : l / 2, a && (b[0] += a[0], b[1] += a[1]);
        var T = c.bundlePosition = [];
        T[f.index] = e[f.xy], T[g.index] = e[g.xy];
        var B = c.barRectShape = X({}, e);
        B[g.wh] = d * Math.max(Math.abs(e[g.wh]), Math.abs(b[g.index] + S)), B[f.wh] = e[f.wh];
        var R = c.clipShape = {};
        R[f.xy] = -e[f.xy], R[f.wh] = h.ecSize[f.wh], R[g.xy] = 0, R[g.wh] = e[g.wh];
      }
      function dH(n) {
        var t = n.symbolPatternSize, e = Un(n.symbolType, -t / 2, -t / 2, t, t);
        return e.attr({ culling: true }), e.type !== "image" && e.setStyle({ strokeNoScale: true }), e;
      }
      function AH(n, t, e, i) {
        var r = n.__pictorialBundle, a = e.symbolSize, o = e.valueLineWidth, s = e.pathPosition, l = t.valueDim, u = e.repeatTimes || 0, h = 0, c = a[t.valueDim.index] + o + e.symbolMargin * 2;
        for (ER(n, function(A) {
          A.__pictorialAnimationIndex = h, A.__pictorialRepeatTimes = u, h < u ? Cd(A, null, d(h), e, i) : Cd(A, null, { scaleX: 0, scaleY: 0 }, e, i, function() {
            r.remove(A);
          }), h++;
        }); h < u; h++) {
          var f = dH(e);
          f.__pictorialAnimationIndex = h, f.__pictorialRepeatTimes = u, r.add(f);
          var g = d(h);
          Cd(f, { x: g.x, y: g.y, scaleX: 0, scaleY: 0 }, { scaleX: g.scaleX, scaleY: g.scaleY, rotation: g.rotation }, e, i);
        }
        function d(A) {
          var p = s.slice(), v = e.pxSign, y = A;
          return (e.symbolRepeatDirection === "start" ? v > 0 : v < 0) && (y = u - 1 - A), p[l.index] = c * (y - u / 2 + 0.5) + s[l.index], { x: p[0], y: p[1], scaleX: e.symbolScale[0], scaleY: e.symbolScale[1], rotation: e.rotation };
        }
      }
      function pH(n, t, e, i) {
        var r = n.__pictorialBundle, a = n.__pictorialMainPath;
        a ? Cd(a, null, { x: e.pathPosition[0], y: e.pathPosition[1], scaleX: e.symbolScale[0], scaleY: e.symbolScale[1], rotation: e.rotation }, e, i) : (a = n.__pictorialMainPath = dH(e), r.add(a), Cd(a, { x: e.pathPosition[0], y: e.pathPosition[1], scaleX: 0, scaleY: 0, rotation: e.rotation }, { scaleX: e.symbolScale[0], scaleY: e.symbolScale[1] }, e, i));
      }
      function vH(n, t, e) {
        var i = X({}, t.barRectShape), r = n.__pictorialBarRect;
        r ? Cd(r, null, { shape: i }, t, e) : (r = n.__pictorialBarRect = new fe({ z2: 2, shape: i, silent: true, style: { stroke: "transparent", fill: "transparent", lineWidth: 0 } }), r.disableMorphing = true, n.add(r));
      }
      function yH(n, t, e, i) {
        if (e.symbolClip) {
          var r = n.__pictorialClipPath, a = X({}, e.clipShape), o = t.valueDim, s = e.animationModel, l = e.dataIndex;
          if (r) Ee(r, { shape: a }, s, l);
          else {
            a[o.wh] = 0, r = new fe({ shape: a }), n.__pictorialBundle.setClipPath(r), n.__pictorialClipPath = r;
            var u = {};
            u[o.wh] = e.clipShape[o.wh], Wh[i ? "updateProps" : "initProps"](r, { shape: u }, s, l);
          }
        }
      }
      function mH(n, t) {
        var e = n.getItemModel(t);
        return e.getAnimationDelayParams = dPt, e.isAnimationEnabled = APt, e;
      }
      function dPt(n) {
        return { index: n.__pictorialAnimationIndex, count: n.__pictorialRepeatTimes };
      }
      function APt() {
        return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
      }
      function _H(n, t, e, i) {
        var r = new Dt(), a = new Dt();
        return r.add(a), r.__pictorialBundle = a, a.x = e.bundlePosition[0], a.y = e.bundlePosition[1], e.symbolRepeat ? AH(r, t, e) : pH(r, t, e), vH(r, e, i), yH(r, t, e, i), r.__pictorialShapeStr = IH(n, e), r.__pictorialSymbolMeta = e, r;
      }
      function pPt(n, t, e) {
        var i = e.animationModel, r = e.dataIndex, a = n.__pictorialBundle;
        Ee(a, { x: e.bundlePosition[0], y: e.bundlePosition[1] }, i, r), e.symbolRepeat ? AH(n, t, e, true) : pH(n, t, e, true), vH(n, e, true), yH(n, t, e, true);
      }
      function EH(n, t, e, i) {
        var r = i.__pictorialBarRect;
        r && r.removeTextContent();
        var a = [];
        ER(i, function(o) {
          a.push(o);
        }), i.__pictorialMainPath && a.push(i.__pictorialMainPath), i.__pictorialClipPath && (e = null), D(a, function(o) {
          uu(o, { scaleX: 0, scaleY: 0 }, e, t, function() {
            i.parent && i.parent.remove(i);
          });
        }), n.setItemGraphicEl(t, null);
      }
      function IH(n, t) {
        return [n.getItemVisual(t.dataIndex, "symbol") || "none", !!t.symbolRepeat, !!t.symbolClip].join(":");
      }
      function ER(n, t, e) {
        D(n.__pictorialBundle.children(), function(i) {
          i !== n.__pictorialBarRect && t.call(e, i);
        });
      }
      function Cd(n, t, e, i, r, a) {
        t && n.attr(t), i.symbolClip && !r ? e && n.attr(e) : e && Wh[r ? "updateProps" : "initProps"](n, e, i.animationModel, i.dataIndex, a);
      }
      function xH(n, t, e) {
        var i = e.dataIndex, r = e.itemModel, a = r.getModel("emphasis"), o = a.getModel("itemStyle").getItemStyle(), s = r.getModel(["blur", "itemStyle"]).getItemStyle(), l = r.getModel(["select", "itemStyle"]).getItemStyle(), u = r.getShallow("cursor"), h = a.get("focus"), c = a.get("blurScope"), f = a.get("scale");
        ER(n, function(A) {
          if (A instanceof gi) {
            var p = A.style;
            A.useStyle(X({ image: p.image, x: p.x, y: p.y, width: p.width, height: p.height }, e.style));
          } else A.useStyle(e.style);
          var v = A.ensureState("emphasis");
          v.style = o, f && (v.scaleX = A.scaleX * 1.1, v.scaleY = A.scaleY * 1.1), A.ensureState("blur").style = s, A.ensureState("select").style = l, u && (A.cursor = u), A.z2 = e.z2;
        });
        var g = t.valueDim.posDesc[+(e.boundingLength > 0)], d = n.__pictorialBarRect;
        d.ignoreClip = true, xi(d, Jn(r), { labelFetcher: t.seriesModel, labelDataIndex: i, defaultText: pd(t.seriesModel.getData(), i), inheritColor: e.style.fill, defaultOpacity: e.style.opacity, defaultOutsidePosition: g }), pn(n, h, c, a.get("disabled"));
      }
      function wH(n) {
        var t = Math.round(n);
        return Math.abs(n - t) < 1e-4 ? t : Math.ceil(n);
      }
      var vPt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.hasSymbolVisual = true, e.defaultSymbol = "roundRect", e;
        }
        return t.prototype.getInitialData = function(e) {
          return e.stack = null, n.prototype.getInitialData.apply(this, arguments);
        }, t.type = "series.pictorialBar", t.dependencies = ["grid"], t.defaultOption = cu(ty.defaultOption, { symbol: "circle", symbolSize: null, symbolRotate: null, symbolPosition: null, symbolOffset: null, symbolMargin: null, symbolRepeat: false, symbolRepeatDirection: "end", symbolClip: false, symbolBoundingData: null, symbolPatternSize: 400, barGap: "-100%", clip: false, progressive: 0, emphasis: { scale: false }, select: { itemStyle: { borderColor: "#212121" } } }), t;
      }(ty);
      function yPt(n) {
        n.registerChartView(uPt), n.registerSeriesModel(vPt), n.registerLayout(n.PRIORITY.VISUAL.LAYOUT, Gt(QV, "pictorialBar")), n.registerLayout(n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, zV("pictorialBar"));
      }
      var mPt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._layers = [], e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = e.getData(), o = this, s = this.group, l = e.getLayerSeries(), u = a.getLayout("layoutInfo"), h = u.rect, c = u.boundaryGap;
          s.x = 0, s.y = h.y + c[0];
          function f(p) {
            return p.name;
          }
          var g = new Js(this._layersSeries || [], l, f, f), d = [];
          g.add(ct(A, this, "add")).update(ct(A, this, "update")).remove(ct(A, this, "remove")).execute();
          function A(p, v, y) {
            var m = o._layers;
            if (p === "remove") {
              s.remove(m[v]);
              return;
            }
            for (var _ = [], I = [], E, x = l[v].indices, w = 0; w < x.length; w++) {
              var C = a.getItemLayout(x[w]), S = C.x, b = C.y0, T = C.y;
              _.push(S, b), I.push(S, b + T), E = a.getItemVisual(x[w], "style");
            }
            var B, R = a.getItemLayout(x[0]), M = e.getModel("label"), L = M.get("margin"), N = e.getModel("emphasis");
            if (p === "add") {
              var F = d[v] = new Dt();
              B = new n9({ shape: { points: _, stackedOnPoints: I, smooth: 0.4, stackedOnSmooth: 0.4, smoothConstraint: false }, z2: 0 }), F.add(B), s.add(F), e.isAnimationEnabled() && B.setClipPath(_Pt(B.getBoundingRect(), e, function() {
                B.removeClipPath();
              }));
            } else {
              var F = m[y];
              B = F.childAt(0), s.add(F), d[v] = F, Ee(B, { shape: { points: _, stackedOnPoints: I } }, e), to(B);
            }
            xi(B, Jn(e), { labelDataIndex: x[w - 1], defaultText: a.getName(x[w - 1]), inheritColor: E.fill }, { normal: { verticalAlign: "middle" } }), B.setTextConfig({ position: null, local: true });
            var k = B.getTextContent();
            k && (k.x = R.x - L, k.y = R.y0 + R.y / 2), B.useStyle(E), a.setItemGraphicEl(v, B), Ii(B, e), pn(B, N.get("focus"), N.get("blurScope"), N.get("disabled"));
          }
          this._layersSeries = l, this._layers = d;
        }, t.type = "themeRiver", t;
      }(qe);
      function _Pt(n, t, e) {
        var i = new fe({ shape: { x: n.x - 10, y: n.y - 10, width: 0, height: n.height + 20 } });
        return on(i, { shape: { x: n.x - 50, width: n.width + 100, height: n.height + 20 } }, t, e), i;
      }
      var IR = 2, EPt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e) {
          n.prototype.init.apply(this, arguments), this.legendVisualProvider = new ny(ct(this.getData, this), ct(this.getRawData, this));
        }, t.prototype.fixData = function(e) {
          var i = e.length, r = {}, a = xT(e, function(f) {
            return r.hasOwnProperty(f[0] + "") || (r[f[0] + ""] = -1), f[2];
          }), o = [];
          a.buckets.each(function(f, g) {
            o.push({ name: g, dataList: f });
          });
          for (var s = o.length, l = 0; l < s; ++l) {
            for (var u = o[l].name, h = 0; h < o[l].dataList.length; ++h) {
              var c = o[l].dataList[h][0] + "";
              r[c] = l;
            }
            for (var c in r) r.hasOwnProperty(c) && r[c] !== l && (r[c] = l, e[i] = [c, 0, u], i++);
          }
          return e;
        }, t.prototype.getInitialData = function(e, i) {
          for (var r = this.getReferringComponents("singleAxis", zn).models[0], a = r.get("type"), o = Fe(e.data, function(d) {
            return d[2] !== void 0;
          }), s = this.fixData(o || []), l = [], u = this.nameMap = dt(), h = 0, c = 0; c < s.length; ++c) l.push(s[c][IR]), u.get(s[c][IR]) || (u.set(s[c][IR], h), h++);
          var f = Uv(s, { coordDimensions: ["single"], dimensionsDefine: [{ name: "time", type: wE(a) }, { name: "value", type: "float" }, { name: "name", type: "ordinal" }], encodeDefine: { single: 0, value: 1, itemName: 2 } }).dimensions, g = new er(f, this);
          return g.initData(s), g;
        }, t.prototype.getLayerSeries = function() {
          for (var e = this.getData(), i = e.count(), r = [], a = 0; a < i; ++a) r[a] = a;
          var o = e.mapDimension("single"), s = xT(r, function(u) {
            return e.get("name", u);
          }), l = [];
          return s.buckets.each(function(u, h) {
            u.sort(function(c, f) {
              return e.get(o, c) - e.get(o, f);
            }), l.push({ name: h, indices: u });
          }), l;
        }, t.prototype.getAxisTooltipData = function(e, i, r) {
          Z(e) || (e = e ? [e] : []);
          for (var a = this.getData(), o = this.getLayerSeries(), s = [], l = o.length, u, h = 0; h < l; ++h) {
            for (var c = Number.MAX_VALUE, f = -1, g = o[h].indices.length, d = 0; d < g; ++d) {
              var A = a.get(e[0], o[h].indices[d]), p = Math.abs(A - i);
              p <= c && (u = A, c = p, f = o[h].indices[d]);
            }
            s.push(f);
          }
          return { dataIndices: s, nestestValue: u };
        }, t.prototype.formatTooltip = function(e, i, r) {
          var a = this.getData(), o = a.getName(e), s = a.get(a.mapDimension("value"), e);
          return ti("nameValue", { name: o, value: s });
        }, t.type = "series.themeRiver", t.dependencies = ["singleAxis"], t.defaultOption = { z: 2, colorBy: "data", coordinateSystem: "singleAxis", boundaryGap: ["10%", "10%"], singleAxisIndex: 0, animationEasing: "linear", label: { margin: 4, show: true, position: "left", fontSize: 11 }, emphasis: { label: { show: true } } }, t;
      }(tn);
      function IPt(n, t) {
        n.eachSeriesByType("themeRiver", function(e) {
          var i = e.getData(), r = e.coordinateSystem, a = {}, o = r.getRect();
          a.rect = o;
          var s = e.get("boundaryGap"), l = r.getAxis();
          if (a.boundaryGap = s, l.orient === "horizontal") {
            s[0] = st(s[0], o.height), s[1] = st(s[1], o.height);
            var u = o.height - s[0] - s[1];
            CH(i, e, u);
          } else {
            s[0] = st(s[0], o.width), s[1] = st(s[1], o.width);
            var h = o.width - s[0] - s[1];
            CH(i, e, h);
          }
          i.setLayout("layoutInfo", a);
        });
      }
      function CH(n, t, e) {
        if (n.count()) for (var i = t.coordinateSystem, r = t.getLayerSeries(), a = n.mapDimension("single"), o = n.mapDimension("value"), s = K(r, function(p) {
          return K(p.indices, function(v) {
            var y = i.dataToPoint(n.get(a, v));
            return y[1] = n.get(o, v), y;
          });
        }), l = xPt(s), u = l.y0, h = e / l.max, c = r.length, f = r[0].indices.length, g, d = 0; d < f; ++d) {
          g = u[d] * h, n.setItemLayout(r[0].indices[d], { layerIndex: 0, x: s[0][d][0], y0: g, y: s[0][d][1] * h });
          for (var A = 1; A < c; ++A) g += s[A - 1][d][1] * h, n.setItemLayout(r[A].indices[d], { layerIndex: A, x: s[A][d][0], y0: g, y: s[A][d][1] * h });
        }
      }
      function xPt(n) {
        for (var t = n.length, e = n[0].length, i = [], r = [], a = 0, o = 0; o < e; ++o) {
          for (var s = 0, l = 0; l < t; ++l) s += n[l][o][1];
          s > a && (a = s), i.push(s);
        }
        for (var u = 0; u < e; ++u) r[u] = (a - i[u]) / 2;
        a = 0;
        for (var h = 0; h < e; ++h) {
          var c = i[h] + r[h];
          c > a && (a = c);
        }
        return { y0: r, max: a };
      }
      function wPt(n) {
        n.registerChartView(mPt), n.registerSeriesModel(EPt), n.registerLayout(IPt), n.registerProcessor(ey("themeRiver"));
      }
      var CPt = 2, SPt = 4, SH = function(n) {
        V(t, n);
        function t(e, i, r, a) {
          var o = n.call(this) || this;
          o.z2 = CPt, o.textConfig = { inside: true }, Nt(o).seriesIndex = i.seriesIndex;
          var s = new Ae({ z2: SPt, silent: e.getModel().get(["label", "silent"]) });
          return o.setTextContent(s), o.updateData(true, e, i, r, a), o;
        }
        return t.prototype.updateData = function(e, i, r, a, o) {
          this.node = i, i.piece = this, r = r || this._seriesModel, a = a || this._ecModel;
          var s = this;
          Nt(s).dataIndex = i.dataIndex;
          var l = i.getModel(), u = l.getModel("emphasis"), h = i.getLayout(), c = X({}, h);
          c.label = null;
          var f = i.getVisual("style");
          f.lineJoin = "bevel";
          var g = i.getVisual("decal");
          g && (f.decal = ud(g, o));
          var d = Ac(l.getModel("itemStyle"), c, true);
          X(c, d), D($i, function(y) {
            var m = s.ensureState(y), _ = l.getModel([y, "itemStyle"]);
            m.style = _.getItemStyle();
            var I = Ac(_, c);
            I && (m.shape = I);
          }), e ? (s.setShape(c), s.shape.r = h.r0, on(s, { shape: { r: h.r } }, r, i.dataIndex)) : (Ee(s, { shape: c }, r), to(s)), s.useStyle(f), this._updateLabel(r);
          var A = l.getShallow("cursor");
          A && s.attr("cursor", A), this._seriesModel = r || this._seriesModel, this._ecModel = a || this._ecModel;
          var p = u.get("focus"), v = p === "ancestor" ? i.getAncestorsIndices() : p === "descendant" ? i.getDescendantIndices() : p;
          pn(this, v, u.get("blurScope"), u.get("disabled"));
        }, t.prototype._updateLabel = function(e) {
          var i = this, r = this.node.getModel(), a = r.getModel("label"), o = this.node.getLayout(), s = o.endAngle - o.startAngle, l = (o.startAngle + o.endAngle) / 2, u = Math.cos(l), h = Math.sin(l), c = this, f = c.getTextContent(), g = this.node.dataIndex, d = a.get("minAngle") / 180 * Math.PI, A = a.get("show") && !(d != null && Math.abs(s) < d);
          f.ignore = !A, D(ov, function(v) {
            var y = v === "normal" ? r.getModel("label") : r.getModel([v, "label"]), m = v === "normal", _ = m ? f : f.ensureState(v), I = e.getFormattedLabel(g, v);
            m && (I = I || i.node.name), _.style = Je(y, {}, null, v !== "normal", true), I && (_.style.text = I);
            var E = y.get("show");
            E != null && !m && (_.ignore = !E);
            var x = p(y, "position"), w = m ? c : c.states[v], C = w.style.fill;
            w.textConfig = { outsideFill: y.get("color") === "inherit" ? C : null, inside: x !== "outside" };
            var S, b = p(y, "distance") || 0, T = p(y, "align"), B = p(y, "rotate"), R = Math.PI * 0.5, M = Math.PI * 1.5, L = Yr(B === "tangential" ? Math.PI / 2 - l : l), N = L > R && !Jp(L - R) && L < M;
            x === "outside" ? (S = o.r + b, T = N ? "right" : "left") : !T || T === "center" ? (s === 2 * Math.PI && o.r0 === 0 ? S = 0 : S = (o.r + o.r0) / 2, T = "center") : T === "left" ? (S = o.r0 + b, T = N ? "right" : "left") : T === "right" && (S = o.r - b, T = N ? "left" : "right"), _.style.align = T, _.style.verticalAlign = p(y, "verticalAlign") || "middle", _.x = S * u + o.cx, _.y = S * h + o.cy;
            var F = 0;
            B === "radial" ? F = Yr(-l) + (N ? Math.PI : 0) : B === "tangential" ? F = Yr(Math.PI / 2 - l) + (N ? Math.PI : 0) : ye(B) && (F = B * Math.PI / 180), _.rotation = Yr(F);
          });
          function p(v, y) {
            var m = v.get(y);
            return m == null ? a.get(y) : m;
          }
          f.dirtyStyle();
        }, t;
      }(Zi), xR = "sunburstRootToNode", bH = "sunburstHighlight", bPt = "sunburstUnhighlight";
      function TPt(n) {
        n.registerAction({ type: xR, update: "updateView" }, function(t, e) {
          e.eachComponent({ mainType: "series", subType: "sunburst", query: t }, i);
          function i(r, a) {
            var o = uy(t, [xR], r);
            if (o) {
              var s = r.getViewRoot();
              s && (t.direction = wD(s, o.node) ? "rollUp" : "drillDown"), r.resetViewRoot(o.node);
            }
          }
        }), n.registerAction({ type: bH, update: "none" }, function(t, e, i) {
          t = X({}, t), e.eachComponent({ mainType: "series", subType: "sunburst", query: t }, r);
          function r(a) {
            var o = uy(t, [bH], a);
            o && (t.dataIndex = o.node.dataIndex);
          }
          Qn("sunburstHighlight", "highlight"), i.dispatchAction(X(t, { type: "highlight" }));
        }), n.registerAction({ type: bPt, update: "updateView" }, function(t, e, i) {
          t = X({}, t), Qn("sunburstUnhighlight", "downplay"), i.dispatchAction(X(t, { type: "downplay" }));
        });
      }
      var BPt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r, a) {
          var o = this;
          this.seriesModel = e, this.api = r, this.ecModel = i;
          var s = e.getData(), l = s.tree.root, u = e.getViewRoot(), h = this.group, c = e.get("renderLabelForZeroData"), f = [];
          u.eachNode(function(y) {
            f.push(y);
          });
          var g = this._oldChildren || [];
          d(f, g), v(l, u), this._initEvents(), this._oldChildren = f;
          function d(y, m) {
            if (y.length === 0 && m.length === 0) return;
            new Js(m, y, _, _).add(I).update(I).remove(Gt(I, null)).execute();
            function _(E) {
              return E.getId();
            }
            function I(E, x) {
              var w = E == null ? null : y[E], C = x == null ? null : m[x];
              A(w, C);
            }
          }
          function A(y, m) {
            if (!c && y && !y.getValue() && (y = null), y !== l && m !== l) {
              if (m && m.piece) y ? (m.piece.updateData(false, y, e, i, r), s.setItemGraphicEl(y.dataIndex, m.piece)) : p(m);
              else if (y) {
                var _ = new SH(y, e, i, r);
                h.add(_), s.setItemGraphicEl(y.dataIndex, _);
              }
            }
          }
          function p(y) {
            y && y.piece && (h.remove(y.piece), y.piece = null);
          }
          function v(y, m) {
            m.depth > 0 ? (o.virtualPiece ? o.virtualPiece.updateData(false, y, e, i, r) : (o.virtualPiece = new SH(y, e, i, r), h.add(o.virtualPiece)), m.piece.off("click"), o.virtualPiece.on("click", function(_) {
              o._rootToNode(m.parentNode);
            })) : o.virtualPiece && (h.remove(o.virtualPiece), o.virtualPiece = null);
          }
        }, t.prototype._initEvents = function() {
          var e = this;
          this.group.off("click"), this.group.on("click", function(i) {
            var r = false, a = e.seriesModel.getViewRoot();
            a.eachNode(function(o) {
              if (!r && o.piece && o.piece === i.target) {
                var s = o.getModel().get("nodeClick");
                if (s === "rootToNode") e._rootToNode(o);
                else if (s === "link") {
                  var l = o.getModel(), u = l.get("link");
                  if (u) {
                    var h = l.get("target", true) || "_blank";
                    tE(u, h);
                  }
                }
                r = true;
              }
            });
          });
        }, t.prototype._rootToNode = function(e) {
          e !== this.seriesModel.getViewRoot() && this.api.dispatchAction({ type: xR, from: this.uid, seriesId: this.seriesModel.id, targetNode: e });
        }, t.prototype.containPoint = function(e, i) {
          var r = i.getData(), a = r.getItemLayout(0);
          if (a) {
            var o = e[0] - a.cx, s = e[1] - a.cy, l = Math.sqrt(o * o + s * s);
            return l <= a.r && l >= a.r0;
          }
        }, t.type = "sunburst", t;
      }(qe), MPt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.ignoreStyleOnData = true, e;
        }
        return t.prototype.getInitialData = function(e, i) {
          var r = { name: e.name, children: e.data };
          TH(r);
          var a = this._levelModels = K(e.levels || [], function(l) {
            return new De(l, this, i);
          }, this), o = xD.createTree(r, this, s);
          function s(l) {
            l.wrapMethod("getItemModel", function(u, h) {
              var c = o.getNodeByDataIndex(h), f = a[c.depth];
              return f && (u.parentModel = f), u;
            });
          }
          return o.data;
        }, t.prototype.optionUpdated = function() {
          this.resetViewRoot();
        }, t.prototype.getDataParams = function(e) {
          var i = n.prototype.getDataParams.apply(this, arguments), r = this.getData().tree.getNodeByDataIndex(e);
          return i.treePathInfo = iI(r, this), i;
        }, t.prototype.getLevelModel = function(e) {
          return this._levelModels && this._levelModels[e.depth];
        }, t.prototype.getViewRoot = function() {
          return this._viewRoot;
        }, t.prototype.resetViewRoot = function(e) {
          e ? this._viewRoot = e : e = this._viewRoot;
          var i = this.getRawData().tree.root;
          (!e || e !== i && !i.contains(e)) && (this._viewRoot = i);
        }, t.prototype.enableAriaDecal = function() {
          Qq(this);
        }, t.type = "series.sunburst", t.defaultOption = { z: 2, center: ["50%", "50%"], radius: [0, "75%"], clockwise: true, startAngle: 90, minAngle: 0, stillShowZeroSum: true, nodeClick: "rootToNode", renderLabelForZeroData: false, label: { rotate: "radial", show: true, opacity: 1, align: "center", position: "inside", distance: 5, silent: true }, itemStyle: { borderWidth: 1, borderColor: "white", borderType: "solid", shadowBlur: 0, shadowColor: "rgba(0, 0, 0, 0.2)", shadowOffsetX: 0, shadowOffsetY: 0, opacity: 1 }, emphasis: { focus: "descendant" }, blur: { itemStyle: { opacity: 0.2 }, label: { opacity: 0.1 } }, animationType: "expansion", animationDuration: 1e3, animationDurationUpdate: 500, data: [], sort: "desc" }, t;
      }(tn);
      function TH(n) {
        var t = 0;
        D(n.children, function(i) {
          TH(i);
          var r = i.value;
          Z(r) && (r = r[0]), t += r;
        });
        var e = n.value;
        Z(e) && (e = e[0]), (e == null || isNaN(e)) && (e = t), e < 0 && (e = 0), Z(n.value) ? n.value[0] = e : n.value = e;
      }
      var BH = Math.PI / 180;
      function DPt(n, t, e) {
        t.eachSeriesByType(n, function(i) {
          var r = i.get("center"), a = i.get("radius");
          Z(a) || (a = [0, a]), Z(r) || (r = [r, r]);
          var o = e.getWidth(), s = e.getHeight(), l = Math.min(o, s), u = st(r[0], o), h = st(r[1], s), c = st(a[0], l / 2), f = st(a[1], l / 2), g = -i.get("startAngle") * BH, d = i.get("minAngle") * BH, A = i.getData().tree.root, p = i.getViewRoot(), v = p.depth, y = i.get("sort");
          y != null && MH(p, y);
          var m = 0;
          D(p.children, function(L) {
            !isNaN(L.getValue()) && m++;
          });
          var _ = p.getValue(), I = Math.PI / (_ || m) * 2, E = p.depth > 0, x = p.height - (E ? -1 : 1), w = (f - c) / (x || 1), C = i.get("clockwise"), S = i.get("stillShowZeroSum"), b = C ? 1 : -1, T = function(L, N) {
            if (L) {
              var F = N;
              if (L !== A) {
                var k = L.getValue(), O = _ === 0 && S ? I : k * I;
                O < d && (O = d), F = N + b * O;
                var Q = L.depth - v - (E ? -1 : 1), j = c + w * Q, Y = c + w * (Q + 1), G = i.getLevelModel(L);
                if (G) {
                  var $ = G.get("r0", true), J = G.get("r", true), et = G.get("radius", true);
                  et != null && ($ = et[0], J = et[1]), $ != null && (j = st($, l / 2)), J != null && (Y = st(J, l / 2));
                }
                L.setLayout({ angle: O, startAngle: N, endAngle: F, clockwise: C, cx: u, cy: h, r0: j, r: Y });
              }
              if (L.children && L.children.length) {
                var nt = 0;
                D(L.children, function(gt) {
                  nt += T(gt, N + nt);
                });
              }
              return F - N;
            }
          };
          if (E) {
            var B = c, R = c + w, M = Math.PI * 2;
            A.setLayout({ angle: M, startAngle: g, endAngle: g + M, clockwise: C, cx: u, cy: h, r0: B, r: R });
          }
          T(p, g);
        });
      }
      function MH(n, t) {
        var e = n.children || [];
        n.children = RPt(e, t), e.length && D(n.children, function(i) {
          MH(i, t);
        });
      }
      function RPt(n, t) {
        if (yt(t)) {
          var e = K(n, function(r, a) {
            var o = r.getValue();
            return { params: { depth: r.depth, height: r.height, dataIndex: r.dataIndex, getValue: function() {
              return o;
            } }, index: a };
          });
          return e.sort(function(r, a) {
            return t(r.params, a.params);
          }), K(e, function(r) {
            return n[r.index];
          });
        } else {
          var i = t === "asc";
          return n.sort(function(r, a) {
            var o = (r.getValue() - a.getValue()) * (i ? 1 : -1);
            return o === 0 ? (r.dataIndex - a.dataIndex) * (i ? -1 : 1) : o;
          });
        }
      }
      function LPt(n) {
        var t = {};
        function e(i, r, a) {
          for (var o = i; o && o.depth > 1; ) o = o.parentNode;
          var s = r.getColorFromPalette(o.name || o.dataIndex + "", t);
          return i.depth > 1 && ht(s) && (s = H2(s, (i.depth - 1) / (a - 1) * 0.5)), s;
        }
        n.eachSeriesByType("sunburst", function(i) {
          var r = i.getData(), a = r.tree;
          a.eachNode(function(o) {
            var s = o.getModel(), l = s.getModel("itemStyle").getItemStyle();
            l.fill || (l.fill = e(o, i, a.root.height));
            var u = r.ensureUniqueItemVisual(o.dataIndex, "style");
            X(u, l);
          });
        });
      }
      function PPt(n) {
        n.registerChartView(BPt), n.registerSeriesModel(MPt), n.registerLayout(Gt(DPt, "sunburst")), n.registerProcessor(Gt(ey, "sunburst")), n.registerVisual(LPt), TPt(n);
      }
      var DH = { color: "fill", borderColor: "stroke" }, NPt = { symbol: 1, symbolSize: 1, symbolKeepAspect: 1, legendIcon: 1, visualMeta: 1, liftZ: 1, decal: 1 }, rl = ce(), FPt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.optionUpdated = function() {
          this.currentZLevel = this.get("zlevel", true), this.currentZ = this.get("z", true);
        }, t.prototype.getInitialData = function(e, i) {
          return tl(null, this);
        }, t.prototype.getDataParams = function(e, i, r) {
          var a = n.prototype.getDataParams.call(this, e, i);
          return r && (a.info = rl(r).info), a;
        }, t.type = "series.custom", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], t.defaultOption = { coordinateSystem: "cartesian2d", z: 2, legendHoverLink: true, clip: false }, t;
      }(tn);
      function kPt(n, t) {
        return t = t || [0, 0], K(["x", "y"], function(e, i) {
          var r = this.getAxis(e), a = t[i], o = n[i] / 2;
          return r.type === "category" ? r.getBandWidth() : Math.abs(r.dataToCoord(a - o) - r.dataToCoord(a + o));
        }, this);
      }
      function OPt(n) {
        var t = n.master.getRect();
        return { coordSys: { type: "cartesian2d", x: t.x, y: t.y, width: t.width, height: t.height }, api: { coord: function(e) {
          return n.dataToPoint(e);
        }, size: ct(kPt, n) } };
      }
      function QPt(n, t) {
        return t = t || [0, 0], K([0, 1], function(e) {
          var i = t[e], r = n[e] / 2, a = [], o = [];
          return a[e] = i - r, o[e] = i + r, a[1 - e] = o[1 - e] = t[1 - e], Math.abs(this.dataToPoint(a)[e] - this.dataToPoint(o)[e]);
        }, this);
      }
      function zPt(n) {
        var t = n.getBoundingRect();
        return { coordSys: { type: "geo", x: t.x, y: t.y, width: t.width, height: t.height, zoom: n.getZoom() }, api: { coord: function(e) {
          return n.dataToPoint(e);
        }, size: ct(QPt, n) } };
      }
      function GPt(n, t) {
        var e = this.getAxis(), i = t instanceof Array ? t[0] : t, r = (n instanceof Array ? n[0] : n) / 2;
        return e.type === "category" ? e.getBandWidth() : Math.abs(e.dataToCoord(i - r) - e.dataToCoord(i + r));
      }
      function UPt(n) {
        var t = n.getRect();
        return { coordSys: { type: "singleAxis", x: t.x, y: t.y, width: t.width, height: t.height }, api: { coord: function(e) {
          return n.dataToPoint(e);
        }, size: ct(GPt, n) } };
      }
      function VPt(n, t) {
        return t = t || [0, 0], K(["Radius", "Angle"], function(e, i) {
          var r = "get" + e + "Axis", a = this[r](), o = t[i], s = n[i] / 2, l = a.type === "category" ? a.getBandWidth() : Math.abs(a.dataToCoord(o - s) - a.dataToCoord(o + s));
          return e === "Angle" && (l = l * Math.PI / 180), l;
        }, this);
      }
      function jPt(n) {
        var t = n.getRadiusAxis(), e = n.getAngleAxis(), i = t.getExtent();
        return i[0] > i[1] && i.reverse(), { coordSys: { type: "polar", cx: n.cx, cy: n.cy, r: i[1], r0: i[0] }, api: { coord: function(r) {
          var a = t.dataToRadius(r[0]), o = e.dataToAngle(r[1]), s = n.coordToPoint([a, o]);
          return s.push(a, o * Math.PI / 180), s;
        }, size: ct(VPt, n) } };
      }
      function qPt(n) {
        var t = n.getRect(), e = n.getRangeInfo();
        return { coordSys: { type: "calendar", x: t.x, y: t.y, width: t.width, height: t.height, cellWidth: n.getCellWidth(), cellHeight: n.getCellHeight(), rangeInfo: { start: e.start, end: e.end, weeks: e.weeks, dayCount: e.allDay } }, api: { coord: function(i, r) {
          return n.dataToPoint(i, r);
        } } };
      }
      var RH = {};
      function LH(n, t, e, i) {
        return n && (n.legacy || n.legacy !== false && !e && !i && t !== "tspan" && (t === "text" || ft(n, "text")));
      }
      function PH(n, t, e) {
        var i = n, r, a, o;
        if (t === "text") o = i;
        else {
          o = {}, ft(i, "text") && (o.text = i.text), ft(i, "rich") && (o.rich = i.rich), ft(i, "textFill") && (o.fill = i.textFill), ft(i, "textStroke") && (o.stroke = i.textStroke), ft(i, "fontFamily") && (o.fontFamily = i.fontFamily), ft(i, "fontSize") && (o.fontSize = i.fontSize), ft(i, "fontStyle") && (o.fontStyle = i.fontStyle), ft(i, "fontWeight") && (o.fontWeight = i.fontWeight), a = { type: "text", style: o, silent: true }, r = {};
          var s = ft(i, "textPosition");
          e ? r.position = s ? i.textPosition : "inside" : s && (r.position = i.textPosition), ft(i, "textPosition") && (r.position = i.textPosition), ft(i, "textOffset") && (r.offset = i.textOffset), ft(i, "textRotation") && (r.rotation = i.textRotation), ft(i, "textDistance") && (r.distance = i.textDistance);
        }
        return NH(o, n), D(o.rich, function(l) {
          NH(l, l);
        }), { textConfig: r, textContent: a };
      }
      function NH(n, t) {
        t && (t.font = t.textFont || t.font, ft(t, "textStrokeWidth") && (n.lineWidth = t.textStrokeWidth), ft(t, "textAlign") && (n.align = t.textAlign), ft(t, "textVerticalAlign") && (n.verticalAlign = t.textVerticalAlign), ft(t, "textLineHeight") && (n.lineHeight = t.textLineHeight), ft(t, "textWidth") && (n.width = t.textWidth), ft(t, "textHeight") && (n.height = t.textHeight), ft(t, "textBackgroundColor") && (n.backgroundColor = t.textBackgroundColor), ft(t, "textPadding") && (n.padding = t.textPadding), ft(t, "textBorderColor") && (n.borderColor = t.textBorderColor), ft(t, "textBorderWidth") && (n.borderWidth = t.textBorderWidth), ft(t, "textBorderRadius") && (n.borderRadius = t.textBorderRadius), ft(t, "textBoxShadowColor") && (n.shadowColor = t.textBoxShadowColor), ft(t, "textBoxShadowBlur") && (n.shadowBlur = t.textBoxShadowBlur), ft(t, "textBoxShadowOffsetX") && (n.shadowOffsetX = t.textBoxShadowOffsetX), ft(t, "textBoxShadowOffsetY") && (n.shadowOffsetY = t.textBoxShadowOffsetY));
      }
      function FH(n, t, e) {
        var i = n;
        i.textPosition = i.textPosition || e.position || "inside", e.offset != null && (i.textOffset = e.offset), e.rotation != null && (i.textRotation = e.rotation), e.distance != null && (i.textDistance = e.distance);
        var r = i.textPosition.indexOf("inside") >= 0, a = n.fill || "#000";
        kH(i, t);
        var o = i.textFill == null;
        return r ? o && (i.textFill = e.insideFill || "#fff", !i.textStroke && e.insideStroke && (i.textStroke = e.insideStroke), !i.textStroke && (i.textStroke = a), i.textStrokeWidth == null && (i.textStrokeWidth = 2)) : (o && (i.textFill = n.fill || e.outsideFill || "#000"), !i.textStroke && e.outsideStroke && (i.textStroke = e.outsideStroke)), i.text = t.text, i.rich = t.rich, D(t.rich, function(s) {
          kH(s, s);
        }), i;
      }
      function kH(n, t) {
        t && (ft(t, "fill") && (n.textFill = t.fill), ft(t, "stroke") && (n.textStroke = t.fill), ft(t, "lineWidth") && (n.textStrokeWidth = t.lineWidth), ft(t, "font") && (n.font = t.font), ft(t, "fontStyle") && (n.fontStyle = t.fontStyle), ft(t, "fontWeight") && (n.fontWeight = t.fontWeight), ft(t, "fontSize") && (n.fontSize = t.fontSize), ft(t, "fontFamily") && (n.fontFamily = t.fontFamily), ft(t, "align") && (n.textAlign = t.align), ft(t, "verticalAlign") && (n.textVerticalAlign = t.verticalAlign), ft(t, "lineHeight") && (n.textLineHeight = t.lineHeight), ft(t, "width") && (n.textWidth = t.width), ft(t, "height") && (n.textHeight = t.height), ft(t, "backgroundColor") && (n.textBackgroundColor = t.backgroundColor), ft(t, "padding") && (n.textPadding = t.padding), ft(t, "borderColor") && (n.textBorderColor = t.borderColor), ft(t, "borderWidth") && (n.textBorderWidth = t.borderWidth), ft(t, "borderRadius") && (n.textBorderRadius = t.borderRadius), ft(t, "shadowColor") && (n.textBoxShadowColor = t.shadowColor), ft(t, "shadowBlur") && (n.textBoxShadowBlur = t.shadowBlur), ft(t, "shadowOffsetX") && (n.textBoxShadowOffsetX = t.shadowOffsetX), ft(t, "shadowOffsetY") && (n.textBoxShadowOffsetY = t.shadowOffsetY), ft(t, "textShadowColor") && (n.textShadowColor = t.textShadowColor), ft(t, "textShadowBlur") && (n.textShadowBlur = t.textShadowBlur), ft(t, "textShadowOffsetX") && (n.textShadowOffsetX = t.textShadowOffsetX), ft(t, "textShadowOffsetY") && (n.textShadowOffsetY = t.textShadowOffsetY));
      }
      function OH(n, t) {
        if (true) {
          var e = n + "^_^" + t;
          RH[e] || (RH[e] = true);
        }
      }
      var QH = { position: ["x", "y"], scale: ["scaleX", "scaleY"], origin: ["originX", "originY"] }, zH = oe(QH), pI = zo(Vo, function(n, t) {
        return n[t] = 1, n;
      }, {}), GH = Vo.join(", "), vI = ["", "style", "shape", "extra"], Sd = ce();
      function wR(n, t, e, i, r) {
        var a = n + "Animation", o = Ug(n, i, r) || {}, s = Sd(t).userDuring;
        return o.duration > 0 && (o.during = s ? ct($Pt, { el: t, userDuring: s }) : null, o.setToFinal = true, o.scope = n), X(o, e[a]), o;
      }
      function yI(n, t, e, i) {
        i = i || {};
        var r = i.dataIndex, a = i.isInit, o = i.clearStyle, s = e.isAnimationEnabled(), l = Sd(n), u = t.style;
        l.userDuring = t.during;
        var h = {}, c = {};
        if (KPt(n, t, c), jH("shape", t, c), jH("extra", t, c), !a && s && (ZPt(n, t, h), VH("shape", n, t, h), VH("extra", n, t, h), JPt(n, t, u, h)), c.style = u, HPt(n, c, o), WPt(n, t), s) if (a) {
          var f = {};
          D(vI, function(d) {
            var A = d ? t[d] : t;
            A && A.enterFrom && (d && (f[d] = f[d] || {}), X(d ? f[d] : f, A.enterFrom));
          });
          var g = wR("enter", n, t, e, r);
          g.duration > 0 && n.animateFrom(f, g);
        } else YPt(n, t, r || 0, e, h);
        UH(n, t), u ? n.dirty() : n.markRedraw();
      }
      function UH(n, t) {
        for (var e = Sd(n).leaveToProps, i = 0; i < vI.length; i++) {
          var r = vI[i], a = r ? t[r] : t;
          a && a.leaveTo && (e || (e = Sd(n).leaveToProps = {}), r && (e[r] = e[r] || {}), X(r ? e[r] : e, a.leaveTo));
        }
      }
      function mI(n, t, e, i) {
        if (n) {
          var r = n.parent, a = Sd(n).leaveToProps;
          if (a) {
            var o = wR("update", n, t, e, 0);
            o.done = function() {
              r.remove(n);
            }, n.animateTo(a, o);
          } else r.remove(n);
        }
      }
      function Cc(n) {
        return n === "all";
      }
      function HPt(n, t, e) {
        var i = t.style;
        if (!n.isGroup && i) {
          if (e) {
            n.useStyle({});
            for (var r = n.animators, a = 0; a < r.length; a++) {
              var o = r[a];
              o.targetName === "style" && o.changeTarget(n.style);
            }
          }
          n.setStyle(i);
        }
        t && (t.style = null, t && n.attr(t), t.style = i);
      }
      function YPt(n, t, e, i, r) {
        if (r) {
          var a = wR("update", n, t, i, e);
          a.duration > 0 && n.animateFrom(r, a);
        }
      }
      function WPt(n, t) {
        ft(t, "silent") && (n.silent = t.silent), ft(t, "ignore") && (n.ignore = t.ignore), n instanceof ya && ft(t, "invisible") && (n.invisible = t.invisible), n instanceof ne && ft(t, "autoBatch") && (n.autoBatch = t.autoBatch);
      }
      var os = {}, XPt = { setTransform: function(n, t) {
        return It(ft(pI, n), "Only " + GH + " available in `setTransform`."), os.el[n] = t, this;
      }, getTransform: function(n) {
        return It(ft(pI, n), "Only " + GH + " available in `getTransform`."), os.el[n];
      }, setShape: function(n, t) {
        bd(n);
        var e = os.el, i = e.shape || (e.shape = {});
        return i[n] = t, e.dirtyShape && e.dirtyShape(), this;
      }, getShape: function(n) {
        bd(n);
        var t = os.el.shape;
        if (t) return t[n];
      }, setStyle: function(n, t) {
        bd(n);
        var e = os.el, i = e.style;
        return i && (ph(t) && gn("style." + n + " must not be assigned with NaN."), i[n] = t, e.dirtyStyle && e.dirtyStyle()), this;
      }, getStyle: function(n) {
        bd(n);
        var t = os.el.style;
        if (t) return t[n];
      }, setExtra: function(n, t) {
        bd(n);
        var e = os.el.extra || (os.el.extra = {});
        return e[n] = t, this;
      }, getExtra: function(n) {
        bd(n);
        var t = os.el.extra;
        if (t) return t[n];
      } };
      function bd(n) {
        if (n === "transition" || n === "enterFrom" || n === "leaveTo") throw new Error('key must not be "' + n + '"');
      }
      function $Pt() {
        var n = this, t = n.el;
        if (t) {
          var e = Sd(t).userDuring, i = n.userDuring;
          if (e !== i) {
            n.el = n.userDuring = null;
            return;
          }
          os.el = t, i(XPt);
        }
      }
      function VH(n, t, e, i) {
        var r = e[n];
        if (r) {
          var a = t[n], o;
          if (a) {
            var s = e.transition, l = r.transition;
            if (l) if (!o && (o = i[n] = {}), Cc(l)) X(o, a);
            else for (var u = ze(l), h = 0; h < u.length; h++) {
              var c = u[h], f = a[c];
              o[c] = f;
            }
            else if (Cc(s) || $t(s, n) >= 0) {
              !o && (o = i[n] = {});
              for (var g = oe(a), h = 0; h < g.length; h++) {
                var c = g[h], f = a[c];
                tNt(r[c], f) && (o[c] = f);
              }
            }
          }
        }
      }
      function jH(n, t, e) {
        var i = t[n];
        if (i) for (var r = e[n] = {}, a = oe(i), o = 0; o < a.length; o++) {
          var s = a[o];
          r[s] = Yp(i[s]);
        }
      }
      function ZPt(n, t, e) {
        for (var i = t.transition, r = Cc(i) ? Vo : ze(i || []), a = 0; a < r.length; a++) {
          var o = r[a];
          if (!(o === "style" || o === "shape" || o === "extra")) {
            var s = n[o];
            qH(o, "el.transition"), e[o] = s;
          }
        }
      }
      function KPt(n, t, e) {
        for (var i = 0; i < zH.length; i++) {
          var r = zH[i], a = QH[r], o = t[r];
          o && (e[a[0]] = o[0], e[a[1]] = o[1]);
        }
        for (var i = 0; i < Vo.length; i++) {
          var s = Vo[i];
          t[s] != null && (e[s] = t[s]);
        }
      }
      function JPt(n, t, e, i) {
        if (e) {
          var r = n.style, a;
          if (r) {
            var o = e.transition, s = t.transition;
            if (o && !Cc(o)) {
              var l = ze(o);
              !a && (a = i.style = {});
              for (var u = 0; u < l.length; u++) {
                var h = l[u], c = r[h];
                a[h] = c;
              }
            } else if (n.getAnimationStyleProps && (Cc(s) || Cc(o) || $t(s, "style") >= 0)) {
              var f = n.getAnimationStyleProps(), g = f ? f.style : null;
              if (g) {
                !a && (a = i.style = {});
                for (var d = oe(e), u = 0; u < d.length; u++) {
                  var h = d[u];
                  if (g[h]) {
                    var c = r[h];
                    a[h] = c;
                  }
                }
              }
            }
          }
        }
      }
      function tNt(n, t) {
        return Li(n) ? n !== t : n != null && isFinite(n);
      }
      var qH;
      qH = function(n, t) {
        ft(pI, n) || gn("Prop `" + n + "` is not a permitted in `" + t + "`. Only `" + oe(pI).join("`, `") + "` are permitted.");
      };
      var HH = ce(), eNt = ["percent", "easing", "shape", "style", "extra"];
      function YH(n) {
        n.stopAnimation("keyframe"), n.attr(HH(n));
      }
      function _I(n, t, e) {
        if (!(!e.isAnimationEnabled() || !t)) {
          if (Z(t)) {
            D(t, function(s) {
              _I(n, s, e);
            });
            return;
          }
          var i = t.keyframes, r = t.duration;
          if (e && r == null) {
            var a = Ug("enter", e, 0);
            r = a && a.duration;
          }
          if (!(!i || !r)) {
            var o = HH(n);
            D(vI, function(s) {
              if (!(s && !n[s])) {
                var l, u = false;
                i.sort(function(h, c) {
                  return h.percent - c.percent;
                }), D(i, function(h) {
                  var c = n.animators, f = s ? h[s] : h;
                  if (h.percent >= 1 && (u = true), !!f) {
                    var g = oe(f);
                    if (s || (g = Fe(g, function(p) {
                      return $t(eNt, p) < 0;
                    })), !!g.length) {
                      l || (l = n.animate(s, t.loop, true), l.scope = "keyframe");
                      for (var d = 0; d < c.length; d++) c[d] !== l && c[d].targetName === l.targetName && c[d].stopTracks(g);
                      s && (o[s] = o[s] || {});
                      var A = s ? o[s] : o;
                      D(g, function(p) {
                        A[p] = ((s ? n[s] : n) || {})[p];
                      }), l.whenWithKeys(r * h.percent, f, g, h.easing);
                    }
                  }
                }), l && (u || gn("End frame with percent: 1 is missing in the keyframeAnimation.", true), l.delay(t.delay || 0).duration(r).start(t.easing));
              }
            });
          }
        }
      }
      var al = "emphasis", Cu = "normal", CR = "blur", SR = "select", Su = [Cu, al, CR, SR], bR = { normal: ["itemStyle"], emphasis: [al, "itemStyle"], blur: [CR, "itemStyle"], select: [SR, "itemStyle"] }, TR = { normal: ["label"], emphasis: [al, "label"], blur: [CR, "label"], select: [SR, "label"] }, nNt = ["x", "y"], iNt = "e\0\0", Ma = { normal: {}, emphasis: {}, blur: {}, select: {} }, WH = { cartesian2d: OPt, geo: zPt, single: UPt, polar: jPt, calendar: qPt };
      function EI(n) {
        return n instanceof ne;
      }
      function BR(n) {
        return n instanceof ya;
      }
      function rNt(n, t) {
        t.copyTransform(n), BR(t) && BR(n) && (t.setStyle(n.style), t.z = n.z, t.z2 = n.z2, t.zlevel = n.zlevel, t.invisible = n.invisible, t.ignore = n.ignore, EI(t) && EI(n) && t.setShape(n.shape));
      }
      var aNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r, a) {
          this._progressiveEls = null;
          var o = this._data, s = e.getData(), l = this.group, u = $H(e, s, i, r);
          o || l.removeAll(), s.diff(o).add(function(c) {
            RR(r, null, c, u(c, a), e, l, s);
          }).remove(function(c) {
            var f = o.getItemGraphicEl(c);
            f && mI(f, rl(f).option, e);
          }).update(function(c, f) {
            var g = o.getItemGraphicEl(f);
            RR(r, g, c, u(c, a), e, l, s);
          }).execute();
          var h = e.get("clip", true) ? Kv(e.coordinateSystem, false, e) : null;
          h ? l.setClipPath(h) : l.removeClipPath(), this._data = s;
        }, t.prototype.incrementalPrepareRender = function(e, i, r) {
          this.group.removeAll(), this._data = null;
        }, t.prototype.incrementalRender = function(e, i, r, a, o) {
          var s = i.getData(), l = $H(i, s, r, a), u = this._progressiveEls = [];
          function h(g) {
            g.isGroup || (g.incremental = true, g.ensureState("emphasis").hoverLayer = true);
          }
          for (var c = e.start; c < e.end; c++) {
            var f = RR(null, null, c, l(c, o), i, this.group, s);
            f && (f.traverse(h), u.push(f));
          }
        }, t.prototype.eachRendered = function(e) {
          hu(this._progressiveEls || this.group, e);
        }, t.prototype.filterForExposedEvent = function(e, i, r, a) {
          var o = i.element;
          if (o == null || r.name === o) return true;
          for (; (r = r.__hostTarget || r.parent) && r !== this.group; ) if (r.name === o) return true;
          return false;
        }, t.type = "custom", t;
      }(qe);
      function MR(n) {
        var t = n.type, e;
        if (t === "path") {
          var i = n.shape, r = i.width != null && i.height != null ? { x: i.x || 0, y: i.y || 0, width: i.width, height: i.height } : null, a = eY(i);
          e = G1(a, null, r, i.layout || "center"), rl(e).customPathData = a;
        } else if (t === "image") e = new gi({}), rl(e).customImagePath = n.style.image;
        else if (t === "text") e = new Ae({});
        else if (t === "group") e = new Dt();
        else {
          if (t === "compoundPath") throw new Error('"compoundPath" is not supported yet.');
          var o = oB(t);
          if (!o) {
            var s = "";
            s = 'graphic type "' + t + '" can not be found.', be(s);
          }
          e = new o();
        }
        return rl(e).customGraphicType = t, e.name = n.name, e.z2EmphasisLift = 1, e.z2SelectLift = 1, e;
      }
      function DR(n, t, e, i, r, a, o) {
        YH(t);
        var s = r && r.normal.cfg;
        s && t.setTextConfig(s), i && i.transition == null && (i.transition = nNt);
        var l = i && i.style;
        if (l) {
          if (t.type === "text") {
            var u = l;
            ft(u, "textFill") && (u.fill = u.textFill), ft(u, "textStroke") && (u.stroke = u.textStroke);
          }
          var h = void 0, c = EI(t) ? l.decal : null;
          n && c && (c.dirty = true, h = ud(c, n)), l.__decalPattern = h;
        }
        if (BR(t) && l) {
          var h = l.__decalPattern;
          h && (l.decal = h);
        }
        yI(t, i, a, { dataIndex: e, isInit: o, clearStyle: true }), _I(t, i.keyframeAnimation, a);
      }
      function XH(n, t, e, i, r) {
        var a = t.isGroup ? null : t, o = r && r[n].cfg;
        if (a) {
          var s = a.ensureState(n);
          if (i === false) {
            var l = a.getState(n);
            l && (l.style = null);
          } else s.style = i || null;
          o && (s.textConfig = o), Gh(a);
        }
      }
      function oNt(n, t, e) {
        if (!n.isGroup) {
          var i = n, r = e.currentZ, a = e.currentZLevel;
          i.z = r, i.zlevel = a;
          var o = t.z2;
          o != null && (i.z2 = o || 0);
          for (var s = 0; s < Su.length; s++) sNt(i, t, Su[s]);
        }
      }
      function sNt(n, t, e) {
        var i = e === Cu, r = i ? t : II(t, e), a = r ? r.z2 : null, o;
        a != null && (o = i ? n : n.ensureState(e), o.z2 = a || 0);
      }
      function $H(n, t, e, i) {
        var r = n.get("renderItem"), a = n.coordinateSystem, o = {};
        a && (It(r, "series.render is required."), It(a.prepareCustoms || WH[a.type], "This coordSys does not support custom series."), o = a.prepareCustoms ? a.prepareCustoms(a) : WH[a.type](a));
        for (var s = wt({ getWidth: i.getWidth, getHeight: i.getHeight, getZr: i.getZr, getDevicePixelRatio: i.getDevicePixelRatio, value: _, style: E, ordinalRawValue: I, styleEmphasis: x, visual: S, barLayout: b, currentSeriesIndices: T, font: B }, o.api || {}), l = { context: {}, seriesId: n.id, seriesName: n.name, seriesIndex: n.seriesIndex, coordSys: o.coordSys, dataInsideLength: t.count(), encode: lNt(n.getData()) }, u, h, c = {}, f = {}, g = {}, d = {}, A = 0; A < Su.length; A++) {
          var p = Su[A];
          g[p] = n.getModel(bR[p]), d[p] = n.getModel(TR[p]);
        }
        function v(R) {
          return R === u ? h || (h = t.getItemModel(R)) : t.getItemModel(R);
        }
        function y(R, M) {
          return t.hasItemOption ? R === u ? c[M] || (c[M] = v(R).getModel(bR[M])) : v(R).getModel(bR[M]) : g[M];
        }
        function m(R, M) {
          return t.hasItemOption ? R === u ? f[M] || (f[M] = v(R).getModel(TR[M])) : v(R).getModel(TR[M]) : d[M];
        }
        return function(R, M) {
          return u = R, h = null, c = {}, f = {}, r && r(wt({ dataIndexInside: R, dataIndex: t.getRawIndex(R), actionType: M ? M.type : null }, l), s);
        };
        function _(R, M) {
          return M == null && (M = u), t.getStore().get(t.getDimensionIndex(R || 0), M);
        }
        function I(R, M) {
          M == null && (M = u), R = R || 0;
          var L = t.getDimensionInfo(R);
          if (!L) {
            var N = t.getDimensionIndex(R);
            return N >= 0 ? t.getStore().get(N, M) : void 0;
          }
          var F = t.get(L.name, M), k = L && L.ordinalMeta;
          return k ? k.categories[F] : F;
        }
        function E(R, M) {
          OH("api.style", "Please write literal style directly instead."), M == null && (M = u);
          var L = t.getItemVisual(M, "style"), N = L && L.fill, F = L && L.opacity, k = y(M, Cu).getItemStyle();
          N != null && (k.fill = N), F != null && (k.opacity = F);
          var O = { inheritColor: ht(N) ? N : "#000" }, Q = m(M, Cu), j = Je(Q, null, O, false, true);
          j.text = Q.getShallow("show") ? kt(n.getFormattedLabel(M, Cu), pd(t, M)) : null;
          var Y = q1(Q, O, false);
          return C(R, k), k = FH(k, j, Y), R && w(k, R), k.legacy = true, k;
        }
        function x(R, M) {
          OH("api.styleEmphasis", "Please write literal style directly instead."), M == null && (M = u);
          var L = y(M, al).getItemStyle(), N = m(M, al), F = Je(N, null, null, true, true);
          F.text = N.getShallow("show") ? fa(n.getFormattedLabel(M, al), n.getFormattedLabel(M, Cu), pd(t, M)) : null;
          var k = q1(N, null, true);
          return C(R, L), L = FH(L, F, k), R && w(L, R), L.legacy = true, L;
        }
        function w(R, M) {
          for (var L in M) ft(M, L) && (R[L] = M[L]);
        }
        function C(R, M) {
          R && (R.textFill && (M.textFill = R.textFill), R.textPosition && (M.textPosition = R.textPosition));
        }
        function S(R, M) {
          if (M == null && (M = u), ft(DH, R)) {
            var L = t.getItemVisual(M, "style");
            return L ? L[DH[R]] : null;
          }
          if (ft(NPt, R)) return t.getItemVisual(M, R);
        }
        function b(R) {
          if (a.type === "cartesian2d") {
            var M = a.getBaseAxis();
            return KSt(wt({ axis: M }, R));
          }
        }
        function T() {
          return e.getCurrentSeriesIndices();
        }
        function B(R) {
          return uB(R, e);
        }
      }
      function lNt(n) {
        var t = {};
        return D(n.dimensions, function(e) {
          var i = n.getDimensionInfo(e);
          if (!i.isExtraCoord) {
            var r = i.coordDim, a = t[r] = t[r] || [];
            a[i.coordDimIndex] = n.getDimensionIndex(e);
          }
        }), t;
      }
      function RR(n, t, e, i, r, a, o) {
        if (!i) {
          a.remove(t);
          return;
        }
        var s = LR(n, t, e, i, r, a);
        return s && o.setItemGraphicEl(e, s), s && pn(s, i.focus, i.blurScope, i.emphasisDisabled), s;
      }
      function LR(n, t, e, i, r, a) {
        It(i, "should not have an null/undefined element setting");
        var o = -1, s = t;
        t && ZH(t, i, r) && (o = $t(a.childrenRef(), t), t = null);
        var l = !t, u = t;
        u ? u.clearStates() : (u = MR(i), s && rNt(s, u)), i.morph === false ? u.disableMorphing = true : u.disableMorphing && (u.disableMorphing = false), Ma.normal.cfg = Ma.normal.conOpt = Ma.emphasis.cfg = Ma.emphasis.conOpt = Ma.blur.cfg = Ma.blur.conOpt = Ma.select.cfg = Ma.select.conOpt = null, Ma.isLegacy = false, hNt(u, e, i, r, l, Ma), uNt(u, e, i, r, l), DR(n, u, e, i, Ma, r, l), ft(i, "info") && (rl(u).info = i.info);
        for (var h = 0; h < Su.length; h++) {
          var c = Su[h];
          if (c !== Cu) {
            var f = II(i, c), g = PR(i, f, c);
            XH(c, u, f, g, Ma);
          }
        }
        return oNt(u, i, r), i.type === "group" && cNt(n, u, e, i, r), o >= 0 ? a.replaceAt(u, o) : a.add(u), u;
      }
      function ZH(n, t, e) {
        var i = rl(n), r = t.type, a = t.shape, o = t.style;
        return e.isUniversalTransitionEnabled() || r != null && r !== i.customGraphicType || r === "path" && ANt(a) && eY(a) !== i.customPathData || r === "image" && ft(o, "image") && o.image !== i.customImagePath;
      }
      function uNt(n, t, e, i, r) {
        var a = e.clipPath;
        if (a === false) n && n.getClipPath() && n.removeClipPath();
        else if (a) {
          var o = n.getClipPath();
          o && ZH(o, a, i) && (o = null), o || (o = MR(a), It(EI(o), "Only any type of `path` can be used in `clipPath`, rather than " + o.type + "."), n.setClipPath(o)), DR(null, o, t, a, null, i, r);
        }
      }
      function hNt(n, t, e, i, r, a) {
        if (!n.isGroup) {
          KH(e, null, a), KH(e, al, a);
          var o = a.normal.conOpt, s = a.emphasis.conOpt, l = a.blur.conOpt, u = a.select.conOpt;
          if (o != null || s != null || u != null || l != null) {
            var h = n.getTextContent();
            if (o === false) h && n.removeTextContent();
            else {
              o = a.normal.conOpt = o || { type: "text" }, h ? h.clearStates() : (h = MR(o), n.setTextContent(h)), DR(null, h, t, o, null, i, r);
              for (var c = o && o.style, f = 0; f < Su.length; f++) {
                var g = Su[f];
                if (g !== Cu) {
                  var d = a[g].conOpt;
                  XH(g, h, d, PR(o, d, g), null);
                }
              }
              c ? h.dirty() : h.markRedraw();
            }
          }
        }
      }
      function KH(n, t, e) {
        var i = t ? II(n, t) : n, r = t ? PR(n, i, al) : n.style, a = n.type, o = i ? i.textConfig : null, s = n.textContent, l = s ? t ? II(s, t) : s : null;
        if (r && (e.isLegacy || LH(r, a, !!o, !!l))) {
          e.isLegacy = true;
          var u = PH(r, a, !t);
          !o && u.textConfig && (o = u.textConfig), !l && u.textContent && (l = u.textContent);
        }
        if (!t && l) {
          var h = l;
          !h.type && (h.type = "text"), It(h.type === "text", 'textContent.type must be "text"');
        }
        var c = t ? e[t] : e.normal;
        c.cfg = o, c.conOpt = l;
      }
      function II(n, t) {
        return t ? n ? n[t] : null : n;
      }
      function PR(n, t, e) {
        var i = t && t.style;
        return i == null && e === al && n && (i = n.styleEmphasis), i;
      }
      function cNt(n, t, e, i, r) {
        var a = i.children, o = a ? a.length : 0, s = i.$mergeChildren, l = s === "byName" || i.diffChildrenByName, u = s === false;
        if (!(!o && !l && !u)) {
          if (l) {
            gNt({ api: n, oldChildren: t.children() || [], newChildren: a || [], dataIndex: e, seriesModel: r, group: t });
            return;
          }
          u && t.removeAll();
          for (var h = 0; h < o; h++) {
            var c = a[h], f = t.childAt(h);
            c ? (c.ignore == null && (c.ignore = false), LR(n, f, e, c, r, t)) : (It(f, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before."), f.ignore = true);
          }
          for (var g = t.childCount() - 1; g >= h; g--) {
            var d = t.childAt(g);
            fNt(t, d, r);
          }
        }
      }
      function fNt(n, t, e) {
        t && mI(t, rl(n).option, e);
      }
      function gNt(n) {
        new Js(n.oldChildren, n.newChildren, JH, JH, n).add(tY).update(tY).remove(dNt).execute();
      }
      function JH(n, t) {
        var e = n && n.name;
        return e != null ? e : iNt + t;
      }
      function tY(n, t) {
        var e = this.context, i = n != null ? e.newChildren[n] : null, r = t != null ? e.oldChildren[t] : null;
        LR(e.api, r, e.dataIndex, i, e.seriesModel, e.group);
      }
      function dNt(n) {
        var t = this.context, e = t.oldChildren[n];
        e && mI(e, rl(e).option, t.seriesModel);
      }
      function eY(n) {
        return n && (n.pathData || n.d);
      }
      function ANt(n) {
        return n && (ft(n, "pathData") || ft(n, "d"));
      }
      function pNt(n) {
        n.registerChartView(aNt), n.registerSeriesModel(FPt);
      }
      var Sc = ce(), nY = Ct, NR = ct, FR = function() {
        function n() {
          this._dragging = false, this.animationThreshold = 15;
        }
        return n.prototype.render = function(t, e, i, r) {
          var a = e.get("value"), o = e.get("status");
          if (this._axisModel = t, this._axisPointerModel = e, this._api = i, !(!r && this._lastValue === a && this._lastStatus === o)) {
            this._lastValue = a, this._lastStatus = o;
            var s = this._group, l = this._handle;
            if (!o || o === "hide") {
              s && s.hide(), l && l.hide();
              return;
            }
            s && s.show(), l && l.show();
            var u = {};
            this.makeElOption(u, a, t, e, i);
            var h = u.graphicKey;
            h !== this._lastGraphicKey && this.clear(i), this._lastGraphicKey = h;
            var c = this._moveAnimation = this.determineAnimation(t, e);
            if (!s) s = this._group = new Dt(), this.createPointerEl(s, u, t, e), this.createLabelEl(s, u, t, e), i.getZr().add(s);
            else {
              var f = Gt(iY, e, c);
              this.updatePointerEl(s, u, f), this.updateLabelEl(s, u, f, e);
            }
            oY(s, e, true), this._renderHandle(a);
          }
        }, n.prototype.remove = function(t) {
          this.clear(t);
        }, n.prototype.dispose = function(t) {
          this.clear(t);
        }, n.prototype.determineAnimation = function(t, e) {
          var i = e.get("animation"), r = t.axis, a = r.type === "category", o = e.get("snap");
          if (!o && !a) return false;
          if (i === "auto" || i == null) {
            var s = this.animationThreshold;
            if (a && r.getBandWidth() > s) return true;
            if (o) {
              var l = aD(t).seriesDataCount, u = r.getExtent();
              return Math.abs(u[0] - u[1]) / l > s;
            }
            return false;
          }
          return i === true;
        }, n.prototype.makeElOption = function(t, e, i, r, a) {
        }, n.prototype.createPointerEl = function(t, e, i, r) {
          var a = e.pointer;
          if (a) {
            var o = Sc(t).pointerEl = new Wh[a.type](nY(e.pointer));
            t.add(o);
          }
        }, n.prototype.createLabelEl = function(t, e, i, r) {
          if (e.label) {
            var a = Sc(t).labelEl = new Ae(nY(e.label));
            t.add(a), aY(a, r);
          }
        }, n.prototype.updatePointerEl = function(t, e, i) {
          var r = Sc(t).pointerEl;
          r && e.pointer && (r.setStyle(e.pointer.style), i(r, { shape: e.pointer.shape }));
        }, n.prototype.updateLabelEl = function(t, e, i, r) {
          var a = Sc(t).labelEl;
          a && (a.setStyle(e.label.style), i(a, { x: e.label.x, y: e.label.y }), aY(a, r));
        }, n.prototype._renderHandle = function(t) {
          if (!(this._dragging || !this.updateHandleTransform)) {
            var e = this._axisPointerModel, i = this._api.getZr(), r = this._handle, a = e.getModel("handle"), o = e.get("status");
            if (!a.get("show") || !o || o === "hide") {
              r && i.remove(r), this._handle = null;
              return;
            }
            var s;
            this._handle || (s = true, r = this._handle = vv(a.get("icon"), { cursor: "move", draggable: true, onmousemove: function(u) {
              Qs(u.event);
            }, onmousedown: NR(this._onHandleDragMove, this, 0, 0), drift: NR(this._onHandleDragMove, this), ondragend: NR(this._onHandleDragEnd, this) }), i.add(r)), oY(r, e, false), r.setStyle(a.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
            var l = a.get("size");
            Z(l) || (l = [l, l]), r.scaleX = l[0] / 2, r.scaleY = l[1] / 2, ad(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, s);
          }
        }, n.prototype._moveHandleToValue = function(t, e) {
          iY(this._axisPointerModel, !e && this._moveAnimation, this._handle, kR(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
        }, n.prototype._onHandleDragMove = function(t, e) {
          var i = this._handle;
          if (i) {
            this._dragging = true;
            var r = this.updateHandleTransform(kR(i), [t, e], this._axisModel, this._axisPointerModel);
            this._payloadInfo = r, i.stopAnimation(), i.attr(kR(r)), Sc(i).lastProp = null, this._doDispatchAxisPointer();
          }
        }, n.prototype._doDispatchAxisPointer = function() {
          var t = this._handle;
          if (t) {
            var e = this._payloadInfo, i = this._axisModel;
            this._api.dispatchAction({ type: "updateAxisPointer", x: e.cursorPoint[0], y: e.cursorPoint[1], tooltipOption: e.tooltipOption, axesInfo: [{ axisDim: i.axis.dim, axisIndex: i.componentIndex }] });
          }
        }, n.prototype._onHandleDragEnd = function() {
          this._dragging = false;
          var t = this._handle;
          if (t) {
            var e = this._axisPointerModel.get("value");
            this._moveHandleToValue(e), this._api.dispatchAction({ type: "hideTip" });
          }
        }, n.prototype.clear = function(t) {
          this._lastValue = null, this._lastStatus = null;
          var e = t.getZr(), i = this._group, r = this._handle;
          e && i && (this._lastGraphicKey = null, i && e.remove(i), r && e.remove(r), this._group = null, this._handle = null, this._payloadInfo = null), Mv(this, "_doDispatchAxisPointer");
        }, n.prototype.doClear = function() {
        }, n.prototype.buildLabel = function(t, e, i) {
          return i = i || 0, { x: t[i], y: t[1 - i], width: e[i], height: e[1 - i] };
        }, n;
      }();
      function iY(n, t, e, i) {
        rY(Sc(e).lastProp, i) || (Sc(e).lastProp = i, t ? Ee(e, i, n) : (e.stopAnimation(), e.attr(i)));
      }
      function rY(n, t) {
        if (Et(n) && Et(t)) {
          var e = true;
          return D(t, function(i, r) {
            e = e && rY(n[r], i);
          }), !!e;
        } else return n === t;
      }
      function aY(n, t) {
        n[t.get(["label", "show"]) ? "show" : "hide"]();
      }
      function kR(n) {
        return { x: n.x || 0, y: n.y || 0, rotation: n.rotation || 0 };
      }
      function oY(n, t, e) {
        var i = t.get("z"), r = t.get("zlevel");
        n && n.traverse(function(a) {
          a.type !== "group" && (i != null && (a.z = i), r != null && (a.zlevel = r), a.silent = e);
        });
      }
      function OR(n) {
        var t = n.get("type"), e = n.getModel(t + "Style"), i;
        return t === "line" ? (i = e.getLineStyle(), i.fill = null) : t === "shadow" && (i = e.getAreaStyle(), i.stroke = null), i;
      }
      function sY(n, t, e, i, r) {
        var a = e.get("value"), o = lY(a, t.axis, t.ecModel, e.get("seriesDataIndices"), { precision: e.get(["label", "precision"]), formatter: e.get(["label", "formatter"]) }), s = e.getModel("label"), l = Zg(s.get("padding") || 0), u = s.getFont(), h = $p(o, u), c = r.position, f = h.width + l[1] + l[3], g = h.height + l[0] + l[2], d = r.align;
        d === "right" && (c[0] -= f), d === "center" && (c[0] -= f / 2);
        var A = r.verticalAlign;
        A === "bottom" && (c[1] -= g), A === "middle" && (c[1] -= g / 2), vNt(c, f, g, i);
        var p = s.get("backgroundColor");
        (!p || p === "auto") && (p = t.get(["axisLine", "lineStyle", "color"])), n.label = { x: c[0], y: c[1], style: Je(s, { text: o, font: u, fill: s.getTextColor(), padding: l, backgroundColor: p }), z2: 10 };
      }
      function vNt(n, t, e, i) {
        var r = i.getWidth(), a = i.getHeight();
        n[0] = Math.min(n[0] + t, r) - t, n[1] = Math.min(n[1] + e, a) - e, n[0] = Math.max(n[0], 0), n[1] = Math.max(n[1], 0);
      }
      function lY(n, t, e, i, r) {
        n = t.scale.parse(n);
        var a = t.scale.getLabel({ value: n }, { precision: r.precision }), o = r.formatter;
        if (o) {
          var s = { value: wM(t, { value: n }), axisDimension: t.dim, axisIndex: t.index, seriesData: [] };
          D(i, function(l) {
            var u = e.getSeriesByIndex(l.seriesIndex), h = l.dataIndexInside, c = u && u.getDataParams(h);
            c && s.seriesData.push(c);
          }), ht(o) ? a = o.replace("{value}", a) : yt(o) && (a = o(s));
        }
        return a;
      }
      function QR(n, t, e) {
        var i = Vr();
        return _h(i, i, e.rotation), Go(i, i, e.position), no([n.dataToCoord(t), (e.labelOffset || 0) + (e.labelDirection || 1) * (e.labelMargin || 0)], i);
      }
      function uY(n, t, e, i, r, a) {
        var o = rr.innerTextLayout(e.rotation, 0, e.labelDirection);
        e.labelMargin = r.get(["label", "margin"]), sY(t, i, r, a, { position: QR(i.axis, n, e), align: o.textAlign, verticalAlign: o.textVerticalAlign });
      }
      function zR(n, t, e) {
        return e = e || 0, { x1: n[e], y1: n[1 - e], x2: t[e], y2: t[1 - e] };
      }
      function hY(n, t, e) {
        return e = e || 0, { x: n[e], y: n[1 - e], width: t[e], height: t[1 - e] };
      }
      function cY(n, t, e, i, r, a) {
        return { cx: n, cy: t, r0: e, r: i, startAngle: r, endAngle: a, clockwise: true };
      }
      var yNt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.makeElOption = function(e, i, r, a, o) {
          var s = r.axis, l = s.grid, u = a.get("type"), h = fY(l, s).getOtherAxis(s).getGlobalExtent(), c = s.toGlobalCoord(s.dataToCoord(i, true));
          if (u && u !== "none") {
            var f = OR(a), g = mNt[u](s, c, h);
            g.style = f, e.graphicKey = g.type, e.pointer = g;
          }
          var d = eD(l.model, r);
          uY(i, e, d, r, a, o);
        }, t.prototype.getHandleTransform = function(e, i, r) {
          var a = eD(i.axis.grid.model, i, { labelInside: false });
          a.labelMargin = r.get(["handle", "margin"]);
          var o = QR(i.axis, e, a);
          return { x: o[0], y: o[1], rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0) };
        }, t.prototype.updateHandleTransform = function(e, i, r, a) {
          var o = r.axis, s = o.grid, l = o.getGlobalExtent(true), u = fY(s, o).getOtherAxis(o).getGlobalExtent(), h = o.dim === "x" ? 0 : 1, c = [e.x, e.y];
          c[h] += i[h], c[h] = Math.min(l[1], c[h]), c[h] = Math.max(l[0], c[h]);
          var f = (u[1] + u[0]) / 2, g = [f, f];
          g[h] = c[h];
          var d = [{ verticalAlign: "middle" }, { align: "center" }];
          return { x: c[0], y: c[1], rotation: e.rotation, cursorPoint: g, tooltipOption: d[h] };
        }, t;
      }(FR);
      function fY(n, t) {
        var e = {};
        return e[t.dim + "AxisIndex"] = t.index, n.getCartesian(e);
      }
      var mNt = { line: function(n, t, e) {
        var i = zR([t, e[0]], [t, e[1]], gY(n));
        return { type: "Line", subPixelOptimize: true, shape: i };
      }, shadow: function(n, t, e) {
        var i = Math.max(1, n.getBandWidth()), r = e[1] - e[0];
        return { type: "Rect", shape: hY([t - i / 2, e[0]], [i, r], gY(n)) };
      } };
      function gY(n) {
        return n.dim === "x" ? 0 : 1;
      }
      var _Nt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "axisPointer", t.defaultOption = { show: "auto", z: 50, type: "line", snap: false, triggerTooltip: true, triggerEmphasis: true, value: null, status: null, link: [], animation: null, animationDurationUpdate: 200, lineStyle: { color: "#B9BEC9", width: 1, type: "dashed" }, shadowStyle: { color: "rgba(210,219,238,0.2)" }, label: { show: true, formatter: null, precision: "auto", margin: 3, color: "#fff", padding: [5, 7, 5, 7], backgroundColor: "auto", borderColor: null, borderWidth: 0, borderRadius: 3 }, handle: { show: false, icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z", size: 45, margin: 50, color: "#333", shadowBlur: 3, shadowColor: "#aaa", shadowOffsetX: 0, shadowOffsetY: 2, throttle: 40 } }, t;
      }(ae), ol = ce(), ENt = D;
      function dY(n, t, e) {
        if (!re.node) {
          var i = t.getZr();
          ol(i).records || (ol(i).records = {}), INt(i, t);
          var r = ol(i).records[n] || (ol(i).records[n] = {});
          r.handler = e;
        }
      }
      function INt(n, t) {
        if (ol(n).initialized) return;
        ol(n).initialized = true, e("click", Gt(AY, "click")), e("mousemove", Gt(AY, "mousemove")), e("globalout", wNt);
        function e(i, r) {
          n.on(i, function(a) {
            var o = CNt(t);
            ENt(ol(n).records, function(s) {
              s && r(s, a, o.dispatchAction);
            }), xNt(o.pendings, t);
          });
        }
      }
      function xNt(n, t) {
        var e = n.showTip.length, i = n.hideTip.length, r;
        e ? r = n.showTip[e - 1] : i && (r = n.hideTip[i - 1]), r && (r.dispatchAction = null, t.dispatchAction(r));
      }
      function wNt(n, t, e) {
        n.handler("leave", null, e);
      }
      function AY(n, t, e, i) {
        t.handler(n, e, i);
      }
      function CNt(n) {
        var t = { showTip: [], hideTip: [] }, e = function(i) {
          var r = t[i.type];
          r ? r.push(i) : (i.dispatchAction = e, n.dispatchAction(i));
        };
        return { dispatchAction: e, pendings: t };
      }
      function GR(n, t) {
        if (!re.node) {
          var e = t.getZr(), i = (ol(e).records || {})[n];
          i && (ol(e).records[n] = null);
        }
      }
      var SNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = i.getComponent("tooltip"), o = e.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
          dY("axisPointer", r, function(s, l, u) {
            o !== "none" && (s === "leave" || o.indexOf(s) >= 0) && u({ type: "updateAxisPointer", currTrigger: s, x: l && l.offsetX, y: l && l.offsetY });
          });
        }, t.prototype.remove = function(e, i) {
          GR("axisPointer", i);
        }, t.prototype.dispose = function(e, i) {
          GR("axisPointer", i);
        }, t.type = "axisPointer", t;
      }(un);
      function pY(n, t) {
        var e = [], i = n.seriesIndex, r;
        if (i == null || !(r = t.getSeriesByIndex(i))) return { point: [] };
        var a = r.getData(), o = Bh(a, n);
        if (o == null || o < 0 || Z(o)) return { point: [] };
        var s = a.getItemGraphicEl(o), l = r.coordinateSystem;
        if (r.getTooltipPosition) e = r.getTooltipPosition(o) || [];
        else if (l && l.dataToPoint) if (n.isStacked) {
          var u = l.getBaseAxis(), h = l.getOtherAxis(u), c = h.dim, f = u.dim, g = c === "x" || c === "radius" ? 1 : 0, d = a.mapDimension(f), A = [];
          A[g] = a.get(d, o), A[1 - g] = a.get(a.getCalculationInfo("stackResultDimension"), o), e = l.dataToPoint(A) || [];
        } else e = l.dataToPoint(a.getValues(K(l.dimensions, function(v) {
          return a.mapDimension(v);
        }), o)) || [];
        else if (s) {
          var p = s.getBoundingRect().clone();
          p.applyTransform(s.transform), e = [p.x + p.width / 2, p.y + p.height / 2];
        }
        return { point: e, el: s };
      }
      var vY = ce();
      function bNt(n, t, e) {
        var i = n.currTrigger, r = [n.x, n.y], a = n, o = n.dispatchAction || ct(e.dispatchAction, e), s = t.getComponent("axisPointer").coordSysAxesInfo;
        if (s) {
          xI(r) && (r = pY({ seriesIndex: a.seriesIndex, dataIndex: a.dataIndex }, t).point);
          var l = xI(r), u = a.axesInfo, h = s.axesInfo, c = i === "leave" || xI(r), f = {}, g = {}, d = { list: [], map: {} }, A = { showPointer: Gt(BNt, g), showTooltip: Gt(MNt, d) };
          D(s.coordSysMap, function(v, y) {
            var m = l || v.containPoint(r);
            D(s.coordSysAxesInfo[y], function(_, I) {
              var E = _.axis, x = PNt(u, _);
              if (!c && m && (!u || x)) {
                var w = x && x.value;
                w == null && !l && (w = E.pointToData(r)), w != null && yY(_, w, A, false, f);
              }
            });
          });
          var p = {};
          return D(h, function(v, y) {
            var m = v.linkGroup;
            m && !g[y] && D(m.axesInfo, function(_, I) {
              var E = g[I];
              if (_ !== v && E) {
                var x = E.value;
                m.mapper && (x = v.axis.scale.parse(m.mapper(x, mY(_), mY(v)))), p[v.key] = x;
              }
            });
          }), D(p, function(v, y) {
            yY(h[y], v, A, true, f);
          }), DNt(g, h, f), RNt(d, r, n, o), LNt(h, o, e), f;
        }
      }
      function yY(n, t, e, i, r) {
        var a = n.axis;
        if (!(a.scale.isBlank() || !a.containData(t))) {
          if (!n.involveSeries) {
            e.showPointer(n, t);
            return;
          }
          var o = TNt(t, n), s = o.payloadBatch, l = o.snapToValue;
          s[0] && r.seriesIndex == null && X(r, s[0]), !i && n.snap && a.containData(l) && l != null && (t = l), e.showPointer(n, t, s), e.showTooltip(n, o, l);
        }
      }
      function TNt(n, t) {
        var e = t.axis, i = e.dim, r = n, a = [], o = Number.MAX_VALUE, s = -1;
        return D(t.seriesModels, function(l, u) {
          var h = l.getData().mapDimensionsAll(i), c, f;
          if (l.getAxisTooltipData) {
            var g = l.getAxisTooltipData(h, n, e);
            f = g.dataIndices, c = g.nestestValue;
          } else {
            if (f = l.getData().indicesOfNearest(h[0], n, e.type === "category" ? 0.5 : null), !f.length) return;
            c = l.getData().get(h[0], f[0]);
          }
          if (!(c == null || !isFinite(c))) {
            var d = n - c, A = Math.abs(d);
            A <= o && ((A < o || d >= 0 && s < 0) && (o = A, s = d, r = c, a.length = 0), D(f, function(p) {
              a.push({ seriesIndex: l.seriesIndex, dataIndexInside: p, dataIndex: l.getData().getRawIndex(p) });
            }));
          }
        }), { payloadBatch: a, snapToValue: r };
      }
      function BNt(n, t, e, i) {
        n[t.key] = { value: e, payloadBatch: i };
      }
      function MNt(n, t, e, i) {
        var r = e.payloadBatch, a = t.axis, o = a.model, s = t.axisPointerModel;
        if (!(!t.triggerTooltip || !r.length)) {
          var l = t.coordSys.model, u = iy(l), h = n.map[u];
          h || (h = n.map[u] = { coordSysId: l.id, coordSysIndex: l.componentIndex, coordSysType: l.type, coordSysMainType: l.mainType, dataByAxis: [] }, n.list.push(h)), h.dataByAxis.push({ axisDim: a.dim, axisIndex: o.componentIndex, axisType: o.type, axisId: o.id, value: i, valueLabelOpt: { precision: s.get(["label", "precision"]), formatter: s.get(["label", "formatter"]) }, seriesDataIndices: r.slice() });
        }
      }
      function DNt(n, t, e) {
        var i = e.axesInfo = [];
        D(t, function(r, a) {
          var o = r.axisPointerModel.option, s = n[a];
          s ? (!r.useHandle && (o.status = "show"), o.value = s.value, o.seriesDataIndices = (s.payloadBatch || []).slice()) : !r.useHandle && (o.status = "hide"), o.status === "show" && i.push({ axisDim: r.axis.dim, axisIndex: r.axis.model.componentIndex, value: o.value });
        });
      }
      function RNt(n, t, e, i) {
        if (xI(t) || !n.list.length) {
          i({ type: "hideTip" });
          return;
        }
        var r = ((n.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
        i({ type: "showTip", escapeConnect: true, x: t[0], y: t[1], tooltipOption: e.tooltipOption, position: e.position, dataIndexInside: r.dataIndexInside, dataIndex: r.dataIndex, seriesIndex: r.seriesIndex, dataByCoordSys: n.list });
      }
      function LNt(n, t, e) {
        var i = e.getZr(), r = "axisPointerLastHighlights", a = vY(i)[r] || {}, o = vY(i)[r] = {};
        D(n, function(u, h) {
          var c = u.axisPointerModel.option;
          c.status === "show" && u.triggerEmphasis && D(c.seriesDataIndices, function(f) {
            var g = f.seriesIndex + " | " + f.dataIndex;
            o[g] = f;
          });
        });
        var s = [], l = [];
        D(a, function(u, h) {
          !o[h] && l.push(u);
        }), D(o, function(u, h) {
          !a[h] && s.push(u);
        }), l.length && e.dispatchAction({ type: "downplay", escapeConnect: true, notBlur: true, batch: l }), s.length && e.dispatchAction({ type: "highlight", escapeConnect: true, notBlur: true, batch: s });
      }
      function PNt(n, t) {
        for (var e = 0; e < (n || []).length; e++) {
          var i = n[e];
          if (t.axis.dim === i.axisDim && t.axis.model.componentIndex === i.axisIndex) return i;
        }
      }
      function mY(n) {
        var t = n.axis.model, e = {}, i = e.axisDim = n.axis.dim;
        return e.axisIndex = e[i + "AxisIndex"] = t.componentIndex, e.axisName = e[i + "AxisName"] = t.name, e.axisId = e[i + "AxisId"] = t.id, e;
      }
      function xI(n) {
        return !n || n[0] == null || isNaN(n[0]) || n[1] == null || isNaN(n[1]);
      }
      function Ey(n) {
        pc.registerAxisPointerClass("CartesianAxisPointer", yNt), n.registerComponentModel(_Nt), n.registerComponentView(SNt), n.registerPreprocessor(function(t) {
          if (t) {
            (!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {});
            var e = t.axisPointer.link;
            e && !Z(e) && (t.axisPointer.link = [e]);
          }
        }), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, function(t, e) {
          t.getComponent("axisPointer").coordSysAxesInfo = qTt(t, e);
        }), n.registerAction({ type: "updateAxisPointer", event: "updateAxisPointer", update: ":updateAxisPointer" }, bNt);
      }
      function NNt(n) {
        Kt(W9), Kt(Ey);
      }
      var FNt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.makeElOption = function(e, i, r, a, o) {
          var s = r.axis;
          s.dim === "angle" && (this.animationThreshold = Math.PI / 18);
          var l = s.polar, u = l.getOtherAxis(s), h = u.getExtent(), c = s.dataToCoord(i), f = a.get("type");
          if (f && f !== "none") {
            var g = OR(a), d = ONt[f](s, l, c, h);
            d.style = g, e.graphicKey = d.type, e.pointer = d;
          }
          var A = a.get(["label", "margin"]), p = kNt(i, r, a, l, A);
          sY(e, r, a, o, p);
        }, t;
      }(FR);
      function kNt(n, t, e, i, r) {
        var a = t.axis, o = a.dataToCoord(n), s = i.getAngleAxis().getExtent()[0];
        s = s / 180 * Math.PI;
        var l = i.getRadiusAxis().getExtent(), u, h, c;
        if (a.dim === "radius") {
          var f = Vr();
          _h(f, f, s), Go(f, f, [i.cx, i.cy]), u = no([o, -r], f);
          var g = t.getModel("axisLabel").get("rotate") || 0, d = rr.innerTextLayout(s, g * Math.PI / 180, -1);
          h = d.textAlign, c = d.textVerticalAlign;
        } else {
          var A = l[1];
          u = i.coordToPoint([A + r, o]);
          var p = i.cx, v = i.cy;
          h = Math.abs(u[0] - p) / A < 0.3 ? "center" : u[0] > p ? "left" : "right", c = Math.abs(u[1] - v) / A < 0.3 ? "middle" : u[1] > v ? "top" : "bottom";
        }
        return { position: u, align: h, verticalAlign: c };
      }
      var ONt = { line: function(n, t, e, i) {
        return n.dim === "angle" ? { type: "Line", shape: zR(t.coordToPoint([i[0], e]), t.coordToPoint([i[1], e])) } : { type: "Circle", shape: { cx: t.cx, cy: t.cy, r: e } };
      }, shadow: function(n, t, e, i) {
        var r = Math.max(1, n.getBandWidth()), a = Math.PI / 180;
        return n.dim === "angle" ? { type: "Sector", shape: cY(t.cx, t.cy, i[0], i[1], (-e - r / 2) * a, (-e + r / 2) * a) } : { type: "Sector", shape: cY(t.cx, t.cy, e - r / 2, e + r / 2, 0, Math.PI * 2) };
      } }, QNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.findAxisModel = function(e) {
          var i, r = this.ecModel;
          return r.eachComponent(e, function(a) {
            a.getCoordSysModel() === this && (i = a);
          }, this), i;
        }, t.type = "polar", t.dependencies = ["radiusAxis", "angleAxis"], t.defaultOption = { z: 0, center: ["50%", "50%"], radius: "80%" }, t;
      }(ae), UR = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.getCoordSysModel = function() {
          return this.getReferringComponents("polar", zn).models[0];
        }, t.type = "polarAxis", t;
      }(ae);
      kn(UR, jv);
      var zNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "angleAxis", t;
      }(UR), GNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "radiusAxis", t;
      }(UR), VR = function(n) {
        V(t, n);
        function t(e, i) {
          return n.call(this, "radius", e, i) || this;
        }
        return t.prototype.pointToData = function(e, i) {
          return this.polar.pointToData(e, i)[this.dim === "radius" ? 0 : 1];
        }, t;
      }(ao);
      VR.prototype.dataToRadius = ao.prototype.dataToCoord, VR.prototype.radiusToData = ao.prototype.coordToData;
      var UNt = ce(), jR = function(n) {
        V(t, n);
        function t(e, i) {
          return n.call(this, "angle", e, i || [0, 360]) || this;
        }
        return t.prototype.pointToData = function(e, i) {
          return this.polar.pointToData(e, i)[this.dim === "radius" ? 0 : 1];
        }, t.prototype.calculateCategoryInterval = function() {
          var e = this, i = e.getLabelModel(), r = e.scale, a = r.getExtent(), o = r.count();
          if (a[1] - a[0] < 1) return 0;
          var s = a[0], l = e.dataToCoord(s + 1) - e.dataToCoord(s), u = Math.abs(l), h = $p(s == null ? "" : s + "", i.getFont(), "center", "top"), c = Math.max(h.height, 7), f = c / u;
          isNaN(f) && (f = 1 / 0);
          var g = Math.max(0, Math.floor(f)), d = UNt(e.model), A = d.lastAutoInterval, p = d.lastTickCount;
          return A != null && p != null && Math.abs(A - g) <= 1 && Math.abs(p - o) <= 1 && A > g ? g = A : (d.lastTickCount = o, d.lastAutoInterval = g), g;
        }, t;
      }(ao);
      jR.prototype.dataToAngle = ao.prototype.dataToCoord, jR.prototype.angleToData = ao.prototype.coordToData;
      var _Y = ["radius", "angle"], VNt = function() {
        function n(t) {
          this.dimensions = _Y, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new VR(), this._angleAxis = new jR(), this.axisPointerEnabled = true, this.name = t || "", this._radiusAxis.polar = this._angleAxis.polar = this;
        }
        return n.prototype.containPoint = function(t) {
          var e = this.pointToCoord(t);
          return this._radiusAxis.contain(e[0]) && this._angleAxis.contain(e[1]);
        }, n.prototype.containData = function(t) {
          return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1]);
        }, n.prototype.getAxis = function(t) {
          var e = "_" + t + "Axis";
          return this[e];
        }, n.prototype.getAxes = function() {
          return [this._radiusAxis, this._angleAxis];
        }, n.prototype.getAxesByScale = function(t) {
          var e = [], i = this._angleAxis, r = this._radiusAxis;
          return i.scale.type === t && e.push(i), r.scale.type === t && e.push(r), e;
        }, n.prototype.getAngleAxis = function() {
          return this._angleAxis;
        }, n.prototype.getRadiusAxis = function() {
          return this._radiusAxis;
        }, n.prototype.getOtherAxis = function(t) {
          var e = this._angleAxis;
          return t === e ? this._radiusAxis : e;
        }, n.prototype.getBaseAxis = function() {
          return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
        }, n.prototype.getTooltipAxes = function(t) {
          var e = t != null && t !== "auto" ? this.getAxis(t) : this.getBaseAxis();
          return { baseAxes: [e], otherAxes: [this.getOtherAxis(e)] };
        }, n.prototype.dataToPoint = function(t, e) {
          return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], e), this._angleAxis.dataToAngle(t[1], e)]);
        }, n.prototype.pointToData = function(t, e) {
          var i = this.pointToCoord(t);
          return [this._radiusAxis.radiusToData(i[0], e), this._angleAxis.angleToData(i[1], e)];
        }, n.prototype.pointToCoord = function(t) {
          var e = t[0] - this.cx, i = t[1] - this.cy, r = this.getAngleAxis(), a = r.getExtent(), o = Math.min(a[0], a[1]), s = Math.max(a[0], a[1]);
          r.inverse ? o = s - 360 : s = o + 360;
          var l = Math.sqrt(e * e + i * i);
          e /= l, i /= l;
          for (var u = Math.atan2(-i, e) / Math.PI * 180, h = u < o ? 1 : -1; u < o || u > s; ) u += h * 360;
          return [l, u];
        }, n.prototype.coordToPoint = function(t) {
          var e = t[0], i = t[1] / 180 * Math.PI, r = Math.cos(i) * e + this.cx, a = -Math.sin(i) * e + this.cy;
          return [r, a];
        }, n.prototype.getArea = function() {
          var t = this.getAngleAxis(), e = this.getRadiusAxis(), i = e.getExtent().slice();
          i[0] > i[1] && i.reverse();
          var r = t.getExtent(), a = Math.PI / 180;
          return { cx: this.cx, cy: this.cy, r0: i[0], r: i[1], startAngle: -r[0] * a, endAngle: -r[1] * a, clockwise: t.inverse, contain: function(o, s) {
            var l = o - this.cx, u = s - this.cy, h = l * l + u * u - 1e-4, c = this.r, f = this.r0;
            return h <= c * c && h >= f * f;
          } };
        }, n.prototype.convertToPixel = function(t, e, i) {
          var r = EY(e);
          return r === this ? this.dataToPoint(i) : null;
        }, n.prototype.convertFromPixel = function(t, e, i) {
          var r = EY(e);
          return r === this ? this.pointToData(i) : null;
        }, n;
      }();
      function EY(n) {
        var t = n.seriesModel, e = n.polarModel;
        return e && e.coordinateSystem || t && t.coordinateSystem;
      }
      function jNt(n, t, e) {
        var i = t.get("center"), r = e.getWidth(), a = e.getHeight();
        n.cx = st(i[0], r), n.cy = st(i[1], a);
        var o = n.getRadiusAxis(), s = Math.min(r, a) / 2, l = t.get("radius");
        l == null ? l = [0, "100%"] : Z(l) || (l = [0, l]);
        var u = [st(l[0], s), st(l[1], s)];
        o.inverse ? o.setExtent(u[1], u[0]) : o.setExtent(u[0], u[1]);
      }
      function qNt(n, t) {
        var e = this, i = e.getAngleAxis(), r = e.getRadiusAxis();
        if (i.scale.setExtent(1 / 0, -1 / 0), r.scale.setExtent(1 / 0, -1 / 0), n.eachSeries(function(s) {
          if (s.coordinateSystem === e) {
            var l = s.getData();
            D(kE(l, "radius"), function(u) {
              r.scale.unionExtentFromData(l, u);
            }), D(kE(l, "angle"), function(u) {
              i.scale.unionExtentFromData(l, u);
            });
          }
        }), gd(i.scale, i.model), gd(r.scale, r.model), i.type === "category" && !i.onBand) {
          var a = i.getExtent(), o = 360 / i.scale.count();
          i.inverse ? a[1] += o : a[1] -= o, i.setExtent(a[0], a[1]);
        }
      }
      function HNt(n) {
        return n.mainType === "angleAxis";
      }
      function IY(n, t) {
        var e;
        if (n.type = t.get("type"), n.scale = FE(t), n.onBand = t.get("boundaryGap") && n.type === "category", n.inverse = t.get("inverse"), HNt(t)) {
          n.inverse = n.inverse !== t.get("clockwise");
          var i = t.get("startAngle"), r = (e = t.get("endAngle")) !== null && e !== void 0 ? e : i + (n.inverse ? -360 : 360);
          n.setExtent(i, r);
        }
        t.axis = n, n.model = t;
      }
      var YNt = { dimensions: _Y, create: function(n, t) {
        var e = [];
        return n.eachComponent("polar", function(i, r) {
          var a = new VNt(r + "");
          a.update = qNt;
          var o = a.getRadiusAxis(), s = a.getAngleAxis(), l = i.findAxisModel("radiusAxis"), u = i.findAxisModel("angleAxis");
          IY(o, l), IY(s, u), jNt(a, i, t), e.push(a), i.coordinateSystem = a, a.model = i;
        }), n.eachSeries(function(i) {
          if (i.get("coordinateSystem") === "polar") {
            var r = i.getReferringComponents("polar", zn).models[0];
            if (!r) throw new Error('Polar "' + On(i.get("polarIndex"), i.get("polarId"), 0) + '" not found');
            i.coordinateSystem = r.coordinateSystem;
          }
        }), e;
      } }, WNt = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
      function wI(n, t, e) {
        t[1] > t[0] && (t = t.slice().reverse());
        var i = n.coordToPoint([t[0], e]), r = n.coordToPoint([t[1], e]);
        return { x1: i[0], y1: i[1], x2: r[0], y2: r[1] };
      }
      function CI(n) {
        var t = n.getRadiusAxis();
        return t.inverse ? 0 : 1;
      }
      function xY(n) {
        var t = n[0], e = n[n.length - 1];
        t && e && Math.abs(Math.abs(t.coord - e.coord) - 360) < 1e-4 && n.pop();
      }
      var XNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.axisPointerClass = "PolarAxisPointer", e;
        }
        return t.prototype.render = function(e, i) {
          if (this.group.removeAll(), !!e.get("show")) {
            var r = e.axis, a = r.polar, o = a.getRadiusAxis().getExtent(), s = r.getTicksCoords(), l = r.getMinorTicksCoords(), u = K(r.getViewLabels(), function(h) {
              h = Ct(h);
              var c = r.scale, f = c.type === "ordinal" ? c.getRawOrdinalNumber(h.tickValue) : h.tickValue;
              return h.coord = r.dataToCoord(f), h;
            });
            xY(u), xY(s), D(WNt, function(h) {
              e.get([h, "show"]) && (!r.scale.isBlank() || h === "axisLine") && $Nt[h](this.group, e, a, s, l, o, u);
            }, this);
          }
        }, t.type = "angleAxis", t;
      }(pc), $Nt = { axisLine: function(n, t, e, i, r, a) {
        var o = t.getModel(["axisLine", "lineStyle"]), s = e.getAngleAxis(), l = Math.PI / 180, u = s.getExtent(), h = CI(e), c = h ? 0 : 1, f, g = Math.abs(u[1] - u[0]) === 360 ? "Circle" : "Arc";
        a[c] === 0 ? f = new Wh[g]({ shape: { cx: e.cx, cy: e.cy, r: a[h], startAngle: -u[0] * l, endAngle: -u[1] * l, clockwise: s.inverse }, style: o.getLineStyle(), z2: 1, silent: true }) : f = new fv({ shape: { cx: e.cx, cy: e.cy, r: a[h], r0: a[c] }, style: o.getLineStyle(), z2: 1, silent: true }), f.style.fill = null, n.add(f);
      }, axisTick: function(n, t, e, i, r, a) {
        var o = t.getModel("axisTick"), s = (o.get("inside") ? -1 : 1) * o.get("length"), l = a[CI(e)], u = K(i, function(h) {
          return new Kn({ shape: wI(e, [l, l + s], h.coord) });
        });
        n.add(_a(u, { style: wt(o.getModel("lineStyle").getLineStyle(), { stroke: t.get(["axisLine", "lineStyle", "color"]) }) }));
      }, minorTick: function(n, t, e, i, r, a) {
        if (r.length) {
          for (var o = t.getModel("axisTick"), s = t.getModel("minorTick"), l = (o.get("inside") ? -1 : 1) * s.get("length"), u = a[CI(e)], h = [], c = 0; c < r.length; c++) for (var f = 0; f < r[c].length; f++) h.push(new Kn({ shape: wI(e, [u, u + l], r[c][f].coord) }));
          n.add(_a(h, { style: wt(s.getModel("lineStyle").getLineStyle(), wt(o.getLineStyle(), { stroke: t.get(["axisLine", "lineStyle", "color"]) })) }));
        }
      }, axisLabel: function(n, t, e, i, r, a, o) {
        var s = t.getCategories(true), l = t.getModel("axisLabel"), u = l.get("margin"), h = t.get("triggerEvent");
        D(o, function(c, f) {
          var g = l, d = c.tickValue, A = a[CI(e)], p = e.coordToPoint([A + u, c.coord]), v = e.cx, y = e.cy, m = Math.abs(p[0] - v) / A < 0.3 ? "center" : p[0] > v ? "left" : "right", _ = Math.abs(p[1] - y) / A < 0.3 ? "middle" : p[1] > y ? "top" : "bottom";
          if (s && s[d]) {
            var I = s[d];
            Et(I) && I.textStyle && (g = new De(I.textStyle, l, l.ecModel));
          }
          var E = new Ae({ silent: rr.isLabelSilent(t), style: Je(g, { x: p[0], y: p[1], fill: g.getTextColor() || t.get(["axisLine", "lineStyle", "color"]), text: c.formattedLabel, align: m, verticalAlign: _ }) });
          if (n.add(E), h) {
            var x = rr.makeAxisEventDataBase(t);
            x.targetType = "axisLabel", x.value = c.rawLabel, Nt(E).eventData = x;
          }
        }, this);
      }, splitLine: function(n, t, e, i, r, a) {
        var o = t.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0;
        l = l instanceof Array ? l : [l];
        for (var h = [], c = 0; c < i.length; c++) {
          var f = u++ % l.length;
          h[f] = h[f] || [], h[f].push(new Kn({ shape: wI(e, a, i[c].coord) }));
        }
        for (var c = 0; c < h.length; c++) n.add(_a(h[c], { style: wt({ stroke: l[c % l.length] }, s.getLineStyle()), silent: true, z: t.get("z") }));
      }, minorSplitLine: function(n, t, e, i, r, a) {
        if (r.length) {
          for (var o = t.getModel("minorSplitLine"), s = o.getModel("lineStyle"), l = [], u = 0; u < r.length; u++) for (var h = 0; h < r[u].length; h++) l.push(new Kn({ shape: wI(e, a, r[u][h].coord) }));
          n.add(_a(l, { style: s.getLineStyle(), silent: true, z: t.get("z") }));
        }
      }, splitArea: function(n, t, e, i, r, a) {
        if (i.length) {
          var o = t.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
          l = l instanceof Array ? l : [l];
          for (var h = [], c = Math.PI / 180, f = -i[0].coord * c, g = Math.min(a[0], a[1]), d = Math.max(a[0], a[1]), A = t.get("clockwise"), p = 1, v = i.length; p <= v; p++) {
            var y = p === v ? i[0].coord : i[p].coord, m = u++ % l.length;
            h[m] = h[m] || [], h[m].push(new Zi({ shape: { cx: e.cx, cy: e.cy, r0: g, r: d, startAngle: f, endAngle: -y * c, clockwise: A }, silent: true })), f = -y * c;
          }
          for (var p = 0; p < h.length; p++) n.add(_a(h[p], { style: wt({ fill: l[p % l.length] }, s.getAreaStyle()), silent: true }));
        }
      } }, ZNt = ["axisLine", "axisTickLabel", "axisName"], KNt = ["splitLine", "splitArea", "minorSplitLine"], JNt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.axisPointerClass = "PolarAxisPointer", e;
        }
        return t.prototype.render = function(e, i) {
          if (this.group.removeAll(), !!e.get("show")) {
            var r = this._axisGroup, a = this._axisGroup = new Dt();
            this.group.add(a);
            var o = e.axis, s = o.polar, l = s.getAngleAxis(), u = o.getTicksCoords(), h = o.getMinorTicksCoords(), c = l.getExtent()[0], f = o.getExtent(), g = eFt(s, e, c), d = new rr(e, g);
            D(ZNt, d.add, d), a.add(d.getGroup()), pv(r, a, e), D(KNt, function(A) {
              e.get([A, "show"]) && !o.scale.isBlank() && tFt[A](this.group, e, s, c, f, u, h);
            }, this);
          }
        }, t.type = "radiusAxis", t;
      }(pc), tFt = { splitLine: function(n, t, e, i, r, a) {
        var o = t.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0, h = e.getAngleAxis(), c = Math.PI / 180, f = h.getExtent(), g = Math.abs(f[1] - f[0]) === 360 ? "Circle" : "Arc";
        l = l instanceof Array ? l : [l];
        for (var d = [], A = 0; A < a.length; A++) {
          var p = u++ % l.length;
          d[p] = d[p] || [], d[p].push(new Wh[g]({ shape: { cx: e.cx, cy: e.cy, r: Math.max(a[A].coord, 0), startAngle: -f[0] * c, endAngle: -f[1] * c, clockwise: h.inverse } }));
        }
        for (var A = 0; A < d.length; A++) n.add(_a(d[A], { style: wt({ stroke: l[A % l.length], fill: null }, s.getLineStyle()), silent: true }));
      }, minorSplitLine: function(n, t, e, i, r, a, o) {
        if (o.length) {
          for (var s = t.getModel("minorSplitLine"), l = s.getModel("lineStyle"), u = [], h = 0; h < o.length; h++) for (var c = 0; c < o[h].length; c++) u.push(new $s({ shape: { cx: e.cx, cy: e.cy, r: o[h][c].coord } }));
          n.add(_a(u, { style: wt({ fill: null }, l.getLineStyle()), silent: true }));
        }
      }, splitArea: function(n, t, e, i, r, a) {
        if (a.length) {
          var o = t.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
          l = l instanceof Array ? l : [l];
          for (var h = [], c = a[0].coord, f = 1; f < a.length; f++) {
            var g = u++ % l.length;
            h[g] = h[g] || [], h[g].push(new Zi({ shape: { cx: e.cx, cy: e.cy, r0: c, r: a[f].coord, startAngle: 0, endAngle: Math.PI * 2 }, silent: true })), c = a[f].coord;
          }
          for (var f = 0; f < h.length; f++) n.add(_a(h[f], { style: wt({ fill: l[f % l.length] }, s.getAreaStyle()), silent: true }));
        }
      } };
      function eFt(n, t, e) {
        return { position: [n.cx, n.cy], rotation: e / 180 * Math.PI, labelDirection: -1, tickDirection: -1, nameDirection: 1, labelRotate: t.getModel("axisLabel").get("rotate"), z2: 1 };
      }
      function wY(n) {
        return n.get("stack") || "__ec_stack_" + n.seriesIndex;
      }
      function CY(n, t) {
        return t.dim + n.model.componentIndex;
      }
      function nFt(n, t, e) {
        var i = {}, r = iFt(Fe(t.getSeriesByType(n), function(a) {
          return !t.isSeriesFiltered(a) && a.coordinateSystem && a.coordinateSystem.type === "polar";
        }));
        t.eachSeriesByType(n, function(a) {
          if (a.coordinateSystem.type === "polar") {
            var o = a.getData(), s = a.coordinateSystem, l = s.getBaseAxis(), u = CY(s, l), h = wY(a), c = r[u][h], f = c.offset, g = c.width, d = s.getOtherAxis(l), A = a.coordinateSystem.cx, p = a.coordinateSystem.cy, v = a.get("barMinHeight") || 0, y = a.get("barMinAngle") || 0;
            i[h] = i[h] || [];
            for (var m = o.mapDimension(d.dim), _ = o.mapDimension(l.dim), I = yu(o, m), E = l.dim !== "radius" || !a.get("roundCap", true), x = d.model, w = x.get("startValue"), C = d.dataToCoord(w || 0), S = 0, b = o.count(); S < b; S++) {
              var T = o.get(m, S), B = o.get(_, S), R = T >= 0 ? "p" : "n", M = C;
              I && (i[h][B] || (i[h][B] = { p: C, n: C }), M = i[h][B][R]);
              var L = void 0, N = void 0, F = void 0, k = void 0;
              if (d.dim === "radius") {
                var O = d.dataToCoord(T) - C, Q = l.dataToCoord(B);
                Math.abs(O) < v && (O = (O < 0 ? -1 : 1) * v), L = M, N = M + O, F = Q - f, k = F - g, I && (i[h][B][R] = N);
              } else {
                var j = d.dataToCoord(T, E) - C, Y = l.dataToCoord(B);
                Math.abs(j) < y && (j = (j < 0 ? -1 : 1) * y), L = Y + f, N = L + g, F = M, k = M + j, I && (i[h][B][R] = k);
              }
              o.setItemLayout(S, { cx: A, cy: p, r0: L, r: N, startAngle: -F * Math.PI / 180, endAngle: -k * Math.PI / 180, clockwise: F >= k });
            }
          }
        });
      }
      function iFt(n) {
        var t = {};
        D(n, function(i, r) {
          var a = i.getData(), o = i.coordinateSystem, s = o.getBaseAxis(), l = CY(o, s), u = s.getExtent(), h = s.type === "category" ? s.getBandWidth() : Math.abs(u[1] - u[0]) / a.count(), c = t[l] || { bandWidth: h, remainedWidth: h, autoWidthCount: 0, categoryGap: "20%", gap: "30%", stacks: {} }, f = c.stacks;
          t[l] = c;
          var g = wY(i);
          f[g] || c.autoWidthCount++, f[g] = f[g] || { width: 0, maxWidth: 0 };
          var d = st(i.get("barWidth"), h), A = st(i.get("barMaxWidth"), h), p = i.get("barGap"), v = i.get("barCategoryGap");
          d && !f[g].width && (d = Math.min(c.remainedWidth, d), f[g].width = d, c.remainedWidth -= d), A && (f[g].maxWidth = A), p != null && (c.gap = p), v != null && (c.categoryGap = v);
        });
        var e = {};
        return D(t, function(i, r) {
          e[r] = {};
          var a = i.stacks, o = i.bandWidth, s = st(i.categoryGap, o), l = st(i.gap, 1), u = i.remainedWidth, h = i.autoWidthCount, c = (u - s) / (h + (h - 1) * l);
          c = Math.max(c, 0), D(a, function(A, p) {
            var v = A.maxWidth;
            v && v < c && (v = Math.min(v, u), A.width && (v = Math.min(v, A.width)), u -= v, A.width = v, h--);
          }), c = (u - s) / (h + (h - 1) * l), c = Math.max(c, 0);
          var f = 0, g;
          D(a, function(A, p) {
            A.width || (A.width = c), g = A, f += A.width * (1 + l);
          }), g && (f -= g.width * l);
          var d = -f / 2;
          D(a, function(A, p) {
            e[r][p] = e[r][p] || { offset: d, width: A.width }, d += A.width * (1 + l);
          });
        }), e;
      }
      var rFt = { startAngle: 90, clockwise: true, splitNumber: 12, axisLabel: { rotate: 0 } }, aFt = { splitNumber: 5 }, oFt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "polar", t;
      }(un);
      function sFt(n) {
        Kt(Ey), pc.registerAxisPointerClass("PolarAxisPointer", FNt), n.registerCoordinateSystem("polar", YNt), n.registerComponentModel(QNt), n.registerComponentView(oFt), yd(n, "angle", zNt, rFt), yd(n, "radius", GNt, aFt), n.registerComponentView(XNt), n.registerComponentView(JNt), n.registerLayout(Gt(nFt, "bar"));
      }
      function qR(n, t) {
        t = t || {};
        var e = n.coordinateSystem, i = n.axis, r = {}, a = i.position, o = i.orient, s = e.getRect(), l = [s.x, s.x + s.width, s.y, s.y + s.height], u = { horizontal: { top: l[2], bottom: l[3] }, vertical: { left: l[0], right: l[1] } };
        r.position = [o === "vertical" ? u.vertical[a] : l[0], o === "horizontal" ? u.horizontal[a] : l[3]];
        var h = { horizontal: 0, vertical: 1 };
        r.rotation = Math.PI / 2 * h[o];
        var c = { top: -1, bottom: 1, right: 1, left: -1 };
        r.labelDirection = r.tickDirection = r.nameDirection = c[a], n.get(["axisTick", "inside"]) && (r.tickDirection = -r.tickDirection), On(t.labelInside, n.get(["axisLabel", "inside"])) && (r.labelDirection = -r.labelDirection);
        var f = t.rotate;
        return f == null && (f = n.get(["axisLabel", "rotate"])), r.labelRotation = a === "top" ? -f : f, r.z2 = 1, r;
      }
      var lFt = ["axisLine", "axisTickLabel", "axisName"], uFt = ["splitArea", "splitLine"], hFt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.axisPointerClass = "SingleAxisPointer", e;
        }
        return t.prototype.render = function(e, i, r, a) {
          var o = this.group;
          o.removeAll();
          var s = this._axisGroup;
          this._axisGroup = new Dt();
          var l = qR(e), u = new rr(e, l);
          D(lFt, u.add, u), o.add(this._axisGroup), o.add(u.getGroup()), D(uFt, function(h) {
            e.get([h, "show"]) && cFt[h](this, this.group, this._axisGroup, e);
          }, this), pv(s, this._axisGroup, e), n.prototype.render.call(this, e, i, r, a);
        }, t.prototype.remove = function() {
          j9(this);
        }, t.type = "singleAxis", t;
      }(pc), cFt = { splitLine: function(n, t, e, i) {
        var r = i.axis;
        if (!r.scale.isBlank()) {
          var a = i.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color");
          s = s instanceof Array ? s : [s];
          for (var l = o.get("width"), u = i.coordinateSystem.getRect(), h = r.isHorizontal(), c = [], f = 0, g = r.getTicksCoords({ tickModel: a }), d = [], A = [], p = 0; p < g.length; ++p) {
            var v = r.toGlobalCoord(g[p].coord);
            h ? (d[0] = v, d[1] = u.y, A[0] = v, A[1] = u.y + u.height) : (d[0] = u.x, d[1] = v, A[0] = u.x + u.width, A[1] = v);
            var y = new Kn({ shape: { x1: d[0], y1: d[1], x2: A[0], y2: A[1] }, silent: true });
            jg(y.shape, l);
            var m = f++ % s.length;
            c[m] = c[m] || [], c[m].push(y);
          }
          for (var _ = o.getLineStyle(["color"]), p = 0; p < c.length; ++p) t.add(_a(c[p], { style: wt({ stroke: s[p % s.length] }, _), silent: true }));
        }
      }, splitArea: function(n, t, e, i) {
        V9(n, e, i, i);
      } }, SI = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.getCoordSysModel = function() {
          return this;
        }, t.type = "singleAxis", t.layoutMode = "box", t.defaultOption = { left: "5%", top: "5%", right: "5%", bottom: "5%", type: "value", position: "bottom", orient: "horizontal", axisLine: { show: true, lineStyle: { width: 1, type: "solid" } }, tooltip: { show: true }, axisTick: { show: true, length: 6, lineStyle: { width: 1 } }, axisLabel: { show: true, interval: "auto" }, splitLine: { show: true, lineStyle: { type: "dashed", opacity: 0.2 } } }, t;
      }(ae);
      kn(SI, jv.prototype);
      var fFt = function(n) {
        V(t, n);
        function t(e, i, r, a, o) {
          var s = n.call(this, e, i, r) || this;
          return s.type = a || "value", s.position = o || "bottom", s;
        }
        return t.prototype.isHorizontal = function() {
          var e = this.position;
          return e === "top" || e === "bottom";
        }, t.prototype.pointToData = function(e, i) {
          return this.coordinateSystem.pointToData(e)[0];
        }, t;
      }(ao), SY = ["single"], gFt = function() {
        function n(t, e, i) {
          this.type = "single", this.dimension = "single", this.dimensions = SY, this.axisPointerEnabled = true, this.model = t, this._init(t, e, i);
        }
        return n.prototype._init = function(t, e, i) {
          var r = this.dimension, a = new fFt(r, FE(t), [0, 0], t.get("type"), t.get("position")), o = a.type === "category";
          a.onBand = o && t.get("boundaryGap"), a.inverse = t.get("inverse"), a.orient = t.get("orient"), t.axis = a, a.model = t, a.coordinateSystem = this, this._axis = a;
        }, n.prototype.update = function(t, e) {
          t.eachSeries(function(i) {
            if (i.coordinateSystem === this) {
              var r = i.getData();
              D(r.mapDimensionsAll(this.dimension), function(a) {
                this._axis.scale.unionExtentFromData(r, a);
              }, this), gd(this._axis.scale, this._axis.model);
            }
          }, this);
        }, n.prototype.resize = function(t, e) {
          this._rect = Yn({ left: t.get("left"), top: t.get("top"), right: t.get("right"), bottom: t.get("bottom"), width: t.get("width"), height: t.get("height") }, { width: e.getWidth(), height: e.getHeight() }), this._adjustAxis();
        }, n.prototype.getRect = function() {
          return this._rect;
        }, n.prototype._adjustAxis = function() {
          var t = this._rect, e = this._axis, i = e.isHorizontal(), r = i ? [0, t.width] : [0, t.height], a = e.inverse ? 1 : 0;
          e.setExtent(r[a], r[1 - a]), this._updateAxisTransform(e, i ? t.x : t.y);
        }, n.prototype._updateAxisTransform = function(t, e) {
          var i = t.getExtent(), r = i[0] + i[1], a = t.isHorizontal();
          t.toGlobalCoord = a ? function(o) {
            return o + e;
          } : function(o) {
            return r - o + e;
          }, t.toLocalCoord = a ? function(o) {
            return o - e;
          } : function(o) {
            return r - o + e;
          };
        }, n.prototype.getAxis = function() {
          return this._axis;
        }, n.prototype.getBaseAxis = function() {
          return this._axis;
        }, n.prototype.getAxes = function() {
          return [this._axis];
        }, n.prototype.getTooltipAxes = function() {
          return { baseAxes: [this.getAxis()], otherAxes: [] };
        }, n.prototype.containPoint = function(t) {
          var e = this.getRect(), i = this.getAxis(), r = i.orient;
          return r === "horizontal" ? i.contain(i.toLocalCoord(t[0])) && t[1] >= e.y && t[1] <= e.y + e.height : i.contain(i.toLocalCoord(t[1])) && t[0] >= e.y && t[0] <= e.y + e.height;
        }, n.prototype.pointToData = function(t) {
          var e = this.getAxis();
          return [e.coordToData(e.toLocalCoord(t[e.orient === "horizontal" ? 0 : 1]))];
        }, n.prototype.dataToPoint = function(t) {
          var e = this.getAxis(), i = this.getRect(), r = [], a = e.orient === "horizontal" ? 0 : 1;
          return t instanceof Array && (t = t[0]), r[a] = e.toGlobalCoord(e.dataToCoord(+t)), r[1 - a] = a === 0 ? i.y + i.height / 2 : i.x + i.width / 2, r;
        }, n.prototype.convertToPixel = function(t, e, i) {
          var r = bY(e);
          return r === this ? this.dataToPoint(i) : null;
        }, n.prototype.convertFromPixel = function(t, e, i) {
          var r = bY(e);
          return r === this ? this.pointToData(i) : null;
        }, n;
      }();
      function bY(n) {
        var t = n.seriesModel, e = n.singleAxisModel;
        return e && e.coordinateSystem || t && t.coordinateSystem;
      }
      function dFt(n, t) {
        var e = [];
        return n.eachComponent("singleAxis", function(i, r) {
          var a = new gFt(i, n, t);
          a.name = "single_" + r, a.resize(i, t), i.coordinateSystem = a, e.push(a);
        }), n.eachSeries(function(i) {
          if (i.get("coordinateSystem") === "singleAxis") {
            var r = i.getReferringComponents("singleAxis", zn).models[0];
            i.coordinateSystem = r && r.coordinateSystem;
          }
        }), e;
      }
      var AFt = { create: dFt, dimensions: SY }, TY = ["x", "y"], pFt = ["width", "height"], vFt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.makeElOption = function(e, i, r, a, o) {
          var s = r.axis, l = s.coordinateSystem, u = HR(l, 1 - bI(s)), h = l.dataToPoint(i)[0], c = a.get("type");
          if (c && c !== "none") {
            var f = OR(a), g = yFt[c](s, h, u);
            g.style = f, e.graphicKey = g.type, e.pointer = g;
          }
          var d = qR(r);
          uY(i, e, d, r, a, o);
        }, t.prototype.getHandleTransform = function(e, i, r) {
          var a = qR(i, { labelInside: false });
          a.labelMargin = r.get(["handle", "margin"]);
          var o = QR(i.axis, e, a);
          return { x: o[0], y: o[1], rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0) };
        }, t.prototype.updateHandleTransform = function(e, i, r, a) {
          var o = r.axis, s = o.coordinateSystem, l = bI(o), u = HR(s, l), h = [e.x, e.y];
          h[l] += i[l], h[l] = Math.min(u[1], h[l]), h[l] = Math.max(u[0], h[l]);
          var c = HR(s, 1 - l), f = (c[1] + c[0]) / 2, g = [f, f];
          return g[l] = h[l], { x: h[0], y: h[1], rotation: e.rotation, cursorPoint: g, tooltipOption: { verticalAlign: "middle" } };
        }, t;
      }(FR), yFt = { line: function(n, t, e) {
        var i = zR([t, e[0]], [t, e[1]], bI(n));
        return { type: "Line", subPixelOptimize: true, shape: i };
      }, shadow: function(n, t, e) {
        var i = n.getBandWidth(), r = e[1] - e[0];
        return { type: "Rect", shape: hY([t - i / 2, e[0]], [i, r], bI(n)) };
      } };
      function bI(n) {
        return n.isHorizontal() ? 0 : 1;
      }
      function HR(n, t) {
        var e = n.getRect();
        return [e[TY[t]], e[TY[t]] + e[pFt[t]]];
      }
      var mFt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "single", t;
      }(un);
      function _Ft(n) {
        Kt(Ey), pc.registerAxisPointerClass("SingleAxisPointer", vFt), n.registerComponentView(mFt), n.registerComponentView(hFt), n.registerComponentModel(SI), yd(n, "single", SI, SI.defaultOption), n.registerCoordinateSystem("single", AFt);
      }
      var EFt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e, i, r) {
          var a = Kg(e);
          n.prototype.init.apply(this, arguments), BY(e, a);
        }, t.prototype.mergeOption = function(e) {
          n.prototype.mergeOption.apply(this, arguments), BY(this.option, e);
        }, t.prototype.getCellSize = function() {
          return this.option.cellSize;
        }, t.type = "calendar", t.defaultOption = { z: 2, left: 80, top: 60, cellSize: 20, orient: "horizontal", splitLine: { show: true, lineStyle: { color: "#000", width: 1, type: "solid" } }, itemStyle: { color: "#fff", borderWidth: 1, borderColor: "#ccc" }, dayLabel: { show: true, firstDay: 0, position: "start", margin: "50%", color: "#000" }, monthLabel: { show: true, position: "start", margin: 5, align: "center", formatter: null, color: "#000" }, yearLabel: { show: true, position: null, margin: 30, formatter: null, color: "#ccc", fontFamily: "sans-serif", fontWeight: "bolder", fontSize: 20 } }, t;
      }(ae);
      function BY(n, t) {
        var e = n.cellSize, i;
        Z(e) ? i = e : i = n.cellSize = [e, e], i.length === 1 && (i[1] = i[0]);
        var r = K([0, 1], function(a) {
          return Gxt(t, a) && (i[a] = "auto"), i[a] != null && i[a] !== "auto";
        });
        gu(n, t, { type: "box", ignoreSize: r });
      }
      var IFt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          var a = this.group;
          a.removeAll();
          var o = e.coordinateSystem, s = o.getRangeInfo(), l = o.getOrient(), u = i.getLocaleModel();
          this._renderDayRect(e, s, a), this._renderLines(e, s, l, a), this._renderYearText(e, s, l, a), this._renderMonthText(e, u, l, a), this._renderWeekText(e, u, s, l, a);
        }, t.prototype._renderDayRect = function(e, i, r) {
          for (var a = e.coordinateSystem, o = e.getModel("itemStyle").getItemStyle(), s = a.getCellWidth(), l = a.getCellHeight(), u = i.start.time; u <= i.end.time; u = a.getNextNDay(u, 1).time) {
            var h = a.dataToRect([u], false).tl, c = new fe({ shape: { x: h[0], y: h[1], width: s, height: l }, cursor: "default", style: o });
            r.add(c);
          }
        }, t.prototype._renderLines = function(e, i, r, a) {
          var o = this, s = e.coordinateSystem, l = e.getModel(["splitLine", "lineStyle"]).getLineStyle(), u = e.get(["splitLine", "show"]), h = l.lineWidth;
          this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
          for (var c = i.start, f = 0; c.time <= i.end.time; f++) {
            d(c.formatedDate), f === 0 && (c = s.getDateInfo(i.start.y + "-" + i.start.m));
            var g = c.date;
            g.setMonth(g.getMonth() + 1), c = s.getDateInfo(g);
          }
          d(s.getNextNDay(i.end.time, 1).formatedDate);
          function d(A) {
            o._firstDayOfMonth.push(s.getDateInfo(A)), o._firstDayPoints.push(s.dataToRect([A], false).tl);
            var p = o._getLinePointsOfOneWeek(e, A, r);
            o._tlpoints.push(p[0]), o._blpoints.push(p[p.length - 1]), u && o._drawSplitline(p, l, a);
          }
          u && this._drawSplitline(o._getEdgesPoints(o._tlpoints, h, r), l, a), u && this._drawSplitline(o._getEdgesPoints(o._blpoints, h, r), l, a);
        }, t.prototype._getEdgesPoints = function(e, i, r) {
          var a = [e[0].slice(), e[e.length - 1].slice()], o = r === "horizontal" ? 0 : 1;
          return a[0][o] = a[0][o] - i / 2, a[1][o] = a[1][o] + i / 2, a;
        }, t.prototype._drawSplitline = function(e, i, r) {
          var a = new Ji({ z2: 20, shape: { points: e }, style: i });
          r.add(a);
        }, t.prototype._getLinePointsOfOneWeek = function(e, i, r) {
          for (var a = e.coordinateSystem, o = a.getDateInfo(i), s = [], l = 0; l < 7; l++) {
            var u = a.getNextNDay(o.time, l), h = a.dataToRect([u.time], false);
            s[2 * u.day] = h.tl, s[2 * u.day + 1] = h[r === "horizontal" ? "bl" : "tr"];
          }
          return s;
        }, t.prototype._formatterLabel = function(e, i) {
          return ht(e) && e ? Oxt(e, i) : yt(e) ? e(i) : i.nameMap;
        }, t.prototype._yearTextPositionControl = function(e, i, r, a, o) {
          var s = i[0], l = i[1], u = ["center", "bottom"];
          a === "bottom" ? (l += o, u = ["center", "top"]) : a === "left" ? s -= o : a === "right" ? (s += o, u = ["center", "top"]) : l -= o;
          var h = 0;
          return (a === "left" || a === "right") && (h = Math.PI / 2), { rotation: h, x: s, y: l, style: { align: u[0], verticalAlign: u[1] } };
        }, t.prototype._renderYearText = function(e, i, r, a) {
          var o = e.getModel("yearLabel");
          if (o.get("show")) {
            var s = o.get("margin"), l = o.get("position");
            l || (l = r !== "horizontal" ? "top" : "left");
            var u = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]], h = (u[0][0] + u[1][0]) / 2, c = (u[0][1] + u[1][1]) / 2, f = r === "horizontal" ? 0 : 1, g = { top: [h, u[f][1]], bottom: [h, u[1 - f][1]], left: [u[1 - f][0], c], right: [u[f][0], c] }, d = i.start.y;
            +i.end.y > +i.start.y && (d = d + "-" + i.end.y);
            var A = o.get("formatter"), p = { start: i.start.y, end: i.end.y, nameMap: d }, v = this._formatterLabel(A, p), y = new Ae({ z2: 30, style: Je(o, { text: v }) });
            y.attr(this._yearTextPositionControl(y, g[l], r, l, s)), a.add(y);
          }
        }, t.prototype._monthTextPositionControl = function(e, i, r, a, o) {
          var s = "left", l = "top", u = e[0], h = e[1];
          return r === "horizontal" ? (h = h + o, i && (s = "center"), a === "start" && (l = "bottom")) : (u = u + o, i && (l = "middle"), a === "start" && (s = "right")), { x: u, y: h, align: s, verticalAlign: l };
        }, t.prototype._renderMonthText = function(e, i, r, a) {
          var o = e.getModel("monthLabel");
          if (o.get("show")) {
            var s = o.get("nameMap"), l = o.get("margin"), u = o.get("position"), h = o.get("align"), c = [this._tlpoints, this._blpoints];
            (!s || ht(s)) && (s && (i = dB(s) || i), s = i.get(["time", "monthAbbr"]) || []);
            var f = u === "start" ? 0 : 1, g = r === "horizontal" ? 0 : 1;
            l = u === "start" ? -l : l;
            for (var d = h === "center", A = 0; A < c[f].length - 1; A++) {
              var p = c[f][A].slice(), v = this._firstDayOfMonth[A];
              if (d) {
                var y = this._firstDayPoints[A];
                p[g] = (y[g] + c[0][A + 1][g]) / 2;
              }
              var m = o.get("formatter"), _ = s[+v.m - 1], I = { yyyy: v.y, yy: (v.y + "").slice(2), MM: v.m, M: +v.m, nameMap: _ }, E = this._formatterLabel(m, I), x = new Ae({ z2: 30, style: X(Je(o, { text: E }), this._monthTextPositionControl(p, d, r, u, l)) });
              a.add(x);
            }
          }
        }, t.prototype._weekTextPositionControl = function(e, i, r, a, o) {
          var s = "center", l = "middle", u = e[0], h = e[1], c = r === "start";
          return i === "horizontal" ? (u = u + a + (c ? 1 : -1) * o[0] / 2, s = c ? "right" : "left") : (h = h + a + (c ? 1 : -1) * o[1] / 2, l = c ? "bottom" : "top"), { x: u, y: h, align: s, verticalAlign: l };
        }, t.prototype._renderWeekText = function(e, i, r, a, o) {
          var s = e.getModel("dayLabel");
          if (s.get("show")) {
            var l = e.coordinateSystem, u = s.get("position"), h = s.get("nameMap"), c = s.get("margin"), f = l.getFirstDayOfWeek();
            if (!h || ht(h)) {
              h && (i = dB(h) || i);
              var g = i.get(["time", "dayOfWeekShort"]);
              h = g || K(i.get(["time", "dayOfWeekAbbr"]), function(I) {
                return I[0];
              });
            }
            var d = l.getNextNDay(r.end.time, 7 - r.lweek).time, A = [l.getCellWidth(), l.getCellHeight()];
            c = st(c, Math.min(A[1], A[0])), u === "start" && (d = l.getNextNDay(r.start.time, -(7 + r.fweek)).time, c = -c);
            for (var p = 0; p < 7; p++) {
              var v = l.getNextNDay(d, p), y = l.dataToRect([v.time], false).center, m = p;
              m = Math.abs((p + f) % 7);
              var _ = new Ae({ z2: 30, style: X(Je(s, { text: h[m] }), this._weekTextPositionControl(y, a, u, c, A)) });
              o.add(_);
            }
          }
        }, t.type = "calendar", t;
      }(un), YR = 864e5, xFt = function() {
        function n(t, e, i) {
          this.type = "calendar", this.dimensions = n.dimensions, this.getDimensionsInfo = n.getDimensionsInfo, this._model = t;
        }
        return n.getDimensionsInfo = function() {
          return [{ name: "time", type: "time" }, "value"];
        }, n.prototype.getRangeInfo = function() {
          return this._rangeInfo;
        }, n.prototype.getModel = function() {
          return this._model;
        }, n.prototype.getRect = function() {
          return this._rect;
        }, n.prototype.getCellWidth = function() {
          return this._sw;
        }, n.prototype.getCellHeight = function() {
          return this._sh;
        }, n.prototype.getOrient = function() {
          return this._orient;
        }, n.prototype.getFirstDayOfWeek = function() {
          return this._firstDayOfWeek;
        }, n.prototype.getDateInfo = function(t) {
          t = qo(t);
          var e = t.getFullYear(), i = t.getMonth() + 1, r = i < 10 ? "0" + i : "" + i, a = t.getDate(), o = a < 10 ? "0" + a : "" + a, s = t.getDay();
          return s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7), { y: e + "", m: r, d: o, day: s, time: t.getTime(), formatedDate: e + "-" + r + "-" + o, date: t };
        }, n.prototype.getNextNDay = function(t, e) {
          return e = e || 0, e === 0 ? this.getDateInfo(t) : (t = new Date(this.getDateInfo(t).time), t.setDate(t.getDate() + e), this.getDateInfo(t));
        }, n.prototype.update = function(t, e) {
          this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
          var i = this._rangeInfo.weeks || 1, r = ["width", "height"], a = this._model.getCellSize().slice(), o = this._model.getBoxLayoutParams(), s = this._orient === "horizontal" ? [i, 7] : [7, i];
          D([0, 1], function(c) {
            h(a, c) && (o[r[c]] = a[c] * s[c]);
          });
          var l = { width: e.getWidth(), height: e.getHeight() }, u = this._rect = Yn(o, l);
          D([0, 1], function(c) {
            h(a, c) || (a[c] = u[r[c]] / s[c]);
          });
          function h(c, f) {
            return c[f] != null && c[f] !== "auto";
          }
          this._sw = a[0], this._sh = a[1];
        }, n.prototype.dataToPoint = function(t, e) {
          Z(t) && (t = t[0]), e == null && (e = true);
          var i = this.getDateInfo(t), r = this._rangeInfo, a = i.formatedDate;
          if (e && !(i.time >= r.start.time && i.time < r.end.time + YR)) return [NaN, NaN];
          var o = i.day, s = this._getRangeInfo([r.start.time, a]).nthWeek;
          return this._orient === "vertical" ? [this._rect.x + o * this._sw + this._sw / 2, this._rect.y + s * this._sh + this._sh / 2] : [this._rect.x + s * this._sw + this._sw / 2, this._rect.y + o * this._sh + this._sh / 2];
        }, n.prototype.pointToData = function(t) {
          var e = this.pointToDate(t);
          return e && e.time;
        }, n.prototype.dataToRect = function(t, e) {
          var i = this.dataToPoint(t, e);
          return { contentShape: { x: i[0] - (this._sw - this._lineWidth) / 2, y: i[1] - (this._sh - this._lineWidth) / 2, width: this._sw - this._lineWidth, height: this._sh - this._lineWidth }, center: i, tl: [i[0] - this._sw / 2, i[1] - this._sh / 2], tr: [i[0] + this._sw / 2, i[1] - this._sh / 2], br: [i[0] + this._sw / 2, i[1] + this._sh / 2], bl: [i[0] - this._sw / 2, i[1] + this._sh / 2] };
        }, n.prototype.pointToDate = function(t) {
          var e = Math.floor((t[0] - this._rect.x) / this._sw) + 1, i = Math.floor((t[1] - this._rect.y) / this._sh) + 1, r = this._rangeInfo.range;
          return this._orient === "vertical" ? this._getDateByWeeksAndDay(i, e - 1, r) : this._getDateByWeeksAndDay(e, i - 1, r);
        }, n.prototype.convertToPixel = function(t, e, i) {
          var r = MY(e);
          return r === this ? r.dataToPoint(i) : null;
        }, n.prototype.convertFromPixel = function(t, e, i) {
          var r = MY(e);
          return r === this ? r.pointToData(i) : null;
        }, n.prototype.containPoint = function(t) {
          return false;
        }, n.prototype._initRangeOption = function() {
          var t = this._model.get("range"), e;
          if (Z(t) && t.length === 1 && (t = t[0]), Z(t)) e = t;
          else {
            var i = t.toString();
            if (/^\d{4}$/.test(i) && (e = [i + "-01-01", i + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(i)) {
              var r = this.getDateInfo(i), a = r.date;
              a.setMonth(a.getMonth() + 1);
              var o = this.getNextNDay(a, -1);
              e = [r.formatedDate, o.formatedDate];
            }
            /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(i) && (e = [i, i]);
          }
          if (!e) return Ya("Invalid date range."), t;
          var s = this._getRangeInfo(e);
          return s.start.time > s.end.time && e.reverse(), e;
        }, n.prototype._getRangeInfo = function(t) {
          var e = [this.getDateInfo(t[0]), this.getDateInfo(t[1])], i;
          e[0].time > e[1].time && (i = true, e.reverse());
          var r = Math.floor(e[1].time / YR) - Math.floor(e[0].time / YR) + 1, a = new Date(e[0].time), o = a.getDate(), s = e[1].date.getDate();
          a.setDate(o + r - 1);
          var l = a.getDate();
          if (l !== s) for (var u = a.getTime() - e[1].time > 0 ? 1 : -1; (l = a.getDate()) !== s && (a.getTime() - e[1].time) * u > 0; ) r -= u, a.setDate(l - u);
          var h = Math.floor((r + e[0].day + 6) / 7), c = i ? -h + 1 : h - 1;
          return i && e.reverse(), { range: [e[0].formatedDate, e[1].formatedDate], start: e[0], end: e[1], allDay: r, weeks: h, nthWeek: c, fweek: e[0].day, lweek: e[1].day };
        }, n.prototype._getDateByWeeksAndDay = function(t, e, i) {
          var r = this._getRangeInfo(i);
          if (t > r.weeks || t === 0 && e < r.fweek || t === r.weeks && e > r.lweek) return null;
          var a = (t - 1) * 7 - r.fweek + e, o = new Date(r.start.time);
          return o.setDate(+r.start.d + a), this.getDateInfo(o);
        }, n.create = function(t, e) {
          var i = [];
          return t.eachComponent("calendar", function(r) {
            var a = new n(r);
            i.push(a), r.coordinateSystem = a;
          }), t.eachSeries(function(r) {
            r.get("coordinateSystem") === "calendar" && (r.coordinateSystem = i[r.get("calendarIndex") || 0]);
          }), i;
        }, n.dimensions = ["time", "value"], n;
      }();
      function MY(n) {
        var t = n.calendarModel, e = n.seriesModel, i = t ? t.coordinateSystem : e ? e.coordinateSystem : null;
        return i;
      }
      function wFt(n) {
        n.registerComponentModel(EFt), n.registerComponentView(IFt), n.registerCoordinateSystem("calendar", xFt);
      }
      function CFt(n, t) {
        var e = n.existing;
        if (t.id = n.keyInfo.id, !t.type && e && (t.type = e.type), t.parentId == null) {
          var i = t.parentOption;
          i ? t.parentId = i.id : e && (t.parentId = e.parentId);
        }
        t.parentOption = null;
      }
      function DY(n, t) {
        var e;
        return D(t, function(i) {
          n[i] != null && n[i] !== "auto" && (e = true);
        }), e;
      }
      function SFt(n, t, e) {
        var i = X({}, e), r = n[t], a = e.$action || "merge";
        if (a === "merge") if (r) {
          if (true) {
            var o = e.type;
            It(!o || r.type === o, 'Please set $action: "replace" to change `type`');
          }
          Yt(r, i, true), gu(r, i, { ignoreSize: true }), h6(e, r), TI(e, r), TI(e, r, "shape"), TI(e, r, "style"), TI(e, r, "extra"), e.clipPath = r.clipPath;
        } else n[t] = i;
        else a === "replace" ? n[t] = i : a === "remove" && r && (n[t] = null);
      }
      var RY = ["transition", "enterFrom", "leaveTo"], bFt = RY.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
      function TI(n, t, e) {
        if (e && (!n[e] && t[e] && (n[e] = {}), n = n[e], t = t[e]), !(!n || !t)) for (var i = e ? RY : bFt, r = 0; r < i.length; r++) {
          var a = i[r];
          n[a] == null && t[a] != null && (n[a] = t[a]);
        }
      }
      function TFt(n, t) {
        if (n && (n.hv = t.hv = [DY(t, ["left", "right"]), DY(t, ["top", "bottom"])], n.type === "group")) {
          var e = n, i = t;
          e.width == null && (e.width = i.width = 0), e.height == null && (e.height = i.height = 0);
        }
      }
      var BFt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.preventAutoZ = true, e;
        }
        return t.prototype.mergeOption = function(e, i) {
          var r = this.option.elements;
          this.option.elements = null, n.prototype.mergeOption.call(this, e, i), this.option.elements = r;
        }, t.prototype.optionUpdated = function(e, i) {
          var r = this.option, a = (i ? r : e).elements, o = r.elements = i ? [] : r.elements, s = [];
          this._flatten(a, s, null);
          var l = v4(o, s, "normalMerge"), u = this._elOptionsToUpdate = [];
          D(l, function(h, c) {
            var f = h.newOption;
            It(Et(f) || h.existing, "Empty graphic option definition"), f && (u.push(f), CFt(h, f), SFt(o, c, f), TFt(o[c], f));
          }, this), r.elements = Fe(o, function(h) {
            return h && delete h.$action, h != null;
          });
        }, t.prototype._flatten = function(e, i, r) {
          D(e, function(a) {
            if (a) {
              r && (a.parentOption = r), i.push(a);
              var o = a.children;
              o && o.length && this._flatten(o, i, a), delete a.children;
            }
          }, this);
        }, t.prototype.useElOptionsToUpdate = function() {
          var e = this._elOptionsToUpdate;
          return this._elOptionsToUpdate = null, e;
        }, t.type = "graphic", t.defaultOption = { elements: [] }, t;
      }(ae), LY = { path: null, compoundPath: null, group: Dt, image: gi, text: Ae }, Da = ce(), MFt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function() {
          this._elMap = dt();
        }, t.prototype.render = function(e, i, r) {
          e !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = e, this._updateElements(e), this._relocate(e, r);
        }, t.prototype._updateElements = function(e) {
          var i = e.useElOptionsToUpdate();
          if (i) {
            var r = this._elMap, a = this.group, o = e.get("z"), s = e.get("zlevel");
            D(i, function(l) {
              var u = Hn(l.id, null), h = u != null ? r.get(u) : null, c = Hn(l.parentId, null), f = c != null ? r.get(c) : a, g = l.type, d = l.style;
              g === "text" && d && l.hv && l.hv[1] && (d.textVerticalAlign = d.textBaseline = d.verticalAlign = d.align = null);
              var A = l.textContent, p = l.textConfig;
              if (d && LH(d, g, !!p, !!A)) {
                var v = PH(d, g, true);
                !p && v.textConfig && (p = l.textConfig = v.textConfig), !A && v.textContent && (A = v.textContent);
              }
              var y = DFt(l);
              h && It(f === h.parent, "Changing parent is not supported.");
              var m = l.$action || "merge", _ = m === "merge", I = m === "replace";
              if (_) {
                var E = !h, x = h;
                E ? x = PY(u, f, l.type, r) : (x && (Da(x).isNew = false), YH(x)), x && (yI(x, y, e, { isInit: E }), NY(x, l, o, s));
              } else if (I) {
                BI(h, l, r, e);
                var w = PY(u, f, l.type, r);
                w && (yI(w, y, e, { isInit: true }), NY(w, l, o, s));
              } else m === "remove" && (UH(h, l), BI(h, l, r, e));
              var C = r.get(u);
              if (C && A) if (_) {
                var S = C.getTextContent();
                S ? S.attr(A) : C.setTextContent(new Ae(A));
              } else I && C.setTextContent(new Ae(A));
              if (C) {
                var b = l.clipPath;
                if (b) {
                  var T = b.type, B = void 0, E = false;
                  if (_) {
                    var R = C.getClipPath();
                    E = !R || Da(R).type !== T, B = E ? WR(T) : R;
                  } else I && (E = true, B = WR(T));
                  C.setClipPath(B), yI(B, b, e, { isInit: E }), _I(B, b.keyframeAnimation, e);
                }
                var M = Da(C);
                C.setTextConfig(p), M.option = l, RFt(C, e, l), qg({ el: C, componentModel: e, itemName: C.name, itemTooltipOption: l.tooltip }), _I(C, l.keyframeAnimation, e);
              }
            });
          }
        }, t.prototype._relocate = function(e, i) {
          for (var r = e.option.elements, a = this.group, o = this._elMap, s = i.getWidth(), l = i.getHeight(), u = ["x", "y"], h = 0; h < r.length; h++) {
            var c = r[h], f = Hn(c.id, null), g = f != null ? o.get(f) : null;
            if (!(!g || !g.isGroup)) {
              var d = g.parent, A = d === a, p = Da(g), v = Da(d);
              p.width = st(p.option.width, A ? s : v.width) || 0, p.height = st(p.option.height, A ? l : v.height) || 0;
            }
          }
          for (var h = r.length - 1; h >= 0; h--) {
            var c = r[h], f = Hn(c.id, null), g = f != null ? o.get(f) : null;
            if (g) {
              var d = g.parent, v = Da(d), y = d === a ? { width: s, height: l } : { width: v.width, height: v.height }, m = {}, _ = nE(g, c, y, null, { hv: c.hv, boundingMode: c.bounding }, m);
              if (!Da(g).isNew && _) {
                for (var I = c.transition, E = {}, x = 0; x < u.length; x++) {
                  var w = u[x], C = m[w];
                  I && (Cc(I) || $t(I, w) >= 0) ? E[w] = C : g[w] = C;
                }
                Ee(g, E, e, 0);
              } else g.attr(m);
            }
          }
        }, t.prototype._clear = function() {
          var e = this, i = this._elMap;
          i.each(function(r) {
            BI(r, Da(r).option, i, e._lastGraphicModel);
          }), this._elMap = dt();
        }, t.prototype.dispose = function() {
          this._clear();
        }, t.type = "graphic", t;
      }(un);
      function WR(n) {
        It(n, "graphic type MUST be set");
        var t = ft(LY, n) ? LY[n] : oB(n);
        It(t, "graphic type " + n + " can not be found");
        var e = new t({});
        return Da(e).type = n, e;
      }
      function PY(n, t, e, i) {
        var r = WR(e);
        return t.add(r), i.set(n, r), Da(r).id = n, Da(r).isNew = true, r;
      }
      function BI(n, t, e, i) {
        var r = n && n.parent;
        r && (n.type === "group" && n.traverse(function(a) {
          BI(a, t, e, i);
        }), mI(n, t, i), e.removeKey(Da(n).id));
      }
      function NY(n, t, e, i) {
        n.isGroup || D([["cursor", ya.prototype.cursor], ["zlevel", i || 0], ["z", e || 0], ["z2", 0]], function(r) {
          var a = r[0];
          ft(t, a) ? n[a] = kt(t[a], r[1]) : n[a] == null && (n[a] = r[1]);
        }), D(oe(t), function(r) {
          if (r.indexOf("on") === 0) {
            var a = t[r];
            n[r] = yt(a) ? a : null;
          }
        }), ft(t, "draggable") && (n.draggable = t.draggable), t.name != null && (n.name = t.name), t.id != null && (n.id = t.id);
      }
      function DFt(n) {
        return n = X({}, n), D(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(u6), function(t) {
          delete n[t];
        }), n;
      }
      function RFt(n, t, e) {
        var i = Nt(n).eventData;
        !n.silent && !n.ignore && !i && (i = Nt(n).eventData = { componentType: "graphic", componentIndex: t.componentIndex, name: n.name }), i && (i.info = e.info);
      }
      function LFt(n) {
        n.registerComponentModel(BFt), n.registerComponentView(MFt), n.registerPreprocessor(function(t) {
          var e = t.graphic;
          Z(e) ? !e[0] || !e[0].elements ? t.graphic = [{ elements: e }] : t.graphic = [t.graphic[0]] : e && !e.elements && (t.graphic = [{ elements: [e] }]);
        });
      }
      var FY = ["x", "y", "radius", "angle", "single"], PFt = ["cartesian2d", "polar", "singleAxis"];
      function NFt(n) {
        var t = n.get("coordinateSystem");
        return $t(PFt, t) >= 0;
      }
      function bu(n) {
        return It(n), n + "Axis";
      }
      function FFt(n, t) {
        var e = dt(), i = [], r = dt();
        n.eachComponent({ mainType: "dataZoom", query: t }, function(h) {
          r.get(h.uid) || s(h);
        });
        var a;
        do
          a = false, n.eachComponent("dataZoom", o);
        while (a);
        function o(h) {
          !r.get(h.uid) && l(h) && (s(h), a = true);
        }
        function s(h) {
          r.set(h.uid, true), i.push(h), u(h);
        }
        function l(h) {
          var c = false;
          return h.eachTargetAxis(function(f, g) {
            var d = e.get(f);
            d && d[g] && (c = true);
          }), c;
        }
        function u(h) {
          h.eachTargetAxis(function(c, f) {
            (e.get(c) || e.set(c, []))[f] = true;
          });
        }
        return i;
      }
      function kY(n) {
        var t = n.ecModel, e = { infoList: [], infoMap: dt() };
        return n.eachTargetAxis(function(i, r) {
          var a = t.getComponent(bu(i), r);
          if (a) {
            var o = a.getCoordSysModel();
            if (o) {
              var s = o.uid, l = e.infoMap.get(s);
              l || (l = { model: o, axisModels: [] }, e.infoList.push(l), e.infoMap.set(s, l)), l.axisModels.push(a);
            }
          }
        }), e;
      }
      var XR = function() {
        function n() {
          this.indexList = [], this.indexMap = [];
        }
        return n.prototype.add = function(t) {
          this.indexMap[t] || (this.indexList.push(t), this.indexMap[t] = true);
        }, n;
      }(), Iy = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._autoThrottle = true, e._noTarget = true, e._rangePropMode = ["percent", "percent"], e;
        }
        return t.prototype.init = function(e, i, r) {
          var a = OY(e);
          this.settledOption = a, this.mergeDefaultAndTheme(e, r), this._doInit(a);
        }, t.prototype.mergeOption = function(e) {
          var i = OY(e);
          Yt(this.option, e, true), Yt(this.settledOption, i, true), this._doInit(i);
        }, t.prototype._doInit = function(e) {
          var i = this.option;
          this._setDefaultThrottle(e), this._updateRangeUse(e);
          var r = this.settledOption;
          D([["start", "startValue"], ["end", "endValue"]], function(a, o) {
            this._rangePropMode[o] === "value" && (i[a[0]] = r[a[0]] = null);
          }, this), this._resetTarget();
        }, t.prototype._resetTarget = function() {
          var e = this.get("orient", true), i = this._targetAxisInfoMap = dt(), r = this._fillSpecifiedTargetAxis(i);
          r ? this._orient = e || this._makeAutoOrientByTargetAxis() : (this._orient = e || "horizontal", this._fillAutoTargetAxisByOrient(i, this._orient)), this._noTarget = true, i.each(function(a) {
            a.indexList.length && (this._noTarget = false);
          }, this);
        }, t.prototype._fillSpecifiedTargetAxis = function(e) {
          var i = false;
          return D(FY, function(r) {
            var a = this.getReferringComponents(bu(r), bEt);
            if (a.specified) {
              i = true;
              var o = new XR();
              D(a.models, function(s) {
                o.add(s.componentIndex);
              }), e.set(r, o);
            }
          }, this), i;
        }, t.prototype._fillAutoTargetAxisByOrient = function(e, i) {
          var r = this.ecModel, a = true;
          if (a) {
            var o = i === "vertical" ? "y" : "x", s = r.findComponents({ mainType: o + "Axis" });
            l(s, o);
          }
          if (a) {
            var s = r.findComponents({ mainType: "singleAxis", filter: function(h) {
              return h.get("orient", true) === i;
            } });
            l(s, "single");
          }
          function l(u, h) {
            var c = u[0];
            if (c) {
              var f = new XR();
              if (f.add(c.componentIndex), e.set(h, f), a = false, h === "x" || h === "y") {
                var g = c.getReferringComponents("grid", zn).models[0];
                g && D(u, function(d) {
                  c.componentIndex !== d.componentIndex && g === d.getReferringComponents("grid", zn).models[0] && f.add(d.componentIndex);
                });
              }
            }
          }
          a && D(FY, function(u) {
            if (a) {
              var h = r.findComponents({ mainType: bu(u), filter: function(f) {
                return f.get("type", true) === "category";
              } });
              if (h[0]) {
                var c = new XR();
                c.add(h[0].componentIndex), e.set(u, c), a = false;
              }
            }
          }, this);
        }, t.prototype._makeAutoOrientByTargetAxis = function() {
          var e;
          return this.eachTargetAxis(function(i) {
            !e && (e = i);
          }, this), e === "y" ? "vertical" : "horizontal";
        }, t.prototype._setDefaultThrottle = function(e) {
          if (e.hasOwnProperty("throttle") && (this._autoThrottle = false), this._autoThrottle) {
            var i = this.ecModel.option;
            this.option.throttle = i.animation && i.animationDurationUpdate > 0 ? 100 : 20;
          }
        }, t.prototype._updateRangeUse = function(e) {
          var i = this._rangePropMode, r = this.get("rangeMode");
          D([["start", "startValue"], ["end", "endValue"]], function(a, o) {
            var s = e[a[0]] != null, l = e[a[1]] != null;
            s && !l ? i[o] = "percent" : !s && l ? i[o] = "value" : r ? i[o] = r[o] : s && (i[o] = "percent");
          });
        }, t.prototype.noTarget = function() {
          return this._noTarget;
        }, t.prototype.getFirstTargetAxisModel = function() {
          var e;
          return this.eachTargetAxis(function(i, r) {
            e == null && (e = this.ecModel.getComponent(bu(i), r));
          }, this), e;
        }, t.prototype.eachTargetAxis = function(e, i) {
          this._targetAxisInfoMap.each(function(r, a) {
            D(r.indexList, function(o) {
              e.call(i, a, o);
            });
          });
        }, t.prototype.getAxisProxy = function(e, i) {
          var r = this.getAxisModel(e, i);
          if (r) return r.__dzAxisProxy;
        }, t.prototype.getAxisModel = function(e, i) {
          It(e && i != null);
          var r = this._targetAxisInfoMap.get(e);
          if (r && r.indexMap[i]) return this.ecModel.getComponent(bu(e), i);
        }, t.prototype.setRawRange = function(e) {
          var i = this.option, r = this.settledOption;
          D([["start", "startValue"], ["end", "endValue"]], function(a) {
            (e[a[0]] != null || e[a[1]] != null) && (i[a[0]] = r[a[0]] = e[a[0]], i[a[1]] = r[a[1]] = e[a[1]]);
          }, this), this._updateRangeUse(e);
        }, t.prototype.setCalculatedRange = function(e) {
          var i = this.option;
          D(["start", "startValue", "end", "endValue"], function(r) {
            i[r] = e[r];
          });
        }, t.prototype.getPercentRange = function() {
          var e = this.findRepresentativeAxisProxy();
          if (e) return e.getDataPercentWindow();
        }, t.prototype.getValueRange = function(e, i) {
          if (e == null && i == null) {
            var r = this.findRepresentativeAxisProxy();
            if (r) return r.getDataValueWindow();
          } else return this.getAxisProxy(e, i).getDataValueWindow();
        }, t.prototype.findRepresentativeAxisProxy = function(e) {
          if (e) return e.__dzAxisProxy;
          for (var i, r = this._targetAxisInfoMap.keys(), a = 0; a < r.length; a++) for (var o = r[a], s = this._targetAxisInfoMap.get(o), l = 0; l < s.indexList.length; l++) {
            var u = this.getAxisProxy(o, s.indexList[l]);
            if (u.hostedBy(this)) return u;
            i || (i = u);
          }
          return i;
        }, t.prototype.getRangePropMode = function() {
          return this._rangePropMode.slice();
        }, t.prototype.getOrient = function() {
          return It(this._orient), this._orient;
        }, t.type = "dataZoom", t.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"], t.defaultOption = { z: 4, filterMode: "filter", start: 0, end: 100 }, t;
      }(ae);
      function OY(n) {
        var t = {};
        return D(["start", "end", "startValue", "endValue", "throttle"], function(e) {
          n.hasOwnProperty(e) && (t[e] = n[e]);
        }), t;
      }
      var kFt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "dataZoom.select", t;
      }(Iy), $R = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r, a) {
          this.dataZoomModel = e, this.ecModel = i, this.api = r;
        }, t.type = "dataZoom", t;
      }(un), OFt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "dataZoom.select", t;
      }($R), Td = D, QY = va, QFt = function() {
        function n(t, e, i, r) {
          this._dimName = t, this._axisIndex = e, this.ecModel = r, this._dataZoomModel = i;
        }
        return n.prototype.hostedBy = function(t) {
          return this._dataZoomModel === t;
        }, n.prototype.getDataValueWindow = function() {
          return this._valueWindow.slice();
        }, n.prototype.getDataPercentWindow = function() {
          return this._percentWindow.slice();
        }, n.prototype.getTargetSeriesModels = function() {
          var t = [];
          return this.ecModel.eachSeries(function(e) {
            if (NFt(e)) {
              var i = bu(this._dimName), r = e.getReferringComponents(i, zn).models[0];
              r && this._axisIndex === r.componentIndex && t.push(e);
            }
          }, this), t;
        }, n.prototype.getAxisModel = function() {
          return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
        }, n.prototype.getMinMaxSpan = function() {
          return Ct(this._minMaxSpan);
        }, n.prototype.calculateDataWindow = function(t) {
          var e = this._dataExtent, i = this.getAxisModel(), r = i.axis.scale, a = this._dataZoomModel.getRangePropMode(), o = [0, 100], s = [], l = [], u;
          Td(["start", "end"], function(f, g) {
            var d = t[f], A = t[f + "Value"];
            a[g] === "percent" ? (d == null && (d = o[g]), A = r.parse(Ne(d, o, e))) : (u = true, A = A == null ? e[g] : r.parse(A), d = Ne(A, e, o)), l[g] = A == null || isNaN(A) ? e[g] : A, s[g] = d == null || isNaN(d) ? o[g] : d;
          }), QY(l), QY(s);
          var h = this._minMaxSpan;
          u ? c(l, s, e, o, false) : c(s, l, o, e, true);
          function c(f, g, d, A, p) {
            var v = p ? "Span" : "ValueSpan";
            Ic(0, f, d, "all", h["min" + v], h["max" + v]);
            for (var y = 0; y < 2; y++) g[y] = Ne(f[y], d, A, true), p && (g[y] = r.parse(g[y]));
          }
          return { valueWindow: l, percentWindow: s };
        }, n.prototype.reset = function(t) {
          if (t === this._dataZoomModel) {
            var e = this.getTargetSeriesModels();
            this._dataExtent = zFt(this, this._dimName, e), this._updateMinMaxSpan();
            var i = this.calculateDataWindow(t.settledOption);
            this._valueWindow = i.valueWindow, this._percentWindow = i.percentWindow, this._setAxisModel();
          }
        }, n.prototype.filterData = function(t, e) {
          if (t !== this._dataZoomModel) return;
          var i = this._dimName, r = this.getTargetSeriesModels(), a = t.get("filterMode"), o = this._valueWindow;
          if (a === "none") return;
          Td(r, function(l) {
            var u = l.getData(), h = u.mapDimensionsAll(i);
            if (h.length) {
              if (a === "weakFilter") {
                var c = u.getStore(), f = K(h, function(g) {
                  return u.getDimensionIndex(g);
                }, u);
                u.filterSelf(function(g) {
                  for (var d, A, p, v = 0; v < h.length; v++) {
                    var y = c.get(f[v], g), m = !isNaN(y), _ = y < o[0], I = y > o[1];
                    if (m && !_ && !I) return true;
                    m && (p = true), _ && (d = true), I && (A = true);
                  }
                  return p && d && A;
                });
              } else Td(h, function(g) {
                if (a === "empty") l.setData(u = u.map(g, function(A) {
                  return s(A) ? A : NaN;
                }));
                else {
                  var d = {};
                  d[g] = o, u.selectRange(d);
                }
              });
              Td(h, function(g) {
                u.setApproximateExtent(o, g);
              });
            }
          });
          function s(l) {
            return l >= o[0] && l <= o[1];
          }
        }, n.prototype._updateMinMaxSpan = function() {
          var t = this._minMaxSpan = {}, e = this._dataZoomModel, i = this._dataExtent;
          Td(["min", "max"], function(r) {
            var a = e.get(r + "Span"), o = e.get(r + "ValueSpan");
            o != null && (o = this.getAxisModel().axis.scale.parse(o)), o != null ? a = Ne(i[0] + o, i, [0, 100], true) : a != null && (o = Ne(a, [0, 100], i, true) - i[0]), t[r + "Span"] = a, t[r + "ValueSpan"] = o;
          }, this);
        }, n.prototype._setAxisModel = function() {
          var t = this.getAxisModel(), e = this._percentWindow, i = this._valueWindow;
          if (e) {
            var r = r4(i, [0, 500]);
            r = Math.min(r, 20);
            var a = t.axis.scale.rawExtentInfo;
            e[0] !== 0 && a.setDeterminedMinMax("min", +i[0].toFixed(r)), e[1] !== 100 && a.setDeterminedMinMax("max", +i[1].toFixed(r)), a.freeze();
          }
        }, n;
      }();
      function zFt(n, t, e) {
        var i = [1 / 0, -1 / 0];
        Td(e, function(o) {
          _bt(i, o.getData(), t);
        });
        var r = n.getAxisModel(), a = HV(r.axis.scale, r, i).calculate();
        return [a.min, a.max];
      }
      var GFt = { getTargetSeries: function(n) {
        function t(r) {
          n.eachComponent("dataZoom", function(a) {
            a.eachTargetAxis(function(o, s) {
              var l = n.getComponent(bu(o), s);
              r(o, s, l, a);
            });
          });
        }
        t(function(r, a, o, s) {
          o.__dzAxisProxy = null;
        });
        var e = [];
        t(function(r, a, o, s) {
          o.__dzAxisProxy || (o.__dzAxisProxy = new QFt(r, a, s, n), e.push(o.__dzAxisProxy));
        });
        var i = dt();
        return D(e, function(r) {
          D(r.getTargetSeriesModels(), function(a) {
            i.set(a.uid, a);
          });
        }), i;
      }, overallReset: function(n, t) {
        n.eachComponent("dataZoom", function(e) {
          e.eachTargetAxis(function(i, r) {
            e.getAxisProxy(i, r).reset(e);
          }), e.eachTargetAxis(function(i, r) {
            e.getAxisProxy(i, r).filterData(e, t);
          });
        }), n.eachComponent("dataZoom", function(e) {
          var i = e.findRepresentativeAxisProxy();
          if (i) {
            var r = i.getDataPercentWindow(), a = i.getDataValueWindow();
            e.setCalculatedRange({ start: r[0], end: r[1], startValue: a[0], endValue: a[1] });
          }
        });
      } };
      function UFt(n) {
        n.registerAction("dataZoom", function(t, e) {
          var i = FFt(e, t);
          D(i, function(r) {
            r.setRawRange({ start: t.start, end: t.end, startValue: t.startValue, endValue: t.endValue });
          });
        });
      }
      var zY = false;
      function ZR(n) {
        zY || (zY = true, n.registerProcessor(n.PRIORITY.PROCESSOR.FILTER, GFt), UFt(n), n.registerSubTypeDefaulter("dataZoom", function() {
          return "slider";
        }));
      }
      function VFt(n) {
        n.registerComponentModel(kFt), n.registerComponentView(OFt), ZR(n);
      }
      var Ra = /* @__PURE__ */ function() {
        function n() {
        }
        return n;
      }(), GY = {};
      function Bd(n, t) {
        GY[n] = t;
      }
      function UY(n) {
        return GY[n];
      }
      var jFt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.optionUpdated = function() {
          n.prototype.optionUpdated.apply(this, arguments);
          var e = this.ecModel;
          D(this.option.feature, function(i, r) {
            var a = UY(r);
            a && (a.getDefaultOption && (a.defaultOption = a.getDefaultOption(e)), Yt(i, a.defaultOption));
          });
        }, t.type = "toolbox", t.layoutMode = { type: "box", ignoreSize: true }, t.defaultOption = { show: true, z: 6, orient: "horizontal", left: "right", top: "top", backgroundColor: "transparent", borderColor: "#ccc", borderRadius: 0, borderWidth: 0, padding: 5, itemSize: 15, itemGap: 8, showTitle: true, iconStyle: { borderColor: "#666", color: "none" }, emphasis: { iconStyle: { borderColor: "#3E98C5" } }, tooltip: { show: false, position: "bottom" } }, t;
      }(ae);
      function qFt(n, t, e) {
        var i = t.getBoxLayoutParams(), r = t.get("padding"), a = { width: e.getWidth(), height: e.getHeight() }, o = Yn(i, a, r);
        Zh(t.get("orient"), n, t.get("itemGap"), o.width, o.height), nE(n, i, a, r);
      }
      function VY(n, t) {
        var e = Zg(t.get("padding")), i = t.getItemStyle(["color", "opacity"]);
        return i.fill = t.get("backgroundColor"), n = new fe({ shape: { x: n.x - e[3], y: n.y - e[0], width: n.width + e[1] + e[3], height: n.height + e[0] + e[2], r: t.get("borderRadius") }, style: i, silent: true, z2: -1 }), n;
      }
      var HFt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.render = function(e, i, r, a) {
          var o = this.group;
          if (o.removeAll(), !e.get("show")) return;
          var s = +e.get("itemSize"), l = e.get("orient") === "vertical", u = e.get("feature") || {}, h = this._features || (this._features = {}), c = [];
          D(u, function(d, A) {
            c.push(A);
          }), new Js(this._featureNames || [], c).add(f).update(f).remove(Gt(f, null)).execute(), this._featureNames = c;
          function f(d, A) {
            var p = c[d], v = c[A], y = u[p], m = new De(y, e, e.ecModel), _;
            if (a && a.newTitle != null && a.featureName === p && (y.title = a.newTitle), p && !v) {
              if (YFt(p)) _ = { onclick: m.option.onclick, featureName: p };
              else {
                var I = UY(p);
                if (!I) return;
                _ = new I();
              }
              h[p] = _;
            } else if (_ = h[v], !_) return;
            _.uid = Yg("toolbox-feature"), _.model = m, _.ecModel = i, _.api = r;
            var E = _ instanceof Ra;
            if (!p && v) {
              E && _.dispose && _.dispose(i, r);
              return;
            }
            if (!m.get("show") || E && _.unusable) {
              E && _.remove && _.remove(i, r);
              return;
            }
            g(m, _, p), m.setIconStatus = function(x, w) {
              var C = this.option, S = this.iconPaths;
              C.iconStatus = C.iconStatus || {}, C.iconStatus[x] = w, S[x] && (w === "emphasis" ? Ws : Xs)(S[x]);
            }, _ instanceof Ra && _.render && _.render(m, i, r, a);
          }
          function g(d, A, p) {
            var v = d.getModel("iconStyle"), y = d.getModel(["emphasis", "iconStyle"]), m = A instanceof Ra && A.getIcons ? A.getIcons() : d.get("icon"), _ = d.get("title") || {}, I, E;
            ht(m) ? (I = {}, I[p] = m) : I = m, ht(_) ? (E = {}, E[p] = _) : E = _;
            var x = d.iconPaths = {};
            D(I, function(w, C) {
              var S = vv(w, {}, { x: -s / 2, y: -s / 2, width: s, height: s });
              S.setStyle(v.getItemStyle());
              var b = S.ensureState("emphasis");
              b.style = y.getItemStyle();
              var T = new Ae({ style: { text: E[C], align: y.get("textAlign"), borderRadius: y.get("textBorderRadius"), padding: y.get("textPadding"), fill: null, font: uB({ fontStyle: y.get("textFontStyle"), fontFamily: y.get("textFontFamily"), fontSize: y.get("textFontSize"), fontWeight: y.get("textFontWeight") }, i) }, ignore: true });
              S.setTextContent(T), qg({ el: S, componentModel: e, itemName: C, formatterParamsExtra: { title: E[C] } }), S.__title = E[C], S.on("mouseover", function() {
                var B = y.getItemStyle(), R = l ? e.get("right") == null && e.get("left") !== "right" ? "right" : "left" : e.get("bottom") == null && e.get("top") !== "bottom" ? "bottom" : "top";
                T.setStyle({ fill: y.get("textFill") || B.fill || B.stroke || "#000", backgroundColor: y.get("textBackgroundColor") }), S.setTextConfig({ position: y.get("textPosition") || R }), T.ignore = !e.get("showTitle"), r.enterEmphasis(this);
              }).on("mouseout", function() {
                d.get(["iconStatus", C]) !== "emphasis" && r.leaveEmphasis(this), T.hide();
              }), (d.get(["iconStatus", C]) === "emphasis" ? Ws : Xs)(S), o.add(S), S.on("click", ct(A.onclick, A, i, r, C)), x[C] = S;
            });
          }
          qFt(o, e, r), o.add(VY(o.getBoundingRect(), e)), l || o.eachChild(function(d) {
            var A = d.__title, p = d.ensureState("emphasis"), v = p.textConfig || (p.textConfig = {}), y = d.getTextContent(), m = y && y.ensureState("emphasis");
            if (m && !yt(m) && A) {
              var _ = m.style || (m.style = {}), I = $p(A, Ae.makeFont(_)), E = d.x + o.x, x = d.y + o.y + s, w = false;
              x + I.height > r.getHeight() && (v.position = "top", w = true);
              var C = w ? -5 - I.height : s + 10;
              E + I.width / 2 > r.getWidth() ? (v.position = ["100%", C], _.align = "right") : E - I.width / 2 < 0 && (v.position = [0, C], _.align = "left");
            }
          });
        }, t.prototype.updateView = function(e, i, r, a) {
          D(this._features, function(o) {
            o instanceof Ra && o.updateView && o.updateView(o.model, i, r, a);
          });
        }, t.prototype.remove = function(e, i) {
          D(this._features, function(r) {
            r instanceof Ra && r.remove && r.remove(e, i);
          }), this.group.removeAll();
        }, t.prototype.dispose = function(e, i) {
          D(this._features, function(r) {
            r instanceof Ra && r.dispose && r.dispose(e, i);
          });
        }, t.type = "toolbox", t;
      }(un);
      function YFt(n) {
        return n.indexOf("my") === 0;
      }
      var WFt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.onclick = function(e, i) {
          var r = this.model, a = r.get("name") || e.get("title.0.text") || "echarts", o = i.getZr().painter.getType() === "svg", s = o ? "svg" : r.get("type", true) || "png", l = i.getConnectedDataURL({ type: s, backgroundColor: r.get("backgroundColor", true) || e.get("backgroundColor") || "#fff", connectedBackgroundColor: r.get("connectedBackgroundColor"), excludeComponents: r.get("excludeComponents"), pixelRatio: r.get("pixelRatio") }), u = re.browser;
          if (typeof MouseEvent == "function" && (u.newEdge || !u.ie && !u.edge)) {
            var h = document.createElement("a");
            h.download = a + "." + s, h.target = "_blank", h.href = l;
            var c = new MouseEvent("click", { view: document.defaultView, bubbles: true, cancelable: false });
            h.dispatchEvent(c);
          } else if (window.navigator.msSaveOrOpenBlob || o) {
            var f = l.split(","), g = f[0].indexOf("base64") > -1, d = o ? decodeURIComponent(f[1]) : f[1];
            g && (d = window.atob(d));
            var A = a + "." + s;
            if (window.navigator.msSaveOrOpenBlob) {
              for (var p = d.length, v = new Uint8Array(p); p--; ) v[p] = d.charCodeAt(p);
              var y = new Blob([v]);
              window.navigator.msSaveOrOpenBlob(y, A);
            } else {
              var m = document.createElement("iframe");
              document.body.appendChild(m);
              var _ = m.contentWindow, I = _.document;
              I.open("image/svg+xml", "replace"), I.write(d), I.close(), _.focus(), I.execCommand("SaveAs", true, A), document.body.removeChild(m);
            }
          } else {
            var E = r.get("lang"), x = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (E && E[0] || "") + '" /></body>', w = window.open();
            w.document.write(x), w.document.title = a;
          }
        }, t.getDefaultOption = function(e) {
          var i = { show: true, icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0", title: e.getLocaleModel().get(["toolbox", "saveAsImage", "title"]), type: "png", connectedBackgroundColor: "#fff", name: "", excludeComponents: ["toolbox"], lang: e.getLocaleModel().get(["toolbox", "saveAsImage", "lang"]) };
          return i;
        }, t;
      }(Ra), jY = "__ec_magicType_stack__", XFt = [["line", "bar"], ["stack"]], $Ft = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.getIcons = function() {
          var e = this.model, i = e.get("icon"), r = {};
          return D(e.get("type"), function(a) {
            i[a] && (r[a] = i[a]);
          }), r;
        }, t.getDefaultOption = function(e) {
          var i = { show: true, type: [], icon: { line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4", bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7", stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z" }, title: e.getLocaleModel().get(["toolbox", "magicType", "title"]), option: {}, seriesIndex: {} };
          return i;
        }, t.prototype.onclick = function(e, i, r) {
          var a = this.model, o = a.get(["seriesIndex", r]);
          if (qY[r]) {
            var s = { series: [] }, l = function(c) {
              var f = c.subType, g = c.id, d = qY[r](f, g, c, a);
              d && (wt(d, c.option), s.series.push(d));
              var A = c.coordinateSystem;
              if (A && A.type === "cartesian2d" && (r === "line" || r === "bar")) {
                var p = A.getAxesByScale("ordinal")[0];
                if (p) {
                  var v = p.dim, y = v + "Axis", m = c.getReferringComponents(y, zn).models[0], _ = m.componentIndex;
                  s[y] = s[y] || [];
                  for (var I = 0; I <= _; I++) s[y][_] = s[y][_] || {};
                  s[y][_].boundaryGap = r === "bar";
                }
              }
            };
            D(XFt, function(c) {
              $t(c, r) >= 0 && D(c, function(f) {
                a.setIconStatus(f, "normal");
              });
            }), a.setIconStatus(r, "emphasis"), e.eachComponent({ mainType: "series", query: o == null ? null : { seriesIndex: o } }, l);
            var u, h = r;
            r === "stack" && (u = Yt({ stack: a.option.title.tiled, tiled: a.option.title.stack }, a.option.title), a.get(["iconStatus", r]) !== "emphasis" && (h = "tiled")), i.dispatchAction({ type: "changeMagicType", currentType: h, newOption: s, newTitle: u, featureName: "magicType" });
          }
        }, t;
      }(Ra), qY = { line: function(n, t, e, i) {
        if (n === "bar") return Yt({ id: t, type: "line", data: e.get("data"), stack: e.get("stack"), markPoint: e.get("markPoint"), markLine: e.get("markLine") }, i.get(["option", "line"]) || {}, true);
      }, bar: function(n, t, e, i) {
        if (n === "line") return Yt({ id: t, type: "bar", data: e.get("data"), stack: e.get("stack"), markPoint: e.get("markPoint"), markLine: e.get("markLine") }, i.get(["option", "bar"]) || {}, true);
      }, stack: function(n, t, e, i) {
        var r = e.get("stack") === jY;
        if (n === "line" || n === "bar") return i.setIconStatus("stack", r ? "normal" : "emphasis"), Yt({ id: t, stack: r ? "" : jY }, i.get(["option", "stack"]) || {}, true);
      } };
      ts({ type: "changeMagicType", event: "magicTypeChanged", update: "prepareAndUpdate" }, function(n, t) {
        t.mergeOption(n.newOption);
      });
      var MI = new Array(60).join("-"), Md = "	";
      function ZFt(n) {
        var t = {}, e = [], i = [];
        return n.eachRawSeries(function(r) {
          var a = r.coordinateSystem;
          if (a && (a.type === "cartesian2d" || a.type === "polar")) {
            var o = a.getBaseAxis();
            if (o.type === "category") {
              var s = o.dim + "_" + o.index;
              t[s] || (t[s] = { categoryAxis: o, valueAxis: a.getOtherAxis(o), series: [] }, i.push({ axisDim: o.dim, axisIndex: o.index })), t[s].series.push(r);
            } else e.push(r);
          } else e.push(r);
        }), { seriesGroupByCategoryAxis: t, other: e, meta: i };
      }
      function KFt(n) {
        var t = [];
        return D(n, function(e, i) {
          var r = e.categoryAxis, a = e.valueAxis, o = a.dim, s = [" "].concat(K(e.series, function(g) {
            return g.name;
          })), l = [r.model.getCategories()];
          D(e.series, function(g) {
            var d = g.getRawData();
            l.push(g.getRawData().mapArray(d.mapDimension(o), function(A) {
              return A;
            }));
          });
          for (var u = [s.join(Md)], h = 0; h < l[0].length; h++) {
            for (var c = [], f = 0; f < l.length; f++) c.push(l[f][h]);
            u.push(c.join(Md));
          }
          t.push(u.join(`
`));
        }), t.join(`

` + MI + `

`);
      }
      function JFt(n) {
        return K(n, function(t) {
          var e = t.getRawData(), i = [t.name], r = [];
          return e.each(e.dimensions, function() {
            for (var a = arguments.length, o = arguments[a - 1], s = e.getName(o), l = 0; l < a - 1; l++) r[l] = arguments[l];
            i.push((s ? s + Md : "") + r.join(Md));
          }), i.join(`
`);
        }).join(`

` + MI + `

`);
      }
      function tkt(n) {
        var t = ZFt(n);
        return { value: Fe([KFt(t.seriesGroupByCategoryAxis), JFt(t.other)], function(e) {
          return !!e.replace(/[\n\t\s]/g, "");
        }).join(`

` + MI + `

`), meta: t.meta };
      }
      function DI(n) {
        return n.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function ekt(n) {
        var t = n.slice(0, n.indexOf(`
`));
        if (t.indexOf(Md) >= 0) return true;
      }
      var KR = new RegExp("[" + Md + "]+", "g");
      function nkt(n) {
        for (var t = n.split(/\n+/g), e = DI(t.shift()).split(KR), i = [], r = K(e, function(l) {
          return { name: l, data: [] };
        }), a = 0; a < t.length; a++) {
          var o = DI(t[a]).split(KR);
          i.push(o.shift());
          for (var s = 0; s < o.length; s++) r[s] && (r[s].data[a] = o[s]);
        }
        return { series: r, categories: i };
      }
      function ikt(n) {
        for (var t = n.split(/\n+/g), e = DI(t.shift()), i = [], r = 0; r < t.length; r++) {
          var a = DI(t[r]);
          if (a) {
            var o = a.split(KR), s = "", l = void 0, u = false;
            isNaN(o[0]) ? (u = true, s = o[0], o = o.slice(1), i[r] = { name: s, value: [] }, l = i[r].value) : l = i[r] = [];
            for (var h = 0; h < o.length; h++) l.push(+o[h]);
            l.length === 1 && (u ? i[r].value = l[0] : i[r] = l[0]);
          }
        }
        return { name: e, data: i };
      }
      function rkt(n, t) {
        var e = n.split(new RegExp(`
*` + MI + `
*`, "g")), i = { series: [] };
        return D(e, function(r, a) {
          if (ekt(r)) {
            var o = nkt(r), s = t[a], l = s.axisDim + "Axis";
            s && (i[l] = i[l] || [], i[l][s.axisIndex] = { data: o.categories }, i.series = i.series.concat(o.series));
          } else {
            var o = ikt(r);
            i.series.push(o);
          }
        }), i;
      }
      var akt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.onclick = function(e, i) {
          setTimeout(function() {
            i.dispatchAction({ type: "hideTip" });
          });
          var r = i.getDom(), a = this.model;
          this._dom && r.removeChild(this._dom);
          var o = document.createElement("div");
          o.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", o.style.backgroundColor = a.get("backgroundColor") || "#fff";
          var s = document.createElement("h4"), l = a.get("lang") || [];
          s.innerHTML = l[0] || a.get("title"), s.style.cssText = "margin:10px 20px", s.style.color = a.get("textColor");
          var u = document.createElement("div"), h = document.createElement("textarea");
          u.style.cssText = "overflow:auto";
          var c = a.get("optionToContent"), f = a.get("contentToOption"), g = tkt(e);
          if (yt(c)) {
            var d = c(i.getOption());
            ht(d) ? u.innerHTML = d : Ah(d) && u.appendChild(d);
          } else {
            h.readOnly = a.get("readOnly");
            var A = h.style;
            A.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", A.color = a.get("textColor"), A.borderColor = a.get("textareaBorderColor"), A.backgroundColor = a.get("textareaColor"), h.value = g.value, u.appendChild(h);
          }
          var p = g.meta, v = document.createElement("div");
          v.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
          var y = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", m = document.createElement("div"), _ = document.createElement("div");
          y += ";background-color:" + a.get("buttonColor"), y += ";color:" + a.get("buttonTextColor");
          var I = this;
          function E() {
            r.removeChild(o), I._dom = null;
          }
          R2(m, "click", E), R2(_, "click", function() {
            if (f == null && c != null || f != null && c == null) {
              gn("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored."), E();
              return;
            }
            var x;
            try {
              yt(f) ? x = f(u, i.getOption()) : x = rkt(h.value, p);
            } catch (w) {
              throw E(), new Error("Data view format error " + w);
            }
            x && i.dispatchAction({ type: "changeDataView", newOption: x }), E();
          }), m.innerHTML = l[1], _.innerHTML = l[2], _.style.cssText = m.style.cssText = y, !a.get("readOnly") && v.appendChild(_), v.appendChild(m), o.appendChild(s), o.appendChild(u), o.appendChild(v), u.style.height = r.clientHeight - 80 + "px", r.appendChild(o), this._dom = o;
        }, t.prototype.remove = function(e, i) {
          this._dom && i.getDom().removeChild(this._dom);
        }, t.prototype.dispose = function(e, i) {
          this.remove(e, i);
        }, t.getDefaultOption = function(e) {
          var i = { show: true, readOnly: false, optionToContent: null, contentToOption: null, icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28", title: e.getLocaleModel().get(["toolbox", "dataView", "title"]), lang: e.getLocaleModel().get(["toolbox", "dataView", "lang"]), backgroundColor: "#fff", textColor: "#000", textareaColor: "#fff", textareaBorderColor: "#333", buttonColor: "#c23531", buttonTextColor: "#fff" };
          return i;
        }, t;
      }(Ra);
      function okt(n, t) {
        return K(n, function(e, i) {
          var r = t && t[i];
          if (Et(r) && !Z(r)) {
            var a = Et(e) && !Z(e);
            a || (e = { value: e });
            var o = r.name != null && e.name == null;
            return e = wt(e, r), o && delete e.name, e;
          } else return e;
        });
      }
      ts({ type: "changeDataView", event: "dataViewChanged", update: "prepareAndUpdate" }, function(n, t) {
        var e = [];
        D(n.newOption.series, function(i) {
          var r = t.getSeriesByName(i.name)[0];
          if (!r) e.push(X({ type: "scatter" }, i));
          else {
            var a = r.get("data");
            e.push({ name: i.name, data: okt(i.data, a) });
          }
        }), t.mergeOption(wt({ series: e }, n.newOption));
      });
      var HY = D, YY = ce();
      function skt(n, t) {
        var e = JR(n);
        HY(t, function(i, r) {
          for (var a = e.length - 1; a >= 0; a--) {
            var o = e[a];
            if (o[r]) break;
          }
          if (a < 0) {
            var s = n.queryComponents({ mainType: "dataZoom", subType: "select", id: r })[0];
            if (s) {
              var l = s.getPercentRange();
              e[0][r] = { dataZoomId: r, start: l[0], end: l[1] };
            }
          }
        }), e.push(t);
      }
      function lkt(n) {
        var t = JR(n), e = t[t.length - 1];
        t.length > 1 && t.pop();
        var i = {};
        return HY(e, function(r, a) {
          for (var o = t.length - 1; o >= 0; o--) if (r = t[o][a], r) {
            i[a] = r;
            break;
          }
        }), i;
      }
      function ukt(n) {
        YY(n).snapshots = null;
      }
      function hkt(n) {
        return JR(n).length;
      }
      function JR(n) {
        var t = YY(n);
        return t.snapshots || (t.snapshots = [{}]), t.snapshots;
      }
      var ckt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.onclick = function(e, i) {
          ukt(e), i.dispatchAction({ type: "restore", from: this.uid });
        }, t.getDefaultOption = function(e) {
          var i = { show: true, icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5", title: e.getLocaleModel().get(["toolbox", "restore", "title"]) };
          return i;
        }, t;
      }(Ra);
      ts({ type: "restore", event: "restore", update: "prepareAndUpdate" }, function(n, t) {
        t.resetOption("recreate");
      });
      var fkt = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"], tL = function() {
        function n(t, e, i) {
          var r = this;
          this._targetInfoList = [];
          var a = WY(e, t);
          D(gkt, function(o, s) {
            (!i || !i.include || $t(i.include, s) >= 0) && o(a, r._targetInfoList);
          });
        }
        return n.prototype.setOutputRanges = function(t, e) {
          return this.matchOutputRanges(t, e, function(i, r, a) {
            if ((i.coordRanges || (i.coordRanges = [])).push(r), !i.coordRange) {
              i.coordRange = r;
              var o = nL[i.brushType](0, a, r);
              i.__rangeOffset = { offset: KY[i.brushType](o.values, i.range, [1, 1]), xyMinMax: o.xyMinMax };
            }
          }), t;
        }, n.prototype.matchOutputRanges = function(t, e, i) {
          D(t, function(r) {
            var a = this.findTargetInfo(r, e);
            a && a !== true && D(a.coordSyses, function(o) {
              var s = nL[r.brushType](1, o, r.range, true);
              i(r, s.values, o, e);
            });
          }, this);
        }, n.prototype.setInputRanges = function(t, e) {
          D(t, function(i) {
            var r = this.findTargetInfo(i, e);
            if (It(!r || r === true || i.coordRange, "coordRange must be specified when coord index specified."), It(!r || r !== true || i.range, "range must be specified in global brush."), i.range = i.range || [], r && r !== true) {
              i.panelId = r.panelId;
              var a = nL[i.brushType](0, r.coordSys, i.coordRange), o = i.__rangeOffset;
              i.range = o ? KY[i.brushType](a.values, o.offset, dkt(a.xyMinMax, o.xyMinMax)) : a.values;
            }
          }, this);
        }, n.prototype.makePanelOpts = function(t, e) {
          return K(this._targetInfoList, function(i) {
            var r = i.getPanelRect();
            return { panelId: i.panelId, defaultBrushType: e ? e(i) : null, clipPath: H7(r), isTargetByCursor: W7(r, t, i.coordSysModel), getLinearBrushOtherExtent: Y7(r) };
          });
        }, n.prototype.controlSeries = function(t, e, i) {
          var r = this.findTargetInfo(t, i);
          return r === true || r && $t(r.coordSyses, e.coordinateSystem) >= 0;
        }, n.prototype.findTargetInfo = function(t, e) {
          for (var i = this._targetInfoList, r = WY(e, t), a = 0; a < i.length; a++) {
            var o = i[a], s = t.panelId;
            if (s) {
              if (o.panelId === s) return o;
            } else for (var l = 0; l < XY.length; l++) if (XY[l](r, o)) return o;
          }
          return true;
        }, n;
      }();
      function eL(n) {
        return n[0] > n[1] && n.reverse(), n;
      }
      function WY(n, t) {
        return ev(n, t, { includeMainTypes: fkt });
      }
      var gkt = { grid: function(n, t) {
        var e = n.xAxisModels, i = n.yAxisModels, r = n.gridModels, a = dt(), o = {}, s = {};
        !e && !i && !r || (D(e, function(l) {
          var u = l.axis.grid.model;
          a.set(u.id, u), o[u.id] = true;
        }), D(i, function(l) {
          var u = l.axis.grid.model;
          a.set(u.id, u), s[u.id] = true;
        }), D(r, function(l) {
          a.set(l.id, l), o[l.id] = true, s[l.id] = true;
        }), a.each(function(l) {
          var u = l.coordinateSystem, h = [];
          D(u.getCartesians(), function(c, f) {
            ($t(e, c.getAxis("x").model) >= 0 || $t(i, c.getAxis("y").model) >= 0) && h.push(c);
          }), t.push({ panelId: "grid--" + l.id, gridModel: l, coordSysModel: l, coordSys: h[0], coordSyses: h, getPanelRect: $Y.grid, xAxisDeclared: o[l.id], yAxisDeclared: s[l.id] });
        }));
      }, geo: function(n, t) {
        D(n.geoModels, function(e) {
          var i = e.coordinateSystem;
          t.push({ panelId: "geo--" + e.id, geoModel: e, coordSysModel: e, coordSys: i, coordSyses: [i], getPanelRect: $Y.geo });
        });
      } }, XY = [function(n, t) {
        var e = n.xAxisModel, i = n.yAxisModel, r = n.gridModel;
        return !r && e && (r = e.axis.grid.model), !r && i && (r = i.axis.grid.model), r && r === t.gridModel;
      }, function(n, t) {
        var e = n.geoModel;
        return e && e === t.geoModel;
      }], $Y = { grid: function() {
        return this.coordSys.master.getRect().clone();
      }, geo: function() {
        var n = this.coordSys, t = n.getBoundingRect().clone();
        return t.applyTransform(Yh(n)), t;
      } }, nL = { lineX: Gt(ZY, 0), lineY: Gt(ZY, 1), rect: function(n, t, e, i) {
        var r = n ? t.pointToData([e[0][0], e[1][0]], i) : t.dataToPoint([e[0][0], e[1][0]], i), a = n ? t.pointToData([e[0][1], e[1][1]], i) : t.dataToPoint([e[0][1], e[1][1]], i), o = [eL([r[0], a[0]]), eL([r[1], a[1]])];
        return { values: o, xyMinMax: o };
      }, polygon: function(n, t, e, i) {
        var r = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]], a = K(e, function(o) {
          var s = n ? t.pointToData(o, i) : t.dataToPoint(o, i);
          return r[0][0] = Math.min(r[0][0], s[0]), r[1][0] = Math.min(r[1][0], s[1]), r[0][1] = Math.max(r[0][1], s[0]), r[1][1] = Math.max(r[1][1], s[1]), s;
        });
        return { values: a, xyMinMax: r };
      } };
      function ZY(n, t, e, i) {
        It(e.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
        var r = e.getAxis(["x", "y"][n]), a = eL(K([0, 1], function(s) {
          return t ? r.coordToData(r.toLocalCoord(i[s]), true) : r.toGlobalCoord(r.dataToCoord(i[s]));
        })), o = [];
        return o[n] = a, o[1 - n] = [NaN, NaN], { values: a, xyMinMax: o };
      }
      var KY = { lineX: Gt(JY, 0), lineY: Gt(JY, 1), rect: function(n, t, e) {
        return [[n[0][0] - e[0] * t[0][0], n[0][1] - e[0] * t[0][1]], [n[1][0] - e[1] * t[1][0], n[1][1] - e[1] * t[1][1]]];
      }, polygon: function(n, t, e) {
        return K(n, function(i, r) {
          return [i[0] - e[0] * t[r][0], i[1] - e[1] * t[r][1]];
        });
      } };
      function JY(n, t, e, i) {
        return [t[0] - i[n] * e[0], t[1] - i[n] * e[1]];
      }
      function dkt(n, t) {
        var e = tW(n), i = tW(t), r = [e[0] / i[0], e[1] / i[1]];
        return isNaN(r[0]) && (r[0] = 1), isNaN(r[1]) && (r[1] = 1), r;
      }
      function tW(n) {
        return n ? [n[0][1] - n[0][0], n[1][1] - n[1][0]] : [NaN, NaN];
      }
      var iL = D, Akt = IEt("toolbox-dataZoom_"), pkt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.render = function(e, i, r, a) {
          this._brushController || (this._brushController = new nR(r.getZr()), this._brushController.on("brush", ct(this._onBrush, this)).mount()), mkt(e, i, this, a, r), ykt(e, i);
        }, t.prototype.onclick = function(e, i, r) {
          vkt[r].call(this);
        }, t.prototype.remove = function(e, i) {
          this._brushController && this._brushController.unmount();
        }, t.prototype.dispose = function(e, i) {
          this._brushController && this._brushController.dispose();
        }, t.prototype._onBrush = function(e) {
          var i = e.areas;
          if (!e.isEnd || !i.length) return;
          var r = {}, a = this.ecModel;
          this._brushController.updateCovers([]);
          var o = new tL(rL(this.model), a, { include: ["grid"] });
          o.matchOutputRanges(i, a, function(u, h, c) {
            if (c.type === "cartesian2d") {
              var f = u.brushType;
              f === "rect" ? (s("x", c, h[0]), s("y", c, h[1])) : s({ lineX: "x", lineY: "y" }[f], c, h);
            }
          }), skt(a, r), this._dispatchZoomAction(r);
          function s(u, h, c) {
            var f = h.getAxis(u), g = f.model, d = l(u, g, a), A = d.findRepresentativeAxisProxy(g).getMinMaxSpan();
            (A.minValueSpan != null || A.maxValueSpan != null) && (c = Ic(0, c.slice(), f.scale.getExtent(), 0, A.minValueSpan, A.maxValueSpan)), d && (r[d.id] = { dataZoomId: d.id, startValue: c[0], endValue: c[1] });
          }
          function l(u, h, c) {
            var f;
            return c.eachComponent({ mainType: "dataZoom", subType: "select" }, function(g) {
              var d = g.getAxisModel(u, h.componentIndex);
              d && (f = g);
            }), f;
          }
        }, t.prototype._dispatchZoomAction = function(e) {
          var i = [];
          iL(e, function(r, a) {
            i.push(Ct(r));
          }), i.length && this.api.dispatchAction({ type: "dataZoom", from: this.uid, batch: i });
        }, t.getDefaultOption = function(e) {
          var i = { show: true, filterMode: "filter", icon: { zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1", back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26" }, title: e.getLocaleModel().get(["toolbox", "dataZoom", "title"]), brushStyle: { borderWidth: 0, color: "rgba(210,219,238,0.2)" } };
          return i;
        }, t;
      }(Ra), vkt = { zoom: function() {
        var n = !this._isZoomActive;
        this.api.dispatchAction({ type: "takeGlobalCursor", key: "dataZoomSelect", dataZoomSelectActive: n });
      }, back: function() {
        this._dispatchZoomAction(lkt(this.ecModel));
      } };
      function rL(n) {
        var t = { xAxisIndex: n.get("xAxisIndex", true), yAxisIndex: n.get("yAxisIndex", true), xAxisId: n.get("xAxisId", true), yAxisId: n.get("yAxisId", true) };
        return t.xAxisIndex == null && t.xAxisId == null && (t.xAxisIndex = "all"), t.yAxisIndex == null && t.yAxisId == null && (t.yAxisIndex = "all"), t;
      }
      function ykt(n, t) {
        n.setIconStatus("back", hkt(t) > 1 ? "emphasis" : "normal");
      }
      function mkt(n, t, e, i, r) {
        var a = e._isZoomActive;
        i && i.type === "takeGlobalCursor" && (a = i.key === "dataZoomSelect" ? i.dataZoomSelectActive : false), e._isZoomActive = a, n.setIconStatus("zoom", a ? "emphasis" : "normal");
        var o = new tL(rL(n), t, { include: ["grid"] }), s = o.makePanelOpts(r, function(l) {
          return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect";
        });
        e._brushController.setPanels(s).enableBrush(a && s.length ? { brushType: "auto", brushStyle: n.getModel("brushStyle").getItemStyle() } : false);
      }
      Yxt("dataZoom", function(n) {
        var t = n.getComponent("toolbox", 0), e = ["feature", "dataZoom"];
        if (!t || t.get(e) == null) return;
        var i = t.getModel(e), r = [], a = rL(i), o = ev(n, a);
        iL(o.xAxisModels, function(l) {
          return s(l, "xAxis", "xAxisIndex");
        }), iL(o.yAxisModels, function(l) {
          return s(l, "yAxis", "yAxisIndex");
        });
        function s(l, u, h) {
          var c = l.componentIndex, f = { type: "select", $fromToolbox: true, filterMode: i.get("filterMode", true) || "filter", id: Akt + u + c };
          f[h] = c, r.push(f);
        }
        return r;
      });
      function _kt(n) {
        n.registerComponentModel(jFt), n.registerComponentView(HFt), Bd("saveAsImage", WFt), Bd("magicType", $Ft), Bd("dataView", akt), Bd("dataZoom", pkt), Bd("restore", ckt), Kt(VFt);
      }
      var Ekt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "tooltip", t.dependencies = ["axisPointer"], t.defaultOption = { z: 60, show: true, showContent: true, trigger: "item", triggerOn: "mousemove|click", alwaysShowContent: false, displayMode: "single", renderMode: "auto", confine: null, showDelay: 0, hideDelay: 100, transitionDuration: 0.4, enterable: false, backgroundColor: "#fff", shadowBlur: 10, shadowColor: "rgba(0, 0, 0, .2)", shadowOffsetX: 1, shadowOffsetY: 2, borderRadius: 4, borderWidth: 1, padding: null, extraCssText: "", axisPointer: { type: "line", axis: "auto", animation: "auto", animationDurationUpdate: 200, animationEasingUpdate: "exponentialOut", crossStyle: { color: "#999", width: 1, type: "dashed", textStyle: {} } }, textStyle: { color: "#666", fontSize: 14 } }, t;
      }(ae);
      function eW(n) {
        var t = n.get("confine");
        return t != null ? !!t : n.get("renderMode") === "richText";
      }
      function nW(n) {
        if (re.domSupported) {
          for (var t = document.documentElement.style, e = 0, i = n.length; e < i; e++) if (n[e] in t) return n[e];
        }
      }
      var iW = nW(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), Ikt = nW(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
      function rW(n, t) {
        if (!n) return t;
        t = o6(t, true);
        var e = n.indexOf(t);
        return n = e === -1 ? t : "-" + n.slice(0, e) + "-" + t, n.toLowerCase();
      }
      function xkt(n, t) {
        var e = n.currentStyle || document.defaultView && document.defaultView.getComputedStyle(n);
        return e ? e[t] : null;
      }
      var wkt = rW(Ikt, "transition"), aL = rW(iW, "transform"), Ckt = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (re.transform3dSupported ? "will-change:transform;" : "");
      function Skt(n) {
        return n = n === "left" ? "right" : n === "right" ? "left" : n === "top" ? "bottom" : "top", n;
      }
      function bkt(n, t, e) {
        if (!ht(e) || e === "inside") return "";
        var i = n.get("backgroundColor"), r = n.get("borderWidth");
        t = Xh(t);
        var a = Skt(e), o = Math.max(Math.round(r) * 1.5, 6), s = "", l = aL + ":", u;
        $t(["left", "right"], a) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
        var h = u * Math.PI / 180, c = o + r, f = c * Math.abs(Math.cos(h)) + c * Math.abs(Math.sin(h)), g = Math.round(((f - Math.SQRT2 * r) / 2 + Math.SQRT2 * r - (f - c) / 2) * 100) / 100;
        s += ";" + a + ":-" + g + "px";
        var d = t + " solid " + r + "px;", A = ["position:absolute;width:" + o + "px;height:" + o + "px;z-index:-1;", s + ";" + l + ";", "border-bottom:" + d, "border-right:" + d, "background-color:" + i + ";"];
        return '<div style="' + A.join("") + '"></div>';
      }
      function Tkt(n, t) {
        var e = "cubic-bezier(0.23,1,0.32,1)", i = " " + n / 2 + "s " + e, r = "opacity" + i + ",visibility" + i;
        return t || (i = " " + n + "s " + e, r += re.transformSupported ? "," + aL + i : ",left" + i + ",top" + i), wkt + ":" + r;
      }
      function aW(n, t, e) {
        var i = n.toFixed(0) + "px", r = t.toFixed(0) + "px";
        if (!re.transformSupported) return e ? "top:" + r + ";left:" + i + ";" : [["top", r], ["left", i]];
        var a = re.transform3dSupported, o = "translate" + (a ? "3d" : "") + "(" + i + "," + r + (a ? ",0" : "") + ")";
        return e ? "top:0;left:0;" + aL + ":" + o + ";" : [["top", 0], ["left", 0], [iW, o]];
      }
      function Bkt(n) {
        var t = [], e = n.get("fontSize"), i = n.getTextColor();
        i && t.push("color:" + i), t.push("font:" + n.getFont()), e && t.push("line-height:" + Math.round(e * 3 / 2) + "px");
        var r = n.get("textShadowColor"), a = n.get("textShadowBlur") || 0, o = n.get("textShadowOffsetX") || 0, s = n.get("textShadowOffsetY") || 0;
        return r && a && t.push("text-shadow:" + o + "px " + s + "px " + a + "px " + r), D(["decoration", "align"], function(l) {
          var u = n.get(l);
          u && t.push("text-" + l + ":" + u);
        }), t.join(";");
      }
      function Mkt(n, t, e) {
        var i = [], r = n.get("transitionDuration"), a = n.get("backgroundColor"), o = n.get("shadowBlur"), s = n.get("shadowColor"), l = n.get("shadowOffsetX"), u = n.get("shadowOffsetY"), h = n.getModel("textStyle"), c = hU(n, "html"), f = l + "px " + u + "px " + o + "px " + s;
        return i.push("box-shadow:" + f), t && r && i.push(Tkt(r, e)), a && i.push("background-color:" + a), D(["width", "color", "radius"], function(g) {
          var d = "border-" + g, A = o6(d), p = n.get(A);
          p != null && i.push(d + ":" + p + (g === "color" ? "" : "px"));
        }), i.push(Bkt(h)), c != null && i.push("padding:" + Zg(c).join("px ") + "px"), i.join(";") + ";";
      }
      function oW(n, t, e, i, r) {
        var a = t && t.painter;
        if (e) {
          var o = a && a.getViewportRoot();
          o && J_t(n, o, e, i, r);
        } else {
          n[0] = i, n[1] = r;
          var s = a && a.getViewportRootOffset();
          s && (n[0] += s.offsetLeft, n[1] += s.offsetTop);
        }
        n[2] = n[0] / t.getWidth(), n[3] = n[1] / t.getHeight();
      }
      var Dkt = function() {
        function n(t, e) {
          if (this._show = false, this._styleCoord = [0, 0, 0, 0], this._enterable = true, this._alwaysShowContent = false, this._firstShow = true, this._longHide = true, re.wxa) return null;
          var i = document.createElement("div");
          i.domBelongToZr = true, this.el = i;
          var r = this._zr = t.getZr(), a = e.appendTo, o = a && (ht(a) ? document.querySelector(a) : Ah(a) ? a : yt(a) && a(t.getDom()));
          oW(this._styleCoord, r, o, t.getWidth() / 2, t.getHeight() / 2), (o || t.getDom()).appendChild(i), this._api = t, this._container = o;
          var s = this;
          i.onmouseenter = function() {
            s._enterable && (clearTimeout(s._hideTimeout), s._show = true), s._inContent = true;
          }, i.onmousemove = function(l) {
            if (l = l || window.event, !s._enterable) {
              var u = r.handler, h = r.painter.getViewportRoot();
              da(h, l, true), u.dispatch("mousemove", l);
            }
          }, i.onmouseleave = function() {
            s._inContent = false, s._enterable && s._show && s.hideLater(s._hideDelay);
          };
        }
        return n.prototype.update = function(t) {
          if (!this._container) {
            var e = this._api.getDom(), i = xkt(e, "position"), r = e.style;
            r.position !== "absolute" && i !== "absolute" && (r.position = "relative");
          }
          var a = t.get("alwaysShowContent");
          a && this._moveIfResized(), this._alwaysShowContent = a, this.el.className = t.get("className") || "";
        }, n.prototype.show = function(t, e) {
          clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
          var i = this.el, r = i.style, a = this._styleCoord;
          i.innerHTML ? r.cssText = Ckt + Mkt(t, !this._firstShow, this._longHide) + aW(a[0], a[1], true) + ("border-color:" + Xh(e) + ";") + (t.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : r.display = "none", this._show = true, this._firstShow = false, this._longHide = false;
        }, n.prototype.setContent = function(t, e, i, r, a) {
          var o = this.el;
          if (t == null) {
            o.innerHTML = "";
            return;
          }
          var s = "";
          if (ht(a) && i.get("trigger") === "item" && !eW(i) && (s = bkt(i, r, a)), ht(t)) o.innerHTML = t + s;
          else if (t) {
            o.innerHTML = "", Z(t) || (t = [t]);
            for (var l = 0; l < t.length; l++) Ah(t[l]) && t[l].parentNode !== o && o.appendChild(t[l]);
            if (s && o.childNodes.length) {
              var u = document.createElement("div");
              u.innerHTML = s, o.appendChild(u);
            }
          }
        }, n.prototype.setEnterable = function(t) {
          this._enterable = t;
        }, n.prototype.getSize = function() {
          var t = this.el;
          return [t.offsetWidth, t.offsetHeight];
        }, n.prototype.moveTo = function(t, e) {
          var i = this._styleCoord;
          if (oW(i, this._zr, this._container, t, e), i[0] != null && i[1] != null) {
            var r = this.el.style, a = aW(i[0], i[1]);
            D(a, function(o) {
              r[o[0]] = o[1];
            });
          }
        }, n.prototype._moveIfResized = function() {
          var t = this._styleCoord[2], e = this._styleCoord[3];
          this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight());
        }, n.prototype.hide = function() {
          var t = this, e = this.el.style;
          e.visibility = "hidden", e.opacity = "0", re.transform3dSupported && (e.willChange = ""), this._show = false, this._longHideTimeout = setTimeout(function() {
            return t._longHide = true;
          }, 500);
        }, n.prototype.hideLater = function(t) {
          this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = false, this._hideTimeout = setTimeout(ct(this.hide, this), t)) : this.hide());
        }, n.prototype.isShow = function() {
          return this._show;
        }, n.prototype.dispose = function() {
          clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
          var t = this.el.parentNode;
          t && t.removeChild(this.el), this.el = this._container = null;
        }, n;
      }(), Rkt = function() {
        function n(t) {
          this._show = false, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = false, this._enterable = true, this._zr = t.getZr(), lW(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2);
        }
        return n.prototype.update = function(t) {
          var e = t.get("alwaysShowContent");
          e && this._moveIfResized(), this._alwaysShowContent = e;
        }, n.prototype.show = function() {
          this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = true;
        }, n.prototype.setContent = function(t, e, i, r, a) {
          var o = this;
          Et(t) && be(true ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
          var s = i.getModel("textStyle");
          this.el = new Ae({ style: { rich: e.richTextStyles, text: t, lineHeight: 22, borderWidth: 1, borderColor: r, textShadowColor: s.get("textShadowColor"), fill: i.get(["textStyle", "color"]), padding: hU(i, "richText"), verticalAlign: "top", align: "left" }, z: i.get("z") }), D(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
            o.el.style[u] = i.get(u);
          }), D(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
            o.el.style[u] = s.get(u) || 0;
          }), this._zr.add(this.el);
          var l = this;
          this.el.on("mouseover", function() {
            l._enterable && (clearTimeout(l._hideTimeout), l._show = true), l._inContent = true;
          }), this.el.on("mouseout", function() {
            l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = false;
          });
        }, n.prototype.setEnterable = function(t) {
          this._enterable = t;
        }, n.prototype.getSize = function() {
          var t = this.el, e = this.el.getBoundingRect(), i = sW(t.style);
          return [e.width + i.left + i.right, e.height + i.top + i.bottom];
        }, n.prototype.moveTo = function(t, e) {
          var i = this.el;
          if (i) {
            var r = this._styleCoord;
            lW(r, this._zr, t, e), t = r[0], e = r[1];
            var a = i.style, o = Tu(a.borderWidth || 0), s = sW(a);
            i.x = t + o + s.left, i.y = e + o + s.top, i.markRedraw();
          }
        }, n.prototype._moveIfResized = function() {
          var t = this._styleCoord[2], e = this._styleCoord[3];
          this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight());
        }, n.prototype.hide = function() {
          this.el && this.el.hide(), this._show = false;
        }, n.prototype.hideLater = function(t) {
          this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = false, this._hideTimeout = setTimeout(ct(this.hide, this), t)) : this.hide());
        }, n.prototype.isShow = function() {
          return this._show;
        }, n.prototype.dispose = function() {
          this._zr.remove(this.el);
        }, n;
      }();
      function Tu(n) {
        return Math.max(0, n);
      }
      function sW(n) {
        var t = Tu(n.shadowBlur || 0), e = Tu(n.shadowOffsetX || 0), i = Tu(n.shadowOffsetY || 0);
        return { left: Tu(t - e), right: Tu(t + e), top: Tu(t - i), bottom: Tu(t + i) };
      }
      function lW(n, t, e, i) {
        n[0] = e, n[1] = i, n[2] = n[0] / t.getWidth(), n[3] = n[1] / t.getHeight();
      }
      var Lkt = new fe({ shape: { x: -1, y: -1, width: 2, height: 2 } }), Pkt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e, i) {
          if (!(re.node || !i.getDom())) {
            var r = e.getComponent("tooltip"), a = this._renderMode = BEt(r.get("renderMode"));
            this._tooltipContent = a === "richText" ? new Rkt(i) : new Dkt(i, { appendTo: r.get("appendToBody", true) ? "body" : r.get("appendTo", true) });
          }
        }, t.prototype.render = function(e, i, r) {
          if (!(re.node || !r.getDom())) {
            this.group.removeAll(), this._tooltipModel = e, this._ecModel = i, this._api = r;
            var a = this._tooltipContent;
            a.update(e), a.setEnterable(e.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && e.get("transitionDuration") ? ad(this, "_updatePosition", 50, "fixRate") : Mv(this, "_updatePosition");
          }
        }, t.prototype._initGlobalListener = function() {
          var e = this._tooltipModel, i = e.get("triggerOn");
          dY("itemTooltip", this._api, ct(function(r, a, o) {
            i !== "none" && (i.indexOf(r) >= 0 ? this._tryShow(a, o) : r === "leave" && this._hide(o));
          }, this));
        }, t.prototype._keepShow = function() {
          var e = this._tooltipModel, i = this._ecModel, r = this._api, a = e.get("triggerOn");
          if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
            var o = this;
            clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
              !r.isDisposed() && o.manuallyShowTip(e, i, r, { x: o._lastX, y: o._lastY, dataByCoordSys: o._lastDataByCoordSys });
            });
          }
        }, t.prototype.manuallyShowTip = function(e, i, r, a) {
          if (!(a.from === this.uid || re.node || !r.getDom())) {
            var o = uW(a, r);
            this._ticket = "";
            var s = a.dataByCoordSys, l = Okt(a, i, r);
            if (l) {
              var u = l.el.getBoundingRect().clone();
              u.applyTransform(l.el.transform), this._tryShow({ offsetX: u.x + u.width / 2, offsetY: u.y + u.height / 2, target: l.el, position: a.position, positionDefault: "bottom" }, o);
            } else if (a.tooltip && a.x != null && a.y != null) {
              var h = Lkt;
              h.x = a.x, h.y = a.y, h.update(), Nt(h).tooltipConfig = { name: null, option: a.tooltip }, this._tryShow({ offsetX: a.x, offsetY: a.y, target: h }, o);
            } else if (s) this._tryShow({ offsetX: a.x, offsetY: a.y, position: a.position, dataByCoordSys: s, tooltipOption: a.tooltipOption }, o);
            else if (a.seriesIndex != null) {
              if (this._manuallyAxisShowTip(e, i, r, a)) return;
              var c = pY(a, i), f = c.point[0], g = c.point[1];
              f != null && g != null && this._tryShow({ offsetX: f, offsetY: g, target: c.el, position: a.position, positionDefault: "bottom" }, o);
            } else a.x != null && a.y != null && (r.dispatchAction({ type: "updateAxisPointer", x: a.x, y: a.y }), this._tryShow({ offsetX: a.x, offsetY: a.y, position: a.position, target: r.getZr().findHover(a.x, a.y).target }, o));
          }
        }, t.prototype.manuallyHideTip = function(e, i, r, a) {
          var o = this._tooltipContent;
          this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(uW(a, r));
        }, t.prototype._manuallyAxisShowTip = function(e, i, r, a) {
          var o = a.seriesIndex, s = a.dataIndex, l = i.getComponent("axisPointer").coordSysAxesInfo;
          if (!(o == null || s == null || l == null)) {
            var u = i.getSeriesByIndex(o);
            if (u) {
              var h = u.getData(), c = xy([h.getItemModel(s), u, (u.coordinateSystem || {}).model], this._tooltipModel);
              if (c.get("trigger") === "axis") return r.dispatchAction({ type: "updateAxisPointer", seriesIndex: o, dataIndex: s, position: a.position }), true;
            }
          }
        }, t.prototype._tryShow = function(e, i) {
          var r = e.target, a = this._tooltipModel;
          if (a) {
            this._lastX = e.offsetX, this._lastY = e.offsetY;
            var o = e.dataByCoordSys;
            if (o && o.length) this._showAxisTooltip(o, e);
            else if (r) {
              var s = Nt(r);
              if (s.ssrType === "legend") return;
              this._lastDataByCoordSys = null;
              var l, u;
              ec(r, function(h) {
                if (Nt(h).dataIndex != null) return l = h, true;
                if (Nt(h).tooltipConfig != null) return u = h, true;
              }, true), l ? this._showSeriesItemTooltip(e, l, i) : u ? this._showComponentItemTooltip(e, u, i) : this._hide(i);
            } else this._lastDataByCoordSys = null, this._hide(i);
          }
        }, t.prototype._showOrMove = function(e, i) {
          var r = e.get("showDelay");
          i = ct(i, this), clearTimeout(this._showTimout), r > 0 ? this._showTimout = setTimeout(i, r) : i();
        }, t.prototype._showAxisTooltip = function(e, i) {
          var r = this._ecModel, a = this._tooltipModel, o = [i.offsetX, i.offsetY], s = xy([i.tooltipOption], a), l = this._renderMode, u = [], h = ti("section", { blocks: [], noHeader: true }), c = [], f = new VB();
          D(e, function(y) {
            D(y.dataByAxis, function(m) {
              var _ = r.getComponent(m.axisDim + "Axis", m.axisIndex), I = m.value;
              if (!(!_ || I == null)) {
                var E = lY(I, _.axis, r, m.seriesDataIndices, m.valueLabelOpt), x = ti("section", { header: E, noHeader: !Wa(E), sortBlocks: true, blocks: [] });
                h.blocks.push(x), D(m.seriesDataIndices, function(w) {
                  var C = r.getSeriesByIndex(w.seriesIndex), S = w.dataIndexInside, b = C.getDataParams(S);
                  if (!(b.dataIndex < 0)) {
                    b.axisDim = m.axisDim, b.axisIndex = m.axisIndex, b.axisType = m.axisType, b.axisId = m.axisId, b.axisValue = wM(_.axis, { value: I }), b.axisValueLabel = E, b.marker = f.makeTooltipMarker("item", Xh(b.color), l);
                    var T = j6(C.formatTooltip(S, true, null)), B = T.frag;
                    if (B) {
                      var R = xy([C], a).get("valueFormatter");
                      x.blocks.push(R ? X({ valueFormatter: R }, B) : B);
                    }
                    T.text && c.push(T.text), u.push(b);
                  }
                });
              }
            });
          }), h.blocks.reverse(), c.reverse();
          var g = i.position, d = s.get("order"), A = sU(h, f, l, d, r.get("useUTC"), s.get("textStyle"));
          A && c.unshift(A);
          var p = l === "richText" ? `

` : "<br/>", v = c.join(p);
          this._showOrMove(s, function() {
            this._updateContentNotChangedOnAxis(e, u) ? this._updatePosition(s, g, o[0], o[1], this._tooltipContent, u) : this._showTooltipContent(s, v, u, Math.random() + "", o[0], o[1], g, null, f);
          });
        }, t.prototype._showSeriesItemTooltip = function(e, i, r) {
          var a = this._ecModel, o = Nt(i), s = o.seriesIndex, l = a.getSeriesByIndex(s), u = o.dataModel || l, h = o.dataIndex, c = o.dataType, f = u.getData(c), g = this._renderMode, d = e.positionDefault, A = xy([f.getItemModel(h), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, d ? { position: d } : null), p = A.get("trigger");
          if (!(p != null && p !== "item")) {
            var v = u.getDataParams(h, c), y = new VB();
            v.marker = y.makeTooltipMarker("item", Xh(v.color), g);
            var m = j6(u.formatTooltip(h, false, c)), _ = A.get("order"), I = A.get("valueFormatter"), E = m.frag, x = E ? sU(I ? X({ valueFormatter: I }, E) : E, y, g, _, a.get("useUTC"), A.get("textStyle")) : m.text, w = "item_" + u.name + "_" + h;
            this._showOrMove(A, function() {
              this._showTooltipContent(A, x, v, w, e.offsetX, e.offsetY, e.position, e.target, y);
            }), r({ type: "showTip", dataIndexInside: h, dataIndex: f.getRawIndex(h), seriesIndex: s, from: this.uid });
          }
        }, t.prototype._showComponentItemTooltip = function(e, i, r) {
          var a = this._renderMode === "html", o = Nt(i), s = o.tooltipConfig, l = s.option || {}, u = l.encodeHTMLContent;
          if (ht(l)) {
            var h = l;
            l = { content: h, formatter: h }, u = true;
          }
          u && a && l.content && (l = Ct(l), l.content = Er(l.content));
          var c = [l], f = this._ecModel.getComponent(o.componentMainType, o.componentIndex);
          f && c.push(f), c.push({ formatter: l.content });
          var g = e.positionDefault, d = xy(c, this._tooltipModel, g ? { position: g } : null), A = d.get("content"), p = Math.random() + "", v = new VB();
          this._showOrMove(d, function() {
            var y = Ct(d.get("formatterParams") || {});
            this._showTooltipContent(d, A, y, p, e.offsetX, e.offsetY, e.position, i, v);
          }), r({ type: "showTip", from: this.uid });
        }, t.prototype._showTooltipContent = function(e, i, r, a, o, s, l, u, h) {
          if (this._ticket = "", !(!e.get("showContent") || !e.get("show"))) {
            var c = this._tooltipContent;
            c.setEnterable(e.get("enterable"));
            var f = e.get("formatter");
            l = l || e.get("position");
            var g = i, d = this._getNearestPoint([o, s], r, e.get("trigger"), e.get("borderColor")), A = d.color;
            if (f) if (ht(f)) {
              var p = e.ecModel.get("useUTC"), v = Z(r) ? r[0] : r, y = v && v.axisType && v.axisType.indexOf("time") >= 0;
              g = f, y && (g = X1(v.axisValue, g, p)), g = l6(g, r, true);
            } else if (yt(f)) {
              var m = ct(function(_, I) {
                _ === this._ticket && (c.setContent(I, h, e, A, l), this._updatePosition(e, l, o, s, c, r, u));
              }, this);
              this._ticket = a, g = f(r, a, m);
            } else g = f;
            c.setContent(g, h, e, A, l), c.show(e, A), this._updatePosition(e, l, o, s, c, r, u);
          }
        }, t.prototype._getNearestPoint = function(e, i, r, a) {
          if (r === "axis" || Z(i)) return { color: a || (this._renderMode === "html" ? "#fff" : "none") };
          if (!Z(i)) return { color: a || i.color || i.borderColor };
        }, t.prototype._updatePosition = function(e, i, r, a, o, s, l) {
          var u = this._api.getWidth(), h = this._api.getHeight();
          i = i || e.get("position");
          var c = o.getSize(), f = e.get("align"), g = e.get("verticalAlign"), d = l && l.getBoundingRect().clone();
          if (l && d.applyTransform(l.transform), yt(i) && (i = i([r, a], s, o.el, d, { viewSize: [u, h], contentSize: c.slice() })), Z(i)) r = st(i[0], u), a = st(i[1], h);
          else if (Et(i)) {
            var A = i;
            A.width = c[0], A.height = c[1];
            var p = Yn(A, { width: u, height: h });
            r = p.x, a = p.y, f = null, g = null;
          } else if (ht(i) && l) {
            var v = kkt(i, d, c, e.get("borderWidth"));
            r = v[0], a = v[1];
          } else {
            var v = Nkt(r, a, o, u, h, f ? null : 20, g ? null : 20);
            r = v[0], a = v[1];
          }
          if (f && (r -= hW(f) ? c[0] / 2 : f === "right" ? c[0] : 0), g && (a -= hW(g) ? c[1] / 2 : g === "bottom" ? c[1] : 0), eW(e)) {
            var v = Fkt(r, a, o, u, h);
            r = v[0], a = v[1];
          }
          o.moveTo(r, a);
        }, t.prototype._updateContentNotChangedOnAxis = function(e, i) {
          var r = this._lastDataByCoordSys, a = this._cbParamsList, o = !!r && r.length === e.length;
          return o && D(r, function(s, l) {
            var u = s.dataByAxis || [], h = e[l] || {}, c = h.dataByAxis || [];
            o = o && u.length === c.length, o && D(u, function(f, g) {
              var d = c[g] || {}, A = f.seriesDataIndices || [], p = d.seriesDataIndices || [];
              o = o && f.value === d.value && f.axisType === d.axisType && f.axisId === d.axisId && A.length === p.length, o && D(A, function(v, y) {
                var m = p[y];
                o = o && v.seriesIndex === m.seriesIndex && v.dataIndex === m.dataIndex;
              }), a && D(f.seriesDataIndices, function(v) {
                var y = v.seriesIndex, m = i[y], _ = a[y];
                m && _ && _.data !== m.data && (o = false);
              });
            });
          }), this._lastDataByCoordSys = e, this._cbParamsList = i, !!o;
        }, t.prototype._hide = function(e) {
          this._lastDataByCoordSys = null, e({ type: "hideTip", from: this.uid });
        }, t.prototype.dispose = function(e, i) {
          re.node || !i.getDom() || (Mv(this, "_updatePosition"), this._tooltipContent.dispose(), GR("itemTooltip", i));
        }, t.type = "tooltip", t;
      }(un);
      function xy(n, t, e) {
        var i = t.ecModel, r;
        e ? (r = new De(e, i, i), r = new De(t.option, r, i)) : r = t;
        for (var a = n.length - 1; a >= 0; a--) {
          var o = n[a];
          o && (o instanceof De && (o = o.get("tooltip", true)), ht(o) && (o = { formatter: o }), o && (r = new De(o, r, i)));
        }
        return r;
      }
      function uW(n, t) {
        return n.dispatchAction || ct(t.dispatchAction, t);
      }
      function Nkt(n, t, e, i, r, a, o) {
        var s = e.getSize(), l = s[0], u = s[1];
        return a != null && (n + l + a + 2 > i ? n -= l + a : n += a), o != null && (t + u + o > r ? t -= u + o : t += o), [n, t];
      }
      function Fkt(n, t, e, i, r) {
        var a = e.getSize(), o = a[0], s = a[1];
        return n = Math.min(n + o, i) - o, t = Math.min(t + s, r) - s, n = Math.max(n, 0), t = Math.max(t, 0), [n, t];
      }
      function kkt(n, t, e, i) {
        var r = e[0], a = e[1], o = Math.ceil(Math.SQRT2 * i) + 8, s = 0, l = 0, u = t.width, h = t.height;
        switch (n) {
          case "inside":
            s = t.x + u / 2 - r / 2, l = t.y + h / 2 - a / 2;
            break;
          case "top":
            s = t.x + u / 2 - r / 2, l = t.y - a - o;
            break;
          case "bottom":
            s = t.x + u / 2 - r / 2, l = t.y + h + o;
            break;
          case "left":
            s = t.x - r - o, l = t.y + h / 2 - a / 2;
            break;
          case "right":
            s = t.x + u + o, l = t.y + h / 2 - a / 2;
        }
        return [s, l];
      }
      function hW(n) {
        return n === "center" || n === "middle";
      }
      function Okt(n, t, e) {
        var i = IT(n).queryOptionMap, r = i.keys()[0];
        if (!(!r || r === "series")) {
          var a = nv(t, r, i.get(r), { useDefault: false, enableAll: false, enableNone: false }), o = a.models[0];
          if (o) {
            var s = e.getViewOfComponentModel(o), l;
            if (s.group.traverse(function(u) {
              var h = Nt(u).tooltipConfig;
              if (h && h.name === n.name) return l = u, true;
            }), l) return { componentMainType: r, componentIndex: o.componentIndex, el: l };
          }
        }
      }
      function Qkt(n) {
        Kt(Ey), n.registerComponentModel(Ekt), n.registerComponentView(Pkt), n.registerAction({ type: "showTip", event: "showTip", update: "tooltip:manuallyShowTip" }, bn), n.registerAction({ type: "hideTip", event: "hideTip", update: "tooltip:manuallyHideTip" }, bn);
      }
      var zkt = ["rect", "polygon", "keep", "clear"];
      function Gkt(n, t) {
        var e = ze(n ? n.brush : []);
        if (e.length) {
          var i = [];
          D(e, function(l) {
            var u = l.hasOwnProperty("toolbox") ? l.toolbox : [];
            u instanceof Array && (i = i.concat(u));
          });
          var r = n && n.toolbox;
          Z(r) && (r = r[0]), r || (r = { feature: {} }, n.toolbox = [r]);
          var a = r.feature || (r.feature = {}), o = a.brush || (a.brush = {}), s = o.type || (o.type = []);
          s.push.apply(s, i), Ukt(s), t && !s.length && s.push.apply(s, zkt);
        }
      }
      function Ukt(n) {
        var t = {};
        D(n, function(e) {
          t[e] = 1;
        }), n.length = 0, D(t, function(e, i) {
          n.push(i);
        });
      }
      var cW = D;
      function fW(n) {
        if (n) {
          for (var t in n) if (n.hasOwnProperty(t)) return true;
        }
      }
      function oL(n, t, e) {
        var i = {};
        return cW(t, function(a) {
          var o = i[a] = r();
          cW(n[a], function(s, l) {
            if (ni.isValidType(l)) {
              var u = { type: l, visual: s };
              e && e(u, a), o[l] = new ni(u), l === "opacity" && (u = Ct(u), u.type = "colorAlpha", o.__hidden.__alphaForOpacity = new ni(u));
            }
          });
        }), i;
        function r() {
          var a = function() {
          };
          a.prototype.__hidden = a.prototype;
          var o = new a();
          return o;
        }
      }
      function gW(n, t, e) {
        var i;
        D(e, function(r) {
          t.hasOwnProperty(r) && fW(t[r]) && (i = true);
        }), i && D(e, function(r) {
          t.hasOwnProperty(r) && fW(t[r]) ? n[r] = Ct(t[r]) : delete n[r];
        });
      }
      function Vkt(n, t, e, i, r, a) {
        var o = {};
        D(n, function(c) {
          var f = ni.prepareVisualTypes(t[c]);
          o[c] = f;
        });
        var s;
        function l(c) {
          return YB(e, s, c);
        }
        function u(c, f) {
          RU(e, s, c, f);
        }
        e.each(h);
        function h(c, f) {
          s = c;
          var g = e.getRawDataItem(s);
          if (!(g && g.visualMap === false)) for (var d = i.call(r, c), A = t[d], p = o[d], v = 0, y = p.length; v < y; v++) {
            var m = p[v];
            A[m] && A[m].applyVisual(c, l, u);
          }
        }
      }
      function jkt(n, t, e, i) {
        var r = {};
        return D(n, function(a) {
          var o = ni.prepareVisualTypes(t[a]);
          r[a] = o;
        }), { progress: function(o, s) {
          var l;
          i != null && (l = s.getDimensionIndex(i));
          function u(I) {
            return YB(s, c, I);
          }
          function h(I, E) {
            RU(s, c, I, E);
          }
          for (var c, f = s.getStore(); (c = o.next()) != null; ) {
            var g = s.getRawDataItem(c);
            if (!(g && g.visualMap === false)) for (var d = i != null ? f.get(l, c) : c, A = e(d), p = t[A], v = r[A], y = 0, m = v.length; y < m; y++) {
              var _ = v[y];
              p[_] && p[_].applyVisual(d, u, h);
            }
          }
        } };
      }
      function qkt(n) {
        var t = n.brushType, e = { point: function(i) {
          return dW[t].point(i, e, n);
        }, rect: function(i) {
          return dW[t].rect(i, e, n);
        } };
        return e;
      }
      var dW = { lineX: AW(0), lineY: AW(1), rect: { point: function(n, t, e) {
        return n && e.boundingRect.contain(n[0], n[1]);
      }, rect: function(n, t, e) {
        return n && e.boundingRect.intersect(n);
      } }, polygon: { point: function(n, t, e) {
        return n && e.boundingRect.contain(n[0], n[1]) && sc(e.range, n[0], n[1]);
      }, rect: function(n, t, e) {
        var i = e.range;
        if (!n || i.length <= 1) return false;
        var r = n.x, a = n.y, o = n.width, s = n.height, l = i[0];
        if (sc(i, r, a) || sc(i, r + o, a) || sc(i, r, a + s) || sc(i, r + o, a + s) || Wt.create(n).contain(l[0], l[1]) || yv(r, a, r + o, a, i) || yv(r, a, r, a + s, i) || yv(r + o, a, r + o, a + s, i) || yv(r, a + s, r + o, a + s, i)) return true;
      } } };
      function AW(n) {
        var t = ["x", "y"], e = ["width", "height"];
        return { point: function(i, r, a) {
          if (i) {
            var o = a.range, s = i[n];
            return wy(s, o);
          }
        }, rect: function(i, r, a) {
          if (i) {
            var o = a.range, s = [i[t[n]], i[t[n]] + i[e[n]]];
            return s[1] < s[0] && s.reverse(), wy(s[0], o) || wy(s[1], o) || wy(o[0], s) || wy(o[1], s);
          }
        } };
      }
      function wy(n, t) {
        return t[0] <= n && n <= t[1];
      }
      var pW = ["inBrush", "outOfBrush"], sL = "__ecBrushSelect", lL = "__ecInBrushSelectEvent";
      function vW(n) {
        n.eachComponent({ mainType: "brush" }, function(t) {
          var e = t.brushTargetManager = new tL(t.option, n);
          e.setInputRanges(t.areas, n);
        });
      }
      function Hkt(n, t, e) {
        var i = [], r, a;
        n.eachComponent({ mainType: "brush" }, function(o) {
          e && e.type === "takeGlobalCursor" && o.setBrushOption(e.key === "brush" ? e.brushOption : { brushType: false });
        }), vW(n), n.eachComponent({ mainType: "brush" }, function(o, s) {
          var l = { brushId: o.id, brushIndex: s, brushName: o.name, areas: Ct(o.areas), selected: [] };
          i.push(l);
          var u = o.option, h = u.brushLink, c = [], f = [], g = [], d = false;
          s || (r = u.throttleType, a = u.throttleDelay);
          var A = K(o.areas, function(I) {
            var E = $kt[I.brushType], x = wt({ boundingRect: E ? E(I) : void 0 }, I);
            return x.selectors = qkt(x), x;
          }), p = oL(o.option, pW, function(I) {
            I.mappingMethod = "fixed";
          });
          Z(h) && D(h, function(I) {
            c[I] = 1;
          });
          function v(I) {
            return h === "all" || !!c[I];
          }
          function y(I) {
            return !!I.length;
          }
          n.eachSeries(function(I, E) {
            var x = g[E] = [];
            I.subType === "parallel" ? m(I, E) : _(I, E, x);
          });
          function m(I, E) {
            var x = I.coordinateSystem;
            d = d || x.hasAxisBrushed(), v(E) && x.eachActiveState(I.getData(), function(w, C) {
              w === "active" && (f[C] = 1);
            });
          }
          function _(I, E, x) {
            if (!(!I.brushSelector || Xkt(o, E)) && (D(A, function(C) {
              o.brushTargetManager.controlSeries(C, I, n) && x.push(C), d = d || y(x);
            }), v(E) && y(x))) {
              var w = I.getData();
              w.each(function(C) {
                yW(I, x, w, C) && (f[C] = 1);
              });
            }
          }
          n.eachSeries(function(I, E) {
            var x = { seriesId: I.id, seriesIndex: E, seriesName: I.name, dataIndex: [] };
            l.selected.push(x);
            var w = g[E], C = I.getData(), S = v(E) ? function(b) {
              return f[b] ? (x.dataIndex.push(C.getRawIndex(b)), "inBrush") : "outOfBrush";
            } : function(b) {
              return yW(I, w, C, b) ? (x.dataIndex.push(C.getRawIndex(b)), "inBrush") : "outOfBrush";
            };
            (v(E) ? d : y(w)) && Vkt(pW, p, C, S);
          });
        }), Ykt(t, r, a, i, e);
      }
      function Ykt(n, t, e, i, r) {
        if (r) {
          var a = n.getZr();
          if (!a[lL]) {
            a[sL] || (a[sL] = Wkt);
            var o = ad(a, sL, e, t);
            o(n, i);
          }
        }
      }
      function Wkt(n, t) {
        if (!n.isDisposed()) {
          var e = n.getZr();
          e[lL] = true, n.dispatchAction({ type: "brushSelect", batch: t }), e[lL] = false;
        }
      }
      function yW(n, t, e, i) {
        for (var r = 0, a = t.length; r < a; r++) {
          var o = t[r];
          if (n.brushSelector(i, e, o.selectors, o)) return true;
        }
      }
      function Xkt(n, t) {
        var e = n.option.seriesIndex;
        return e != null && e !== "all" && (Z(e) ? $t(e, t) < 0 : t !== e);
      }
      var $kt = { rect: function(n) {
        return mW(n.range);
      }, polygon: function(n) {
        for (var t, e = n.range, i = 0, r = e.length; i < r; i++) {
          t = t || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
          var a = e[i];
          a[0] < t[0][0] && (t[0][0] = a[0]), a[0] > t[0][1] && (t[0][1] = a[0]), a[1] < t[1][0] && (t[1][0] = a[1]), a[1] > t[1][1] && (t[1][1] = a[1]);
        }
        return t && mW(t);
      } };
      function mW(n) {
        return new Wt(n[0][0], n[1][0], n[0][1] - n[0][0], n[1][1] - n[1][0]);
      }
      var Zkt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e, i) {
          this.ecModel = e, this.api = i, this.model, (this._brushController = new nR(i.getZr())).on("brush", ct(this._onBrush, this)).mount();
        }, t.prototype.render = function(e, i, r, a) {
          this.model = e, this._updateController(e, i, r, a);
        }, t.prototype.updateTransform = function(e, i, r, a) {
          vW(i), this._updateController(e, i, r, a);
        }, t.prototype.updateVisual = function(e, i, r, a) {
          this.updateTransform(e, i, r, a);
        }, t.prototype.updateView = function(e, i, r, a) {
          this._updateController(e, i, r, a);
        }, t.prototype._updateController = function(e, i, r, a) {
          (!a || a.$from !== e.id) && this._brushController.setPanels(e.brushTargetManager.makePanelOpts(r)).enableBrush(e.brushOption).updateCovers(e.areas.slice());
        }, t.prototype.dispose = function() {
          this._brushController.dispose();
        }, t.prototype._onBrush = function(e) {
          var i = this.model.id, r = this.model.brushTargetManager.setOutputRanges(e.areas, this.ecModel);
          (!e.isEnd || e.removeOnClick) && this.api.dispatchAction({ type: "brush", brushId: i, areas: Ct(r), $from: i }), e.isEnd && this.api.dispatchAction({ type: "brushEnd", brushId: i, areas: Ct(r), $from: i });
        }, t.type = "brush", t;
      }(un), Kkt = "#ddd", Jkt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.areas = [], e.brushOption = {}, e;
        }
        return t.prototype.optionUpdated = function(e, i) {
          var r = this.option;
          !i && gW(r, e, ["inBrush", "outOfBrush"]);
          var a = r.inBrush = r.inBrush || {};
          r.outOfBrush = r.outOfBrush || { color: Kkt }, a.hasOwnProperty("liftZ") || (a.liftZ = 5);
        }, t.prototype.setAreas = function(e) {
          It(Z(e)), D(e, function(i) {
            It(i.brushType, "Illegal areas");
          }), e && (this.areas = K(e, function(i) {
            return _W(this.option, i);
          }, this));
        }, t.prototype.setBrushOption = function(e) {
          this.brushOption = _W(this.option, e), this.brushType = this.brushOption.brushType;
        }, t.type = "brush", t.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], t.defaultOption = { seriesIndex: "all", brushType: "rect", brushMode: "single", transformable: true, brushStyle: { borderWidth: 1, color: "rgba(210,219,238,0.3)", borderColor: "#D2DBEE" }, throttleType: "fixRate", throttleDelay: 0, removeOnClick: true, z: 1e4 }, t;
      }(ae);
      function _W(n, t) {
        return Yt({ brushType: n.brushType, brushMode: n.brushMode, transformable: n.transformable, brushStyle: new De(n.brushStyle).getItemStyle(), removeOnClick: n.removeOnClick, z: n.z }, t, true);
      }
      var tOt = ["rect", "polygon", "lineX", "lineY", "keep", "clear"], eOt = function(n) {
        V(t, n);
        function t() {
          return n !== null && n.apply(this, arguments) || this;
        }
        return t.prototype.render = function(e, i, r) {
          var a, o, s;
          i.eachComponent({ mainType: "brush" }, function(l) {
            a = l.brushType, o = l.brushOption.brushMode || "single", s = s || !!l.areas.length;
          }), this._brushType = a, this._brushMode = o, D(e.get("type", true), function(l) {
            e.setIconStatus(l, (l === "keep" ? o === "multiple" : l === "clear" ? s : l === a) ? "emphasis" : "normal");
          });
        }, t.prototype.updateView = function(e, i, r) {
          this.render(e, i, r);
        }, t.prototype.getIcons = function() {
          var e = this.model, i = e.get("icon", true), r = {};
          return D(e.get("type", true), function(a) {
            i[a] && (r[a] = i[a]);
          }), r;
        }, t.prototype.onclick = function(e, i, r) {
          var a = this._brushType, o = this._brushMode;
          r === "clear" ? (i.dispatchAction({ type: "axisAreaSelect", intervals: [] }), i.dispatchAction({ type: "brush", command: "clear", areas: [] })) : i.dispatchAction({ type: "takeGlobalCursor", key: "brush", brushOption: { brushType: r === "keep" ? a : a === r ? false : r, brushMode: r === "keep" ? o === "multiple" ? "single" : "multiple" : o } });
        }, t.getDefaultOption = function(e) {
          var i = { show: true, type: tOt.slice(), icon: { rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13", polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2", lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4", lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4", keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z", clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2" }, title: e.getLocaleModel().get(["toolbox", "brush", "title"]) };
          return i;
        }, t;
      }(Ra);
      function nOt(n) {
        n.registerComponentView(Zkt), n.registerComponentModel(Jkt), n.registerPreprocessor(Gkt), n.registerVisual(n.PRIORITY.VISUAL.BRUSH, Hkt), n.registerAction({ type: "brush", event: "brush", update: "updateVisual" }, function(t, e) {
          e.eachComponent({ mainType: "brush", query: t }, function(i) {
            i.setAreas(t.areas);
          });
        }), n.registerAction({ type: "brushSelect", event: "brushSelected", update: "none" }, bn), n.registerAction({ type: "brushEnd", event: "brushEnd", update: "none" }, bn), Bd("brush", eOt);
      }
      var iOt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.layoutMode = { type: "box", ignoreSize: true }, e;
        }
        return t.type = "title", t.defaultOption = { z: 6, show: true, text: "", target: "blank", subtext: "", subtarget: "blank", left: 0, top: 0, backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, padding: 5, itemGap: 10, textStyle: { fontSize: 18, fontWeight: "bold", color: "#464646" }, subtextStyle: { fontSize: 12, color: "#6E7079" } }, t;
      }(ae), rOt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.render = function(e, i, r) {
          if (this.group.removeAll(), !!e.get("show")) {
            var a = this.group, o = e.getModel("textStyle"), s = e.getModel("subtextStyle"), l = e.get("textAlign"), u = kt(e.get("textBaseline"), e.get("textVerticalAlign")), h = new Ae({ style: Je(o, { text: e.get("text"), fill: o.getTextColor() }, { disableBox: true }), z2: 10 }), c = h.getBoundingRect(), f = e.get("subtext"), g = new Ae({ style: Je(s, { text: f, fill: s.getTextColor(), y: c.height + e.get("itemGap"), verticalAlign: "top" }, { disableBox: true }), z2: 10 }), d = e.get("link"), A = e.get("sublink"), p = e.get("triggerEvent", true);
            h.silent = !d && !p, g.silent = !A && !p, d && h.on("click", function() {
              tE(d, "_" + e.get("target"));
            }), A && g.on("click", function() {
              tE(A, "_" + e.get("subtarget"));
            }), Nt(h).eventData = Nt(g).eventData = p ? { componentType: "title", componentIndex: e.componentIndex } : null, a.add(h), f && a.add(g);
            var v = a.getBoundingRect(), y = e.getBoxLayoutParams();
            y.width = v.width, y.height = v.height;
            var m = Yn(y, { width: r.getWidth(), height: r.getHeight() }, e.get("padding"));
            l || (l = e.get("left") || e.get("right"), l === "middle" && (l = "center"), l === "right" ? m.x += m.width : l === "center" && (m.x += m.width / 2)), u || (u = e.get("top") || e.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? m.y += m.height : u === "middle" && (m.y += m.height / 2), u = u || "top"), a.x = m.x, a.y = m.y, a.markRedraw();
            var _ = { align: l, verticalAlign: u };
            h.setStyle(_), g.setStyle(_), v = a.getBoundingRect();
            var I = m.margin, E = e.getItemStyle(["color", "opacity"]);
            E.fill = e.get("backgroundColor");
            var x = new fe({ shape: { x: v.x - I[3], y: v.y - I[0], width: v.width + I[1] + I[3], height: v.height + I[0] + I[2], r: e.get("borderRadius") }, style: E, subPixelOptimize: true, silent: true });
            a.add(x);
          }
        }, t.type = "title", t;
      }(un);
      function aOt(n) {
        n.registerComponentModel(iOt), n.registerComponentView(rOt);
      }
      var EW = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.layoutMode = "box", e;
        }
        return t.prototype.init = function(e, i, r) {
          this.mergeDefaultAndTheme(e, r), this._initData();
        }, t.prototype.mergeOption = function(e) {
          n.prototype.mergeOption.apply(this, arguments), this._initData();
        }, t.prototype.setCurrentIndex = function(e) {
          e == null && (e = this.option.currentIndex);
          var i = this._data.count();
          this.option.loop ? e = (e % i + i) % i : (e >= i && (e = i - 1), e < 0 && (e = 0)), this.option.currentIndex = e;
        }, t.prototype.getCurrentIndex = function() {
          return this.option.currentIndex;
        }, t.prototype.isIndexMax = function() {
          return this.getCurrentIndex() >= this._data.count() - 1;
        }, t.prototype.setPlayState = function(e) {
          this.option.autoPlay = !!e;
        }, t.prototype.getPlayState = function() {
          return !!this.option.autoPlay;
        }, t.prototype._initData = function() {
          var e = this.option, i = e.data || [], r = e.axisType, a = this._names = [], o;
          r === "category" ? (o = [], D(i, function(u, h) {
            var c = Hn(Pg(u), ""), f;
            Et(u) ? (f = Ct(u), f.value = h) : f = h, o.push(f), a.push(c);
          })) : o = i;
          var s = { category: "ordinal", time: "time", value: "number" }[r] || "number", l = this._data = new er([{ name: "value", type: s }], this);
          l.initData(o, a);
        }, t.prototype.getData = function() {
          return this._data;
        }, t.prototype.getCategories = function() {
          if (this.get("axisType") === "category") return this._names.slice();
        }, t.type = "timeline", t.defaultOption = { z: 4, show: true, axisType: "time", realtime: true, left: "20%", top: null, right: "20%", bottom: 0, width: null, height: 40, padding: 5, controlPosition: "left", autoPlay: false, rewind: false, loop: true, playInterval: 2e3, currentIndex: 0, itemStyle: {}, label: { color: "#000" }, data: [] }, t;
      }(ae), IW = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "timeline.slider", t.defaultOption = cu(EW.defaultOption, { backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, orient: "horizontal", inverse: false, tooltip: { trigger: "item" }, symbol: "circle", symbolSize: 12, lineStyle: { show: true, width: 2, color: "#DAE1F5" }, label: { position: "auto", show: true, interval: "auto", rotate: 0, color: "#A4B1D7" }, itemStyle: { color: "#A4B1D7", borderWidth: 1 }, checkpointStyle: { symbol: "circle", symbolSize: 15, color: "#316bf3", borderColor: "#fff", borderWidth: 2, shadowBlur: 2, shadowOffsetX: 1, shadowOffsetY: 1, shadowColor: "rgba(0, 0, 0, 0.3)", animation: true, animationDuration: 300, animationEasing: "quinticInOut" }, controlStyle: { show: true, showPlayBtn: true, showPrevBtn: true, showNextBtn: true, itemSize: 24, itemGap: 12, position: "left", playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z", stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z", nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z", prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z", prevBtnSize: 18, nextBtnSize: 18, color: "#A4B1D7", borderColor: "#A4B1D7", borderWidth: 1 }, emphasis: { label: { show: true, color: "#6f778d" }, itemStyle: { color: "#316BF3" }, controlStyle: { color: "#316BF3", borderColor: "#316BF3", borderWidth: 2 } }, progress: { lineStyle: { color: "#316BF3" }, itemStyle: { color: "#316BF3" }, label: { color: "#6f778d" } }, data: [] }), t;
      }(EW);
      kn(IW, oE.prototype);
      var oOt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "timeline", t;
      }(un), sOt = function(n) {
        V(t, n);
        function t(e, i, r, a) {
          var o = n.call(this, e, i, r) || this;
          return o.type = a || "value", o;
        }
        return t.prototype.getLabelModel = function() {
          return this.model.getModel("label");
        }, t.prototype.isHorizontal = function() {
          return this.model.get("orient") === "horizontal";
        }, t;
      }(ao), uL = Math.PI, xW = ce(), lOt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function(e, i) {
          this.api = i;
        }, t.prototype.render = function(e, i, r) {
          if (this.model = e, this.api = r, this.ecModel = i, this.group.removeAll(), e.get("show", true)) {
            var a = this._layout(e, r), o = this._createGroup("_mainGroup"), s = this._createGroup("_labelGroup"), l = this._axis = this._createAxis(a, e);
            e.formatTooltip = function(u) {
              var h = l.scale.getLabel({ value: u });
              return ti("nameValue", { noName: true, value: h });
            }, D(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(u) {
              this["_render" + u](a, o, l, e);
            }, this), this._renderAxisLabel(a, s, l, e), this._position(a, e);
          }
          this._doPlayStop(), this._updateTicksStatus();
        }, t.prototype.remove = function() {
          this._clearTimer(), this.group.removeAll();
        }, t.prototype.dispose = function() {
          this._clearTimer();
        }, t.prototype._layout = function(e, i) {
          var r = e.get(["label", "position"]), a = e.get("orient"), o = hOt(e, i), s;
          r == null || r === "auto" ? s = a === "horizontal" ? o.y + o.height / 2 < i.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < i.getWidth() / 2 ? "+" : "-" : ht(r) ? s = { horizontal: { top: "-", bottom: "+" }, vertical: { left: "-", right: "+" } }[a][r] : s = r;
          var l = { horizontal: "center", vertical: s >= 0 || s === "+" ? "left" : "right" }, u = { horizontal: s >= 0 || s === "+" ? "top" : "bottom", vertical: "middle" }, h = { horizontal: 0, vertical: uL / 2 }, c = a === "vertical" ? o.height : o.width, f = e.getModel("controlStyle"), g = f.get("show", true), d = g ? f.get("itemSize") : 0, A = g ? f.get("itemGap") : 0, p = d + A, v = e.get(["label", "rotate"]) || 0;
          v = v * uL / 180;
          var y, m, _, I = f.get("position", true), E = g && f.get("showPlayBtn", true), x = g && f.get("showPrevBtn", true), w = g && f.get("showNextBtn", true), C = 0, S = c;
          I === "left" || I === "bottom" ? (E && (y = [0, 0], C += p), x && (m = [C, 0], C += p), w && (_ = [S - d, 0], S -= p)) : (E && (y = [S - d, 0], S -= p), x && (m = [0, 0], C += p), w && (_ = [S - d, 0], S -= p));
          var b = [C, S];
          return e.get("inverse") && b.reverse(), { viewRect: o, mainLength: c, orient: a, rotation: h[a], labelRotation: v, labelPosOpt: s, labelAlign: e.get(["label", "align"]) || l[a], labelBaseline: e.get(["label", "verticalAlign"]) || e.get(["label", "baseline"]) || u[a], playPosition: y, prevBtnPosition: m, nextBtnPosition: _, axisExtent: b, controlSize: d, controlGap: A };
        }, t.prototype._position = function(e, i) {
          var r = this._mainGroup, a = this._labelGroup, o = e.viewRect;
          if (e.orient === "vertical") {
            var s = Vr(), l = o.x, u = o.y + o.height;
            Go(s, s, [-l, -u]), _h(s, s, -uL / 2), Go(s, s, [l, u]), o = o.clone(), o.applyTransform(s);
          }
          var h = y(o), c = y(r.getBoundingRect()), f = y(a.getBoundingRect()), g = [r.x, r.y], d = [a.x, a.y];
          d[0] = g[0] = h[0][0];
          var A = e.labelPosOpt;
          if (A == null || ht(A)) {
            var p = A === "+" ? 0 : 1;
            m(g, c, h, 1, p), m(d, f, h, 1, 1 - p);
          } else {
            var p = A >= 0 ? 0 : 1;
            m(g, c, h, 1, p), d[1] = g[1] + A;
          }
          r.setPosition(g), a.setPosition(d), r.rotation = a.rotation = e.rotation, v(r), v(a);
          function v(_) {
            _.originX = h[0][0] - _.x, _.originY = h[1][0] - _.y;
          }
          function y(_) {
            return [[_.x, _.x + _.width], [_.y, _.y + _.height]];
          }
          function m(_, I, E, x, w) {
            _[x] += E[x][w] - I[x][w];
          }
        }, t.prototype._createAxis = function(e, i) {
          var r = i.getData(), a = i.get("axisType"), o = uOt(i, a);
          o.getTicks = function() {
            return r.mapArray(["value"], function(u) {
              return { value: u };
            });
          };
          var s = r.getDataExtent("value");
          o.setExtent(s[0], s[1]), o.calcNiceTicks();
          var l = new sOt("value", o, e.axisExtent, a);
          return l.model = i, l;
        }, t.prototype._createGroup = function(e) {
          var i = this[e] = new Dt();
          return this.group.add(i), i;
        }, t.prototype._renderAxisLine = function(e, i, r, a) {
          var o = r.getExtent();
          if (a.get(["lineStyle", "show"])) {
            var s = new Kn({ shape: { x1: o[0], y1: 0, x2: o[1], y2: 0 }, style: X({ lineCap: "round" }, a.getModel("lineStyle").getLineStyle()), silent: true, z2: 1 });
            i.add(s);
            var l = this._progressLine = new Kn({ shape: { x1: o[0], x2: this._currentPointer ? this._currentPointer.x : o[0], y1: 0, y2: 0 }, style: wt({ lineCap: "round", lineWidth: s.style.lineWidth }, a.getModel(["progress", "lineStyle"]).getLineStyle()), silent: true, z2: 1 });
            i.add(l);
          }
        }, t.prototype._renderAxisTick = function(e, i, r, a) {
          var o = this, s = a.getData(), l = r.scale.getTicks();
          this._tickSymbols = [], D(l, function(u) {
            var h = r.dataToCoord(u.value), c = s.getItemModel(u.value), f = c.getModel("itemStyle"), g = c.getModel(["emphasis", "itemStyle"]), d = c.getModel(["progress", "itemStyle"]), A = { x: h, y: 0, onclick: ct(o._changeTimeline, o, u.value) }, p = wW(c, f, i, A);
            p.ensureState("emphasis").style = g.getItemStyle(), p.ensureState("progress").style = d.getItemStyle(), Uh(p);
            var v = Nt(p);
            c.get("tooltip") ? (v.dataIndex = u.value, v.dataModel = a) : v.dataIndex = v.dataModel = null, o._tickSymbols.push(p);
          });
        }, t.prototype._renderAxisLabel = function(e, i, r, a) {
          var o = this, s = r.getLabelModel();
          if (s.get("show")) {
            var l = a.getData(), u = r.getViewLabels();
            this._tickLabels = [], D(u, function(h) {
              var c = h.tickValue, f = l.getItemModel(c), g = f.getModel("label"), d = f.getModel(["emphasis", "label"]), A = f.getModel(["progress", "label"]), p = r.dataToCoord(h.tickValue), v = new Ae({ x: p, y: 0, rotation: e.labelRotation - e.rotation, onclick: ct(o._changeTimeline, o, c), silent: false, style: Je(g, { text: h.formattedLabel, align: e.labelAlign, verticalAlign: e.labelBaseline }) });
              v.ensureState("emphasis").style = Je(d), v.ensureState("progress").style = Je(A), i.add(v), Uh(v), xW(v).dataIndex = c, o._tickLabels.push(v);
            });
          }
        }, t.prototype._renderControl = function(e, i, r, a) {
          var o = e.controlSize, s = e.rotation, l = a.getModel("controlStyle").getItemStyle(), u = a.getModel(["emphasis", "controlStyle"]).getItemStyle(), h = a.getPlayState(), c = a.get("inverse", true);
          f(e.nextBtnPosition, "next", ct(this._changeTimeline, this, c ? "-" : "+")), f(e.prevBtnPosition, "prev", ct(this._changeTimeline, this, c ? "+" : "-")), f(e.playPosition, h ? "stop" : "play", ct(this._handlePlayClick, this, !h), true);
          function f(g, d, A, p) {
            if (g) {
              var v = Za(kt(a.get(["controlStyle", d + "BtnSize"]), o), o), y = [0, -v / 2, v, v], m = cOt(a, d + "Icon", y, { x: g[0], y: g[1], originX: o / 2, originY: 0, rotation: p ? -s : 0, rectHover: true, style: l, onclick: A });
              m.ensureState("emphasis").style = u, i.add(m), Uh(m);
            }
          }
        }, t.prototype._renderCurrentPointer = function(e, i, r, a) {
          var o = a.getData(), s = a.getCurrentIndex(), l = o.getItemModel(s).getModel("checkpointStyle"), u = this, h = { onCreate: function(c) {
            c.draggable = true, c.drift = ct(u._handlePointerDrag, u), c.ondragend = ct(u._handlePointerDragend, u), CW(c, u._progressLine, s, r, a, true);
          }, onUpdate: function(c) {
            CW(c, u._progressLine, s, r, a);
          } };
          this._currentPointer = wW(l, l, this._mainGroup, {}, this._currentPointer, h);
        }, t.prototype._handlePlayClick = function(e) {
          this._clearTimer(), this.api.dispatchAction({ type: "timelinePlayChange", playState: e, from: this.uid });
        }, t.prototype._handlePointerDrag = function(e, i, r) {
          this._clearTimer(), this._pointerChangeTimeline([r.offsetX, r.offsetY]);
        }, t.prototype._handlePointerDragend = function(e) {
          this._pointerChangeTimeline([e.offsetX, e.offsetY], true);
        }, t.prototype._pointerChangeTimeline = function(e, i) {
          var r = this._toAxisCoord(e)[0], a = this._axis, o = va(a.getExtent().slice());
          r > o[1] && (r = o[1]), r < o[0] && (r = o[0]), this._currentPointer.x = r, this._currentPointer.markRedraw();
          var s = this._progressLine;
          s && (s.shape.x2 = r, s.dirty());
          var l = this._findNearestTick(r), u = this.model;
          (i || l !== u.getCurrentIndex() && u.get("realtime")) && this._changeTimeline(l);
        }, t.prototype._doPlayStop = function() {
          var e = this;
          this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
            var i = e.model;
            e._changeTimeline(i.getCurrentIndex() + (i.get("rewind", true) ? -1 : 1));
          }, this.model.get("playInterval")));
        }, t.prototype._toAxisCoord = function(e) {
          var i = this._mainGroup.getLocalTransform();
          return no(e, i, true);
        }, t.prototype._findNearestTick = function(e) {
          var i = this.model.getData(), r = 1 / 0, a, o = this._axis;
          return i.each(["value"], function(s, l) {
            var u = o.dataToCoord(s), h = Math.abs(u - e);
            h < r && (r = h, a = l);
          }), a;
        }, t.prototype._clearTimer = function() {
          this._timer && (clearTimeout(this._timer), this._timer = null);
        }, t.prototype._changeTimeline = function(e) {
          var i = this.model.getCurrentIndex();
          e === "+" ? e = i + 1 : e === "-" && (e = i - 1), this.api.dispatchAction({ type: "timelineChange", currentIndex: e, from: this.uid });
        }, t.prototype._updateTicksStatus = function() {
          var e = this.model.getCurrentIndex(), i = this._tickSymbols, r = this._tickLabels;
          if (i) for (var a = 0; a < i.length; a++) i && i[a] && i[a].toggleState("progress", a < e);
          if (r) for (var a = 0; a < r.length; a++) r && r[a] && r[a].toggleState("progress", xW(r[a]).dataIndex <= e);
        }, t.type = "timeline.slider", t;
      }(oOt);
      function uOt(n, t) {
        if (t = t || n.get("type"), t) switch (t) {
          case "category":
            return new DE({ ordinalMeta: n.getCategories(), extent: [1 / 0, -1 / 0] });
          case "time":
            return new IM({ locale: n.ecModel.getLocaleModel(), useUTC: n.ecModel.get("useUTC") });
          default:
            return new el();
        }
      }
      function hOt(n, t) {
        return Yn(n.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() }, n.get("padding"));
      }
      function cOt(n, t, e, i) {
        var r = i.style, a = vv(n.get(["controlStyle", t]), i || {}, new Wt(e[0], e[1], e[2], e[3]));
        return r && a.setStyle(r), a;
      }
      function wW(n, t, e, i, r, a) {
        var o = t.get("color");
        if (r) r.setColor(o), e.add(r), a && a.onUpdate(r);
        else {
          var s = n.get("symbol");
          r = Un(s, -1, -1, 2, 2, o), r.setStyle("strokeNoScale", true), e.add(r), a && a.onCreate(r);
        }
        var l = t.getItemStyle(["color"]);
        r.setStyle(l), i = Yt({ rectHover: true, z2: 100 }, i, true);
        var u = sd(n.get("symbolSize"));
        i.scaleX = u[0] / 2, i.scaleY = u[1] / 2;
        var h = nc(n.get("symbolOffset"), u);
        h && (i.x = (i.x || 0) + h[0], i.y = (i.y || 0) + h[1]);
        var c = n.get("symbolRotate");
        return i.rotation = (c || 0) * Math.PI / 180 || 0, r.attr(i), r.updateTransform(), r;
      }
      function CW(n, t, e, i, r, a) {
        if (!n.dragging) {
          var o = r.getModel("checkpointStyle"), s = i.dataToCoord(r.getData().get("value", e));
          if (a || !o.get("animation", true)) n.attr({ x: s, y: 0 }), t && t.attr({ shape: { x2: s } });
          else {
            var l = { duration: o.get("animationDuration", true), easing: o.get("animationEasing", true) };
            n.stopAnimation(null, true), n.animateTo({ x: s, y: 0 }, l), t && t.animateTo({ shape: { x2: s } }, l);
          }
        }
      }
      function fOt(n) {
        n.registerAction({ type: "timelineChange", event: "timelineChanged", update: "prepareAndUpdate" }, function(t, e, i) {
          var r = e.getComponent("timeline");
          return r && t.currentIndex != null && (r.setCurrentIndex(t.currentIndex), !r.get("loop", true) && r.isIndexMax() && r.getPlayState() && (r.setPlayState(false), i.dispatchAction({ type: "timelinePlayChange", playState: false, from: t.from }))), e.resetOption("timeline", { replaceMerge: r.get("replaceMerge", true) }), wt({ currentIndex: r.option.currentIndex }, t);
        }), n.registerAction({ type: "timelinePlayChange", event: "timelinePlayChanged", update: "update" }, function(t, e) {
          var i = e.getComponent("timeline");
          i && t.playState != null && i.setPlayState(t.playState);
        });
      }
      function gOt(n) {
        var t = n && n.timeline;
        Z(t) || (t = t ? [t] : []), D(t, function(e) {
          e && dOt(e);
        });
      }
      function dOt(n) {
        var t = n.type, e = { number: "value", time: "time" };
        if (e[t] && (n.axisType = e[t], delete n.type), SW(n), bc(n, "controlPosition")) {
          var i = n.controlStyle || (n.controlStyle = {});
          bc(i, "position") || (i.position = n.controlPosition), i.position === "none" && !bc(i, "show") && (i.show = false, delete i.position), delete n.controlPosition;
        }
        D(n.data || [], function(r) {
          Et(r) && !Z(r) && (!bc(r, "value") && bc(r, "name") && (r.value = r.name), SW(r));
        });
      }
      function SW(n) {
        var t = n.itemStyle || (n.itemStyle = {}), e = t.emphasis || (t.emphasis = {}), i = n.label || n.label || {}, r = i.normal || (i.normal = {}), a = { normal: 1, emphasis: 1 };
        D(i, function(o, s) {
          !a[s] && !bc(r, s) && (r[s] = o);
        }), e.label && !bc(i, "emphasis") && (i.emphasis = e.label, delete e.label);
      }
      function bc(n, t) {
        return n.hasOwnProperty(t);
      }
      function AOt(n) {
        n.registerComponentModel(IW), n.registerComponentView(lOt), n.registerSubTypeDefaulter("timeline", function() {
          return "slider";
        }), fOt(n), n.registerPreprocessor(gOt);
      }
      function hL(n, t) {
        if (!n) return false;
        for (var e = Z(n) ? n : [n], i = 0; i < e.length; i++) if (e[i] && e[i][t]) return true;
        return false;
      }
      function RI(n) {
        Th(n, "label", ["show"]);
      }
      var LI = ce(), sl = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.createdBySelf = false, e;
        }
        return t.prototype.init = function(e, i, r) {
          if (this.type === "marker") throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
          this.mergeDefaultAndTheme(e, r), this._mergeOption(e, r, false, true);
        }, t.prototype.isAnimationEnabled = function() {
          if (re.node) return false;
          var e = this.__hostSeries;
          return this.getShallow("animation") && e && e.isAnimationEnabled();
        }, t.prototype.mergeOption = function(e, i) {
          this._mergeOption(e, i, false, false);
        }, t.prototype._mergeOption = function(e, i, r, a) {
          var o = this.mainType;
          r || i.eachSeries(function(s) {
            var l = s.get(this.mainType, true), u = LI(s)[o];
            if (!l || !l.data) {
              LI(s)[o] = null;
              return;
            }
            u ? u._mergeOption(l, i, true) : (a && RI(l), D(l.data, function(h) {
              h instanceof Array ? (RI(h[0]), RI(h[1])) : RI(h);
            }), u = this.createMarkerModelFromSeries(l, this, i), X(u, { mainType: this.mainType, seriesIndex: s.seriesIndex, name: s.name, createdBySelf: true }), u.__hostSeries = s), LI(s)[o] = u;
          }, this);
        }, t.prototype.formatTooltip = function(e, i, r) {
          var a = this.getData(), o = this.getRawValue(e), s = a.getName(e);
          return ti("section", { header: this.name, blocks: [ti("nameValue", { name: s, value: o, noName: !s, noValue: o == null })] });
        }, t.prototype.getData = function() {
          return this._data;
        }, t.prototype.setData = function(e) {
          this._data = e;
        }, t.prototype.getDataParams = function(e, i) {
          var r = oE.prototype.getDataParams.call(this, e, i), a = this.__hostSeries;
          return a && (r.seriesId = a.id, r.seriesName = a.name, r.seriesType = a.subType), r;
        }, t.getMarkerModelFromSeries = function(e, i) {
          return LI(e)[i];
        }, t.type = "marker", t.dependencies = ["series", "grid", "polar", "geo"], t;
      }(ae);
      kn(sl, oE.prototype);
      var pOt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.createMarkerModelFromSeries = function(e, i, r) {
          return new t(e, i, r);
        }, t.type = "markPoint", t.defaultOption = { z: 5, symbol: "pin", symbolSize: 50, tooltip: { trigger: "item" }, label: { show: true, position: "inside" }, itemStyle: { borderWidth: 2 }, emphasis: { label: { show: true } } }, t;
      }(sl);
      function cL(n) {
        return !(isNaN(parseFloat(n.x)) && isNaN(parseFloat(n.y)));
      }
      function vOt(n) {
        return !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
      }
      function PI(n, t, e, i, r, a) {
        var o = [], s = yu(t, i), l = s ? t.getCalculationInfo("stackResultDimension") : i, u = gL(t, l, n), h = t.indicesOfNearest(l, u)[0];
        o[r] = t.get(e, h), o[a] = t.get(l, h);
        var c = t.get(i, h), f = jo(t.get(i, h));
        return f = Math.min(f, 20), f >= 0 && (o[a] = +o[a].toFixed(f)), [o, c];
      }
      var fL = { min: Gt(PI, "min"), max: Gt(PI, "max"), average: Gt(PI, "average"), median: Gt(PI, "median") };
      function Cy(n, t) {
        if (t) {
          var e = n.getData(), i = n.coordinateSystem, r = i && i.dimensions;
          if (!vOt(t) && !Z(t.coord) && Z(r)) {
            var a = bW(t, e, i, n);
            if (t = Ct(t), t.type && fL[t.type] && a.baseAxis && a.valueAxis) {
              var o = $t(r, a.baseAxis.dim), s = $t(r, a.valueAxis.dim), l = fL[t.type](e, a.baseDataDim, a.valueDataDim, o, s);
              t.coord = l[0], t.value = l[1];
            } else t.coord = [t.xAxis != null ? t.xAxis : t.radiusAxis, t.yAxis != null ? t.yAxis : t.angleAxis];
          }
          if (t.coord == null || !Z(r)) t.coord = [];
          else for (var u = t.coord, h = 0; h < 2; h++) fL[u[h]] && (u[h] = gL(e, e.mapDimension(r[h]), u[h]));
          return t;
        }
      }
      function bW(n, t, e, i) {
        var r = {};
        return n.valueIndex != null || n.valueDim != null ? (r.valueDataDim = n.valueIndex != null ? t.getDimension(n.valueIndex) : n.valueDim, r.valueAxis = e.getAxis(yOt(i, r.valueDataDim)), r.baseAxis = e.getOtherAxis(r.valueAxis), r.baseDataDim = t.mapDimension(r.baseAxis.dim)) : (r.baseAxis = i.getBaseAxis(), r.valueAxis = e.getOtherAxis(r.baseAxis), r.baseDataDim = t.mapDimension(r.baseAxis.dim), r.valueDataDim = t.mapDimension(r.valueAxis.dim)), r;
      }
      function yOt(n, t) {
        var e = n.getData().getDimensionInfo(t);
        return e && e.coordDim;
      }
      function Sy(n, t) {
        return n && n.containData && t.coord && !cL(t) ? n.containData(t.coord) : true;
      }
      function mOt(n, t, e) {
        return n && n.containZone && t.coord && e.coord && !cL(t) && !cL(e) ? n.containZone(t.coord, e.coord) : true;
      }
      function TW(n, t) {
        return n ? function(e, i, r, a) {
          var o = a < 2 ? e.coord && e.coord[a] : e.value;
          return du(o, t[a]);
        } : function(e, i, r, a) {
          return du(e.value, t[a]);
        };
      }
      function gL(n, t, e) {
        if (e === "average") {
          var i = 0, r = 0;
          return n.each(t, function(a, o) {
            isNaN(a) || (i += a, r++);
          }), i / r;
        } else return e === "median" ? n.getMedian(t) : n.getDataExtent(t)[e === "max" ? 1 : 0];
      }
      var dL = ce(), AL = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.init = function() {
          this.markerGroupMap = dt();
        }, t.prototype.render = function(e, i, r) {
          var a = this, o = this.markerGroupMap;
          o.each(function(s) {
            dL(s).keep = false;
          }), i.eachSeries(function(s) {
            var l = sl.getMarkerModelFromSeries(s, a.type);
            l && a.renderSeries(s, l, i, r);
          }), o.each(function(s) {
            !dL(s).keep && a.group.remove(s.group);
          });
        }, t.prototype.markKeep = function(e) {
          dL(e).keep = true;
        }, t.prototype.toggleBlurSeries = function(e, i) {
          var r = this;
          D(e, function(a) {
            var o = sl.getMarkerModelFromSeries(a, r.type);
            if (o) {
              var s = o.getData();
              s.eachItemGraphicEl(function(l) {
                l && (i ? a8(l) : YT(l));
              });
            }
          });
        }, t.type = "marker", t;
      }(un);
      function BW(n, t, e) {
        var i = t.coordinateSystem;
        n.each(function(r) {
          var a = n.getItemModel(r), o, s = st(a.get("x"), e.getWidth()), l = st(a.get("y"), e.getHeight());
          if (!isNaN(s) && !isNaN(l)) o = [s, l];
          else if (t.getMarkerPosition) o = t.getMarkerPosition(n.getValues(n.dimensions, r));
          else if (i) {
            var u = n.get(i.dimensions[0], r), h = n.get(i.dimensions[1], r);
            o = i.dataToPoint([u, h]);
          }
          isNaN(s) || (o[0] = s), isNaN(l) || (o[1] = l), n.setItemLayout(r, o);
        });
      }
      var _Ot = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.updateTransform = function(e, i, r) {
          i.eachSeries(function(a) {
            var o = sl.getMarkerModelFromSeries(a, "markPoint");
            o && (BW(o.getData(), a, r), this.markerGroupMap.get(a.id).updateLayout());
          }, this);
        }, t.prototype.renderSeries = function(e, i, r, a) {
          var o = e.coordinateSystem, s = e.id, l = e.getData(), u = this.markerGroupMap, h = u.get(s) || u.set(s, new Zv()), c = EOt(o, e, i);
          i.setData(c), BW(i.getData(), e, a), c.each(function(f) {
            var g = c.getItemModel(f), d = g.getShallow("symbol"), A = g.getShallow("symbolSize"), p = g.getShallow("symbolRotate"), v = g.getShallow("symbolOffset"), y = g.getShallow("symbolKeepAspect");
            if (yt(d) || yt(A) || yt(p) || yt(v)) {
              var m = i.getRawValue(f), _ = i.getDataParams(f);
              yt(d) && (d = d(m, _)), yt(A) && (A = A(m, _)), yt(p) && (p = p(m, _)), yt(v) && (v = v(m, _));
            }
            var I = g.getModel("itemStyle").getItemStyle(), E = Lv(l, "color");
            I.fill || (I.fill = E), c.setItemVisual(f, { symbol: d, symbolSize: A, symbolRotate: p, symbolOffset: v, symbolKeepAspect: y, style: I });
          }), h.updateData(c), this.group.add(h.group), c.eachItemGraphicEl(function(f) {
            f.traverse(function(g) {
              Nt(g).dataModel = i;
            });
          }), this.markKeep(h), h.group.silent = i.get("silent") || e.get("silent");
        }, t.type = "markPoint", t;
      }(AL);
      function EOt(n, t, e) {
        var i;
        n ? i = K(n && n.dimensions, function(s) {
          var l = t.getData().getDimensionInfo(t.getData().mapDimension(s)) || {};
          return X(X({}, l), { name: s, ordinalMeta: null });
        }) : i = [{ name: "value", type: "float" }];
        var r = new er(i, e), a = K(e.get("data"), Gt(Cy, t));
        n && (a = Fe(a, Gt(Sy, n)));
        var o = TW(!!n, i);
        return r.initData(a, null, o), r;
      }
      function IOt(n) {
        n.registerComponentModel(pOt), n.registerComponentView(_Ot), n.registerPreprocessor(function(t) {
          hL(t.series, "markPoint") && (t.markPoint = t.markPoint || {});
        });
      }
      var xOt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.createMarkerModelFromSeries = function(e, i, r) {
          return new t(e, i, r);
        }, t.type = "markLine", t.defaultOption = { z: 5, symbol: ["circle", "arrow"], symbolSize: [8, 16], symbolOffset: 0, precision: 2, tooltip: { trigger: "item" }, label: { show: true, position: "end", distance: 5 }, lineStyle: { type: "dashed" }, emphasis: { label: { show: true }, lineStyle: { width: 3 } }, animationEasing: "linear" }, t;
      }(sl), NI = ce(), wOt = function(n, t, e, i) {
        var r = n.getData(), a;
        if (Z(i)) a = i;
        else {
          var o = i.type;
          if (o === "min" || o === "max" || o === "average" || o === "median" || i.xAxis != null || i.yAxis != null) {
            var s = void 0, l = void 0;
            if (i.yAxis != null || i.xAxis != null) s = t.getAxis(i.yAxis != null ? "y" : "x"), l = On(i.yAxis, i.xAxis);
            else {
              var u = bW(i, r, t, n);
              s = u.valueAxis;
              var h = RV(r, u.valueDataDim);
              l = gL(r, h, o);
            }
            var c = s.dim === "x" ? 0 : 1, f = 1 - c, g = Ct(i), d = { coord: [] };
            g.type = null, g.coord = [], g.coord[f] = -1 / 0, d.coord[f] = 1 / 0;
            var A = e.get("precision");
            A >= 0 && ye(l) && (l = +l.toFixed(Math.min(A, 20))), g.coord[c] = d.coord[c] = l, a = [g, d, { type: o, valueIndex: i.valueIndex, value: l }];
          } else Ya("Invalid markLine data."), a = [];
        }
        var p = [Cy(n, a[0]), Cy(n, a[1]), X({}, a[2])];
        return p[2].type = p[2].type || null, Yt(p[2], p[0]), Yt(p[2], p[1]), p;
      };
      function FI(n) {
        return !isNaN(n) && !isFinite(n);
      }
      function MW(n, t, e, i) {
        var r = 1 - n, a = i.dimensions[n];
        return FI(t[r]) && FI(e[r]) && t[n] === e[n] && i.getAxis(a).containData(t[n]);
      }
      function COt(n, t) {
        if (n.type === "cartesian2d") {
          var e = t[0].coord, i = t[1].coord;
          if (e && i && (MW(1, e, i, n) || MW(0, e, i, n))) return true;
        }
        return Sy(n, t[0]) && Sy(n, t[1]);
      }
      function pL(n, t, e, i, r) {
        var a = i.coordinateSystem, o = n.getItemModel(t), s, l = st(o.get("x"), r.getWidth()), u = st(o.get("y"), r.getHeight());
        if (!isNaN(l) && !isNaN(u)) s = [l, u];
        else {
          if (i.getMarkerPosition) s = i.getMarkerPosition(n.getValues(n.dimensions, t));
          else {
            var h = a.dimensions, c = n.get(h[0], t), f = n.get(h[1], t);
            s = a.dataToPoint([c, f]);
          }
          if (dc(a, "cartesian2d")) {
            var g = a.getAxis("x"), d = a.getAxis("y"), h = a.dimensions;
            FI(n.get(h[0], t)) ? s[0] = g.toGlobalCoord(g.getExtent()[e ? 0 : 1]) : FI(n.get(h[1], t)) && (s[1] = d.toGlobalCoord(d.getExtent()[e ? 0 : 1]));
          }
          isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
        }
        n.setItemLayout(t, s);
      }
      var SOt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.updateTransform = function(e, i, r) {
          i.eachSeries(function(a) {
            var o = sl.getMarkerModelFromSeries(a, "markLine");
            if (o) {
              var s = o.getData(), l = NI(o).from, u = NI(o).to;
              l.each(function(h) {
                pL(l, h, true, a, r), pL(u, h, false, a, r);
              }), s.each(function(h) {
                s.setItemLayout(h, [l.getItemLayout(h), u.getItemLayout(h)]);
              }), this.markerGroupMap.get(a.id).updateLayout();
            }
          }, this);
        }, t.prototype.renderSeries = function(e, i, r, a) {
          var o = e.coordinateSystem, s = e.id, l = e.getData(), u = this.markerGroupMap, h = u.get(s) || u.set(s, new jD());
          this.group.add(h.group);
          var c = bOt(o, e, i), f = c.from, g = c.to, d = c.line;
          NI(i).from = f, NI(i).to = g, i.setData(d);
          var A = i.get("symbol"), p = i.get("symbolSize"), v = i.get("symbolRotate"), y = i.get("symbolOffset");
          Z(A) || (A = [A, A]), Z(p) || (p = [p, p]), Z(v) || (v = [v, v]), Z(y) || (y = [y, y]), c.from.each(function(_) {
            m(f, _, true), m(g, _, false);
          }), d.each(function(_) {
            var I = d.getItemModel(_).getModel("lineStyle").getLineStyle();
            d.setItemLayout(_, [f.getItemLayout(_), g.getItemLayout(_)]), I.stroke == null && (I.stroke = f.getItemVisual(_, "style").fill), d.setItemVisual(_, { fromSymbolKeepAspect: f.getItemVisual(_, "symbolKeepAspect"), fromSymbolOffset: f.getItemVisual(_, "symbolOffset"), fromSymbolRotate: f.getItemVisual(_, "symbolRotate"), fromSymbolSize: f.getItemVisual(_, "symbolSize"), fromSymbol: f.getItemVisual(_, "symbol"), toSymbolKeepAspect: g.getItemVisual(_, "symbolKeepAspect"), toSymbolOffset: g.getItemVisual(_, "symbolOffset"), toSymbolRotate: g.getItemVisual(_, "symbolRotate"), toSymbolSize: g.getItemVisual(_, "symbolSize"), toSymbol: g.getItemVisual(_, "symbol"), style: I });
          }), h.updateData(d), c.line.eachItemGraphicEl(function(_) {
            Nt(_).dataModel = i, _.traverse(function(I) {
              Nt(I).dataModel = i;
            });
          });
          function m(_, I, E) {
            var x = _.getItemModel(I);
            pL(_, I, E, e, a);
            var w = x.getModel("itemStyle").getItemStyle();
            w.fill == null && (w.fill = Lv(l, "color")), _.setItemVisual(I, { symbolKeepAspect: x.get("symbolKeepAspect"), symbolOffset: kt(x.get("symbolOffset", true), y[E ? 0 : 1]), symbolRotate: kt(x.get("symbolRotate", true), v[E ? 0 : 1]), symbolSize: kt(x.get("symbolSize"), p[E ? 0 : 1]), symbol: kt(x.get("symbol", true), A[E ? 0 : 1]), style: w });
          }
          this.markKeep(h), h.group.silent = i.get("silent") || e.get("silent");
        }, t.type = "markLine", t;
      }(AL);
      function bOt(n, t, e) {
        var i;
        n ? i = K(n && n.dimensions, function(u) {
          var h = t.getData().getDimensionInfo(t.getData().mapDimension(u)) || {};
          return X(X({}, h), { name: u, ordinalMeta: null });
        }) : i = [{ name: "value", type: "float" }];
        var r = new er(i, e), a = new er(i, e), o = new er([], e), s = K(e.get("data"), Gt(wOt, t, n, e));
        n && (s = Fe(s, Gt(COt, n)));
        var l = TW(!!n, i);
        return r.initData(K(s, function(u) {
          return u[0];
        }), null, l), a.initData(K(s, function(u) {
          return u[1];
        }), null, l), o.initData(K(s, function(u) {
          return u[2];
        })), o.hasItemOption = true, { from: r, to: a, line: o };
      }
      function TOt(n) {
        n.registerComponentModel(xOt), n.registerComponentView(SOt), n.registerPreprocessor(function(t) {
          hL(t.series, "markLine") && (t.markLine = t.markLine || {});
        });
      }
      var BOt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.createMarkerModelFromSeries = function(e, i, r) {
          return new t(e, i, r);
        }, t.type = "markArea", t.defaultOption = { z: 1, tooltip: { trigger: "item" }, animation: false, label: { show: true, position: "top" }, itemStyle: { borderWidth: 0 }, emphasis: { label: { show: true, position: "top" } } }, t;
      }(sl), kI = ce(), MOt = function(n, t, e, i) {
        var r = i[0], a = i[1];
        if (!(!r || !a)) {
          var o = Cy(n, r), s = Cy(n, a), l = o.coord, u = s.coord;
          l[0] = On(l[0], -1 / 0), l[1] = On(l[1], -1 / 0), u[0] = On(u[0], 1 / 0), u[1] = On(u[1], 1 / 0);
          var h = _2([{}, o, s]);
          return h.coord = [o.coord, s.coord], h.x0 = o.x, h.y0 = o.y, h.x1 = s.x, h.y1 = s.y, h;
        }
      };
      function OI(n) {
        return !isNaN(n) && !isFinite(n);
      }
      function DW(n, t, e, i) {
        var r = 1 - n;
        return OI(t[r]) && OI(e[r]);
      }
      function DOt(n, t) {
        var e = t.coord[0], i = t.coord[1], r = { coord: e, x: t.x0, y: t.y0 }, a = { coord: i, x: t.x1, y: t.y1 };
        return dc(n, "cartesian2d") ? e && i && (DW(1, e, i) || DW(0, e, i)) ? true : mOt(n, r, a) : Sy(n, r) || Sy(n, a);
      }
      function RW(n, t, e, i, r) {
        var a = i.coordinateSystem, o = n.getItemModel(t), s, l = st(o.get(e[0]), r.getWidth()), u = st(o.get(e[1]), r.getHeight());
        if (!isNaN(l) && !isNaN(u)) s = [l, u];
        else {
          if (i.getMarkerPosition) {
            var h = n.getValues(["x0", "y0"], t), c = n.getValues(["x1", "y1"], t), f = a.clampData(h), g = a.clampData(c), d = [];
            e[0] === "x0" ? d[0] = f[0] > g[0] ? c[0] : h[0] : d[0] = f[0] > g[0] ? h[0] : c[0], e[1] === "y0" ? d[1] = f[1] > g[1] ? c[1] : h[1] : d[1] = f[1] > g[1] ? h[1] : c[1], s = i.getMarkerPosition(d, e, true);
          } else {
            var A = n.get(e[0], t), p = n.get(e[1], t), v = [A, p];
            a.clampData && a.clampData(v, v), s = a.dataToPoint(v, true);
          }
          if (dc(a, "cartesian2d")) {
            var y = a.getAxis("x"), m = a.getAxis("y"), A = n.get(e[0], t), p = n.get(e[1], t);
            OI(A) ? s[0] = y.toGlobalCoord(y.getExtent()[e[0] === "x0" ? 0 : 1]) : OI(p) && (s[1] = m.toGlobalCoord(m.getExtent()[e[1] === "y0" ? 0 : 1]));
          }
          isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
        }
        return s;
      }
      var LW = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]], ROt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.updateTransform = function(e, i, r) {
          i.eachSeries(function(a) {
            var o = sl.getMarkerModelFromSeries(a, "markArea");
            if (o) {
              var s = o.getData();
              s.each(function(l) {
                var u = K(LW, function(c) {
                  return RW(s, l, c, a, r);
                });
                s.setItemLayout(l, u);
                var h = s.getItemGraphicEl(l);
                h.setShape("points", u);
              });
            }
          }, this);
        }, t.prototype.renderSeries = function(e, i, r, a) {
          var o = e.coordinateSystem, s = e.id, l = e.getData(), u = this.markerGroupMap, h = u.get(s) || u.set(s, { group: new Dt() });
          this.group.add(h.group), this.markKeep(h);
          var c = LOt(o, e, i);
          i.setData(c), c.each(function(f) {
            var g = K(LW, function(w) {
              return RW(c, f, w, e, a);
            }), d = o.getAxis("x").scale, A = o.getAxis("y").scale, p = d.getExtent(), v = A.getExtent(), y = [d.parse(c.get("x0", f)), d.parse(c.get("x1", f))], m = [A.parse(c.get("y0", f)), A.parse(c.get("y1", f))];
            va(y), va(m);
            var _ = !(p[0] > y[1] || p[1] < y[0] || v[0] > m[1] || v[1] < m[0]), I = !_;
            c.setItemLayout(f, { points: g, allClipped: I });
            var E = c.getItemModel(f).getModel("itemStyle").getItemStyle(), x = Lv(l, "color");
            E.fill || (E.fill = x, ht(E.fill) && (E.fill = e1(E.fill, 0.4))), E.stroke || (E.stroke = x), c.setItemVisual(f, "style", E);
          }), c.diff(kI(h).data).add(function(f) {
            var g = c.getItemLayout(f);
            if (!g.allClipped) {
              var d = new Ki({ shape: { points: g.points } });
              c.setItemGraphicEl(f, d), h.group.add(d);
            }
          }).update(function(f, g) {
            var d = kI(h).data.getItemGraphicEl(g), A = c.getItemLayout(f);
            A.allClipped ? d && h.group.remove(d) : (d ? Ee(d, { shape: { points: A.points } }, i, f) : d = new Ki({ shape: { points: A.points } }), c.setItemGraphicEl(f, d), h.group.add(d));
          }).remove(function(f) {
            var g = kI(h).data.getItemGraphicEl(f);
            h.group.remove(g);
          }).execute(), c.eachItemGraphicEl(function(f, g) {
            var d = c.getItemModel(g), A = c.getItemVisual(g, "style");
            f.useStyle(c.getItemVisual(g, "style")), xi(f, Jn(d), { labelFetcher: i, labelDataIndex: g, defaultText: c.getName(g) || "", inheritColor: ht(A.fill) ? e1(A.fill, 1) : "#000" }), Ii(f, d), pn(f, null, null, d.get(["emphasis", "disabled"])), Nt(f).dataModel = i;
          }), kI(h).data = c, h.group.silent = i.get("silent") || e.get("silent");
        }, t.type = "markArea", t;
      }(AL);
      function LOt(n, t, e) {
        var i, r, a = ["x0", "y0", "x1", "y1"];
        if (n) {
          var o = K(n && n.dimensions, function(u) {
            var h = t.getData(), c = h.getDimensionInfo(h.mapDimension(u)) || {};
            return X(X({}, c), { name: u, ordinalMeta: null });
          });
          r = K(a, function(u, h) {
            return { name: u, type: o[h % 2].type };
          }), i = new er(r, e);
        } else r = [{ name: "value", type: "float" }], i = new er(r, e);
        var s = K(e.get("data"), Gt(MOt, t, n, e));
        n && (s = Fe(s, Gt(DOt, n)));
        var l = n ? function(u, h, c, f) {
          var g = u.coord[Math.floor(f / 2)][f % 2];
          return du(g, r[f]);
        } : function(u, h, c, f) {
          return du(u.value, r[f]);
        };
        return i.initData(s, null, l), i.hasItemOption = true, i;
      }
      function POt(n) {
        n.registerComponentModel(BOt), n.registerComponentView(ROt), n.registerPreprocessor(function(t) {
          hL(t.series, "markArea") && (t.markArea = t.markArea || {});
        });
      }
      var NOt = function(n, t) {
        if (t === "all") return { type: "all", title: n.getLocaleModel().get(["legend", "selector", "all"]) };
        if (t === "inverse") return { type: "inverse", title: n.getLocaleModel().get(["legend", "selector", "inverse"]) };
      }, vL = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.layoutMode = { type: "box", ignoreSize: true }, e;
        }
        return t.prototype.init = function(e, i, r) {
          this.mergeDefaultAndTheme(e, r), e.selected = e.selected || {}, this._updateSelector(e);
        }, t.prototype.mergeOption = function(e, i) {
          n.prototype.mergeOption.call(this, e, i), this._updateSelector(e);
        }, t.prototype._updateSelector = function(e) {
          var i = e.selector, r = this.ecModel;
          i === true && (i = e.selector = ["all", "inverse"]), Z(i) && D(i, function(a, o) {
            ht(a) && (a = { type: a }), i[o] = Yt(a, NOt(r, a.type));
          });
        }, t.prototype.optionUpdated = function() {
          this._updateData(this.ecModel);
          var e = this._data;
          if (e[0] && this.get("selectedMode") === "single") {
            for (var i = false, r = 0; r < e.length; r++) {
              var a = e[r].get("name");
              if (this.isSelected(a)) {
                this.select(a), i = true;
                break;
              }
            }
            !i && this.select(e[0].get("name"));
          }
        }, t.prototype._updateData = function(e) {
          var i = [], r = [];
          e.eachRawSeries(function(l) {
            var u = l.name;
            r.push(u);
            var h;
            if (l.legendVisualProvider) {
              var c = l.legendVisualProvider, f = c.getAllNames();
              e.isSeriesFiltered(l) || (r = r.concat(f)), f.length ? i = i.concat(f) : h = true;
            } else h = true;
            h && ET(l) && i.push(l.name);
          }), this._availableNames = r;
          var a = this.get("data") || i, o = dt(), s = K(a, function(l) {
            return (ht(l) || ye(l)) && (l = { name: l }), o.get(l.name) ? null : (o.set(l.name, true), new De(l, this, this.ecModel));
          }, this);
          this._data = Fe(s, function(l) {
            return !!l;
          });
        }, t.prototype.getData = function() {
          return this._data;
        }, t.prototype.select = function(e) {
          var i = this.option.selected, r = this.get("selectedMode");
          if (r === "single") {
            var a = this._data;
            D(a, function(o) {
              i[o.get("name")] = false;
            });
          }
          i[e] = true;
        }, t.prototype.unSelect = function(e) {
          this.get("selectedMode") !== "single" && (this.option.selected[e] = false);
        }, t.prototype.toggleSelected = function(e) {
          var i = this.option.selected;
          i.hasOwnProperty(e) || (i[e] = true), this[i[e] ? "unSelect" : "select"](e);
        }, t.prototype.allSelect = function() {
          var e = this._data, i = this.option.selected;
          D(e, function(r) {
            i[r.get("name", true)] = true;
          });
        }, t.prototype.inverseSelect = function() {
          var e = this._data, i = this.option.selected;
          D(e, function(r) {
            var a = r.get("name", true);
            i.hasOwnProperty(a) || (i[a] = true), i[a] = !i[a];
          });
        }, t.prototype.isSelected = function(e) {
          var i = this.option.selected;
          return !(i.hasOwnProperty(e) && !i[e]) && $t(this._availableNames, e) >= 0;
        }, t.prototype.getOrient = function() {
          return this.get("orient") === "vertical" ? { index: 1, name: "vertical" } : { index: 0, name: "horizontal" };
        }, t.type = "legend.plain", t.dependencies = ["series"], t.defaultOption = { z: 4, show: true, orient: "horizontal", left: "center", top: 0, align: "auto", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderRadius: 0, borderWidth: 0, padding: 5, itemGap: 10, itemWidth: 25, itemHeight: 14, symbolRotate: "inherit", symbolKeepAspect: true, inactiveColor: "#ccc", inactiveBorderColor: "#ccc", inactiveBorderWidth: "auto", itemStyle: { color: "inherit", opacity: "inherit", borderColor: "inherit", borderWidth: "auto", borderCap: "inherit", borderJoin: "inherit", borderDashOffset: "inherit", borderMiterLimit: "inherit" }, lineStyle: { width: "auto", color: "inherit", inactiveColor: "#ccc", inactiveWidth: 2, opacity: "inherit", type: "inherit", cap: "inherit", join: "inherit", dashOffset: "inherit", miterLimit: "inherit" }, textStyle: { color: "#333" }, selectedMode: true, selector: false, selectorLabel: { show: true, borderRadius: 10, padding: [3, 5, 3, 5], fontSize: 12, fontFamily: "sans-serif", color: "#666", borderWidth: 1, borderColor: "#666" }, emphasis: { selectorLabel: { show: true, color: "#eee", backgroundColor: "#666" } }, selectorPosition: "auto", selectorItemGap: 7, selectorButtonGap: 10, tooltip: { show: false } }, t;
      }(ae), Dd = Gt, yL = D, QI = Dt, PW = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.newlineDisabled = false, e;
        }
        return t.prototype.init = function() {
          this.group.add(this._contentGroup = new QI()), this.group.add(this._selectorGroup = new QI()), this._isFirstRender = true;
        }, t.prototype.getContentGroup = function() {
          return this._contentGroup;
        }, t.prototype.getSelectorGroup = function() {
          return this._selectorGroup;
        }, t.prototype.render = function(e, i, r) {
          var a = this._isFirstRender;
          if (this._isFirstRender = false, this.resetInner(), !!e.get("show", true)) {
            var o = e.get("align"), s = e.get("orient");
            (!o || o === "auto") && (o = e.get("left") === "right" && s === "vertical" ? "right" : "left");
            var l = e.get("selector", true), u = e.get("selectorPosition", true);
            l && (!u || u === "auto") && (u = s === "horizontal" ? "end" : "start"), this.renderInner(o, e, i, r, l, s, u);
            var h = e.getBoxLayoutParams(), c = { width: r.getWidth(), height: r.getHeight() }, f = e.get("padding"), g = Yn(h, c, f), d = this.layoutInner(e, o, g, a, l, u), A = Yn(wt({ width: d.width, height: d.height }, h), c, f);
            this.group.x = A.x - d.x, this.group.y = A.y - d.y, this.group.markRedraw(), this.group.add(this._backgroundEl = VY(d, e));
          }
        }, t.prototype.resetInner = function() {
          this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
        }, t.prototype.renderInner = function(e, i, r, a, o, s, l) {
          var u = this.getContentGroup(), h = dt(), c = i.get("selectedMode"), f = [];
          r.eachRawSeries(function(g) {
            !g.get("legendHoverLink") && f.push(g.id);
          }), yL(i.getData(), function(g, d) {
            var A = g.get("name");
            if (!this.newlineDisabled && (A === "" || A === `
`)) {
              var p = new QI();
              p.newline = true, u.add(p);
              return;
            }
            var v = r.getSeriesByName(A)[0];
            if (!h.get(A)) {
              if (v) {
                var y = v.getData(), m = y.getVisual("legendLineStyle") || {}, _ = y.getVisual("legendIcon"), I = y.getVisual("style"), E = this._createItem(v, A, d, g, i, e, m, I, _, c, a);
                E.on("click", Dd(NW, A, null, a, f)).on("mouseover", Dd(mL, v.name, null, a, f)).on("mouseout", Dd(_L, v.name, null, a, f)), r.ssr && E.eachChild(function(x) {
                  var w = Nt(x);
                  w.seriesIndex = v.seriesIndex, w.dataIndex = d, w.ssrType = "legend";
                }), h.set(A, true);
              } else r.eachRawSeries(function(x) {
                if (!h.get(A) && x.legendVisualProvider) {
                  var w = x.legendVisualProvider;
                  if (!w.containName(A)) return;
                  var C = w.indexOfName(A), S = w.getItemVisual(C, "style"), b = w.getItemVisual(C, "legendIcon"), T = qr(S.fill);
                  T && T[3] === 0 && (T[3] = 0.2, S = X(X({}, S), { fill: Gs(T, "rgba") }));
                  var B = this._createItem(x, A, d, g, i, e, {}, S, b, c, a);
                  B.on("click", Dd(NW, null, A, a, f)).on("mouseover", Dd(mL, null, A, a, f)).on("mouseout", Dd(_L, null, A, a, f)), r.ssr && B.eachChild(function(R) {
                    var M = Nt(R);
                    M.seriesIndex = x.seriesIndex, M.dataIndex = d, M.ssrType = "legend";
                  }), h.set(A, true);
                }
              }, this);
              h.get(A);
            }
          }, this), o && this._createSelector(o, i, a, s, l);
        }, t.prototype._createSelector = function(e, i, r, a, o) {
          var s = this.getSelectorGroup();
          yL(e, function(u) {
            var h = u.type, c = new Ae({ style: { x: 0, y: 0, align: "center", verticalAlign: "middle" }, onclick: function() {
              r.dispatchAction({ type: h === "all" ? "legendAllSelect" : "legendInverseSelect" });
            } });
            s.add(c);
            var f = i.getModel("selectorLabel"), g = i.getModel(["emphasis", "selectorLabel"]);
            xi(c, { normal: f, emphasis: g }, { defaultText: u.title }), Uh(c);
          });
        }, t.prototype._createItem = function(e, i, r, a, o, s, l, u, h, c, f) {
          var g = e.visualDrawType, d = o.get("itemWidth"), A = o.get("itemHeight"), p = o.isSelected(i), v = a.get("symbolRotate"), y = a.get("symbolKeepAspect"), m = a.get("icon");
          h = m || h || "roundRect";
          var _ = FOt(h, a, l, u, g, p, f), I = new QI(), E = a.getModel("textStyle");
          if (yt(e.getLegendIcon) && (!m || m === "inherit")) I.add(e.getLegendIcon({ itemWidth: d, itemHeight: A, icon: h, iconRotate: v, itemStyle: _.itemStyle, lineStyle: _.lineStyle, symbolKeepAspect: y }));
          else {
            var x = m === "inherit" && e.getData().getVisual("symbol") ? v === "inherit" ? e.getData().getVisual("symbolRotate") : v : 0;
            I.add(kOt({ itemWidth: d, itemHeight: A, icon: h, iconRotate: x, itemStyle: _.itemStyle, lineStyle: _.lineStyle, symbolKeepAspect: y }));
          }
          var w = s === "left" ? d + 5 : -5, C = s, S = o.get("formatter"), b = i;
          ht(S) && S ? b = S.replace("{name}", i != null ? i : "") : yt(S) && (b = S(i));
          var T = p ? E.getTextColor() : a.get("inactiveColor");
          I.add(new Ae({ style: Je(E, { text: b, x: w, y: A / 2, fill: T, align: C, verticalAlign: "middle" }, { inheritColor: T }) }));
          var B = new fe({ shape: I.getBoundingRect(), style: { fill: "transparent" } }), R = a.getModel("tooltip");
          return R.get("show") && qg({ el: B, componentModel: o, itemName: i, itemTooltipOption: R.option }), I.add(B), I.eachChild(function(M) {
            M.silent = true;
          }), B.silent = !c, this.getContentGroup().add(I), Uh(I), I.__legendDataIndex = r, I;
        }, t.prototype.layoutInner = function(e, i, r, a, o, s) {
          var l = this.getContentGroup(), u = this.getSelectorGroup();
          Zh(e.get("orient"), l, e.get("itemGap"), r.width, r.height);
          var h = l.getBoundingRect(), c = [-h.x, -h.y];
          if (u.markRedraw(), l.markRedraw(), o) {
            Zh("horizontal", u, e.get("selectorItemGap", true));
            var f = u.getBoundingRect(), g = [-f.x, -f.y], d = e.get("selectorButtonGap", true), A = e.getOrient().index, p = A === 0 ? "width" : "height", v = A === 0 ? "height" : "width", y = A === 0 ? "y" : "x";
            s === "end" ? g[A] += h[p] + d : c[A] += f[p] + d, g[1 - A] += h[v] / 2 - f[v] / 2, u.x = g[0], u.y = g[1], l.x = c[0], l.y = c[1];
            var m = { x: 0, y: 0 };
            return m[p] = h[p] + d + f[p], m[v] = Math.max(h[v], f[v]), m[y] = Math.min(0, f[y] + g[1 - A]), m;
          } else return l.x = c[0], l.y = c[1], this.group.getBoundingRect();
        }, t.prototype.remove = function() {
          this.getContentGroup().removeAll(), this._isFirstRender = true;
        }, t.type = "legend.plain", t;
      }(un);
      function FOt(n, t, e, i, r, a, o) {
        function s(p, v) {
          p.lineWidth === "auto" && (p.lineWidth = v.lineWidth > 0 ? 2 : 0), yL(p, function(y, m) {
            p[m] === "inherit" && (p[m] = v[m]);
          });
        }
        var l = t.getModel("itemStyle"), u = l.getItemStyle(), h = n.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", c = l.getShallow("decal");
        u.decal = !c || c === "inherit" ? i.decal : ud(c, o), u.fill === "inherit" && (u.fill = i[r]), u.stroke === "inherit" && (u.stroke = i[h]), u.opacity === "inherit" && (u.opacity = (r === "fill" ? i : e).opacity), s(u, i);
        var f = t.getModel("lineStyle"), g = f.getLineStyle();
        if (s(g, e), u.fill === "auto" && (u.fill = i.fill), u.stroke === "auto" && (u.stroke = i.fill), g.stroke === "auto" && (g.stroke = i.fill), !a) {
          var d = t.get("inactiveBorderWidth"), A = u[h];
          u.lineWidth = d === "auto" ? i.lineWidth > 0 && A ? 2 : 0 : u.lineWidth, u.fill = t.get("inactiveColor"), u.stroke = t.get("inactiveBorderColor"), g.stroke = f.get("inactiveColor"), g.lineWidth = f.get("inactiveWidth");
        }
        return { itemStyle: u, lineStyle: g };
      }
      function kOt(n) {
        var t = n.icon || "roundRect", e = Un(t, 0, 0, n.itemWidth, n.itemHeight, n.itemStyle.fill, n.symbolKeepAspect);
        return e.setStyle(n.itemStyle), e.rotation = (n.iconRotate || 0) * Math.PI / 180, e.setOrigin([n.itemWidth / 2, n.itemHeight / 2]), t.indexOf("empty") > -1 && (e.style.stroke = e.style.fill, e.style.fill = "#fff", e.style.lineWidth = 2), e;
      }
      function NW(n, t, e, i) {
        _L(n, t, e, i), e.dispatchAction({ type: "legendToggleSelect", name: n != null ? n : t }), mL(n, t, e, i);
      }
      function FW(n) {
        for (var t = n.getZr().storage.getDisplayList(), e, i = 0, r = t.length; i < r && !(e = t[i].states.emphasis); ) i++;
        return e && e.hoverLayer;
      }
      function mL(n, t, e, i) {
        FW(e) || e.dispatchAction({ type: "highlight", seriesName: n, name: t, excludeSeriesId: i });
      }
      function _L(n, t, e, i) {
        FW(e) || e.dispatchAction({ type: "downplay", seriesName: n, name: t, excludeSeriesId: i });
      }
      function OOt(n) {
        var t = n.findComponents({ mainType: "legend" });
        t && t.length && n.filterSeries(function(e) {
          for (var i = 0; i < t.length; i++) if (!t[i].isSelected(e.name)) return false;
          return true;
        });
      }
      function by(n, t, e) {
        var i = {}, r = n === "toggleSelected", a;
        return e.eachComponent("legend", function(o) {
          r && a != null ? o[a ? "select" : "unSelect"](t.name) : n === "allSelect" || n === "inverseSelect" ? o[n]() : (o[n](t.name), a = o.isSelected(t.name));
          var s = o.getData();
          D(s, function(l) {
            var u = l.get("name");
            if (!(u === `
` || u === "")) {
              var h = o.isSelected(u);
              i.hasOwnProperty(u) ? i[u] = i[u] && h : i[u] = h;
            }
          });
        }), n === "allSelect" || n === "inverseSelect" ? { selected: i } : { name: t.name, selected: i };
      }
      function QOt(n) {
        n.registerAction("legendToggleSelect", "legendselectchanged", Gt(by, "toggleSelected")), n.registerAction("legendAllSelect", "legendselectall", Gt(by, "allSelect")), n.registerAction("legendInverseSelect", "legendinverseselect", Gt(by, "inverseSelect")), n.registerAction("legendSelect", "legendselected", Gt(by, "select")), n.registerAction("legendUnSelect", "legendunselected", Gt(by, "unSelect"));
      }
      function kW(n) {
        n.registerComponentModel(vL), n.registerComponentView(PW), n.registerProcessor(n.PRIORITY.PROCESSOR.SERIES_FILTER, OOt), n.registerSubTypeDefaulter("legend", function() {
          return "plain";
        }), QOt(n);
      }
      var zOt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.setScrollDataIndex = function(e) {
          this.option.scrollDataIndex = e;
        }, t.prototype.init = function(e, i, r) {
          var a = Kg(e);
          n.prototype.init.call(this, e, i, r), OW(this, e, a);
        }, t.prototype.mergeOption = function(e, i) {
          n.prototype.mergeOption.call(this, e, i), OW(this, this.option, e);
        }, t.type = "legend.scroll", t.defaultOption = cu(vL.defaultOption, { scrollDataIndex: 0, pageButtonItemGap: 5, pageButtonGap: null, pageButtonPosition: "end", pageFormatter: "{current}/{total}", pageIcons: { horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"], vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"] }, pageIconColor: "#2f4554", pageIconInactiveColor: "#aaa", pageIconSize: 15, pageTextStyle: { color: "#333" }, animationDurationUpdate: 800 }), t;
      }(vL);
      function OW(n, t, e) {
        var i = n.getOrient(), r = [1, 1];
        r[i.index] = 0, gu(t, e, { type: "box", ignoreSize: !!r });
      }
      var QW = Dt, EL = ["width", "height"], IL = ["x", "y"], GOt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.newlineDisabled = true, e._currentIndex = 0, e;
        }
        return t.prototype.init = function() {
          n.prototype.init.call(this), this.group.add(this._containerGroup = new QW()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new QW());
        }, t.prototype.resetInner = function() {
          n.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
        }, t.prototype.renderInner = function(e, i, r, a, o, s, l) {
          var u = this;
          n.prototype.renderInner.call(this, e, i, r, a, o, s, l);
          var h = this._controllerGroup, c = i.get("pageIconSize", true), f = Z(c) ? c : [c, c];
          d("pagePrev", 0);
          var g = i.getModel("pageTextStyle");
          h.add(new Ae({ name: "pageText", style: { text: "xx/xx", fill: g.getTextColor(), font: g.getFont(), verticalAlign: "middle", align: "center" }, silent: true })), d("pageNext", 1);
          function d(A, p) {
            var v = A + "DataIndex", y = vv(i.get("pageIcons", true)[i.getOrient().name][p], { onclick: ct(u._pageGo, u, v, i, a) }, { x: -f[0] / 2, y: -f[1] / 2, width: f[0], height: f[1] });
            y.name = A, h.add(y);
          }
        }, t.prototype.layoutInner = function(e, i, r, a, o, s) {
          var l = this.getSelectorGroup(), u = e.getOrient().index, h = EL[u], c = IL[u], f = EL[1 - u], g = IL[1 - u];
          o && Zh("horizontal", l, e.get("selectorItemGap", true));
          var d = e.get("selectorButtonGap", true), A = l.getBoundingRect(), p = [-A.x, -A.y], v = Ct(r);
          o && (v[h] = r[h] - A[h] - d);
          var y = this._layoutContentAndController(e, a, v, u, h, f, g, c);
          if (o) {
            if (s === "end") p[u] += y[h] + d;
            else {
              var m = A[h] + d;
              p[u] -= m, y[c] -= m;
            }
            y[h] += A[h] + d, p[1 - u] += y[g] + y[f] / 2 - A[f] / 2, y[f] = Math.max(y[f], A[f]), y[g] = Math.min(y[g], A[g] + p[1 - u]), l.x = p[0], l.y = p[1], l.markRedraw();
          }
          return y;
        }, t.prototype._layoutContentAndController = function(e, i, r, a, o, s, l, u) {
          var h = this.getContentGroup(), c = this._containerGroup, f = this._controllerGroup;
          Zh(e.get("orient"), h, e.get("itemGap"), a ? r.width : null, a ? null : r.height), Zh("horizontal", f, e.get("pageButtonItemGap", true));
          var g = h.getBoundingRect(), d = f.getBoundingRect(), A = this._showController = g[o] > r[o], p = [-g.x, -g.y];
          i || (p[a] = h[u]);
          var v = [0, 0], y = [-d.x, -d.y], m = kt(e.get("pageButtonGap", true), e.get("itemGap", true));
          if (A) {
            var _ = e.get("pageButtonPosition", true);
            _ === "end" ? y[a] += r[o] - d[o] : v[a] += d[o] + m;
          }
          y[1 - a] += g[s] / 2 - d[s] / 2, h.setPosition(p), c.setPosition(v), f.setPosition(y);
          var I = { x: 0, y: 0 };
          if (I[o] = A ? r[o] : g[o], I[s] = Math.max(g[s], d[s]), I[l] = Math.min(0, d[l] + y[1 - a]), c.__rectSize = r[o], A) {
            var E = { x: 0, y: 0 };
            E[o] = Math.max(r[o] - d[o] - m, 0), E[s] = I[s], c.setClipPath(new fe({ shape: E })), c.__rectSize = E[o];
          } else f.eachChild(function(w) {
            w.attr({ invisible: true, silent: true });
          });
          var x = this._getPageInfo(e);
          return x.pageIndex != null && Ee(h, { x: x.contentPosition[0], y: x.contentPosition[1] }, A ? e : null), this._updatePageInfoView(e, x), I;
        }, t.prototype._pageGo = function(e, i, r) {
          var a = this._getPageInfo(i)[e];
          a != null && r.dispatchAction({ type: "legendScroll", scrollDataIndex: a, legendId: i.id });
        }, t.prototype._updatePageInfoView = function(e, i) {
          var r = this._controllerGroup;
          D(["pagePrev", "pageNext"], function(h) {
            var c = h + "DataIndex", f = i[c] != null, g = r.childOfName(h);
            g && (g.setStyle("fill", f ? e.get("pageIconColor", true) : e.get("pageIconInactiveColor", true)), g.cursor = f ? "pointer" : "default");
          });
          var a = r.childOfName("pageText"), o = e.get("pageFormatter"), s = i.pageIndex, l = s != null ? s + 1 : 0, u = i.pageCount;
          a && o && a.setStyle("text", ht(o) ? o.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : o({ current: l, total: u }));
        }, t.prototype._getPageInfo = function(e) {
          var i = e.get("scrollDataIndex", true), r = this.getContentGroup(), a = this._containerGroup.__rectSize, o = e.getOrient().index, s = EL[o], l = IL[o], u = this._findTargetItemIndex(i), h = r.children(), c = h[u], f = h.length, g = f ? 1 : 0, d = { contentPosition: [r.x, r.y], pageCount: g, pageIndex: g - 1, pagePrevDataIndex: null, pageNextDataIndex: null };
          if (!c) return d;
          var A = _(c);
          d.contentPosition[o] = -A.s;
          for (var p = u + 1, v = A, y = A, m = null; p <= f; ++p) m = _(h[p]), (!m && y.e > v.s + a || m && !I(m, v.s)) && (y.i > v.i ? v = y : v = m, v && (d.pageNextDataIndex == null && (d.pageNextDataIndex = v.i), ++d.pageCount)), y = m;
          for (var p = u - 1, v = A, y = A, m = null; p >= -1; --p) m = _(h[p]), (!m || !I(y, m.s)) && v.i < y.i && (y = v, d.pagePrevDataIndex == null && (d.pagePrevDataIndex = v.i), ++d.pageCount, ++d.pageIndex), v = m;
          return d;
          function _(E) {
            if (E) {
              var x = E.getBoundingRect(), w = x[l] + E[l];
              return { s: w, e: w + x[s], i: E.__legendDataIndex };
            }
          }
          function I(E, x) {
            return E.e >= x && E.s <= x + a;
          }
        }, t.prototype._findTargetItemIndex = function(e) {
          if (!this._showController) return 0;
          var i, r = this.getContentGroup(), a;
          return r.eachChild(function(o, s) {
            var l = o.__legendDataIndex;
            a == null && l != null && (a = s), l === e && (i = s);
          }), i != null ? i : a;
        }, t.type = "legend.scroll", t;
      }(PW);
      function UOt(n) {
        n.registerAction("legendScroll", "legendscroll", function(t, e) {
          var i = t.scrollDataIndex;
          i != null && e.eachComponent({ mainType: "legend", subType: "scroll", query: t }, function(r) {
            r.setScrollDataIndex(i);
          });
        });
      }
      function VOt(n) {
        Kt(kW), n.registerComponentModel(zOt), n.registerComponentView(GOt), UOt(n);
      }
      function jOt(n) {
        Kt(kW), Kt(VOt);
      }
      var qOt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "dataZoom.inside", t.defaultOption = cu(Iy.defaultOption, { disabled: false, zoomLock: false, zoomOnMouseWheel: true, moveOnMouseMove: true, moveOnMouseWheel: false, preventDefaultMouseMove: true }), t;
      }(Iy), xL = ce();
      function HOt(n, t, e) {
        xL(n).coordSysRecordMap.each(function(i) {
          var r = i.dataZoomInfoMap.get(t.uid);
          r && (r.getRange = e);
        });
      }
      function YOt(n, t) {
        for (var e = xL(n).coordSysRecordMap, i = e.keys(), r = 0; r < i.length; r++) {
          var a = i[r], o = e.get(a), s = o.dataZoomInfoMap;
          if (s) {
            var l = t.uid, u = s.get(l);
            u && (s.removeKey(l), s.keys().length || zW(e, o));
          }
        }
      }
      function zW(n, t) {
        if (t) {
          n.removeKey(t.model.uid);
          var e = t.controller;
          e && e.dispose();
        }
      }
      function WOt(n, t) {
        var e = { model: t, containsPoint: Gt($Ot, t), dispatchAction: Gt(XOt, n), dataZoomInfoMap: null, controller: null }, i = e.controller = new ay(n.getZr());
        return D(["pan", "zoom", "scrollMove"], function(r) {
          i.on(r, function(a) {
            var o = [];
            e.dataZoomInfoMap.each(function(s) {
              if (a.isAvailableBehavior(s.model.option)) {
                var l = (s.getRange || {})[r], u = l && l(s.dzReferCoordSysInfo, e.model.mainType, e.controller, a);
                !s.model.get("disabled", true) && u && o.push({ dataZoomId: s.model.id, start: u[0], end: u[1] });
              }
            }), o.length && e.dispatchAction(o);
          });
        }), e;
      }
      function XOt(n, t) {
        n.isDisposed() || n.dispatchAction({ type: "dataZoom", animation: { easing: "cubicOut", duration: 100 }, batch: t });
      }
      function $Ot(n, t, e, i) {
        return n.coordinateSystem.containPoint([e, i]);
      }
      function ZOt(n) {
        var t, e = "type_", i = { type_true: 2, type_move: 1, type_false: 0, type_undefined: -1 }, r = true;
        return n.each(function(a) {
          var o = a.model, s = o.get("disabled", true) ? false : o.get("zoomLock", true) ? "move" : true;
          i[e + s] > i[e + t] && (t = s), r = r && o.get("preventDefaultMouseMove", true);
        }), { controlType: t, opt: { zoomOnMouseWheel: true, moveOnMouseMove: true, moveOnMouseWheel: true, preventDefaultMouseMove: !!r } };
      }
      function KOt(n) {
        n.registerProcessor(n.PRIORITY.PROCESSOR.FILTER, function(t, e) {
          var i = xL(e), r = i.coordSysRecordMap || (i.coordSysRecordMap = dt());
          r.each(function(a) {
            a.dataZoomInfoMap = null;
          }), t.eachComponent({ mainType: "dataZoom", subType: "inside" }, function(a) {
            var o = kY(a);
            D(o.infoList, function(s) {
              var l = s.model.uid, u = r.get(l) || r.set(l, WOt(e, s.model)), h = u.dataZoomInfoMap || (u.dataZoomInfoMap = dt());
              h.set(a.uid, { dzReferCoordSysInfo: s, model: a, getRange: null });
            });
          }), r.each(function(a) {
            var o = a.controller, s, l = a.dataZoomInfoMap;
            if (l) {
              var u = l.keys()[0];
              u != null && (s = l.get(u));
            }
            if (!s) {
              zW(r, a);
              return;
            }
            var h = ZOt(l);
            o.enable(h.controlType, h.opt), o.setPointerChecker(a.containsPoint), ad(a, "dispatchAction", s.model.get("throttle", true), "fixRate");
          });
        });
      }
      var JOt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "dataZoom.inside", e;
        }
        return t.prototype.render = function(e, i, r) {
          if (n.prototype.render.apply(this, arguments), e.noTarget()) {
            this._clear();
            return;
          }
          this.range = e.getPercentRange(), HOt(r, e, { pan: ct(wL.pan, this), zoom: ct(wL.zoom, this), scrollMove: ct(wL.scrollMove, this) });
        }, t.prototype.dispose = function() {
          this._clear(), n.prototype.dispose.apply(this, arguments);
        }, t.prototype._clear = function() {
          YOt(this.api, this.dataZoomModel), this.range = null;
        }, t.type = "dataZoom.inside", t;
      }($R), wL = { zoom: function(n, t, e, i) {
        var r = this.range, a = r.slice(), o = n.axisModels[0];
        if (o) {
          var s = CL[t](null, [i.originX, i.originY], o, e, n), l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (a[1] - a[0]) + a[0], u = Math.max(1 / i.scale, 0);
          a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l;
          var h = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
          if (Ic(0, a, [0, 100], 0, h.minSpan, h.maxSpan), this.range = a, r[0] !== a[0] || r[1] !== a[1]) return a;
        }
      }, pan: GW(function(n, t, e, i, r, a) {
        var o = CL[i]([a.oldX, a.oldY], [a.newX, a.newY], t, r, e);
        return o.signal * (n[1] - n[0]) * o.pixel / o.pixelLength;
      }), scrollMove: GW(function(n, t, e, i, r, a) {
        var o = CL[i]([0, 0], [a.scrollDelta, a.scrollDelta], t, r, e);
        return o.signal * (n[1] - n[0]) * a.scrollDelta;
      }) };
      function GW(n) {
        return function(t, e, i, r) {
          var a = this.range, o = a.slice(), s = t.axisModels[0];
          if (s) {
            var l = n(o, s, t, e, i, r);
            if (Ic(l, o, [0, 100], "all"), this.range = o, a[0] !== o[0] || a[1] !== o[1]) return o;
          }
        };
      }
      var CL = { grid: function(n, t, e, i, r) {
        var a = e.axis, o = {}, s = r.model.coordinateSystem.getRect();
        return n = n || [0, 0], a.dim === "x" ? (o.pixel = t[0] - n[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = a.inverse ? 1 : -1) : (o.pixel = t[1] - n[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = a.inverse ? -1 : 1), o;
      }, polar: function(n, t, e, i, r) {
        var a = e.axis, o = {}, s = r.model.coordinateSystem, l = s.getRadiusAxis().getExtent(), u = s.getAngleAxis().getExtent();
        return n = n ? s.pointToCoord(n) : [0, 0], t = s.pointToCoord(t), e.mainType === "radiusAxis" ? (o.pixel = t[0] - n[0], o.pixelLength = l[1] - l[0], o.pixelStart = l[0], o.signal = a.inverse ? 1 : -1) : (o.pixel = t[1] - n[1], o.pixelLength = u[1] - u[0], o.pixelStart = u[0], o.signal = a.inverse ? -1 : 1), o;
      }, singleAxis: function(n, t, e, i, r) {
        var a = e.axis, o = r.model.coordinateSystem.getRect(), s = {};
        return n = n || [0, 0], a.orient === "horizontal" ? (s.pixel = t[0] - n[0], s.pixelLength = o.width, s.pixelStart = o.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = t[1] - n[1], s.pixelLength = o.height, s.pixelStart = o.y, s.signal = a.inverse ? -1 : 1), s;
      } };
      function UW(n) {
        ZR(n), n.registerComponentModel(qOt), n.registerComponentView(JOt), KOt(n);
      }
      var tQt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.type = "dataZoom.slider", t.layoutMode = "box", t.defaultOption = cu(Iy.defaultOption, { show: true, right: "ph", top: "ph", width: "ph", height: "ph", left: null, bottom: null, borderColor: "#d2dbee", borderRadius: 3, backgroundColor: "rgba(47,69,84,0)", dataBackground: { lineStyle: { color: "#d2dbee", width: 0.5 }, areaStyle: { color: "#d2dbee", opacity: 0.2 } }, selectedDataBackground: { lineStyle: { color: "#8fb0f7", width: 0.5 }, areaStyle: { color: "#8fb0f7", opacity: 0.2 } }, fillerColor: "rgba(135,175,274,0.2)", handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z", handleSize: "100%", handleStyle: { color: "#fff", borderColor: "#ACB8D1" }, moveHandleSize: 7, moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z", moveHandleStyle: { color: "#D2DBEE", opacity: 0.7 }, showDetail: true, showDataShadow: "auto", realtime: true, zoomLock: false, textStyle: { color: "#6E7079" }, brushSelect: true, brushStyle: { color: "rgba(135,175,274,0.15)" }, emphasis: { handleStyle: { borderColor: "#8FB0F7" }, moveHandleStyle: { color: "#8FB0F7" } } }), t;
      }(Iy), Ty = fe, VW = 7, eQt = 1, SL = 30, nQt = 7, By = "horizontal", jW = "vertical", iQt = 5, rQt = ["line", "bar", "candlestick", "scatter"], aQt = { easing: "cubicOut", duration: 100, delay: 0 }, oQt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._displayables = {}, e;
        }
        return t.prototype.init = function(e, i) {
          this.api = i, this._onBrush = ct(this._onBrush, this), this._onBrushEnd = ct(this._onBrushEnd, this);
        }, t.prototype.render = function(e, i, r, a) {
          if (n.prototype.render.apply(this, arguments), ad(this, "_dispatchZoomAction", e.get("throttle"), "fixRate"), this._orient = e.getOrient(), e.get("show") === false) {
            this.group.removeAll();
            return;
          }
          if (e.noTarget()) {
            this._clear(), this.group.removeAll();
            return;
          }
          (!a || a.type !== "dataZoom" || a.from !== this.uid) && this._buildView(), this._updateView();
        }, t.prototype.dispose = function() {
          this._clear(), n.prototype.dispose.apply(this, arguments);
        }, t.prototype._clear = function() {
          Mv(this, "_dispatchZoomAction");
          var e = this.api.getZr();
          e.off("mousemove", this._onBrush), e.off("mouseup", this._onBrushEnd);
        }, t.prototype._buildView = function() {
          var e = this.group;
          e.removeAll(), this._brushing = false, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
          var i = this._displayables.sliderGroup = new Dt();
          this._renderBackground(), this._renderHandle(), this._renderDataShadow(), e.add(i), this._positionGroup();
        }, t.prototype._resetLocation = function() {
          var e = this.dataZoomModel, i = this.api, r = e.get("brushSelect"), a = r ? nQt : 0, o = this._findCoordRect(), s = { width: i.getWidth(), height: i.getHeight() }, l = this._orient === By ? { right: s.width - o.x - o.width, top: s.height - SL - VW - a, width: o.width, height: SL } : { right: VW, top: o.y, width: SL, height: o.height }, u = Kg(e.option);
          D(["right", "top", "width", "height"], function(c) {
            u[c] === "ph" && (u[c] = l[c]);
          });
          var h = Yn(u, s);
          this._location = { x: h.x, y: h.y }, this._size = [h.width, h.height], this._orient === jW && this._size.reverse();
        }, t.prototype._positionGroup = function() {
          var e = this.group, i = this._location, r = this._orient, a = this.dataZoomModel.getFirstTargetAxisModel(), o = a && a.get("inverse"), s = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse;
          s.attr(r === By && !o ? { scaleY: l ? 1 : -1, scaleX: 1 } : r === By && o ? { scaleY: l ? 1 : -1, scaleX: -1 } : r === jW && !o ? { scaleY: l ? -1 : 1, scaleX: 1, rotation: Math.PI / 2 } : { scaleY: l ? -1 : 1, scaleX: -1, rotation: Math.PI / 2 });
          var u = e.getBoundingRect([s]);
          e.x = i.x - u.x, e.y = i.y - u.y, e.markRedraw();
        }, t.prototype._getViewExtent = function() {
          return [0, this._size[0]];
        }, t.prototype._renderBackground = function() {
          var e = this.dataZoomModel, i = this._size, r = this._displayables.sliderGroup, a = e.get("brushSelect");
          r.add(new Ty({ silent: true, shape: { x: 0, y: 0, width: i[0], height: i[1] }, style: { fill: e.get("backgroundColor") }, z2: -40 }));
          var o = new Ty({ shape: { x: 0, y: 0, width: i[0], height: i[1] }, style: { fill: "transparent" }, z2: 0, onclick: ct(this._onClickPanel, this) }), s = this.api.getZr();
          a ? (o.on("mousedown", this._onBrushStart, this), o.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), r.add(o);
        }, t.prototype._renderDataShadow = function() {
          var e = this._dataShadowInfo = this._prepareDataShadowInfo();
          if (this._displayables.dataShadowSegs = [], !e) return;
          var i = this._size, r = this._shadowSize || [], a = e.series, o = a.getRawData(), s = a.getShadowDim && a.getShadowDim(), l = s && o.getDimensionInfo(s) ? a.getShadowDim() : e.otherDim;
          if (l == null) return;
          var u = this._shadowPolygonPts, h = this._shadowPolylinePts;
          if (o !== this._shadowData || l !== this._shadowDim || i[0] !== r[0] || i[1] !== r[1]) {
            var c = o.getDataExtent(l), f = (c[1] - c[0]) * 0.3;
            c = [c[0] - f, c[1] + f];
            var g = [0, i[1]], d = [0, i[0]], A = [[i[0], 0], [0, 0]], p = [], v = d[1] / (o.count() - 1), y = 0, m = Math.round(o.count() / i[0]), _;
            o.each([l], function(C, S) {
              if (m > 0 && S % m) {
                y += v;
                return;
              }
              var b = C == null || isNaN(C) || C === "", T = b ? 0 : Ne(C, c, g, true);
              b && !_ && S ? (A.push([A[A.length - 1][0], 0]), p.push([p[p.length - 1][0], 0])) : !b && _ && (A.push([y, 0]), p.push([y, 0])), A.push([y, T]), p.push([y, T]), y += v, _ = b;
            }), u = this._shadowPolygonPts = A, h = this._shadowPolylinePts = p;
          }
          this._shadowData = o, this._shadowDim = l, this._shadowSize = [i[0], i[1]];
          var I = this.dataZoomModel;
          function E(C) {
            var S = I.getModel(C ? "selectedDataBackground" : "dataBackground"), b = new Dt(), T = new Ki({ shape: { points: u }, segmentIgnoreThreshold: 1, style: S.getModel("areaStyle").getAreaStyle(), silent: true, z2: -20 }), B = new Ji({ shape: { points: h }, segmentIgnoreThreshold: 1, style: S.getModel("lineStyle").getLineStyle(), silent: true, z2: -19 });
            return b.add(T), b.add(B), b;
          }
          for (var x = 0; x < 3; x++) {
            var w = E(x === 1);
            this._displayables.sliderGroup.add(w), this._displayables.dataShadowSegs.push(w);
          }
        }, t.prototype._prepareDataShadowInfo = function() {
          var e = this.dataZoomModel, i = e.get("showDataShadow");
          if (i !== false) {
            var r, a = this.ecModel;
            return e.eachTargetAxis(function(o, s) {
              var l = e.getAxisProxy(o, s).getTargetSeriesModels();
              D(l, function(u) {
                if (!r && !(i !== true && $t(rQt, u.get("type")) < 0)) {
                  var h = a.getComponent(bu(o), s).axis, c = sQt(o), f, g = u.coordinateSystem;
                  c != null && g.getOtherAxis && (f = g.getOtherAxis(h).inverse), c = u.getData().mapDimension(c), r = { thisAxis: h, series: u, thisDim: o, otherDim: c, otherAxisInverse: f };
                }
              }, this);
            }, this), r;
          }
        }, t.prototype._renderHandle = function() {
          var e = this.group, i = this._displayables, r = i.handles = [null, null], a = i.handleLabels = [null, null], o = this._displayables.sliderGroup, s = this._size, l = this.dataZoomModel, u = this.api, h = l.get("borderRadius") || 0, c = l.get("brushSelect"), f = i.filler = new Ty({ silent: c, style: { fill: l.get("fillerColor") }, textConfig: { position: "inside" } });
          o.add(f), o.add(new Ty({ silent: true, subPixelOptimize: true, shape: { x: 0, y: 0, width: s[0], height: s[1], r: h }, style: { stroke: l.get("dataBackgroundColor") || l.get("borderColor"), lineWidth: eQt, fill: "rgba(0,0,0,0)" } })), D([0, 1], function(m) {
            var _ = l.get("handleIcon");
            !dE[_] && _.indexOf("path://") < 0 && _.indexOf("image://") < 0 && (_ = "path://" + _, Ka("handleIcon now needs 'path://' prefix when using a path string"));
            var I = Un(_, -1, 0, 2, 2, null, true);
            I.attr({ cursor: qW(this._orient), draggable: true, drift: ct(this._onDragMove, this, m), ondragend: ct(this._onDragEnd, this), onmouseover: ct(this._showDataInfo, this, true), onmouseout: ct(this._showDataInfo, this, false), z2: 5 });
            var E = I.getBoundingRect(), x = l.get("handleSize");
            this._handleHeight = st(x, this._size[1]), this._handleWidth = E.width / E.height * this._handleHeight, I.setStyle(l.getModel("handleStyle").getItemStyle()), I.style.strokeNoScale = true, I.rectHover = true, I.ensureState("emphasis").style = l.getModel(["emphasis", "handleStyle"]).getItemStyle(), Uh(I);
            var w = l.get("handleColor");
            w != null && (I.style.fill = w), o.add(r[m] = I);
            var C = l.getModel("textStyle");
            e.add(a[m] = new Ae({ silent: true, invisible: true, style: Je(C, { x: 0, y: 0, text: "", verticalAlign: "middle", align: "center", fill: C.getTextColor(), font: C.getFont() }), z2: 10 }));
          }, this);
          var g = f;
          if (c) {
            var d = st(l.get("moveHandleSize"), s[1]), A = i.moveHandle = new fe({ style: l.getModel("moveHandleStyle").getItemStyle(), silent: true, shape: { r: [0, 0, 2, 2], y: s[1] - 0.5, height: d } }), p = d * 0.8, v = i.moveHandleIcon = Un(l.get("moveHandleIcon"), -p / 2, -p / 2, p, p, "#fff", true);
            v.silent = true, v.y = s[1] + d / 2 - 0.5, A.ensureState("emphasis").style = l.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
            var y = Math.min(s[1] / 2, Math.max(d, 10));
            g = i.moveZone = new fe({ invisible: true, shape: { y: s[1] - y, height: d + y } }), g.on("mouseover", function() {
              u.enterEmphasis(A);
            }).on("mouseout", function() {
              u.leaveEmphasis(A);
            }), o.add(A), o.add(v), o.add(g);
          }
          g.attr({ draggable: true, cursor: qW(this._orient), drift: ct(this._onDragMove, this, "all"), ondragstart: ct(this._showDataInfo, this, true), ondragend: ct(this._onDragEnd, this), onmouseover: ct(this._showDataInfo, this, true), onmouseout: ct(this._showDataInfo, this, false) });
        }, t.prototype._resetInterval = function() {
          var e = this._range = this.dataZoomModel.getPercentRange(), i = this._getViewExtent();
          this._handleEnds = [Ne(e[0], [0, 100], i, true), Ne(e[1], [0, 100], i, true)];
        }, t.prototype._updateInterval = function(e, i) {
          var r = this.dataZoomModel, a = this._handleEnds, o = this._getViewExtent(), s = r.findRepresentativeAxisProxy().getMinMaxSpan(), l = [0, 100];
          Ic(i, a, o, r.get("zoomLock") ? "all" : e, s.minSpan != null ? Ne(s.minSpan, l, o, true) : null, s.maxSpan != null ? Ne(s.maxSpan, l, o, true) : null);
          var u = this._range, h = this._range = va([Ne(a[0], o, l, true), Ne(a[1], o, l, true)]);
          return !u || u[0] !== h[0] || u[1] !== h[1];
        }, t.prototype._updateView = function(e) {
          var i = this._displayables, r = this._handleEnds, a = va(r.slice()), o = this._size;
          D([0, 1], function(g) {
            var d = i.handles[g], A = this._handleHeight;
            d.attr({ scaleX: A / 2, scaleY: A / 2, x: r[g] + (g ? -1 : 1), y: o[1] / 2 - A / 2 });
          }, this), i.filler.setShape({ x: a[0], y: 0, width: a[1] - a[0], height: o[1] });
          var s = { x: a[0], width: a[1] - a[0] };
          i.moveHandle && (i.moveHandle.setShape(s), i.moveZone.setShape(s), i.moveZone.getBoundingRect(), i.moveHandleIcon && i.moveHandleIcon.attr("x", s.x + s.width / 2));
          for (var l = i.dataShadowSegs, u = [0, a[0], a[1], o[0]], h = 0; h < l.length; h++) {
            var c = l[h], f = c.getClipPath();
            f || (f = new fe(), c.setClipPath(f)), f.setShape({ x: u[h], y: 0, width: u[h + 1] - u[h], height: o[1] });
          }
          this._updateDataInfo(e);
        }, t.prototype._updateDataInfo = function(e) {
          var i = this.dataZoomModel, r = this._displayables, a = r.handleLabels, o = this._orient, s = ["", ""];
          if (i.get("showDetail")) {
            var l = i.findRepresentativeAxisProxy();
            if (l) {
              var u = l.getAxisModel().axis, h = this._range, c = e ? l.calculateDataWindow({ start: h[0], end: h[1] }).valueWindow : l.getDataValueWindow();
              s = [this._formatLabel(c[0], u), this._formatLabel(c[1], u)];
            }
          }
          var f = va(this._handleEnds.slice());
          g.call(this, 0), g.call(this, 1);
          function g(d) {
            var A = Yh(r.handles[d].parent, this.group), p = V1(d === 0 ? "right" : "left", A), v = this._handleWidth / 2 + iQt, y = no([f[d] + (d === 0 ? -v : v), this._size[1] / 2], A);
            a[d].setStyle({ x: y[0], y: y[1], verticalAlign: o === By ? "middle" : p, align: o === By ? p : "center", text: s[d] });
          }
        }, t.prototype._formatLabel = function(e, i) {
          var r = this.dataZoomModel, a = r.get("labelFormatter"), o = r.get("labelPrecision");
          (o == null || o === "auto") && (o = i.getPixelPrecision());
          var s = e == null || isNaN(e) ? "" : i.type === "category" || i.type === "time" ? i.scale.getLabel({ value: Math.round(e) }) : e.toFixed(Math.min(o, 20));
          return yt(a) ? a(e, s) : ht(a) ? a.replace("{value}", s) : s;
        }, t.prototype._showDataInfo = function(e) {
          e = this._dragging || e;
          var i = this._displayables, r = i.handleLabels;
          r[0].attr("invisible", !e), r[1].attr("invisible", !e), i.moveHandle && this.api[e ? "enterEmphasis" : "leaveEmphasis"](i.moveHandle, 1);
        }, t.prototype._onDragMove = function(e, i, r, a) {
          this._dragging = true, Qs(a.event);
          var o = this._displayables.sliderGroup.getLocalTransform(), s = no([i, r], o, true), l = this._updateInterval(e, s[0]), u = this.dataZoomModel.get("realtime");
          this._updateView(!u), l && u && this._dispatchZoomAction(true);
        }, t.prototype._onDragEnd = function() {
          this._dragging = false, this._showDataInfo(false);
          var e = this.dataZoomModel.get("realtime");
          !e && this._dispatchZoomAction(false);
        }, t.prototype._onClickPanel = function(e) {
          var i = this._size, r = this._displayables.sliderGroup.transformCoordToLocal(e.offsetX, e.offsetY);
          if (!(r[0] < 0 || r[0] > i[0] || r[1] < 0 || r[1] > i[1])) {
            var a = this._handleEnds, o = (a[0] + a[1]) / 2, s = this._updateInterval("all", r[0] - o);
            this._updateView(), s && this._dispatchZoomAction(false);
          }
        }, t.prototype._onBrushStart = function(e) {
          var i = e.offsetX, r = e.offsetY;
          this._brushStart = new jt(i, r), this._brushing = true, this._brushStartTime = +/* @__PURE__ */ new Date();
        }, t.prototype._onBrushEnd = function(e) {
          if (this._brushing) {
            var i = this._displayables.brushRect;
            if (this._brushing = false, !!i) {
              i.attr("ignore", true);
              var r = i.shape, a = +/* @__PURE__ */ new Date();
              if (!(a - this._brushStartTime < 200 && Math.abs(r.width) < 5)) {
                var o = this._getViewExtent(), s = [0, 100];
                this._range = va([Ne(r.x, o, s, true), Ne(r.x + r.width, o, s, true)]), this._handleEnds = [r.x, r.x + r.width], this._updateView(), this._dispatchZoomAction(false);
              }
            }
          }
        }, t.prototype._onBrush = function(e) {
          this._brushing && (Qs(e.event), this._updateBrushRect(e.offsetX, e.offsetY));
        }, t.prototype._updateBrushRect = function(e, i) {
          var r = this._displayables, a = this.dataZoomModel, o = r.brushRect;
          o || (o = r.brushRect = new Ty({ silent: true, style: a.getModel("brushStyle").getItemStyle() }), r.sliderGroup.add(o)), o.attr("ignore", false);
          var s = this._brushStart, l = this._displayables.sliderGroup, u = l.transformCoordToLocal(e, i), h = l.transformCoordToLocal(s.x, s.y), c = this._size;
          u[0] = Math.max(Math.min(c[0], u[0]), 0), o.setShape({ x: h[0], y: 0, width: u[0] - h[0], height: c[1] });
        }, t.prototype._dispatchZoomAction = function(e) {
          var i = this._range;
          this.api.dispatchAction({ type: "dataZoom", from: this.uid, dataZoomId: this.dataZoomModel.id, animation: e ? aQt : null, start: i[0], end: i[1] });
        }, t.prototype._findCoordRect = function() {
          var e, i = kY(this.dataZoomModel).infoList;
          if (!e && i.length) {
            var r = i[0].model.coordinateSystem;
            e = r.getRect && r.getRect();
          }
          if (!e) {
            var a = this.api.getWidth(), o = this.api.getHeight();
            e = { x: a * 0.2, y: o * 0.2, width: a * 0.6, height: o * 0.6 };
          }
          return e;
        }, t.type = "dataZoom.slider", t;
      }($R);
      function sQt(n) {
        var t = { x: "y", y: "x", radius: "angle", angle: "radius" };
        return t[n];
      }
      function qW(n) {
        return n === "vertical" ? "ns-resize" : "ew-resize";
      }
      function HW(n) {
        n.registerComponentModel(tQt), n.registerComponentView(oQt), ZR(n);
      }
      function lQt(n) {
        Kt(UW), Kt(HW);
      }
      var YW = { get: function(n, t, e) {
        var i = Ct((uQt[n] || {})[t]);
        return e && Z(i) ? i[i.length - 1] : i;
      } }, uQt = { color: { active: ["#006edd", "#e0ffff"], inactive: ["rgba(0,0,0,0)"] }, colorHue: { active: [0, 360], inactive: [0, 0] }, colorSaturation: { active: [0.3, 1], inactive: [0, 0] }, colorLightness: { active: [0.9, 0.5], inactive: [0, 0] }, colorAlpha: { active: [0.3, 1], inactive: [0, 0] }, opacity: { active: [0.3, 1], inactive: [0, 0] }, symbol: { active: ["circle", "roundRect", "diamond"], inactive: ["none"] }, symbolSize: { active: [10, 50], inactive: [0, 0] } }, WW = ni.mapVisual, hQt = ni.eachVisual, cQt = Z, XW = D, fQt = va, gQt = Ne, zI = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.stateList = ["inRange", "outOfRange"], e.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"], e.layoutMode = { type: "box", ignoreSize: true }, e.dataBound = [-1 / 0, 1 / 0], e.targetVisuals = {}, e.controllerVisuals = {}, e;
        }
        return t.prototype.init = function(e, i, r) {
          this.mergeDefaultAndTheme(e, r);
        }, t.prototype.optionUpdated = function(e, i) {
          var r = this.option;
          !i && gW(r, e, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
        }, t.prototype.resetVisual = function(e) {
          var i = this.stateList;
          e = ct(e, this), this.controllerVisuals = oL(this.option.controller, i, e), this.targetVisuals = oL(this.option.target, i, e);
        }, t.prototype.getItemSymbol = function() {
          return null;
        }, t.prototype.getTargetSeriesIndices = function() {
          var e = this.option.seriesIndex, i = [];
          return e == null || e === "all" ? this.ecModel.eachSeries(function(r, a) {
            i.push(a);
          }) : i = ze(e), i;
        }, t.prototype.eachTargetSeries = function(e, i) {
          D(this.getTargetSeriesIndices(), function(r) {
            var a = this.ecModel.getSeriesByIndex(r);
            a && e.call(i, a);
          }, this);
        }, t.prototype.isTargetSeries = function(e) {
          var i = false;
          return this.eachTargetSeries(function(r) {
            r === e && (i = true);
          }), i;
        }, t.prototype.formatValueText = function(e, i, r) {
          var a = this.option, o = a.precision, s = this.dataBound, l = a.formatter, u;
          r = r || ["<", ">"], Z(e) && (e = e.slice(), u = true);
          var h = i ? e : u ? [c(e[0]), c(e[1])] : c(e);
          if (ht(l)) return l.replace("{value}", u ? h[0] : h).replace("{value2}", u ? h[1] : h);
          if (yt(l)) return u ? l(e[0], e[1]) : l(e);
          if (u) return e[0] === s[0] ? r[0] + " " + h[1] : e[1] === s[1] ? r[1] + " " + h[0] : h[0] + " - " + h[1];
          return h;
          function c(f) {
            return f === s[0] ? "min" : f === s[1] ? "max" : (+f).toFixed(Math.min(o, 20));
          }
        }, t.prototype.resetExtent = function() {
          var e = this.option, i = fQt([e.min, e.max]);
          this._dataExtent = i;
        }, t.prototype.getDataDimensionIndex = function(e) {
          var i = this.option.dimension;
          if (i != null) return e.getDimensionIndex(i);
          for (var r = e.dimensions, a = r.length - 1; a >= 0; a--) {
            var o = r[a], s = e.getDimensionInfo(o);
            if (!s.isCalculationCoord) return s.storeDimIndex;
          }
        }, t.prototype.getExtent = function() {
          return this._dataExtent.slice();
        }, t.prototype.completeVisualOption = function() {
          var e = this.ecModel, i = this.option, r = { inRange: i.inRange, outOfRange: i.outOfRange }, a = i.target || (i.target = {}), o = i.controller || (i.controller = {});
          Yt(a, r), Yt(o, r);
          var s = this.isCategory();
          l.call(this, a), l.call(this, o), u.call(this, a, "inRange", "outOfRange"), h.call(this, o);
          function l(c) {
            cQt(i.color) && !c.inRange && (c.inRange = { color: i.color.slice().reverse() }), c.inRange = c.inRange || { color: e.get("gradientColor") };
          }
          function u(c, f, g) {
            var d = c[f], A = c[g];
            d && !A && (A = c[g] = {}, XW(d, function(p, v) {
              if (ni.isValidType(v)) {
                var y = YW.get(v, "inactive", s);
                y != null && (A[v] = y, v === "color" && !A.hasOwnProperty("opacity") && !A.hasOwnProperty("colorAlpha") && (A.opacity = [0, 0]));
              }
            }));
          }
          function h(c) {
            var f = (c.inRange || {}).symbol || (c.outOfRange || {}).symbol, g = (c.inRange || {}).symbolSize || (c.outOfRange || {}).symbolSize, d = this.get("inactiveColor"), A = this.getItemSymbol(), p = A || "roundRect";
            XW(this.stateList, function(v) {
              var y = this.itemSize, m = c[v];
              m || (m = c[v] = { color: s ? d : [d] }), m.symbol == null && (m.symbol = f && Ct(f) || (s ? p : [p])), m.symbolSize == null && (m.symbolSize = g && Ct(g) || (s ? y[0] : [y[0], y[0]])), m.symbol = WW(m.symbol, function(E) {
                return E === "none" ? p : E;
              });
              var _ = m.symbolSize;
              if (_ != null) {
                var I = -1 / 0;
                hQt(_, function(E) {
                  E > I && (I = E);
                }), m.symbolSize = WW(_, function(E) {
                  return gQt(E, [0, I], [0, y[0]], true);
                });
              }
            }, this);
          }
        }, t.prototype.resetItemSize = function() {
          this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
        }, t.prototype.isCategory = function() {
          return !!this.option.categories;
        }, t.prototype.setSelected = function(e) {
        }, t.prototype.getSelected = function() {
          return null;
        }, t.prototype.getValueState = function(e) {
          return null;
        }, t.prototype.getVisualMeta = function(e) {
          return null;
        }, t.type = "visualMap", t.dependencies = ["series"], t.defaultOption = { show: true, z: 4, seriesIndex: "all", min: 0, max: 200, left: 0, right: null, top: null, bottom: 0, itemWidth: null, itemHeight: null, inverse: false, orient: "vertical", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", contentColor: "#5793f3", inactiveColor: "#aaa", borderWidth: 0, padding: 5, textGap: 10, precision: 0, textStyle: { color: "#333" } }, t;
      }(ae), $W = [20, 140], dQt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.optionUpdated = function(e, i) {
          n.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(r) {
            r.mappingMethod = "linear", r.dataExtent = this.getExtent();
          }), this._resetRange();
        }, t.prototype.resetItemSize = function() {
          n.prototype.resetItemSize.apply(this, arguments);
          var e = this.itemSize;
          (e[0] == null || isNaN(e[0])) && (e[0] = $W[0]), (e[1] == null || isNaN(e[1])) && (e[1] = $W[1]);
        }, t.prototype._resetRange = function() {
          var e = this.getExtent(), i = this.option.range;
          !i || i.auto ? (e.auto = 1, this.option.range = e) : Z(i) && (i[0] > i[1] && i.reverse(), i[0] = Math.max(i[0], e[0]), i[1] = Math.min(i[1], e[1]));
        }, t.prototype.completeVisualOption = function() {
          n.prototype.completeVisualOption.apply(this, arguments), D(this.stateList, function(e) {
            var i = this.option.controller[e].symbolSize;
            i && i[0] !== i[1] && (i[0] = i[1] / 3);
          }, this);
        }, t.prototype.setSelected = function(e) {
          this.option.range = e.slice(), this._resetRange();
        }, t.prototype.getSelected = function() {
          var e = this.getExtent(), i = va((this.get("range") || []).slice());
          return i[0] > e[1] && (i[0] = e[1]), i[1] > e[1] && (i[1] = e[1]), i[0] < e[0] && (i[0] = e[0]), i[1] < e[0] && (i[1] = e[0]), i;
        }, t.prototype.getValueState = function(e) {
          var i = this.option.range, r = this.getExtent();
          return (i[0] <= r[0] || i[0] <= e) && (i[1] >= r[1] || e <= i[1]) ? "inRange" : "outOfRange";
        }, t.prototype.findTargetDataIndices = function(e) {
          var i = [];
          return this.eachTargetSeries(function(r) {
            var a = [], o = r.getData();
            o.each(this.getDataDimensionIndex(o), function(s, l) {
              e[0] <= s && s <= e[1] && a.push(l);
            }, this), i.push({ seriesId: r.id, dataIndex: a });
          }, this), i;
        }, t.prototype.getVisualMeta = function(e) {
          var i = ZW(this, "outOfRange", this.getExtent()), r = ZW(this, "inRange", this.option.range.slice()), a = [];
          function o(g, d) {
            a.push({ value: g, color: e(g, d) });
          }
          for (var s = 0, l = 0, u = r.length, h = i.length; l < h && (!r.length || i[l] <= r[0]); l++) i[l] < r[s] && o(i[l], "outOfRange");
          for (var c = 1; s < u; s++, c = 0) c && a.length && o(r[s], "outOfRange"), o(r[s], "inRange");
          for (var c = 1; l < h; l++) (!r.length || r[r.length - 1] < i[l]) && (c && (a.length && o(a[a.length - 1].value, "outOfRange"), c = 0), o(i[l], "outOfRange"));
          var f = a.length;
          return { stops: a, outerColors: [f ? a[0].color : "transparent", f ? a[f - 1].color : "transparent"] };
        }, t.type = "visualMap.continuous", t.defaultOption = cu(zI.defaultOption, { align: "auto", calculable: false, hoverLink: true, realtime: true, handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z", handleSize: "120%", handleStyle: { borderColor: "#fff", borderWidth: 1 }, indicatorIcon: "circle", indicatorSize: "50%", indicatorStyle: { borderColor: "#fff", borderWidth: 2, shadowBlur: 2, shadowOffsetX: 1, shadowOffsetY: 1, shadowColor: "rgba(0,0,0,0.2)" } }), t;
      }(zI);
      function ZW(n, t, e) {
        if (e[0] === e[1]) return e.slice();
        for (var i = 200, r = (e[1] - e[0]) / i, a = e[0], o = [], s = 0; s <= i && a < e[1]; s++) o.push(a), a += r;
        return o.push(e[1]), o;
      }
      var KW = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e.autoPositionValues = { left: 1, right: 1, top: 1, bottom: 1 }, e;
        }
        return t.prototype.init = function(e, i) {
          this.ecModel = e, this.api = i;
        }, t.prototype.render = function(e, i, r, a) {
          if (this.visualMapModel = e, e.get("show") === false) {
            this.group.removeAll();
            return;
          }
          this.doRender(e, i, r, a);
        }, t.prototype.renderBackground = function(e) {
          var i = this.visualMapModel, r = Zg(i.get("padding") || 0), a = e.getBoundingRect();
          e.add(new fe({ z2: -1, silent: true, shape: { x: a.x - r[3], y: a.y - r[0], width: a.width + r[3] + r[1], height: a.height + r[0] + r[2] }, style: { fill: i.get("backgroundColor"), stroke: i.get("borderColor"), lineWidth: i.get("borderWidth") } }));
        }, t.prototype.getControllerVisual = function(e, i, r) {
          r = r || {};
          var a = r.forceState, o = this.visualMapModel, s = {};
          if (i === "color") {
            var l = o.get("contentColor");
            s.color = l;
          }
          function u(g) {
            return s[g];
          }
          function h(g, d) {
            s[g] = d;
          }
          var c = o.controllerVisuals[a || o.getValueState(e)], f = ni.prepareVisualTypes(c);
          return D(f, function(g) {
            var d = c[g];
            r.convertOpacityToAlpha && g === "opacity" && (g = "colorAlpha", d = c.__alphaForOpacity), ni.dependsOn(g, i) && d && d.applyVisual(e, u, h);
          }), s[i];
        }, t.prototype.positionGroup = function(e) {
          var i = this.visualMapModel, r = this.api;
          nE(e, i.getBoxLayoutParams(), { width: r.getWidth(), height: r.getHeight() });
        }, t.prototype.doRender = function(e, i, r, a) {
        }, t.type = "visualMap", t;
      }(un), JW = [["left", "right", "width"], ["top", "bottom", "height"]];
      function tX(n, t, e) {
        var i = n.option, r = i.align;
        if (r != null && r !== "auto") return r;
        for (var a = { width: t.getWidth(), height: t.getHeight() }, o = i.orient === "horizontal" ? 1 : 0, s = JW[o], l = [0, null, 10], u = {}, h = 0; h < 3; h++) u[JW[1 - o][h]] = l[h], u[s[h]] = h === 2 ? e[0] : i[s[h]];
        var c = [["x", "width", 3], ["y", "height", 0]][o], f = Yn(u, a, i.padding);
        return s[(f.margin[c[2]] || 0) + f[c[0]] + f[c[1]] * 0.5 < a[c[1]] * 0.5 ? 0 : 1];
      }
      function GI(n, t) {
        return D(n || [], function(e) {
          e.dataIndex != null && (e.dataIndexInside = e.dataIndex, e.dataIndex = null), e.highlightKey = "visualMap" + (t ? t.componentIndex : "");
        }), n;
      }
      var ss = Ne, AQt = D, eX = Math.min, bL = Math.max, pQt = 12, vQt = 6, yQt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._shapes = {}, e._dataInterval = [], e._handleEnds = [], e._hoverLinkDataIndices = [], e;
        }
        return t.prototype.init = function(e, i) {
          n.prototype.init.call(this, e, i), this._hoverLinkFromSeriesMouseOver = ct(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = ct(this._hideIndicator, this);
        }, t.prototype.doRender = function(e, i, r, a) {
          (!a || a.type !== "selectDataRange" || a.from !== this.uid) && this._buildView();
        }, t.prototype._buildView = function() {
          this.group.removeAll();
          var e = this.visualMapModel, i = this.group;
          this._orient = e.get("orient"), this._useHandle = e.get("calculable"), this._resetInterval(), this._renderBar(i);
          var r = e.get("text");
          this._renderEndsText(i, r, 0), this._renderEndsText(i, r, 1), this._updateView(true), this.renderBackground(i), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(i);
        }, t.prototype._renderEndsText = function(e, i, r) {
          if (i) {
            var a = i[1 - r];
            a = a != null ? a + "" : "";
            var o = this.visualMapModel, s = o.get("textGap"), l = o.itemSize, u = this._shapes.mainGroup, h = this._applyTransform([l[0] / 2, r === 0 ? -s : l[1] + s], u), c = this._applyTransform(r === 0 ? "bottom" : "top", u), f = this._orient, g = this.visualMapModel.textStyleModel;
            this.group.add(new Ae({ style: Je(g, { x: h[0], y: h[1], verticalAlign: f === "horizontal" ? "middle" : c, align: f === "horizontal" ? c : "center", text: a }) }));
          }
        }, t.prototype._renderBar = function(e) {
          var i = this.visualMapModel, r = this._shapes, a = i.itemSize, o = this._orient, s = this._useHandle, l = tX(i, this.api, a), u = r.mainGroup = this._createBarGroup(l), h = new Dt();
          u.add(h), h.add(r.outOfRange = nX()), h.add(r.inRange = nX(null, s ? rX(this._orient) : null, ct(this._dragHandle, this, "all", false), ct(this._dragHandle, this, "all", true))), h.setClipPath(new fe({ shape: { x: 0, y: 0, width: a[0], height: a[1], r: 3 } }));
          var c = i.textStyleModel.getTextRect(""), f = bL(c.width, c.height);
          s && (r.handleThumbs = [], r.handleLabels = [], r.handleLabelPoints = [], this._createHandle(i, u, 0, a, f, o), this._createHandle(i, u, 1, a, f, o)), this._createIndicator(i, u, a, f, o), e.add(u);
        }, t.prototype._createHandle = function(e, i, r, a, o, s) {
          var l = ct(this._dragHandle, this, r, false), u = ct(this._dragHandle, this, r, true), h = Za(e.get("handleSize"), a[0]), c = Un(e.get("handleIcon"), -h / 2, -h / 2, h, h, null, true), f = rX(this._orient);
          c.attr({ cursor: f, draggable: true, drift: l, ondragend: u, onmousemove: function(v) {
            Qs(v.event);
          } }), c.x = a[0] / 2, c.useStyle(e.getModel("handleStyle").getItemStyle()), c.setStyle({ strokeNoScale: true, strokeFirst: true }), c.style.lineWidth *= 2, c.ensureState("emphasis").style = e.getModel(["emphasis", "handleStyle"]).getItemStyle(), Vh(c, true), i.add(c);
          var g = this.visualMapModel.textStyleModel, d = new Ae({ cursor: f, draggable: true, drift: l, onmousemove: function(v) {
            Qs(v.event);
          }, ondragend: u, style: Je(g, { x: 0, y: 0, text: "" }) });
          d.ensureState("blur").style = { opacity: 0.1 }, d.stateTransition = { duration: 200 }, this.group.add(d);
          var A = [h, 0], p = this._shapes;
          p.handleThumbs[r] = c, p.handleLabelPoints[r] = A, p.handleLabels[r] = d;
        }, t.prototype._createIndicator = function(e, i, r, a, o) {
          var s = Za(e.get("indicatorSize"), r[0]), l = Un(e.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, true);
          l.attr({ cursor: "move", invisible: true, silent: true, x: r[0] / 2 });
          var u = e.getModel("indicatorStyle").getItemStyle();
          if (l instanceof gi) {
            var h = l.style;
            l.useStyle(X({ image: h.image, x: h.x, y: h.y, width: h.width, height: h.height }, u));
          } else l.useStyle(u);
          i.add(l);
          var c = this.visualMapModel.textStyleModel, f = new Ae({ silent: true, invisible: true, style: Je(c, { x: 0, y: 0, text: "" }) });
          this.group.add(f);
          var g = [(o === "horizontal" ? a / 2 : vQt) + r[0] / 2, 0], d = this._shapes;
          d.indicator = l, d.indicatorLabel = f, d.indicatorLabelPoint = g, this._firstShowIndicator = true;
        }, t.prototype._dragHandle = function(e, i, r, a) {
          if (this._useHandle) {
            if (this._dragging = !i, !i) {
              var o = this._applyTransform([r, a], this._shapes.mainGroup, true);
              this._updateInterval(e, o[1]), this._hideIndicator(), this._updateView();
            }
            i === !this.visualMapModel.get("realtime") && this.api.dispatchAction({ type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: this._dataInterval.slice() }), i ? !this._hovering && this._clearHoverLinkToSeries() : iX(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[e], false);
          }
        }, t.prototype._resetInterval = function() {
          var e = this.visualMapModel, i = this._dataInterval = e.getSelected(), r = e.getExtent(), a = [0, e.itemSize[1]];
          this._handleEnds = [ss(i[0], r, a, true), ss(i[1], r, a, true)];
        }, t.prototype._updateInterval = function(e, i) {
          i = i || 0;
          var r = this.visualMapModel, a = this._handleEnds, o = [0, r.itemSize[1]];
          Ic(i, a, o, e, 0);
          var s = r.getExtent();
          this._dataInterval = [ss(a[0], o, s, true), ss(a[1], o, s, true)];
        }, t.prototype._updateView = function(e) {
          var i = this.visualMapModel, r = i.getExtent(), a = this._shapes, o = [0, i.itemSize[1]], s = e ? o : this._handleEnds, l = this._createBarVisual(this._dataInterval, r, s, "inRange"), u = this._createBarVisual(r, r, o, "outOfRange");
          a.inRange.setStyle({ fill: l.barColor }).setShape("points", l.barPoints), a.outOfRange.setStyle({ fill: u.barColor }).setShape("points", u.barPoints), this._updateHandle(s, l);
        }, t.prototype._createBarVisual = function(e, i, r, a) {
          var o = { forceState: a, convertOpacityToAlpha: true }, s = this._makeColorGradient(e, o), l = [this.getControllerVisual(e[0], "symbolSize", o), this.getControllerVisual(e[1], "symbolSize", o)], u = this._createBarPoints(r, l);
          return { barColor: new dv(0, 0, 0, 1, s), barPoints: u, handlesColor: [s[0].color, s[s.length - 1].color] };
        }, t.prototype._makeColorGradient = function(e, i) {
          var r = 100, a = [], o = (e[1] - e[0]) / r;
          a.push({ color: this.getControllerVisual(e[0], "color", i), offset: 0 });
          for (var s = 1; s < r; s++) {
            var l = e[0] + o * s;
            if (l > e[1]) break;
            a.push({ color: this.getControllerVisual(l, "color", i), offset: s / r });
          }
          return a.push({ color: this.getControllerVisual(e[1], "color", i), offset: 1 }), a;
        }, t.prototype._createBarPoints = function(e, i) {
          var r = this.visualMapModel.itemSize;
          return [[r[0] - i[0], e[0]], [r[0], e[0]], [r[0], e[1]], [r[0] - i[1], e[1]]];
        }, t.prototype._createBarGroup = function(e) {
          var i = this._orient, r = this.visualMapModel.get("inverse");
          return new Dt(i === "horizontal" && !r ? { scaleX: e === "bottom" ? 1 : -1, rotation: Math.PI / 2 } : i === "horizontal" && r ? { scaleX: e === "bottom" ? -1 : 1, rotation: -Math.PI / 2 } : i === "vertical" && !r ? { scaleX: e === "left" ? 1 : -1, scaleY: -1 } : { scaleX: e === "left" ? 1 : -1 });
        }, t.prototype._updateHandle = function(e, i) {
          if (this._useHandle) {
            var r = this._shapes, a = this.visualMapModel, o = r.handleThumbs, s = r.handleLabels, l = a.itemSize, u = a.getExtent();
            AQt([0, 1], function(h) {
              var c = o[h];
              c.setStyle("fill", i.handlesColor[h]), c.y = e[h];
              var f = ss(e[h], [0, l[1]], u, true), g = this.getControllerVisual(f, "symbolSize");
              c.scaleX = c.scaleY = g / l[0], c.x = l[0] - g / 2;
              var d = no(r.handleLabelPoints[h], Yh(c, this.group));
              s[h].setStyle({ x: d[0], y: d[1], text: a.formatValueText(this._dataInterval[h]), verticalAlign: "middle", align: this._orient === "vertical" ? this._applyTransform("left", r.mainGroup) : "center" });
            }, this);
          }
        }, t.prototype._showIndicator = function(e, i, r, a) {
          var o = this.visualMapModel, s = o.getExtent(), l = o.itemSize, u = [0, l[1]], h = this._shapes, c = h.indicator;
          if (c) {
            c.attr("invisible", false);
            var f = { convertOpacityToAlpha: true }, g = this.getControllerVisual(e, "color", f), d = this.getControllerVisual(e, "symbolSize"), A = ss(e, s, u, true), p = l[0] - d / 2, v = { x: c.x, y: c.y };
            c.y = A, c.x = p;
            var y = no(h.indicatorLabelPoint, Yh(c, this.group)), m = h.indicatorLabel;
            m.attr("invisible", false);
            var _ = this._applyTransform("left", h.mainGroup), I = this._orient, E = I === "horizontal";
            m.setStyle({ text: (r || "") + o.formatValueText(i), verticalAlign: E ? _ : "middle", align: E ? "center" : _ });
            var x = { x: p, y: A, style: { fill: g } }, w = { style: { x: y[0], y: y[1] } };
            if (o.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
              var C = { duration: 100, easing: "cubicInOut", additive: true };
              c.x = v.x, c.y = v.y, c.animateTo(x, C), m.animateTo(w, C);
            } else c.attr(x), m.attr(w);
            this._firstShowIndicator = false;
            var S = this._shapes.handleLabels;
            if (S) for (var b = 0; b < S.length; b++) this.api.enterBlur(S[b]);
          }
        }, t.prototype._enableHoverLinkToSeries = function() {
          var e = this;
          this._shapes.mainGroup.on("mousemove", function(i) {
            if (e._hovering = true, !e._dragging) {
              var r = e.visualMapModel.itemSize, a = e._applyTransform([i.offsetX, i.offsetY], e._shapes.mainGroup, true, true);
              a[1] = eX(bL(0, a[1]), r[1]), e._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= r[0]);
            }
          }).on("mouseout", function() {
            e._hovering = false, !e._dragging && e._clearHoverLinkToSeries();
          });
        }, t.prototype._enableHoverLinkFromSeries = function() {
          var e = this.api.getZr();
          this.visualMapModel.option.hoverLink ? (e.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), e.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
        }, t.prototype._doHoverLinkToSeries = function(e, i) {
          var r = this.visualMapModel, a = r.itemSize;
          if (r.option.hoverLink) {
            var o = [0, a[1]], s = r.getExtent();
            e = eX(bL(o[0], e), o[1]);
            var l = mQt(r, s, o), u = [e - l, e + l], h = ss(e, o, s, true), c = [ss(u[0], o, s, true), ss(u[1], o, s, true)];
            u[0] < o[0] && (c[0] = -1 / 0), u[1] > o[1] && (c[1] = 1 / 0), i && (c[0] === -1 / 0 ? this._showIndicator(h, c[1], "< ", l) : c[1] === 1 / 0 ? this._showIndicator(h, c[0], "> ", l) : this._showIndicator(h, h, " ", l));
            var f = this._hoverLinkDataIndices, g = [];
            (i || iX(r)) && (g = this._hoverLinkDataIndices = r.findTargetDataIndices(c));
            var d = CEt(f, g);
            this._dispatchHighDown("downplay", GI(d[0], r)), this._dispatchHighDown("highlight", GI(d[1], r));
          }
        }, t.prototype._hoverLinkFromSeriesMouseOver = function(e) {
          var i;
          if (ec(e.target, function(l) {
            var u = Nt(l);
            if (u.dataIndex != null) return i = u, true;
          }, true), !!i) {
            var r = this.ecModel.getSeriesByIndex(i.seriesIndex), a = this.visualMapModel;
            if (a.isTargetSeries(r)) {
              var o = r.getData(i.dataType), s = o.getStore().get(a.getDataDimensionIndex(o), i.dataIndex);
              isNaN(s) || this._showIndicator(s, s);
            }
          }
        }, t.prototype._hideIndicator = function() {
          var e = this._shapes;
          e.indicator && e.indicator.attr("invisible", true), e.indicatorLabel && e.indicatorLabel.attr("invisible", true);
          var i = this._shapes.handleLabels;
          if (i) for (var r = 0; r < i.length; r++) this.api.leaveBlur(i[r]);
        }, t.prototype._clearHoverLinkToSeries = function() {
          this._hideIndicator();
          var e = this._hoverLinkDataIndices;
          this._dispatchHighDown("downplay", GI(e, this.visualMapModel)), e.length = 0;
        }, t.prototype._clearHoverLinkFromSeries = function() {
          this._hideIndicator();
          var e = this.api.getZr();
          e.off("mouseover", this._hoverLinkFromSeriesMouseOver), e.off("mouseout", this._hideIndicator);
        }, t.prototype._applyTransform = function(e, i, r, a) {
          var o = Yh(i, a ? null : this.group);
          return Z(e) ? no(e, o, r) : V1(e, o, r);
        }, t.prototype._dispatchHighDown = function(e, i) {
          i && i.length && this.api.dispatchAction({ type: e, batch: i });
        }, t.prototype.dispose = function() {
          this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
        }, t.type = "visualMap.continuous", t;
      }(KW);
      function nX(n, t, e, i) {
        return new Ki({ shape: { points: n }, draggable: !!e, cursor: t, drift: e, onmousemove: function(r) {
          Qs(r.event);
        }, ondragend: i });
      }
      function mQt(n, t, e) {
        var i = pQt / 2, r = n.get("hoverLinkDataSize");
        return r && (i = ss(r, t, e, true) / 2), i;
      }
      function iX(n) {
        var t = n.get("hoverLinkOnHandle");
        return !!(t == null ? n.get("realtime") : t);
      }
      function rX(n) {
        return n === "vertical" ? "ns-resize" : "ew-resize";
      }
      var _Qt = { type: "selectDataRange", event: "dataRangeSelected", update: "update" }, EQt = function(n, t) {
        t.eachComponent({ mainType: "visualMap", query: n }, function(e) {
          e.setSelected(n.selected);
        });
      }, IQt = [{ createOnAllSeries: true, reset: function(n, t) {
        var e = [];
        return t.eachComponent("visualMap", function(i) {
          var r = n.pipelineContext;
          !i.isTargetSeries(n) || r && r.large || e.push(jkt(i.stateList, i.targetVisuals, ct(i.getValueState, i), i.getDataDimensionIndex(n.getData())));
        }), e;
      } }, { createOnAllSeries: true, reset: function(n, t) {
        var e = n.getData(), i = [];
        t.eachComponent("visualMap", function(r) {
          if (r.isTargetSeries(n)) {
            var a = r.getVisualMeta(ct(xQt, null, n, r)) || { stops: [], outerColors: [] }, o = r.getDataDimensionIndex(e);
            o >= 0 && (a.dimension = o, i.push(a));
          }
        }), n.getData().setVisual("visualMeta", i);
      } }];
      function xQt(n, t, e, i) {
        for (var r = t.targetVisuals[i], a = ni.prepareVisualTypes(r), o = { color: Lv(n.getData(), "color") }, s = 0, l = a.length; s < l; s++) {
          var u = a[s], h = r[u === "opacity" ? "__alphaForOpacity" : u];
          h && h.applyVisual(e, c, f);
        }
        return o.color;
        function c(g) {
          return o[g];
        }
        function f(g, d) {
          o[g] = d;
        }
      }
      var aX = D;
      function wQt(n) {
        var t = n && n.visualMap;
        Z(t) || (t = t ? [t] : []), aX(t, function(e) {
          if (e) {
            Rd(e, "splitList") && !Rd(e, "pieces") && (e.pieces = e.splitList, delete e.splitList);
            var i = e.pieces;
            i && Z(i) && aX(i, function(r) {
              Et(r) && (Rd(r, "start") && !Rd(r, "min") && (r.min = r.start), Rd(r, "end") && !Rd(r, "max") && (r.max = r.end));
            });
          }
        });
      }
      function Rd(n, t) {
        return n && n.hasOwnProperty && n.hasOwnProperty(t);
      }
      var oX = false;
      function sX(n) {
        oX || (oX = true, n.registerSubTypeDefaulter("visualMap", function(t) {
          return !t.categories && (!(t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) || t.calculable) ? "continuous" : "piecewise";
        }), n.registerAction(_Qt, EQt), D(IQt, function(t) {
          n.registerVisual(n.PRIORITY.VISUAL.COMPONENT, t);
        }), n.registerPreprocessor(wQt));
      }
      function lX(n) {
        n.registerComponentModel(dQt), n.registerComponentView(yQt), sX(n);
      }
      var CQt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e._pieceList = [], e;
        }
        return t.prototype.optionUpdated = function(e, i) {
          n.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
          var r = this._mode = this._determineMode();
          this._pieceList = [], SQt[this._mode].call(this, this._pieceList), this._resetSelected(e, i);
          var a = this.option.categories;
          this.resetVisual(function(o, s) {
            r === "categories" ? (o.mappingMethod = "category", o.categories = Ct(a)) : (o.dataExtent = this.getExtent(), o.mappingMethod = "piecewise", o.pieceList = K(this._pieceList, function(l) {
              return l = Ct(l), s !== "inRange" && (l.visual = null), l;
            }));
          });
        }, t.prototype.completeVisualOption = function() {
          var e = this.option, i = {}, r = ni.listVisualTypes(), a = this.isCategory();
          D(e.pieces, function(s) {
            D(r, function(l) {
              s.hasOwnProperty(l) && (i[l] = 1);
            });
          }), D(i, function(s, l) {
            var u = false;
            D(this.stateList, function(h) {
              u = u || o(e, h, l) || o(e.target, h, l);
            }, this), !u && D(this.stateList, function(h) {
              (e[h] || (e[h] = {}))[l] = YW.get(l, h === "inRange" ? "active" : "inactive", a);
            });
          }, this);
          function o(s, l, u) {
            return s && s[l] && s[l].hasOwnProperty(u);
          }
          n.prototype.completeVisualOption.apply(this, arguments);
        }, t.prototype._resetSelected = function(e, i) {
          var r = this.option, a = this._pieceList, o = (i ? r : e).selected || {};
          if (r.selected = o, D(a, function(l, u) {
            var h = this.getSelectedMapKey(l);
            o.hasOwnProperty(h) || (o[h] = true);
          }, this), r.selectedMode === "single") {
            var s = false;
            D(a, function(l, u) {
              var h = this.getSelectedMapKey(l);
              o[h] && (s ? o[h] = false : s = true);
            }, this);
          }
        }, t.prototype.getItemSymbol = function() {
          return this.get("itemSymbol");
        }, t.prototype.getSelectedMapKey = function(e) {
          return this._mode === "categories" ? e.value + "" : e.index + "";
        }, t.prototype.getPieceList = function() {
          return this._pieceList;
        }, t.prototype._determineMode = function() {
          var e = this.option;
          return e.pieces && e.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
        }, t.prototype.setSelected = function(e) {
          this.option.selected = Ct(e);
        }, t.prototype.getValueState = function(e) {
          var i = ni.findPieceIndex(e, this._pieceList);
          return i != null && this.option.selected[this.getSelectedMapKey(this._pieceList[i])] ? "inRange" : "outOfRange";
        }, t.prototype.findTargetDataIndices = function(e) {
          var i = [], r = this._pieceList;
          return this.eachTargetSeries(function(a) {
            var o = [], s = a.getData();
            s.each(this.getDataDimensionIndex(s), function(l, u) {
              var h = ni.findPieceIndex(l, r);
              h === e && o.push(u);
            }, this), i.push({ seriesId: a.id, dataIndex: o });
          }, this), i;
        }, t.prototype.getRepresentValue = function(e) {
          var i;
          if (this.isCategory()) i = e.value;
          else if (e.value != null) i = e.value;
          else {
            var r = e.interval || [];
            i = r[0] === -1 / 0 && r[1] === 1 / 0 ? 0 : (r[0] + r[1]) / 2;
          }
          return i;
        }, t.prototype.getVisualMeta = function(e) {
          if (this.isCategory()) return;
          var i = [], r = ["", ""], a = this;
          function o(h, c) {
            var f = a.getRepresentValue({ interval: h });
            c || (c = a.getValueState(f));
            var g = e(f, c);
            h[0] === -1 / 0 ? r[0] = g : h[1] === 1 / 0 ? r[1] = g : i.push({ value: h[0], color: g }, { value: h[1], color: g });
          }
          var s = this._pieceList.slice();
          if (!s.length) s.push({ interval: [-1 / 0, 1 / 0] });
          else {
            var l = s[0].interval[0];
            l !== -1 / 0 && s.unshift({ interval: [-1 / 0, l] }), l = s[s.length - 1].interval[1], l !== 1 / 0 && s.push({ interval: [l, 1 / 0] });
          }
          var u = -1 / 0;
          return D(s, function(h) {
            var c = h.interval;
            c && (c[0] > u && o([u, c[0]], "outOfRange"), o(c.slice()), u = c[1]);
          }, this), { stops: i, outerColors: r };
        }, t.type = "visualMap.piecewise", t.defaultOption = cu(zI.defaultOption, { selected: null, minOpen: false, maxOpen: false, align: "auto", itemWidth: 20, itemHeight: 14, itemSymbol: "roundRect", pieces: null, categories: null, splitNumber: 5, selectedMode: "multiple", itemGap: 10, hoverLink: true }), t;
      }(zI), SQt = { splitNumber: function(n) {
        var t = this.option, e = Math.min(t.precision, 20), i = this.getExtent(), r = t.splitNumber;
        r = Math.max(parseInt(r, 10), 1), t.splitNumber = r;
        for (var a = (i[1] - i[0]) / r; +a.toFixed(e) !== a && e < 5; ) e++;
        t.precision = e, a = +a.toFixed(e), t.minOpen && n.push({ interval: [-1 / 0, i[0]], close: [0, 0] });
        for (var o = 0, s = i[0]; o < r; s += a, o++) {
          var l = o === r - 1 ? i[1] : s + a;
          n.push({ interval: [s, l], close: [1, 1] });
        }
        t.maxOpen && n.push({ interval: [i[1], 1 / 0], close: [0, 0] }), l4(n), D(n, function(u, h) {
          u.index = h, u.text = this.formatValueText(u.interval);
        }, this);
      }, categories: function(n) {
        var t = this.option;
        D(t.categories, function(e) {
          n.push({ text: this.formatValueText(e, true), value: e });
        }, this), uX(t, n);
      }, pieces: function(n) {
        var t = this.option;
        D(t.pieces, function(e, i) {
          Et(e) || (e = { value: e });
          var r = { text: "", index: i };
          if (e.label != null && (r.text = e.label), e.hasOwnProperty("value")) {
            var a = r.value = e.value;
            r.interval = [a, a], r.close = [1, 1];
          } else {
            for (var o = r.interval = [], s = r.close = [0, 0], l = [1, 0, 1], u = [-1 / 0, 1 / 0], h = [], c = 0; c < 2; c++) {
              for (var f = [["gte", "gt", "min"], ["lte", "lt", "max"]][c], g = 0; g < 3 && o[c] == null; g++) o[c] = e[f[g]], s[c] = l[g], h[c] = g === 2;
              o[c] == null && (o[c] = u[c]);
            }
            h[0] && o[1] === 1 / 0 && (s[0] = 0), h[1] && o[0] === -1 / 0 && (s[1] = 0), o[0] > o[1], o[0] === o[1] && s[0] && s[1] && (r.value = o[0]);
          }
          r.visual = ni.retrieveVisuals(e), n.push(r);
        }, this), uX(t, n), l4(n), D(n, function(e) {
          var i = e.close, r = [["<", ""][i[1]], [">", ""][i[0]]];
          e.text = e.text || this.formatValueText(e.value != null ? e.value : e.interval, false, r);
        }, this);
      } };
      function uX(n, t) {
        var e = n.inverse;
        (n.orient === "vertical" ? !e : e) && t.reverse();
      }
      var bQt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = t.type, e;
        }
        return t.prototype.doRender = function() {
          var e = this.group;
          e.removeAll();
          var i = this.visualMapModel, r = i.get("textGap"), a = i.textStyleModel, o = a.getFont(), s = a.getTextColor(), l = this._getItemAlign(), u = i.itemSize, h = this._getViewData(), c = h.endsText, f = On(i.get("showLabel", true), !c);
          c && this._renderEndsText(e, c[0], u, f, l), D(h.viewPieceList, function(g) {
            var d = g.piece, A = new Dt();
            A.onclick = ct(this._onItemClick, this, d), this._enableHoverLink(A, g.indexInModelPieceList);
            var p = i.getRepresentValue(d);
            if (this._createItemSymbol(A, p, [0, 0, u[0], u[1]]), f) {
              var v = this.visualMapModel.getValueState(p);
              A.add(new Ae({ style: { x: l === "right" ? -r : u[0] + r, y: u[1] / 2, text: d.text, verticalAlign: "middle", align: l, font: o, fill: s, opacity: v === "outOfRange" ? 0.5 : 1 } }));
            }
            e.add(A);
          }, this), c && this._renderEndsText(e, c[1], u, f, l), Zh(i.get("orient"), e, i.get("itemGap")), this.renderBackground(e), this.positionGroup(e);
        }, t.prototype._enableHoverLink = function(e, i) {
          var r = this;
          e.on("mouseover", function() {
            return a("highlight");
          }).on("mouseout", function() {
            return a("downplay");
          });
          var a = function(o) {
            var s = r.visualMapModel;
            s.option.hoverLink && r.api.dispatchAction({ type: o, batch: GI(s.findTargetDataIndices(i), s) });
          };
        }, t.prototype._getItemAlign = function() {
          var e = this.visualMapModel, i = e.option;
          if (i.orient === "vertical") return tX(e, this.api, e.itemSize);
          var r = i.align;
          return (!r || r === "auto") && (r = "left"), r;
        }, t.prototype._renderEndsText = function(e, i, r, a, o) {
          if (i) {
            var s = new Dt(), l = this.visualMapModel.textStyleModel;
            s.add(new Ae({ style: Je(l, { x: a ? o === "right" ? r[0] : 0 : r[0] / 2, y: r[1] / 2, verticalAlign: "middle", align: a ? o : "center", text: i }) })), e.add(s);
          }
        }, t.prototype._getViewData = function() {
          var e = this.visualMapModel, i = K(e.getPieceList(), function(s, l) {
            return { piece: s, indexInModelPieceList: l };
          }), r = e.get("text"), a = e.get("orient"), o = e.get("inverse");
          return (a === "horizontal" ? o : !o) ? i.reverse() : r && (r = r.slice().reverse()), { viewPieceList: i, endsText: r };
        }, t.prototype._createItemSymbol = function(e, i, r) {
          e.add(Un(this.getControllerVisual(i, "symbol"), r[0], r[1], r[2], r[3], this.getControllerVisual(i, "color")));
        }, t.prototype._onItemClick = function(e) {
          var i = this.visualMapModel, r = i.option, a = r.selectedMode;
          if (a) {
            var o = Ct(r.selected), s = i.getSelectedMapKey(e);
            a === "single" || a === true ? (o[s] = true, D(o, function(l, u) {
              o[u] = u === s;
            })) : o[s] = !o[s], this.api.dispatchAction({ type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: o });
          }
        }, t.type = "visualMap.piecewise", t;
      }(KW);
      function hX(n) {
        n.registerComponentModel(CQt), n.registerComponentView(bQt), sX(n);
      }
      function TQt(n) {
        Kt(lX), Kt(hX);
      }
      var BQt = { label: { enabled: true }, decal: { show: false } }, cX = ce(), MQt = {};
      function DQt(n, t) {
        var e = n.getModel("aria");
        if (!e.get("enabled")) return;
        var i = Ct(BQt);
        Yt(i.label, n.getLocaleModel().get("aria"), false), Yt(e.option, i, false), r(), a();
        function r() {
          var u = e.getModel("decal"), h = u.get("show");
          if (h) {
            var c = dt();
            n.eachSeries(function(f) {
              if (!f.isColorBySeries()) {
                var g = c.get(f.type);
                g || (g = {}, c.set(f.type, g)), cX(f).scope = g;
              }
            }), n.eachRawSeries(function(f) {
              if (n.isSeriesFiltered(f)) return;
              if (yt(f.enableAriaDecal)) {
                f.enableAriaDecal();
                return;
              }
              var g = f.getData();
              if (f.isColorBySeries()) {
                var y = bB(f.ecModel, f.name, MQt, n.getSeriesCount()), m = g.getVisual("decal");
                g.setVisual("decal", _(m, y));
              } else {
                var d = f.getRawData(), A = {}, p = cX(f).scope;
                g.each(function(I) {
                  var E = g.getRawIndex(I);
                  A[E] = I;
                });
                var v = d.count();
                d.each(function(I) {
                  var E = A[I], x = d.getName(I) || I + "", w = bB(f.ecModel, x, p, v), C = g.getItemVisual(E, "decal");
                  g.setItemVisual(E, "decal", _(C, w));
                });
              }
              function _(I, E) {
                var x = I ? X(X({}, E), I) : E;
                return x.dirty = true, x;
              }
            });
          }
        }
        function a() {
          var u = t.getZr().dom;
          if (u) {
            var h = n.getLocaleModel().get("aria"), c = e.getModel("label");
            if (c.option = wt(c.option, h), !!c.get("enabled")) {
              if (c.get("description")) {
                u.setAttribute("aria-label", c.get("description"));
                return;
              }
              var f = n.getSeriesCount(), g = c.get(["data", "maxCount"]) || 10, d = c.get(["series", "maxCount"]) || 10, A = Math.min(f, d), p;
              if (!(f < 1)) {
                var v = s();
                if (v) {
                  var y = c.get(["general", "withTitle"]);
                  p = o(y, { title: v });
                } else p = c.get(["general", "withoutTitle"]);
                var m = [], _ = f > 1 ? c.get(["series", "multiple", "prefix"]) : c.get(["series", "single", "prefix"]);
                p += o(_, { seriesCount: f }), n.eachSeries(function(w, C) {
                  if (C < A) {
                    var S = void 0, b = w.get("name"), T = b ? "withName" : "withoutName";
                    S = f > 1 ? c.get(["series", "multiple", T]) : c.get(["series", "single", T]), S = o(S, { seriesId: w.seriesIndex, seriesName: w.get("name"), seriesType: l(w.subType) });
                    var B = w.getData();
                    if (B.count() > g) {
                      var R = c.get(["data", "partialData"]);
                      S += o(R, { displayCnt: g });
                    } else S += c.get(["data", "allData"]);
                    for (var M = c.get(["data", "separator", "middle"]), L = c.get(["data", "separator", "end"]), N = [], F = 0; F < B.count(); F++) if (F < g) {
                      var k = B.getName(F), O = B.getValues(F), Q = c.get(["data", k ? "withName" : "withoutName"]);
                      N.push(o(Q, { name: k, value: O.join(M) }));
                    }
                    S += N.join(M) + L, m.push(S);
                  }
                });
                var I = c.getModel(["series", "multiple", "separator"]), E = I.get("middle"), x = I.get("end");
                p += m.join(E) + x, u.setAttribute("aria-label", p);
              }
            }
          }
        }
        function o(u, h) {
          if (!ht(u)) return u;
          var c = u;
          return D(h, function(f, g) {
            c = c.replace(new RegExp("\\{\\s*" + g + "\\s*\\}", "g"), f);
          }), c;
        }
        function s() {
          var u = n.get("title");
          return u && u.length && (u = u[0]), u && u.text;
        }
        function l(u) {
          var h = n.getLocaleModel().get(["series", "typeNames"]);
          return h[u] || h.chart;
        }
      }
      function RQt(n) {
        if (!(!n || !n.aria)) {
          var t = n.aria;
          t.show != null && (t.enabled = t.show), t.label = t.label || {}, D(["description", "general", "series", "data"], function(e) {
            t[e] != null && (t.label[e] = t[e]);
          });
        }
      }
      function LQt(n) {
        n.registerPreprocessor(RQt), n.registerVisual(n.PRIORITY.VISUAL.ARIA, DQt);
      }
      var fX = { value: "eq", "<": "lt", "<=": "lte", ">": "gt", ">=": "gte", "=": "eq", "!=": "ne", "<>": "ne" }, PQt = function() {
        function n(t) {
          var e = this._condVal = ht(t) ? new RegExp(t) : t5(t) ? t : null;
          if (e == null) {
            var i = "";
            i = Ir("Illegal regexp", t, "in"), be(i);
          }
        }
        return n.prototype.evaluate = function(t) {
          var e = typeof t;
          return ht(e) ? this._condVal.test(t) : ye(e) ? this._condVal.test(t + "") : false;
        }, n;
      }(), NQt = function() {
        function n() {
        }
        return n.prototype.evaluate = function() {
          return this.value;
        }, n;
      }(), FQt = function() {
        function n() {
        }
        return n.prototype.evaluate = function() {
          for (var t = this.children, e = 0; e < t.length; e++) if (!t[e].evaluate()) return false;
          return true;
        }, n;
      }(), kQt = function() {
        function n() {
        }
        return n.prototype.evaluate = function() {
          for (var t = this.children, e = 0; e < t.length; e++) if (t[e].evaluate()) return true;
          return false;
        }, n;
      }(), OQt = function() {
        function n() {
        }
        return n.prototype.evaluate = function() {
          return !this.child.evaluate();
        }, n;
      }(), QQt = function() {
        function n() {
        }
        return n.prototype.evaluate = function() {
          for (var t = !!this.valueParser, e = this.getValue, i = e(this.valueGetterParam), r = t ? this.valueParser(i) : null, a = 0; a < this.subCondList.length; a++) if (!this.subCondList[a].evaluate(t ? r : i)) return false;
          return true;
        }, n;
      }();
      function TL(n, t) {
        if (n === true || n === false) {
          var e = new NQt();
          return e.value = n, e;
        }
        var i = "";
        return dX(n) || (i = Ir("Illegal config. Expect a plain object but actually", n), be(i)), n.and ? gX("and", n, t) : n.or ? gX("or", n, t) : n.not ? zQt(n, t) : GQt(n, t);
      }
      function gX(n, t, e) {
        var i = t[n], r = "";
        r = Ir('"and"/"or" condition should only be `' + n + ": [...]` and must not be empty array.", "Illegal condition:", t), Z(i) || be(r), i.length || be(r);
        var a = n === "and" ? new FQt() : new kQt();
        return a.children = K(i, function(o) {
          return TL(o, e);
        }), a.children.length || be(r), a;
      }
      function zQt(n, t) {
        var e = n.not, i = "";
        i = Ir('"not" condition should only be `not: {}`.', "Illegal condition:", n), dX(e) || be(i);
        var r = new OQt();
        return r.child = TL(e, t), r.child || be(i), r;
      }
      function GQt(n, t) {
        for (var e = "", i = t.prepareGetValue(n), r = [], a = oe(n), o = n.parser, s = o ? H6(o) : null, l = 0; l < a.length; l++) {
          var u = a[l];
          if (!(u === "parser" || t.valueGetterAttrMap.get(u))) {
            var h = ft(fX, u) ? fX[u] : u, c = n[u], f = s ? s(c) : c, g = Mwt(h, f) || h === "reg" && new PQt(f);
            g || (e = Ir('Illegal relational operation: "' + u + '" in condition:', n), be(e)), r.push(g);
          }
        }
        r.length || (e = Ir("Relational condition must have at least one operator.", "Illegal condition:", n), be(e));
        var d = new QQt();
        return d.valueGetterParam = i, d.valueParser = s, d.getValue = t.getValue, d.subCondList = r, d;
      }
      function dX(n) {
        return Et(n) && !Li(n);
      }
      var UQt = function() {
        function n(t, e) {
          this._cond = TL(t, e);
        }
        return n.prototype.evaluate = function() {
          return this._cond.evaluate();
        }, n;
      }();
      function VQt(n, t) {
        return new UQt(n, t);
      }
      var jQt = { type: "echarts:filter", transform: function(n) {
        for (var t = n.upstream, e, i = VQt(n.config, { valueGetterAttrMap: dt({ dimension: true }), prepareGetValue: function(s) {
          var l = "", u = s.dimension;
          ft(s, "dimension") || (l = Ir('Relation condition must has prop "dimension" specified.', "Illegal condition:", s), be(l));
          var h = t.getDimensionInfo(u);
          return h || (l = Ir("Can not find dimension info via: " + u + `.
`, "Existing dimensions: ", t.cloneAllDimensionInfo(), `.
`, "Illegal condition:", s, `.
`), be(l)), { dimIdx: h.index };
        }, getValue: function(s) {
          return t.retrieveValueFromItem(e, s.dimIdx);
        } }), r = [], a = 0, o = t.count(); a < o; a++) e = t.getRawDataItem(a), i.evaluate() && r.push(e);
        return { data: r };
      } }, BL = "";
      BL = ["Valid config is like:", '{ dimension: "age", order: "asc" }', 'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'].join(" ");
      var qQt = { type: "echarts:sort", transform: function(n) {
        var t = n.upstream, e = n.config, i = "", r = ze(e);
        r.length || (i = "Empty `config` in sort transform.", be(i));
        var a = [];
        D(r, function(h) {
          var c = h.dimension, f = h.order, g = h.parser, d = h.incomparable;
          if (c == null && (i = 'Sort transform config must has "dimension" specified.' + BL, be(i)), f !== "asc" && f !== "desc" && (i = 'Sort transform config must has "order" specified.' + BL, be(i)), d && d !== "min" && d !== "max") {
            var A = "";
            A = 'incomparable must be "min" or "max" rather than "' + d + '".', be(A);
          }
          if (f !== "asc" && f !== "desc") {
            var p = "";
            p = 'order must be "asc" or "desc" rather than "' + f + '".', be(p);
          }
          var v = t.getDimensionInfo(c);
          v || (i = Ir("Can not find dimension info via: " + c + `.
`, "Existing dimensions: ", t.cloneAllDimensionInfo(), `.
`, "Illegal config:", h, `.
`), be(i));
          var y = g ? H6(g) : null;
          g && !y && (i = Ir("Invalid parser name " + g + `.
`, "Illegal config:", h, `.
`), be(i)), a.push({ dimIdx: v.index, parser: y, comparator: new W6(f, d) });
        });
        var o = t.sourceFormat;
        o !== Ni && o !== xa && (i = 'sourceFormat "' + o + '" is not supported yet', be(i));
        for (var s = [], l = 0, u = t.count(); l < u; l++) s.push(t.getRawDataItem(l));
        return s.sort(function(h, c) {
          for (var f = 0; f < a.length; f++) {
            var g = a[f], d = t.retrieveValueFromItem(h, g.dimIdx), A = t.retrieveValueFromItem(c, g.dimIdx);
            g.parser && (d = g.parser(d), A = g.parser(A));
            var p = g.comparator.evaluate(d, A);
            if (p !== 0) return p;
          }
          return 0;
        }), { data: s };
      } };
      function HQt(n) {
        n.registerTransform(jQt), n.registerTransform(qQt);
      }
      var YQt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "dataset", e;
        }
        return t.prototype.init = function(e, i, r) {
          n.prototype.init.call(this, e, i, r), this._sourceManager = new tU(this), eU(this);
        }, t.prototype.mergeOption = function(e, i) {
          n.prototype.mergeOption.call(this, e, i), eU(this);
        }, t.prototype.optionUpdated = function() {
          this._sourceManager.dirty();
        }, t.prototype.getSourceManager = function() {
          return this._sourceManager;
        }, t.type = "dataset", t.defaultOption = { seriesLayoutBy: Jo }, t;
      }(ae), WQt = function(n) {
        V(t, n);
        function t() {
          var e = n !== null && n.apply(this, arguments) || this;
          return e.type = "dataset", e;
        }
        return t.type = "dataset", t;
      }(un);
      function XQt(n) {
        n.registerComponentModel(YQt), n.registerComponentView(WQt);
      }
      var ls = $o.CMD;
      function Ld(n, t) {
        return Math.abs(n - t) < 1e-5;
      }
      function ML(n) {
        var t = n.data, e = n.len(), i = [], r, a = 0, o = 0, s = 0, l = 0;
        function u(B, R) {
          r && r.length > 2 && i.push(r), r = [B, R];
        }
        function h(B, R, M, L) {
          Ld(B, M) && Ld(R, L) || r.push(B, R, M, L, M, L);
        }
        function c(B, R, M, L, N, F) {
          var k = Math.abs(R - B), O = Math.tan(k / 4) * 4 / 3, Q = R < B ? -1 : 1, j = Math.cos(B), Y = Math.sin(B), G = Math.cos(R), $ = Math.sin(R), J = j * N + M, et = Y * F + L, nt = G * N + M, gt = $ * F + L, q = N * O * Q, W = F * O * Q;
          r.push(J - q * Y, et + W * j, nt + q * $, gt - W * G, nt, gt);
        }
        for (var f, g, d, A, p = 0; p < e; ) {
          var v = t[p++], y = p === 1;
          switch (y && (a = t[p], o = t[p + 1], s = a, l = o, (v === ls.L || v === ls.C || v === ls.Q) && (r = [s, l])), v) {
            case ls.M:
              a = s = t[p++], o = l = t[p++], u(s, l);
              break;
            case ls.L:
              f = t[p++], g = t[p++], h(a, o, f, g), a = f, o = g;
              break;
            case ls.C:
              r.push(t[p++], t[p++], t[p++], t[p++], a = t[p++], o = t[p++]);
              break;
            case ls.Q:
              f = t[p++], g = t[p++], d = t[p++], A = t[p++], r.push(a + 2 / 3 * (f - a), o + 2 / 3 * (g - o), d + 2 / 3 * (f - d), A + 2 / 3 * (g - A), d, A), a = d, o = A;
              break;
            case ls.A:
              var m = t[p++], _ = t[p++], I = t[p++], E = t[p++], x = t[p++], w = t[p++] + x;
              p += 1;
              var C = !t[p++];
              f = Math.cos(x) * I + m, g = Math.sin(x) * E + _, y ? (s = f, l = g, u(s, l)) : h(a, o, f, g), a = Math.cos(w) * I + m, o = Math.sin(w) * E + _;
              for (var S = (C ? -1 : 1) * Math.PI / 2, b = x; C ? b > w : b < w; b += S) {
                var T = C ? Math.max(b + S, w) : Math.min(b + S, w);
                c(b, T, m, _, I, E);
              }
              break;
            case ls.R:
              s = a = t[p++], l = o = t[p++], f = s + t[p++], g = l + t[p++], u(f, l), h(f, l, f, g), h(f, g, s, g), h(s, g, s, l), h(s, l, f, l);
              break;
            case ls.Z:
              r && h(a, o, s, l), a = s, o = l;
              break;
          }
        }
        return r && r.length > 2 && i.push(r), i;
      }
      function DL(n, t, e, i, r, a, o, s, l, u) {
        if (Ld(n, e) && Ld(t, i) && Ld(r, o) && Ld(a, s)) {
          l.push(o, s);
          return;
        }
        var h = 2 / u, c = h * h, f = o - n, g = s - t, d = Math.sqrt(f * f + g * g);
        f /= d, g /= d;
        var A = e - n, p = i - t, v = r - o, y = a - s, m = A * A + p * p, _ = v * v + y * y;
        if (m < c && _ < c) {
          l.push(o, s);
          return;
        }
        var I = f * A + g * p, E = -f * v - g * y, x = m - I * I, w = _ - E * E;
        if (x < c && I >= 0 && w < c && E >= 0) {
          l.push(o, s);
          return;
        }
        var C = [], S = [];
        eu(n, e, r, o, 0.5, C), eu(t, i, a, s, 0.5, S), DL(C[0], S[0], C[1], S[1], C[2], S[2], C[3], S[3], l, u), DL(C[4], S[4], C[5], S[5], C[6], S[6], C[7], S[7], l, u);
      }
      function $Qt(n, t) {
        var e = ML(n), i = [];
        t = t || 1;
        for (var r = 0; r < e.length; r++) {
          var a = e[r], o = [], s = a[0], l = a[1];
          o.push(s, l);
          for (var u = 2; u < a.length; ) {
            var h = a[u++], c = a[u++], f = a[u++], g = a[u++], d = a[u++], A = a[u++];
            DL(s, l, h, c, f, g, d, A, o, t), s = d, l = A;
          }
          i.push(o);
        }
        return i;
      }
      function AX(n, t, e) {
        var i = n[t], r = n[1 - t], a = Math.abs(i / r), o = Math.ceil(Math.sqrt(a * e)), s = Math.floor(e / o);
        s === 0 && (s = 1, o = e);
        for (var l = [], u = 0; u < o; u++) l.push(s);
        var h = o * s, c = e - h;
        if (c > 0) for (var u = 0; u < c; u++) l[u % o] += 1;
        return l;
      }
      function pX(n, t, e) {
        for (var i = n.r0, r = n.r, a = n.startAngle, o = n.endAngle, s = Math.abs(o - a), l = s * r, u = r - i, h = l > Math.abs(u), c = AX([l, u], h ? 0 : 1, t), f = (h ? s : u) / c.length, g = 0; g < c.length; g++) for (var d = (h ? u : s) / c[g], A = 0; A < c[g]; A++) {
          var p = {};
          h ? (p.startAngle = a + f * g, p.endAngle = a + f * (g + 1), p.r0 = i + d * A, p.r = i + d * (A + 1)) : (p.startAngle = a + d * A, p.endAngle = a + d * (A + 1), p.r0 = i + f * g, p.r = i + f * (g + 1)), p.clockwise = n.clockwise, p.cx = n.cx, p.cy = n.cy, e.push(p);
        }
      }
      function ZQt(n, t, e) {
        for (var i = n.width, r = n.height, a = i > r, o = AX([i, r], a ? 0 : 1, t), s = a ? "width" : "height", l = a ? "height" : "width", u = a ? "x" : "y", h = a ? "y" : "x", c = n[s] / o.length, f = 0; f < o.length; f++) for (var g = n[l] / o[f], d = 0; d < o[f]; d++) {
          var A = {};
          A[u] = f * c, A[h] = d * g, A[s] = c, A[l] = g, A.x += n.x, A.y += n.y, e.push(A);
        }
      }
      function vX(n, t, e, i) {
        return n * i - e * t;
      }
      function KQt(n, t, e, i, r, a, o, s) {
        var l = e - n, u = i - t, h = o - r, c = s - a, f = vX(h, c, l, u);
        if (Math.abs(f) < 1e-6) return null;
        var g = n - r, d = t - a, A = vX(g, d, h, c) / f;
        return A < 0 || A > 1 ? null : new jt(A * l + n, A * u + t);
      }
      function JQt(n, t, e) {
        var i = new jt();
        jt.sub(i, e, t), i.normalize();
        var r = new jt();
        jt.sub(r, n, t);
        var a = r.dot(i);
        return a;
      }
      function Pd(n, t) {
        var e = n[n.length - 1];
        e && e[0] === t[0] && e[1] === t[1] || n.push(t);
      }
      function t3t(n, t, e) {
        for (var i = n.length, r = [], a = 0; a < i; a++) {
          var o = n[a], s = n[(a + 1) % i], l = KQt(o[0], o[1], s[0], s[1], t.x, t.y, e.x, e.y);
          l && r.push({ projPt: JQt(l, t, e), pt: l, idx: a });
        }
        if (r.length < 2) return [{ points: n }, { points: n }];
        r.sort(function(p, v) {
          return p.projPt - v.projPt;
        });
        var u = r[0], h = r[r.length - 1];
        if (h.idx < u.idx) {
          var c = u;
          u = h, h = c;
        }
        for (var f = [u.pt.x, u.pt.y], g = [h.pt.x, h.pt.y], d = [f], A = [g], a = u.idx + 1; a <= h.idx; a++) Pd(d, n[a].slice());
        Pd(d, g), Pd(d, f);
        for (var a = h.idx + 1; a <= u.idx + i; a++) Pd(A, n[a % i].slice());
        return Pd(A, f), Pd(A, g), [{ points: d }, { points: A }];
      }
      function yX(n) {
        var t = n.points, e = [], i = [];
        w1(t, e, i);
        var r = new Wt(e[0], e[1], i[0] - e[0], i[1] - e[1]), a = r.width, o = r.height, s = r.x, l = r.y, u = new jt(), h = new jt();
        return a > o ? (u.x = h.x = s + a / 2, u.y = l, h.y = l + o) : (u.y = h.y = l + o / 2, u.x = s, h.x = s + a), t3t(t, u, h);
      }
      function UI(n, t, e, i) {
        if (e === 1) i.push(t);
        else {
          var r = Math.floor(e / 2), a = n(t);
          UI(n, a[0], r, i), UI(n, a[1], e - r, i);
        }
        return i;
      }
      function e3t(n, t) {
        for (var e = [], i = 0; i < t; i++) e.push(eB(n));
        return e;
      }
      function n3t(n, t) {
        t.setStyle(n.style), t.z = n.z, t.z2 = n.z2, t.zlevel = n.zlevel;
      }
      function i3t(n) {
        for (var t = [], e = 0; e < n.length; ) t.push([n[e++], n[e++]]);
        return t;
      }
      function r3t(n, t) {
        var e = [], i = n.shape, r;
        switch (n.type) {
          case "rect":
            ZQt(i, t, e), r = fe;
            break;
          case "sector":
            pX(i, t, e), r = Zi;
            break;
          case "circle":
            pX({ r0: 0, r: i.r, startAngle: 0, endAngle: Math.PI * 2, cx: i.cx, cy: i.cy }, t, e), r = Zi;
            break;
          default:
            var a = n.getComputedTransform(), o = a ? Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1], a[2] * a[2] + a[3] * a[3])) : 1, s = K($Qt(n.getUpdatedPathProxy(), o), function(v) {
              return i3t(v);
            }), l = s.length;
            if (l === 0) UI(yX, { points: s[0] }, t, e);
            else if (l === t) for (var u = 0; u < l; u++) e.push({ points: s[u] });
            else {
              var h = 0, c = K(s, function(v) {
                var y = [], m = [];
                w1(v, y, m);
                var _ = (m[1] - y[1]) * (m[0] - y[0]);
                return h += _, { poly: v, area: _ };
              });
              c.sort(function(v, y) {
                return y.area - v.area;
              });
              for (var f = t, u = 0; u < l; u++) {
                var g = c[u];
                if (f <= 0) break;
                var d = u === l - 1 ? f : Math.ceil(g.area / h * t);
                d < 0 || (UI(yX, { points: g.poly }, d, e), f -= d);
              }
            }
            r = Ki;
            break;
        }
        if (!r) return e3t(n, t);
        for (var A = [], u = 0; u < e.length; u++) {
          var p = new r();
          p.setShape(e[u]), n3t(n, p), A.push(p);
        }
        return A;
      }
      function a3t(n, t) {
        var e = n.length, i = t.length;
        if (e === i) return [n, t];
        for (var r = [], a = [], o = e < i ? n : t, s = Math.min(e, i), l = Math.abs(i - e) / 6, u = (s - 2) / 6, h = Math.ceil(l / u) + 1, c = [o[0], o[1]], f = l, g = 2; g < s; ) {
          var d = o[g - 2], A = o[g - 1], p = o[g++], v = o[g++], y = o[g++], m = o[g++], _ = o[g++], I = o[g++];
          if (f <= 0) {
            c.push(p, v, y, m, _, I);
            continue;
          }
          for (var E = Math.min(f, h - 1) + 1, x = 1; x <= E; x++) {
            var w = x / E;
            eu(d, p, y, _, w, r), eu(A, v, m, I, w, a), d = r[3], A = a[3], c.push(r[1], a[1], r[2], a[2], d, A), p = r[5], v = a[5], y = r[6], m = a[6];
          }
          f -= E - 1;
        }
        return o === n ? [c, t] : [n, c];
      }
      function mX(n, t) {
        for (var e = n.length, i = n[e - 2], r = n[e - 1], a = [], o = 0; o < t.length; ) a[o++] = i, a[o++] = r;
        return a;
      }
      function o3t(n, t) {
        for (var e, i, r, a = [], o = [], s = 0; s < Math.max(n.length, t.length); s++) {
          var l = n[s], u = t[s], h = void 0, c = void 0;
          l ? u ? (e = a3t(l, u), h = e[0], c = e[1], i = h, r = c) : (c = mX(r || l, l), h = l) : (h = mX(i || u, u), c = u), a.push(h), o.push(c);
        }
        return [a, o];
      }
      function _X(n) {
        for (var t = 0, e = 0, i = 0, r = n.length, a = 0, o = r - 2; a < r; o = a, a += 2) {
          var s = n[o], l = n[o + 1], u = n[a], h = n[a + 1], c = s * h - u * l;
          t += c, e += (s + u) * c, i += (l + h) * c;
        }
        return t === 0 ? [n[0] || 0, n[1] || 0] : [e / t / 3, i / t / 3, t];
      }
      function s3t(n, t, e, i) {
        for (var r = (n.length - 2) / 6, a = 1 / 0, o = 0, s = n.length, l = s - 2, u = 0; u < r; u++) {
          for (var h = u * 6, c = 0, f = 0; f < s; f += 2) {
            var g = f === 0 ? h : (h + f - 2) % l + 2, d = n[g] - e[0], A = n[g + 1] - e[1], p = t[f] - i[0], v = t[f + 1] - i[1], y = p - d, m = v - A;
            c += y * y + m * m;
          }
          c < a && (a = c, o = u);
        }
        return o;
      }
      function l3t(n) {
        for (var t = [], e = n.length, i = 0; i < e; i += 2) t[i] = n[e - i - 2], t[i + 1] = n[e - i - 1];
        return t;
      }
      function u3t(n, t, e, i) {
        for (var r = [], a, o = 0; o < n.length; o++) {
          var s = n[o], l = t[o], u = _X(s), h = _X(l);
          a == null && (a = u[2] < 0 != h[2] < 0);
          var c = [], f = [], g = 0, d = 1 / 0, A = [], p = s.length;
          a && (s = l3t(s));
          for (var v = s3t(s, l, u, h) * 6, y = p - 2, m = 0; m < y; m += 2) {
            var _ = (v + m) % y + 2;
            c[m + 2] = s[_] - u[0], c[m + 3] = s[_ + 1] - u[1];
          }
          c[0] = s[v] - u[0], c[1] = s[v + 1] - u[1];
          for (var I = i / e, E = -i / 2; E <= i / 2; E += I) {
            for (var x = Math.sin(E), w = Math.cos(E), C = 0, m = 0; m < s.length; m += 2) {
              var S = c[m], b = c[m + 1], T = l[m] - h[0], B = l[m + 1] - h[1], R = T * w - B * x, M = T * x + B * w;
              A[m] = R, A[m + 1] = M;
              var L = R - S, N = M - b;
              C += L * L + N * N;
            }
            if (C < d) {
              d = C, g = E;
              for (var F = 0; F < A.length; F++) f[F] = A[F];
            }
          }
          r.push({ from: c, to: f, fromCp: u, toCp: h, rotation: -g });
        }
        return r;
      }
      function VI(n) {
        return n.__isCombineMorphing;
      }
      var EX = "__mOriginal_";
      function jI(n, t, e) {
        var i = EX + t, r = n[i] || n[t];
        n[i] || (n[i] = n[t]);
        var a = e.replace, o = e.after, s = e.before;
        n[t] = function() {
          var l = arguments, u;
          return s && s.apply(this, l), a ? u = a.apply(this, l) : u = r.apply(this, l), o && o.apply(this, l), u;
        };
      }
      function My(n, t) {
        var e = EX + t;
        n[e] && (n[t] = n[e], n[e] = null);
      }
      function IX(n, t) {
        for (var e = 0; e < n.length; e++) for (var i = n[e], r = 0; r < i.length; ) {
          var a = i[r], o = i[r + 1];
          i[r++] = t[0] * a + t[2] * o + t[4], i[r++] = t[1] * a + t[3] * o + t[5];
        }
      }
      function xX(n, t) {
        var e = n.getUpdatedPathProxy(), i = t.getUpdatedPathProxy(), r = o3t(ML(e), ML(i)), a = r[0], o = r[1], s = n.getComputedTransform(), l = t.getComputedTransform();
        function u() {
          this.transform = null;
        }
        s && IX(a, s), l && IX(o, l), jI(t, "updateTransform", { replace: u }), t.transform = null;
        var h = u3t(a, o, 10, Math.PI), c = [];
        jI(t, "buildPath", { replace: function(f) {
          for (var g = t.__morphT, d = 1 - g, A = [], p = 0; p < h.length; p++) {
            var v = h[p], y = v.from, m = v.to, _ = v.rotation * g, I = v.fromCp, E = v.toCp, x = Math.sin(_), w = Math.cos(_);
            j_(A, I, E, g);
            for (var C = 0; C < y.length; C += 2) {
              var S = y[C], b = y[C + 1], T = m[C], B = m[C + 1], R = S * d + T * g, M = b * d + B * g;
              c[C] = R * w - M * x + A[0], c[C + 1] = R * x + M * w + A[1];
            }
            var L = c[0], N = c[1];
            f.moveTo(L, N);
            for (var C = 2; C < y.length; ) {
              var T = c[C++], B = c[C++], F = c[C++], k = c[C++], O = c[C++], Q = c[C++];
              L === T && N === B && F === O && k === Q ? f.lineTo(O, Q) : f.bezierCurveTo(T, B, F, k, O, Q), L = O, N = Q;
            }
          }
        } });
      }
      function RL(n, t, e) {
        if (!n || !t) return t;
        var i = e.done, r = e.during;
        xX(n, t), t.__morphT = 0;
        function a() {
          My(t, "buildPath"), My(t, "updateTransform"), t.__morphT = -1, t.createPathProxy(), t.dirtyShape();
        }
        return t.animateTo({ __morphT: 1 }, wt({ during: function(o) {
          t.dirtyShape(), r && r(o);
        }, done: function() {
          a(), i && i();
        } }, e)), t;
      }
      function h3t(n, t, e, i, r, a) {
        var o = 16;
        n = r === e ? 0 : Math.round(32767 * (n - e) / (r - e)), t = a === i ? 0 : Math.round(32767 * (t - i) / (a - i));
        for (var s = 0, l, u = (1 << o) / 2; u > 0; u /= 2) {
          var h = 0, c = 0;
          (n & u) > 0 && (h = 1), (t & u) > 0 && (c = 1), s += u * u * (3 * h ^ c), c === 0 && (h === 1 && (n = u - 1 - n, t = u - 1 - t), l = n, n = t, t = l);
        }
        return s;
      }
      function qI(n) {
        var t = 1 / 0, e = 1 / 0, i = -1 / 0, r = -1 / 0, a = K(n, function(s) {
          var l = s.getBoundingRect(), u = s.getComputedTransform(), h = l.x + l.width / 2 + (u ? u[4] : 0), c = l.y + l.height / 2 + (u ? u[5] : 0);
          return t = Math.min(h, t), e = Math.min(c, e), i = Math.max(h, i), r = Math.max(c, r), [h, c];
        }), o = K(a, function(s, l) {
          return { cp: s, z: h3t(s[0], s[1], t, e, i, r), path: n[l] };
        });
        return o.sort(function(s, l) {
          return s.z - l.z;
        }).map(function(s) {
          return s.path;
        });
      }
      function wX(n) {
        return r3t(n.path, n.count);
      }
      function LL() {
        return { fromIndividuals: [], toIndividuals: [], count: 0 };
      }
      function c3t(n, t, e) {
        var i = [];
        function r(I) {
          for (var E = 0; E < I.length; E++) {
            var x = I[E];
            VI(x) ? r(x.childrenRef()) : x instanceof ne && i.push(x);
          }
        }
        r(n);
        var a = i.length;
        if (!a) return LL();
        var o = e.dividePath || wX, s = o({ path: t, count: a });
        if (s.length !== a) return LL();
        i = qI(i), s = qI(s);
        for (var l = e.done, u = e.during, h = e.individualDelay, c = new Vs(), f = 0; f < a; f++) {
          var g = i[f], d = s[f];
          d.parent = t, d.copyTransform(c), h || xX(g, d);
        }
        t.__isCombineMorphing = true, t.childrenRef = function() {
          return s;
        };
        function A(I) {
          for (var E = 0; E < s.length; E++) s[E].addSelfToZr(I);
        }
        jI(t, "addSelfToZr", { after: function(I) {
          A(I);
        } }), jI(t, "removeSelfFromZr", { after: function(I) {
          for (var E = 0; E < s.length; E++) s[E].removeSelfFromZr(I);
        } });
        function p() {
          t.__isCombineMorphing = false, t.__morphT = -1, t.childrenRef = null, My(t, "addSelfToZr"), My(t, "removeSelfFromZr");
        }
        var v = s.length;
        if (h) for (var y = v, m = function() {
          y--, y === 0 && (p(), l && l());
        }, f = 0; f < v; f++) {
          var _ = h ? wt({ delay: (e.delay || 0) + h(f, v, i[f], s[f]), done: m }, e) : e;
          RL(i[f], s[f], _);
        }
        else t.__morphT = 0, t.animateTo({ __morphT: 1 }, wt({ during: function(I) {
          for (var E = 0; E < v; E++) {
            var x = s[E];
            x.__morphT = t.__morphT, x.dirtyShape();
          }
          u && u(I);
        }, done: function() {
          p();
          for (var I = 0; I < n.length; I++) My(n[I], "updateTransform");
          l && l();
        } }, e));
        return t.__zr && A(t.__zr), { fromIndividuals: i, toIndividuals: s, count: v };
      }
      function f3t(n, t, e) {
        var i = t.length, r = [], a = e.dividePath || wX;
        function o(g) {
          for (var d = 0; d < g.length; d++) {
            var A = g[d];
            VI(A) ? o(A.childrenRef()) : A instanceof ne && r.push(A);
          }
        }
        if (VI(n)) {
          o(n.childrenRef());
          var s = r.length;
          if (s < i) for (var l = 0, u = s; u < i; u++) r.push(eB(r[l++ % s]));
          r.length = i;
        } else {
          r = a({ path: n, count: i });
          for (var h = n.getComputedTransform(), u = 0; u < r.length; u++) r[u].setLocalTransform(h);
          if (r.length !== i) return LL();
        }
        r = qI(r), t = qI(t);
        for (var c = e.individualDelay, u = 0; u < i; u++) {
          var f = c ? wt({ delay: (e.delay || 0) + c(u, i, r[u], t[u]) }, e) : e;
          RL(r[u], t[u], f);
        }
        return { fromIndividuals: r, toIndividuals: t, count: t.length };
      }
      function CX(n) {
        return Z(n[0]);
      }
      function SX(n, t) {
        for (var e = [], i = n.length, r = 0; r < i; r++) e.push({ one: n[r], many: [] });
        for (var r = 0; r < t.length; r++) {
          var a = t[r].length, o = void 0;
          for (o = 0; o < a; o++) e[o % i].many.push(t[r][o]);
        }
        for (var s = 0, r = i - 1; r >= 0; r--) if (!e[r].many.length) {
          var l = e[s].many;
          if (l.length <= 1) if (s) s = 0;
          else return e;
          var a = l.length, u = Math.ceil(a / 2);
          e[r].many = l.slice(u, a), e[s].many = l.slice(0, u), s++;
        }
        return e;
      }
      var g3t = { clone: function(n) {
        for (var t = [], e = 1 - Math.pow(1 - n.path.style.opacity, 1 / n.count), i = 0; i < n.count; i++) {
          var r = eB(n.path);
          r.setStyle("opacity", e), t.push(r);
        }
        return t;
      }, split: null };
      function PL(n, t, e, i, r, a) {
        if (!n.length || !t.length) return;
        var o = Ug("update", i, r);
        if (!(o && o.duration > 0)) return;
        var s = i.getModel("universalTransition").get("delay"), l = Object.assign({ setToFinal: true }, o), u, h;
        CX(n) && (u = n, h = t), CX(t) && (u = t, h = n);
        function c(v, y, m, _, I) {
          var E = v.many, x = v.one;
          if (E.length === 1 && !I) {
            var w = y ? E[0] : x, C = y ? x : E[0];
            if (VI(w)) c({ many: [w], one: C }, true, m, _, true);
            else {
              var S = s ? wt({ delay: s(m, _) }, l) : l;
              RL(w, C, S), a(w, C, w, C, S);
            }
          } else for (var b = wt({ dividePath: g3t[e], individualDelay: s && function(N, F, k, O) {
            return s(N + m, _);
          } }, l), T = y ? c3t(E, x, b) : f3t(x, E, b), B = T.fromIndividuals, R = T.toIndividuals, M = B.length, L = 0; L < M; L++) {
            var S = s ? wt({ delay: s(L, M) }, l) : l;
            a(B[L], R[L], y ? E[L] : v.one, y ? v.one : E[L], S);
          }
        }
        for (var f = u ? u === n : n.length > t.length, g = u ? SX(h, u) : SX(f ? t : n, [f ? n : t]), d = 0, A = 0; A < g.length; A++) d += g[A].many.length;
        for (var p = 0, A = 0; A < g.length; A++) c(g[A], f, p, d), p += g[A].many.length;
      }
      function Tc(n) {
        if (!n) return [];
        if (Z(n)) {
          for (var t = [], e = 0; e < n.length; e++) t.push(Tc(n[e]));
          return t;
        }
        var i = [];
        return n.traverse(function(r) {
          r instanceof ne && !r.disableMorphing && !r.invisible && !r.ignore && i.push(r);
        }), i;
      }
      var bX = 1e4, d3t = 0, TX = 1, BX = 2, A3t = ce();
      function p3t(n, t) {
        for (var e = n.dimensions, i = 0; i < e.length; i++) {
          var r = n.getDimensionInfo(e[i]);
          if (r && r.otherDims[t] === 0) return e[i];
        }
      }
      function v3t(n, t, e) {
        var i = n.getDimensionInfo(e), r = i && i.ordinalMeta;
        if (i) {
          var a = n.get(i.name, t);
          return r && r.categories[a] || a + "";
        }
      }
      function MX(n, t, e, i) {
        var r = i ? "itemChildGroupId" : "itemGroupId", a = p3t(n, r);
        if (a) {
          var o = v3t(n, t, a);
          return o;
        }
        var s = n.getRawDataItem(t), l = i ? "childGroupId" : "groupId";
        if (s && s[l]) return s[l] + "";
        if (!i) return e || n.getId(t);
      }
      function DX(n) {
        var t = [];
        return D(n, function(e) {
          var i = e.data, r = e.dataGroupId;
          if (i.count() > bX) {
            gn("Universal transition is disabled on large data > 10k.");
            return;
          }
          for (var a = i.getIndices(), o = 0; o < a.length; o++) t.push({ data: i, groupId: MX(i, o, r, false), childGroupId: MX(i, o, r, true), divide: e.divide, dataIndex: o });
        }), t;
      }
      function NL(n, t, e) {
        n.traverse(function(i) {
          i instanceof ne && on(i, { style: { opacity: 0 } }, t, { dataIndex: e, isFrom: true });
        });
      }
      function FL(n) {
        if (n.parent) {
          var t = n.getComputedTransform();
          n.setLocalTransform(t), n.parent.remove(n);
        }
      }
      function Nd(n) {
        n.stopAnimation(), n.isGroup && n.traverse(function(t) {
          t.stopAnimation();
        });
      }
      function y3t(n, t, e) {
        var i = Ug("update", e, t);
        i && n.traverse(function(r) {
          if (r instanceof ya) {
            var a = cxt(r);
            a && r.animateFrom({ style: a }, i);
          }
        });
      }
      function m3t(n, t) {
        var e = n.length;
        if (e !== t.length) return false;
        for (var i = 0; i < e; i++) {
          var r = n[i], a = t[i];
          if (r.data.getId(r.dataIndex) !== a.data.getId(a.dataIndex)) return false;
        }
        return true;
      }
      function RX(n, t, e) {
        var i = DX(n), r = DX(t);
        function a(m, _, I, E, x) {
          (I || m) && _.animateFrom({ style: I && I !== m ? X(X({}, I.style), m.style) : m.style }, x);
        }
        var o = false, s = d3t, l = dt(), u = dt();
        i.forEach(function(m) {
          m.groupId && l.set(m.groupId, true), m.childGroupId && u.set(m.childGroupId, true);
        });
        for (var h = 0; h < r.length; h++) {
          var c = r[h].groupId;
          if (u.get(c)) {
            s = TX;
            break;
          }
          var f = r[h].childGroupId;
          if (f && l.get(f)) {
            s = BX;
            break;
          }
        }
        function g(m, _) {
          return function(I) {
            var E = I.data, x = I.dataIndex;
            return _ ? E.getId(x) : m ? s === TX ? I.childGroupId : I.groupId : s === BX ? I.childGroupId : I.groupId;
          };
        }
        var d = m3t(i, r), A = {};
        if (!d) for (var h = 0; h < r.length; h++) {
          var p = r[h], v = p.data.getItemGraphicEl(p.dataIndex);
          v && (A[v.id] = true);
        }
        function y(m, _) {
          var I = i[_], E = r[m], x = E.data.hostModel, w = I.data.getItemGraphicEl(I.dataIndex), C = E.data.getItemGraphicEl(E.dataIndex);
          if (w === C) {
            C && y3t(C, E.dataIndex, x);
            return;
          }
          w && A[w.id] || C && (Nd(C), w ? (Nd(w), FL(w), o = true, PL(Tc(w), Tc(C), E.divide, x, m, a)) : NL(C, x, m));
        }
        new Js(i, r, g(true, d), g(false, d), null, "multiple").update(y).updateManyToOne(function(m, _) {
          var I = r[m], E = I.data, x = E.hostModel, w = E.getItemGraphicEl(I.dataIndex), C = Fe(K(_, function(S) {
            return i[S].data.getItemGraphicEl(i[S].dataIndex);
          }), function(S) {
            return S && S !== w && !A[S.id];
          });
          w && (Nd(w), C.length ? (D(C, function(S) {
            Nd(S), FL(S);
          }), o = true, PL(Tc(C), Tc(w), I.divide, x, m, a)) : NL(w, x, I.dataIndex));
        }).updateOneToMany(function(m, _) {
          var I = i[_], E = I.data.getItemGraphicEl(I.dataIndex);
          if (!(E && A[E.id])) {
            var x = Fe(K(m, function(C) {
              return r[C].data.getItemGraphicEl(r[C].dataIndex);
            }), function(C) {
              return C && C !== E;
            }), w = r[m[0]].data.hostModel;
            x.length && (D(x, function(C) {
              return Nd(C);
            }), E ? (Nd(E), FL(E), o = true, PL(Tc(E), Tc(x), I.divide, w, m[0], a)) : D(x, function(C) {
              return NL(C, w, m[0]);
            }));
          }
        }).updateManyToMany(function(m, _) {
          new Js(_, m, function(I) {
            return i[I].data.getId(i[I].dataIndex);
          }, function(I) {
            return r[I].data.getId(r[I].dataIndex);
          }).update(function(I, E) {
            y(m[I], _[E]);
          }).execute();
        }).execute(), o && D(t, function(m) {
          var _ = m.data, I = _.hostModel, E = I && e.getViewOfSeriesModel(I), x = Ug("update", I, 0);
          E && I.isAnimationEnabled() && x && x.duration > 0 && E.group.traverse(function(w) {
            w instanceof ne && !w.animators.length && w.animateFrom({ style: { opacity: 0 } }, x);
          });
        });
      }
      function LX(n) {
        var t = n.getModel("universalTransition").get("seriesKey");
        return t || n.id;
      }
      function PX(n) {
        return Z(n) ? n.sort().join(",") : n;
      }
      function Bu(n) {
        if (n.hostModel) return n.hostModel.getModel("universalTransition").get("divideShape");
      }
      function _3t(n, t) {
        var e = dt(), i = dt(), r = dt();
        D(n.oldSeries, function(o, s) {
          var l = n.oldDataGroupIds[s], u = n.oldData[s], h = LX(o), c = PX(h);
          i.set(c, { dataGroupId: l, data: u }), Z(h) && D(h, function(f) {
            r.set(f, { key: c, dataGroupId: l, data: u });
          });
        });
        function a(o) {
          e.get(o) && gn("Duplicated seriesKey in universalTransition " + o);
        }
        return D(t.updatedSeries, function(o) {
          if (o.isUniversalTransitionEnabled() && o.isAnimationEnabled()) {
            var s = o.get("dataGroupId"), l = o.getData(), u = LX(o), h = PX(u), c = i.get(h);
            if (c) a(h), e.set(h, { oldSeries: [{ dataGroupId: c.dataGroupId, divide: Bu(c.data), data: c.data }], newSeries: [{ dataGroupId: s, divide: Bu(l), data: l }] });
            else if (Z(u)) {
              a(h);
              var f = [];
              D(u, function(A) {
                var p = i.get(A);
                p.data && f.push({ dataGroupId: p.dataGroupId, divide: Bu(p.data), data: p.data });
              }), f.length && e.set(h, { oldSeries: f, newSeries: [{ dataGroupId: s, data: l, divide: Bu(l) }] });
            } else {
              var g = r.get(u);
              if (g) {
                var d = e.get(g.key);
                d || (d = { oldSeries: [{ dataGroupId: g.dataGroupId, data: g.data, divide: Bu(g.data) }], newSeries: [] }, e.set(g.key, d)), d.newSeries.push({ dataGroupId: s, data: l, divide: Bu(l) });
              }
            }
          }
        }), e;
      }
      function NX(n, t) {
        for (var e = 0; e < n.length; e++) {
          var i = t.seriesIndex != null && t.seriesIndex === n[e].seriesIndex || t.seriesId != null && t.seriesId === n[e].id;
          if (i) return e;
        }
      }
      function E3t(n, t, e, i) {
        var r = [], a = [];
        D(ze(n.from), function(o) {
          var s = NX(t.oldSeries, o);
          s >= 0 && r.push({ dataGroupId: t.oldDataGroupIds[s], data: t.oldData[s], divide: Bu(t.oldData[s]), groupIdDim: o.dimension });
        }), D(ze(n.to), function(o) {
          var s = NX(e.updatedSeries, o);
          if (s >= 0) {
            var l = e.updatedSeries[s].getData();
            a.push({ dataGroupId: t.oldDataGroupIds[s], data: l, divide: Bu(l), groupIdDim: o.dimension });
          }
        }), r.length > 0 && a.length > 0 && RX(r, a, i);
      }
      function I3t(n) {
        n.registerUpdateLifecycle("series:beforeupdate", function(t, e, i) {
          D(ze(i.seriesTransition), function(r) {
            D(ze(r.to), function(a) {
              for (var o = i.updatedSeries, s = 0; s < o.length; s++) (a.seriesIndex != null && a.seriesIndex === o[s].seriesIndex || a.seriesId != null && a.seriesId === o[s].id) && (o[s][uE] = true);
            });
          });
        }), n.registerUpdateLifecycle("series:transition", function(t, e, i) {
          var r = A3t(e);
          if (r.oldSeries && i.updatedSeries && i.optionChanged) {
            var a = i.seriesTransition;
            if (a) D(ze(a), function(g) {
              E3t(g, r, i, e);
            });
            else {
              var o = _3t(r, i);
              D(o.keys(), function(g) {
                var d = o.get(g);
                RX(d.oldSeries, d.newSeries, e);
              });
            }
            D(i.updatedSeries, function(g) {
              g[uE] && (g[uE] = false);
            });
          }
          for (var s = t.getSeries(), l = r.oldSeries = [], u = r.oldDataGroupIds = [], h = r.oldData = [], c = 0; c < s.length; c++) {
            var f = s[c].getData();
            f.count() < bX && (l.push(s[c]), u.push(s[c].get("dataGroupId")), h.push(f));
          }
        });
      }
      Kt([L2t]), Kt([T2t]), Kt([J2t, dTt, wTt, iBt, dBt, tMt, TMt, cDt, LDt, QDt, WDt, URt, gLt, wLt, zLt, jLt, tPt, sPt, yPt, wPt, PPt, pNt]), Kt(NNt), Kt(sFt), Kt(Tq), Kt(_Ft), Kt(X7), Kt(wFt), Kt(LFt), Kt(_kt), Kt(Qkt), Kt(Ey), Kt(nOt), Kt(aOt), Kt(AOt), Kt(IOt), Kt(TOt), Kt(POt), Kt(jOt), Kt(lQt), Kt(UW), Kt(HW), Kt(TQt), Kt(lX), Kt(hX), Kt(LQt), Kt(HQt), Kt(XQt), Kt(I3t), Kt(Wbt);
      function HI() {
        return [1, 0, 0, 1, 0, 0];
      }
      function x3t(n) {
        return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 1, n[4] = 0, n[5] = 0, n;
      }
      function w3t(n, t) {
        return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n;
      }
      function kL(n, t, e) {
        var i = t[0] * e[0] + t[2] * e[1], r = t[1] * e[0] + t[3] * e[1], a = t[0] * e[2] + t[2] * e[3], o = t[1] * e[2] + t[3] * e[3], s = t[0] * e[4] + t[2] * e[5] + t[4], l = t[1] * e[4] + t[3] * e[5] + t[5];
        return n[0] = i, n[1] = r, n[2] = a, n[3] = o, n[4] = s, n[5] = l, n;
      }
      function FX(n, t, e) {
        return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4] + e[0], n[5] = t[5] + e[1], n;
      }
      function C3t(n, t, e) {
        var i = t[0], r = t[2], a = t[4], o = t[1], s = t[3], l = t[5], u = Math.sin(e), h = Math.cos(e);
        return n[0] = i * h + o * u, n[1] = -i * u + o * h, n[2] = r * h + s * u, n[3] = -r * u + h * s, n[4] = h * a + u * l, n[5] = h * l - u * a, n;
      }
      function S3t(n, t, e) {
        var i = e[0], r = e[1];
        return n[0] = t[0] * i, n[1] = t[1] * r, n[2] = t[2] * i, n[3] = t[3] * r, n[4] = t[4] * i, n[5] = t[5] * r, n;
      }
      function b3t(n, t) {
        var e = t[0], i = t[2], r = t[4], a = t[1], o = t[3], s = t[5], l = e * o - a * i;
        return l ? (l = 1 / l, n[0] = o * l, n[1] = -a * l, n[2] = -i * l, n[3] = e * l, n[4] = (i * s - o * r) * l, n[5] = (a * r - e * s) * l, n) : null;
      }
      function kX(n, t, e) {
        var i = t[0], r = t[1];
        return n[0] = e[0] * i + e[2] * r + e[4], n[1] = e[1] * i + e[3] * r + e[5], n;
      }
      var OX = x3t, QX = 5e-5;
      function Bc(n) {
        return n > QX || n < -QX;
      }
      var Mc = [], Fd = [], OL = HI(), QL = Math.abs, zL = function() {
        function n() {
        }
        return n.prototype.getLocalTransform = function(t) {
          return n.getLocalTransform(this, t);
        }, n.prototype.setPosition = function(t) {
          this.x = t[0], this.y = t[1];
        }, n.prototype.setScale = function(t) {
          this.scaleX = t[0], this.scaleY = t[1];
        }, n.prototype.setSkew = function(t) {
          this.skewX = t[0], this.skewY = t[1];
        }, n.prototype.setOrigin = function(t) {
          this.originX = t[0], this.originY = t[1];
        }, n.prototype.needLocalTransform = function() {
          return Bc(this.rotation) || Bc(this.x) || Bc(this.y) || Bc(this.scaleX - 1) || Bc(this.scaleY - 1) || Bc(this.skewX) || Bc(this.skewY);
        }, n.prototype.updateTransform = function() {
          var t = this.parent && this.parent.transform, e = this.needLocalTransform(), i = this.transform;
          if (!(e || t)) {
            i && OX(i);
            return;
          }
          i = i || HI(), e ? this.getLocalTransform(i) : OX(i), t && (e ? kL(i, t, i) : w3t(i, t)), this.transform = i, this._resolveGlobalScaleRatio(i);
        }, n.prototype._resolveGlobalScaleRatio = function(t) {
          var e = this.globalScaleRatio;
          if (e != null && e !== 1) {
            this.getGlobalScale(Mc);
            var i = Mc[0] < 0 ? -1 : 1, r = Mc[1] < 0 ? -1 : 1, a = ((Mc[0] - i) * e + i) / Mc[0] || 0, o = ((Mc[1] - r) * e + r) / Mc[1] || 0;
            t[0] *= a, t[1] *= a, t[2] *= o, t[3] *= o;
          }
          this.invTransform = this.invTransform || HI(), b3t(this.invTransform, t);
        }, n.prototype.getComputedTransform = function() {
          for (var t = this, e = []; t; ) e.push(t), t = t.parent;
          for (; t = e.pop(); ) t.updateTransform();
          return this.transform;
        }, n.prototype.setLocalTransform = function(t) {
          if (t) {
            var e = t[0] * t[0] + t[1] * t[1], i = t[2] * t[2] + t[3] * t[3], r = Math.atan2(t[1], t[0]), a = Math.PI / 2 + r - Math.atan2(t[3], t[2]);
            i = Math.sqrt(i) * Math.cos(a), e = Math.sqrt(e), this.skewX = a, this.skewY = 0, this.rotation = -r, this.x = +t[4], this.y = +t[5], this.scaleX = e, this.scaleY = i, this.originX = 0, this.originY = 0;
          }
        }, n.prototype.decomposeTransform = function() {
          if (this.transform) {
            var t = this.parent, e = this.transform;
            t && t.transform && (kL(Fd, t.invTransform, e), e = Fd);
            var i = this.originX, r = this.originY;
            (i || r) && (OL[4] = i, OL[5] = r, kL(Fd, e, OL), Fd[4] -= i, Fd[5] -= r, e = Fd), this.setLocalTransform(e);
          }
        }, n.prototype.getGlobalScale = function(t) {
          var e = this.transform;
          return t = t || [], e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), e[0] < 0 && (t[0] = -t[0]), e[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t);
        }, n.prototype.transformCoordToLocal = function(t, e) {
          var i = [t, e], r = this.invTransform;
          return r && kX(i, i, r), i;
        }, n.prototype.transformCoordToGlobal = function(t, e) {
          var i = [t, e], r = this.transform;
          return r && kX(i, i, r), i;
        }, n.prototype.getLineScale = function() {
          var t = this.transform;
          return t && QL(t[0] - 1) > 1e-10 && QL(t[3] - 1) > 1e-10 ? Math.sqrt(QL(t[0] * t[3] - t[2] * t[1])) : 1;
        }, n.prototype.copyTransform = function(t) {
          T3t(this, t);
        }, n.getLocalTransform = function(t, e) {
          e = e || [];
          var i = t.originX || 0, r = t.originY || 0, a = t.scaleX, o = t.scaleY, s = t.anchorX, l = t.anchorY, u = t.rotation || 0, h = t.x, c = t.y, f = t.skewX ? Math.tan(t.skewX) : 0, g = t.skewY ? Math.tan(-t.skewY) : 0;
          if (i || r || s || l) {
            var d = i + s, A = r + l;
            e[4] = -d * a - f * A * o, e[5] = -A * o - g * d * a;
          } else e[4] = e[5] = 0;
          return e[0] = a, e[3] = o, e[1] = g * a, e[2] = f * o, u && C3t(e, e, u), e[4] += i + h, e[5] += r + c, e;
        }, n.initDefaultProps = function() {
          var t = n.prototype;
          t.scaleX = t.scaleY = t.globalScaleRatio = 1, t.x = t.y = t.originX = t.originY = t.skewX = t.skewY = t.rotation = t.anchorX = t.anchorY = 0;
        }(), n;
      }(), zX = ["x", "y", "originX", "originY", "anchorX", "anchorY", "rotation", "scaleX", "scaleY", "skewX", "skewY"];
      function T3t(n, t) {
        for (var e = 0; e < zX.length; e++) {
          var i = zX[e];
          n[i] = t[i];
        }
      }
      var ar = function() {
        function n(t, e) {
          this.x = t || 0, this.y = e || 0;
        }
        return n.prototype.copy = function(t) {
          return this.x = t.x, this.y = t.y, this;
        }, n.prototype.clone = function() {
          return new n(this.x, this.y);
        }, n.prototype.set = function(t, e) {
          return this.x = t, this.y = e, this;
        }, n.prototype.equal = function(t) {
          return t.x === this.x && t.y === this.y;
        }, n.prototype.add = function(t) {
          return this.x += t.x, this.y += t.y, this;
        }, n.prototype.scale = function(t) {
          this.x *= t, this.y *= t;
        }, n.prototype.scaleAndAdd = function(t, e) {
          this.x += t.x * e, this.y += t.y * e;
        }, n.prototype.sub = function(t) {
          return this.x -= t.x, this.y -= t.y, this;
        }, n.prototype.dot = function(t) {
          return this.x * t.x + this.y * t.y;
        }, n.prototype.len = function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, n.prototype.lenSquare = function() {
          return this.x * this.x + this.y * this.y;
        }, n.prototype.normalize = function() {
          var t = this.len();
          return this.x /= t, this.y /= t, this;
        }, n.prototype.distance = function(t) {
          var e = this.x - t.x, i = this.y - t.y;
          return Math.sqrt(e * e + i * i);
        }, n.prototype.distanceSquare = function(t) {
          var e = this.x - t.x, i = this.y - t.y;
          return e * e + i * i;
        }, n.prototype.negate = function() {
          return this.x = -this.x, this.y = -this.y, this;
        }, n.prototype.transform = function(t) {
          if (t) {
            var e = this.x, i = this.y;
            return this.x = t[0] * e + t[2] * i + t[4], this.y = t[1] * e + t[3] * i + t[5], this;
          }
        }, n.prototype.toArray = function(t) {
          return t[0] = this.x, t[1] = this.y, t;
        }, n.prototype.fromArray = function(t) {
          this.x = t[0], this.y = t[1];
        }, n.set = function(t, e, i) {
          t.x = e, t.y = i;
        }, n.copy = function(t, e) {
          t.x = e.x, t.y = e.y;
        }, n.len = function(t) {
          return Math.sqrt(t.x * t.x + t.y * t.y);
        }, n.lenSquare = function(t) {
          return t.x * t.x + t.y * t.y;
        }, n.dot = function(t, e) {
          return t.x * e.x + t.y * e.y;
        }, n.add = function(t, e, i) {
          t.x = e.x + i.x, t.y = e.y + i.y;
        }, n.sub = function(t, e, i) {
          t.x = e.x - i.x, t.y = e.y - i.y;
        }, n.scale = function(t, e, i) {
          t.x = e.x * i, t.y = e.y * i;
        }, n.scaleAndAdd = function(t, e, i, r) {
          t.x = e.x + i.x * r, t.y = e.y + i.y * r;
        }, n.lerp = function(t, e, i, r) {
          var a = 1 - r;
          t.x = a * e.x + r * i.x, t.y = a * e.y + r * i.y;
        }, n;
      }(), YI = Math.min, WI = Math.max, Dc = new ar(), Rc = new ar(), Lc = new ar(), Pc = new ar(), Dy = new ar(), Ry = new ar(), GX = function() {
        function n(t, e, i, r) {
          i < 0 && (t = t + i, i = -i), r < 0 && (e = e + r, r = -r), this.x = t, this.y = e, this.width = i, this.height = r;
        }
        return n.prototype.union = function(t) {
          var e = YI(t.x, this.x), i = YI(t.y, this.y);
          isFinite(this.x) && isFinite(this.width) ? this.width = WI(t.x + t.width, this.x + this.width) - e : this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = WI(t.y + t.height, this.y + this.height) - i : this.height = t.height, this.x = e, this.y = i;
        }, n.prototype.applyTransform = function(t) {
          n.applyTransform(this, this, t);
        }, n.prototype.calculateTransform = function(t) {
          var e = this, i = t.width / e.width, r = t.height / e.height, a = HI();
          return FX(a, a, [-e.x, -e.y]), S3t(a, a, [i, r]), FX(a, a, [t.x, t.y]), a;
        }, n.prototype.intersect = function(t, e) {
          if (!t) return false;
          t instanceof n || (t = n.create(t));
          var i = this, r = i.x, a = i.x + i.width, o = i.y, s = i.y + i.height, l = t.x, u = t.x + t.width, h = t.y, c = t.y + t.height, f = !(a < l || u < r || s < h || c < o);
          if (e) {
            var g = 1 / 0, d = 0, A = Math.abs(a - l), p = Math.abs(u - r), v = Math.abs(s - h), y = Math.abs(c - o), m = Math.min(A, p), _ = Math.min(v, y);
            a < l || u < r ? m > d && (d = m, A < p ? ar.set(Ry, -A, 0) : ar.set(Ry, p, 0)) : m < g && (g = m, A < p ? ar.set(Dy, A, 0) : ar.set(Dy, -p, 0)), s < h || c < o ? _ > d && (d = _, v < y ? ar.set(Ry, 0, -v) : ar.set(Ry, 0, y)) : m < g && (g = m, v < y ? ar.set(Dy, 0, v) : ar.set(Dy, 0, -y));
          }
          return e && ar.copy(e, f ? Dy : Ry), f;
        }, n.prototype.contain = function(t, e) {
          var i = this;
          return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i.height;
        }, n.prototype.clone = function() {
          return new n(this.x, this.y, this.width, this.height);
        }, n.prototype.copy = function(t) {
          n.copy(this, t);
        }, n.prototype.plain = function() {
          return { x: this.x, y: this.y, width: this.width, height: this.height };
        }, n.prototype.isFinite = function() {
          return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
        }, n.prototype.isZero = function() {
          return this.width === 0 || this.height === 0;
        }, n.create = function(t) {
          return new n(t.x, t.y, t.width, t.height);
        }, n.copy = function(t, e) {
          t.x = e.x, t.y = e.y, t.width = e.width, t.height = e.height;
        }, n.applyTransform = function(t, e, i) {
          if (!i) {
            t !== e && n.copy(t, e);
            return;
          }
          if (i[1] < 1e-5 && i[1] > -1e-5 && i[2] < 1e-5 && i[2] > -1e-5) {
            var r = i[0], a = i[3], o = i[4], s = i[5];
            t.x = e.x * r + o, t.y = e.y * a + s, t.width = e.width * r, t.height = e.height * a, t.width < 0 && (t.x += t.width, t.width = -t.width), t.height < 0 && (t.y += t.height, t.height = -t.height);
            return;
          }
          Dc.x = Lc.x = e.x, Dc.y = Pc.y = e.y, Rc.x = Pc.x = e.x + e.width, Rc.y = Lc.y = e.y + e.height, Dc.transform(i), Pc.transform(i), Rc.transform(i), Lc.transform(i), t.x = YI(Dc.x, Rc.x, Lc.x, Pc.x), t.y = YI(Dc.y, Rc.y, Lc.y, Pc.y);
          var l = WI(Dc.x, Rc.x, Lc.x, Pc.x), u = WI(Dc.y, Rc.y, Lc.y, Pc.y);
          t.width = l - t.x, t.height = u - t.y;
        }, n;
      }(), Nc = (n) => {
        var t = typeof n;
        return n !== null && (t === "object" || t === "function");
      }, UX = (n, t) => (Object.keys(t).forEach((e) => {
        Nc(t[e]) && Nc(n[e]) ? UX(n[e], t[e]) : n[e] = t[e];
      }), n), GL = function(n, t, ...e) {
        return function(...i) {
          return n.apply(t, e.concat(Array.prototype.slice.call(i)));
        };
      }, VX = function(n, t) {
        for (var e = 0, i, r = n.length; e < r; e++) if (n[e].index === t.index) {
          i = e;
          break;
        }
        return i === void 0 ? n.push(t) : n[i] = t, n;
      }, jX = function() {
        function n(t) {
          return t ? (t ^ Math.random() * 16 >> t / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, n);
        }
        return n();
      };
      function qX(n, t) {
        n.forEach((e) => {
          t[e] && (t[e] = t[e].bind(t));
        });
      }
      function UL(n) {
        return n && n.parentNode ? n.parentNode.removeChild(n) : null;
      }
      function XI(n, t) {
        var e = new MouseEvent(n, { bubbles: true, cancelable: true, button: t.pointerEvent.button, buttons: t.pointerEvent.buttons, clientX: t.pointerEvent.clientX, clientY: t.pointerEvent.clientY, zrX: t.pointerEvent.offsetX, zrY: t.pointerEvent.offsetY, movementX: t.pointerEvent.movementX, movementY: t.pointerEvent.movementY, relatedTarget: t.pointerEvent.relatedTarget, screenX: t.pointerEvent.screenX, screenY: t.pointerEvent.screenY, view: window });
        return e.zrX = t.pointerEvent.offsetX, e.zrY = t.pointerEvent.offsetY, e.event = e, e;
      }
      function B3t(n, t) {
        for (var e = n.split("."), i = t.split("."), r = 0; r < 3; r++) {
          var a = Number(e[r]), o = Number(i[r]);
          if (a > o) return 1;
          if (o > a) return -1;
          if (!isNaN(a) && isNaN(o)) return 1;
          if (isNaN(a) && !isNaN(o)) return -1;
        }
        return 0;
      }
      var M3t = (n) => !n.UTF8Encoding, HX = (n, t, e) => {
        for (var i = [], r = [t[0], t[1]], a = r[0], o = r[1], s = 0; s < n.length; s += 2) {
          var l = n.charCodeAt(s) - 64, u = n.charCodeAt(s + 1) - 64;
          l = l >> 1 ^ -(l & 1), u = u >> 1 ^ -(u & 1), l += a, u += o, a = l, o = u, i.push([l / e, u / e]);
        }
        return i;
      }, D3t = (n) => {
        if (M3t(n)) return n;
        var t = n.UTF8Scale;
        t == null && (t = 1024);
        for (var e = n.features, i = 0; i < e.length; i++) for (var r = e[i], a = r.geometry, o = [a.coordinates, a.encodeOffsets], s = o[0], l = o[1], u = 0; u < s.length; u++) {
          var h = s[u];
          if (a.type === "Polygon") s[u] = HX(h, l[u], t);
          else if (a.type === "MultiPolygon") for (var c = 0; c < h.length; c++) {
            var f = h[c];
            h[c] = HX(f, l[u][c], t);
          }
        }
        return n.UTF8Encoding = false, n;
      };
      function R3t(n) {
        var t = D3t(n), e = t.features.filter((r) => r.geometry && r.properties && r.geometry.coordinates.length > 0), i = e.map((r) => {
          var a = r.properties, o = r.geometry, s = o.coordinates, l = [];
          return o.type === "Polygon" && l.push(s[0]), o.type === "MultiPolygon" && s.forEach((u) => {
            u[0] && l.push(u[0]);
          }), { properties: a, type: "Feature", geometry: { type: "Polygon", coordinates: l } };
        });
        return { type: "FeatureCollection", crs: {}, features: i };
      }
      var L3t = function(n, t, e) {
        return t.center = e.dataToPoint(t.coordinates), t;
      }, P3t = function(n, t, e) {
        return Nc(n.grid) && !Array.isArray(n.grid) || Array.isArray(n.grid) && (n.grid = n.grid.map((i, r) => {
          var a = e.dataToPoint(n.series[r].coordinates);
          return i.left = a[0] - parseFloat(i.width) / 2, i.top = a[1] - parseFloat(i.height) / 2, i;
        })), t;
      }, N3t = function(n, t, e) {
        return Nc(n.grid) && !Array.isArray(n.grid) || Array.isArray(n.grid) && (n.grid = n.grid.map((i, r) => {
          var a = e.dataToPoint(n.series[r].coordinates);
          return i.left = a[0] - parseFloat(i.width) / 2, i.top = a[1] - parseFloat(i.height) / 2, i;
        })), t;
      }, F3t = Object.freeze({ pie: L3t, bar: P3t, line: N3t }), k3t = { forcedRerender: false, forcedPrecomposeRerender: false, hideOnZooming: false, hideOnMoving: false, hideOnRotating: false, convertTypes: ["pie", "line", "bar"], insertFirst: false, stopEvent: false, polyfillEvents: B3t(RZ, "6.1.1") <= 0 };
      class ll extends Kr {
        constructor(t, e, i) {
          var r = Object.assign(k3t, e);
          super(r), this._options = r, this._chartOptions = t, this.set("chartOptions", t), this.$chart = null, this.$container = void 0, this._isRegistered = false, this._initEvent = false, this._incremental = [], this._coordinateSystem = null, this.coordinateSystemId = "", this.prevVisibleState = "", qX(["redraw", "onResize", "onZoomEnd", "onCenterChange", "onDragRotateEnd", "onMoveStart", "onMoveEnd", "mouseDown", "mouseUp", "onClick", "mouseMove"], this), i && this.setMap(i);
        }
        appendTo(t, e = false) {
          this.setMap(t, e);
        }
        getMap() {
          return this._map;
        }
        setMap(t, e = false) {
          if (t && (e || t instanceof qw)) this._map = t, this._map.once("postrender", () => {
            this.handleMapChanged();
          }), this._map.renderSync();
          else throw new Error("not ol map object");
        }
        getChartOptions() {
          return this.get("chartOptions");
        }
        setChartOptions(t = {}) {
          return this._chartOptions = t, this.set("chartOptions", t), this.clearAndRedraw(), this;
        }
        appendData(t, e = true) {
          return t && (e && (this._incremental = VX(this._incremental, { index: this._incremental.length, data: t.data, seriesIndex: t.seriesIndex })), this.$chart.appendData({ data: t.data.copyWithin(), seriesIndex: t.seriesIndex })), this;
        }
        clear(t) {
          t || (this._incremental = []), this.$chart && this.$chart.clear();
        }
        remove() {
          this.clear(), this.$chart && this.$chart.dispose(), this._initEvent && this.$container && (this.$container && UL(this.$container), this.unBindEvent()), delete this.$chart, delete this._map;
        }
        show() {
          this.setVisible(true);
        }
        innerShow() {
          this.$container && (this.$container.style.display = this.prevVisibleState, this.prevVisibleState = "");
        }
        hide() {
          this.setVisible(false);
        }
        innerHide() {
          this.$container && (this.prevVisibleState = this.$container.style.display, this.$container.style.display = "none");
        }
        isVisible() {
          return this.$container && this.$container.style.display !== "none";
        }
        showLoading() {
          this.$chart && this.$chart.showLoading();
        }
        hideLoading() {
          this.$chart && this.$chart.hideLoading();
        }
        setZIndex(t) {
          this.$container && (typeof t == "number" && (t = String(t)), this.$container.style.zIndex = t);
        }
        getZIndex() {
          return this.$container && this.$container.style.zIndex;
        }
        setVisible(t) {
          t ? (this.$container && (this.$container.style.display = ""), this._chartOptions = this.getChartOptions(), this.clearAndRedraw()) : (this.$container && (this.$container.style.display = "none"), this.clear(true), this._chartOptions = {}, this.clearAndRedraw());
        }
        render() {
          !this.$chart && this.$container ? (this.$chart = vSt(this.$container), this._chartOptions && (this.registerMap(), this.$chart.setOption(this.convertData(this._chartOptions), false)), this.dispatchEvent({ type: "load", source: this, value: this.$chart })) : this.isVisible() && this.redraw();
        }
        redraw() {
          this.clearAndRedraw();
        }
        updateViewSize(t) {
          this.$container && (this.$container.style.width = `${t[0]}px`, this.$container.style.height = `${t[1]}px`, this.$container.setAttribute("width", String(t[0])), this.$container.setAttribute("height", String(t[1])));
        }
        onResize(t) {
          var e = this.getMap();
          if (e) {
            var i = e.getSize();
            this.updateViewSize(i), this.clearAndRedraw(), t && this.dispatchEvent({ type: "change:size", source: this, value: i });
          }
        }
        onZoomEnd() {
          this._options.hideOnZooming && this.innerShow();
          var t = this.getMap();
          t && t.getView() && (this.clearAndRedraw(), this.dispatchEvent({ type: "zoomend", source: this, value: t.getView().getZoom() }));
        }
        onDragRotateEnd() {
          this._options.hideOnRotating && this.innerShow();
          var t = this.getMap();
          t && t.getView() && (this.clearAndRedraw(), this.dispatchEvent({ type: "change:rotation", source: this, value: t.getView().getRotation() }));
        }
        onMoveStart() {
          this._options.hideOnMoving && this.innerHide();
          var t = this.getMap();
          t && t.getView() && this.dispatchEvent({ type: "movestart", source: this, value: t.getView().getCenter() });
        }
        onMoveEnd() {
          this._options.hideOnMoving && this.innerShow();
          var t = this.getMap();
          t && t.getView() && (this.clearAndRedraw(), this.dispatchEvent({ type: "moveend", source: this, value: t.getView().getCenter() }));
        }
        onClick(t) {
          this.$chart && this.$chart.getZr().painter.getViewportRoot().dispatchEvent(XI("click", t));
        }
        mouseDown(t) {
          this.$chart && this.$chart.getZr().painter.getViewportRoot().dispatchEvent(XI("mousedown", t));
        }
        mouseUp(t) {
          this.$chart && this.$chart.getZr().painter.getViewportRoot().dispatchEvent(XI("mouseup", t));
        }
        mouseMove(t) {
          if (this.$chart) for (var e = t.originalEvent.target; e; ) {
            if (e.className === "ol-overlaycontainer-stopevent") {
              this.$chart.getZr().painter.getViewportRoot().dispatchEvent(XI("mousemove", t));
              return;
            }
            e = e.parentElement;
          }
        }
        onCenterChange() {
          var t = this.getMap();
          t && t.getView() && (this.clearAndRedraw(), this.dispatchEvent({ type: "change:center", source: this, value: t.getView().getCenter() }));
        }
        handleMapChanged() {
          var t = this.getMap();
          if (this._initEvent && this.$container && (this.$container && UL(this.$container), this.unBindEvent()), this.$container || (this.createLayerContainer(), this.onResize(false)), t) {
            var e = this._options.stopEvent ? t.getOverlayContainerStopEvent() : t.getOverlayContainer();
            this._options.insertFirst ? e.insertBefore(this.$container, e.childNodes[0] || null) : e.appendChild(this.$container), this.render(), this.bindEvent(t);
          }
        }
        createLayerContainer() {
          this.$container = document.createElement("div"), this.$container.style.position = "absolute", this.$container.style.top = "0px", this.$container.style.left = "0px", this.$container.style.right = "0px", this.$container.style.bottom = "0px", this.$container.style.pointerEvents = "auto";
        }
        bindEvent(t) {
          var e = t.getView();
          this._options.forcedPrecomposeRerender && t.on("precompose", this.redraw), t.on("change:size", this.onResize), e.on("change:resolution", this.onZoomEnd), e.on("change:center", this.onCenterChange), e.on("change:rotation", this.onDragRotateEnd), t.on("movestart", this.onMoveStart), t.on("moveend", this.onMoveEnd), this._options.polyfillEvents && (t.on("pointerdown", this.mouseDown), t.on("pointerup", this.mouseUp), t.on("pointermove", this.mouseMove), t.on("click", this.onClick)), this._initEvent = true;
        }
        unBindEvent() {
          var t = this.getMap();
          if (t) {
            var e = t.getView();
            e && (t.un("precompose", this.redraw), t.un("change:size", this.onResize), e.un("change:resolution", this.onZoomEnd), e.un("change:center", this.onCenterChange), e.un("change:rotation", this.onDragRotateEnd), t.un("movestart", this.onMoveStart), t.un("moveend", this.onMoveEnd), this._options.polyfillEvents && (t.un("pointerdown", this.mouseDown), t.un("pointerup", this.mouseUp), t.un("pointermove", this.mouseMove), t.un("click", this.onClick)), this._initEvent = false);
          }
        }
        clearAndRedraw() {
          if (!(!this.$chart || !this.isVisible())) {
            if (this._options.forcedRerender && this.$chart.clear(), this.$chart.resize(), this._chartOptions && (this.registerMap(), this.$chart.setOption(this.convertData(this._chartOptions), false), this._incremental && this._incremental.length > 0)) for (var t = 0; t < this._incremental.length; t++) this.appendData(this._incremental[t], false);
            this.dispatchEvent({ type: "redraw", source: this });
          }
        }
        registerMap() {
          if (this._isRegistered || (this.coordinateSystemId = `openlayers_${jX()}`, _V(this.coordinateSystemId, this.getCoordinateSystem(this._options)), this._isRegistered = true), this._chartOptions) {
            var t = this._chartOptions.series;
            if (t && Nc(t)) {
              var e = this._options.convertTypes;
              if (e) for (var i = t.length - 1; i >= 0; i--) e.indexOf(t[i].type) > -1 || (t[i].coordinateSystem = this.coordinateSystemId), t[i].animation = false;
            }
          }
        }
        convertData(t) {
          var e = t.series;
          if (e && e.length > 0) {
            if (!this._coordinateSystem) {
              var i = this.getCoordinateSystem(this._options);
              this._coordinateSystem = new i(this.getMap());
            }
            if (e && Nc(e)) {
              var r = this._options.convertTypes;
              if (r) for (var a = e.length - 1; a >= 0; a--) r.indexOf(e[a].type) > -1 && e[a] && e[a].hasOwnProperty("coordinates") && (e[a] = F3t[e[a].type](t, e[a], this._coordinateSystem));
            }
          }
          return t;
        }
        getCoordinateSystem(t) {
          var e = this.getMap(), i = this.coordinateSystemId;
          class r {
            constructor(o) {
              this._mapOffset = [0, 0], this.dimensions = ["lng", "lat"], this._roamTransformable = new zL(), this._rawTransformable = new zL(), this._viewRect = new GX(0, 0, 0, 0), this.map = o, this.dimensions = ["lng", "lat"], this.projCode = r.getProjectionCode(this.map);
            }
            getZoom() {
              return this.map.getView().getZoom();
            }
            setZoom(o) {
              return this.map.getView().setZoom(o);
            }
            getViewRectAfterRoam() {
              return this.getViewRect().clone();
            }
            setMapOffset(o) {
              this._mapOffset = o;
            }
            dataToPoint(o) {
              var s;
              if (o && Array.isArray(o) && o.length > 0) {
                s = o.map((f) => {
                  var g = 0;
                  return typeof f == "string" ? g = Number(f) : g = f, g;
                });
                var l = t && t.source || "EPSG:4326", u = t && t.destination || this.projCode, h = this.map.getPixelFromCoordinate(po(s, l, u)), c = this._mapOffset;
                return [h[0] - c[0], h[1] - c[1]];
              }
              return [0, 0];
            }
            pointToData(o) {
              var s = this._mapOffset;
              return this.map.getCoordinateFromPixel([o[0] + s[0], o[1] + s[1]]);
            }
            setViewRect() {
              var o = this.map.getSize();
              this._viewRect = new GX(0, 0, o[0], o[1]);
            }
            getViewRect() {
              return this._viewRect;
            }
            getRoamTransform() {
              return this._roamTransformable.getLocalTransform();
            }
            prepareCustoms() {
              var o = this.getViewRect();
              return { coordSys: { type: i, x: o.x, y: o.y, width: o.width, height: o.height }, api: { coord: GL(this.dataToPoint, this), size: GL(this.dataToCoordsSize, this) } };
            }
            dataToCoordsSize(o, s = [0, 0]) {
              return [0, 1].map((l) => {
                var u = s[l], h = [], c = [], f = o[l] / 2;
                h[l] = u - f, c[l] = u + f, h[1 - l] = s[1 - l], c[1 - l] = s[1 - l];
                var g = this.dataToPoint(h)[l] - this.dataToPoint(c)[l];
                return Math.abs(g);
              });
            }
            getTransformInfo() {
              var o = this._rawTransformable, s = this._roamTransformable, l = new zL();
              return l.transform = s.transform, l.decomposeTransform(), { roam: { x: l.x, y: l.y, scaleX: l.scaleX, scaleY: l.scaleY }, raw: { x: o.x, y: o.y, scaleX: o.scaleX, scaleY: o.scaleY } };
            }
          }
          return r.dimensions = r.prototype.dimensions || ["lng", "lat"], r.create = function(a) {
            a.eachSeries((o) => {
              o.get("coordinateSystem") === i && (o.coordinateSystem = new r(e));
            });
          }, r.getProjectionCode = function(a) {
            var o = "";
            return a ? o = a.getView() && a.getView().getProjection().getCode() : o = "EPSG:3857", o;
          }, r;
        }
        dispatchEvent(t) {
          return super.dispatchEvent(t);
        }
        set(t, e, i) {
          return super.set(t, e, i);
        }
        get(t) {
          return super.get(t);
        }
        unset(t, e) {
          return super.unset(t, e);
        }
        on(t, e) {
          return super.on(t, e);
        }
        un(t, e) {
          return super.un(t, e);
        }
      }
      ll.formatGeoJSON = R3t, ll.bind = GL, ll.merge = UX, ll.uuid = jX, ll.bindAll = qX, ll.arrayAdd = VX, ll.removeNode = UL, ll.isObject = Nc;
      const VL = P.defineComponent({ name: "OlEcharts", __name: "index", props: { chartOptions: {}, options: {}, zIndex: {}, visible: { type: Boolean, default: true } }, emits: ["load"], setup(n, { emit: t }) {
        const e = P.inject("VMap"), i = P.unref(e).map;
        let r = P.shallowRef(), a = P.ref(false);
        const o = n, s = t, l = () => {
          var u;
          r.value = new ll(o.chartOptions, o.options), r.value.on("load", () => {
            a.value = true, s("load");
          }), o.zIndex && r.value.setZIndex(o.zIndex), r.value.setVisible(o.visible), (u = r.value) == null || u.appendTo(i);
        };
        return P.watch(() => o.visible, (u) => {
          var h;
          (h = r.value) == null || h.setVisible(u);
        }), P.watch(() => o.zIndex, (u) => {
          var h;
          (u || u === 0 || u === null) && ((h = r.value) == null || h.setZIndex(u));
        }), P.watch(() => o.chartOptions, (u) => {
          var h;
          u && ((h = r.value) == null || h.setChartOptions(u));
        }, { deep: true }), P.onMounted(() => {
          l();
        }), P.onBeforeUnmount(() => {
          var u;
          (u = r.value) == null || u.remove();
        }), (u, h) => P.unref(a) ? P.renderSlot(u.$slots, "default", { key: 0 }) : P.createCommentVNode("", true);
      } }), O3t = (n) => n.component(VL.name || "OlEcharts", VL), jL = P.defineComponent({ name: "OlConfig", __name: "index", props: { map: {}, tdt: {}, baidu: {}, amap: {} }, setup(n) {
        let t = P.ref(false);
        const e = n, i = () => Tt(this, null, function* () {
          P.provide("ConfigProvide", e);
        });
        return P.onMounted(() => Tt(this, null, function* () {
          i().then(() => {
            t.value = true;
          });
        })), (r, a) => P.unref(t) ? P.renderSlot(r.$slots, "default", { key: 0 }) : P.createCommentVNode("", true);
      } }), Q3t = [Vst, kct, Oct, hyt, cyt, xyt, wyt, Cyt, Syt, byt, Ryt, Lyt, Pyt, Nyt, Fyt, kyt, Oyt, Qyt, Vyt, jyt, qyt, imt, T_t, O3t, (n) => n.component(jL.name || "OlConfig", jL)], Ly = { tdt: { ak: "", Normal: "https://t0.tianditu.gov.cn/DataServer?T=vec_w&X={x}&Y={y}&L={z}&tk=", Normal_Label: "https://t0.tianditu.gov.cn/DataServer?T=cva_w&X={x}&Y={y}&L={z}&tk=", Satellite: "https://t0.tianditu.gov.cn/DataServer?T=img_w&X={x}&Y={y}&L={z}&tk=", Satellite_Label: "https://t0.tianditu.gov.cn/DataServer?T=cia_w&X={x}&Y={y}&L={z}&tk=", Terrain: "https://t0.tianditu.gov.cn/DataServer?T=ter_w&X={x}&Y={y}&L={z}&tk=", Terrain_Label: "https://t0.tianditu.gov.cn/DataServer?T=cta_w&X={x}&Y={y}&L={z}&tk=" }, baidu: { ak: "", Normal: "https://maponline1.bdimg.com/tile/?qt=vtile&x={x}&y={y}&z={z}&styles=pl&scaler=1&udt=20220113&from=jsapi2_0", Satellite: "https://maponline3.bdimg.com/starpic/?qt=satepc&u=x={x};y={y};z={z};v=009;type=sate&fm=46&udt=20240910", Satellite_Label: "https://maponline0.bdimg.com/tile/?qt=vtile&x={x}&y={y}&z={z}&styles=sl&udt=20240910", midnight: "http://api0.map.bdimg.com/customimage/tile?&x={x}&y={y}&z={z}&udt=20220819&scale=1&customid=midnight&ak=" }, amap: { Normal: "http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}", Satellite: "http://webst01.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}", Satellite_Label: "http://webst01.is.autonavi.com/appmaptile?style=8&x={x}&y={y}&z={z}" } }, $I = Ly, z3t = Symbol(), YX = (n = []) => ({ install: (e, i) => {
        n.forEach((a) => e.use(a));
        let r = Ly;
        i && (e.config.globalProperties.$OlMapConfig = i, i.tdt && (r.tdt = rt(rt({}, Ly.tdt), i.tdt)), i.baidu && (r.baidu = rt(rt({}, Ly.baidu), i.baidu)), r.amap = rt(rt({}, Ly.amap), i.amap), r.map = rt({}, i.map)), e.provide("$OlMapConfig", { map: r.map, TDT: r.tdt, Baidu: r.tdt, AMap: r.tdt });
      } }), G3t = YX([...Q3t]);
      var WX = ((n) => (n.TDT = "TDT", n.TDT_SATELLITE = "TDT_SATELLITE", n.TDT_TERRAIN = "TDT_TERRAIN", n.MAPBOX = "MAPBOX", n.BAIDU = "BAIDU", n.BAIDU_SATELLITE = "BAIDU_SATELLITE", n.BAIDU_MIDNIGHT = "BAIDU_MIDNIGHT", n.AMAP = "AMAP", n.AMAP_SATELLITE = "AMAP_SATELLITE", n.GEOTIFF = "GEOTIFF", n.CUSTOMER = "CUSTOMER", n.XYZ = "XYZ", n.OSM = "OSM", n))(WX || {});
      class U3t extends ah {
        decodeBlock(t) {
          return t;
        }
      }
      const V3t = Object.freeze(Object.defineProperty({ __proto__: null, default: U3t }, Symbol.toStringTag, { value: "Module" })), XX = 9, qL = 256, HL = 257, j3t = 12;
      function q3t(n, t, e) {
        const i = t % 8, r = Math.floor(t / 8), a = 8 - i, o = t + e - (r + 1) * 8;
        let s = 8 * (r + 2) - (t + e);
        const l = (r + 2) * 8 - t;
        if (s = Math.max(0, s), r >= n.length) return HL;
        let u = n[r] & jn(2, 8 - i) - 1;
        u <<= e - a;
        let h = u;
        if (r + 1 < n.length) {
          let c = n[r + 1] >>> s;
          c <<= Math.max(0, e - l), h += c;
        }
        if (o > 8 && r + 2 < n.length) {
          const c = (r + 3) * 8 - (t + e), f = n[r + 2] >>> c;
          h += f;
        }
        return h;
      }
      function YL(n, t) {
        for (let e = t.length - 1; e >= 0; e--) n.push(t[e]);
        return n;
      }
      function H3t(n) {
        const t = new Uint16Array(4093), e = new Uint8Array(4093);
        for (let d = 0; d <= 257; d++) t[d] = 4096, e[d] = d;
        let i = 258, r = XX, a = 0;
        function o() {
          i = 258, r = XX;
        }
        function s(d) {
          const A = q3t(d, a, r);
          return a += r, A;
        }
        function l(d, A) {
          return e[i] = A, t[i] = d, i++, i - 1;
        }
        function u(d) {
          const A = [];
          for (let p = d; p !== 4096; p = t[p]) A.push(e[p]);
          return A;
        }
        const h = [];
        o();
        const c = new Uint8Array(n);
        let f = s(c), g;
        for (; f !== HL; ) {
          if (f === qL) {
            for (o(), f = s(c); f === qL; ) f = s(c);
            if (f === HL) break;
            if (f > qL) throw new Error(`corrupted code at scanline ${f}`);
            {
              const d = u(f);
              YL(h, d), g = f;
            }
          } else if (f < i) {
            const d = u(f);
            YL(h, d), l(g, d[d.length - 1]), g = f;
          } else {
            const d = u(g);
            if (!d) throw new Error(`Bogus entry. Not in dictionary, ${g} / ${i}, position: ${a}`);
            YL(h, d), h.push(d[d.length - 1]), l(g, d[d.length - 1]), g = f;
          }
          i + 1 >= jn(2, r) && (r === j3t ? g = void 0 : r++), f = s(c);
        }
        return new Uint8Array(h);
      }
      class Y3t extends ah {
        decodeBlock(t) {
          return H3t(t).buffer;
        }
      }
      const W3t = Object.freeze(Object.defineProperty({ __proto__: null, default: Y3t }, Symbol.toStringTag, { value: "Module" })), Py = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), ZI = 4017, KI = 799, JI = 3406, tx = 2276, ex = 1567, nx = 3784, kd = 5793, ix = 2896;
      function $X(n, t) {
        let e = 0;
        const i = [];
        let r = 16;
        for (; r > 0 && !n[r - 1]; ) --r;
        i.push({ children: [], index: 0 });
        let a = i[0], o;
        for (let s = 0; s < r; s++) {
          for (let l = 0; l < n[s]; l++) {
            for (a = i.pop(), a.children[a.index] = t[e]; a.index > 0; ) a = i.pop();
            for (a.index++, i.push(a); i.length <= s; ) i.push(o = { children: [], index: 0 }), a.children[a.index] = o.children, a = o;
            e++;
          }
          s + 1 < r && (i.push(o = { children: [], index: 0 }), a.children[a.index] = o.children, a = o);
        }
        return i[0].children;
      }
      function X3t(n, t, e, i, r, a, o, s, l) {
        const { mcusPerLine: u, progressive: h } = e, c = t;
        let f = t, g = 0, d = 0;
        function A() {
          if (d > 0) return d--, g >> d & 1;
          if (g = n[f++], g === 255) {
            const G = n[f++];
            if (G) throw new Error(`unexpected marker: ${(g << 8 | G).toString(16)}`);
          }
          return d = 7, g >>> 7;
        }
        function p(G) {
          let $ = G, J;
          for (; (J = A()) !== null; ) {
            if ($ = $[J], typeof $ == "number") return $;
            if (typeof $ != "object") throw new Error("invalid huffman sequence");
          }
          return null;
        }
        function v(G) {
          let $ = G, J = 0;
          for (; $ > 0; ) {
            const et = A();
            if (et === null) return;
            J = J << 1 | et, --$;
          }
          return J;
        }
        function y(G) {
          const $ = v(G);
          return $ >= 1 << G - 1 ? $ : $ + (-1 << G) + 1;
        }
        function m(G, $) {
          const J = p(G.huffmanTableDC), et = J === 0 ? 0 : y(J);
          G.pred += et, $[0] = G.pred;
          let nt = 1;
          for (; nt < 64; ) {
            const gt = p(G.huffmanTableAC), q = gt & 15, W = gt >> 4;
            if (q === 0) {
              if (W < 15) break;
              nt += 16;
            } else {
              nt += W;
              const it = Py[nt];
              $[it] = y(q), nt++;
            }
          }
        }
        function _(G, $) {
          const J = p(G.huffmanTableDC), et = J === 0 ? 0 : y(J) << l;
          G.pred += et, $[0] = G.pred;
        }
        function I(G, $) {
          $[0] |= A() << l;
        }
        let E = 0;
        function x(G, $) {
          if (E > 0) {
            E--;
            return;
          }
          let J = a;
          const et = o;
          for (; J <= et; ) {
            const nt = p(G.huffmanTableAC), gt = nt & 15, q = nt >> 4;
            if (gt === 0) {
              if (q < 15) {
                E = v(q) + (1 << q) - 1;
                break;
              }
              J += 16;
            } else {
              J += q;
              const W = Py[J];
              $[W] = y(gt) * (1 << l), J++;
            }
          }
        }
        let w = 0, C;
        function S(G, $) {
          let J = a;
          const et = o;
          let nt = 0;
          for (; J <= et; ) {
            const gt = Py[J], q = $[gt] < 0 ? -1 : 1;
            switch (w) {
              case 0: {
                const W = p(G.huffmanTableAC), it = W & 15;
                if (nt = W >> 4, it === 0) nt < 15 ? (E = v(nt) + (1 << nt), w = 4) : (nt = 16, w = 1);
                else {
                  if (it !== 1) throw new Error("invalid ACn encoding");
                  C = y(it), w = nt ? 2 : 3;
                }
                continue;
              }
              case 1:
              case 2:
                $[gt] ? $[gt] += (A() << l) * q : (nt--, nt === 0 && (w = w === 2 ? 3 : 0));
                break;
              case 3:
                $[gt] ? $[gt] += (A() << l) * q : ($[gt] = C << l, w = 0);
                break;
              case 4:
                $[gt] && ($[gt] += (A() << l) * q);
                break;
            }
            J++;
          }
          w === 4 && (E--, E === 0 && (w = 0));
        }
        function b(G, $, J, et, nt) {
          const gt = J / u | 0, q = J % u, W = gt * G.v + et, it = q * G.h + nt;
          $(G, G.blocks[W][it]);
        }
        function T(G, $, J) {
          const et = J / G.blocksPerLine | 0, nt = J % G.blocksPerLine;
          $(G, G.blocks[et][nt]);
        }
        const B = i.length;
        let R, M, L, N, F, k;
        h ? a === 0 ? k = s === 0 ? _ : I : k = s === 0 ? x : S : k = m;
        let O = 0, Q, j;
        B === 1 ? j = i[0].blocksPerLine * i[0].blocksPerColumn : j = u * e.mcusPerColumn;
        const Y = r || j;
        for (; O < j; ) {
          for (M = 0; M < B; M++) i[M].pred = 0;
          if (E = 0, B === 1) for (R = i[0], F = 0; F < Y; F++) T(R, k, O), O++;
          else for (F = 0; F < Y; F++) {
            for (M = 0; M < B; M++) {
              R = i[M];
              const { h: G, v: $ } = R;
              for (L = 0; L < $; L++) for (N = 0; N < G; N++) b(R, k, O, L, N);
            }
            if (O++, O === j) break;
          }
          if (d = 0, Q = n[f] << 8 | n[f + 1], Q < 65280) throw new Error("marker was not found");
          if (Q >= 65488 && Q <= 65495) f += 2;
          else break;
        }
        return f - c;
      }
      function $3t(n, t) {
        const e = [], { blocksPerLine: i, blocksPerColumn: r } = t, a = i << 3, o = new Int32Array(64), s = new Uint8Array(64);
        function l(u, h, c) {
          const f = t.quantizationTable;
          let g, d, A, p, v, y, m, _, I;
          const E = c;
          let x;
          for (x = 0; x < 64; x++) E[x] = u[x] * f[x];
          for (x = 0; x < 8; ++x) {
            const w = 8 * x;
            if (E[1 + w] === 0 && E[2 + w] === 0 && E[3 + w] === 0 && E[4 + w] === 0 && E[5 + w] === 0 && E[6 + w] === 0 && E[7 + w] === 0) {
              I = kd * E[0 + w] + 512 >> 10, E[0 + w] = I, E[1 + w] = I, E[2 + w] = I, E[3 + w] = I, E[4 + w] = I, E[5 + w] = I, E[6 + w] = I, E[7 + w] = I;
              continue;
            }
            g = kd * E[0 + w] + 128 >> 8, d = kd * E[4 + w] + 128 >> 8, A = E[2 + w], p = E[6 + w], v = ix * (E[1 + w] - E[7 + w]) + 128 >> 8, _ = ix * (E[1 + w] + E[7 + w]) + 128 >> 8, y = E[3 + w] << 4, m = E[5 + w] << 4, I = g - d + 1 >> 1, g = g + d + 1 >> 1, d = I, I = A * nx + p * ex + 128 >> 8, A = A * ex - p * nx + 128 >> 8, p = I, I = v - m + 1 >> 1, v = v + m + 1 >> 1, m = I, I = _ + y + 1 >> 1, y = _ - y + 1 >> 1, _ = I, I = g - p + 1 >> 1, g = g + p + 1 >> 1, p = I, I = d - A + 1 >> 1, d = d + A + 1 >> 1, A = I, I = v * tx + _ * JI + 2048 >> 12, v = v * JI - _ * tx + 2048 >> 12, _ = I, I = y * KI + m * ZI + 2048 >> 12, y = y * ZI - m * KI + 2048 >> 12, m = I, E[0 + w] = g + _, E[7 + w] = g - _, E[1 + w] = d + m, E[6 + w] = d - m, E[2 + w] = A + y, E[5 + w] = A - y, E[3 + w] = p + v, E[4 + w] = p - v;
          }
          for (x = 0; x < 8; ++x) {
            const w = x;
            if (E[1 * 8 + w] === 0 && E[2 * 8 + w] === 0 && E[3 * 8 + w] === 0 && E[4 * 8 + w] === 0 && E[5 * 8 + w] === 0 && E[6 * 8 + w] === 0 && E[7 * 8 + w] === 0) {
              I = kd * c[x + 0] + 8192 >> 14, E[0 * 8 + w] = I, E[1 * 8 + w] = I, E[2 * 8 + w] = I, E[3 * 8 + w] = I, E[4 * 8 + w] = I, E[5 * 8 + w] = I, E[6 * 8 + w] = I, E[7 * 8 + w] = I;
              continue;
            }
            g = kd * E[0 * 8 + w] + 2048 >> 12, d = kd * E[4 * 8 + w] + 2048 >> 12, A = E[2 * 8 + w], p = E[6 * 8 + w], v = ix * (E[1 * 8 + w] - E[7 * 8 + w]) + 2048 >> 12, _ = ix * (E[1 * 8 + w] + E[7 * 8 + w]) + 2048 >> 12, y = E[3 * 8 + w], m = E[5 * 8 + w], I = g - d + 1 >> 1, g = g + d + 1 >> 1, d = I, I = A * nx + p * ex + 2048 >> 12, A = A * ex - p * nx + 2048 >> 12, p = I, I = v - m + 1 >> 1, v = v + m + 1 >> 1, m = I, I = _ + y + 1 >> 1, y = _ - y + 1 >> 1, _ = I, I = g - p + 1 >> 1, g = g + p + 1 >> 1, p = I, I = d - A + 1 >> 1, d = d + A + 1 >> 1, A = I, I = v * tx + _ * JI + 2048 >> 12, v = v * JI - _ * tx + 2048 >> 12, _ = I, I = y * KI + m * ZI + 2048 >> 12, y = y * ZI - m * KI + 2048 >> 12, m = I, E[0 * 8 + w] = g + _, E[7 * 8 + w] = g - _, E[1 * 8 + w] = d + m, E[6 * 8 + w] = d - m, E[2 * 8 + w] = A + y, E[5 * 8 + w] = A - y, E[3 * 8 + w] = p + v, E[4 * 8 + w] = p - v;
          }
          for (x = 0; x < 64; ++x) {
            const w = 128 + (E[x] + 8 >> 4);
            w < 0 ? h[x] = 0 : w > 255 ? h[x] = 255 : h[x] = w;
          }
        }
        for (let u = 0; u < r; u++) {
          const h = u << 3;
          for (let c = 0; c < 8; c++) e.push(new Uint8Array(a));
          for (let c = 0; c < i; c++) {
            l(t.blocks[u][c], s, o);
            let f = 0;
            const g = c << 3;
            for (let d = 0; d < 8; d++) {
              const A = e[h + d];
              for (let p = 0; p < 8; p++) A[g + p] = s[f++];
            }
          }
        }
        return e;
      }
      class Z3t {
        constructor() {
          this.jfif = null, this.adobe = null, this.quantizationTables = [], this.huffmanTablesAC = [], this.huffmanTablesDC = [], this.resetFrames();
        }
        resetFrames() {
          this.frames = [];
        }
        parse(t) {
          let e = 0;
          function i() {
            const s = t[e] << 8 | t[e + 1];
            return e += 2, s;
          }
          function r() {
            const s = i(), l = t.subarray(e, e + s - 2);
            return e += l.length, l;
          }
          function a(s) {
            let l = 0, u = 0, h, c;
            for (c in s.components) s.components.hasOwnProperty(c) && (h = s.components[c], l < h.h && (l = h.h), u < h.v && (u = h.v));
            const f = Math.ceil(s.samplesPerLine / 8 / l), g = Math.ceil(s.scanLines / 8 / u);
            for (c in s.components) if (s.components.hasOwnProperty(c)) {
              h = s.components[c];
              const d = Math.ceil(Math.ceil(s.samplesPerLine / 8) * h.h / l), A = Math.ceil(Math.ceil(s.scanLines / 8) * h.v / u), p = f * h.h, v = g * h.v, y = [];
              for (let m = 0; m < v; m++) {
                const _ = [];
                for (let I = 0; I < p; I++) _.push(new Int32Array(64));
                y.push(_);
              }
              h.blocksPerLine = d, h.blocksPerColumn = A, h.blocks = y;
            }
            s.maxH = l, s.maxV = u, s.mcusPerLine = f, s.mcusPerColumn = g;
          }
          let o = i();
          if (o !== 65496) throw new Error("SOI not found");
          for (o = i(); o !== 65497; ) {
            switch (o) {
              case 65280:
                break;
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534: {
                const s = r();
                o === 65504 && s[0] === 74 && s[1] === 70 && s[2] === 73 && s[3] === 70 && s[4] === 0 && (this.jfif = { version: { major: s[5], minor: s[6] }, densityUnits: s[7], xDensity: s[8] << 8 | s[9], yDensity: s[10] << 8 | s[11], thumbWidth: s[12], thumbHeight: s[13], thumbData: s.subarray(14, 14 + 3 * s[12] * s[13]) }), o === 65518 && s[0] === 65 && s[1] === 100 && s[2] === 111 && s[3] === 98 && s[4] === 101 && s[5] === 0 && (this.adobe = { version: s[6], flags0: s[7] << 8 | s[8], flags1: s[9] << 8 | s[10], transformCode: s[11] });
                break;
              }
              case 65499: {
                const l = i() + e - 2;
                for (; e < l; ) {
                  const u = t[e++], h = new Int32Array(64);
                  if (u >> 4) if (u >> 4 === 1) for (let c = 0; c < 64; c++) {
                    const f = Py[c];
                    h[f] = i();
                  }
                  else throw new Error("DQT: invalid table spec");
                  else for (let c = 0; c < 64; c++) {
                    const f = Py[c];
                    h[f] = t[e++];
                  }
                  this.quantizationTables[u & 15] = h;
                }
                break;
              }
              case 65472:
              case 65473:
              case 65474: {
                i();
                const s = { extended: o === 65473, progressive: o === 65474, precision: t[e++], scanLines: i(), samplesPerLine: i(), components: {}, componentsOrder: [] }, l = t[e++];
                let u;
                for (let h = 0; h < l; h++) {
                  u = t[e];
                  const c = t[e + 1] >> 4, f = t[e + 1] & 15, g = t[e + 2];
                  s.componentsOrder.push(u), s.components[u] = { h: c, v: f, quantizationIdx: g }, e += 3;
                }
                a(s), this.frames.push(s);
                break;
              }
              case 65476: {
                const s = i();
                for (let l = 2; l < s; ) {
                  const u = t[e++], h = new Uint8Array(16);
                  let c = 0;
                  for (let g = 0; g < 16; g++, e++) h[g] = t[e], c += h[g];
                  const f = new Uint8Array(c);
                  for (let g = 0; g < c; g++, e++) f[g] = t[e];
                  l += 17 + c, u >> 4 ? this.huffmanTablesAC[u & 15] = $X(h, f) : this.huffmanTablesDC[u & 15] = $X(h, f);
                }
                break;
              }
              case 65501:
                i(), this.resetInterval = i();
                break;
              case 65498: {
                i();
                const s = t[e++], l = [], u = this.frames[0];
                for (let d = 0; d < s; d++) {
                  const A = u.components[t[e++]], p = t[e++];
                  A.huffmanTableDC = this.huffmanTablesDC[p >> 4], A.huffmanTableAC = this.huffmanTablesAC[p & 15], l.push(A);
                }
                const h = t[e++], c = t[e++], f = t[e++], g = X3t(t, e, u, l, this.resetInterval, h, c, f >> 4, f & 15);
                e += g;
                break;
              }
              case 65535:
                t[e] !== 255 && e--;
                break;
              default:
                if (t[e - 3] === 255 && t[e - 2] >= 192 && t[e - 2] <= 254) {
                  e -= 3;
                  break;
                }
                throw new Error(`unknown JPEG marker ${o.toString(16)}`);
            }
            o = i();
          }
        }
        getResult() {
          const { frames: t } = this;
          if (this.frames.length === 0) throw new Error("no frames were decoded");
          this.frames.length > 1;
          for (let h = 0; h < this.frames.length; h++) {
            const c = this.frames[h].components;
            for (const f of Object.keys(c)) c[f].quantizationTable = this.quantizationTables[c[f].quantizationIdx], delete c[f].quantizationIdx;
          }
          const e = t[0], { components: i, componentsOrder: r } = e, a = [], o = e.samplesPerLine, s = e.scanLines;
          for (let h = 0; h < r.length; h++) {
            const c = i[r[h]];
            a.push({ lines: $3t(e, c), scaleX: c.h / e.maxH, scaleY: c.v / e.maxV });
          }
          const l = new Uint8Array(o * s * a.length);
          let u = 0;
          for (let h = 0; h < s; ++h) for (let c = 0; c < o; ++c) for (let f = 0; f < a.length; ++f) {
            const g = a[f];
            l[u] = g.lines[0 | h * g.scaleY][0 | c * g.scaleX], ++u;
          }
          return l;
        }
      }
      class K3t extends ah {
        constructor(t) {
          super(), this.reader = new Z3t(), t.JPEGTables && this.reader.parse(t.JPEGTables);
        }
        decodeBlock(t) {
          return this.reader.resetFrames(), this.reader.parse(new Uint8Array(t)), this.reader.getResult().buffer;
        }
      }
      const J3t = Object.freeze(Object.defineProperty({ __proto__: null, default: K3t }, Symbol.toStringTag, { value: "Module" }));
      const tzt = 4, ZX = 0, KX = 1, ezt = 2;
      function Od(n) {
        let t = n.length;
        for (; --t >= 0; ) n[t] = 0;
      }
      const nzt = 0, JX = 1, izt = 2, rzt = 3, azt = 258, WL = 29, Ny = 256, Fy = Ny + 1 + WL, Qd = 30, XL = 19, t$ = 2 * Fy + 1, Fc = 15, $L = 16, ozt = 7, ZL = 256, e$ = 16, n$ = 17, i$ = 18, KL = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]), rx = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), szt = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]), r$ = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), lzt = 512, ul = new Array((Fy + 2) * 2);
      Od(ul);
      const ky = new Array(Qd * 2);
      Od(ky);
      const Oy = new Array(lzt);
      Od(Oy);
      const Qy = new Array(azt - rzt + 1);
      Od(Qy);
      const JL = new Array(WL);
      Od(JL);
      const ax = new Array(Qd);
      Od(ax);
      function tP(n, t, e, i, r) {
        this.static_tree = n, this.extra_bits = t, this.extra_base = e, this.elems = i, this.max_length = r, this.has_stree = n && n.length;
      }
      let a$, o$, s$;
      function eP(n, t) {
        this.dyn_tree = n, this.max_code = 0, this.stat_desc = t;
      }
      const l$ = (n) => n < 256 ? Oy[n] : Oy[256 + (n >>> 7)], zy = (n, t) => {
        n.pending_buf[n.pending++] = t & 255, n.pending_buf[n.pending++] = t >>> 8 & 255;
      }, Tr = (n, t, e) => {
        n.bi_valid > $L - e ? (n.bi_buf |= t << n.bi_valid & 65535, zy(n, n.bi_buf), n.bi_buf = t >> $L - n.bi_valid, n.bi_valid += e - $L) : (n.bi_buf |= t << n.bi_valid & 65535, n.bi_valid += e);
      }, us = (n, t, e) => {
        Tr(n, e[t * 2], e[t * 2 + 1]);
      }, u$ = (n, t) => {
        let e = 0;
        do
          e |= n & 1, n >>>= 1, e <<= 1;
        while (--t > 0);
        return e >>> 1;
      }, uzt = (n) => {
        n.bi_valid === 16 ? (zy(n, n.bi_buf), n.bi_buf = 0, n.bi_valid = 0) : n.bi_valid >= 8 && (n.pending_buf[n.pending++] = n.bi_buf & 255, n.bi_buf >>= 8, n.bi_valid -= 8);
      }, hzt = (n, t) => {
        const e = t.dyn_tree, i = t.max_code, r = t.stat_desc.static_tree, a = t.stat_desc.has_stree, o = t.stat_desc.extra_bits, s = t.stat_desc.extra_base, l = t.stat_desc.max_length;
        let u, h, c, f, g, d, A = 0;
        for (f = 0; f <= Fc; f++) n.bl_count[f] = 0;
        for (e[n.heap[n.heap_max] * 2 + 1] = 0, u = n.heap_max + 1; u < t$; u++) h = n.heap[u], f = e[e[h * 2 + 1] * 2 + 1] + 1, f > l && (f = l, A++), e[h * 2 + 1] = f, !(h > i) && (n.bl_count[f]++, g = 0, h >= s && (g = o[h - s]), d = e[h * 2], n.opt_len += d * (f + g), a && (n.static_len += d * (r[h * 2 + 1] + g)));
        if (A !== 0) {
          do {
            for (f = l - 1; n.bl_count[f] === 0; ) f--;
            n.bl_count[f]--, n.bl_count[f + 1] += 2, n.bl_count[l]--, A -= 2;
          } while (A > 0);
          for (f = l; f !== 0; f--) for (h = n.bl_count[f]; h !== 0; ) c = n.heap[--u], !(c > i) && (e[c * 2 + 1] !== f && (n.opt_len += (f - e[c * 2 + 1]) * e[c * 2], e[c * 2 + 1] = f), h--);
        }
      }, h$ = (n, t, e) => {
        const i = new Array(Fc + 1);
        let r = 0, a, o;
        for (a = 1; a <= Fc; a++) r = r + e[a - 1] << 1, i[a] = r;
        for (o = 0; o <= t; o++) {
          let s = n[o * 2 + 1];
          s !== 0 && (n[o * 2] = u$(i[s]++, s));
        }
      }, czt = () => {
        let n, t, e, i, r;
        const a = new Array(Fc + 1);
        for (e = 0, i = 0; i < WL - 1; i++) for (JL[i] = e, n = 0; n < 1 << KL[i]; n++) Qy[e++] = i;
        for (Qy[e - 1] = i, r = 0, i = 0; i < 16; i++) for (ax[i] = r, n = 0; n < 1 << rx[i]; n++) Oy[r++] = i;
        for (r >>= 7; i < Qd; i++) for (ax[i] = r << 7, n = 0; n < 1 << rx[i] - 7; n++) Oy[256 + r++] = i;
        for (t = 0; t <= Fc; t++) a[t] = 0;
        for (n = 0; n <= 143; ) ul[n * 2 + 1] = 8, n++, a[8]++;
        for (; n <= 255; ) ul[n * 2 + 1] = 9, n++, a[9]++;
        for (; n <= 279; ) ul[n * 2 + 1] = 7, n++, a[7]++;
        for (; n <= 287; ) ul[n * 2 + 1] = 8, n++, a[8]++;
        for (h$(ul, Fy + 1, a), n = 0; n < Qd; n++) ky[n * 2 + 1] = 5, ky[n * 2] = u$(n, 5);
        a$ = new tP(ul, KL, Ny + 1, Fy, Fc), o$ = new tP(ky, rx, 0, Qd, Fc), s$ = new tP(new Array(0), szt, 0, XL, ozt);
      }, c$ = (n) => {
        let t;
        for (t = 0; t < Fy; t++) n.dyn_ltree[t * 2] = 0;
        for (t = 0; t < Qd; t++) n.dyn_dtree[t * 2] = 0;
        for (t = 0; t < XL; t++) n.bl_tree[t * 2] = 0;
        n.dyn_ltree[ZL * 2] = 1, n.opt_len = n.static_len = 0, n.sym_next = n.matches = 0;
      }, f$ = (n) => {
        n.bi_valid > 8 ? zy(n, n.bi_buf) : n.bi_valid > 0 && (n.pending_buf[n.pending++] = n.bi_buf), n.bi_buf = 0, n.bi_valid = 0;
      }, g$ = (n, t, e, i) => {
        const r = t * 2, a = e * 2;
        return n[r] < n[a] || n[r] === n[a] && i[t] <= i[e];
      }, nP = (n, t, e) => {
        const i = n.heap[e];
        let r = e << 1;
        for (; r <= n.heap_len && (r < n.heap_len && g$(t, n.heap[r + 1], n.heap[r], n.depth) && r++, !g$(t, i, n.heap[r], n.depth)); ) n.heap[e] = n.heap[r], e = r, r <<= 1;
        n.heap[e] = i;
      }, d$ = (n, t, e) => {
        let i, r, a = 0, o, s;
        if (n.sym_next !== 0) do
          i = n.pending_buf[n.sym_buf + a++] & 255, i += (n.pending_buf[n.sym_buf + a++] & 255) << 8, r = n.pending_buf[n.sym_buf + a++], i === 0 ? us(n, r, t) : (o = Qy[r], us(n, o + Ny + 1, t), s = KL[o], s !== 0 && (r -= JL[o], Tr(n, r, s)), i--, o = l$(i), us(n, o, e), s = rx[o], s !== 0 && (i -= ax[o], Tr(n, i, s)));
        while (a < n.sym_next);
        us(n, ZL, t);
      }, iP = (n, t) => {
        const e = t.dyn_tree, i = t.stat_desc.static_tree, r = t.stat_desc.has_stree, a = t.stat_desc.elems;
        let o, s, l = -1, u;
        for (n.heap_len = 0, n.heap_max = t$, o = 0; o < a; o++) e[o * 2] !== 0 ? (n.heap[++n.heap_len] = l = o, n.depth[o] = 0) : e[o * 2 + 1] = 0;
        for (; n.heap_len < 2; ) u = n.heap[++n.heap_len] = l < 2 ? ++l : 0, e[u * 2] = 1, n.depth[u] = 0, n.opt_len--, r && (n.static_len -= i[u * 2 + 1]);
        for (t.max_code = l, o = n.heap_len >> 1; o >= 1; o--) nP(n, e, o);
        u = a;
        do
          o = n.heap[1], n.heap[1] = n.heap[n.heap_len--], nP(n, e, 1), s = n.heap[1], n.heap[--n.heap_max] = o, n.heap[--n.heap_max] = s, e[u * 2] = e[o * 2] + e[s * 2], n.depth[u] = (n.depth[o] >= n.depth[s] ? n.depth[o] : n.depth[s]) + 1, e[o * 2 + 1] = e[s * 2 + 1] = u, n.heap[1] = u++, nP(n, e, 1);
        while (n.heap_len >= 2);
        n.heap[--n.heap_max] = n.heap[1], hzt(n, t), h$(e, l, n.bl_count);
      }, A$ = (n, t, e) => {
        let i, r = -1, a, o = t[0 * 2 + 1], s = 0, l = 7, u = 4;
        for (o === 0 && (l = 138, u = 3), t[(e + 1) * 2 + 1] = 65535, i = 0; i <= e; i++) a = o, o = t[(i + 1) * 2 + 1], !(++s < l && a === o) && (s < u ? n.bl_tree[a * 2] += s : a !== 0 ? (a !== r && n.bl_tree[a * 2]++, n.bl_tree[e$ * 2]++) : s <= 10 ? n.bl_tree[n$ * 2]++ : n.bl_tree[i$ * 2]++, s = 0, r = a, o === 0 ? (l = 138, u = 3) : a === o ? (l = 6, u = 3) : (l = 7, u = 4));
      }, p$ = (n, t, e) => {
        let i, r = -1, a, o = t[0 * 2 + 1], s = 0, l = 7, u = 4;
        for (o === 0 && (l = 138, u = 3), i = 0; i <= e; i++) if (a = o, o = t[(i + 1) * 2 + 1], !(++s < l && a === o)) {
          if (s < u) do
            us(n, a, n.bl_tree);
          while (--s !== 0);
          else a !== 0 ? (a !== r && (us(n, a, n.bl_tree), s--), us(n, e$, n.bl_tree), Tr(n, s - 3, 2)) : s <= 10 ? (us(n, n$, n.bl_tree), Tr(n, s - 3, 3)) : (us(n, i$, n.bl_tree), Tr(n, s - 11, 7));
          s = 0, r = a, o === 0 ? (l = 138, u = 3) : a === o ? (l = 6, u = 3) : (l = 7, u = 4);
        }
      }, fzt = (n) => {
        let t;
        for (A$(n, n.dyn_ltree, n.l_desc.max_code), A$(n, n.dyn_dtree, n.d_desc.max_code), iP(n, n.bl_desc), t = XL - 1; t >= 3 && n.bl_tree[r$[t] * 2 + 1] === 0; t--) ;
        return n.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
      }, gzt = (n, t, e, i) => {
        let r;
        for (Tr(n, t - 257, 5), Tr(n, e - 1, 5), Tr(n, i - 4, 4), r = 0; r < i; r++) Tr(n, n.bl_tree[r$[r] * 2 + 1], 3);
        p$(n, n.dyn_ltree, t - 1), p$(n, n.dyn_dtree, e - 1);
      }, dzt = (n) => {
        let t = 4093624447, e;
        for (e = 0; e <= 31; e++, t >>>= 1) if (t & 1 && n.dyn_ltree[e * 2] !== 0) return ZX;
        if (n.dyn_ltree[9 * 2] !== 0 || n.dyn_ltree[10 * 2] !== 0 || n.dyn_ltree[13 * 2] !== 0) return KX;
        for (e = 32; e < Ny; e++) if (n.dyn_ltree[e * 2] !== 0) return KX;
        return ZX;
      };
      let v$ = false;
      const Azt = (n) => {
        v$ || (czt(), v$ = true), n.l_desc = new eP(n.dyn_ltree, a$), n.d_desc = new eP(n.dyn_dtree, o$), n.bl_desc = new eP(n.bl_tree, s$), n.bi_buf = 0, n.bi_valid = 0, c$(n);
      }, y$ = (n, t, e, i) => {
        Tr(n, (nzt << 1) + (i ? 1 : 0), 3), f$(n), zy(n, e), zy(n, ~e), e && n.pending_buf.set(n.window.subarray(t, t + e), n.pending), n.pending += e;
      }, pzt = (n) => {
        Tr(n, JX << 1, 3), us(n, ZL, ul), uzt(n);
      }, vzt = (n, t, e, i) => {
        let r, a, o = 0;
        n.level > 0 ? (n.strm.data_type === ezt && (n.strm.data_type = dzt(n)), iP(n, n.l_desc), iP(n, n.d_desc), o = fzt(n), r = n.opt_len + 3 + 7 >>> 3, a = n.static_len + 3 + 7 >>> 3, a <= r && (r = a)) : r = a = e + 5, e + 4 <= r && t !== -1 ? y$(n, t, e, i) : n.strategy === tzt || a === r ? (Tr(n, (JX << 1) + (i ? 1 : 0), 3), d$(n, ul, ky)) : (Tr(n, (izt << 1) + (i ? 1 : 0), 3), gzt(n, n.l_desc.max_code + 1, n.d_desc.max_code + 1, o + 1), d$(n, n.dyn_ltree, n.dyn_dtree)), c$(n), i && f$(n);
      }, yzt = (n, t, e) => (n.pending_buf[n.sym_buf + n.sym_next++] = t, n.pending_buf[n.sym_buf + n.sym_next++] = t >> 8, n.pending_buf[n.sym_buf + n.sym_next++] = e, t === 0 ? n.dyn_ltree[e * 2]++ : (n.matches++, t--, n.dyn_ltree[(Qy[e] + Ny + 1) * 2]++, n.dyn_dtree[l$(t) * 2]++), n.sym_next === n.sym_end);
      var mzt = Azt, _zt = y$, Ezt = vzt, Izt = yzt, xzt = pzt, wzt = { _tr_init: mzt, _tr_stored_block: _zt, _tr_flush_block: Ezt, _tr_tally: Izt, _tr_align: xzt }, Gy = (n, t, e, i) => {
        let r = n & 65535 | 0, a = n >>> 16 & 65535 | 0, o = 0;
        for (; e !== 0; ) {
          o = e > 2e3 ? 2e3 : e, e -= o;
          do
            r = r + t[i++] | 0, a = a + r | 0;
          while (--o);
          r %= 65521, a %= 65521;
        }
        return r | a << 16 | 0;
      };
      const Czt = () => {
        let n, t = [];
        for (var e = 0; e < 256; e++) {
          n = e;
          for (var i = 0; i < 8; i++) n = n & 1 ? 3988292384 ^ n >>> 1 : n >>> 1;
          t[e] = n;
        }
        return t;
      }, Szt = new Uint32Array(Czt());
      var di = (n, t, e, i) => {
        const r = Szt, a = i + e;
        n ^= -1;
        for (let o = i; o < a; o++) n = n >>> 8 ^ r[(n ^ t[o]) & 255];
        return n ^ -1;
      }, zd = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }, Uy = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      const { _tr_init: bzt, _tr_stored_block: rP, _tr_flush_block: Tzt, _tr_tally: Mu, _tr_align: Bzt } = wzt, { Z_NO_FLUSH: Du, Z_PARTIAL_FLUSH: Mzt, Z_FULL_FLUSH: Dzt, Z_FINISH: La, Z_BLOCK: m$, Z_OK: Ci, Z_STREAM_END: _$, Z_STREAM_ERROR: hs, Z_DATA_ERROR: Rzt, Z_BUF_ERROR: aP, Z_DEFAULT_COMPRESSION: Lzt, Z_FILTERED: Pzt, Z_HUFFMAN_ONLY: ox, Z_RLE: Nzt, Z_FIXED: Fzt, Z_DEFAULT_STRATEGY: kzt, Z_UNKNOWN: Ozt, Z_DEFLATED: sx } = Uy, Qzt = 9, zzt = 15, Gzt = 8, oP = 256 + 1 + 29, Uzt = 30, Vzt = 19, jzt = 2 * oP + 1, qzt = 15, Re = 3, Ru = 258, cs = Ru + Re + 1, Hzt = 32, Gd = 42, sP = 57, lP = 69, uP = 73, hP = 91, cP = 103, kc = 113, Vy = 666, or = 1, Ud = 2, Oc = 3, Vd = 4, Yzt = 3, Qc = (n, t) => (n.msg = zd[t], t), E$ = (n) => n * 2 - (n > 4 ? 9 : 0), Lu = (n) => {
        let t = n.length;
        for (; --t >= 0; ) n[t] = 0;
      }, Wzt = (n) => {
        let t, e, i, r = n.w_size;
        t = n.hash_size, i = t;
        do
          e = n.head[--i], n.head[i] = e >= r ? e - r : 0;
        while (--t);
        t = r, i = t;
        do
          e = n.prev[--i], n.prev[i] = e >= r ? e - r : 0;
        while (--t);
      };
      let Pu = (n, t, e) => (t << n.hash_shift ^ e) & n.hash_mask;
      const $r = (n) => {
        const t = n.state;
        let e = t.pending;
        e > n.avail_out && (e = n.avail_out), e !== 0 && (n.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + e), n.next_out), n.next_out += e, t.pending_out += e, n.total_out += e, n.avail_out -= e, t.pending -= e, t.pending === 0 && (t.pending_out = 0));
      }, Zr = (n, t) => {
        Tzt(n, n.block_start >= 0 ? n.block_start : -1, n.strstart - n.block_start, t), n.block_start = n.strstart, $r(n.strm);
      }, He = (n, t) => {
        n.pending_buf[n.pending++] = t;
      }, jy = (n, t) => {
        n.pending_buf[n.pending++] = t >>> 8 & 255, n.pending_buf[n.pending++] = t & 255;
      }, fP = (n, t, e, i) => {
        let r = n.avail_in;
        return r > i && (r = i), r === 0 ? 0 : (n.avail_in -= r, t.set(n.input.subarray(n.next_in, n.next_in + r), e), n.state.wrap === 1 ? n.adler = Gy(n.adler, t, r, e) : n.state.wrap === 2 && (n.adler = di(n.adler, t, r, e)), n.next_in += r, n.total_in += r, r);
      }, I$ = (n, t) => {
        let e = n.max_chain_length, i = n.strstart, r, a, o = n.prev_length, s = n.nice_match;
        const l = n.strstart > n.w_size - cs ? n.strstart - (n.w_size - cs) : 0, u = n.window, h = n.w_mask, c = n.prev, f = n.strstart + Ru;
        let g = u[i + o - 1], d = u[i + o];
        n.prev_length >= n.good_match && (e >>= 2), s > n.lookahead && (s = n.lookahead);
        do
          if (r = t, !(u[r + o] !== d || u[r + o - 1] !== g || u[r] !== u[i] || u[++r] !== u[i + 1])) {
            i += 2, r++;
            do
              ;
            while (u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && u[++i] === u[++r] && i < f);
            if (a = Ru - (f - i), i = f - Ru, a > o) {
              if (n.match_start = t, o = a, a >= s) break;
              g = u[i + o - 1], d = u[i + o];
            }
          }
        while ((t = c[t & h]) > l && --e !== 0);
        return o <= n.lookahead ? o : n.lookahead;
      }, jd = (n) => {
        const t = n.w_size;
        let e, i, r;
        do {
          if (i = n.window_size - n.lookahead - n.strstart, n.strstart >= t + (t - cs) && (n.window.set(n.window.subarray(t, t + t - i), 0), n.match_start -= t, n.strstart -= t, n.block_start -= t, n.insert > n.strstart && (n.insert = n.strstart), Wzt(n), i += t), n.strm.avail_in === 0) break;
          if (e = fP(n.strm, n.window, n.strstart + n.lookahead, i), n.lookahead += e, n.lookahead + n.insert >= Re) for (r = n.strstart - n.insert, n.ins_h = n.window[r], n.ins_h = Pu(n, n.ins_h, n.window[r + 1]); n.insert && (n.ins_h = Pu(n, n.ins_h, n.window[r + Re - 1]), n.prev[r & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = r, r++, n.insert--, !(n.lookahead + n.insert < Re)); ) ;
        } while (n.lookahead < cs && n.strm.avail_in !== 0);
      }, x$ = (n, t) => {
        let e = n.pending_buf_size - 5 > n.w_size ? n.w_size : n.pending_buf_size - 5, i, r, a, o = 0, s = n.strm.avail_in;
        do {
          if (i = 65535, a = n.bi_valid + 42 >> 3, n.strm.avail_out < a || (a = n.strm.avail_out - a, r = n.strstart - n.block_start, i > r + n.strm.avail_in && (i = r + n.strm.avail_in), i > a && (i = a), i < e && (i === 0 && t !== La || t === Du || i !== r + n.strm.avail_in))) break;
          o = t === La && i === r + n.strm.avail_in ? 1 : 0, rP(n, 0, 0, o), n.pending_buf[n.pending - 4] = i, n.pending_buf[n.pending - 3] = i >> 8, n.pending_buf[n.pending - 2] = ~i, n.pending_buf[n.pending - 1] = ~i >> 8, $r(n.strm), r && (r > i && (r = i), n.strm.output.set(n.window.subarray(n.block_start, n.block_start + r), n.strm.next_out), n.strm.next_out += r, n.strm.avail_out -= r, n.strm.total_out += r, n.block_start += r, i -= r), i && (fP(n.strm, n.strm.output, n.strm.next_out, i), n.strm.next_out += i, n.strm.avail_out -= i, n.strm.total_out += i);
        } while (o === 0);
        return s -= n.strm.avail_in, s && (s >= n.w_size ? (n.matches = 2, n.window.set(n.strm.input.subarray(n.strm.next_in - n.w_size, n.strm.next_in), 0), n.strstart = n.w_size, n.insert = n.strstart) : (n.window_size - n.strstart <= s && (n.strstart -= n.w_size, n.window.set(n.window.subarray(n.w_size, n.w_size + n.strstart), 0), n.matches < 2 && n.matches++, n.insert > n.strstart && (n.insert = n.strstart)), n.window.set(n.strm.input.subarray(n.strm.next_in - s, n.strm.next_in), n.strstart), n.strstart += s, n.insert += s > n.w_size - n.insert ? n.w_size - n.insert : s), n.block_start = n.strstart), n.high_water < n.strstart && (n.high_water = n.strstart), o ? Vd : t !== Du && t !== La && n.strm.avail_in === 0 && n.strstart === n.block_start ? Ud : (a = n.window_size - n.strstart, n.strm.avail_in > a && n.block_start >= n.w_size && (n.block_start -= n.w_size, n.strstart -= n.w_size, n.window.set(n.window.subarray(n.w_size, n.w_size + n.strstart), 0), n.matches < 2 && n.matches++, a += n.w_size, n.insert > n.strstart && (n.insert = n.strstart)), a > n.strm.avail_in && (a = n.strm.avail_in), a && (fP(n.strm, n.window, n.strstart, a), n.strstart += a, n.insert += a > n.w_size - n.insert ? n.w_size - n.insert : a), n.high_water < n.strstart && (n.high_water = n.strstart), a = n.bi_valid + 42 >> 3, a = n.pending_buf_size - a > 65535 ? 65535 : n.pending_buf_size - a, e = a > n.w_size ? n.w_size : a, r = n.strstart - n.block_start, (r >= e || (r || t === La) && t !== Du && n.strm.avail_in === 0 && r <= a) && (i = r > a ? a : r, o = t === La && n.strm.avail_in === 0 && i === r ? 1 : 0, rP(n, n.block_start, i, o), n.block_start += i, $r(n.strm)), o ? Oc : or);
      }, gP = (n, t) => {
        let e, i;
        for (; ; ) {
          if (n.lookahead < cs) {
            if (jd(n), n.lookahead < cs && t === Du) return or;
            if (n.lookahead === 0) break;
          }
          if (e = 0, n.lookahead >= Re && (n.ins_h = Pu(n, n.ins_h, n.window[n.strstart + Re - 1]), e = n.prev[n.strstart & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = n.strstart), e !== 0 && n.strstart - e <= n.w_size - cs && (n.match_length = I$(n, e)), n.match_length >= Re) if (i = Mu(n, n.strstart - n.match_start, n.match_length - Re), n.lookahead -= n.match_length, n.match_length <= n.max_lazy_match && n.lookahead >= Re) {
            n.match_length--;
            do
              n.strstart++, n.ins_h = Pu(n, n.ins_h, n.window[n.strstart + Re - 1]), e = n.prev[n.strstart & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = n.strstart;
            while (--n.match_length !== 0);
            n.strstart++;
          } else n.strstart += n.match_length, n.match_length = 0, n.ins_h = n.window[n.strstart], n.ins_h = Pu(n, n.ins_h, n.window[n.strstart + 1]);
          else i = Mu(n, 0, n.window[n.strstart]), n.lookahead--, n.strstart++;
          if (i && (Zr(n, false), n.strm.avail_out === 0)) return or;
        }
        return n.insert = n.strstart < Re - 1 ? n.strstart : Re - 1, t === La ? (Zr(n, true), n.strm.avail_out === 0 ? Oc : Vd) : n.sym_next && (Zr(n, false), n.strm.avail_out === 0) ? or : Ud;
      }, qd = (n, t) => {
        let e, i, r;
        for (; ; ) {
          if (n.lookahead < cs) {
            if (jd(n), n.lookahead < cs && t === Du) return or;
            if (n.lookahead === 0) break;
          }
          if (e = 0, n.lookahead >= Re && (n.ins_h = Pu(n, n.ins_h, n.window[n.strstart + Re - 1]), e = n.prev[n.strstart & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = n.strstart), n.prev_length = n.match_length, n.prev_match = n.match_start, n.match_length = Re - 1, e !== 0 && n.prev_length < n.max_lazy_match && n.strstart - e <= n.w_size - cs && (n.match_length = I$(n, e), n.match_length <= 5 && (n.strategy === Pzt || n.match_length === Re && n.strstart - n.match_start > 4096) && (n.match_length = Re - 1)), n.prev_length >= Re && n.match_length <= n.prev_length) {
            r = n.strstart + n.lookahead - Re, i = Mu(n, n.strstart - 1 - n.prev_match, n.prev_length - Re), n.lookahead -= n.prev_length - 1, n.prev_length -= 2;
            do
              ++n.strstart <= r && (n.ins_h = Pu(n, n.ins_h, n.window[n.strstart + Re - 1]), e = n.prev[n.strstart & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = n.strstart);
            while (--n.prev_length !== 0);
            if (n.match_available = 0, n.match_length = Re - 1, n.strstart++, i && (Zr(n, false), n.strm.avail_out === 0)) return or;
          } else if (n.match_available) {
            if (i = Mu(n, 0, n.window[n.strstart - 1]), i && Zr(n, false), n.strstart++, n.lookahead--, n.strm.avail_out === 0) return or;
          } else n.match_available = 1, n.strstart++, n.lookahead--;
        }
        return n.match_available && (i = Mu(n, 0, n.window[n.strstart - 1]), n.match_available = 0), n.insert = n.strstart < Re - 1 ? n.strstart : Re - 1, t === La ? (Zr(n, true), n.strm.avail_out === 0 ? Oc : Vd) : n.sym_next && (Zr(n, false), n.strm.avail_out === 0) ? or : Ud;
      }, Xzt = (n, t) => {
        let e, i, r, a;
        const o = n.window;
        for (; ; ) {
          if (n.lookahead <= Ru) {
            if (jd(n), n.lookahead <= Ru && t === Du) return or;
            if (n.lookahead === 0) break;
          }
          if (n.match_length = 0, n.lookahead >= Re && n.strstart > 0 && (r = n.strstart - 1, i = o[r], i === o[++r] && i === o[++r] && i === o[++r])) {
            a = n.strstart + Ru;
            do
              ;
            while (i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && r < a);
            n.match_length = Ru - (a - r), n.match_length > n.lookahead && (n.match_length = n.lookahead);
          }
          if (n.match_length >= Re ? (e = Mu(n, 1, n.match_length - Re), n.lookahead -= n.match_length, n.strstart += n.match_length, n.match_length = 0) : (e = Mu(n, 0, n.window[n.strstart]), n.lookahead--, n.strstart++), e && (Zr(n, false), n.strm.avail_out === 0)) return or;
        }
        return n.insert = 0, t === La ? (Zr(n, true), n.strm.avail_out === 0 ? Oc : Vd) : n.sym_next && (Zr(n, false), n.strm.avail_out === 0) ? or : Ud;
      }, $zt = (n, t) => {
        let e;
        for (; ; ) {
          if (n.lookahead === 0 && (jd(n), n.lookahead === 0)) {
            if (t === Du) return or;
            break;
          }
          if (n.match_length = 0, e = Mu(n, 0, n.window[n.strstart]), n.lookahead--, n.strstart++, e && (Zr(n, false), n.strm.avail_out === 0)) return or;
        }
        return n.insert = 0, t === La ? (Zr(n, true), n.strm.avail_out === 0 ? Oc : Vd) : n.sym_next && (Zr(n, false), n.strm.avail_out === 0) ? or : Ud;
      };
      function fs(n, t, e, i, r) {
        this.good_length = n, this.max_lazy = t, this.nice_length = e, this.max_chain = i, this.func = r;
      }
      const qy = [new fs(0, 0, 0, 0, x$), new fs(4, 4, 8, 4, gP), new fs(4, 5, 16, 8, gP), new fs(4, 6, 32, 32, gP), new fs(4, 4, 16, 16, qd), new fs(8, 16, 32, 32, qd), new fs(8, 16, 128, 128, qd), new fs(8, 32, 128, 256, qd), new fs(32, 128, 258, 1024, qd), new fs(32, 258, 258, 4096, qd)], Zzt = (n) => {
        n.window_size = 2 * n.w_size, Lu(n.head), n.max_lazy_match = qy[n.level].max_lazy, n.good_match = qy[n.level].good_length, n.nice_match = qy[n.level].nice_length, n.max_chain_length = qy[n.level].max_chain, n.strstart = 0, n.block_start = 0, n.lookahead = 0, n.insert = 0, n.match_length = n.prev_length = Re - 1, n.match_available = 0, n.ins_h = 0;
      };
      function Kzt() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = sx, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(jzt * 2), this.dyn_dtree = new Uint16Array((2 * Uzt + 1) * 2), this.bl_tree = new Uint16Array((2 * Vzt + 1) * 2), Lu(this.dyn_ltree), Lu(this.dyn_dtree), Lu(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(qzt + 1), this.heap = new Uint16Array(2 * oP + 1), Lu(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * oP + 1), Lu(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      const Hy = (n) => {
        if (!n) return 1;
        const t = n.state;
        return !t || t.strm !== n || t.status !== Gd && t.status !== sP && t.status !== lP && t.status !== uP && t.status !== hP && t.status !== cP && t.status !== kc && t.status !== Vy ? 1 : 0;
      }, w$ = (n) => {
        if (Hy(n)) return Qc(n, hs);
        n.total_in = n.total_out = 0, n.data_type = Ozt;
        const t = n.state;
        return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap === 2 ? sP : t.wrap ? Gd : kc, n.adler = t.wrap === 2 ? 0 : 1, t.last_flush = -2, bzt(t), Ci;
      }, C$ = (n) => {
        const t = w$(n);
        return t === Ci && Zzt(n.state), t;
      }, Jzt = (n, t) => Hy(n) || n.state.wrap !== 2 ? hs : (n.state.gzhead = t, Ci), S$ = (n, t, e, i, r, a) => {
        if (!n) return hs;
        let o = 1;
        if (t === Lzt && (t = 6), i < 0 ? (o = 0, i = -i) : i > 15 && (o = 2, i -= 16), r < 1 || r > Qzt || e !== sx || i < 8 || i > 15 || t < 0 || t > 9 || a < 0 || a > Fzt || i === 8 && o !== 1) return Qc(n, hs);
        i === 8 && (i = 9);
        const s = new Kzt();
        return n.state = s, s.strm = n, s.status = Gd, s.wrap = o, s.gzhead = null, s.w_bits = i, s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = r + 7, s.hash_size = 1 << s.hash_bits, s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + Re - 1) / Re), s.window = new Uint8Array(s.w_size * 2), s.head = new Uint16Array(s.hash_size), s.prev = new Uint16Array(s.w_size), s.lit_bufsize = 1 << r + 6, s.pending_buf_size = s.lit_bufsize * 4, s.pending_buf = new Uint8Array(s.pending_buf_size), s.sym_buf = s.lit_bufsize, s.sym_end = (s.lit_bufsize - 1) * 3, s.level = t, s.strategy = a, s.method = e, C$(n);
      }, tGt = (n, t) => S$(n, t, sx, zzt, Gzt, kzt), eGt = (n, t) => {
        if (Hy(n) || t > m$ || t < 0) return n ? Qc(n, hs) : hs;
        const e = n.state;
        if (!n.output || n.avail_in !== 0 && !n.input || e.status === Vy && t !== La) return Qc(n, n.avail_out === 0 ? aP : hs);
        const i = e.last_flush;
        if (e.last_flush = t, e.pending !== 0) {
          if ($r(n), n.avail_out === 0) return e.last_flush = -1, Ci;
        } else if (n.avail_in === 0 && E$(t) <= E$(i) && t !== La) return Qc(n, aP);
        if (e.status === Vy && n.avail_in !== 0) return Qc(n, aP);
        if (e.status === Gd && e.wrap === 0 && (e.status = kc), e.status === Gd) {
          let r = sx + (e.w_bits - 8 << 4) << 8, a = -1;
          if (e.strategy >= ox || e.level < 2 ? a = 0 : e.level < 6 ? a = 1 : e.level === 6 ? a = 2 : a = 3, r |= a << 6, e.strstart !== 0 && (r |= Hzt), r += 31 - r % 31, jy(e, r), e.strstart !== 0 && (jy(e, n.adler >>> 16), jy(e, n.adler & 65535)), n.adler = 1, e.status = kc, $r(n), e.pending !== 0) return e.last_flush = -1, Ci;
        }
        if (e.status === sP) {
          if (n.adler = 0, He(e, 31), He(e, 139), He(e, 8), e.gzhead) He(e, (e.gzhead.text ? 1 : 0) + (e.gzhead.hcrc ? 2 : 0) + (e.gzhead.extra ? 4 : 0) + (e.gzhead.name ? 8 : 0) + (e.gzhead.comment ? 16 : 0)), He(e, e.gzhead.time & 255), He(e, e.gzhead.time >> 8 & 255), He(e, e.gzhead.time >> 16 & 255), He(e, e.gzhead.time >> 24 & 255), He(e, e.level === 9 ? 2 : e.strategy >= ox || e.level < 2 ? 4 : 0), He(e, e.gzhead.os & 255), e.gzhead.extra && e.gzhead.extra.length && (He(e, e.gzhead.extra.length & 255), He(e, e.gzhead.extra.length >> 8 & 255)), e.gzhead.hcrc && (n.adler = di(n.adler, e.pending_buf, e.pending, 0)), e.gzindex = 0, e.status = lP;
          else if (He(e, 0), He(e, 0), He(e, 0), He(e, 0), He(e, 0), He(e, e.level === 9 ? 2 : e.strategy >= ox || e.level < 2 ? 4 : 0), He(e, Yzt), e.status = kc, $r(n), e.pending !== 0) return e.last_flush = -1, Ci;
        }
        if (e.status === lP) {
          if (e.gzhead.extra) {
            let r = e.pending, a = (e.gzhead.extra.length & 65535) - e.gzindex;
            for (; e.pending + a > e.pending_buf_size; ) {
              let s = e.pending_buf_size - e.pending;
              if (e.pending_buf.set(e.gzhead.extra.subarray(e.gzindex, e.gzindex + s), e.pending), e.pending = e.pending_buf_size, e.gzhead.hcrc && e.pending > r && (n.adler = di(n.adler, e.pending_buf, e.pending - r, r)), e.gzindex += s, $r(n), e.pending !== 0) return e.last_flush = -1, Ci;
              r = 0, a -= s;
            }
            let o = new Uint8Array(e.gzhead.extra);
            e.pending_buf.set(o.subarray(e.gzindex, e.gzindex + a), e.pending), e.pending += a, e.gzhead.hcrc && e.pending > r && (n.adler = di(n.adler, e.pending_buf, e.pending - r, r)), e.gzindex = 0;
          }
          e.status = uP;
        }
        if (e.status === uP) {
          if (e.gzhead.name) {
            let r = e.pending, a;
            do {
              if (e.pending === e.pending_buf_size) {
                if (e.gzhead.hcrc && e.pending > r && (n.adler = di(n.adler, e.pending_buf, e.pending - r, r)), $r(n), e.pending !== 0) return e.last_flush = -1, Ci;
                r = 0;
              }
              e.gzindex < e.gzhead.name.length ? a = e.gzhead.name.charCodeAt(e.gzindex++) & 255 : a = 0, He(e, a);
            } while (a !== 0);
            e.gzhead.hcrc && e.pending > r && (n.adler = di(n.adler, e.pending_buf, e.pending - r, r)), e.gzindex = 0;
          }
          e.status = hP;
        }
        if (e.status === hP) {
          if (e.gzhead.comment) {
            let r = e.pending, a;
            do {
              if (e.pending === e.pending_buf_size) {
                if (e.gzhead.hcrc && e.pending > r && (n.adler = di(n.adler, e.pending_buf, e.pending - r, r)), $r(n), e.pending !== 0) return e.last_flush = -1, Ci;
                r = 0;
              }
              e.gzindex < e.gzhead.comment.length ? a = e.gzhead.comment.charCodeAt(e.gzindex++) & 255 : a = 0, He(e, a);
            } while (a !== 0);
            e.gzhead.hcrc && e.pending > r && (n.adler = di(n.adler, e.pending_buf, e.pending - r, r));
          }
          e.status = cP;
        }
        if (e.status === cP) {
          if (e.gzhead.hcrc) {
            if (e.pending + 2 > e.pending_buf_size && ($r(n), e.pending !== 0)) return e.last_flush = -1, Ci;
            He(e, n.adler & 255), He(e, n.adler >> 8 & 255), n.adler = 0;
          }
          if (e.status = kc, $r(n), e.pending !== 0) return e.last_flush = -1, Ci;
        }
        if (n.avail_in !== 0 || e.lookahead !== 0 || t !== Du && e.status !== Vy) {
          let r = e.level === 0 ? x$(e, t) : e.strategy === ox ? $zt(e, t) : e.strategy === Nzt ? Xzt(e, t) : qy[e.level].func(e, t);
          if ((r === Oc || r === Vd) && (e.status = Vy), r === or || r === Oc) return n.avail_out === 0 && (e.last_flush = -1), Ci;
          if (r === Ud && (t === Mzt ? Bzt(e) : t !== m$ && (rP(e, 0, 0, false), t === Dzt && (Lu(e.head), e.lookahead === 0 && (e.strstart = 0, e.block_start = 0, e.insert = 0))), $r(n), n.avail_out === 0)) return e.last_flush = -1, Ci;
        }
        return t !== La ? Ci : e.wrap <= 0 ? _$ : (e.wrap === 2 ? (He(e, n.adler & 255), He(e, n.adler >> 8 & 255), He(e, n.adler >> 16 & 255), He(e, n.adler >> 24 & 255), He(e, n.total_in & 255), He(e, n.total_in >> 8 & 255), He(e, n.total_in >> 16 & 255), He(e, n.total_in >> 24 & 255)) : (jy(e, n.adler >>> 16), jy(e, n.adler & 65535)), $r(n), e.wrap > 0 && (e.wrap = -e.wrap), e.pending !== 0 ? Ci : _$);
      }, nGt = (n) => {
        if (Hy(n)) return hs;
        const t = n.state.status;
        return n.state = null, t === kc ? Qc(n, Rzt) : Ci;
      }, iGt = (n, t) => {
        let e = t.length;
        if (Hy(n)) return hs;
        const i = n.state, r = i.wrap;
        if (r === 2 || r === 1 && i.status !== Gd || i.lookahead) return hs;
        if (r === 1 && (n.adler = Gy(n.adler, t, e, 0)), i.wrap = 0, e >= i.w_size) {
          r === 0 && (Lu(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0);
          let l = new Uint8Array(i.w_size);
          l.set(t.subarray(e - i.w_size, e), 0), t = l, e = i.w_size;
        }
        const a = n.avail_in, o = n.next_in, s = n.input;
        for (n.avail_in = e, n.next_in = 0, n.input = t, jd(i); i.lookahead >= Re; ) {
          let l = i.strstart, u = i.lookahead - (Re - 1);
          do
            i.ins_h = Pu(i, i.ins_h, i.window[l + Re - 1]), i.prev[l & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = l, l++;
          while (--u);
          i.strstart = l, i.lookahead = Re - 1, jd(i);
        }
        return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = Re - 1, i.match_available = 0, n.next_in = o, n.input = s, n.avail_in = a, i.wrap = r, Ci;
      };
      var rGt = tGt, aGt = S$, oGt = C$, sGt = w$, lGt = Jzt, uGt = eGt, hGt = nGt, cGt = iGt, fGt = "pako deflate (from Nodeca project)", Yy = { deflateInit: rGt, deflateInit2: aGt, deflateReset: oGt, deflateResetKeep: sGt, deflateSetHeader: lGt, deflate: uGt, deflateEnd: hGt, deflateSetDictionary: cGt, deflateInfo: fGt };
      const gGt = (n, t) => Object.prototype.hasOwnProperty.call(n, t);
      var dGt = function(n) {
        const t = Array.prototype.slice.call(arguments, 1);
        for (; t.length; ) {
          const e = t.shift();
          if (e) {
            if (typeof e != "object") throw new TypeError(e + "must be non-object");
            for (const i in e) gGt(e, i) && (n[i] = e[i]);
          }
        }
        return n;
      }, AGt = (n) => {
        let t = 0;
        for (let i = 0, r = n.length; i < r; i++) t += n[i].length;
        const e = new Uint8Array(t);
        for (let i = 0, r = 0, a = n.length; i < a; i++) {
          let o = n[i];
          e.set(o, r), r += o.length;
        }
        return e;
      }, lx = { assign: dGt, flattenChunks: AGt };
      let b$ = true;
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (n) {
        b$ = false;
      }
      const Wy = new Uint8Array(256);
      for (let n = 0; n < 256; n++) Wy[n] = n >= 252 ? 6 : n >= 248 ? 5 : n >= 240 ? 4 : n >= 224 ? 3 : n >= 192 ? 2 : 1;
      Wy[254] = Wy[254] = 1;
      var pGt = (n) => {
        if (typeof TextEncoder == "function" && TextEncoder.prototype.encode) return new TextEncoder().encode(n);
        let t, e, i, r, a, o = n.length, s = 0;
        for (r = 0; r < o; r++) e = n.charCodeAt(r), (e & 64512) === 55296 && r + 1 < o && (i = n.charCodeAt(r + 1), (i & 64512) === 56320 && (e = 65536 + (e - 55296 << 10) + (i - 56320), r++)), s += e < 128 ? 1 : e < 2048 ? 2 : e < 65536 ? 3 : 4;
        for (t = new Uint8Array(s), a = 0, r = 0; a < s; r++) e = n.charCodeAt(r), (e & 64512) === 55296 && r + 1 < o && (i = n.charCodeAt(r + 1), (i & 64512) === 56320 && (e = 65536 + (e - 55296 << 10) + (i - 56320), r++)), e < 128 ? t[a++] = e : e < 2048 ? (t[a++] = 192 | e >>> 6, t[a++] = 128 | e & 63) : e < 65536 ? (t[a++] = 224 | e >>> 12, t[a++] = 128 | e >>> 6 & 63, t[a++] = 128 | e & 63) : (t[a++] = 240 | e >>> 18, t[a++] = 128 | e >>> 12 & 63, t[a++] = 128 | e >>> 6 & 63, t[a++] = 128 | e & 63);
        return t;
      };
      const vGt = (n, t) => {
        if (t < 65534 && n.subarray && b$) return String.fromCharCode.apply(null, n.length === t ? n : n.subarray(0, t));
        let e = "";
        for (let i = 0; i < t; i++) e += String.fromCharCode(n[i]);
        return e;
      };
      var yGt = (n, t) => {
        const e = t || n.length;
        if (typeof TextDecoder == "function" && TextDecoder.prototype.decode) return new TextDecoder().decode(n.subarray(0, t));
        let i, r;
        const a = new Array(e * 2);
        for (r = 0, i = 0; i < e; ) {
          let o = n[i++];
          if (o < 128) {
            a[r++] = o;
            continue;
          }
          let s = Wy[o];
          if (s > 4) {
            a[r++] = 65533, i += s - 1;
            continue;
          }
          for (o &= s === 2 ? 31 : s === 3 ? 15 : 7; s > 1 && i < e; ) o = o << 6 | n[i++] & 63, s--;
          if (s > 1) {
            a[r++] = 65533;
            continue;
          }
          o < 65536 ? a[r++] = o : (o -= 65536, a[r++] = 55296 | o >> 10 & 1023, a[r++] = 56320 | o & 1023);
        }
        return vGt(a, r);
      }, mGt = (n, t) => {
        t = t || n.length, t > n.length && (t = n.length);
        let e = t - 1;
        for (; e >= 0 && (n[e] & 192) === 128; ) e--;
        return e < 0 || e === 0 ? t : e + Wy[n[e]] > t ? e : t;
      }, Xy = { string2buf: pGt, buf2string: yGt, utf8border: mGt };
      function _Gt() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      }
      var T$ = _Gt;
      const B$ = Object.prototype.toString, { Z_NO_FLUSH: EGt, Z_SYNC_FLUSH: IGt, Z_FULL_FLUSH: xGt, Z_FINISH: wGt, Z_OK: ux, Z_STREAM_END: CGt, Z_DEFAULT_COMPRESSION: SGt, Z_DEFAULT_STRATEGY: bGt, Z_DEFLATED: TGt } = Uy;
      function dP(n) {
        this.options = lx.assign({ level: SGt, method: TGt, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: bGt }, n || {});
        let t = this.options;
        t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new T$(), this.strm.avail_out = 0;
        let e = Yy.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);
        if (e !== ux) throw new Error(zd[e]);
        if (t.header && Yy.deflateSetHeader(this.strm, t.header), t.dictionary) {
          let i;
          if (typeof t.dictionary == "string" ? i = Xy.string2buf(t.dictionary) : B$.call(t.dictionary) === "[object ArrayBuffer]" ? i = new Uint8Array(t.dictionary) : i = t.dictionary, e = Yy.deflateSetDictionary(this.strm, i), e !== ux) throw new Error(zd[e]);
          this._dict_set = true;
        }
      }
      dP.prototype.push = function(n, t) {
        const e = this.strm, i = this.options.chunkSize;
        let r, a;
        if (this.ended) return false;
        for (t === ~~t ? a = t : a = t === true ? wGt : EGt, typeof n == "string" ? e.input = Xy.string2buf(n) : B$.call(n) === "[object ArrayBuffer]" ? e.input = new Uint8Array(n) : e.input = n, e.next_in = 0, e.avail_in = e.input.length; ; ) {
          if (e.avail_out === 0 && (e.output = new Uint8Array(i), e.next_out = 0, e.avail_out = i), (a === IGt || a === xGt) && e.avail_out <= 6) {
            this.onData(e.output.subarray(0, e.next_out)), e.avail_out = 0;
            continue;
          }
          if (r = Yy.deflate(e, a), r === CGt) return e.next_out > 0 && this.onData(e.output.subarray(0, e.next_out)), r = Yy.deflateEnd(this.strm), this.onEnd(r), this.ended = true, r === ux;
          if (e.avail_out === 0) {
            this.onData(e.output);
            continue;
          }
          if (a > 0 && e.next_out > 0) {
            this.onData(e.output.subarray(0, e.next_out)), e.avail_out = 0;
            continue;
          }
          if (e.avail_in === 0) break;
        }
        return true;
      }, dP.prototype.onData = function(n) {
        this.chunks.push(n);
      }, dP.prototype.onEnd = function(n) {
        n === ux && (this.result = lx.flattenChunks(this.chunks)), this.chunks = [], this.err = n, this.msg = this.strm.msg;
      };
      const hx = 16209, BGt = 16191;
      var MGt = function(t, e) {
        let i, r, a, o, s, l, u, h, c, f, g, d, A, p, v, y, m, _, I, E, x, w, C, S;
        const b = t.state;
        i = t.next_in, C = t.input, r = i + (t.avail_in - 5), a = t.next_out, S = t.output, o = a - (e - t.avail_out), s = a + (t.avail_out - 257), l = b.dmax, u = b.wsize, h = b.whave, c = b.wnext, f = b.window, g = b.hold, d = b.bits, A = b.lencode, p = b.distcode, v = (1 << b.lenbits) - 1, y = (1 << b.distbits) - 1;
        t: do {
          d < 15 && (g += C[i++] << d, d += 8, g += C[i++] << d, d += 8), m = A[g & v];
          e: for (; ; ) {
            if (_ = m >>> 24, g >>>= _, d -= _, _ = m >>> 16 & 255, _ === 0) S[a++] = m & 65535;
            else if (_ & 16) {
              I = m & 65535, _ &= 15, _ && (d < _ && (g += C[i++] << d, d += 8), I += g & (1 << _) - 1, g >>>= _, d -= _), d < 15 && (g += C[i++] << d, d += 8, g += C[i++] << d, d += 8), m = p[g & y];
              n: for (; ; ) {
                if (_ = m >>> 24, g >>>= _, d -= _, _ = m >>> 16 & 255, _ & 16) {
                  if (E = m & 65535, _ &= 15, d < _ && (g += C[i++] << d, d += 8, d < _ && (g += C[i++] << d, d += 8)), E += g & (1 << _) - 1, E > l) {
                    t.msg = "invalid distance too far back", b.mode = hx;
                    break t;
                  }
                  if (g >>>= _, d -= _, _ = a - o, E > _) {
                    if (_ = E - _, _ > h && b.sane) {
                      t.msg = "invalid distance too far back", b.mode = hx;
                      break t;
                    }
                    if (x = 0, w = f, c === 0) {
                      if (x += u - _, _ < I) {
                        I -= _;
                        do
                          S[a++] = f[x++];
                        while (--_);
                        x = a - E, w = S;
                      }
                    } else if (c < _) {
                      if (x += u + c - _, _ -= c, _ < I) {
                        I -= _;
                        do
                          S[a++] = f[x++];
                        while (--_);
                        if (x = 0, c < I) {
                          _ = c, I -= _;
                          do
                            S[a++] = f[x++];
                          while (--_);
                          x = a - E, w = S;
                        }
                      }
                    } else if (x += c - _, _ < I) {
                      I -= _;
                      do
                        S[a++] = f[x++];
                      while (--_);
                      x = a - E, w = S;
                    }
                    for (; I > 2; ) S[a++] = w[x++], S[a++] = w[x++], S[a++] = w[x++], I -= 3;
                    I && (S[a++] = w[x++], I > 1 && (S[a++] = w[x++]));
                  } else {
                    x = a - E;
                    do
                      S[a++] = S[x++], S[a++] = S[x++], S[a++] = S[x++], I -= 3;
                    while (I > 2);
                    I && (S[a++] = S[x++], I > 1 && (S[a++] = S[x++]));
                  }
                } else if (_ & 64) {
                  t.msg = "invalid distance code", b.mode = hx;
                  break t;
                } else {
                  m = p[(m & 65535) + (g & (1 << _) - 1)];
                  continue n;
                }
                break;
              }
            } else if (_ & 64) if (_ & 32) {
              b.mode = BGt;
              break t;
            } else {
              t.msg = "invalid literal/length code", b.mode = hx;
              break t;
            }
            else {
              m = A[(m & 65535) + (g & (1 << _) - 1)];
              continue e;
            }
            break;
          }
        } while (i < r && a < s);
        I = d >> 3, i -= I, d -= I << 3, g &= (1 << d) - 1, t.next_in = i, t.next_out = a, t.avail_in = i < r ? 5 + (r - i) : 5 - (i - r), t.avail_out = a < s ? 257 + (s - a) : 257 - (a - s), b.hold = g, b.bits = d;
      };
      const Hd = 15, M$ = 852, D$ = 592, R$ = 0, AP = 1, L$ = 2, DGt = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), RGt = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]), LGt = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]), PGt = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
      var $y = (n, t, e, i, r, a, o, s) => {
        const l = s.bits;
        let u = 0, h = 0, c = 0, f = 0, g = 0, d = 0, A = 0, p = 0, v = 0, y = 0, m, _, I, E, x, w = null, C;
        const S = new Uint16Array(Hd + 1), b = new Uint16Array(Hd + 1);
        let T = null, B, R, M;
        for (u = 0; u <= Hd; u++) S[u] = 0;
        for (h = 0; h < i; h++) S[t[e + h]]++;
        for (g = l, f = Hd; f >= 1 && S[f] === 0; f--) ;
        if (g > f && (g = f), f === 0) return r[a++] = 1 << 24 | 64 << 16 | 0, r[a++] = 1 << 24 | 64 << 16 | 0, s.bits = 1, 0;
        for (c = 1; c < f && S[c] === 0; c++) ;
        for (g < c && (g = c), p = 1, u = 1; u <= Hd; u++) if (p <<= 1, p -= S[u], p < 0) return -1;
        if (p > 0 && (n === R$ || f !== 1)) return -1;
        for (b[1] = 0, u = 1; u < Hd; u++) b[u + 1] = b[u] + S[u];
        for (h = 0; h < i; h++) t[e + h] !== 0 && (o[b[t[e + h]]++] = h);
        if (n === R$ ? (w = T = o, C = 20) : n === AP ? (w = DGt, T = RGt, C = 257) : (w = LGt, T = PGt, C = 0), y = 0, h = 0, u = c, x = a, d = g, A = 0, I = -1, v = 1 << g, E = v - 1, n === AP && v > M$ || n === L$ && v > D$) return 1;
        for (; ; ) {
          B = u - A, o[h] + 1 < C ? (R = 0, M = o[h]) : o[h] >= C ? (R = T[o[h] - C], M = w[o[h] - C]) : (R = 96, M = 0), m = 1 << u - A, _ = 1 << d, c = _;
          do
            _ -= m, r[x + (y >> A) + _] = B << 24 | R << 16 | M | 0;
          while (_ !== 0);
          for (m = 1 << u - 1; y & m; ) m >>= 1;
          if (m !== 0 ? (y &= m - 1, y += m) : y = 0, h++, --S[u] === 0) {
            if (u === f) break;
            u = t[e + o[h]];
          }
          if (u > g && (y & E) !== I) {
            for (A === 0 && (A = g), x += c, d = u - A, p = 1 << d; d + A < f && (p -= S[d + A], !(p <= 0)); ) d++, p <<= 1;
            if (v += 1 << d, n === AP && v > M$ || n === L$ && v > D$) return 1;
            I = y & E, r[I] = g << 24 | d << 16 | x - a | 0;
          }
        }
        return y !== 0 && (r[x + y] = u - A << 24 | 64 << 16 | 0), s.bits = g, 0;
      };
      const NGt = 0, P$ = 1, N$ = 2, { Z_FINISH: F$, Z_BLOCK: FGt, Z_TREES: cx, Z_OK: zc, Z_STREAM_END: kGt, Z_NEED_DICT: OGt, Z_STREAM_ERROR: Pa, Z_DATA_ERROR: k$, Z_MEM_ERROR: O$, Z_BUF_ERROR: QGt, Z_DEFLATED: Q$ } = Uy, fx = 16180, z$ = 16181, G$ = 16182, U$ = 16183, V$ = 16184, j$ = 16185, q$ = 16186, H$ = 16187, Y$ = 16188, W$ = 16189, gx = 16190, hl = 16191, pP = 16192, X$ = 16193, vP = 16194, $$ = 16195, Z$ = 16196, K$ = 16197, J$ = 16198, dx = 16199, Ax = 16200, tZ = 16201, eZ = 16202, nZ = 16203, iZ = 16204, rZ = 16205, yP = 16206, aZ = 16207, oZ = 16208, vn = 16209, sZ = 16210, lZ = 16211, zGt = 852, GGt = 592, UGt = 15, uZ = (n) => (n >>> 24 & 255) + (n >>> 8 & 65280) + ((n & 65280) << 8) + ((n & 255) << 24);
      function VGt() {
        this.strm = null, this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      const Gc = (n) => {
        if (!n) return 1;
        const t = n.state;
        return !t || t.strm !== n || t.mode < fx || t.mode > lZ ? 1 : 0;
      }, hZ = (n) => {
        if (Gc(n)) return Pa;
        const t = n.state;
        return n.total_in = n.total_out = t.total = 0, n.msg = "", t.wrap && (n.adler = t.wrap & 1), t.mode = fx, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(zGt), t.distcode = t.distdyn = new Int32Array(GGt), t.sane = 1, t.back = -1, zc;
      }, cZ = (n) => {
        if (Gc(n)) return Pa;
        const t = n.state;
        return t.wsize = 0, t.whave = 0, t.wnext = 0, hZ(n);
      }, fZ = (n, t) => {
        let e;
        if (Gc(n)) return Pa;
        const i = n.state;
        return t < 0 ? (e = 0, t = -t) : (e = (t >> 4) + 5, t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? Pa : (i.window !== null && i.wbits !== t && (i.window = null), i.wrap = e, i.wbits = t, cZ(n));
      }, gZ = (n, t) => {
        if (!n) return Pa;
        const e = new VGt();
        n.state = e, e.strm = n, e.window = null, e.mode = fx;
        const i = fZ(n, t);
        return i !== zc && (n.state = null), i;
      }, jGt = (n) => gZ(n, UGt);
      let dZ = true, mP, _P;
      const qGt = (n) => {
        if (dZ) {
          mP = new Int32Array(512), _P = new Int32Array(32);
          let t = 0;
          for (; t < 144; ) n.lens[t++] = 8;
          for (; t < 256; ) n.lens[t++] = 9;
          for (; t < 280; ) n.lens[t++] = 7;
          for (; t < 288; ) n.lens[t++] = 8;
          for ($y(P$, n.lens, 0, 288, mP, 0, n.work, { bits: 9 }), t = 0; t < 32; ) n.lens[t++] = 5;
          $y(N$, n.lens, 0, 32, _P, 0, n.work, { bits: 5 }), dZ = false;
        }
        n.lencode = mP, n.lenbits = 9, n.distcode = _P, n.distbits = 5;
      }, AZ = (n, t, e, i) => {
        let r;
        const a = n.state;
        return a.window === null && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new Uint8Array(a.wsize)), i >= a.wsize ? (a.window.set(t.subarray(e - a.wsize, e), 0), a.wnext = 0, a.whave = a.wsize) : (r = a.wsize - a.wnext, r > i && (r = i), a.window.set(t.subarray(e - i, e - i + r), a.wnext), i -= r, i ? (a.window.set(t.subarray(e - i, e), 0), a.wnext = i, a.whave = a.wsize) : (a.wnext += r, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += r))), 0;
      }, HGt = (n, t) => {
        let e, i, r, a, o, s, l, u, h, c, f, g, d, A, p = 0, v, y, m, _, I, E, x, w;
        const C = new Uint8Array(4);
        let S, b;
        const T = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        if (Gc(n) || !n.output || !n.input && n.avail_in !== 0) return Pa;
        e = n.state, e.mode === hl && (e.mode = pP), o = n.next_out, r = n.output, l = n.avail_out, a = n.next_in, i = n.input, s = n.avail_in, u = e.hold, h = e.bits, c = s, f = l, w = zc;
        t: for (; ; ) switch (e.mode) {
          case fx:
            if (e.wrap === 0) {
              e.mode = pP;
              break;
            }
            for (; h < 16; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            if (e.wrap & 2 && u === 35615) {
              e.wbits === 0 && (e.wbits = 15), e.check = 0, C[0] = u & 255, C[1] = u >>> 8 & 255, e.check = di(e.check, C, 2, 0), u = 0, h = 0, e.mode = z$;
              break;
            }
            if (e.head && (e.head.done = false), !(e.wrap & 1) || (((u & 255) << 8) + (u >> 8)) % 31) {
              n.msg = "incorrect header check", e.mode = vn;
              break;
            }
            if ((u & 15) !== Q$) {
              n.msg = "unknown compression method", e.mode = vn;
              break;
            }
            if (u >>>= 4, h -= 4, x = (u & 15) + 8, e.wbits === 0 && (e.wbits = x), x > 15 || x > e.wbits) {
              n.msg = "invalid window size", e.mode = vn;
              break;
            }
            e.dmax = 1 << e.wbits, e.flags = 0, n.adler = e.check = 1, e.mode = u & 512 ? W$ : hl, u = 0, h = 0;
            break;
          case z$:
            for (; h < 16; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            if (e.flags = u, (e.flags & 255) !== Q$) {
              n.msg = "unknown compression method", e.mode = vn;
              break;
            }
            if (e.flags & 57344) {
              n.msg = "unknown header flags set", e.mode = vn;
              break;
            }
            e.head && (e.head.text = u >> 8 & 1), e.flags & 512 && e.wrap & 4 && (C[0] = u & 255, C[1] = u >>> 8 & 255, e.check = di(e.check, C, 2, 0)), u = 0, h = 0, e.mode = G$;
          case G$:
            for (; h < 32; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            e.head && (e.head.time = u), e.flags & 512 && e.wrap & 4 && (C[0] = u & 255, C[1] = u >>> 8 & 255, C[2] = u >>> 16 & 255, C[3] = u >>> 24 & 255, e.check = di(e.check, C, 4, 0)), u = 0, h = 0, e.mode = U$;
          case U$:
            for (; h < 16; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            e.head && (e.head.xflags = u & 255, e.head.os = u >> 8), e.flags & 512 && e.wrap & 4 && (C[0] = u & 255, C[1] = u >>> 8 & 255, e.check = di(e.check, C, 2, 0)), u = 0, h = 0, e.mode = V$;
          case V$:
            if (e.flags & 1024) {
              for (; h < 16; ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              e.length = u, e.head && (e.head.extra_len = u), e.flags & 512 && e.wrap & 4 && (C[0] = u & 255, C[1] = u >>> 8 & 255, e.check = di(e.check, C, 2, 0)), u = 0, h = 0;
            } else e.head && (e.head.extra = null);
            e.mode = j$;
          case j$:
            if (e.flags & 1024 && (g = e.length, g > s && (g = s), g && (e.head && (x = e.head.extra_len - e.length, e.head.extra || (e.head.extra = new Uint8Array(e.head.extra_len)), e.head.extra.set(i.subarray(a, a + g), x)), e.flags & 512 && e.wrap & 4 && (e.check = di(e.check, i, g, a)), s -= g, a += g, e.length -= g), e.length)) break t;
            e.length = 0, e.mode = q$;
          case q$:
            if (e.flags & 2048) {
              if (s === 0) break t;
              g = 0;
              do
                x = i[a + g++], e.head && x && e.length < 65536 && (e.head.name += String.fromCharCode(x));
              while (x && g < s);
              if (e.flags & 512 && e.wrap & 4 && (e.check = di(e.check, i, g, a)), s -= g, a += g, x) break t;
            } else e.head && (e.head.name = null);
            e.length = 0, e.mode = H$;
          case H$:
            if (e.flags & 4096) {
              if (s === 0) break t;
              g = 0;
              do
                x = i[a + g++], e.head && x && e.length < 65536 && (e.head.comment += String.fromCharCode(x));
              while (x && g < s);
              if (e.flags & 512 && e.wrap & 4 && (e.check = di(e.check, i, g, a)), s -= g, a += g, x) break t;
            } else e.head && (e.head.comment = null);
            e.mode = Y$;
          case Y$:
            if (e.flags & 512) {
              for (; h < 16; ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              if (e.wrap & 4 && u !== (e.check & 65535)) {
                n.msg = "header crc mismatch", e.mode = vn;
                break;
              }
              u = 0, h = 0;
            }
            e.head && (e.head.hcrc = e.flags >> 9 & 1, e.head.done = true), n.adler = e.check = 0, e.mode = hl;
            break;
          case W$:
            for (; h < 32; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            n.adler = e.check = uZ(u), u = 0, h = 0, e.mode = gx;
          case gx:
            if (e.havedict === 0) return n.next_out = o, n.avail_out = l, n.next_in = a, n.avail_in = s, e.hold = u, e.bits = h, OGt;
            n.adler = e.check = 1, e.mode = hl;
          case hl:
            if (t === FGt || t === cx) break t;
          case pP:
            if (e.last) {
              u >>>= h & 7, h -= h & 7, e.mode = yP;
              break;
            }
            for (; h < 3; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            switch (e.last = u & 1, u >>>= 1, h -= 1, u & 3) {
              case 0:
                e.mode = X$;
                break;
              case 1:
                if (qGt(e), e.mode = dx, t === cx) {
                  u >>>= 2, h -= 2;
                  break t;
                }
                break;
              case 2:
                e.mode = Z$;
                break;
              case 3:
                n.msg = "invalid block type", e.mode = vn;
            }
            u >>>= 2, h -= 2;
            break;
          case X$:
            for (u >>>= h & 7, h -= h & 7; h < 32; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            if ((u & 65535) !== (u >>> 16 ^ 65535)) {
              n.msg = "invalid stored block lengths", e.mode = vn;
              break;
            }
            if (e.length = u & 65535, u = 0, h = 0, e.mode = vP, t === cx) break t;
          case vP:
            e.mode = $$;
          case $$:
            if (g = e.length, g) {
              if (g > s && (g = s), g > l && (g = l), g === 0) break t;
              r.set(i.subarray(a, a + g), o), s -= g, a += g, l -= g, o += g, e.length -= g;
              break;
            }
            e.mode = hl;
            break;
          case Z$:
            for (; h < 14; ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            if (e.nlen = (u & 31) + 257, u >>>= 5, h -= 5, e.ndist = (u & 31) + 1, u >>>= 5, h -= 5, e.ncode = (u & 15) + 4, u >>>= 4, h -= 4, e.nlen > 286 || e.ndist > 30) {
              n.msg = "too many length or distance symbols", e.mode = vn;
              break;
            }
            e.have = 0, e.mode = K$;
          case K$:
            for (; e.have < e.ncode; ) {
              for (; h < 3; ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              e.lens[T[e.have++]] = u & 7, u >>>= 3, h -= 3;
            }
            for (; e.have < 19; ) e.lens[T[e.have++]] = 0;
            if (e.lencode = e.lendyn, e.lenbits = 7, S = { bits: e.lenbits }, w = $y(NGt, e.lens, 0, 19, e.lencode, 0, e.work, S), e.lenbits = S.bits, w) {
              n.msg = "invalid code lengths set", e.mode = vn;
              break;
            }
            e.have = 0, e.mode = J$;
          case J$:
            for (; e.have < e.nlen + e.ndist; ) {
              for (; p = e.lencode[u & (1 << e.lenbits) - 1], v = p >>> 24, y = p >>> 16 & 255, m = p & 65535, !(v <= h); ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              if (m < 16) u >>>= v, h -= v, e.lens[e.have++] = m;
              else {
                if (m === 16) {
                  for (b = v + 2; h < b; ) {
                    if (s === 0) break t;
                    s--, u += i[a++] << h, h += 8;
                  }
                  if (u >>>= v, h -= v, e.have === 0) {
                    n.msg = "invalid bit length repeat", e.mode = vn;
                    break;
                  }
                  x = e.lens[e.have - 1], g = 3 + (u & 3), u >>>= 2, h -= 2;
                } else if (m === 17) {
                  for (b = v + 3; h < b; ) {
                    if (s === 0) break t;
                    s--, u += i[a++] << h, h += 8;
                  }
                  u >>>= v, h -= v, x = 0, g = 3 + (u & 7), u >>>= 3, h -= 3;
                } else {
                  for (b = v + 7; h < b; ) {
                    if (s === 0) break t;
                    s--, u += i[a++] << h, h += 8;
                  }
                  u >>>= v, h -= v, x = 0, g = 11 + (u & 127), u >>>= 7, h -= 7;
                }
                if (e.have + g > e.nlen + e.ndist) {
                  n.msg = "invalid bit length repeat", e.mode = vn;
                  break;
                }
                for (; g--; ) e.lens[e.have++] = x;
              }
            }
            if (e.mode === vn) break;
            if (e.lens[256] === 0) {
              n.msg = "invalid code -- missing end-of-block", e.mode = vn;
              break;
            }
            if (e.lenbits = 9, S = { bits: e.lenbits }, w = $y(P$, e.lens, 0, e.nlen, e.lencode, 0, e.work, S), e.lenbits = S.bits, w) {
              n.msg = "invalid literal/lengths set", e.mode = vn;
              break;
            }
            if (e.distbits = 6, e.distcode = e.distdyn, S = { bits: e.distbits }, w = $y(N$, e.lens, e.nlen, e.ndist, e.distcode, 0, e.work, S), e.distbits = S.bits, w) {
              n.msg = "invalid distances set", e.mode = vn;
              break;
            }
            if (e.mode = dx, t === cx) break t;
          case dx:
            e.mode = Ax;
          case Ax:
            if (s >= 6 && l >= 258) {
              n.next_out = o, n.avail_out = l, n.next_in = a, n.avail_in = s, e.hold = u, e.bits = h, MGt(n, f), o = n.next_out, r = n.output, l = n.avail_out, a = n.next_in, i = n.input, s = n.avail_in, u = e.hold, h = e.bits, e.mode === hl && (e.back = -1);
              break;
            }
            for (e.back = 0; p = e.lencode[u & (1 << e.lenbits) - 1], v = p >>> 24, y = p >>> 16 & 255, m = p & 65535, !(v <= h); ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            if (y && !(y & 240)) {
              for (_ = v, I = y, E = m; p = e.lencode[E + ((u & (1 << _ + I) - 1) >> _)], v = p >>> 24, y = p >>> 16 & 255, m = p & 65535, !(_ + v <= h); ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              u >>>= _, h -= _, e.back += _;
            }
            if (u >>>= v, h -= v, e.back += v, e.length = m, y === 0) {
              e.mode = rZ;
              break;
            }
            if (y & 32) {
              e.back = -1, e.mode = hl;
              break;
            }
            if (y & 64) {
              n.msg = "invalid literal/length code", e.mode = vn;
              break;
            }
            e.extra = y & 15, e.mode = tZ;
          case tZ:
            if (e.extra) {
              for (b = e.extra; h < b; ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              e.length += u & (1 << e.extra) - 1, u >>>= e.extra, h -= e.extra, e.back += e.extra;
            }
            e.was = e.length, e.mode = eZ;
          case eZ:
            for (; p = e.distcode[u & (1 << e.distbits) - 1], v = p >>> 24, y = p >>> 16 & 255, m = p & 65535, !(v <= h); ) {
              if (s === 0) break t;
              s--, u += i[a++] << h, h += 8;
            }
            if (!(y & 240)) {
              for (_ = v, I = y, E = m; p = e.distcode[E + ((u & (1 << _ + I) - 1) >> _)], v = p >>> 24, y = p >>> 16 & 255, m = p & 65535, !(_ + v <= h); ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              u >>>= _, h -= _, e.back += _;
            }
            if (u >>>= v, h -= v, e.back += v, y & 64) {
              n.msg = "invalid distance code", e.mode = vn;
              break;
            }
            e.offset = m, e.extra = y & 15, e.mode = nZ;
          case nZ:
            if (e.extra) {
              for (b = e.extra; h < b; ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              e.offset += u & (1 << e.extra) - 1, u >>>= e.extra, h -= e.extra, e.back += e.extra;
            }
            if (e.offset > e.dmax) {
              n.msg = "invalid distance too far back", e.mode = vn;
              break;
            }
            e.mode = iZ;
          case iZ:
            if (l === 0) break t;
            if (g = f - l, e.offset > g) {
              if (g = e.offset - g, g > e.whave && e.sane) {
                n.msg = "invalid distance too far back", e.mode = vn;
                break;
              }
              g > e.wnext ? (g -= e.wnext, d = e.wsize - g) : d = e.wnext - g, g > e.length && (g = e.length), A = e.window;
            } else A = r, d = o - e.offset, g = e.length;
            g > l && (g = l), l -= g, e.length -= g;
            do
              r[o++] = A[d++];
            while (--g);
            e.length === 0 && (e.mode = Ax);
            break;
          case rZ:
            if (l === 0) break t;
            r[o++] = e.length, l--, e.mode = Ax;
            break;
          case yP:
            if (e.wrap) {
              for (; h < 32; ) {
                if (s === 0) break t;
                s--, u |= i[a++] << h, h += 8;
              }
              if (f -= l, n.total_out += f, e.total += f, e.wrap & 4 && f && (n.adler = e.check = e.flags ? di(e.check, r, f, o - f) : Gy(e.check, r, f, o - f)), f = l, e.wrap & 4 && (e.flags ? u : uZ(u)) !== e.check) {
                n.msg = "incorrect data check", e.mode = vn;
                break;
              }
              u = 0, h = 0;
            }
            e.mode = aZ;
          case aZ:
            if (e.wrap && e.flags) {
              for (; h < 32; ) {
                if (s === 0) break t;
                s--, u += i[a++] << h, h += 8;
              }
              if (e.wrap & 4 && u !== (e.total & 4294967295)) {
                n.msg = "incorrect length check", e.mode = vn;
                break;
              }
              u = 0, h = 0;
            }
            e.mode = oZ;
          case oZ:
            w = kGt;
            break t;
          case vn:
            w = k$;
            break t;
          case sZ:
            return O$;
          case lZ:
          default:
            return Pa;
        }
        return n.next_out = o, n.avail_out = l, n.next_in = a, n.avail_in = s, e.hold = u, e.bits = h, (e.wsize || f !== n.avail_out && e.mode < vn && (e.mode < yP || t !== F$)) && AZ(n, n.output, n.next_out, f - n.avail_out), c -= n.avail_in, f -= n.avail_out, n.total_in += c, n.total_out += f, e.total += f, e.wrap & 4 && f && (n.adler = e.check = e.flags ? di(e.check, r, f, n.next_out - f) : Gy(e.check, r, f, n.next_out - f)), n.data_type = e.bits + (e.last ? 64 : 0) + (e.mode === hl ? 128 : 0) + (e.mode === dx || e.mode === vP ? 256 : 0), (c === 0 && f === 0 || t === F$) && w === zc && (w = QGt), w;
      }, YGt = (n) => {
        if (Gc(n)) return Pa;
        let t = n.state;
        return t.window && (t.window = null), n.state = null, zc;
      }, WGt = (n, t) => {
        if (Gc(n)) return Pa;
        const e = n.state;
        return e.wrap & 2 ? (e.head = t, t.done = false, zc) : Pa;
      }, XGt = (n, t) => {
        const e = t.length;
        let i, r, a;
        return Gc(n) || (i = n.state, i.wrap !== 0 && i.mode !== gx) ? Pa : i.mode === gx && (r = 1, r = Gy(r, t, e, 0), r !== i.check) ? k$ : (a = AZ(n, t, e, e), a ? (i.mode = sZ, O$) : (i.havedict = 1, zc));
      };
      var $Gt = cZ, ZGt = fZ, KGt = hZ, JGt = jGt, t5t = gZ, e5t = HGt, n5t = YGt, i5t = WGt, r5t = XGt, a5t = "pako inflate (from Nodeca project)", cl = { inflateReset: $Gt, inflateReset2: ZGt, inflateResetKeep: KGt, inflateInit: JGt, inflateInit2: t5t, inflate: e5t, inflateEnd: n5t, inflateGetHeader: i5t, inflateSetDictionary: r5t, inflateInfo: a5t };
      function o5t() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      }
      var s5t = o5t;
      const pZ = Object.prototype.toString, { Z_NO_FLUSH: l5t, Z_FINISH: u5t, Z_OK: Zy, Z_STREAM_END: EP, Z_NEED_DICT: IP, Z_STREAM_ERROR: h5t, Z_DATA_ERROR: vZ, Z_MEM_ERROR: c5t } = Uy;
      function Ky(n) {
        this.options = lx.assign({ chunkSize: 1024 * 64, windowBits: 15, to: "" }, n || {});
        const t = this.options;
        t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, t.windowBits === 0 && (t.windowBits = -15)), t.windowBits >= 0 && t.windowBits < 16 && !(n && n.windowBits) && (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (t.windowBits & 15 || (t.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new T$(), this.strm.avail_out = 0;
        let e = cl.inflateInit2(this.strm, t.windowBits);
        if (e !== Zy) throw new Error(zd[e]);
        if (this.header = new s5t(), cl.inflateGetHeader(this.strm, this.header), t.dictionary && (typeof t.dictionary == "string" ? t.dictionary = Xy.string2buf(t.dictionary) : pZ.call(t.dictionary) === "[object ArrayBuffer]" && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (e = cl.inflateSetDictionary(this.strm, t.dictionary), e !== Zy))) throw new Error(zd[e]);
      }
      Ky.prototype.push = function(n, t) {
        const e = this.strm, i = this.options.chunkSize, r = this.options.dictionary;
        let a, o, s;
        if (this.ended) return false;
        for (t === ~~t ? o = t : o = t === true ? u5t : l5t, pZ.call(n) === "[object ArrayBuffer]" ? e.input = new Uint8Array(n) : e.input = n, e.next_in = 0, e.avail_in = e.input.length; ; ) {
          for (e.avail_out === 0 && (e.output = new Uint8Array(i), e.next_out = 0, e.avail_out = i), a = cl.inflate(e, o), a === IP && r && (a = cl.inflateSetDictionary(e, r), a === Zy ? a = cl.inflate(e, o) : a === vZ && (a = IP)); e.avail_in > 0 && a === EP && e.state.wrap > 0 && n[e.next_in] !== 0; ) cl.inflateReset(e), a = cl.inflate(e, o);
          switch (a) {
            case h5t:
            case vZ:
            case IP:
            case c5t:
              return this.onEnd(a), this.ended = true, false;
          }
          if (s = e.avail_out, e.next_out && (e.avail_out === 0 || a === EP)) if (this.options.to === "string") {
            let l = Xy.utf8border(e.output, e.next_out), u = e.next_out - l, h = Xy.buf2string(e.output, l);
            e.next_out = u, e.avail_out = i - u, u && e.output.set(e.output.subarray(l, l + u), 0), this.onData(h);
          } else this.onData(e.output.length === e.next_out ? e.output : e.output.subarray(0, e.next_out));
          if (!(a === Zy && s === 0)) {
            if (a === EP) return a = cl.inflateEnd(this.strm), this.onEnd(a), this.ended = true, true;
            if (e.avail_in === 0) break;
          }
        }
        return true;
      }, Ky.prototype.onData = function(n) {
        this.chunks.push(n);
      }, Ky.prototype.onEnd = function(n) {
        n === Zy && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = lx.flattenChunks(this.chunks)), this.chunks = [], this.err = n, this.msg = this.strm.msg;
      };
      function xP(n, t) {
        const e = new Ky(t);
        if (e.push(n), e.err) throw e.msg || zd[e.err];
        return e.result;
      }
      function f5t(n, t) {
        return t = t || {}, t.raw = true, xP(n, t);
      }
      var g5t = Ky, d5t = xP, A5t = f5t, p5t = xP, v5t = Uy, y5t = { Inflate: g5t, inflate: d5t, inflateRaw: A5t, ungzip: p5t, constants: v5t };
      const { Inflate: h4t, inflate: m5t, inflateRaw: c4t, ungzip: f4t } = y5t;
      var yZ = m5t;
      class _5t extends ah {
        decodeBlock(t) {
          return yZ(new Uint8Array(t)).buffer;
        }
      }
      const E5t = Object.freeze(Object.defineProperty({ __proto__: null, default: _5t }, Symbol.toStringTag, { value: "Module" }));
      class I5t extends ah {
        decodeBlock(t) {
          const e = new DataView(t), i = [];
          for (let r = 0; r < t.byteLength; ++r) {
            let a = e.getInt8(r);
            if (a < 0) {
              const o = e.getUint8(r + 1);
              a = -a;
              for (let s = 0; s <= a; ++s) i.push(o);
              r += 1;
            } else {
              for (let o = 0; o <= a; ++o) i.push(e.getUint8(r + o + 1));
              r += a + 1;
            }
          }
          return new Uint8Array(i).buffer;
        }
      }
      const x5t = Object.freeze(Object.defineProperty({ __proto__: null, default: I5t }, Symbol.toStringTag, { value: "Module" }));
      var mZ = { exports: {} };
      (function(n) {
        (function() {
          var t = function() {
            var a = {};
            a.defaultNoDataValue = -34027999387901484e22, a.decode = function(c, f) {
              f = f || {};
              var g = f.encodedMaskData || f.encodedMaskData === null, d = u(c, f.inputOffset || 0, g), A = f.noDataValue !== null ? f.noDataValue : a.defaultNoDataValue, p = o(d, f.pixelType || Float32Array, f.encodedMaskData, A, f.returnMask), v = { width: d.width, height: d.height, pixelData: p.resultPixels, minValue: p.minValue, maxValue: d.pixels.maxValue, noDataValue: A };
              return p.resultMask && (v.maskData = p.resultMask), f.returnEncodedMask && d.mask && (v.encodedMaskData = d.mask.bitset ? d.mask.bitset : null), f.returnFileInfo && (v.fileInfo = s(d), f.computeUsedBitDepths && (v.fileInfo.bitDepths = l(d))), v;
            };
            var o = function(c, f, g, d, A) {
              var p = 0, v = c.pixels.numBlocksX, y = c.pixels.numBlocksY, m = Math.floor(c.width / v), _ = Math.floor(c.height / y), I = 2 * c.maxZError, E = Number.MAX_VALUE, x;
              g = g || (c.mask ? c.mask.bitset : null);
              var w, C;
              w = new f(c.width * c.height), A && g && (C = new Uint8Array(c.width * c.height));
              for (var S = new Float32Array(m * _), b, T, B = 0; B <= y; B++) {
                var R = B !== y ? _ : c.height % y;
                if (R !== 0) for (var M = 0; M <= v; M++) {
                  var L = M !== v ? m : c.width % v;
                  if (L !== 0) {
                    var N = B * c.width * _ + M * m, F = c.width - L, k = c.pixels.blocks[p], O, Q, j;
                    k.encoding < 2 ? (k.encoding === 0 ? O = k.rawData : (h(k.stuffedData, k.bitsPerPixel, k.numValidPixels, k.offset, I, S, c.pixels.maxValue), O = S), Q = 0) : k.encoding === 2 ? j = 0 : j = k.offset;
                    var Y;
                    if (g) for (T = 0; T < R; T++) {
                      for (N & 7 && (Y = g[N >> 3], Y <<= N & 7), b = 0; b < L; b++) N & 7 || (Y = g[N >> 3]), Y & 128 ? (C && (C[N] = 1), x = k.encoding < 2 ? O[Q++] : j, E = E > x ? x : E, w[N++] = x) : (C && (C[N] = 0), w[N++] = d), Y <<= 1;
                      N += F;
                    }
                    else if (k.encoding < 2) for (T = 0; T < R; T++) {
                      for (b = 0; b < L; b++) x = O[Q++], E = E > x ? x : E, w[N++] = x;
                      N += F;
                    }
                    else for (E = E > j ? j : E, T = 0; T < R; T++) {
                      for (b = 0; b < L; b++) w[N++] = j;
                      N += F;
                    }
                    if (k.encoding === 1 && Q !== k.numValidPixels) throw "Block and Mask do not match";
                    p++;
                  }
                }
              }
              return { resultPixels: w, resultMask: C, minValue: E };
            }, s = function(c) {
              return { fileIdentifierString: c.fileIdentifierString, fileVersion: c.fileVersion, imageType: c.imageType, height: c.height, width: c.width, maxZError: c.maxZError, eofOffset: c.eofOffset, mask: c.mask ? { numBlocksX: c.mask.numBlocksX, numBlocksY: c.mask.numBlocksY, numBytes: c.mask.numBytes, maxValue: c.mask.maxValue } : null, pixels: { numBlocksX: c.pixels.numBlocksX, numBlocksY: c.pixels.numBlocksY, numBytes: c.pixels.numBytes, maxValue: c.pixels.maxValue, noDataValue: c.noDataValue } };
            }, l = function(c) {
              for (var f = c.pixels.numBlocksX * c.pixels.numBlocksY, g = {}, d = 0; d < f; d++) {
                var A = c.pixels.blocks[d];
                A.encoding === 0 ? g.float32 = true : A.encoding === 1 ? g[A.bitsPerPixel] = true : g[0] = true;
              }
              return Object.keys(g);
            }, u = function(c, f, g) {
              var d = {}, A = new Uint8Array(c, f, 10);
              if (d.fileIdentifierString = String.fromCharCode.apply(null, A), d.fileIdentifierString.trim() !== "CntZImage") throw "Unexpected file identifier string: " + d.fileIdentifierString;
              f += 10;
              var p = new DataView(c, f, 24);
              if (d.fileVersion = p.getInt32(0, true), d.imageType = p.getInt32(4, true), d.height = p.getUint32(8, true), d.width = p.getUint32(12, true), d.maxZError = p.getFloat64(16, true), f += 24, !g) if (p = new DataView(c, f, 16), d.mask = {}, d.mask.numBlocksY = p.getUint32(0, true), d.mask.numBlocksX = p.getUint32(4, true), d.mask.numBytes = p.getUint32(8, true), d.mask.maxValue = p.getFloat32(12, true), f += 16, d.mask.numBytes > 0) {
                var v = new Uint8Array(Math.ceil(d.width * d.height / 8));
                p = new DataView(c, f, d.mask.numBytes);
                var y = p.getInt16(0, true), m = 2, _ = 0;
                do {
                  if (y > 0) for (; y--; ) v[_++] = p.getUint8(m++);
                  else {
                    var I = p.getUint8(m++);
                    for (y = -y; y--; ) v[_++] = I;
                  }
                  y = p.getInt16(m, true), m += 2;
                } while (m < d.mask.numBytes);
                if (y !== -32768 || _ < v.length) throw "Unexpected end of mask RLE encoding";
                d.mask.bitset = v, f += d.mask.numBytes;
              } else d.mask.numBytes | d.mask.numBlocksY | d.mask.maxValue || (d.mask.bitset = new Uint8Array(Math.ceil(d.width * d.height / 8)));
              p = new DataView(c, f, 16), d.pixels = {}, d.pixels.numBlocksY = p.getUint32(0, true), d.pixels.numBlocksX = p.getUint32(4, true), d.pixels.numBytes = p.getUint32(8, true), d.pixels.maxValue = p.getFloat32(12, true), f += 16;
              var E = d.pixels.numBlocksX, x = d.pixels.numBlocksY, w = E + (d.width % E > 0 ? 1 : 0), C = x + (d.height % x > 0 ? 1 : 0);
              d.pixels.blocks = new Array(w * C);
              for (var S = 0, b = 0; b < C; b++) for (var T = 0; T < w; T++) {
                var B = 0, R = c.byteLength - f;
                p = new DataView(c, f, Math.min(10, R));
                var M = {};
                d.pixels.blocks[S++] = M;
                var L = p.getUint8(0);
                if (B++, M.encoding = L & 63, M.encoding > 3) throw "Invalid block encoding (" + M.encoding + ")";
                if (M.encoding === 2) {
                  f++;
                  continue;
                }
                if (L !== 0 && L !== 2) {
                  if (L >>= 6, M.offsetType = L, L === 2) M.offset = p.getInt8(1), B++;
                  else if (L === 1) M.offset = p.getInt16(1, true), B += 2;
                  else if (L === 0) M.offset = p.getFloat32(1, true), B += 4;
                  else throw "Invalid block offset type";
                  if (M.encoding === 1) if (L = p.getUint8(B), B++, M.bitsPerPixel = L & 63, L >>= 6, M.numValidPixelsType = L, L === 2) M.numValidPixels = p.getUint8(B), B++;
                  else if (L === 1) M.numValidPixels = p.getUint16(B, true), B += 2;
                  else if (L === 0) M.numValidPixels = p.getUint32(B, true), B += 4;
                  else throw "Invalid valid pixel count type";
                }
                if (f += B, M.encoding !== 3) {
                  var N, F;
                  if (M.encoding === 0) {
                    var k = (d.pixels.numBytes - 1) / 4;
                    if (k !== Math.floor(k)) throw "uncompressed block has invalid length";
                    N = new ArrayBuffer(k * 4), F = new Uint8Array(N), F.set(new Uint8Array(c, f, k * 4));
                    var O = new Float32Array(N);
                    M.rawData = O, f += k * 4;
                  } else if (M.encoding === 1) {
                    var Q = Math.ceil(M.numValidPixels * M.bitsPerPixel / 8), j = Math.ceil(Q / 4);
                    N = new ArrayBuffer(j * 4), F = new Uint8Array(N), F.set(new Uint8Array(c, f, Q)), M.stuffedData = new Uint32Array(N), f += Q;
                  }
                }
              }
              return d.eofOffset = f, d;
            }, h = function(c, f, g, d, A, p, v) {
              var y = (1 << f) - 1, m = 0, _, I = 0, E, x, w = Math.ceil((v - d) / A), C = c.length * 4 - Math.ceil(f * g / 8);
              for (c[c.length - 1] <<= 8 * C, _ = 0; _ < g; _++) {
                if (I === 0 && (x = c[m++], I = 32), I >= f) E = x >>> I - f & y, I -= f;
                else {
                  var S = f - I;
                  E = (x & y) << S & y, x = c[m++], I = 32 - S, E += x >>> I;
                }
                p[_] = E < w ? d + E * A : v;
              }
              return p;
            };
            return a;
          }(), e = /* @__PURE__ */ function() {
            var a = { unstuff: function(u, h, c, f, g, d, A, p) {
              var v = (1 << c) - 1, y = 0, m, _ = 0, I, E, x, w, C = u.length * 4 - Math.ceil(c * f / 8);
              if (u[u.length - 1] <<= 8 * C, g) for (m = 0; m < f; m++) _ === 0 && (E = u[y++], _ = 32), _ >= c ? (I = E >>> _ - c & v, _ -= c) : (x = c - _, I = (E & v) << x & v, E = u[y++], _ = 32 - x, I += E >>> _), h[m] = g[I];
              else for (w = Math.ceil((p - d) / A), m = 0; m < f; m++) _ === 0 && (E = u[y++], _ = 32), _ >= c ? (I = E >>> _ - c & v, _ -= c) : (x = c - _, I = (E & v) << x & v, E = u[y++], _ = 32 - x, I += E >>> _), h[m] = I < w ? d + I * A : p;
            }, unstuffLUT: function(u, h, c, f, g, d) {
              var A = (1 << h) - 1, p = 0, v = 0, y = 0, m = 0, _ = 0, I, E = [], x = u.length * 4 - Math.ceil(h * c / 8);
              u[u.length - 1] <<= 8 * x;
              var w = Math.ceil((d - f) / g);
              for (v = 0; v < c; v++) m === 0 && (I = u[p++], m = 32), m >= h ? (_ = I >>> m - h & A, m -= h) : (y = h - m, _ = (I & A) << y & A, I = u[p++], m = 32 - y, _ += I >>> m), E[v] = _ < w ? f + _ * g : d;
              return E.unshift(f), E;
            }, unstuff2: function(u, h, c, f, g, d, A, p) {
              var v = (1 << c) - 1, y = 0, m, _ = 0, I = 0, E, x, w;
              if (g) for (m = 0; m < f; m++) _ === 0 && (x = u[y++], _ = 32, I = 0), _ >= c ? (E = x >>> I & v, _ -= c, I += c) : (w = c - _, E = x >>> I & v, x = u[y++], _ = 32 - w, E |= (x & (1 << w) - 1) << c - w, I = w), h[m] = g[E];
              else {
                var C = Math.ceil((p - d) / A);
                for (m = 0; m < f; m++) _ === 0 && (x = u[y++], _ = 32, I = 0), _ >= c ? (E = x >>> I & v, _ -= c, I += c) : (w = c - _, E = x >>> I & v, x = u[y++], _ = 32 - w, E |= (x & (1 << w) - 1) << c - w, I = w), h[m] = E < C ? d + E * A : p;
              }
              return h;
            }, unstuffLUT2: function(u, h, c, f, g, d) {
              var A = (1 << h) - 1, p = 0, v = 0, y = 0, m = 0, _ = 0, I = 0, E, x = [], w = Math.ceil((d - f) / g);
              for (v = 0; v < c; v++) m === 0 && (E = u[p++], m = 32, I = 0), m >= h ? (_ = E >>> I & A, m -= h, I += h) : (y = h - m, _ = E >>> I & A, E = u[p++], m = 32 - y, _ |= (E & (1 << y) - 1) << h - y, I = y), x[v] = _ < w ? f + _ * g : d;
              return x.unshift(f), x;
            }, originalUnstuff: function(u, h, c, f) {
              var g = (1 << c) - 1, d = 0, A, p = 0, v, y, m, _ = u.length * 4 - Math.ceil(c * f / 8);
              for (u[u.length - 1] <<= 8 * _, A = 0; A < f; A++) p === 0 && (y = u[d++], p = 32), p >= c ? (v = y >>> p - c & g, p -= c) : (m = c - p, v = (y & g) << m & g, y = u[d++], p = 32 - m, v += y >>> p), h[A] = v;
              return h;
            }, originalUnstuff2: function(u, h, c, f) {
              var g = (1 << c) - 1, d = 0, A, p = 0, v = 0, y, m, _;
              for (A = 0; A < f; A++) p === 0 && (m = u[d++], p = 32, v = 0), p >= c ? (y = m >>> v & g, p -= c, v += c) : (_ = c - p, y = m >>> v & g, m = u[d++], p = 32 - _, y |= (m & (1 << _) - 1) << c - _, v = _), h[A] = y;
              return h;
            } }, o = { HUFFMAN_LUT_BITS_MAX: 12, computeChecksumFletcher32: function(u) {
              for (var h = 65535, c = 65535, f = u.length, g = Math.floor(f / 2), d = 0; g; ) {
                var A = g >= 359 ? 359 : g;
                g -= A;
                do
                  h += u[d++] << 8, c += h += u[d++];
                while (--A);
                h = (h & 65535) + (h >>> 16), c = (c & 65535) + (c >>> 16);
              }
              return f & 1 && (c += h += u[d] << 8), h = (h & 65535) + (h >>> 16), c = (c & 65535) + (c >>> 16), (c << 16 | h) >>> 0;
            }, readHeaderInfo: function(u, h) {
              var c = h.ptr, f = new Uint8Array(u, c, 6), g = {};
              if (g.fileIdentifierString = String.fromCharCode.apply(null, f), g.fileIdentifierString.lastIndexOf("Lerc2", 0) !== 0) throw "Unexpected file identifier string (expect Lerc2 ): " + g.fileIdentifierString;
              c += 6;
              var d = new DataView(u, c, 8), A = d.getInt32(0, true);
              g.fileVersion = A, c += 4, A >= 3 && (g.checksum = d.getUint32(4, true), c += 4), d = new DataView(u, c, 12), g.height = d.getUint32(0, true), g.width = d.getUint32(4, true), c += 8, A >= 4 ? (g.numDims = d.getUint32(8, true), c += 4) : g.numDims = 1, d = new DataView(u, c, 40), g.numValidPixel = d.getUint32(0, true), g.microBlockSize = d.getInt32(4, true), g.blobSize = d.getInt32(8, true), g.imageType = d.getInt32(12, true), g.maxZError = d.getFloat64(16, true), g.zMin = d.getFloat64(24, true), g.zMax = d.getFloat64(32, true), c += 40, h.headerInfo = g, h.ptr = c;
              var p, v;
              if (A >= 3 && (v = A >= 4 ? 52 : 48, p = this.computeChecksumFletcher32(new Uint8Array(u, c - v, g.blobSize - 14)), p !== g.checksum)) throw "Checksum failed.";
              return true;
            }, checkMinMaxRanges: function(u, h) {
              var c = h.headerInfo, f = this.getDataTypeArray(c.imageType), g = c.numDims * this.getDataTypeSize(c.imageType), d = this.readSubArray(u, h.ptr, f, g), A = this.readSubArray(u, h.ptr + g, f, g);
              h.ptr += 2 * g;
              var p, v = true;
              for (p = 0; p < c.numDims; p++) if (d[p] !== A[p]) {
                v = false;
                break;
              }
              return c.minValues = d, c.maxValues = A, v;
            }, readSubArray: function(u, h, c, f) {
              var g;
              if (c === Uint8Array) g = new Uint8Array(u, h, f);
              else {
                var d = new ArrayBuffer(f), A = new Uint8Array(d);
                A.set(new Uint8Array(u, h, f)), g = new c(d);
              }
              return g;
            }, readMask: function(u, h) {
              var c = h.ptr, f = h.headerInfo, g = f.width * f.height, d = f.numValidPixel, A = new DataView(u, c, 4), p = {};
              if (p.numBytes = A.getUint32(0, true), c += 4, (d === 0 || g === d) && p.numBytes !== 0) throw "invalid mask";
              var v, y;
              if (d === 0) v = new Uint8Array(Math.ceil(g / 8)), p.bitset = v, y = new Uint8Array(g), h.pixels.resultMask = y, c += p.numBytes;
              else if (p.numBytes > 0) {
                v = new Uint8Array(Math.ceil(g / 8)), A = new DataView(u, c, p.numBytes);
                var m = A.getInt16(0, true), _ = 2, I = 0, E = 0;
                do {
                  if (m > 0) for (; m--; ) v[I++] = A.getUint8(_++);
                  else for (E = A.getUint8(_++), m = -m; m--; ) v[I++] = E;
                  m = A.getInt16(_, true), _ += 2;
                } while (_ < p.numBytes);
                if (m !== -32768 || I < v.length) throw "Unexpected end of mask RLE encoding";
                y = new Uint8Array(g);
                var x = 0, w = 0;
                for (w = 0; w < g; w++) w & 7 ? (x = v[w >> 3], x <<= w & 7) : x = v[w >> 3], x & 128 && (y[w] = 1);
                h.pixels.resultMask = y, p.bitset = v, c += p.numBytes;
              }
              return h.ptr = c, h.mask = p, true;
            }, readDataOneSweep: function(u, h, c, f) {
              var g = h.ptr, d = h.headerInfo, A = d.numDims, p = d.width * d.height, v = d.imageType, y = d.numValidPixel * o.getDataTypeSize(v) * A, m, _ = h.pixels.resultMask;
              if (c === Uint8Array) m = new Uint8Array(u, g, y);
              else {
                var I = new ArrayBuffer(y), E = new Uint8Array(I);
                E.set(new Uint8Array(u, g, y)), m = new c(I);
              }
              if (m.length === p * A) f ? h.pixels.resultPixels = o.swapDimensionOrder(m, p, A, c, true) : h.pixels.resultPixels = m;
              else {
                h.pixels.resultPixels = new c(p * A);
                var x = 0, w = 0, C = 0, S = 0;
                if (A > 1) {
                  if (f) {
                    for (w = 0; w < p; w++) if (_[w]) for (S = w, C = 0; C < A; C++, S += p) h.pixels.resultPixels[S] = m[x++];
                  } else for (w = 0; w < p; w++) if (_[w]) for (S = w * A, C = 0; C < A; C++) h.pixels.resultPixels[S + C] = m[x++];
                } else for (w = 0; w < p; w++) _[w] && (h.pixels.resultPixels[w] = m[x++]);
              }
              return g += y, h.ptr = g, true;
            }, readHuffmanTree: function(u, h) {
              var c = this.HUFFMAN_LUT_BITS_MAX, f = new DataView(u, h.ptr, 16);
              h.ptr += 16;
              var g = f.getInt32(0, true);
              if (g < 2) throw "unsupported Huffman version";
              var d = f.getInt32(4, true), A = f.getInt32(8, true), p = f.getInt32(12, true);
              if (A >= p) return false;
              var v = new Uint32Array(p - A);
              o.decodeBits(u, h, v);
              var y = [], m, _, I, E;
              for (m = A; m < p; m++) _ = m - (m < d ? 0 : d), y[_] = { first: v[m - A], second: null };
              var x = u.byteLength - h.ptr, w = Math.ceil(x / 4), C = new ArrayBuffer(w * 4), S = new Uint8Array(C);
              S.set(new Uint8Array(u, h.ptr, x));
              var b = new Uint32Array(C), T = 0, B, R = 0;
              for (B = b[0], m = A; m < p; m++) _ = m - (m < d ? 0 : d), E = y[_].first, E > 0 && (y[_].second = B << T >>> 32 - E, 32 - T >= E ? (T += E, T === 32 && (T = 0, R++, B = b[R])) : (T += E - 32, R++, B = b[R], y[_].second |= B >>> 32 - T));
              var M = 0, L = 0, N = new s();
              for (m = 0; m < y.length; m++) y[m] !== void 0 && (M = Math.max(M, y[m].first));
              M >= c ? L = c : L = M;
              var F = [], k, O, Q, j, Y, G;
              for (m = A; m < p; m++) if (_ = m - (m < d ? 0 : d), E = y[_].first, E > 0) if (k = [E, _], E <= L) for (O = y[_].second << L - E, Q = 1 << L - E, I = 0; I < Q; I++) F[O | I] = k;
              else for (O = y[_].second, G = N, j = E - 1; j >= 0; j--) Y = O >>> j & 1, Y ? (G.right || (G.right = new s()), G = G.right) : (G.left || (G.left = new s()), G = G.left), j === 0 && !G.val && (G.val = k[1]);
              return { decodeLut: F, numBitsLUTQick: L, numBitsLUT: M, tree: N, stuffedData: b, srcPtr: R, bitPos: T };
            }, readHuffman: function(u, h, c, f) {
              var g = h.headerInfo, d = g.numDims, A = h.headerInfo.height, p = h.headerInfo.width, v = p * A, y = this.readHuffmanTree(u, h), m = y.decodeLut, _ = y.tree, I = y.stuffedData, E = y.srcPtr, x = y.bitPos, w = y.numBitsLUTQick, C = y.numBitsLUT, S = h.headerInfo.imageType === 0 ? 128 : 0, b, T, B, R = h.pixels.resultMask, M, L, N, F, k, O, Q, j = 0;
              x > 0 && (E++, x = 0);
              var Y = I[E], G = h.encodeMode === 1, $ = new c(v * d), J = $, et;
              if (d < 2 || G) {
                for (et = 0; et < d; et++) if (d > 1 && (J = new c($.buffer, v * et, v), j = 0), h.headerInfo.numValidPixel === p * A) for (O = 0, F = 0; F < A; F++) for (k = 0; k < p; k++, O++) {
                  if (T = 0, M = Y << x >>> 32 - w, L = M, 32 - x < w && (M |= I[E + 1] >>> 64 - x - w, L = M), m[L]) T = m[L][1], x += m[L][0];
                  else for (M = Y << x >>> 32 - C, L = M, 32 - x < C && (M |= I[E + 1] >>> 64 - x - C, L = M), b = _, Q = 0; Q < C; Q++) if (N = M >>> C - Q - 1 & 1, b = N ? b.right : b.left, !(b.left || b.right)) {
                    T = b.val, x = x + Q + 1;
                    break;
                  }
                  x >= 32 && (x -= 32, E++, Y = I[E]), B = T - S, G ? (k > 0 ? B += j : F > 0 ? B += J[O - p] : B += j, B &= 255, J[O] = B, j = B) : J[O] = B;
                }
                else for (O = 0, F = 0; F < A; F++) for (k = 0; k < p; k++, O++) if (R[O]) {
                  if (T = 0, M = Y << x >>> 32 - w, L = M, 32 - x < w && (M |= I[E + 1] >>> 64 - x - w, L = M), m[L]) T = m[L][1], x += m[L][0];
                  else for (M = Y << x >>> 32 - C, L = M, 32 - x < C && (M |= I[E + 1] >>> 64 - x - C, L = M), b = _, Q = 0; Q < C; Q++) if (N = M >>> C - Q - 1 & 1, b = N ? b.right : b.left, !(b.left || b.right)) {
                    T = b.val, x = x + Q + 1;
                    break;
                  }
                  x >= 32 && (x -= 32, E++, Y = I[E]), B = T - S, G ? (k > 0 && R[O - 1] ? B += j : F > 0 && R[O - p] ? B += J[O - p] : B += j, B &= 255, J[O] = B, j = B) : J[O] = B;
                }
              } else for (O = 0, F = 0; F < A; F++) for (k = 0; k < p; k++) if (O = F * p + k, !R || R[O]) for (et = 0; et < d; et++, O += v) {
                if (T = 0, M = Y << x >>> 32 - w, L = M, 32 - x < w && (M |= I[E + 1] >>> 64 - x - w, L = M), m[L]) T = m[L][1], x += m[L][0];
                else for (M = Y << x >>> 32 - C, L = M, 32 - x < C && (M |= I[E + 1] >>> 64 - x - C, L = M), b = _, Q = 0; Q < C; Q++) if (N = M >>> C - Q - 1 & 1, b = N ? b.right : b.left, !(b.left || b.right)) {
                  T = b.val, x = x + Q + 1;
                  break;
                }
                x >= 32 && (x -= 32, E++, Y = I[E]), B = T - S, J[O] = B;
              }
              h.ptr = h.ptr + (E + 1) * 4 + (x > 0 ? 4 : 0), h.pixels.resultPixels = $, d > 1 && !f && (h.pixels.resultPixels = o.swapDimensionOrder($, v, d, c));
            }, decodeBits: function(u, h, c, f, g) {
              {
                var d = h.headerInfo, A = d.fileVersion, p = 0, v = u.byteLength - h.ptr >= 5 ? 5 : u.byteLength - h.ptr, y = new DataView(u, h.ptr, v), m = y.getUint8(0);
                p++;
                var _ = m >> 6, I = _ === 0 ? 4 : 3 - _, E = (m & 32) > 0, x = m & 31, w = 0;
                if (I === 1) w = y.getUint8(p), p++;
                else if (I === 2) w = y.getUint16(p, true), p += 2;
                else if (I === 4) w = y.getUint32(p, true), p += 4;
                else throw "Invalid valid pixel count type";
                var C = 2 * d.maxZError, S, b, T, B, R, M, L, N, F, k = d.numDims > 1 ? d.maxValues[g] : d.zMax;
                if (E) {
                  for (h.counter.lut++, N = y.getUint8(p), p++, B = Math.ceil((N - 1) * x / 8), R = Math.ceil(B / 4), b = new ArrayBuffer(R * 4), T = new Uint8Array(b), h.ptr += p, T.set(new Uint8Array(u, h.ptr, B)), L = new Uint32Array(b), h.ptr += B, F = 0; N - 1 >>> F; ) F++;
                  B = Math.ceil(w * F / 8), R = Math.ceil(B / 4), b = new ArrayBuffer(R * 4), T = new Uint8Array(b), T.set(new Uint8Array(u, h.ptr, B)), S = new Uint32Array(b), h.ptr += B, A >= 3 ? M = a.unstuffLUT2(L, x, N - 1, f, C, k) : M = a.unstuffLUT(L, x, N - 1, f, C, k), A >= 3 ? a.unstuff2(S, c, F, w, M) : a.unstuff(S, c, F, w, M);
                } else h.counter.bitstuffer++, F = x, h.ptr += p, F > 0 && (B = Math.ceil(w * F / 8), R = Math.ceil(B / 4), b = new ArrayBuffer(R * 4), T = new Uint8Array(b), T.set(new Uint8Array(u, h.ptr, B)), S = new Uint32Array(b), h.ptr += B, A >= 3 ? f == null ? a.originalUnstuff2(S, c, F, w) : a.unstuff2(S, c, F, w, false, f, C, k) : f == null ? a.originalUnstuff(S, c, F, w) : a.unstuff(S, c, F, w, false, f, C, k));
              }
            }, readTiles: function(u, h, c, f) {
              var g = h.headerInfo, d = g.width, A = g.height, p = d * A, v = g.microBlockSize, y = g.imageType, m = o.getDataTypeSize(y), _ = Math.ceil(d / v), I = Math.ceil(A / v);
              h.pixels.numBlocksY = I, h.pixels.numBlocksX = _, h.pixels.ptr = 0;
              var E = 0, x = 0, w = 0, C = 0, S = 0, b = 0, T = 0, B = 0, R = 0, M = 0, L = 0, N = 0, F = 0, k = 0, O = 0, Q = 0, j, Y, G, $, J, et, nt = new c(v * v), gt = A % v || v, q = d % v || v, W, it, Ot = g.numDims, pt, St = h.pixels.resultMask, bt = h.pixels.resultPixels, xe = g.fileVersion, sn = xe >= 5 ? 14 : 15, Ie, yn = g.zMax, ln;
              for (w = 0; w < I; w++) for (S = w !== I - 1 ? v : gt, C = 0; C < _; C++) for (b = C !== _ - 1 ? v : q, L = w * d * v + C * v, N = d - b, pt = 0; pt < Ot; pt++) {
                if (Ot > 1 ? (ln = bt, L = w * d * v + C * v, bt = new c(h.pixels.resultPixels.buffer, p * pt * m, p), yn = g.maxValues[pt]) : ln = null, T = u.byteLength - h.ptr, j = new DataView(u, h.ptr, Math.min(10, T)), Y = {}, Q = 0, B = j.getUint8(0), Q++, Ie = g.fileVersion >= 5 ? B & 4 : 0, R = B >> 6 & 255, M = B >> 2 & sn, M !== (C * v >> 3 & sn) || Ie && pt === 0) throw "integrity issue";
                if (et = B & 3, et > 3) throw h.ptr += Q, "Invalid block encoding (" + et + ")";
                if (et === 2) {
                  if (Ie) if (St) for (E = 0; E < S; E++) for (x = 0; x < b; x++) St[L] && (bt[L] = ln[L]), L++;
                  else for (E = 0; E < S; E++) for (x = 0; x < b; x++) bt[L] = ln[L], L++;
                  h.counter.constant++, h.ptr += Q;
                  continue;
                } else if (et === 0) {
                  if (Ie) throw "integrity issue";
                  if (h.counter.uncompressed++, h.ptr += Q, F = S * b * m, k = u.byteLength - h.ptr, F = F < k ? F : k, G = new ArrayBuffer(F % m === 0 ? F : F + m - F % m), $ = new Uint8Array(G), $.set(new Uint8Array(u, h.ptr, F)), J = new c(G), O = 0, St) for (E = 0; E < S; E++) {
                    for (x = 0; x < b; x++) St[L] && (bt[L] = J[O++]), L++;
                    L += N;
                  }
                  else for (E = 0; E < S; E++) {
                    for (x = 0; x < b; x++) bt[L++] = J[O++];
                    L += N;
                  }
                  h.ptr += O * m;
                } else if (W = o.getDataTypeUsed(Ie && y < 6 ? 4 : y, R), it = o.getOnePixel(Y, Q, W, j), Q += o.getDataTypeSize(W), et === 3) if (h.ptr += Q, h.counter.constantoffset++, St) for (E = 0; E < S; E++) {
                  for (x = 0; x < b; x++) St[L] && (bt[L] = Ie ? Math.min(yn, ln[L] + it) : it), L++;
                  L += N;
                }
                else for (E = 0; E < S; E++) {
                  for (x = 0; x < b; x++) bt[L] = Ie ? Math.min(yn, ln[L] + it) : it, L++;
                  L += N;
                }
                else if (h.ptr += Q, o.decodeBits(u, h, nt, it, pt), Q = 0, Ie) if (St) for (E = 0; E < S; E++) {
                  for (x = 0; x < b; x++) St[L] && (bt[L] = nt[Q++] + ln[L]), L++;
                  L += N;
                }
                else for (E = 0; E < S; E++) {
                  for (x = 0; x < b; x++) bt[L] = nt[Q++] + ln[L], L++;
                  L += N;
                }
                else if (St) for (E = 0; E < S; E++) {
                  for (x = 0; x < b; x++) St[L] && (bt[L] = nt[Q++]), L++;
                  L += N;
                }
                else for (E = 0; E < S; E++) {
                  for (x = 0; x < b; x++) bt[L++] = nt[Q++];
                  L += N;
                }
              }
              Ot > 1 && !f && (h.pixels.resultPixels = o.swapDimensionOrder(h.pixels.resultPixels, p, Ot, c));
            }, formatFileInfo: function(u) {
              return { fileIdentifierString: u.headerInfo.fileIdentifierString, fileVersion: u.headerInfo.fileVersion, imageType: u.headerInfo.imageType, height: u.headerInfo.height, width: u.headerInfo.width, numValidPixel: u.headerInfo.numValidPixel, microBlockSize: u.headerInfo.microBlockSize, blobSize: u.headerInfo.blobSize, maxZError: u.headerInfo.maxZError, pixelType: o.getPixelType(u.headerInfo.imageType), eofOffset: u.eofOffset, mask: u.mask ? { numBytes: u.mask.numBytes } : null, pixels: { numBlocksX: u.pixels.numBlocksX, numBlocksY: u.pixels.numBlocksY, maxValue: u.headerInfo.zMax, minValue: u.headerInfo.zMin, noDataValue: u.noDataValue } };
            }, constructConstantSurface: function(u, h) {
              var c = u.headerInfo.zMax, f = u.headerInfo.zMin, g = u.headerInfo.maxValues, d = u.headerInfo.numDims, A = u.headerInfo.height * u.headerInfo.width, p = 0, v = 0, y = 0, m = u.pixels.resultMask, _ = u.pixels.resultPixels;
              if (m) if (d > 1) {
                if (h) for (p = 0; p < d; p++) for (y = p * A, c = g[p], v = 0; v < A; v++) m[v] && (_[y + v] = c);
                else for (v = 0; v < A; v++) if (m[v]) for (y = v * d, p = 0; p < d; p++) _[y + d] = g[p];
              } else for (v = 0; v < A; v++) m[v] && (_[v] = c);
              else if (d > 1 && f !== c) if (h) for (p = 0; p < d; p++) for (y = p * A, c = g[p], v = 0; v < A; v++) _[y + v] = c;
              else for (v = 0; v < A; v++) for (y = v * d, p = 0; p < d; p++) _[y + p] = g[p];
              else for (v = 0; v < A * d; v++) _[v] = c;
            }, getDataTypeArray: function(u) {
              var h;
              switch (u) {
                case 0:
                  h = Int8Array;
                  break;
                case 1:
                  h = Uint8Array;
                  break;
                case 2:
                  h = Int16Array;
                  break;
                case 3:
                  h = Uint16Array;
                  break;
                case 4:
                  h = Int32Array;
                  break;
                case 5:
                  h = Uint32Array;
                  break;
                case 6:
                  h = Float32Array;
                  break;
                case 7:
                  h = Float64Array;
                  break;
                default:
                  h = Float32Array;
              }
              return h;
            }, getPixelType: function(u) {
              var h;
              switch (u) {
                case 0:
                  h = "S8";
                  break;
                case 1:
                  h = "U8";
                  break;
                case 2:
                  h = "S16";
                  break;
                case 3:
                  h = "U16";
                  break;
                case 4:
                  h = "S32";
                  break;
                case 5:
                  h = "U32";
                  break;
                case 6:
                  h = "F32";
                  break;
                case 7:
                  h = "F64";
                  break;
                default:
                  h = "F32";
              }
              return h;
            }, isValidPixelValue: function(u, h) {
              if (h == null) return false;
              var c;
              switch (u) {
                case 0:
                  c = h >= -128 && h <= 127;
                  break;
                case 1:
                  c = h >= 0 && h <= 255;
                  break;
                case 2:
                  c = h >= -32768 && h <= 32767;
                  break;
                case 3:
                  c = h >= 0 && h <= 65536;
                  break;
                case 4:
                  c = h >= -2147483648 && h <= 2147483647;
                  break;
                case 5:
                  c = h >= 0 && h <= 4294967296;
                  break;
                case 6:
                  c = h >= -34027999387901484e22 && h <= 34027999387901484e22;
                  break;
                case 7:
                  c = h >= -17976931348623157e292 && h <= 17976931348623157e292;
                  break;
                default:
                  c = false;
              }
              return c;
            }, getDataTypeSize: function(u) {
              var h = 0;
              switch (u) {
                case 0:
                case 1:
                  h = 1;
                  break;
                case 2:
                case 3:
                  h = 2;
                  break;
                case 4:
                case 5:
                case 6:
                  h = 4;
                  break;
                case 7:
                  h = 8;
                  break;
                default:
                  h = u;
              }
              return h;
            }, getDataTypeUsed: function(u, h) {
              var c = u;
              switch (u) {
                case 2:
                case 4:
                  c = u - h;
                  break;
                case 3:
                case 5:
                  c = u - 2 * h;
                  break;
                case 6:
                  h === 0 ? c = u : h === 1 ? c = 2 : c = 1;
                  break;
                case 7:
                  h === 0 ? c = u : c = u - 2 * h + 1;
                  break;
                default:
                  c = u;
                  break;
              }
              return c;
            }, getOnePixel: function(u, h, c, f) {
              var g = 0;
              switch (c) {
                case 0:
                  g = f.getInt8(h);
                  break;
                case 1:
                  g = f.getUint8(h);
                  break;
                case 2:
                  g = f.getInt16(h, true);
                  break;
                case 3:
                  g = f.getUint16(h, true);
                  break;
                case 4:
                  g = f.getInt32(h, true);
                  break;
                case 5:
                  g = f.getUInt32(h, true);
                  break;
                case 6:
                  g = f.getFloat32(h, true);
                  break;
                case 7:
                  g = f.getFloat64(h, true);
                  break;
                default:
                  throw "the decoder does not understand this pixel type";
              }
              return g;
            }, swapDimensionOrder: function(u, h, c, f, g) {
              var d = 0, A = 0, p = 0, v = 0, y = u;
              if (c > 1) if (y = new f(h * c), g) for (d = 0; d < h; d++) for (v = d, p = 0; p < c; p++, v += h) y[v] = u[A++];
              else for (d = 0; d < h; d++) for (v = d, p = 0; p < c; p++, v += h) y[A++] = u[v];
              return y;
            } }, s = function(u, h, c) {
              this.val = u, this.left = h, this.right = c;
            }, l = { decode: function(u, h) {
              h = h || {};
              var c = h.noDataValue, f = 0, g = {};
              if (g.ptr = h.inputOffset || 0, g.pixels = {}, !!o.readHeaderInfo(u, g)) {
                var d = g.headerInfo, A = d.fileVersion, p = o.getDataTypeArray(d.imageType);
                if (A > 5) throw "unsupported lerc version 2." + A;
                o.readMask(u, g), d.numValidPixel !== d.width * d.height && !g.pixels.resultMask && (g.pixels.resultMask = h.maskData);
                var v = d.width * d.height;
                g.pixels.resultPixels = new p(v * d.numDims), g.counter = { onesweep: 0, uncompressed: 0, lut: 0, bitstuffer: 0, constant: 0, constantoffset: 0 };
                var y = !h.returnPixelInterleavedDims;
                if (d.numValidPixel !== 0) if (d.zMax === d.zMin) o.constructConstantSurface(g, y);
                else if (A >= 4 && o.checkMinMaxRanges(u, g)) o.constructConstantSurface(g, y);
                else {
                  var m = new DataView(u, g.ptr, 2), _ = m.getUint8(0);
                  if (g.ptr++, _) o.readDataOneSweep(u, g, p, y);
                  else if (A > 1 && d.imageType <= 1 && Math.abs(d.maxZError - 0.5) < 1e-5) {
                    var I = m.getUint8(1);
                    if (g.ptr++, g.encodeMode = I, I > 2 || A < 4 && I > 1) throw "Invalid Huffman flag " + I;
                    I ? o.readHuffman(u, g, p, y) : o.readTiles(u, g, p, y);
                  } else o.readTiles(u, g, p, y);
                }
                g.eofOffset = g.ptr;
                var E;
                h.inputOffset ? (E = g.headerInfo.blobSize + h.inputOffset - g.ptr, Math.abs(E) >= 1 && (g.eofOffset = h.inputOffset + g.headerInfo.blobSize)) : (E = g.headerInfo.blobSize - g.ptr, Math.abs(E) >= 1 && (g.eofOffset = g.headerInfo.blobSize));
                var x = { width: d.width, height: d.height, pixelData: g.pixels.resultPixels, minValue: d.zMin, maxValue: d.zMax, validPixelCount: d.numValidPixel, dimCount: d.numDims, dimStats: { minValues: d.minValues, maxValues: d.maxValues }, maskData: g.pixels.resultMask };
                if (g.pixels.resultMask && o.isValidPixelValue(d.imageType, c)) {
                  var w = g.pixels.resultMask;
                  for (f = 0; f < v; f++) w[f] || (x.pixelData[f] = c);
                  x.noDataValue = c;
                }
                return g.noDataValue = c, h.returnFileInfo && (x.fileInfo = o.formatFileInfo(g)), x;
              }
            }, getBandCount: function(u) {
              var h = 0, c = 0, f = {};
              for (f.ptr = 0, f.pixels = {}; c < u.byteLength - 58; ) o.readHeaderInfo(u, f), c += f.headerInfo.blobSize, h++, f.ptr = c;
              return h;
            } };
            return l;
          }(), i = function() {
            var a = new ArrayBuffer(4), o = new Uint8Array(a), s = new Uint32Array(a);
            return s[0] = 1, o[0] === 1;
          }(), r = { decode: function(a, o) {
            if (!i) throw "Big endian system is not supported.";
            o = o || {};
            var s = o.inputOffset || 0, l = new Uint8Array(a, s, 10), u = String.fromCharCode.apply(null, l), h, c;
            if (u.trim() === "CntZImage") h = t, c = 1;
            else if (u.substring(0, 5) === "Lerc2") h = e, c = 2;
            else throw "Unexpected file identifier string: " + u;
            for (var f = 0, g = a.byteLength - 10, d, A = [], p, v, y = { width: 0, height: 0, pixels: [], pixelType: o.pixelType, mask: null, statistics: [] }, m = 0; s < g; ) {
              var _ = h.decode(a, { inputOffset: s, encodedMaskData: d, maskData: v, returnMask: f === 0, returnEncodedMask: f === 0, returnFileInfo: true, returnPixelInterleavedDims: o.returnPixelInterleavedDims, pixelType: o.pixelType || null, noDataValue: o.noDataValue || null });
              s = _.fileInfo.eofOffset, v = _.maskData, f === 0 && (d = _.encodedMaskData, y.width = _.width, y.height = _.height, y.dimCount = _.dimCount || 1, y.pixelType = _.pixelType || _.fileInfo.pixelType, y.mask = v), c > 1 && (v && A.push(v), _.fileInfo.mask && _.fileInfo.mask.numBytes > 0 && m++), f++, y.pixels.push(_.pixelData), y.statistics.push({ minValue: _.minValue, maxValue: _.maxValue, noDataValue: _.noDataValue, dimStats: _.dimStats });
            }
            var I, E, x;
            if (c > 1 && m > 1) {
              for (x = y.width * y.height, y.bandMasks = A, v = new Uint8Array(x), v.set(A[0]), I = 1; I < A.length; I++) for (p = A[I], E = 0; E < x; E++) v[E] = v[E] & p[E];
              y.maskData = v;
            }
            return y;
          } };
          n.exports ? n.exports = r : this.Lerc = r;
        })();
      })(mZ);
      var w5t = mZ.exports;
      const C5t = up(w5t);
      let Jy, fl, wP;
      const CP = { env: { emscripten_notify_memory_growth: function(n) {
        wP = new Uint8Array(fl.exports.memory.buffer);
      } } };
      class S5t {
        init() {
          return Jy || (typeof fetch != "undefined" ? Jy = fetch("data:application/wasm;base64," + _Z).then((t) => t.arrayBuffer()).then((t) => WebAssembly.instantiate(t, CP)).then(this._init) : Jy = WebAssembly.instantiate(Buffer.from(_Z, "base64"), CP).then(this._init), Jy);
        }
        _init(t) {
          fl = t.instance, CP.env.emscripten_notify_memory_growth(0);
        }
        decode(t, e = 0) {
          if (!fl) throw new Error("ZSTDDecoder: Await .init() before decoding.");
          const i = t.byteLength, r = fl.exports.malloc(i);
          wP.set(t, r), e = e || Number(fl.exports.ZSTD_findDecompressedSize(r, i));
          const a = fl.exports.malloc(e), o = fl.exports.ZSTD_decompress(a, e, r, i), s = wP.slice(a, a + o);
          return fl.exports.free(r), fl.exports.free(a), s;
        }
      }
      const _Z = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", EZ = new S5t();
      class b5t extends ah {
        constructor(t) {
          super(), this.planarConfiguration = typeof t.PlanarConfiguration != "undefined" ? t.PlanarConfiguration : 1, this.samplesPerPixel = typeof t.SamplesPerPixel != "undefined" ? t.SamplesPerPixel : 1, this.addCompression = t.LercParameters[Qut.AddCompression];
        }
        decodeBlock(t) {
          switch (this.addCompression) {
            case lS.None:
              break;
            case lS.Deflate:
              t = yZ(new Uint8Array(t)).buffer;
              break;
            case lS.Zstandard:
              t = EZ.decode(new Uint8Array(t)).buffer;
              break;
            default:
              throw new Error(`Unsupported LERC additional compression method identifier: ${this.addCompression}`);
          }
          return C5t.decode(t, { returnPixelInterleavedDims: this.planarConfiguration === 1 }).pixels[0].buffer;
        }
      }
      const T5t = Object.freeze(Object.defineProperty({ __proto__: null, default: b5t, zstd: EZ }, Symbol.toStringTag, { value: "Module" }));
      class B5t extends ah {
        constructor() {
          if (super(), typeof createImageBitmap == "undefined") throw new Error("Cannot decode WebImage as `createImageBitmap` is not available");
          if (typeof document == "undefined" && typeof OffscreenCanvas == "undefined") throw new Error("Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available");
        }
        decode(t, e) {
          return Tt(this, null, function* () {
            const i = new Blob([e]), r = yield createImageBitmap(i);
            let a;
            typeof document != "undefined" ? (a = document.createElement("canvas"), a.width = r.width, a.height = r.height) : a = new OffscreenCanvas(r.width, r.height);
            const o = a.getContext("2d");
            return o.drawImage(r, 0, 0), o.getImageData(0, 0, r.width, r.height).data.buffer;
          });
        }
      }
      const M5t = Object.freeze(Object.defineProperty({ __proto__: null, default: B5t }, Symbol.toStringTag, { value: "Module" })), D5t = Worker;
      function R5t() {
        const n = 'function A(A,e,t,i,r,I,g){try{var n=A[I](g),a=n.value}catch(A){return void t(A)}n.done?e(a):Promise.resolve(a).then(i,r)}function e(e){return function(){var t=this,i=arguments;return new Promise((function(r,I){var g=e.apply(t,i);function n(e){A(g,r,I,n,a,"next",e)}function a(e){A(g,r,I,n,a,"throw",e)}n(void 0)}))}}function t(A){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(A){return typeof A}:function(A){return A&&"function"==typeof Symbol&&A.constructor===Symbol&&A!==Symbol.prototype?"symbol":typeof A},t(A)}var i={exports:{}};!function(A){var e=function(A){var e,i=Object.prototype,r=i.hasOwnProperty,I="function"==typeof Symbol?Symbol:{},g=I.iterator||"@@iterator",n=I.asyncIterator||"@@asyncIterator",a=I.toStringTag||"@@toStringTag";function o(A,e,t){return Object.defineProperty(A,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),A[e]}try{o({},"")}catch(A){o=function(A,e,t){return A[e]=t}}function B(A,e,t,i){var r=e&&e.prototype instanceof h?e:h,I=Object.create(r.prototype),g=new S(i||[]);return I._invoke=function(A,e,t){var i=Q;return function(r,I){if(i===s)throw new Error("Generator is already running");if(i===f){if("throw"===r)throw I;return R()}for(t.method=r,t.arg=I;;){var g=t.delegate;if(g){var n=m(g,t);if(n){if(n===c)continue;return n}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if(i===Q)throw i=f,t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);i=s;var a=C(A,e,t);if("normal"===a.type){if(i=t.done?f:E,a.arg===c)continue;return{value:a.arg,done:t.done}}"throw"===a.type&&(i=f,t.method="throw",t.arg=a.arg)}}}(A,t,g),I}function C(A,e,t){try{return{type:"normal",arg:A.call(e,t)}}catch(A){return{type:"throw",arg:A}}}A.wrap=B;var Q="suspendedStart",E="suspendedYield",s="executing",f="completed",c={};function h(){}function l(){}function u(){}var w={};o(w,g,(function(){return this}));var d=Object.getPrototypeOf,D=d&&d(d(v([])));D&&D!==i&&r.call(D,g)&&(w=D);var y=u.prototype=h.prototype=Object.create(w);function k(A){["next","throw","return"].forEach((function(e){o(A,e,(function(A){return this._invoke(e,A)}))}))}function p(A,e){function i(I,g,n,a){var o=C(A[I],A,g);if("throw"!==o.type){var B=o.arg,Q=B.value;return Q&&"object"===t(Q)&&r.call(Q,"__await")?e.resolve(Q.__await).then((function(A){i("next",A,n,a)}),(function(A){i("throw",A,n,a)})):e.resolve(Q).then((function(A){B.value=A,n(B)}),(function(A){return i("throw",A,n,a)}))}a(o.arg)}var I;this._invoke=function(A,t){function r(){return new e((function(e,r){i(A,t,e,r)}))}return I=I?I.then(r,r):r()}}function m(A,t){var i=A.iterator[t.method];if(i===e){if(t.delegate=null,"throw"===t.method){if(A.iterator.return&&(t.method="return",t.arg=e,m(A,t),"throw"===t.method))return c;t.method="throw",t.arg=new TypeError("The iterator does not provide a \'throw\' method")}return c}var r=C(i,A.iterator,t.arg);if("throw"===r.type)return t.method="throw",t.arg=r.arg,t.delegate=null,c;var I=r.arg;return I?I.done?(t[A.resultName]=I.value,t.next=A.nextLoc,"return"!==t.method&&(t.method="next",t.arg=e),t.delegate=null,c):I:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,c)}function G(A){var e={tryLoc:A[0]};1 in A&&(e.catchLoc=A[1]),2 in A&&(e.finallyLoc=A[2],e.afterLoc=A[3]),this.tryEntries.push(e)}function F(A){var e=A.completion||{};e.type="normal",delete e.arg,A.completion=e}function S(A){this.tryEntries=[{tryLoc:"root"}],A.forEach(G,this),this.reset(!0)}function v(A){if(A){var t=A[g];if(t)return t.call(A);if("function"==typeof A.next)return A;if(!isNaN(A.length)){var i=-1,I=function t(){for(;++i<A.length;)if(r.call(A,i))return t.value=A[i],t.done=!1,t;return t.value=e,t.done=!0,t};return I.next=I}}return{next:R}}function R(){return{value:e,done:!0}}return l.prototype=u,o(y,"constructor",u),o(u,"constructor",l),l.displayName=o(u,a,"GeneratorFunction"),A.isGeneratorFunction=function(A){var e="function"==typeof A&&A.constructor;return!!e&&(e===l||"GeneratorFunction"===(e.displayName||e.name))},A.mark=function(A){return Object.setPrototypeOf?Object.setPrototypeOf(A,u):(A.__proto__=u,o(A,a,"GeneratorFunction")),A.prototype=Object.create(y),A},A.awrap=function(A){return{__await:A}},k(p.prototype),o(p.prototype,n,(function(){return this})),A.AsyncIterator=p,A.async=function(e,t,i,r,I){void 0===I&&(I=Promise);var g=new p(B(e,t,i,r),I);return A.isGeneratorFunction(t)?g:g.next().then((function(A){return A.done?A.value:g.next()}))},k(y),o(y,a,"Generator"),o(y,g,(function(){return this})),o(y,"toString",(function(){return"[object Generator]"})),A.keys=function(A){var e=[];for(var t in A)e.push(t);return e.reverse(),function t(){for(;e.length;){var i=e.pop();if(i in A)return t.value=i,t.done=!1,t}return t.done=!0,t}},A.values=v,S.prototype={constructor:S,reset:function(A){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(F),!A)for(var t in this)"t"===t.charAt(0)&&r.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=e)},stop:function(){this.done=!0;var A=this.tryEntries[0].completion;if("throw"===A.type)throw A.arg;return this.rval},dispatchException:function(A){if(this.done)throw A;var t=this;function i(i,r){return n.type="throw",n.arg=A,t.next=i,r&&(t.method="next",t.arg=e),!!r}for(var I=this.tryEntries.length-1;I>=0;--I){var g=this.tryEntries[I],n=g.completion;if("root"===g.tryLoc)return i("end");if(g.tryLoc<=this.prev){var a=r.call(g,"catchLoc"),o=r.call(g,"finallyLoc");if(a&&o){if(this.prev<g.catchLoc)return i(g.catchLoc,!0);if(this.prev<g.finallyLoc)return i(g.finallyLoc)}else if(a){if(this.prev<g.catchLoc)return i(g.catchLoc,!0)}else{if(!o)throw new Error("try statement without catch or finally");if(this.prev<g.finallyLoc)return i(g.finallyLoc)}}}},abrupt:function(A,e){for(var t=this.tryEntries.length-1;t>=0;--t){var i=this.tryEntries[t];if(i.tryLoc<=this.prev&&r.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var I=i;break}}I&&("break"===A||"continue"===A)&&I.tryLoc<=e&&e<=I.finallyLoc&&(I=null);var g=I?I.completion:{};return g.type=A,g.arg=e,I?(this.method="next",this.next=I.finallyLoc,c):this.complete(g)},complete:function(A,e){if("throw"===A.type)throw A.arg;return"break"===A.type||"continue"===A.type?this.next=A.arg:"return"===A.type?(this.rval=this.arg=A.arg,this.method="return",this.next="end"):"normal"===A.type&&e&&(this.next=e),c},finish:function(A){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===A)return this.complete(t.completion,t.afterLoc),F(t),c}},catch:function(A){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===A){var i=t.completion;if("throw"===i.type){var r=i.arg;F(t)}return r}}throw new Error("illegal catch attempt")},delegateYield:function(A,t,i){return this.delegate={iterator:v(A),resultName:t,nextLoc:i},"next"===this.method&&(this.arg=e),c}},A}(A.exports);try{regeneratorRuntime=e}catch(A){"object"===("undefined"==typeof globalThis?"undefined":t(globalThis))?globalThis.regeneratorRuntime=e:Function("r","regeneratorRuntime = r")(e)}}(i);var r=i.exports,I=new Map;function g(A,e){Array.isArray(A)||(A=[A]),A.forEach((function(A){return I.set(A,e)}))}function n(A){return a.apply(this,arguments)}function a(){return(a=e(r.mark((function A(e){var t,i;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:if(t=I.get(e.Compression)){A.next=3;break}throw new Error("Unknown compression method identifier: ".concat(e.Compression));case 3:return A.next=5,t();case 5:return i=A.sent,A.abrupt("return",new i(e));case 7:case"end":return A.stop()}}),A)})))).apply(this,arguments)}g([void 0,1],(function(){return Promise.resolve().then((function(){return y})).then((function(A){return A.default}))})),g(5,(function(){return Promise.resolve().then((function(){return F})).then((function(A){return A.default}))})),g(6,(function(){throw new Error("old style JPEG compression is not supported.")})),g(7,(function(){return Promise.resolve().then((function(){return N})).then((function(A){return A.default}))})),g([8,32946],(function(){return Promise.resolve().then((function(){return OA})).then((function(A){return A.default}))})),g(32773,(function(){return Promise.resolve().then((function(){return _A})).then((function(A){return A.default}))})),g(34887,(function(){return Promise.resolve().then((function(){return le})).then(function(){var A=e(r.mark((function A(e){return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return A.next=2,e.zstd.init();case 2:return A.abrupt("return",e);case 3:case"end":return A.stop()}}),A)})));return function(e){return A.apply(this,arguments)}}()).then((function(A){return A.default}))})),g(50001,(function(){return Promise.resolve().then((function(){return de})).then((function(A){return A.default}))}));var o=globalThis;function B(A,e){if(!(A instanceof e))throw new TypeError("Cannot call a class as a function")}function C(A,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(A,i.key,i)}}function Q(A,e,t){return e&&C(A.prototype,e),t&&C(A,t),A}function E(A,e){return E=Object.setPrototypeOf||function(A,e){return A.__proto__=e,A},E(A,e)}function s(A,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");A.prototype=Object.create(e&&e.prototype,{constructor:{value:A,writable:!0,configurable:!0}}),e&&E(A,e)}function f(A,e){if(e&&("object"===t(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(A){if(void 0===A)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return A}(A)}function c(A){return c=Object.setPrototypeOf?Object.getPrototypeOf:function(A){return A.__proto__||Object.getPrototypeOf(A)},c(A)}function h(A,e){var t=A.length-e,i=0;do{for(var r=e;r>0;r--)A[i+e]+=A[i],i++;t-=e}while(t>0)}function l(A,e,t){for(var i=0,r=A.length,I=r/t;r>e;){for(var g=e;g>0;--g)A[i+e]+=A[i],++i;r-=e}for(var n=A.slice(),a=0;a<I;++a)for(var o=0;o<t;++o)A[t*a+o]=n[(t-o-1)*I+a]}function u(A,e,t,i,r,I){if(!e||1===e)return A;for(var g=0;g<r.length;++g){if(r[g]%8!=0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(r[g]!==r[0])throw new Error("When decoding with predictor, all samples must have the same size.")}for(var n=r[0]/8,a=2===I?1:r.length,o=0;o<i&&!(o*a*t*n>=A.byteLength);++o){var B=void 0;if(2===e){switch(r[0]){case 8:B=new Uint8Array(A,o*a*t*n,a*t*n);break;case 16:B=new Uint16Array(A,o*a*t*n,a*t*n/2);break;case 32:B=new Uint32Array(A,o*a*t*n,a*t*n/4);break;default:throw new Error("Predictor 2 not allowed with ".concat(r[0]," bits per sample."))}h(B,a)}else 3===e&&l(B=new Uint8Array(A,o*a*t*n,a*t*n),a,n)}return A}o.addEventListener("message",function(){var A=e(r.mark((function A(e){var t,i,I,g,a,B;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return t=e.data,i=t.id,I=t.fileDirectory,g=t.buffer,A.next=3,n(I);case 3:return a=A.sent,A.next=6,a.decode(I,g);case 6:B=A.sent,o.postMessage({decoded:B,id:i},[B]);case 8:case"end":return A.stop()}}),A)})));return function(e){return A.apply(this,arguments)}}());var w=function(){function A(){B(this,A)}var t;return Q(A,[{key:"decode",value:(t=e(r.mark((function A(e,t){var i,I,g,n,a;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return A.next=2,this.decodeBlock(t);case 2:if(i=A.sent,1===(I=e.Predictor||1)){A.next=9;break}return g=!e.StripOffsets,n=g?e.TileWidth:e.ImageWidth,a=g?e.TileLength:e.RowsPerStrip||e.ImageLength,A.abrupt("return",u(i,I,n,a,e.BitsPerSample,e.PlanarConfiguration));case 9:return A.abrupt("return",i);case 10:case"end":return A.stop()}}),A,this)}))),function(A,e){return t.apply(this,arguments)})}]),A}();function d(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var D=function(A){s(t,w);var e=d(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:"decodeBlock",value:function(A){return A}}]),t}(),y=Object.freeze({__proto__:null,default:D});function k(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}function p(A,e){for(var t=e.length-1;t>=0;t--)A.push(e[t]);return A}function m(A){for(var e=new Uint16Array(4093),t=new Uint8Array(4093),i=0;i<=257;i++)e[i]=4096,t[i]=i;var r=258,I=9,g=0;function n(){r=258,I=9}function a(A){var e=function(A,e,t){var i=e%8,r=Math.floor(e/8),I=8-i,g=e+t-8*(r+1),n=8*(r+2)-(e+t),a=8*(r+2)-e;if(n=Math.max(0,n),r>=A.length)return console.warn("ran off the end of the buffer before finding EOI_CODE (end on input code)"),257;var o=A[r]&Math.pow(2,8-i)-1,B=o<<=t-I;if(r+1<A.length){var C=A[r+1]>>>n;B+=C<<=Math.max(0,t-a)}if(g>8&&r+2<A.length){var Q=8*(r+3)-(e+t);B+=A[r+2]>>>Q}return B}(A,g,I);return g+=I,e}function o(A,i){return t[r]=i,e[r]=A,++r-1}function B(A){for(var i=[],r=A;4096!==r;r=e[r])i.push(t[r]);return i}var C=[];n();for(var Q,E=new Uint8Array(A),s=a(E);257!==s;){if(256===s){for(n(),s=a(E);256===s;)s=a(E);if(257===s)break;if(s>256)throw new Error("corrupted code at scanline ".concat(s));p(C,B(s)),Q=s}else if(s<r){var f=B(s);p(C,f),o(Q,f[f.length-1]),Q=s}else{var c=B(Q);if(!c)throw new Error("Bogus entry. Not in dictionary, ".concat(Q," / ").concat(r,", position: ").concat(g));p(C,c),C.push(c[c.length-1]),o(Q,c[c.length-1]),Q=s}r+1>=Math.pow(2,I)&&(12===I?Q=void 0:I++),s=a(E)}return new Uint8Array(C)}var G=function(A){s(t,w);var e=k(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:"decodeBlock",value:function(A){return m(A).buffer}}]),t}(),F=Object.freeze({__proto__:null,default:G});function S(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var v=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]);function R(A,e){for(var t=0,i=[],r=16;r>0&&!A[r-1];)--r;i.push({children:[],index:0});for(var I,g=i[0],n=0;n<r;n++){for(var a=0;a<A[n];a++){for((g=i.pop()).children[g.index]=e[t];g.index>0;)g=i.pop();for(g.index++,i.push(g);i.length<=n;)i.push(I={children:[],index:0}),g.children[g.index]=I.children,g=I;t++}n+1<r&&(i.push(I={children:[],index:0}),g.children[g.index]=I.children,g=I)}return i[0].children}function U(A,e,i,r,I,g,n,a,o){var B=i.mcusPerLine,C=i.progressive,Q=e,E=e,s=0,f=0;function c(){if(f>0)return f--,s>>f&1;if(255===(s=A[E++])){var e=A[E++];if(e)throw new Error("unexpected marker: ".concat((s<<8|e).toString(16)))}return f=7,s>>>7}function h(A){for(var e,i=A;null!==(e=c());){if("number"==typeof(i=i[e]))return i;if("object"!==t(i))throw new Error("invalid huffman sequence")}return null}function l(A){for(var e=A,t=0;e>0;){var i=c();if(null===i)return;t=t<<1|i,--e}return t}function u(A){var e=l(A);return e>=1<<A-1?e:e+(-1<<A)+1}var w=0;var d,D=0;function y(A,e,t,i,r){var I=t%B,g=(t/B|0)*A.v+i,n=I*A.h+r;e(A,A.blocks[g][n])}function k(A,e,t){var i=t/A.blocksPerLine|0,r=t%A.blocksPerLine;e(A,A.blocks[i][r])}var p,m,G,F,S,R,U=r.length;R=C?0===g?0===a?function(A,e){var t=h(A.huffmanTableDC),i=0===t?0:u(t)<<o;A.pred+=i,e[0]=A.pred}:function(A,e){e[0]|=c()<<o}:0===a?function(A,e){if(w>0)w--;else for(var t=g,i=n;t<=i;){var r=h(A.huffmanTableAC),I=15&r,a=r>>4;if(0===I){if(a<15){w=l(a)+(1<<a)-1;break}t+=16}else e[v[t+=a]]=u(I)*(1<<o),t++}}:function(A,e){for(var t=g,i=n,r=0;t<=i;){var I=v[t],a=e[I]<0?-1:1;switch(D){case 0:var B=h(A.huffmanTableAC),C=15&B;if(r=B>>4,0===C)r<15?(w=l(r)+(1<<r),D=4):(r=16,D=1);else{if(1!==C)throw new Error("invalid ACn encoding");d=u(C),D=r?2:3}continue;case 1:case 2:e[I]?e[I]+=(c()<<o)*a:0==--r&&(D=2===D?3:0);break;case 3:e[I]?e[I]+=(c()<<o)*a:(e[I]=d<<o,D=0);break;case 4:e[I]&&(e[I]+=(c()<<o)*a)}t++}4===D&&0==--w&&(D=0)}:function(A,e){var t=h(A.huffmanTableDC),i=0===t?0:u(t);A.pred+=i,e[0]=A.pred;for(var r=1;r<64;){var I=h(A.huffmanTableAC),g=15&I,n=I>>4;if(0===g){if(n<15)break;r+=16}else e[v[r+=n]]=u(g),r++}};var L,b,M=0;b=1===U?r[0].blocksPerLine*r[0].blocksPerColumn:B*i.mcusPerColumn;for(var N=I||b;M<b;){for(m=0;m<U;m++)r[m].pred=0;if(w=0,1===U)for(p=r[0],S=0;S<N;S++)k(p,R,M),M++;else for(S=0;S<N;S++){for(m=0;m<U;m++){var x=p=r[m],J=x.h,q=x.v;for(G=0;G<q;G++)for(F=0;F<J;F++)y(p,R,M,G,F)}if(++M===b)break}if(f=0,(L=A[E]<<8|A[E+1])<65280)throw new Error("marker was not found");if(!(L>=65488&&L<=65495))break;E+=2}return E-Q}function L(A,e){var t=[],i=e.blocksPerLine,r=e.blocksPerColumn,I=i<<3,g=new Int32Array(64),n=new Uint8Array(64);function a(A,t,i){var r,I,g,n,a,o,B,C,Q,E,s=e.quantizationTable,f=i;for(E=0;E<64;E++)f[E]=A[E]*s[E];for(E=0;E<8;++E){var c=8*E;0!==f[1+c]||0!==f[2+c]||0!==f[3+c]||0!==f[4+c]||0!==f[5+c]||0!==f[6+c]||0!==f[7+c]?(r=5793*f[0+c]+128>>8,I=5793*f[4+c]+128>>8,g=f[2+c],n=f[6+c],a=2896*(f[1+c]-f[7+c])+128>>8,C=2896*(f[1+c]+f[7+c])+128>>8,o=f[3+c]<<4,Q=r-I+1>>1,r=r+I+1>>1,I=Q,Q=3784*g+1567*n+128>>8,g=1567*g-3784*n+128>>8,n=Q,Q=a-(B=f[5+c]<<4)+1>>1,a=a+B+1>>1,B=Q,Q=C+o+1>>1,o=C-o+1>>1,C=Q,Q=r-n+1>>1,r=r+n+1>>1,n=Q,Q=I-g+1>>1,I=I+g+1>>1,g=Q,Q=2276*a+3406*C+2048>>12,a=3406*a-2276*C+2048>>12,C=Q,Q=799*o+4017*B+2048>>12,o=4017*o-799*B+2048>>12,B=Q,f[0+c]=r+C,f[7+c]=r-C,f[1+c]=I+B,f[6+c]=I-B,f[2+c]=g+o,f[5+c]=g-o,f[3+c]=n+a,f[4+c]=n-a):(Q=5793*f[0+c]+512>>10,f[0+c]=Q,f[1+c]=Q,f[2+c]=Q,f[3+c]=Q,f[4+c]=Q,f[5+c]=Q,f[6+c]=Q,f[7+c]=Q)}for(E=0;E<8;++E){var h=E;0!==f[8+h]||0!==f[16+h]||0!==f[24+h]||0!==f[32+h]||0!==f[40+h]||0!==f[48+h]||0!==f[56+h]?(r=5793*f[0+h]+2048>>12,I=5793*f[32+h]+2048>>12,g=f[16+h],n=f[48+h],a=2896*(f[8+h]-f[56+h])+2048>>12,C=2896*(f[8+h]+f[56+h])+2048>>12,o=f[24+h],Q=r-I+1>>1,r=r+I+1>>1,I=Q,Q=3784*g+1567*n+2048>>12,g=1567*g-3784*n+2048>>12,n=Q,Q=a-(B=f[40+h])+1>>1,a=a+B+1>>1,B=Q,Q=C+o+1>>1,o=C-o+1>>1,C=Q,Q=r-n+1>>1,r=r+n+1>>1,n=Q,Q=I-g+1>>1,I=I+g+1>>1,g=Q,Q=2276*a+3406*C+2048>>12,a=3406*a-2276*C+2048>>12,C=Q,Q=799*o+4017*B+2048>>12,o=4017*o-799*B+2048>>12,B=Q,f[0+h]=r+C,f[56+h]=r-C,f[8+h]=I+B,f[48+h]=I-B,f[16+h]=g+o,f[40+h]=g-o,f[24+h]=n+a,f[32+h]=n-a):(Q=5793*i[E+0]+8192>>14,f[0+h]=Q,f[8+h]=Q,f[16+h]=Q,f[24+h]=Q,f[32+h]=Q,f[40+h]=Q,f[48+h]=Q,f[56+h]=Q)}for(E=0;E<64;++E){var l=128+(f[E]+8>>4);t[E]=l<0?0:l>255?255:l}}for(var o=0;o<r;o++){for(var B=o<<3,C=0;C<8;C++)t.push(new Uint8Array(I));for(var Q=0;Q<i;Q++){a(e.blocks[o][Q],n,g);for(var E=0,s=Q<<3,f=0;f<8;f++)for(var c=t[B+f],h=0;h<8;h++)c[s+h]=n[E++]}}return t}var b=function(){function A(){B(this,A),this.jfif=null,this.adobe=null,this.quantizationTables=[],this.huffmanTablesAC=[],this.huffmanTablesDC=[],this.resetFrames()}return Q(A,[{key:"resetFrames",value:function(){this.frames=[]}},{key:"parse",value:function(A){var e=0;function t(){var t=A[e]<<8|A[e+1];return e+=2,t}function i(A){var e,t,i=0,r=0;for(t in A.components)A.components.hasOwnProperty(t)&&(i<(e=A.components[t]).h&&(i=e.h),r<e.v&&(r=e.v));var I=Math.ceil(A.samplesPerLine/8/i),g=Math.ceil(A.scanLines/8/r);for(t in A.components)if(A.components.hasOwnProperty(t)){e=A.components[t];for(var n=Math.ceil(Math.ceil(A.samplesPerLine/8)*e.h/i),a=Math.ceil(Math.ceil(A.scanLines/8)*e.v/r),o=I*e.h,B=g*e.v,C=[],Q=0;Q<B;Q++){for(var E=[],s=0;s<o;s++)E.push(new Int32Array(64));C.push(E)}e.blocksPerLine=n,e.blocksPerColumn=a,e.blocks=C}A.maxH=i,A.maxV=r,A.mcusPerLine=I,A.mcusPerColumn=g}var r,I,g=t();if(65496!==g)throw new Error("SOI not found");for(g=t();65497!==g;){switch(g){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var n=(r=void 0,I=void 0,r=t(),I=A.subarray(e,e+r-2),e+=I.length,I);65504===g&&74===n[0]&&70===n[1]&&73===n[2]&&70===n[3]&&0===n[4]&&(this.jfif={version:{major:n[5],minor:n[6]},densityUnits:n[7],xDensity:n[8]<<8|n[9],yDensity:n[10]<<8|n[11],thumbWidth:n[12],thumbHeight:n[13],thumbData:n.subarray(14,14+3*n[12]*n[13])}),65518===g&&65===n[0]&&100===n[1]&&111===n[2]&&98===n[3]&&101===n[4]&&0===n[5]&&(this.adobe={version:n[6],flags0:n[7]<<8|n[8],flags1:n[9]<<8|n[10],transformCode:n[11]});break;case 65499:for(var a=t()+e-2;e<a;){var o=A[e++],B=new Int32Array(64);if(o>>4==0)for(var C=0;C<64;C++){B[v[C]]=A[e++]}else{if(o>>4!=1)throw new Error("DQT: invalid table spec");for(var Q=0;Q<64;Q++){B[v[Q]]=t()}}this.quantizationTables[15&o]=B}break;case 65472:case 65473:case 65474:t();for(var E={extended:65473===g,progressive:65474===g,precision:A[e++],scanLines:t(),samplesPerLine:t(),components:{},componentsOrder:[]},s=A[e++],f=void 0,c=0;c<s;c++){f=A[e];var h=A[e+1]>>4,l=15&A[e+1],u=A[e+2];E.componentsOrder.push(f),E.components[f]={h:h,v:l,quantizationIdx:u},e+=3}i(E),this.frames.push(E);break;case 65476:for(var w=t(),d=2;d<w;){for(var D=A[e++],y=new Uint8Array(16),k=0,p=0;p<16;p++,e++)y[p]=A[e],k+=y[p];for(var m=new Uint8Array(k),G=0;G<k;G++,e++)m[G]=A[e];d+=17+k,D>>4==0?this.huffmanTablesDC[15&D]=R(y,m):this.huffmanTablesAC[15&D]=R(y,m)}break;case 65501:t(),this.resetInterval=t();break;case 65498:t();for(var F=A[e++],S=[],L=this.frames[0],b=0;b<F;b++){var M=L.components[A[e++]],N=A[e++];M.huffmanTableDC=this.huffmanTablesDC[N>>4],M.huffmanTableAC=this.huffmanTablesAC[15&N],S.push(M)}var x=A[e++],J=A[e++],q=A[e++],Y=U(A,e,L,S,this.resetInterval,x,J,q>>4,15&q);e+=Y;break;case 65535:255!==A[e]&&e--;break;default:if(255===A[e-3]&&A[e-2]>=192&&A[e-2]<=254){e-=3;break}throw new Error("unknown JPEG marker ".concat(g.toString(16)))}g=t()}}},{key:"getResult",value:function(){var A=this.frames;if(0===this.frames.length)throw new Error("no frames were decoded");this.frames.length>1&&console.warn("more than one frame is not supported");for(var e=0;e<this.frames.length;e++)for(var t=this.frames[e].components,i=0,r=Object.keys(t);i<r.length;i++){var I=r[i];t[I].quantizationTable=this.quantizationTables[t[I].quantizationIdx],delete t[I].quantizationIdx}for(var g=A[0],n=g.components,a=g.componentsOrder,o=[],B=g.samplesPerLine,C=g.scanLines,Q=0;Q<a.length;Q++){var E=n[a[Q]];o.push({lines:L(0,E),scaleX:E.h/g.maxH,scaleY:E.v/g.maxV})}for(var s=new Uint8Array(B*C*o.length),f=0,c=0;c<C;++c)for(var h=0;h<B;++h)for(var l=0;l<o.length;++l){var u=o[l];s[f]=u.lines[0|c*u.scaleY][0|h*u.scaleX],++f}return s}}]),A}(),M=function(A){s(t,w);var e=S(t);function t(A){var i;return B(this,t),(i=e.call(this)).reader=new b,A.JPEGTables&&i.reader.parse(A.JPEGTables),i}return Q(t,[{key:"decodeBlock",value:function(A){return this.reader.resetFrames(),this.reader.parse(new Uint8Array(A)),this.reader.getResult().buffer}}]),t}(),N=Object.freeze({__proto__:null,default:M});function x(A){for(var e=A.length;--e>=0;)A[e]=0}x(new Array(576)),x(new Array(60)),x(new Array(512)),x(new Array(256)),x(new Array(29)),x(new Array(30));var J=function(A,e,t,i){for(var r=65535&A|0,I=A>>>16&65535|0,g=0;0!==t;){t-=g=t>2e3?2e3:t;do{I=I+(r=r+e[i++]|0)|0}while(--g);r%=65521,I%=65521}return r|I<<16|0},q=new Uint32Array(function(){for(var A,e=[],t=0;t<256;t++){A=t;for(var i=0;i<8;i++)A=1&A?3988292384^A>>>1:A>>>1;e[t]=A}return e}()),Y=function(A,e,t,i){var r=q,I=i+t;A^=-1;for(var g=i;g<I;g++)A=A>>>8^r[255&(A^e[g])];return-1^A},K={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},H={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},O=function(A,e){return Object.prototype.hasOwnProperty.call(A,e)},P=function(A){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var i=e.shift();if(i){if("object"!==t(i))throw new TypeError(i+"must be non-object");for(var r in i)O(i,r)&&(A[r]=i[r])}}return A},T=function(A){for(var e=0,t=0,i=A.length;t<i;t++)e+=A[t].length;for(var r=new Uint8Array(e),I=0,g=0,n=A.length;I<n;I++){var a=A[I];r.set(a,g),g+=a.length}return r},V=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(A){V=!1}for(var _=new Uint8Array(256),X=0;X<256;X++)_[X]=X>=252?6:X>=248?5:X>=240?4:X>=224?3:X>=192?2:1;_[254]=_[254]=1;var Z=function(A){if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(A);var e,t,i,r,I,g=A.length,n=0;for(r=0;r<g;r++)55296==(64512&(t=A.charCodeAt(r)))&&r+1<g&&56320==(64512&(i=A.charCodeAt(r+1)))&&(t=65536+(t-55296<<10)+(i-56320),r++),n+=t<128?1:t<2048?2:t<65536?3:4;for(e=new Uint8Array(n),I=0,r=0;I<n;r++)55296==(64512&(t=A.charCodeAt(r)))&&r+1<g&&56320==(64512&(i=A.charCodeAt(r+1)))&&(t=65536+(t-55296<<10)+(i-56320),r++),t<128?e[I++]=t:t<2048?(e[I++]=192|t>>>6,e[I++]=128|63&t):t<65536?(e[I++]=224|t>>>12,e[I++]=128|t>>>6&63,e[I++]=128|63&t):(e[I++]=240|t>>>18,e[I++]=128|t>>>12&63,e[I++]=128|t>>>6&63,e[I++]=128|63&t);return e},j=function(A,e){var t,i,r=e||A.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(A.subarray(0,e));var I=new Array(2*r);for(i=0,t=0;t<r;){var g=A[t++];if(g<128)I[i++]=g;else{var n=_[g];if(n>4)I[i++]=65533,t+=n-1;else{for(g&=2===n?31:3===n?15:7;n>1&&t<r;)g=g<<6|63&A[t++],n--;n>1?I[i++]=65533:g<65536?I[i++]=g:(g-=65536,I[i++]=55296|g>>10&1023,I[i++]=56320|1023&g)}}}return function(A,e){if(e<65534&&A.subarray&&V)return String.fromCharCode.apply(null,A.length===e?A:A.subarray(0,e));for(var t="",i=0;i<e;i++)t+=String.fromCharCode(A[i]);return t}(I,i)},W=function(A,e){(e=e||A.length)>A.length&&(e=A.length);for(var t=e-1;t>=0&&128==(192&A[t]);)t--;return t<0||0===t?e:t+_[A[t]]>e?t:e};var z=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},$=function(A,e){var t,i,r,I,g,n,a,o,B,C,Q,E,s,f,c,h,l,u,w,d,D,y,k,p,m=A.state;t=A.next_in,k=A.input,i=t+(A.avail_in-5),r=A.next_out,p=A.output,I=r-(e-A.avail_out),g=r+(A.avail_out-257),n=m.dmax,a=m.wsize,o=m.whave,B=m.wnext,C=m.window,Q=m.hold,E=m.bits,s=m.lencode,f=m.distcode,c=(1<<m.lenbits)-1,h=(1<<m.distbits)-1;A:do{E<15&&(Q+=k[t++]<<E,E+=8,Q+=k[t++]<<E,E+=8),l=s[Q&c];e:for(;;){if(Q>>>=u=l>>>24,E-=u,0===(u=l>>>16&255))p[r++]=65535&l;else{if(!(16&u)){if(0==(64&u)){l=s[(65535&l)+(Q&(1<<u)-1)];continue e}if(32&u){m.mode=12;break A}A.msg="invalid literal/length code",m.mode=30;break A}w=65535&l,(u&=15)&&(E<u&&(Q+=k[t++]<<E,E+=8),w+=Q&(1<<u)-1,Q>>>=u,E-=u),E<15&&(Q+=k[t++]<<E,E+=8,Q+=k[t++]<<E,E+=8),l=f[Q&h];t:for(;;){if(Q>>>=u=l>>>24,E-=u,!(16&(u=l>>>16&255))){if(0==(64&u)){l=f[(65535&l)+(Q&(1<<u)-1)];continue t}A.msg="invalid distance code",m.mode=30;break A}if(d=65535&l,E<(u&=15)&&(Q+=k[t++]<<E,(E+=8)<u&&(Q+=k[t++]<<E,E+=8)),(d+=Q&(1<<u)-1)>n){A.msg="invalid distance too far back",m.mode=30;break A}if(Q>>>=u,E-=u,d>(u=r-I)){if((u=d-u)>o&&m.sane){A.msg="invalid distance too far back",m.mode=30;break A}if(D=0,y=C,0===B){if(D+=a-u,u<w){w-=u;do{p[r++]=C[D++]}while(--u);D=r-d,y=p}}else if(B<u){if(D+=a+B-u,(u-=B)<w){w-=u;do{p[r++]=C[D++]}while(--u);if(D=0,B<w){w-=u=B;do{p[r++]=C[D++]}while(--u);D=r-d,y=p}}}else if(D+=B-u,u<w){w-=u;do{p[r++]=C[D++]}while(--u);D=r-d,y=p}for(;w>2;)p[r++]=y[D++],p[r++]=y[D++],p[r++]=y[D++],w-=3;w&&(p[r++]=y[D++],w>1&&(p[r++]=y[D++]))}else{D=r-d;do{p[r++]=p[D++],p[r++]=p[D++],p[r++]=p[D++],w-=3}while(w>2);w&&(p[r++]=p[D++],w>1&&(p[r++]=p[D++]))}break}}break}}while(t<i&&r<g);t-=w=E>>3,Q&=(1<<(E-=w<<3))-1,A.next_in=t,A.next_out=r,A.avail_in=t<i?i-t+5:5-(t-i),A.avail_out=r<g?g-r+257:257-(r-g),m.hold=Q,m.bits=E},AA=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),eA=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),tA=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),iA=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),rA=function(A,e,t,i,r,I,g,n){var a,o,B,C,Q,E,s,f,c,h=n.bits,l=0,u=0,w=0,d=0,D=0,y=0,k=0,p=0,m=0,G=0,F=null,S=0,v=new Uint16Array(16),R=new Uint16Array(16),U=null,L=0;for(l=0;l<=15;l++)v[l]=0;for(u=0;u<i;u++)v[e[t+u]]++;for(D=h,d=15;d>=1&&0===v[d];d--);if(D>d&&(D=d),0===d)return r[I++]=20971520,r[I++]=20971520,n.bits=1,0;for(w=1;w<d&&0===v[w];w++);for(D<w&&(D=w),p=1,l=1;l<=15;l++)if(p<<=1,(p-=v[l])<0)return-1;if(p>0&&(0===A||1!==d))return-1;for(R[1]=0,l=1;l<15;l++)R[l+1]=R[l]+v[l];for(u=0;u<i;u++)0!==e[t+u]&&(g[R[e[t+u]]++]=u);if(0===A?(F=U=g,E=19):1===A?(F=AA,S-=257,U=eA,L-=257,E=256):(F=tA,U=iA,E=-1),G=0,u=0,l=w,Q=I,y=D,k=0,B=-1,C=(m=1<<D)-1,1===A&&m>852||2===A&&m>592)return 1;for(;;){s=l-k,g[u]<E?(f=0,c=g[u]):g[u]>E?(f=U[L+g[u]],c=F[S+g[u]]):(f=96,c=0),a=1<<l-k,w=o=1<<y;do{r[Q+(G>>k)+(o-=a)]=s<<24|f<<16|c|0}while(0!==o);for(a=1<<l-1;G&a;)a>>=1;if(0!==a?(G&=a-1,G+=a):G=0,u++,0==--v[l]){if(l===d)break;l=e[t+g[u]]}if(l>D&&(G&C)!==B){for(0===k&&(k=D),Q+=w,p=1<<(y=l-k);y+k<d&&!((p-=v[y+k])<=0);)y++,p<<=1;if(m+=1<<y,1===A&&m>852||2===A&&m>592)return 1;r[B=G&C]=D<<24|y<<16|Q-I|0}}return 0!==G&&(r[Q+G]=l-k<<24|64<<16|0),n.bits=D,0},IA=H.Z_FINISH,gA=H.Z_BLOCK,nA=H.Z_TREES,aA=H.Z_OK,oA=H.Z_STREAM_END,BA=H.Z_NEED_DICT,CA=H.Z_STREAM_ERROR,QA=H.Z_DATA_ERROR,EA=H.Z_MEM_ERROR,sA=H.Z_BUF_ERROR,fA=H.Z_DEFLATED,cA=function(A){return(A>>>24&255)+(A>>>8&65280)+((65280&A)<<8)+((255&A)<<24)};function hA(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}var lA,uA,wA=function(A){if(!A||!A.state)return CA;var e=A.state;return A.total_in=A.total_out=e.total=0,A.msg="",e.wrap&&(A.adler=1&e.wrap),e.mode=1,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new Int32Array(852),e.distcode=e.distdyn=new Int32Array(592),e.sane=1,e.back=-1,aA},dA=function(A){if(!A||!A.state)return CA;var e=A.state;return e.wsize=0,e.whave=0,e.wnext=0,wA(A)},DA=function(A,e){var t;if(!A||!A.state)return CA;var i=A.state;return e<0?(t=0,e=-e):(t=1+(e>>4),e<48&&(e&=15)),e&&(e<8||e>15)?CA:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=t,i.wbits=e,dA(A))},yA=function(A,e){if(!A)return CA;var t=new hA;A.state=t,t.window=null;var i=DA(A,e);return i!==aA&&(A.state=null),i},kA=!0,pA=function(A){if(kA){lA=new Int32Array(512),uA=new Int32Array(32);for(var e=0;e<144;)A.lens[e++]=8;for(;e<256;)A.lens[e++]=9;for(;e<280;)A.lens[e++]=7;for(;e<288;)A.lens[e++]=8;for(rA(1,A.lens,0,288,lA,0,A.work,{bits:9}),e=0;e<32;)A.lens[e++]=5;rA(2,A.lens,0,32,uA,0,A.work,{bits:5}),kA=!1}A.lencode=lA,A.lenbits=9,A.distcode=uA,A.distbits=5},mA=function(A,e,t,i){var r,I=A.state;return null===I.window&&(I.wsize=1<<I.wbits,I.wnext=0,I.whave=0,I.window=new Uint8Array(I.wsize)),i>=I.wsize?(I.window.set(e.subarray(t-I.wsize,t),0),I.wnext=0,I.whave=I.wsize):((r=I.wsize-I.wnext)>i&&(r=i),I.window.set(e.subarray(t-i,t-i+r),I.wnext),(i-=r)?(I.window.set(e.subarray(t-i,t),0),I.wnext=i,I.whave=I.wsize):(I.wnext+=r,I.wnext===I.wsize&&(I.wnext=0),I.whave<I.wsize&&(I.whave+=r))),0},GA={inflateReset:dA,inflateReset2:DA,inflateResetKeep:wA,inflateInit:function(A){return yA(A,15)},inflateInit2:yA,inflate:function(A,e){var t,i,r,I,g,n,a,o,B,C,Q,E,s,f,c,h,l,u,w,d,D,y,k,p,m=0,G=new Uint8Array(4),F=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!A||!A.state||!A.output||!A.input&&0!==A.avail_in)return CA;12===(t=A.state).mode&&(t.mode=13),g=A.next_out,r=A.output,a=A.avail_out,I=A.next_in,i=A.input,n=A.avail_in,o=t.hold,B=t.bits,C=n,Q=a,y=aA;A:for(;;)switch(t.mode){case 1:if(0===t.wrap){t.mode=13;break}for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(2&t.wrap&&35615===o){t.check=0,G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0),o=0,B=0,t.mode=2;break}if(t.flags=0,t.head&&(t.head.done=!1),!(1&t.wrap)||(((255&o)<<8)+(o>>8))%31){A.msg="incorrect header check",t.mode=30;break}if((15&o)!==fA){A.msg="unknown compression method",t.mode=30;break}if(B-=4,D=8+(15&(o>>>=4)),0===t.wbits)t.wbits=D;else if(D>t.wbits){A.msg="invalid window size",t.mode=30;break}t.dmax=1<<t.wbits,A.adler=t.check=1,t.mode=512&o?10:12,o=0,B=0;break;case 2:for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(t.flags=o,(255&t.flags)!==fA){A.msg="unknown compression method",t.mode=30;break}if(57344&t.flags){A.msg="unknown header flags set",t.mode=30;break}t.head&&(t.head.text=o>>8&1),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0)),o=0,B=0,t.mode=3;case 3:for(;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.head&&(t.head.time=o),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,G[2]=o>>>16&255,G[3]=o>>>24&255,t.check=Y(t.check,G,4,0)),o=0,B=0,t.mode=4;case 4:for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.head&&(t.head.xflags=255&o,t.head.os=o>>8),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0)),o=0,B=0,t.mode=5;case 5:if(1024&t.flags){for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.length=o,t.head&&(t.head.extra_len=o),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0)),o=0,B=0}else t.head&&(t.head.extra=null);t.mode=6;case 6:if(1024&t.flags&&((E=t.length)>n&&(E=n),E&&(t.head&&(D=t.head.extra_len-t.length,t.head.extra||(t.head.extra=new Uint8Array(t.head.extra_len)),t.head.extra.set(i.subarray(I,I+E),D)),512&t.flags&&(t.check=Y(t.check,i,E,I)),n-=E,I+=E,t.length-=E),t.length))break A;t.length=0,t.mode=7;case 7:if(2048&t.flags){if(0===n)break A;E=0;do{D=i[I+E++],t.head&&D&&t.length<65536&&(t.head.name+=String.fromCharCode(D))}while(D&&E<n);if(512&t.flags&&(t.check=Y(t.check,i,E,I)),n-=E,I+=E,D)break A}else t.head&&(t.head.name=null);t.length=0,t.mode=8;case 8:if(4096&t.flags){if(0===n)break A;E=0;do{D=i[I+E++],t.head&&D&&t.length<65536&&(t.head.comment+=String.fromCharCode(D))}while(D&&E<n);if(512&t.flags&&(t.check=Y(t.check,i,E,I)),n-=E,I+=E,D)break A}else t.head&&(t.head.comment=null);t.mode=9;case 9:if(512&t.flags){for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(o!==(65535&t.check)){A.msg="header crc mismatch",t.mode=30;break}o=0,B=0}t.head&&(t.head.hcrc=t.flags>>9&1,t.head.done=!0),A.adler=t.check=0,t.mode=12;break;case 10:for(;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}A.adler=t.check=cA(o),o=0,B=0,t.mode=11;case 11:if(0===t.havedict)return A.next_out=g,A.avail_out=a,A.next_in=I,A.avail_in=n,t.hold=o,t.bits=B,BA;A.adler=t.check=1,t.mode=12;case 12:if(e===gA||e===nA)break A;case 13:if(t.last){o>>>=7&B,B-=7&B,t.mode=27;break}for(;B<3;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}switch(t.last=1&o,B-=1,3&(o>>>=1)){case 0:t.mode=14;break;case 1:if(pA(t),t.mode=20,e===nA){o>>>=2,B-=2;break A}break;case 2:t.mode=17;break;case 3:A.msg="invalid block type",t.mode=30}o>>>=2,B-=2;break;case 14:for(o>>>=7&B,B-=7&B;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if((65535&o)!=(o>>>16^65535)){A.msg="invalid stored block lengths",t.mode=30;break}if(t.length=65535&o,o=0,B=0,t.mode=15,e===nA)break A;case 15:t.mode=16;case 16:if(E=t.length){if(E>n&&(E=n),E>a&&(E=a),0===E)break A;r.set(i.subarray(I,I+E),g),n-=E,I+=E,a-=E,g+=E,t.length-=E;break}t.mode=12;break;case 17:for(;B<14;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(t.nlen=257+(31&o),o>>>=5,B-=5,t.ndist=1+(31&o),o>>>=5,B-=5,t.ncode=4+(15&o),o>>>=4,B-=4,t.nlen>286||t.ndist>30){A.msg="too many length or distance symbols",t.mode=30;break}t.have=0,t.mode=18;case 18:for(;t.have<t.ncode;){for(;B<3;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.lens[F[t.have++]]=7&o,o>>>=3,B-=3}for(;t.have<19;)t.lens[F[t.have++]]=0;if(t.lencode=t.lendyn,t.lenbits=7,k={bits:t.lenbits},y=rA(0,t.lens,0,19,t.lencode,0,t.work,k),t.lenbits=k.bits,y){A.msg="invalid code lengths set",t.mode=30;break}t.have=0,t.mode=19;case 19:for(;t.have<t.nlen+t.ndist;){for(;h=(m=t.lencode[o&(1<<t.lenbits)-1])>>>16&255,l=65535&m,!((c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(l<16)o>>>=c,B-=c,t.lens[t.have++]=l;else{if(16===l){for(p=c+2;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(o>>>=c,B-=c,0===t.have){A.msg="invalid bit length repeat",t.mode=30;break}D=t.lens[t.have-1],E=3+(3&o),o>>>=2,B-=2}else if(17===l){for(p=c+3;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}B-=c,D=0,E=3+(7&(o>>>=c)),o>>>=3,B-=3}else{for(p=c+7;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}B-=c,D=0,E=11+(127&(o>>>=c)),o>>>=7,B-=7}if(t.have+E>t.nlen+t.ndist){A.msg="invalid bit length repeat",t.mode=30;break}for(;E--;)t.lens[t.have++]=D}}if(30===t.mode)break;if(0===t.lens[256]){A.msg="invalid code -- missing end-of-block",t.mode=30;break}if(t.lenbits=9,k={bits:t.lenbits},y=rA(1,t.lens,0,t.nlen,t.lencode,0,t.work,k),t.lenbits=k.bits,y){A.msg="invalid literal/lengths set",t.mode=30;break}if(t.distbits=6,t.distcode=t.distdyn,k={bits:t.distbits},y=rA(2,t.lens,t.nlen,t.ndist,t.distcode,0,t.work,k),t.distbits=k.bits,y){A.msg="invalid distances set",t.mode=30;break}if(t.mode=20,e===nA)break A;case 20:t.mode=21;case 21:if(n>=6&&a>=258){A.next_out=g,A.avail_out=a,A.next_in=I,A.avail_in=n,t.hold=o,t.bits=B,$(A,Q),g=A.next_out,r=A.output,a=A.avail_out,I=A.next_in,i=A.input,n=A.avail_in,o=t.hold,B=t.bits,12===t.mode&&(t.back=-1);break}for(t.back=0;h=(m=t.lencode[o&(1<<t.lenbits)-1])>>>16&255,l=65535&m,!((c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(h&&0==(240&h)){for(u=c,w=h,d=l;h=(m=t.lencode[d+((o&(1<<u+w)-1)>>u)])>>>16&255,l=65535&m,!(u+(c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}o>>>=u,B-=u,t.back+=u}if(o>>>=c,B-=c,t.back+=c,t.length=l,0===h){t.mode=26;break}if(32&h){t.back=-1,t.mode=12;break}if(64&h){A.msg="invalid literal/length code",t.mode=30;break}t.extra=15&h,t.mode=22;case 22:if(t.extra){for(p=t.extra;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.length+=o&(1<<t.extra)-1,o>>>=t.extra,B-=t.extra,t.back+=t.extra}t.was=t.length,t.mode=23;case 23:for(;h=(m=t.distcode[o&(1<<t.distbits)-1])>>>16&255,l=65535&m,!((c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(0==(240&h)){for(u=c,w=h,d=l;h=(m=t.distcode[d+((o&(1<<u+w)-1)>>u)])>>>16&255,l=65535&m,!(u+(c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}o>>>=u,B-=u,t.back+=u}if(o>>>=c,B-=c,t.back+=c,64&h){A.msg="invalid distance code",t.mode=30;break}t.offset=l,t.extra=15&h,t.mode=24;case 24:if(t.extra){for(p=t.extra;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.offset+=o&(1<<t.extra)-1,o>>>=t.extra,B-=t.extra,t.back+=t.extra}if(t.offset>t.dmax){A.msg="invalid distance too far back",t.mode=30;break}t.mode=25;case 25:if(0===a)break A;if(E=Q-a,t.offset>E){if((E=t.offset-E)>t.whave&&t.sane){A.msg="invalid distance too far back",t.mode=30;break}E>t.wnext?(E-=t.wnext,s=t.wsize-E):s=t.wnext-E,E>t.length&&(E=t.length),f=t.window}else f=r,s=g-t.offset,E=t.length;E>a&&(E=a),a-=E,t.length-=E;do{r[g++]=f[s++]}while(--E);0===t.length&&(t.mode=21);break;case 26:if(0===a)break A;r[g++]=t.length,a--,t.mode=21;break;case 27:if(t.wrap){for(;B<32;){if(0===n)break A;n--,o|=i[I++]<<B,B+=8}if(Q-=a,A.total_out+=Q,t.total+=Q,Q&&(A.adler=t.check=t.flags?Y(t.check,r,Q,g-Q):J(t.check,r,Q,g-Q)),Q=a,(t.flags?o:cA(o))!==t.check){A.msg="incorrect data check",t.mode=30;break}o=0,B=0}t.mode=28;case 28:if(t.wrap&&t.flags){for(;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(o!==(4294967295&t.total)){A.msg="incorrect length check",t.mode=30;break}o=0,B=0}t.mode=29;case 29:y=oA;break A;case 30:y=QA;break A;case 31:return EA;default:return CA}return A.next_out=g,A.avail_out=a,A.next_in=I,A.avail_in=n,t.hold=o,t.bits=B,(t.wsize||Q!==A.avail_out&&t.mode<30&&(t.mode<27||e!==IA))&&mA(A,A.output,A.next_out,Q-A.avail_out),C-=A.avail_in,Q-=A.avail_out,A.total_in+=C,A.total_out+=Q,t.total+=Q,t.wrap&&Q&&(A.adler=t.check=t.flags?Y(t.check,r,Q,A.next_out-Q):J(t.check,r,Q,A.next_out-Q)),A.data_type=t.bits+(t.last?64:0)+(12===t.mode?128:0)+(20===t.mode||15===t.mode?256:0),(0===C&&0===Q||e===IA)&&y===aA&&(y=sA),y},inflateEnd:function(A){if(!A||!A.state)return CA;var e=A.state;return e.window&&(e.window=null),A.state=null,aA},inflateGetHeader:function(A,e){if(!A||!A.state)return CA;var t=A.state;return 0==(2&t.wrap)?CA:(t.head=e,e.done=!1,aA)},inflateSetDictionary:function(A,e){var t,i=e.length;return A&&A.state?0!==(t=A.state).wrap&&11!==t.mode?CA:11===t.mode&&J(1,e,i,0)!==t.check?QA:mA(A,e,i,i)?(t.mode=31,EA):(t.havedict=1,aA):CA},inflateInfo:"pako inflate (from Nodeca project)"};var FA=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},SA=Object.prototype.toString,vA=H.Z_NO_FLUSH,RA=H.Z_FINISH,UA=H.Z_OK,LA=H.Z_STREAM_END,bA=H.Z_NEED_DICT,MA=H.Z_STREAM_ERROR,NA=H.Z_DATA_ERROR,xA=H.Z_MEM_ERROR;function JA(A){this.options=P({chunkSize:65536,windowBits:15,to:""},A||{});var e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||A&&A.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new z,this.strm.avail_out=0;var t=GA.inflateInit2(this.strm,e.windowBits);if(t!==UA)throw new Error(K[t]);if(this.header=new FA,GA.inflateGetHeader(this.strm,this.header),e.dictionary&&("string"==typeof e.dictionary?e.dictionary=Z(e.dictionary):"[object ArrayBuffer]"===SA.call(e.dictionary)&&(e.dictionary=new Uint8Array(e.dictionary)),e.raw&&(t=GA.inflateSetDictionary(this.strm,e.dictionary))!==UA))throw new Error(K[t])}function qA(A,e){var t=new JA(e);if(t.push(A),t.err)throw t.msg||K[t.err];return t.result}JA.prototype.push=function(A,e){var t,i,r,I=this.strm,g=this.options.chunkSize,n=this.options.dictionary;if(this.ended)return!1;for(i=e===~~e?e:!0===e?RA:vA,"[object ArrayBuffer]"===SA.call(A)?I.input=new Uint8Array(A):I.input=A,I.next_in=0,I.avail_in=I.input.length;;){for(0===I.avail_out&&(I.output=new Uint8Array(g),I.next_out=0,I.avail_out=g),(t=GA.inflate(I,i))===bA&&n&&((t=GA.inflateSetDictionary(I,n))===UA?t=GA.inflate(I,i):t===NA&&(t=bA));I.avail_in>0&&t===LA&&I.state.wrap>0&&0!==A[I.next_in];)GA.inflateReset(I),t=GA.inflate(I,i);switch(t){case MA:case NA:case bA:case xA:return this.onEnd(t),this.ended=!0,!1}if(r=I.avail_out,I.next_out&&(0===I.avail_out||t===LA))if("string"===this.options.to){var a=W(I.output,I.next_out),o=I.next_out-a,B=j(I.output,a);I.next_out=o,I.avail_out=g-o,o&&I.output.set(I.output.subarray(a,a+o),0),this.onData(B)}else this.onData(I.output.length===I.next_out?I.output:I.output.subarray(0,I.next_out));if(t!==UA||0!==r){if(t===LA)return t=GA.inflateEnd(this.strm),this.onEnd(t),this.ended=!0,!0;if(0===I.avail_in)break}}return!0},JA.prototype.onData=function(A){this.chunks.push(A)},JA.prototype.onEnd=function(A){A===UA&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=T(this.chunks)),this.chunks=[],this.err=A,this.msg=this.strm.msg};var YA={Inflate:JA,inflate:qA,inflateRaw:function(A,e){return(e=e||{}).raw=!0,qA(A,e)},ungzip:qA,constants:H}.inflate;function KA(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var HA=function(A){s(t,w);var e=KA(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:"decodeBlock",value:function(A){return YA(new Uint8Array(A)).buffer}}]),t}(),OA=Object.freeze({__proto__:null,default:HA});function PA(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var TA,VA=function(A){s(t,w);var e=PA(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:"decodeBlock",value:function(A){for(var e=new DataView(A),t=[],i=0;i<A.byteLength;++i){var r=e.getInt8(i);if(r<0){var I=e.getUint8(i+1);r=-r;for(var g=0;g<=r;++g)t.push(I);i+=1}else{for(var n=0;n<=r;++n)t.push(e.getUint8(i+n+1));i+=r+1}}return new Uint8Array(t).buffer}}]),t}(),_A=Object.freeze({__proto__:null,default:VA}),XA={exports:{}};TA=XA,\n/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\nfunction(){var A,e,t,i,r,I,g,n,a,o,B,C,Q,E,s,f,c=(A={defaultNoDataValue:-34027999387901484e22,decode:function(I,g){var n=(g=g||{}).encodedMaskData||null===g.encodedMaskData,a=r(I,g.inputOffset||0,n),o=null!==g.noDataValue?g.noDataValue:A.defaultNoDataValue,B=e(a,g.pixelType||Float32Array,g.encodedMaskData,o,g.returnMask),C={width:a.width,height:a.height,pixelData:B.resultPixels,minValue:B.minValue,maxValue:a.pixels.maxValue,noDataValue:o};return B.resultMask&&(C.maskData=B.resultMask),g.returnEncodedMask&&a.mask&&(C.encodedMaskData=a.mask.bitset?a.mask.bitset:null),g.returnFileInfo&&(C.fileInfo=t(a),g.computeUsedBitDepths&&(C.fileInfo.bitDepths=i(a))),C}},e=function(A,e,t,i,r){var g,n,a,o=0,B=A.pixels.numBlocksX,C=A.pixels.numBlocksY,Q=Math.floor(A.width/B),E=Math.floor(A.height/C),s=2*A.maxZError,f=Number.MAX_VALUE;t=t||(A.mask?A.mask.bitset:null),n=new e(A.width*A.height),r&&t&&(a=new Uint8Array(A.width*A.height));for(var c,h,l=new Float32Array(Q*E),u=0;u<=C;u++){var w=u!==C?E:A.height%C;if(0!==w)for(var d=0;d<=B;d++){var D=d!==B?Q:A.width%B;if(0!==D){var y,k,p,m,G=u*A.width*E+d*Q,F=A.width-D,S=A.pixels.blocks[o];if(S.encoding<2?(0===S.encoding?y=S.rawData:(I(S.stuffedData,S.bitsPerPixel,S.numValidPixels,S.offset,s,l,A.pixels.maxValue),y=l),k=0):p=2===S.encoding?0:S.offset,t)for(h=0;h<w;h++){for(7&G&&(m=t[G>>3],m<<=7&G),c=0;c<D;c++)7&G||(m=t[G>>3]),128&m?(a&&(a[G]=1),f=f>(g=S.encoding<2?y[k++]:p)?g:f,n[G++]=g):(a&&(a[G]=0),n[G++]=i),m<<=1;G+=F}else if(S.encoding<2)for(h=0;h<w;h++){for(c=0;c<D;c++)f=f>(g=y[k++])?g:f,n[G++]=g;G+=F}else for(f=f>p?p:f,h=0;h<w;h++){for(c=0;c<D;c++)n[G++]=p;G+=F}if(1===S.encoding&&k!==S.numValidPixels)throw"Block and Mask do not match";o++}}}return{resultPixels:n,resultMask:a,minValue:f}},t=function(A){return{fileIdentifierString:A.fileIdentifierString,fileVersion:A.fileVersion,imageType:A.imageType,height:A.height,width:A.width,maxZError:A.maxZError,eofOffset:A.eofOffset,mask:A.mask?{numBlocksX:A.mask.numBlocksX,numBlocksY:A.mask.numBlocksY,numBytes:A.mask.numBytes,maxValue:A.mask.maxValue}:null,pixels:{numBlocksX:A.pixels.numBlocksX,numBlocksY:A.pixels.numBlocksY,numBytes:A.pixels.numBytes,maxValue:A.pixels.maxValue,noDataValue:A.noDataValue}}},i=function(A){for(var e=A.pixels.numBlocksX*A.pixels.numBlocksY,t={},i=0;i<e;i++){var r=A.pixels.blocks[i];0===r.encoding?t.float32=!0:1===r.encoding?t[r.bitsPerPixel]=!0:t[0]=!0}return Object.keys(t)},r=function(A,e,t){var i={},r=new Uint8Array(A,e,10);if(i.fileIdentifierString=String.fromCharCode.apply(null,r),"CntZImage"!==i.fileIdentifierString.trim())throw"Unexpected file identifier string: "+i.fileIdentifierString;e+=10;var I=new DataView(A,e,24);if(i.fileVersion=I.getInt32(0,!0),i.imageType=I.getInt32(4,!0),i.height=I.getUint32(8,!0),i.width=I.getUint32(12,!0),i.maxZError=I.getFloat64(16,!0),e+=24,!t)if(I=new DataView(A,e,16),i.mask={},i.mask.numBlocksY=I.getUint32(0,!0),i.mask.numBlocksX=I.getUint32(4,!0),i.mask.numBytes=I.getUint32(8,!0),i.mask.maxValue=I.getFloat32(12,!0),e+=16,i.mask.numBytes>0){var g=new Uint8Array(Math.ceil(i.width*i.height/8)),n=(I=new DataView(A,e,i.mask.numBytes)).getInt16(0,!0),a=2,o=0;do{if(n>0)for(;n--;)g[o++]=I.getUint8(a++);else{var B=I.getUint8(a++);for(n=-n;n--;)g[o++]=B}n=I.getInt16(a,!0),a+=2}while(a<i.mask.numBytes);if(-32768!==n||o<g.length)throw"Unexpected end of mask RLE encoding";i.mask.bitset=g,e+=i.mask.numBytes}else 0==(i.mask.numBytes|i.mask.numBlocksY|i.mask.maxValue)&&(i.mask.bitset=new Uint8Array(Math.ceil(i.width*i.height/8)));I=new DataView(A,e,16),i.pixels={},i.pixels.numBlocksY=I.getUint32(0,!0),i.pixels.numBlocksX=I.getUint32(4,!0),i.pixels.numBytes=I.getUint32(8,!0),i.pixels.maxValue=I.getFloat32(12,!0),e+=16;var C=i.pixels.numBlocksX,Q=i.pixels.numBlocksY,E=C+(i.width%C>0?1:0),s=Q+(i.height%Q>0?1:0);i.pixels.blocks=new Array(E*s);for(var f=0,c=0;c<s;c++)for(var h=0;h<E;h++){var l=0,u=A.byteLength-e;I=new DataView(A,e,Math.min(10,u));var w={};i.pixels.blocks[f++]=w;var d=I.getUint8(0);if(l++,w.encoding=63&d,w.encoding>3)throw"Invalid block encoding ("+w.encoding+")";if(2!==w.encoding){if(0!==d&&2!==d){if(d>>=6,w.offsetType=d,2===d)w.offset=I.getInt8(1),l++;else if(1===d)w.offset=I.getInt16(1,!0),l+=2;else{if(0!==d)throw"Invalid block offset type";w.offset=I.getFloat32(1,!0),l+=4}if(1===w.encoding)if(d=I.getUint8(l),l++,w.bitsPerPixel=63&d,d>>=6,w.numValidPixelsType=d,2===d)w.numValidPixels=I.getUint8(l),l++;else if(1===d)w.numValidPixels=I.getUint16(l,!0),l+=2;else{if(0!==d)throw"Invalid valid pixel count type";w.numValidPixels=I.getUint32(l,!0),l+=4}}var D;if(e+=l,3!==w.encoding)if(0===w.encoding){var y=(i.pixels.numBytes-1)/4;if(y!==Math.floor(y))throw"uncompressed block has invalid length";D=new ArrayBuffer(4*y),new Uint8Array(D).set(new Uint8Array(A,e,4*y));var k=new Float32Array(D);w.rawData=k,e+=4*y}else if(1===w.encoding){var p=Math.ceil(w.numValidPixels*w.bitsPerPixel/8),m=Math.ceil(p/4);D=new ArrayBuffer(4*m),new Uint8Array(D).set(new Uint8Array(A,e,p)),w.stuffedData=new Uint32Array(D),e+=p}}else e++}return i.eofOffset=e,i},I=function(A,e,t,i,r,I,g){var n,a,o,B=(1<<e)-1,C=0,Q=0,E=Math.ceil((g-i)/r),s=4*A.length-Math.ceil(e*t/8);for(A[A.length-1]<<=8*s,n=0;n<t;n++){if(0===Q&&(o=A[C++],Q=32),Q>=e)a=o>>>Q-e&B,Q-=e;else{var f=e-Q;a=(o&B)<<f&B,a+=(o=A[C++])>>>(Q=32-f)}I[n]=a<E?i+a*r:g}return I},A),h=(g=function(A,e,t,i,r,I,g,n){var a,o,B,C,Q,E=(1<<t)-1,s=0,f=0,c=4*A.length-Math.ceil(t*i/8);if(A[A.length-1]<<=8*c,r)for(a=0;a<i;a++)0===f&&(B=A[s++],f=32),f>=t?(o=B>>>f-t&E,f-=t):(o=(B&E)<<(C=t-f)&E,o+=(B=A[s++])>>>(f=32-C)),e[a]=r[o];else for(Q=Math.ceil((n-I)/g),a=0;a<i;a++)0===f&&(B=A[s++],f=32),f>=t?(o=B>>>f-t&E,f-=t):(o=(B&E)<<(C=t-f)&E,o+=(B=A[s++])>>>(f=32-C)),e[a]=o<Q?I+o*g:n},n=function(A,e,t,i,r,I){var g,n=(1<<e)-1,a=0,o=0,B=0,C=0,Q=0,E=[],s=4*A.length-Math.ceil(e*t/8);A[A.length-1]<<=8*s;var f=Math.ceil((I-i)/r);for(o=0;o<t;o++)0===C&&(g=A[a++],C=32),C>=e?(Q=g>>>C-e&n,C-=e):(Q=(g&n)<<(B=e-C)&n,Q+=(g=A[a++])>>>(C=32-B)),E[o]=Q<f?i+Q*r:I;return E.unshift(i),E},a=function(A,e,t,i,r,I,g,n){var a,o,B,C,Q=(1<<t)-1,E=0,s=0,f=0;if(r)for(a=0;a<i;a++)0===s&&(B=A[E++],s=32,f=0),s>=t?(o=B>>>f&Q,s-=t,f+=t):(o=B>>>f&Q,s=32-(C=t-s),o|=((B=A[E++])&(1<<C)-1)<<t-C,f=C),e[a]=r[o];else{var c=Math.ceil((n-I)/g);for(a=0;a<i;a++)0===s&&(B=A[E++],s=32,f=0),s>=t?(o=B>>>f&Q,s-=t,f+=t):(o=B>>>f&Q,s=32-(C=t-s),o|=((B=A[E++])&(1<<C)-1)<<t-C,f=C),e[a]=o<c?I+o*g:n}return e},o=function(A,e,t,i,r,I){var g,n=(1<<e)-1,a=0,o=0,B=0,C=0,Q=0,E=0,s=[],f=Math.ceil((I-i)/r);for(o=0;o<t;o++)0===C&&(g=A[a++],C=32,E=0),C>=e?(Q=g>>>E&n,C-=e,E+=e):(Q=g>>>E&n,C=32-(B=e-C),Q|=((g=A[a++])&(1<<B)-1)<<e-B,E=B),s[o]=Q<f?i+Q*r:I;return s.unshift(i),s},B=function(A,e,t,i){var r,I,g,n,a=(1<<t)-1,o=0,B=0,C=4*A.length-Math.ceil(t*i/8);for(A[A.length-1]<<=8*C,r=0;r<i;r++)0===B&&(g=A[o++],B=32),B>=t?(I=g>>>B-t&a,B-=t):(I=(g&a)<<(n=t-B)&a,I+=(g=A[o++])>>>(B=32-n)),e[r]=I;return e},C=function(A,e,t,i){var r,I,g,n,a=(1<<t)-1,o=0,B=0,C=0;for(r=0;r<i;r++)0===B&&(g=A[o++],B=32,C=0),B>=t?(I=g>>>C&a,B-=t,C+=t):(I=g>>>C&a,B=32-(n=t-B),I|=((g=A[o++])&(1<<n)-1)<<t-n,C=n),e[r]=I;return e},Q={HUFFMAN_LUT_BITS_MAX:12,computeChecksumFletcher32:function(A){for(var e=65535,t=65535,i=A.length,r=Math.floor(i/2),I=0;r;){var g=r>=359?359:r;r-=g;do{e+=A[I++]<<8,t+=e+=A[I++]}while(--g);e=(65535&e)+(e>>>16),t=(65535&t)+(t>>>16)}return 1&i&&(t+=e+=A[I]<<8),((t=(65535&t)+(t>>>16))<<16|(e=(65535&e)+(e>>>16)))>>>0},readHeaderInfo:function(A,e){var t=e.ptr,i=new Uint8Array(A,t,6),r={};if(r.fileIdentifierString=String.fromCharCode.apply(null,i),0!==r.fileIdentifierString.lastIndexOf("Lerc2",0))throw"Unexpected file identifier string (expect Lerc2 ): "+r.fileIdentifierString;t+=6;var I,g=new DataView(A,t,8),n=g.getInt32(0,!0);if(r.fileVersion=n,t+=4,n>=3&&(r.checksum=g.getUint32(4,!0),t+=4),g=new DataView(A,t,12),r.height=g.getUint32(0,!0),r.width=g.getUint32(4,!0),t+=8,n>=4?(r.numDims=g.getUint32(8,!0),t+=4):r.numDims=1,g=new DataView(A,t,40),r.numValidPixel=g.getUint32(0,!0),r.microBlockSize=g.getInt32(4,!0),r.blobSize=g.getInt32(8,!0),r.imageType=g.getInt32(12,!0),r.maxZError=g.getFloat64(16,!0),r.zMin=g.getFloat64(24,!0),r.zMax=g.getFloat64(32,!0),t+=40,e.headerInfo=r,e.ptr=t,n>=3&&(I=n>=4?52:48,this.computeChecksumFletcher32(new Uint8Array(A,t-I,r.blobSize-14))!==r.checksum))throw"Checksum failed.";return!0},checkMinMaxRanges:function(A,e){var t=e.headerInfo,i=this.getDataTypeArray(t.imageType),r=t.numDims*this.getDataTypeSize(t.imageType),I=this.readSubArray(A,e.ptr,i,r),g=this.readSubArray(A,e.ptr+r,i,r);e.ptr+=2*r;var n,a=!0;for(n=0;n<t.numDims;n++)if(I[n]!==g[n]){a=!1;break}return t.minValues=I,t.maxValues=g,a},readSubArray:function(A,e,t,i){var r;if(t===Uint8Array)r=new Uint8Array(A,e,i);else{var I=new ArrayBuffer(i);new Uint8Array(I).set(new Uint8Array(A,e,i)),r=new t(I)}return r},readMask:function(A,e){var t,i,r=e.ptr,I=e.headerInfo,g=I.width*I.height,n=I.numValidPixel,a=new DataView(A,r,4),o={};if(o.numBytes=a.getUint32(0,!0),r+=4,(0===n||g===n)&&0!==o.numBytes)throw"invalid mask";if(0===n)t=new Uint8Array(Math.ceil(g/8)),o.bitset=t,i=new Uint8Array(g),e.pixels.resultMask=i,r+=o.numBytes;else if(o.numBytes>0){t=new Uint8Array(Math.ceil(g/8));var B=(a=new DataView(A,r,o.numBytes)).getInt16(0,!0),C=2,Q=0,E=0;do{if(B>0)for(;B--;)t[Q++]=a.getUint8(C++);else for(E=a.getUint8(C++),B=-B;B--;)t[Q++]=E;B=a.getInt16(C,!0),C+=2}while(C<o.numBytes);if(-32768!==B||Q<t.length)throw"Unexpected end of mask RLE encoding";i=new Uint8Array(g);var s=0,f=0;for(f=0;f<g;f++)7&f?(s=t[f>>3],s<<=7&f):s=t[f>>3],128&s&&(i[f]=1);e.pixels.resultMask=i,o.bitset=t,r+=o.numBytes}return e.ptr=r,e.mask=o,!0},readDataOneSweep:function(A,e,t,i){var r,I=e.ptr,g=e.headerInfo,n=g.numDims,a=g.width*g.height,o=g.imageType,B=g.numValidPixel*Q.getDataTypeSize(o)*n,C=e.pixels.resultMask;if(t===Uint8Array)r=new Uint8Array(A,I,B);else{var E=new ArrayBuffer(B);new Uint8Array(E).set(new Uint8Array(A,I,B)),r=new t(E)}if(r.length===a*n)e.pixels.resultPixels=i?Q.swapDimensionOrder(r,a,n,t,!0):r;else{e.pixels.resultPixels=new t(a*n);var s=0,f=0,c=0,h=0;if(n>1){if(i){for(f=0;f<a;f++)if(C[f])for(h=f,c=0;c<n;c++,h+=a)e.pixels.resultPixels[h]=r[s++]}else for(f=0;f<a;f++)if(C[f])for(h=f*n,c=0;c<n;c++)e.pixels.resultPixels[h+c]=r[s++]}else for(f=0;f<a;f++)C[f]&&(e.pixels.resultPixels[f]=r[s++])}return I+=B,e.ptr=I,!0},readHuffmanTree:function(A,e){var t=this.HUFFMAN_LUT_BITS_MAX,i=new DataView(A,e.ptr,16);if(e.ptr+=16,i.getInt32(0,!0)<2)throw"unsupported Huffman version";var r=i.getInt32(4,!0),I=i.getInt32(8,!0),g=i.getInt32(12,!0);if(I>=g)return!1;var n=new Uint32Array(g-I);Q.decodeBits(A,e,n);var a,o,B,C,s=[];for(a=I;a<g;a++)s[o=a-(a<r?0:r)]={first:n[a-I],second:null};var f=A.byteLength-e.ptr,c=Math.ceil(f/4),h=new ArrayBuffer(4*c);new Uint8Array(h).set(new Uint8Array(A,e.ptr,f));var l,u=new Uint32Array(h),w=0,d=0;for(l=u[0],a=I;a<g;a++)(C=s[o=a-(a<r?0:r)].first)>0&&(s[o].second=l<<w>>>32-C,32-w>=C?32===(w+=C)&&(w=0,l=u[++d]):(w+=C-32,l=u[++d],s[o].second|=l>>>32-w));var D=0,y=0,k=new E;for(a=0;a<s.length;a++)void 0!==s[a]&&(D=Math.max(D,s[a].first));y=D>=t?t:D;var p,m,G,F,S,v=[];for(a=I;a<g;a++)if((C=s[o=a-(a<r?0:r)].first)>0)if(p=[C,o],C<=y)for(m=s[o].second<<y-C,G=1<<y-C,B=0;B<G;B++)v[m|B]=p;else for(m=s[o].second,S=k,F=C-1;F>=0;F--)m>>>F&1?(S.right||(S.right=new E),S=S.right):(S.left||(S.left=new E),S=S.left),0!==F||S.val||(S.val=p[1]);return{decodeLut:v,numBitsLUTQick:y,numBitsLUT:D,tree:k,stuffedData:u,srcPtr:d,bitPos:w}},readHuffman:function(A,e,t,i){var r,I,g,n,a,o,B,C,E,s=e.headerInfo.numDims,f=e.headerInfo.height,c=e.headerInfo.width,h=c*f,l=this.readHuffmanTree(A,e),u=l.decodeLut,w=l.tree,d=l.stuffedData,D=l.srcPtr,y=l.bitPos,k=l.numBitsLUTQick,p=l.numBitsLUT,m=0===e.headerInfo.imageType?128:0,G=e.pixels.resultMask,F=0;y>0&&(D++,y=0);var S,v=d[D],R=1===e.encodeMode,U=new t(h*s),L=U;if(s<2||R){for(S=0;S<s;S++)if(s>1&&(L=new t(U.buffer,h*S,h),F=0),e.headerInfo.numValidPixel===c*f)for(C=0,o=0;o<f;o++)for(B=0;B<c;B++,C++){if(I=0,a=n=v<<y>>>32-k,32-y<k&&(a=n|=d[D+1]>>>64-y-k),u[a])I=u[a][1],y+=u[a][0];else for(a=n=v<<y>>>32-p,32-y<p&&(a=n|=d[D+1]>>>64-y-p),r=w,E=0;E<p;E++)if(!(r=n>>>p-E-1&1?r.right:r.left).left&&!r.right){I=r.val,y=y+E+1;break}y>=32&&(y-=32,v=d[++D]),g=I-m,R?(g+=B>0?F:o>0?L[C-c]:F,g&=255,L[C]=g,F=g):L[C]=g}else for(C=0,o=0;o<f;o++)for(B=0;B<c;B++,C++)if(G[C]){if(I=0,a=n=v<<y>>>32-k,32-y<k&&(a=n|=d[D+1]>>>64-y-k),u[a])I=u[a][1],y+=u[a][0];else for(a=n=v<<y>>>32-p,32-y<p&&(a=n|=d[D+1]>>>64-y-p),r=w,E=0;E<p;E++)if(!(r=n>>>p-E-1&1?r.right:r.left).left&&!r.right){I=r.val,y=y+E+1;break}y>=32&&(y-=32,v=d[++D]),g=I-m,R?(B>0&&G[C-1]?g+=F:o>0&&G[C-c]?g+=L[C-c]:g+=F,g&=255,L[C]=g,F=g):L[C]=g}}else for(C=0,o=0;o<f;o++)for(B=0;B<c;B++)if(C=o*c+B,!G||G[C])for(S=0;S<s;S++,C+=h){if(I=0,a=n=v<<y>>>32-k,32-y<k&&(a=n|=d[D+1]>>>64-y-k),u[a])I=u[a][1],y+=u[a][0];else for(a=n=v<<y>>>32-p,32-y<p&&(a=n|=d[D+1]>>>64-y-p),r=w,E=0;E<p;E++)if(!(r=n>>>p-E-1&1?r.right:r.left).left&&!r.right){I=r.val,y=y+E+1;break}y>=32&&(y-=32,v=d[++D]),g=I-m,L[C]=g}e.ptr=e.ptr+4*(D+1)+(y>0?4:0),e.pixels.resultPixels=U,s>1&&!i&&(e.pixels.resultPixels=Q.swapDimensionOrder(U,h,s,t))},decodeBits:function(A,e,t,i,r){var I=e.headerInfo,Q=I.fileVersion,E=0,s=A.byteLength-e.ptr>=5?5:A.byteLength-e.ptr,f=new DataView(A,e.ptr,s),c=f.getUint8(0);E++;var h=c>>6,l=0===h?4:3-h,u=(32&c)>0,w=31&c,d=0;if(1===l)d=f.getUint8(E),E++;else if(2===l)d=f.getUint16(E,!0),E+=2;else{if(4!==l)throw"Invalid valid pixel count type";d=f.getUint32(E,!0),E+=4}var D,y,k,p,m,G,F,S,v,R=2*I.maxZError,U=I.numDims>1?I.maxValues[r]:I.zMax;if(u){for(e.counter.lut++,S=f.getUint8(E),E++,p=Math.ceil((S-1)*w/8),m=Math.ceil(p/4),y=new ArrayBuffer(4*m),k=new Uint8Array(y),e.ptr+=E,k.set(new Uint8Array(A,e.ptr,p)),F=new Uint32Array(y),e.ptr+=p,v=0;S-1>>>v;)v++;p=Math.ceil(d*v/8),m=Math.ceil(p/4),y=new ArrayBuffer(4*m),(k=new Uint8Array(y)).set(new Uint8Array(A,e.ptr,p)),D=new Uint32Array(y),e.ptr+=p,G=Q>=3?o(F,w,S-1,i,R,U):n(F,w,S-1,i,R,U),Q>=3?a(D,t,v,d,G):g(D,t,v,d,G)}else e.counter.bitstuffer++,v=w,e.ptr+=E,v>0&&(p=Math.ceil(d*v/8),m=Math.ceil(p/4),y=new ArrayBuffer(4*m),(k=new Uint8Array(y)).set(new Uint8Array(A,e.ptr,p)),D=new Uint32Array(y),e.ptr+=p,Q>=3?null==i?C(D,t,v,d):a(D,t,v,d,!1,i,R,U):null==i?B(D,t,v,d):g(D,t,v,d,!1,i,R,U))},readTiles:function(A,e,t,i){var r=e.headerInfo,I=r.width,g=r.height,n=I*g,a=r.microBlockSize,o=r.imageType,B=Q.getDataTypeSize(o),C=Math.ceil(I/a),E=Math.ceil(g/a);e.pixels.numBlocksY=E,e.pixels.numBlocksX=C,e.pixels.ptr=0;var s,f,c,h,l,u,w,d,D,y,k=0,p=0,m=0,G=0,F=0,S=0,v=0,R=0,U=0,L=0,b=0,M=0,N=0,x=0,J=0,q=new t(a*a),Y=g%a||a,K=I%a||a,H=r.numDims,O=e.pixels.resultMask,P=e.pixels.resultPixels,T=r.fileVersion>=5?14:15,V=r.zMax;for(m=0;m<E;m++)for(F=m!==E-1?a:Y,G=0;G<C;G++)for(L=m*I*a+G*a,b=I-(S=G!==C-1?a:K),d=0;d<H;d++){if(H>1?(y=P,L=m*I*a+G*a,P=new t(e.pixels.resultPixels.buffer,n*d*B,n),V=r.maxValues[d]):y=null,v=A.byteLength-e.ptr,f={},J=0,R=(s=new DataView(A,e.ptr,Math.min(10,v))).getUint8(0),J++,D=r.fileVersion>=5?4&R:0,U=R>>6&255,(R>>2&T)!=(G*a>>3&T))throw"integrity issue";if(D&&0===d)throw"integrity issue";if((l=3&R)>3)throw e.ptr+=J,"Invalid block encoding ("+l+")";if(2!==l)if(0===l){if(D)throw"integrity issue";if(e.counter.uncompressed++,e.ptr+=J,M=(M=F*S*B)<(N=A.byteLength-e.ptr)?M:N,c=new ArrayBuffer(M%B==0?M:M+B-M%B),new Uint8Array(c).set(new Uint8Array(A,e.ptr,M)),h=new t(c),x=0,O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=h[x++]),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L++]=h[x++];L+=b}e.ptr+=x*B}else if(u=Q.getDataTypeUsed(D&&o<6?4:o,U),w=Q.getOnePixel(f,J,u,s),J+=Q.getDataTypeSize(u),3===l)if(e.ptr+=J,e.counter.constantoffset++,O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=D?Math.min(V,y[L]+w):w),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L]=D?Math.min(V,y[L]+w):w,L++;L+=b}else if(e.ptr+=J,Q.decodeBits(A,e,q,w,d),J=0,D)if(O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=q[J++]+y[L]),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L]=q[J++]+y[L],L++;L+=b}else if(O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=q[J++]),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L++]=q[J++];L+=b}else{if(D)if(O)for(k=0;k<F;k++)for(p=0;p<S;p++)O[L]&&(P[L]=y[L]),L++;else for(k=0;k<F;k++)for(p=0;p<S;p++)P[L]=y[L],L++;e.counter.constant++,e.ptr+=J}}H>1&&!i&&(e.pixels.resultPixels=Q.swapDimensionOrder(e.pixels.resultPixels,n,H,t))},formatFileInfo:function(A){return{fileIdentifierString:A.headerInfo.fileIdentifierString,fileVersion:A.headerInfo.fileVersion,imageType:A.headerInfo.imageType,height:A.headerInfo.height,width:A.headerInfo.width,numValidPixel:A.headerInfo.numValidPixel,microBlockSize:A.headerInfo.microBlockSize,blobSize:A.headerInfo.blobSize,maxZError:A.headerInfo.maxZError,pixelType:Q.getPixelType(A.headerInfo.imageType),eofOffset:A.eofOffset,mask:A.mask?{numBytes:A.mask.numBytes}:null,pixels:{numBlocksX:A.pixels.numBlocksX,numBlocksY:A.pixels.numBlocksY,maxValue:A.headerInfo.zMax,minValue:A.headerInfo.zMin,noDataValue:A.noDataValue}}},constructConstantSurface:function(A,e){var t=A.headerInfo.zMax,i=A.headerInfo.zMin,r=A.headerInfo.maxValues,I=A.headerInfo.numDims,g=A.headerInfo.height*A.headerInfo.width,n=0,a=0,o=0,B=A.pixels.resultMask,C=A.pixels.resultPixels;if(B)if(I>1){if(e)for(n=0;n<I;n++)for(o=n*g,t=r[n],a=0;a<g;a++)B[a]&&(C[o+a]=t);else for(a=0;a<g;a++)if(B[a])for(o=a*I,n=0;n<I;n++)C[o+I]=r[n]}else for(a=0;a<g;a++)B[a]&&(C[a]=t);else if(I>1&&i!==t)if(e)for(n=0;n<I;n++)for(o=n*g,t=r[n],a=0;a<g;a++)C[o+a]=t;else for(a=0;a<g;a++)for(o=a*I,n=0;n<I;n++)C[o+n]=r[n];else for(a=0;a<g*I;a++)C[a]=t},getDataTypeArray:function(A){var e;switch(A){case 0:e=Int8Array;break;case 1:e=Uint8Array;break;case 2:e=Int16Array;break;case 3:e=Uint16Array;break;case 4:e=Int32Array;break;case 5:e=Uint32Array;break;case 6:default:e=Float32Array;break;case 7:e=Float64Array}return e},getPixelType:function(A){var e;switch(A){case 0:e="S8";break;case 1:e="U8";break;case 2:e="S16";break;case 3:e="U16";break;case 4:e="S32";break;case 5:e="U32";break;case 6:default:e="F32";break;case 7:e="F64"}return e},isValidPixelValue:function(A,e){if(null==e)return!1;var t;switch(A){case 0:t=e>=-128&&e<=127;break;case 1:t=e>=0&&e<=255;break;case 2:t=e>=-32768&&e<=32767;break;case 3:t=e>=0&&e<=65536;break;case 4:t=e>=-2147483648&&e<=2147483647;break;case 5:t=e>=0&&e<=4294967296;break;case 6:t=e>=-34027999387901484e22&&e<=34027999387901484e22;break;case 7:t=e>=-17976931348623157e292&&e<=17976931348623157e292;break;default:t=!1}return t},getDataTypeSize:function(A){var e=0;switch(A){case 0:case 1:e=1;break;case 2:case 3:e=2;break;case 4:case 5:case 6:e=4;break;case 7:e=8;break;default:e=A}return e},getDataTypeUsed:function(A,e){var t=A;switch(A){case 2:case 4:t=A-e;break;case 3:case 5:t=A-2*e;break;case 6:t=0===e?A:1===e?2:1;break;case 7:t=0===e?A:A-2*e+1;break;default:t=A}return t},getOnePixel:function(A,e,t,i){var r=0;switch(t){case 0:r=i.getInt8(e);break;case 1:r=i.getUint8(e);break;case 2:r=i.getInt16(e,!0);break;case 3:r=i.getUint16(e,!0);break;case 4:r=i.getInt32(e,!0);break;case 5:r=i.getUInt32(e,!0);break;case 6:r=i.getFloat32(e,!0);break;case 7:r=i.getFloat64(e,!0);break;default:throw"the decoder does not understand this pixel type"}return r},swapDimensionOrder:function(A,e,t,i,r){var I=0,g=0,n=0,a=0,o=A;if(t>1)if(o=new i(e*t),r)for(I=0;I<e;I++)for(a=I,n=0;n<t;n++,a+=e)o[a]=A[g++];else for(I=0;I<e;I++)for(a=I,n=0;n<t;n++,a+=e)o[g++]=A[a];return o}},E=function(A,e,t){this.val=A,this.left=e,this.right=t},{decode:function(A,e){var t=(e=e||{}).noDataValue,i=0,r={};r.ptr=e.inputOffset||0,r.pixels={},Q.readHeaderInfo(A,r);var I=r.headerInfo,g=I.fileVersion,n=Q.getDataTypeArray(I.imageType);if(g>5)throw"unsupported lerc version 2."+g;Q.readMask(A,r),I.numValidPixel===I.width*I.height||r.pixels.resultMask||(r.pixels.resultMask=e.maskData);var a=I.width*I.height;r.pixels.resultPixels=new n(a*I.numDims),r.counter={onesweep:0,uncompressed:0,lut:0,bitstuffer:0,constant:0,constantoffset:0};var o,B=!e.returnPixelInterleavedDims;if(0!==I.numValidPixel)if(I.zMax===I.zMin)Q.constructConstantSurface(r,B);else if(g>=4&&Q.checkMinMaxRanges(A,r))Q.constructConstantSurface(r,B);else{var C=new DataView(A,r.ptr,2),E=C.getUint8(0);if(r.ptr++,E)Q.readDataOneSweep(A,r,n,B);else if(g>1&&I.imageType<=1&&Math.abs(I.maxZError-.5)<1e-5){var s=C.getUint8(1);if(r.ptr++,r.encodeMode=s,s>2||g<4&&s>1)throw"Invalid Huffman flag "+s;s?Q.readHuffman(A,r,n,B):Q.readTiles(A,r,n,B)}else Q.readTiles(A,r,n,B)}r.eofOffset=r.ptr,e.inputOffset?(o=r.headerInfo.blobSize+e.inputOffset-r.ptr,Math.abs(o)>=1&&(r.eofOffset=e.inputOffset+r.headerInfo.blobSize)):(o=r.headerInfo.blobSize-r.ptr,Math.abs(o)>=1&&(r.eofOffset=r.headerInfo.blobSize));var f={width:I.width,height:I.height,pixelData:r.pixels.resultPixels,minValue:I.zMin,maxValue:I.zMax,validPixelCount:I.numValidPixel,dimCount:I.numDims,dimStats:{minValues:I.minValues,maxValues:I.maxValues},maskData:r.pixels.resultMask};if(r.pixels.resultMask&&Q.isValidPixelValue(I.imageType,t)){var c=r.pixels.resultMask;for(i=0;i<a;i++)c[i]||(f.pixelData[i]=t);f.noDataValue=t}return r.noDataValue=t,e.returnFileInfo&&(f.fileInfo=Q.formatFileInfo(r)),f},getBandCount:function(A){for(var e=0,t=0,i={ptr:0,pixels:{}};t<A.byteLength-58;)Q.readHeaderInfo(A,i),t+=i.headerInfo.blobSize,e++,i.ptr=t;return e}}),l=(s=new ArrayBuffer(4),f=new Uint8Array(s),new Uint32Array(s)[0]=1,1===f[0]),u={decode:function(A,e){if(!l)throw"Big endian system is not supported.";var t,i,r=(e=e||{}).inputOffset||0,I=new Uint8Array(A,r,10),g=String.fromCharCode.apply(null,I);if("CntZImage"===g.trim())t=c,i=1;else{if("Lerc2"!==g.substring(0,5))throw"Unexpected file identifier string: "+g;t=h,i=2}for(var n,a,o,B,C,Q,E=0,s=A.byteLength-10,f=[],u={width:0,height:0,pixels:[],pixelType:e.pixelType,mask:null,statistics:[]},w=0;r<s;){var d=t.decode(A,{inputOffset:r,encodedMaskData:n,maskData:o,returnMask:0===E,returnEncodedMask:0===E,returnFileInfo:!0,returnPixelInterleavedDims:e.returnPixelInterleavedDims,pixelType:e.pixelType||null,noDataValue:e.noDataValue||null});r=d.fileInfo.eofOffset,o=d.maskData,0===E&&(n=d.encodedMaskData,u.width=d.width,u.height=d.height,u.dimCount=d.dimCount||1,u.pixelType=d.pixelType||d.fileInfo.pixelType,u.mask=o),i>1&&(o&&f.push(o),d.fileInfo.mask&&d.fileInfo.mask.numBytes>0&&w++),E++,u.pixels.push(d.pixelData),u.statistics.push({minValue:d.minValue,maxValue:d.maxValue,noDataValue:d.noDataValue,dimStats:d.dimStats})}if(i>1&&w>1){for(Q=u.width*u.height,u.bandMasks=f,(o=new Uint8Array(Q)).set(f[0]),B=1;B<f.length;B++)for(a=f[B],C=0;C<Q;C++)o[C]=o[C]&a[C];u.maskData=o}return u}};TA.exports?TA.exports=u:this.Lerc=u}();var ZA,jA,WA,zA=XA.exports,$A={env:{emscripten_notify_memory_growth:function(A){WA=new Uint8Array(jA.exports.memory.buffer)}}},Ae=function(){function A(){B(this,A)}return Q(A,[{key:"init",value:function(){return ZA||(ZA="undefined"!=typeof fetch?fetch("data:application/wasm;base64,"+ee).then((function(A){return A.arrayBuffer()})).then((function(A){return WebAssembly.instantiate(A,$A)})).then(this._init):WebAssembly.instantiate(Buffer.from(ee,"base64"),$A).then(this._init))}},{key:"_init",value:function(A){jA=A.instance,$A.env.emscripten_notify_memory_growth(0)}},{key:"decode",value:function(A){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!jA)throw new Error("ZSTDDecoder: Await .init() before decoding.");var t=A.byteLength,i=jA.exports.malloc(t);WA.set(A,i),e=e||Number(jA.exports.ZSTD_findDecompressedSize(i,t));var r=jA.exports.malloc(e),I=jA.exports.ZSTD_decompress(r,e,i,t),g=WA.slice(r,r+I);return jA.exports.free(i),jA.exports.free(r),g}}]),A}(),ee="AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ",te={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop",33550:"ModelPixelScale",33922:"ModelTiepoint",34264:"ModelTransformation",34735:"GeoKeyDirectory",34736:"GeoDoubleParams",34737:"GeoAsciiParams",50674:"LercParameters"},ie={};for(var re in te)te.hasOwnProperty(re)&&(ie[te[re]]=parseInt(re,10));ie.BitsPerSample,ie.ExtraSamples,ie.SampleFormat,ie.StripByteCounts,ie.StripOffsets,ie.StripRowCounts,ie.TileByteCounts,ie.TileOffsets,ie.SubIFDs;var Ie={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE",13:"IFD",16:"LONG8",17:"SLONG8",18:"IFD8"},ge={};for(var ne in Ie)Ie.hasOwnProperty(ne)&&(ge[Ie[ne]]=parseInt(ne,10));var ae=1,oe=0,Be=1,Ce=2,Qe={1024:"GTModelTypeGeoKey",1025:"GTRasterTypeGeoKey",1026:"GTCitationGeoKey",2048:"GeographicTypeGeoKey",2049:"GeogCitationGeoKey",2050:"GeogGeodeticDatumGeoKey",2051:"GeogPrimeMeridianGeoKey",2052:"GeogLinearUnitsGeoKey",2053:"GeogLinearUnitSizeGeoKey",2054:"GeogAngularUnitsGeoKey",2055:"GeogAngularUnitSizeGeoKey",2056:"GeogEllipsoidGeoKey",2057:"GeogSemiMajorAxisGeoKey",2058:"GeogSemiMinorAxisGeoKey",2059:"GeogInvFlatteningGeoKey",2060:"GeogAzimuthUnitsGeoKey",2061:"GeogPrimeMeridianLongGeoKey",2062:"GeogTOWGS84GeoKey",3072:"ProjectedCSTypeGeoKey",3073:"PCSCitationGeoKey",3074:"ProjectionGeoKey",3075:"ProjCoordTransGeoKey",3076:"ProjLinearUnitsGeoKey",3077:"ProjLinearUnitSizeGeoKey",3078:"ProjStdParallel1GeoKey",3079:"ProjStdParallel2GeoKey",3080:"ProjNatOriginLongGeoKey",3081:"ProjNatOriginLatGeoKey",3082:"ProjFalseEastingGeoKey",3083:"ProjFalseNorthingGeoKey",3084:"ProjFalseOriginLongGeoKey",3085:"ProjFalseOriginLatGeoKey",3086:"ProjFalseOriginEastingGeoKey",3087:"ProjFalseOriginNorthingGeoKey",3088:"ProjCenterLongGeoKey",3089:"ProjCenterLatGeoKey",3090:"ProjCenterEastingGeoKey",3091:"ProjCenterNorthingGeoKey",3092:"ProjScaleAtNatOriginGeoKey",3093:"ProjScaleAtCenterGeoKey",3094:"ProjAzimuthAngleGeoKey",3095:"ProjStraightVertPoleLongGeoKey",3096:"ProjRectifiedGridAngleGeoKey",4096:"VerticalCSTypeGeoKey",4097:"VerticalCitationGeoKey",4098:"VerticalDatumGeoKey",4099:"VerticalUnitsGeoKey"},Ee={};for(var se in Qe)Qe.hasOwnProperty(se)&&(Ee[Qe[se]]=parseInt(se,10));function fe(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var ce=new Ae,he=function(A){s(t,w);var e=fe(t);function t(A){var i;return B(this,t),(i=e.call(this)).planarConfiguration=void 0!==A.PlanarConfiguration?A.PlanarConfiguration:1,i.samplesPerPixel=void 0!==A.SamplesPerPixel?A.SamplesPerPixel:1,i.addCompression=A.LercParameters[ae],i}return Q(t,[{key:"decodeBlock",value:function(A){switch(this.addCompression){case oe:break;case Be:A=YA(new Uint8Array(A)).buffer;break;case Ce:A=ce.decode(new Uint8Array(A)).buffer;break;default:throw new Error("Unsupported LERC additional compression method identifier: ".concat(this.addCompression))}return zA.decode(A,{returnPixelInterleavedDims:1===this.planarConfiguration}).pixels[0].buffer}}]),t}(),le=Object.freeze({__proto__:null,zstd:ce,default:he});function ue(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var we=function(A){s(I,w);var t,i=ue(I);function I(){var A;if(B(this,I),A=i.call(this),"undefined"==typeof createImageBitmap)throw new Error("Cannot decode WebImage as `createImageBitmap` is not available");if("undefined"==typeof document&&"undefined"==typeof OffscreenCanvas)throw new Error("Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available");return A}return Q(I,[{key:"decode",value:(t=e(r.mark((function A(e,t){var i,I,g,n;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return i=new Blob([t]),A.next=3,createImageBitmap(i);case 3:return I=A.sent,"undefined"!=typeof document?((g=document.createElement("canvas")).width=I.width,g.height=I.height):g=new OffscreenCanvas(I.width,I.height),(n=g.getContext("2d")).drawImage(I,0,0),A.abrupt("return",n.getImageData(0,0,I.width,I.height).data.buffer);case 8:case"end":return A.stop()}}),A)}))),function(A,e){return t.apply(this,arguments)})}]),I}(),de=Object.freeze({__proto__:null,default:we});';
        return new D5t(typeof Buffer != "undefined" ? "data:application/javascript;base64," + Buffer.from(n, "binary").toString("base64") : URL.createObjectURL(new Blob([n], { type: "application/javascript" })));
      }
      const L5t = Object.freeze(Object.defineProperty({ __proto__: null, create: R5t }, Symbol.toStringTag, { value: "Module" }));
      _t.Circle = MA, _t.Geometry = wm, _t.GeometryCollection = wn, _t.LineString = Be, _t.LinearRing = mo, _t.MultiLineString = ui, _t.MultiPoint = fr, _t.MultiPolygon = bi, _t.OlCluster = xb, _t.OlConfig = jL, _t.OlDragRotateAndZoom = Rb, _t.OlDraw = Mb, _t.OlEcharts = VL, _t.OlFeature = fh, _t.OlFullScreen = bb, _t.OlHeatmap = pb, _t.OlImage = CS, _t.OlMap = mC, _t.OlMeasure = Db, _t.OlMousePosition = Bb, _t.OlOverlay = wb, _t.OlOverview = Cb, _t.OlPath = Nb, _t.OlRoute = A2, _t.OlScaleLine = Tb, _t.OlTiff = vb, _t.OlTile = wS, _t.OlVector = m_, _t.OlWebglVector = lb, _t.OlWfs = db, _t.OlWind = gb, _t.OlWms = Ab, _t.OlZoomSlider = Sb, _t.Point = Ge, _t.Polygon = Dn, _t.SimpleGeometry = Oa, _t.configProviderContextKey = z3t, _t.createStyleFunction = NP, _t.default = G3t, _t.defaultOlMapConfig = $I, _t.enumTile = WX, _t.makeInstaller = YX, _t.utils = Gst, Object.defineProperties(_t, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    });
  }
});
export default require_v3_ol_map_umd();
/*! Bundled license information:

v3-ol-map/lib/v3-ol-map.umd.js:
  (*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
  
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
  
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** *)
  (*!
  * ZRender, a high performance 2d drawing library.
  *
  * Copyright (c) 2013, Baidu Inc.
  * All rights reserved.
  *
  * LICENSE
  * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
  *)
  (*!
  * author: sakitam-fdd <smilefdd@gmail.com> 
  * ol-echarts v4.0.1
  * build-time: 2024-5-30 0:2
  * LICENSE: MIT
  * (c) 2017-2024 https://sakitam-fdd.github.io/ol3Echarts
  *)
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
  (* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve *)
*/
//# sourceMappingURL=v3-ol-map.js.map
